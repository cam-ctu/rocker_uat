
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[18:01:55.063] plan(): Setting new future strategy stack:
[18:01:55.063] List of future strategies:
[18:01:55.063] 1. sequential:
[18:01:55.063]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:55.063]    - tweaked: FALSE
[18:01:55.063]    - call: future::plan("sequential")
[18:01:55.091] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[18:01:55.313] plan(): Setting new future strategy stack:
[18:01:55.313] List of future strategies:
[18:01:55.313] 1. sequential:
[18:01:55.313]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:55.313]    - tweaked: FALSE
[18:01:55.313]    - call: plan(strategy)
[18:01:55.336] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[18:01:55.350] future_lapply() ...
[18:01:55.361] Number of chunks: 1
[18:01:55.362] getGlobalsAndPackagesXApply() ...
[18:01:55.362]  - future.globals: TRUE
[18:01:55.364] getGlobalsAndPackages() ...
[18:01:55.364] Searching for globals...
[18:01:55.373] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:01:55.373] Searching for globals ... DONE
[18:01:55.373] Resolving globals: FALSE
[18:01:55.376] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[18:01:55.377] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:55.378] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:55.378] - packages: [1] ‘future.apply’
[18:01:55.378] getGlobalsAndPackages() ... DONE
[18:01:55.378]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:55.379]  - needed namespaces: [n=1] ‘future.apply’
[18:01:55.379] Finding globals ... DONE
[18:01:55.379]  - use_args: TRUE
[18:01:55.379]  - Getting '...' globals ...
[18:01:55.381] resolve() on list ...
[18:01:55.381]  recursive: 0
[18:01:55.381]  length: 1
[18:01:55.382]  elements: ‘...’
[18:01:55.382]  length: 0 (resolved future 1)
[18:01:55.382] resolve() on list ... DONE
[18:01:55.382]    - '...' content: [n=0] 
[18:01:55.383] List of 1
[18:01:55.383]  $ ...: list()
[18:01:55.383]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.383]  - attr(*, "where")=List of 1
[18:01:55.383]   ..$ ...:<environment: 0x6183bfee2088> 
[18:01:55.383]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.383]  - attr(*, "resolved")= logi TRUE
[18:01:55.383]  - attr(*, "total_size")= num NA
[18:01:55.388]  - Getting '...' globals ... DONE
[18:01:55.388] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:55.388] List of 8
[18:01:55.388]  $ ...future.FUN:function (x, ...)  
[18:01:55.388]  $ x_FUN        :function (x)  
[18:01:55.388]  $ times        : int 1
[18:01:55.388]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:55.388]  $ stop_if_not  :function (...)  
[18:01:55.388]  $ dim          : NULL
[18:01:55.388]  $ valid_types  : chr "character"
[18:01:55.388]  $ ...          : list()
[18:01:55.388]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.388]  - attr(*, "where")=List of 8
[18:01:55.388]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:55.388]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:55.388]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:55.388]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:55.388]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:55.388]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:55.388]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:55.388]   ..$ ...          :<environment: 0x6183bfee2088> 
[18:01:55.388]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.388]  - attr(*, "resolved")= logi FALSE
[18:01:55.388]  - attr(*, "total_size")= num 94208
[18:01:55.399] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:55.400] getGlobalsAndPackagesXApply() ... DONE
[18:01:55.400] Number of futures (= number of chunks): 1
[18:01:55.400] Launching 1 futures (chunks) ...
[18:01:55.401] Chunk #1 of 1 ...
[18:01:55.401]  - Finding globals in 'X' for chunk #1 ...
[18:01:55.401] getGlobalsAndPackages() ...
[18:01:55.401] Searching for globals...
[18:01:55.402] 
[18:01:55.402] Searching for globals ... DONE
[18:01:55.402] - globals: [0] <none>
[18:01:55.403] getGlobalsAndPackages() ... DONE
[18:01:55.403]    + additional globals found: [n=0] 
[18:01:55.403]    + additional namespaces needed: [n=0] 
[18:01:55.403]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:55.403]  - seeds: <none>
[18:01:55.404]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.404] getGlobalsAndPackages() ...
[18:01:55.404] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.404] Resolving globals: FALSE
[18:01:55.405] Tweak future expression to call with '...' arguments ...
[18:01:55.405] {
[18:01:55.405]     do.call(function(...) {
[18:01:55.405]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.405]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:55.405]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.405]             on.exit(options(oopts), add = TRUE)
[18:01:55.405]         }
[18:01:55.405]         {
[18:01:55.405]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:55.405]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.405]                 ...future.FUN(...future.X_jj, ...)
[18:01:55.405]             })
[18:01:55.405]         }
[18:01:55.405]     }, args = future.call.arguments)
[18:01:55.405] }
[18:01:55.405] Tweak future expression to call with '...' arguments ... DONE
[18:01:55.406] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.407] - packages: [1] ‘future.apply’
[18:01:55.407] getGlobalsAndPackages() ... DONE
[18:01:55.408] run() for ‘Future’ ...
[18:01:55.408] - state: ‘created’
[18:01:55.409] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:55.410] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:55.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:55.410]   - Field: ‘label’
[18:01:55.410]   - Field: ‘local’
[18:01:55.410]   - Field: ‘owner’
[18:01:55.411]   - Field: ‘envir’
[18:01:55.411]   - Field: ‘packages’
[18:01:55.411]   - Field: ‘gc’
[18:01:55.411]   - Field: ‘conditions’
[18:01:55.411]   - Field: ‘expr’
[18:01:55.412]   - Field: ‘uuid’
[18:01:55.412]   - Field: ‘seed’
[18:01:55.412]   - Field: ‘version’
[18:01:55.412]   - Field: ‘result’
[18:01:55.412]   - Field: ‘asynchronous’
[18:01:55.413]   - Field: ‘calls’
[18:01:55.413]   - Field: ‘globals’
[18:01:55.413]   - Field: ‘stdout’
[18:01:55.413]   - Field: ‘earlySignal’
[18:01:55.413]   - Field: ‘lazy’
[18:01:55.413]   - Field: ‘state’
[18:01:55.414] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:55.414] - Launch lazy future ...
[18:01:55.415] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:55.419] Packages needed by future strategies (n = 0): <none>
[18:01:55.421] {
[18:01:55.421]     {
[18:01:55.421]         {
[18:01:55.421]             ...future.startTime <- base::Sys.time()
[18:01:55.421]             {
[18:01:55.421]                 {
[18:01:55.421]                   {
[18:01:55.421]                     {
[18:01:55.421]                       base::local({
[18:01:55.421]                         has_future <- base::requireNamespace("future", 
[18:01:55.421]                           quietly = TRUE)
[18:01:55.421]                         if (has_future) {
[18:01:55.421]                           ns <- base::getNamespace("future")
[18:01:55.421]                           version <- ns[[".package"]][["version"]]
[18:01:55.421]                           if (is.null(version)) 
[18:01:55.421]                             version <- utils::packageVersion("future")
[18:01:55.421]                         }
[18:01:55.421]                         else {
[18:01:55.421]                           version <- NULL
[18:01:55.421]                         }
[18:01:55.421]                         if (!has_future || version < "1.8.0") {
[18:01:55.421]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:55.421]                             "", base::R.version$version.string), 
[18:01:55.421]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:55.421]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:55.421]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:55.421]                               "release", "version")], collapse = " "), 
[18:01:55.421]                             hostname = base::Sys.info()[["nodename"]])
[18:01:55.421]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:55.421]                             info)
[18:01:55.421]                           info <- base::paste(info, collapse = "; ")
[18:01:55.421]                           if (!has_future) {
[18:01:55.421]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:55.421]                               info)
[18:01:55.421]                           }
[18:01:55.421]                           else {
[18:01:55.421]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:55.421]                               info, version)
[18:01:55.421]                           }
[18:01:55.421]                           base::stop(msg)
[18:01:55.421]                         }
[18:01:55.421]                       })
[18:01:55.421]                     }
[18:01:55.421]                     base::local({
[18:01:55.421]                       for (pkg in "future.apply") {
[18:01:55.421]                         base::loadNamespace(pkg)
[18:01:55.421]                         base::library(pkg, character.only = TRUE)
[18:01:55.421]                       }
[18:01:55.421]                     })
[18:01:55.421]                   }
[18:01:55.421]                   ...future.strategy.old <- future::plan("list")
[18:01:55.421]                   options(future.plan = NULL)
[18:01:55.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:55.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:55.421]                 }
[18:01:55.421]                 ...future.workdir <- getwd()
[18:01:55.421]             }
[18:01:55.421]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:55.421]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:55.421]         }
[18:01:55.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:55.421]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:55.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:55.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:55.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:55.421]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:55.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:55.421]             base::names(...future.oldOptions))
[18:01:55.421]     }
[18:01:55.421]     if (FALSE) {
[18:01:55.421]     }
[18:01:55.421]     else {
[18:01:55.421]         if (TRUE) {
[18:01:55.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:55.421]                 open = "w")
[18:01:55.421]         }
[18:01:55.421]         else {
[18:01:55.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:55.421]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:55.421]         }
[18:01:55.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:55.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:55.421]             base::sink(type = "output", split = FALSE)
[18:01:55.421]             base::close(...future.stdout)
[18:01:55.421]         }, add = TRUE)
[18:01:55.421]     }
[18:01:55.421]     ...future.frame <- base::sys.nframe()
[18:01:55.421]     ...future.conditions <- base::list()
[18:01:55.421]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:55.421]     if (FALSE) {
[18:01:55.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:55.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:55.421]     }
[18:01:55.421]     ...future.result <- base::tryCatch({
[18:01:55.421]         base::withCallingHandlers({
[18:01:55.421]             ...future.value <- base::withVisible(base::local({
[18:01:55.421]                 do.call(function(...) {
[18:01:55.421]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.421]                   if (!identical(...future.globals.maxSize.org, 
[18:01:55.421]                     ...future.globals.maxSize)) {
[18:01:55.421]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.421]                     on.exit(options(oopts), add = TRUE)
[18:01:55.421]                   }
[18:01:55.421]                   {
[18:01:55.421]                     lapply(seq_along(...future.elements_ii), 
[18:01:55.421]                       FUN = function(jj) {
[18:01:55.421]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.421]                         ...future.FUN(...future.X_jj, ...)
[18:01:55.421]                       })
[18:01:55.421]                   }
[18:01:55.421]                 }, args = future.call.arguments)
[18:01:55.421]             }))
[18:01:55.421]             future::FutureResult(value = ...future.value$value, 
[18:01:55.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:55.421]                   ...future.rng), globalenv = if (FALSE) 
[18:01:55.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:55.421]                     ...future.globalenv.names))
[18:01:55.421]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:55.421]         }, condition = base::local({
[18:01:55.421]             c <- base::c
[18:01:55.421]             inherits <- base::inherits
[18:01:55.421]             invokeRestart <- base::invokeRestart
[18:01:55.421]             length <- base::length
[18:01:55.421]             list <- base::list
[18:01:55.421]             seq.int <- base::seq.int
[18:01:55.421]             signalCondition <- base::signalCondition
[18:01:55.421]             sys.calls <- base::sys.calls
[18:01:55.421]             `[[` <- base::`[[`
[18:01:55.421]             `+` <- base::`+`
[18:01:55.421]             `<<-` <- base::`<<-`
[18:01:55.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:55.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:55.421]                   3L)]
[18:01:55.421]             }
[18:01:55.421]             function(cond) {
[18:01:55.421]                 is_error <- inherits(cond, "error")
[18:01:55.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:55.421]                   NULL)
[18:01:55.421]                 if (is_error) {
[18:01:55.421]                   sessionInformation <- function() {
[18:01:55.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:55.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:55.421]                       search = base::search(), system = base::Sys.info())
[18:01:55.421]                   }
[18:01:55.421]                   ...future.conditions[[length(...future.conditions) + 
[18:01:55.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:55.421]                     cond$call), session = sessionInformation(), 
[18:01:55.421]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:55.421]                   signalCondition(cond)
[18:01:55.421]                 }
[18:01:55.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:55.421]                 "immediateCondition"))) {
[18:01:55.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:55.421]                   ...future.conditions[[length(...future.conditions) + 
[18:01:55.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:55.421]                   if (TRUE && !signal) {
[18:01:55.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:55.421]                     {
[18:01:55.421]                       inherits <- base::inherits
[18:01:55.421]                       invokeRestart <- base::invokeRestart
[18:01:55.421]                       is.null <- base::is.null
[18:01:55.421]                       muffled <- FALSE
[18:01:55.421]                       if (inherits(cond, "message")) {
[18:01:55.421]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:55.421]                         if (muffled) 
[18:01:55.421]                           invokeRestart("muffleMessage")
[18:01:55.421]                       }
[18:01:55.421]                       else if (inherits(cond, "warning")) {
[18:01:55.421]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:55.421]                         if (muffled) 
[18:01:55.421]                           invokeRestart("muffleWarning")
[18:01:55.421]                       }
[18:01:55.421]                       else if (inherits(cond, "condition")) {
[18:01:55.421]                         if (!is.null(pattern)) {
[18:01:55.421]                           computeRestarts <- base::computeRestarts
[18:01:55.421]                           grepl <- base::grepl
[18:01:55.421]                           restarts <- computeRestarts(cond)
[18:01:55.421]                           for (restart in restarts) {
[18:01:55.421]                             name <- restart$name
[18:01:55.421]                             if (is.null(name)) 
[18:01:55.421]                               next
[18:01:55.421]                             if (!grepl(pattern, name)) 
[18:01:55.421]                               next
[18:01:55.421]                             invokeRestart(restart)
[18:01:55.421]                             muffled <- TRUE
[18:01:55.421]                             break
[18:01:55.421]                           }
[18:01:55.421]                         }
[18:01:55.421]                       }
[18:01:55.421]                       invisible(muffled)
[18:01:55.421]                     }
[18:01:55.421]                     muffleCondition(cond, pattern = "^muffle")
[18:01:55.421]                   }
[18:01:55.421]                 }
[18:01:55.421]                 else {
[18:01:55.421]                   if (TRUE) {
[18:01:55.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:55.421]                     {
[18:01:55.421]                       inherits <- base::inherits
[18:01:55.421]                       invokeRestart <- base::invokeRestart
[18:01:55.421]                       is.null <- base::is.null
[18:01:55.421]                       muffled <- FALSE
[18:01:55.421]                       if (inherits(cond, "message")) {
[18:01:55.421]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:55.421]                         if (muffled) 
[18:01:55.421]                           invokeRestart("muffleMessage")
[18:01:55.421]                       }
[18:01:55.421]                       else if (inherits(cond, "warning")) {
[18:01:55.421]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:55.421]                         if (muffled) 
[18:01:55.421]                           invokeRestart("muffleWarning")
[18:01:55.421]                       }
[18:01:55.421]                       else if (inherits(cond, "condition")) {
[18:01:55.421]                         if (!is.null(pattern)) {
[18:01:55.421]                           computeRestarts <- base::computeRestarts
[18:01:55.421]                           grepl <- base::grepl
[18:01:55.421]                           restarts <- computeRestarts(cond)
[18:01:55.421]                           for (restart in restarts) {
[18:01:55.421]                             name <- restart$name
[18:01:55.421]                             if (is.null(name)) 
[18:01:55.421]                               next
[18:01:55.421]                             if (!grepl(pattern, name)) 
[18:01:55.421]                               next
[18:01:55.421]                             invokeRestart(restart)
[18:01:55.421]                             muffled <- TRUE
[18:01:55.421]                             break
[18:01:55.421]                           }
[18:01:55.421]                         }
[18:01:55.421]                       }
[18:01:55.421]                       invisible(muffled)
[18:01:55.421]                     }
[18:01:55.421]                     muffleCondition(cond, pattern = "^muffle")
[18:01:55.421]                   }
[18:01:55.421]                 }
[18:01:55.421]             }
[18:01:55.421]         }))
[18:01:55.421]     }, error = function(ex) {
[18:01:55.421]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:55.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:55.421]                 ...future.rng), started = ...future.startTime, 
[18:01:55.421]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:55.421]             version = "1.8"), class = "FutureResult")
[18:01:55.421]     }, finally = {
[18:01:55.421]         if (!identical(...future.workdir, getwd())) 
[18:01:55.421]             setwd(...future.workdir)
[18:01:55.421]         {
[18:01:55.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:55.421]                 ...future.oldOptions$nwarnings <- NULL
[18:01:55.421]             }
[18:01:55.421]             base::options(...future.oldOptions)
[18:01:55.421]             if (.Platform$OS.type == "windows") {
[18:01:55.421]                 old_names <- names(...future.oldEnvVars)
[18:01:55.421]                 envs <- base::Sys.getenv()
[18:01:55.421]                 names <- names(envs)
[18:01:55.421]                 common <- intersect(names, old_names)
[18:01:55.421]                 added <- setdiff(names, old_names)
[18:01:55.421]                 removed <- setdiff(old_names, names)
[18:01:55.421]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:55.421]                   envs[common]]
[18:01:55.421]                 NAMES <- toupper(changed)
[18:01:55.421]                 args <- list()
[18:01:55.421]                 for (kk in seq_along(NAMES)) {
[18:01:55.421]                   name <- changed[[kk]]
[18:01:55.421]                   NAME <- NAMES[[kk]]
[18:01:55.421]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.421]                     next
[18:01:55.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:55.421]                 }
[18:01:55.421]                 NAMES <- toupper(added)
[18:01:55.421]                 for (kk in seq_along(NAMES)) {
[18:01:55.421]                   name <- added[[kk]]
[18:01:55.421]                   NAME <- NAMES[[kk]]
[18:01:55.421]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.421]                     next
[18:01:55.421]                   args[[name]] <- ""
[18:01:55.421]                 }
[18:01:55.421]                 NAMES <- toupper(removed)
[18:01:55.421]                 for (kk in seq_along(NAMES)) {
[18:01:55.421]                   name <- removed[[kk]]
[18:01:55.421]                   NAME <- NAMES[[kk]]
[18:01:55.421]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.421]                     next
[18:01:55.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:55.421]                 }
[18:01:55.421]                 if (length(args) > 0) 
[18:01:55.421]                   base::do.call(base::Sys.setenv, args = args)
[18:01:55.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:55.421]             }
[18:01:55.421]             else {
[18:01:55.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:55.421]             }
[18:01:55.421]             {
[18:01:55.421]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:55.421]                   0L) {
[18:01:55.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:55.421]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:55.421]                   base::options(opts)
[18:01:55.421]                 }
[18:01:55.421]                 {
[18:01:55.421]                   {
[18:01:55.421]                     NULL
[18:01:55.421]                     RNGkind("Mersenne-Twister")
[18:01:55.421]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:55.421]                       inherits = FALSE)
[18:01:55.421]                   }
[18:01:55.421]                   options(future.plan = NULL)
[18:01:55.421]                   if (is.na(NA_character_)) 
[18:01:55.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:55.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:55.421]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:55.421]                     .init = FALSE)
[18:01:55.421]                 }
[18:01:55.421]             }
[18:01:55.421]         }
[18:01:55.421]     })
[18:01:55.421]     if (TRUE) {
[18:01:55.421]         base::sink(type = "output", split = FALSE)
[18:01:55.421]         if (TRUE) {
[18:01:55.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:55.421]         }
[18:01:55.421]         else {
[18:01:55.421]             ...future.result["stdout"] <- base::list(NULL)
[18:01:55.421]         }
[18:01:55.421]         base::close(...future.stdout)
[18:01:55.421]         ...future.stdout <- NULL
[18:01:55.421]     }
[18:01:55.421]     ...future.result$conditions <- ...future.conditions
[18:01:55.421]     ...future.result$finished <- base::Sys.time()
[18:01:55.421]     ...future.result
[18:01:55.421] }
[18:01:55.425] assign_globals() ...
[18:01:55.425] List of 11
[18:01:55.425]  $ ...future.FUN            :function (x, ...)  
[18:01:55.425]  $ x_FUN                    :function (x)  
[18:01:55.425]  $ times                    : int 1
[18:01:55.425]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:55.425]  $ stop_if_not              :function (...)  
[18:01:55.425]  $ dim                      : NULL
[18:01:55.425]  $ valid_types              : chr "character"
[18:01:55.425]  $ future.call.arguments    : list()
[18:01:55.425]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.425]  $ ...future.elements_ii    :List of 2
[18:01:55.425]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[18:01:55.425]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[18:01:55.425]  $ ...future.seeds_ii       : NULL
[18:01:55.425]  $ ...future.globals.maxSize: NULL
[18:01:55.425]  - attr(*, "where")=List of 11
[18:01:55.425]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:55.425]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:55.425]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:55.425]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:55.425]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:55.425]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:55.425]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:55.425]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:55.425]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:55.425]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:55.425]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:55.425]  - attr(*, "resolved")= logi FALSE
[18:01:55.425]  - attr(*, "total_size")= num 94208
[18:01:55.425]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.425]  - attr(*, "already-done")= logi TRUE
[18:01:55.441] - copied ‘...future.FUN’ to environment
[18:01:55.441] - copied ‘x_FUN’ to environment
[18:01:55.442] - copied ‘times’ to environment
[18:01:55.442] - copied ‘stopf’ to environment
[18:01:55.442] - copied ‘stop_if_not’ to environment
[18:01:55.442] - copied ‘dim’ to environment
[18:01:55.442] - copied ‘valid_types’ to environment
[18:01:55.443] - copied ‘future.call.arguments’ to environment
[18:01:55.443] - copied ‘...future.elements_ii’ to environment
[18:01:55.443] - copied ‘...future.seeds_ii’ to environment
[18:01:55.443] - copied ‘...future.globals.maxSize’ to environment
[18:01:55.443] assign_globals() ... done
[18:01:55.444] plan(): Setting new future strategy stack:
[18:01:55.444] List of future strategies:
[18:01:55.444] 1. sequential:
[18:01:55.444]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:55.444]    - tweaked: FALSE
[18:01:55.444]    - call: NULL
[18:01:55.445] plan(): nbrOfWorkers() = 1
[18:01:55.448] plan(): Setting new future strategy stack:
[18:01:55.448] List of future strategies:
[18:01:55.448] 1. sequential:
[18:01:55.448]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:55.448]    - tweaked: FALSE
[18:01:55.448]    - call: plan(strategy)
[18:01:55.449] plan(): nbrOfWorkers() = 1
[18:01:55.449] SequentialFuture started (and completed)
[18:01:55.450] - Launch lazy future ... done
[18:01:55.450] run() for ‘SequentialFuture’ ... done
[18:01:55.450] Created future:
[18:01:55.451] SequentialFuture:
[18:01:55.451] Label: ‘future_vapply-1’
[18:01:55.451] Expression:
[18:01:55.451] {
[18:01:55.451]     do.call(function(...) {
[18:01:55.451]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.451]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:55.451]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.451]             on.exit(options(oopts), add = TRUE)
[18:01:55.451]         }
[18:01:55.451]         {
[18:01:55.451]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:55.451]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.451]                 ...future.FUN(...future.X_jj, ...)
[18:01:55.451]             })
[18:01:55.451]         }
[18:01:55.451]     }, args = future.call.arguments)
[18:01:55.451] }
[18:01:55.451] Lazy evaluation: FALSE
[18:01:55.451] Asynchronous evaluation: FALSE
[18:01:55.451] Local evaluation: TRUE
[18:01:55.451] Environment: R_GlobalEnv
[18:01:55.451] Capture standard output: TRUE
[18:01:55.451] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:55.451] Globals: 11 objects totaling 92.81 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:55.451] Packages: 1 packages (‘future.apply’)
[18:01:55.451] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:55.451] Resolved: TRUE
[18:01:55.451] Value: 232 bytes of class ‘list’
[18:01:55.451] Early signaling: FALSE
[18:01:55.451] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:55.451] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:55.454] Chunk #1 of 1 ... DONE
[18:01:55.454] Launching 1 futures (chunks) ... DONE
[18:01:55.454] Resolving 1 futures (chunks) ...
[18:01:55.454] resolve() on list ...
[18:01:55.454]  recursive: 0
[18:01:55.455]  length: 1
[18:01:55.455] 
[18:01:55.455] resolved() for ‘SequentialFuture’ ...
[18:01:55.455] - state: ‘finished’
[18:01:55.456] - run: TRUE
[18:01:55.456] - result: ‘FutureResult’
[18:01:55.456] resolved() for ‘SequentialFuture’ ... done
[18:01:55.456] Future #1
[18:01:55.457] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:55.457] - nx: 1
[18:01:55.457] - relay: TRUE
[18:01:55.457] - stdout: TRUE
[18:01:55.458] - signal: TRUE
[18:01:55.458] - resignal: FALSE
[18:01:55.458] - force: TRUE
[18:01:55.458] - relayed: [n=1] FALSE
[18:01:55.458] - queued futures: [n=1] FALSE
[18:01:55.459]  - until=1
[18:01:55.459]  - relaying element #1
[18:01:55.459] - relayed: [n=1] TRUE
[18:01:55.459] - queued futures: [n=1] TRUE
[18:01:55.460] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:55.460]  length: 0 (resolved future 1)
[18:01:55.460] Relaying remaining futures
[18:01:55.460] signalConditionsASAP(NULL, pos=0) ...
[18:01:55.461] - nx: 1
[18:01:55.461] - relay: TRUE
[18:01:55.461] - stdout: TRUE
[18:01:55.461] - signal: TRUE
[18:01:55.461] - resignal: FALSE
[18:01:55.461] - force: TRUE
[18:01:55.462] - relayed: [n=1] TRUE
[18:01:55.462] - queued futures: [n=1] TRUE
 - flush all
[18:01:55.462] - relayed: [n=1] TRUE
[18:01:55.462] - queued futures: [n=1] TRUE
[18:01:55.462] signalConditionsASAP(NULL, pos=0) ... done
[18:01:55.463] resolve() on list ... DONE
[18:01:55.463]  - Number of value chunks collected: 1
[18:01:55.463] Resolving 1 futures (chunks) ... DONE
[18:01:55.463] Reducing values from 1 chunks ...
[18:01:55.464]  - Number of values collected after concatenation: 2
[18:01:55.464]  - Number of values expected: 2
[18:01:55.464] Reducing values from 1 chunks ... DONE
[18:01:55.464] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[18:01:55.467] future_lapply() ...
[18:01:55.470] Number of chunks: 1
[18:01:55.471] getGlobalsAndPackagesXApply() ...
[18:01:55.471]  - future.globals: TRUE
[18:01:55.471] getGlobalsAndPackages() ...
[18:01:55.471] Searching for globals...
[18:01:55.482] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[18:01:55.483] Searching for globals ... DONE
[18:01:55.483] Resolving globals: FALSE
[18:01:55.485] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[18:01:55.486] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:55.486] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:55.486] - packages: [1] ‘future.apply’
[18:01:55.487] getGlobalsAndPackages() ... DONE
[18:01:55.487]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:55.487]  - needed namespaces: [n=1] ‘future.apply’
[18:01:55.487] Finding globals ... DONE
[18:01:55.488]  - use_args: TRUE
[18:01:55.488]  - Getting '...' globals ...
[18:01:55.488] resolve() on list ...
[18:01:55.489]  recursive: 0
[18:01:55.489]  length: 1
[18:01:55.489]  elements: ‘...’
[18:01:55.489]  length: 0 (resolved future 1)
[18:01:55.489] resolve() on list ... DONE
[18:01:55.490]    - '...' content: [n=0] 
[18:01:55.490] List of 1
[18:01:55.490]  $ ...: list()
[18:01:55.490]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.490]  - attr(*, "where")=List of 1
[18:01:55.490]   ..$ ...:<environment: 0x6183c0d041d8> 
[18:01:55.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.490]  - attr(*, "resolved")= logi TRUE
[18:01:55.490]  - attr(*, "total_size")= num NA
[18:01:55.495]  - Getting '...' globals ... DONE
[18:01:55.495] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:55.496] List of 8
[18:01:55.496]  $ ...future.FUN:function (x, ...)  
[18:01:55.496]  $ x_FUN        :function (x)  
[18:01:55.496]  $ times        : int 0
[18:01:55.496]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:55.496]  $ stop_if_not  :function (...)  
[18:01:55.496]  $ dim          : NULL
[18:01:55.496]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:55.496]  $ ...          : list()
[18:01:55.496]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.496]  - attr(*, "where")=List of 8
[18:01:55.496]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:55.496]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:55.496]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:55.496]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:55.496]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:55.496]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:55.496]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:55.496]   ..$ ...          :<environment: 0x6183c0d041d8> 
[18:01:55.496]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.496]  - attr(*, "resolved")= logi FALSE
[18:01:55.496]  - attr(*, "total_size")= num 95472
[18:01:55.506] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:55.507] getGlobalsAndPackagesXApply() ... DONE
[18:01:55.507] Number of futures (= number of chunks): 1
[18:01:55.507] Launching 1 futures (chunks) ...
[18:01:55.508] Chunk #1 of 1 ...
[18:01:55.508]  - Finding globals in 'X' for chunk #1 ...
[18:01:55.508] getGlobalsAndPackages() ...
[18:01:55.508] Searching for globals...
[18:01:55.509] 
[18:01:55.509] Searching for globals ... DONE
[18:01:55.509] - globals: [0] <none>
[18:01:55.509] getGlobalsAndPackages() ... DONE
[18:01:55.509]    + additional globals found: [n=0] 
[18:01:55.510]    + additional namespaces needed: [n=0] 
[18:01:55.510]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:55.510]  - seeds: <none>
[18:01:55.510]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.510] getGlobalsAndPackages() ...
[18:01:55.511] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.511] Resolving globals: FALSE
[18:01:55.511] Tweak future expression to call with '...' arguments ...
[18:01:55.511] {
[18:01:55.511]     do.call(function(...) {
[18:01:55.511]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.511]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:55.511]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.511]             on.exit(options(oopts), add = TRUE)
[18:01:55.511]         }
[18:01:55.511]         {
[18:01:55.511]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:55.511]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.511]                 ...future.FUN(...future.X_jj, ...)
[18:01:55.511]             })
[18:01:55.511]         }
[18:01:55.511]     }, args = future.call.arguments)
[18:01:55.511] }
[18:01:55.512] Tweak future expression to call with '...' arguments ... DONE
[18:01:55.513] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.513] - packages: [1] ‘future.apply’
[18:01:55.513] getGlobalsAndPackages() ... DONE
[18:01:55.514] run() for ‘Future’ ...
[18:01:55.514] - state: ‘created’
[18:01:55.514] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:55.515] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:55.515] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:55.515]   - Field: ‘label’
[18:01:55.516]   - Field: ‘local’
[18:01:55.516]   - Field: ‘owner’
[18:01:55.516]   - Field: ‘envir’
[18:01:55.516]   - Field: ‘packages’
[18:01:55.516]   - Field: ‘gc’
[18:01:55.517]   - Field: ‘conditions’
[18:01:55.517]   - Field: ‘expr’
[18:01:55.517]   - Field: ‘uuid’
[18:01:55.517]   - Field: ‘seed’
[18:01:55.517]   - Field: ‘version’
[18:01:55.518]   - Field: ‘result’
[18:01:55.518]   - Field: ‘asynchronous’
[18:01:55.518]   - Field: ‘calls’
[18:01:55.518]   - Field: ‘globals’
[18:01:55.518]   - Field: ‘stdout’
[18:01:55.519]   - Field: ‘earlySignal’
[18:01:55.519]   - Field: ‘lazy’
[18:01:55.519]   - Field: ‘state’
[18:01:55.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:55.519] - Launch lazy future ...
[18:01:55.520] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:55.520] Packages needed by future strategies (n = 0): <none>
[18:01:55.521] {
[18:01:55.521]     {
[18:01:55.521]         {
[18:01:55.521]             ...future.startTime <- base::Sys.time()
[18:01:55.521]             {
[18:01:55.521]                 {
[18:01:55.521]                   {
[18:01:55.521]                     {
[18:01:55.521]                       base::local({
[18:01:55.521]                         has_future <- base::requireNamespace("future", 
[18:01:55.521]                           quietly = TRUE)
[18:01:55.521]                         if (has_future) {
[18:01:55.521]                           ns <- base::getNamespace("future")
[18:01:55.521]                           version <- ns[[".package"]][["version"]]
[18:01:55.521]                           if (is.null(version)) 
[18:01:55.521]                             version <- utils::packageVersion("future")
[18:01:55.521]                         }
[18:01:55.521]                         else {
[18:01:55.521]                           version <- NULL
[18:01:55.521]                         }
[18:01:55.521]                         if (!has_future || version < "1.8.0") {
[18:01:55.521]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:55.521]                             "", base::R.version$version.string), 
[18:01:55.521]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:55.521]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:55.521]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:55.521]                               "release", "version")], collapse = " "), 
[18:01:55.521]                             hostname = base::Sys.info()[["nodename"]])
[18:01:55.521]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:55.521]                             info)
[18:01:55.521]                           info <- base::paste(info, collapse = "; ")
[18:01:55.521]                           if (!has_future) {
[18:01:55.521]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:55.521]                               info)
[18:01:55.521]                           }
[18:01:55.521]                           else {
[18:01:55.521]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:55.521]                               info, version)
[18:01:55.521]                           }
[18:01:55.521]                           base::stop(msg)
[18:01:55.521]                         }
[18:01:55.521]                       })
[18:01:55.521]                     }
[18:01:55.521]                     base::local({
[18:01:55.521]                       for (pkg in "future.apply") {
[18:01:55.521]                         base::loadNamespace(pkg)
[18:01:55.521]                         base::library(pkg, character.only = TRUE)
[18:01:55.521]                       }
[18:01:55.521]                     })
[18:01:55.521]                   }
[18:01:55.521]                   ...future.strategy.old <- future::plan("list")
[18:01:55.521]                   options(future.plan = NULL)
[18:01:55.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:55.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:55.521]                 }
[18:01:55.521]                 ...future.workdir <- getwd()
[18:01:55.521]             }
[18:01:55.521]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:55.521]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:55.521]         }
[18:01:55.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:55.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:55.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:55.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:55.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:55.521]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:55.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:55.521]             base::names(...future.oldOptions))
[18:01:55.521]     }
[18:01:55.521]     if (FALSE) {
[18:01:55.521]     }
[18:01:55.521]     else {
[18:01:55.521]         if (TRUE) {
[18:01:55.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:55.521]                 open = "w")
[18:01:55.521]         }
[18:01:55.521]         else {
[18:01:55.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:55.521]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:55.521]         }
[18:01:55.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:55.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:55.521]             base::sink(type = "output", split = FALSE)
[18:01:55.521]             base::close(...future.stdout)
[18:01:55.521]         }, add = TRUE)
[18:01:55.521]     }
[18:01:55.521]     ...future.frame <- base::sys.nframe()
[18:01:55.521]     ...future.conditions <- base::list()
[18:01:55.521]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:55.521]     if (FALSE) {
[18:01:55.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:55.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:55.521]     }
[18:01:55.521]     ...future.result <- base::tryCatch({
[18:01:55.521]         base::withCallingHandlers({
[18:01:55.521]             ...future.value <- base::withVisible(base::local({
[18:01:55.521]                 do.call(function(...) {
[18:01:55.521]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.521]                   if (!identical(...future.globals.maxSize.org, 
[18:01:55.521]                     ...future.globals.maxSize)) {
[18:01:55.521]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.521]                     on.exit(options(oopts), add = TRUE)
[18:01:55.521]                   }
[18:01:55.521]                   {
[18:01:55.521]                     lapply(seq_along(...future.elements_ii), 
[18:01:55.521]                       FUN = function(jj) {
[18:01:55.521]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.521]                         ...future.FUN(...future.X_jj, ...)
[18:01:55.521]                       })
[18:01:55.521]                   }
[18:01:55.521]                 }, args = future.call.arguments)
[18:01:55.521]             }))
[18:01:55.521]             future::FutureResult(value = ...future.value$value, 
[18:01:55.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:55.521]                   ...future.rng), globalenv = if (FALSE) 
[18:01:55.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:55.521]                     ...future.globalenv.names))
[18:01:55.521]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:55.521]         }, condition = base::local({
[18:01:55.521]             c <- base::c
[18:01:55.521]             inherits <- base::inherits
[18:01:55.521]             invokeRestart <- base::invokeRestart
[18:01:55.521]             length <- base::length
[18:01:55.521]             list <- base::list
[18:01:55.521]             seq.int <- base::seq.int
[18:01:55.521]             signalCondition <- base::signalCondition
[18:01:55.521]             sys.calls <- base::sys.calls
[18:01:55.521]             `[[` <- base::`[[`
[18:01:55.521]             `+` <- base::`+`
[18:01:55.521]             `<<-` <- base::`<<-`
[18:01:55.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:55.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:55.521]                   3L)]
[18:01:55.521]             }
[18:01:55.521]             function(cond) {
[18:01:55.521]                 is_error <- inherits(cond, "error")
[18:01:55.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:55.521]                   NULL)
[18:01:55.521]                 if (is_error) {
[18:01:55.521]                   sessionInformation <- function() {
[18:01:55.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:55.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:55.521]                       search = base::search(), system = base::Sys.info())
[18:01:55.521]                   }
[18:01:55.521]                   ...future.conditions[[length(...future.conditions) + 
[18:01:55.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:55.521]                     cond$call), session = sessionInformation(), 
[18:01:55.521]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:55.521]                   signalCondition(cond)
[18:01:55.521]                 }
[18:01:55.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:55.521]                 "immediateCondition"))) {
[18:01:55.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:55.521]                   ...future.conditions[[length(...future.conditions) + 
[18:01:55.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:55.521]                   if (TRUE && !signal) {
[18:01:55.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:55.521]                     {
[18:01:55.521]                       inherits <- base::inherits
[18:01:55.521]                       invokeRestart <- base::invokeRestart
[18:01:55.521]                       is.null <- base::is.null
[18:01:55.521]                       muffled <- FALSE
[18:01:55.521]                       if (inherits(cond, "message")) {
[18:01:55.521]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:55.521]                         if (muffled) 
[18:01:55.521]                           invokeRestart("muffleMessage")
[18:01:55.521]                       }
[18:01:55.521]                       else if (inherits(cond, "warning")) {
[18:01:55.521]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:55.521]                         if (muffled) 
[18:01:55.521]                           invokeRestart("muffleWarning")
[18:01:55.521]                       }
[18:01:55.521]                       else if (inherits(cond, "condition")) {
[18:01:55.521]                         if (!is.null(pattern)) {
[18:01:55.521]                           computeRestarts <- base::computeRestarts
[18:01:55.521]                           grepl <- base::grepl
[18:01:55.521]                           restarts <- computeRestarts(cond)
[18:01:55.521]                           for (restart in restarts) {
[18:01:55.521]                             name <- restart$name
[18:01:55.521]                             if (is.null(name)) 
[18:01:55.521]                               next
[18:01:55.521]                             if (!grepl(pattern, name)) 
[18:01:55.521]                               next
[18:01:55.521]                             invokeRestart(restart)
[18:01:55.521]                             muffled <- TRUE
[18:01:55.521]                             break
[18:01:55.521]                           }
[18:01:55.521]                         }
[18:01:55.521]                       }
[18:01:55.521]                       invisible(muffled)
[18:01:55.521]                     }
[18:01:55.521]                     muffleCondition(cond, pattern = "^muffle")
[18:01:55.521]                   }
[18:01:55.521]                 }
[18:01:55.521]                 else {
[18:01:55.521]                   if (TRUE) {
[18:01:55.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:55.521]                     {
[18:01:55.521]                       inherits <- base::inherits
[18:01:55.521]                       invokeRestart <- base::invokeRestart
[18:01:55.521]                       is.null <- base::is.null
[18:01:55.521]                       muffled <- FALSE
[18:01:55.521]                       if (inherits(cond, "message")) {
[18:01:55.521]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:55.521]                         if (muffled) 
[18:01:55.521]                           invokeRestart("muffleMessage")
[18:01:55.521]                       }
[18:01:55.521]                       else if (inherits(cond, "warning")) {
[18:01:55.521]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:55.521]                         if (muffled) 
[18:01:55.521]                           invokeRestart("muffleWarning")
[18:01:55.521]                       }
[18:01:55.521]                       else if (inherits(cond, "condition")) {
[18:01:55.521]                         if (!is.null(pattern)) {
[18:01:55.521]                           computeRestarts <- base::computeRestarts
[18:01:55.521]                           grepl <- base::grepl
[18:01:55.521]                           restarts <- computeRestarts(cond)
[18:01:55.521]                           for (restart in restarts) {
[18:01:55.521]                             name <- restart$name
[18:01:55.521]                             if (is.null(name)) 
[18:01:55.521]                               next
[18:01:55.521]                             if (!grepl(pattern, name)) 
[18:01:55.521]                               next
[18:01:55.521]                             invokeRestart(restart)
[18:01:55.521]                             muffled <- TRUE
[18:01:55.521]                             break
[18:01:55.521]                           }
[18:01:55.521]                         }
[18:01:55.521]                       }
[18:01:55.521]                       invisible(muffled)
[18:01:55.521]                     }
[18:01:55.521]                     muffleCondition(cond, pattern = "^muffle")
[18:01:55.521]                   }
[18:01:55.521]                 }
[18:01:55.521]             }
[18:01:55.521]         }))
[18:01:55.521]     }, error = function(ex) {
[18:01:55.521]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:55.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:55.521]                 ...future.rng), started = ...future.startTime, 
[18:01:55.521]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:55.521]             version = "1.8"), class = "FutureResult")
[18:01:55.521]     }, finally = {
[18:01:55.521]         if (!identical(...future.workdir, getwd())) 
[18:01:55.521]             setwd(...future.workdir)
[18:01:55.521]         {
[18:01:55.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:55.521]                 ...future.oldOptions$nwarnings <- NULL
[18:01:55.521]             }
[18:01:55.521]             base::options(...future.oldOptions)
[18:01:55.521]             if (.Platform$OS.type == "windows") {
[18:01:55.521]                 old_names <- names(...future.oldEnvVars)
[18:01:55.521]                 envs <- base::Sys.getenv()
[18:01:55.521]                 names <- names(envs)
[18:01:55.521]                 common <- intersect(names, old_names)
[18:01:55.521]                 added <- setdiff(names, old_names)
[18:01:55.521]                 removed <- setdiff(old_names, names)
[18:01:55.521]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:55.521]                   envs[common]]
[18:01:55.521]                 NAMES <- toupper(changed)
[18:01:55.521]                 args <- list()
[18:01:55.521]                 for (kk in seq_along(NAMES)) {
[18:01:55.521]                   name <- changed[[kk]]
[18:01:55.521]                   NAME <- NAMES[[kk]]
[18:01:55.521]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.521]                     next
[18:01:55.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:55.521]                 }
[18:01:55.521]                 NAMES <- toupper(added)
[18:01:55.521]                 for (kk in seq_along(NAMES)) {
[18:01:55.521]                   name <- added[[kk]]
[18:01:55.521]                   NAME <- NAMES[[kk]]
[18:01:55.521]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.521]                     next
[18:01:55.521]                   args[[name]] <- ""
[18:01:55.521]                 }
[18:01:55.521]                 NAMES <- toupper(removed)
[18:01:55.521]                 for (kk in seq_along(NAMES)) {
[18:01:55.521]                   name <- removed[[kk]]
[18:01:55.521]                   NAME <- NAMES[[kk]]
[18:01:55.521]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.521]                     next
[18:01:55.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:55.521]                 }
[18:01:55.521]                 if (length(args) > 0) 
[18:01:55.521]                   base::do.call(base::Sys.setenv, args = args)
[18:01:55.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:55.521]             }
[18:01:55.521]             else {
[18:01:55.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:55.521]             }
[18:01:55.521]             {
[18:01:55.521]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:55.521]                   0L) {
[18:01:55.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:55.521]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:55.521]                   base::options(opts)
[18:01:55.521]                 }
[18:01:55.521]                 {
[18:01:55.521]                   {
[18:01:55.521]                     NULL
[18:01:55.521]                     RNGkind("Mersenne-Twister")
[18:01:55.521]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:55.521]                       inherits = FALSE)
[18:01:55.521]                   }
[18:01:55.521]                   options(future.plan = NULL)
[18:01:55.521]                   if (is.na(NA_character_)) 
[18:01:55.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:55.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:55.521]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:55.521]                     .init = FALSE)
[18:01:55.521]                 }
[18:01:55.521]             }
[18:01:55.521]         }
[18:01:55.521]     })
[18:01:55.521]     if (TRUE) {
[18:01:55.521]         base::sink(type = "output", split = FALSE)
[18:01:55.521]         if (TRUE) {
[18:01:55.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:55.521]         }
[18:01:55.521]         else {
[18:01:55.521]             ...future.result["stdout"] <- base::list(NULL)
[18:01:55.521]         }
[18:01:55.521]         base::close(...future.stdout)
[18:01:55.521]         ...future.stdout <- NULL
[18:01:55.521]     }
[18:01:55.521]     ...future.result$conditions <- ...future.conditions
[18:01:55.521]     ...future.result$finished <- base::Sys.time()
[18:01:55.521]     ...future.result
[18:01:55.521] }
[18:01:55.524] assign_globals() ...
[18:01:55.524] List of 11
[18:01:55.524]  $ ...future.FUN            :function (x, ...)  
[18:01:55.524]  $ x_FUN                    :function (x)  
[18:01:55.524]  $ times                    : int 0
[18:01:55.524]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:55.524]  $ stop_if_not              :function (...)  
[18:01:55.524]  $ dim                      : NULL
[18:01:55.524]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:55.524]  $ future.call.arguments    : list()
[18:01:55.524]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.524]  $ ...future.elements_ii    :List of 10
[18:01:55.524]   ..$ : int 1
[18:01:55.524]   ..$ : int 2
[18:01:55.524]   ..$ : int 3
[18:01:55.524]   ..$ : int 4
[18:01:55.524]   ..$ : int 5
[18:01:55.524]   ..$ : int 6
[18:01:55.524]   ..$ : int 7
[18:01:55.524]   ..$ : int 8
[18:01:55.524]   ..$ : int 9
[18:01:55.524]   ..$ : int 10
[18:01:55.524]  $ ...future.seeds_ii       : NULL
[18:01:55.524]  $ ...future.globals.maxSize: NULL
[18:01:55.524]  - attr(*, "where")=List of 11
[18:01:55.524]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:55.524]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:55.524]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:55.524]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:55.524]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:55.524]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:55.524]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:55.524]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:55.524]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:55.524]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:55.524]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:55.524]  - attr(*, "resolved")= logi FALSE
[18:01:55.524]  - attr(*, "total_size")= num 95472
[18:01:55.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.524]  - attr(*, "already-done")= logi TRUE
[18:01:55.547] - copied ‘...future.FUN’ to environment
[18:01:55.547] - reassign environment for ‘x_FUN’
[18:01:55.548] - copied ‘x_FUN’ to environment
[18:01:55.548] - copied ‘times’ to environment
[18:01:55.548] - copied ‘stopf’ to environment
[18:01:55.548] - copied ‘stop_if_not’ to environment
[18:01:55.548] - copied ‘dim’ to environment
[18:01:55.549] - copied ‘valid_types’ to environment
[18:01:55.549] - copied ‘future.call.arguments’ to environment
[18:01:55.549] - copied ‘...future.elements_ii’ to environment
[18:01:55.549] - copied ‘...future.seeds_ii’ to environment
[18:01:55.549] - copied ‘...future.globals.maxSize’ to environment
[18:01:55.550] assign_globals() ... done
[18:01:55.550] plan(): Setting new future strategy stack:
[18:01:55.551] List of future strategies:
[18:01:55.551] 1. sequential:
[18:01:55.551]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:55.551]    - tweaked: FALSE
[18:01:55.551]    - call: NULL
[18:01:55.551] plan(): nbrOfWorkers() = 1
[18:01:55.553] plan(): Setting new future strategy stack:
[18:01:55.553] List of future strategies:
[18:01:55.553] 1. sequential:
[18:01:55.553]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:55.553]    - tweaked: FALSE
[18:01:55.553]    - call: plan(strategy)
[18:01:55.554] plan(): nbrOfWorkers() = 1
[18:01:55.554] SequentialFuture started (and completed)
[18:01:55.555] - Launch lazy future ... done
[18:01:55.555] run() for ‘SequentialFuture’ ... done
[18:01:55.555] Created future:
[18:01:55.555] SequentialFuture:
[18:01:55.555] Label: ‘future_vapply-1’
[18:01:55.555] Expression:
[18:01:55.555] {
[18:01:55.555]     do.call(function(...) {
[18:01:55.555]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.555]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:55.555]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.555]             on.exit(options(oopts), add = TRUE)
[18:01:55.555]         }
[18:01:55.555]         {
[18:01:55.555]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:55.555]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.555]                 ...future.FUN(...future.X_jj, ...)
[18:01:55.555]             })
[18:01:55.555]         }
[18:01:55.555]     }, args = future.call.arguments)
[18:01:55.555] }
[18:01:55.555] Lazy evaluation: FALSE
[18:01:55.555] Asynchronous evaluation: FALSE
[18:01:55.555] Local evaluation: TRUE
[18:01:55.555] Environment: R_GlobalEnv
[18:01:55.555] Capture standard output: TRUE
[18:01:55.555] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:55.555] Globals: 11 objects totaling 93.78 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:55.555] Packages: 1 packages (‘future.apply’)
[18:01:55.555] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:55.555] Resolved: TRUE
[18:01:55.555] Value: 480 bytes of class ‘list’
[18:01:55.555] Early signaling: FALSE
[18:01:55.555] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:55.555] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:55.558] Chunk #1 of 1 ... DONE
[18:01:55.558] Launching 1 futures (chunks) ... DONE
[18:01:55.558] Resolving 1 futures (chunks) ...
[18:01:55.558] resolve() on list ...
[18:01:55.559]  recursive: 0
[18:01:55.559]  length: 1
[18:01:55.559] 
[18:01:55.559] resolved() for ‘SequentialFuture’ ...
[18:01:55.559] - state: ‘finished’
[18:01:55.560] - run: TRUE
[18:01:55.560] - result: ‘FutureResult’
[18:01:55.560] resolved() for ‘SequentialFuture’ ... done
[18:01:55.560] Future #1
[18:01:55.560] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:55.561] - nx: 1
[18:01:55.561] - relay: TRUE
[18:01:55.561] - stdout: TRUE
[18:01:55.561] - signal: TRUE
[18:01:55.561] - resignal: FALSE
[18:01:55.562] - force: TRUE
[18:01:55.562] - relayed: [n=1] FALSE
[18:01:55.562] - queued futures: [n=1] FALSE
[18:01:55.562]  - until=1
[18:01:55.562]  - relaying element #1
[18:01:55.563] - relayed: [n=1] TRUE
[18:01:55.563] - queued futures: [n=1] TRUE
[18:01:55.563] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:55.563]  length: 0 (resolved future 1)
[18:01:55.563] Relaying remaining futures
[18:01:55.564] signalConditionsASAP(NULL, pos=0) ...
[18:01:55.564] - nx: 1
[18:01:55.564] - relay: TRUE
[18:01:55.564] - stdout: TRUE
[18:01:55.564] - signal: TRUE
[18:01:55.565] - resignal: FALSE
[18:01:55.565] - force: TRUE
[18:01:55.565] - relayed: [n=1] TRUE
[18:01:55.565] - queued futures: [n=1] TRUE
 - flush all
[18:01:55.565] - relayed: [n=1] TRUE
[18:01:55.566] - queued futures: [n=1] TRUE
[18:01:55.566] signalConditionsASAP(NULL, pos=0) ... done
[18:01:55.566] resolve() on list ... DONE
[18:01:55.566]  - Number of value chunks collected: 1
[18:01:55.566] Resolving 1 futures (chunks) ... DONE
[18:01:55.567] Reducing values from 1 chunks ...
[18:01:55.567]  - Number of values collected after concatenation: 10
[18:01:55.567]  - Number of values expected: 10
[18:01:55.567] Reducing values from 1 chunks ... DONE
[18:01:55.567] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[18:01:55.569] future_lapply() ...
[18:01:55.573] Number of chunks: 1
[18:01:55.573] getGlobalsAndPackagesXApply() ...
[18:01:55.573]  - future.globals: TRUE
[18:01:55.573] getGlobalsAndPackages() ...
[18:01:55.573] Searching for globals...
[18:01:55.583] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[18:01:55.583] Searching for globals ... DONE
[18:01:55.583] Resolving globals: FALSE
[18:01:55.585] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[18:01:55.586] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:55.586] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:55.586] - packages: [1] ‘future.apply’
[18:01:55.587] getGlobalsAndPackages() ... DONE
[18:01:55.587]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:55.587]  - needed namespaces: [n=1] ‘future.apply’
[18:01:55.587] Finding globals ... DONE
[18:01:55.587]  - use_args: TRUE
[18:01:55.588]  - Getting '...' globals ...
[18:01:55.588] resolve() on list ...
[18:01:55.588]  recursive: 0
[18:01:55.589]  length: 1
[18:01:55.589]  elements: ‘...’
[18:01:55.589]  length: 0 (resolved future 1)
[18:01:55.589] resolve() on list ... DONE
[18:01:55.589]    - '...' content: [n=0] 
[18:01:55.590] List of 1
[18:01:55.590]  $ ...: list()
[18:01:55.590]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.590]  - attr(*, "where")=List of 1
[18:01:55.590]   ..$ ...:<environment: 0x6183c0d04c58> 
[18:01:55.590]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.590]  - attr(*, "resolved")= logi TRUE
[18:01:55.590]  - attr(*, "total_size")= num NA
[18:01:55.595]  - Getting '...' globals ... DONE
[18:01:55.595] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:55.595] List of 8
[18:01:55.595]  $ ...future.FUN:function (x, ...)  
[18:01:55.595]  $ x_FUN        :function (x)  
[18:01:55.595]  $ times        : int 0
[18:01:55.595]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:55.595]  $ stop_if_not  :function (...)  
[18:01:55.595]  $ dim          : NULL
[18:01:55.595]  $ valid_types  : chr [1:2] "logical" "integer"
[18:01:55.595]  $ ...          : list()
[18:01:55.595]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.595]  - attr(*, "where")=List of 8
[18:01:55.595]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:55.595]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:55.595]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:55.595]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:55.595]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:55.595]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:55.595]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:55.595]   ..$ ...          :<environment: 0x6183c0d04c58> 
[18:01:55.595]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.595]  - attr(*, "resolved")= logi FALSE
[18:01:55.595]  - attr(*, "total_size")= num 95400
[18:01:55.606] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:55.606] getGlobalsAndPackagesXApply() ... DONE
[18:01:55.607] Number of futures (= number of chunks): 1
[18:01:55.607] Launching 1 futures (chunks) ...
[18:01:55.607] Chunk #1 of 1 ...
[18:01:55.607]  - Finding globals in 'X' for chunk #1 ...
[18:01:55.608] getGlobalsAndPackages() ...
[18:01:55.608] Searching for globals...
[18:01:55.608] 
[18:01:55.608] Searching for globals ... DONE
[18:01:55.609] - globals: [0] <none>
[18:01:55.609] getGlobalsAndPackages() ... DONE
[18:01:55.609]    + additional globals found: [n=0] 
[18:01:55.609]    + additional namespaces needed: [n=0] 
[18:01:55.609]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:55.610]  - seeds: <none>
[18:01:55.610]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.610] getGlobalsAndPackages() ...
[18:01:55.610] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.610] Resolving globals: FALSE
[18:01:55.611] Tweak future expression to call with '...' arguments ...
[18:01:55.611] {
[18:01:55.611]     do.call(function(...) {
[18:01:55.611]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.611]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:55.611]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.611]             on.exit(options(oopts), add = TRUE)
[18:01:55.611]         }
[18:01:55.611]         {
[18:01:55.611]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:55.611]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.611]                 ...future.FUN(...future.X_jj, ...)
[18:01:55.611]             })
[18:01:55.611]         }
[18:01:55.611]     }, args = future.call.arguments)
[18:01:55.611] }
[18:01:55.611] Tweak future expression to call with '...' arguments ... DONE
[18:01:55.612] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.613] - packages: [1] ‘future.apply’
[18:01:55.613] getGlobalsAndPackages() ... DONE
[18:01:55.613] run() for ‘Future’ ...
[18:01:55.614] - state: ‘created’
[18:01:55.614] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:55.614] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:55.615] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:55.615]   - Field: ‘label’
[18:01:55.615]   - Field: ‘local’
[18:01:55.615]   - Field: ‘owner’
[18:01:55.616]   - Field: ‘envir’
[18:01:55.616]   - Field: ‘packages’
[18:01:55.616]   - Field: ‘gc’
[18:01:55.616]   - Field: ‘conditions’
[18:01:55.616]   - Field: ‘expr’
[18:01:55.617]   - Field: ‘uuid’
[18:01:55.617]   - Field: ‘seed’
[18:01:55.617]   - Field: ‘version’
[18:01:55.617]   - Field: ‘result’
[18:01:55.617]   - Field: ‘asynchronous’
[18:01:55.617]   - Field: ‘calls’
[18:01:55.618]   - Field: ‘globals’
[18:01:55.618]   - Field: ‘stdout’
[18:01:55.618]   - Field: ‘earlySignal’
[18:01:55.618]   - Field: ‘lazy’
[18:01:55.618]   - Field: ‘state’
[18:01:55.619] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:55.619] - Launch lazy future ...
[18:01:55.619] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:55.619] Packages needed by future strategies (n = 0): <none>
[18:01:55.621] {
[18:01:55.621]     {
[18:01:55.621]         {
[18:01:55.621]             ...future.startTime <- base::Sys.time()
[18:01:55.621]             {
[18:01:55.621]                 {
[18:01:55.621]                   {
[18:01:55.621]                     {
[18:01:55.621]                       base::local({
[18:01:55.621]                         has_future <- base::requireNamespace("future", 
[18:01:55.621]                           quietly = TRUE)
[18:01:55.621]                         if (has_future) {
[18:01:55.621]                           ns <- base::getNamespace("future")
[18:01:55.621]                           version <- ns[[".package"]][["version"]]
[18:01:55.621]                           if (is.null(version)) 
[18:01:55.621]                             version <- utils::packageVersion("future")
[18:01:55.621]                         }
[18:01:55.621]                         else {
[18:01:55.621]                           version <- NULL
[18:01:55.621]                         }
[18:01:55.621]                         if (!has_future || version < "1.8.0") {
[18:01:55.621]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:55.621]                             "", base::R.version$version.string), 
[18:01:55.621]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:55.621]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:55.621]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:55.621]                               "release", "version")], collapse = " "), 
[18:01:55.621]                             hostname = base::Sys.info()[["nodename"]])
[18:01:55.621]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:55.621]                             info)
[18:01:55.621]                           info <- base::paste(info, collapse = "; ")
[18:01:55.621]                           if (!has_future) {
[18:01:55.621]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:55.621]                               info)
[18:01:55.621]                           }
[18:01:55.621]                           else {
[18:01:55.621]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:55.621]                               info, version)
[18:01:55.621]                           }
[18:01:55.621]                           base::stop(msg)
[18:01:55.621]                         }
[18:01:55.621]                       })
[18:01:55.621]                     }
[18:01:55.621]                     base::local({
[18:01:55.621]                       for (pkg in "future.apply") {
[18:01:55.621]                         base::loadNamespace(pkg)
[18:01:55.621]                         base::library(pkg, character.only = TRUE)
[18:01:55.621]                       }
[18:01:55.621]                     })
[18:01:55.621]                   }
[18:01:55.621]                   ...future.strategy.old <- future::plan("list")
[18:01:55.621]                   options(future.plan = NULL)
[18:01:55.621]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:55.621]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:55.621]                 }
[18:01:55.621]                 ...future.workdir <- getwd()
[18:01:55.621]             }
[18:01:55.621]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:55.621]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:55.621]         }
[18:01:55.621]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:55.621]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:55.621]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:55.621]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:55.621]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:55.621]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:55.621]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:55.621]             base::names(...future.oldOptions))
[18:01:55.621]     }
[18:01:55.621]     if (FALSE) {
[18:01:55.621]     }
[18:01:55.621]     else {
[18:01:55.621]         if (TRUE) {
[18:01:55.621]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:55.621]                 open = "w")
[18:01:55.621]         }
[18:01:55.621]         else {
[18:01:55.621]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:55.621]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:55.621]         }
[18:01:55.621]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:55.621]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:55.621]             base::sink(type = "output", split = FALSE)
[18:01:55.621]             base::close(...future.stdout)
[18:01:55.621]         }, add = TRUE)
[18:01:55.621]     }
[18:01:55.621]     ...future.frame <- base::sys.nframe()
[18:01:55.621]     ...future.conditions <- base::list()
[18:01:55.621]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:55.621]     if (FALSE) {
[18:01:55.621]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:55.621]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:55.621]     }
[18:01:55.621]     ...future.result <- base::tryCatch({
[18:01:55.621]         base::withCallingHandlers({
[18:01:55.621]             ...future.value <- base::withVisible(base::local({
[18:01:55.621]                 do.call(function(...) {
[18:01:55.621]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.621]                   if (!identical(...future.globals.maxSize.org, 
[18:01:55.621]                     ...future.globals.maxSize)) {
[18:01:55.621]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.621]                     on.exit(options(oopts), add = TRUE)
[18:01:55.621]                   }
[18:01:55.621]                   {
[18:01:55.621]                     lapply(seq_along(...future.elements_ii), 
[18:01:55.621]                       FUN = function(jj) {
[18:01:55.621]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.621]                         ...future.FUN(...future.X_jj, ...)
[18:01:55.621]                       })
[18:01:55.621]                   }
[18:01:55.621]                 }, args = future.call.arguments)
[18:01:55.621]             }))
[18:01:55.621]             future::FutureResult(value = ...future.value$value, 
[18:01:55.621]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:55.621]                   ...future.rng), globalenv = if (FALSE) 
[18:01:55.621]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:55.621]                     ...future.globalenv.names))
[18:01:55.621]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:55.621]         }, condition = base::local({
[18:01:55.621]             c <- base::c
[18:01:55.621]             inherits <- base::inherits
[18:01:55.621]             invokeRestart <- base::invokeRestart
[18:01:55.621]             length <- base::length
[18:01:55.621]             list <- base::list
[18:01:55.621]             seq.int <- base::seq.int
[18:01:55.621]             signalCondition <- base::signalCondition
[18:01:55.621]             sys.calls <- base::sys.calls
[18:01:55.621]             `[[` <- base::`[[`
[18:01:55.621]             `+` <- base::`+`
[18:01:55.621]             `<<-` <- base::`<<-`
[18:01:55.621]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:55.621]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:55.621]                   3L)]
[18:01:55.621]             }
[18:01:55.621]             function(cond) {
[18:01:55.621]                 is_error <- inherits(cond, "error")
[18:01:55.621]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:55.621]                   NULL)
[18:01:55.621]                 if (is_error) {
[18:01:55.621]                   sessionInformation <- function() {
[18:01:55.621]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:55.621]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:55.621]                       search = base::search(), system = base::Sys.info())
[18:01:55.621]                   }
[18:01:55.621]                   ...future.conditions[[length(...future.conditions) + 
[18:01:55.621]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:55.621]                     cond$call), session = sessionInformation(), 
[18:01:55.621]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:55.621]                   signalCondition(cond)
[18:01:55.621]                 }
[18:01:55.621]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:55.621]                 "immediateCondition"))) {
[18:01:55.621]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:55.621]                   ...future.conditions[[length(...future.conditions) + 
[18:01:55.621]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:55.621]                   if (TRUE && !signal) {
[18:01:55.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:55.621]                     {
[18:01:55.621]                       inherits <- base::inherits
[18:01:55.621]                       invokeRestart <- base::invokeRestart
[18:01:55.621]                       is.null <- base::is.null
[18:01:55.621]                       muffled <- FALSE
[18:01:55.621]                       if (inherits(cond, "message")) {
[18:01:55.621]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:55.621]                         if (muffled) 
[18:01:55.621]                           invokeRestart("muffleMessage")
[18:01:55.621]                       }
[18:01:55.621]                       else if (inherits(cond, "warning")) {
[18:01:55.621]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:55.621]                         if (muffled) 
[18:01:55.621]                           invokeRestart("muffleWarning")
[18:01:55.621]                       }
[18:01:55.621]                       else if (inherits(cond, "condition")) {
[18:01:55.621]                         if (!is.null(pattern)) {
[18:01:55.621]                           computeRestarts <- base::computeRestarts
[18:01:55.621]                           grepl <- base::grepl
[18:01:55.621]                           restarts <- computeRestarts(cond)
[18:01:55.621]                           for (restart in restarts) {
[18:01:55.621]                             name <- restart$name
[18:01:55.621]                             if (is.null(name)) 
[18:01:55.621]                               next
[18:01:55.621]                             if (!grepl(pattern, name)) 
[18:01:55.621]                               next
[18:01:55.621]                             invokeRestart(restart)
[18:01:55.621]                             muffled <- TRUE
[18:01:55.621]                             break
[18:01:55.621]                           }
[18:01:55.621]                         }
[18:01:55.621]                       }
[18:01:55.621]                       invisible(muffled)
[18:01:55.621]                     }
[18:01:55.621]                     muffleCondition(cond, pattern = "^muffle")
[18:01:55.621]                   }
[18:01:55.621]                 }
[18:01:55.621]                 else {
[18:01:55.621]                   if (TRUE) {
[18:01:55.621]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:55.621]                     {
[18:01:55.621]                       inherits <- base::inherits
[18:01:55.621]                       invokeRestart <- base::invokeRestart
[18:01:55.621]                       is.null <- base::is.null
[18:01:55.621]                       muffled <- FALSE
[18:01:55.621]                       if (inherits(cond, "message")) {
[18:01:55.621]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:55.621]                         if (muffled) 
[18:01:55.621]                           invokeRestart("muffleMessage")
[18:01:55.621]                       }
[18:01:55.621]                       else if (inherits(cond, "warning")) {
[18:01:55.621]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:55.621]                         if (muffled) 
[18:01:55.621]                           invokeRestart("muffleWarning")
[18:01:55.621]                       }
[18:01:55.621]                       else if (inherits(cond, "condition")) {
[18:01:55.621]                         if (!is.null(pattern)) {
[18:01:55.621]                           computeRestarts <- base::computeRestarts
[18:01:55.621]                           grepl <- base::grepl
[18:01:55.621]                           restarts <- computeRestarts(cond)
[18:01:55.621]                           for (restart in restarts) {
[18:01:55.621]                             name <- restart$name
[18:01:55.621]                             if (is.null(name)) 
[18:01:55.621]                               next
[18:01:55.621]                             if (!grepl(pattern, name)) 
[18:01:55.621]                               next
[18:01:55.621]                             invokeRestart(restart)
[18:01:55.621]                             muffled <- TRUE
[18:01:55.621]                             break
[18:01:55.621]                           }
[18:01:55.621]                         }
[18:01:55.621]                       }
[18:01:55.621]                       invisible(muffled)
[18:01:55.621]                     }
[18:01:55.621]                     muffleCondition(cond, pattern = "^muffle")
[18:01:55.621]                   }
[18:01:55.621]                 }
[18:01:55.621]             }
[18:01:55.621]         }))
[18:01:55.621]     }, error = function(ex) {
[18:01:55.621]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:55.621]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:55.621]                 ...future.rng), started = ...future.startTime, 
[18:01:55.621]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:55.621]             version = "1.8"), class = "FutureResult")
[18:01:55.621]     }, finally = {
[18:01:55.621]         if (!identical(...future.workdir, getwd())) 
[18:01:55.621]             setwd(...future.workdir)
[18:01:55.621]         {
[18:01:55.621]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:55.621]                 ...future.oldOptions$nwarnings <- NULL
[18:01:55.621]             }
[18:01:55.621]             base::options(...future.oldOptions)
[18:01:55.621]             if (.Platform$OS.type == "windows") {
[18:01:55.621]                 old_names <- names(...future.oldEnvVars)
[18:01:55.621]                 envs <- base::Sys.getenv()
[18:01:55.621]                 names <- names(envs)
[18:01:55.621]                 common <- intersect(names, old_names)
[18:01:55.621]                 added <- setdiff(names, old_names)
[18:01:55.621]                 removed <- setdiff(old_names, names)
[18:01:55.621]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:55.621]                   envs[common]]
[18:01:55.621]                 NAMES <- toupper(changed)
[18:01:55.621]                 args <- list()
[18:01:55.621]                 for (kk in seq_along(NAMES)) {
[18:01:55.621]                   name <- changed[[kk]]
[18:01:55.621]                   NAME <- NAMES[[kk]]
[18:01:55.621]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.621]                     next
[18:01:55.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:55.621]                 }
[18:01:55.621]                 NAMES <- toupper(added)
[18:01:55.621]                 for (kk in seq_along(NAMES)) {
[18:01:55.621]                   name <- added[[kk]]
[18:01:55.621]                   NAME <- NAMES[[kk]]
[18:01:55.621]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.621]                     next
[18:01:55.621]                   args[[name]] <- ""
[18:01:55.621]                 }
[18:01:55.621]                 NAMES <- toupper(removed)
[18:01:55.621]                 for (kk in seq_along(NAMES)) {
[18:01:55.621]                   name <- removed[[kk]]
[18:01:55.621]                   NAME <- NAMES[[kk]]
[18:01:55.621]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.621]                     next
[18:01:55.621]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:55.621]                 }
[18:01:55.621]                 if (length(args) > 0) 
[18:01:55.621]                   base::do.call(base::Sys.setenv, args = args)
[18:01:55.621]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:55.621]             }
[18:01:55.621]             else {
[18:01:55.621]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:55.621]             }
[18:01:55.621]             {
[18:01:55.621]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:55.621]                   0L) {
[18:01:55.621]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:55.621]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:55.621]                   base::options(opts)
[18:01:55.621]                 }
[18:01:55.621]                 {
[18:01:55.621]                   {
[18:01:55.621]                     NULL
[18:01:55.621]                     RNGkind("Mersenne-Twister")
[18:01:55.621]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:55.621]                       inherits = FALSE)
[18:01:55.621]                   }
[18:01:55.621]                   options(future.plan = NULL)
[18:01:55.621]                   if (is.na(NA_character_)) 
[18:01:55.621]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:55.621]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:55.621]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:55.621]                     .init = FALSE)
[18:01:55.621]                 }
[18:01:55.621]             }
[18:01:55.621]         }
[18:01:55.621]     })
[18:01:55.621]     if (TRUE) {
[18:01:55.621]         base::sink(type = "output", split = FALSE)
[18:01:55.621]         if (TRUE) {
[18:01:55.621]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:55.621]         }
[18:01:55.621]         else {
[18:01:55.621]             ...future.result["stdout"] <- base::list(NULL)
[18:01:55.621]         }
[18:01:55.621]         base::close(...future.stdout)
[18:01:55.621]         ...future.stdout <- NULL
[18:01:55.621]     }
[18:01:55.621]     ...future.result$conditions <- ...future.conditions
[18:01:55.621]     ...future.result$finished <- base::Sys.time()
[18:01:55.621]     ...future.result
[18:01:55.621] }
[18:01:55.624] assign_globals() ...
[18:01:55.624] List of 11
[18:01:55.624]  $ ...future.FUN            :function (x, ...)  
[18:01:55.624]  $ x_FUN                    :function (x)  
[18:01:55.624]  $ times                    : int 0
[18:01:55.624]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:55.624]  $ stop_if_not              :function (...)  
[18:01:55.624]  $ dim                      : NULL
[18:01:55.624]  $ valid_types              : chr [1:2] "logical" "integer"
[18:01:55.624]  $ future.call.arguments    : list()
[18:01:55.624]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.624]  $ ...future.elements_ii    :List of 10
[18:01:55.624]   ..$ : int 1
[18:01:55.624]   ..$ : int 2
[18:01:55.624]   ..$ : int 3
[18:01:55.624]   ..$ : int 4
[18:01:55.624]   ..$ : int 5
[18:01:55.624]   ..$ : int 6
[18:01:55.624]   ..$ : int 7
[18:01:55.624]   ..$ : int 8
[18:01:55.624]   ..$ : int 9
[18:01:55.624]   ..$ : int 10
[18:01:55.624]  $ ...future.seeds_ii       : NULL
[18:01:55.624]  $ ...future.globals.maxSize: NULL
[18:01:55.624]  - attr(*, "where")=List of 11
[18:01:55.624]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:55.624]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:55.624]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:55.624]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:55.624]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:55.624]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:55.624]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:55.624]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:55.624]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:55.624]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:55.624]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:55.624]  - attr(*, "resolved")= logi FALSE
[18:01:55.624]  - attr(*, "total_size")= num 95400
[18:01:55.624]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.624]  - attr(*, "already-done")= logi TRUE
[18:01:55.647] - copied ‘...future.FUN’ to environment
[18:01:55.647] - reassign environment for ‘x_FUN’
[18:01:55.647] - copied ‘x_FUN’ to environment
[18:01:55.647] - copied ‘times’ to environment
[18:01:55.648] - copied ‘stopf’ to environment
[18:01:55.648] - copied ‘stop_if_not’ to environment
[18:01:55.648] - copied ‘dim’ to environment
[18:01:55.648] - copied ‘valid_types’ to environment
[18:01:55.648] - copied ‘future.call.arguments’ to environment
[18:01:55.649] - copied ‘...future.elements_ii’ to environment
[18:01:55.649] - copied ‘...future.seeds_ii’ to environment
[18:01:55.649] - copied ‘...future.globals.maxSize’ to environment
[18:01:55.649] assign_globals() ... done
[18:01:55.650] plan(): Setting new future strategy stack:
[18:01:55.650] List of future strategies:
[18:01:55.650] 1. sequential:
[18:01:55.650]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:55.650]    - tweaked: FALSE
[18:01:55.650]    - call: NULL
[18:01:55.651] plan(): nbrOfWorkers() = 1
[18:01:55.653] plan(): Setting new future strategy stack:
[18:01:55.653] List of future strategies:
[18:01:55.653] 1. sequential:
[18:01:55.653]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:55.653]    - tweaked: FALSE
[18:01:55.653]    - call: plan(strategy)
[18:01:55.654] plan(): nbrOfWorkers() = 1
[18:01:55.654] SequentialFuture started (and completed)
[18:01:55.654] - Launch lazy future ... done
[18:01:55.655] run() for ‘SequentialFuture’ ... done
[18:01:55.655] Created future:
[18:01:55.655] SequentialFuture:
[18:01:55.655] Label: ‘future_vapply-1’
[18:01:55.655] Expression:
[18:01:55.655] {
[18:01:55.655]     do.call(function(...) {
[18:01:55.655]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.655]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:55.655]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.655]             on.exit(options(oopts), add = TRUE)
[18:01:55.655]         }
[18:01:55.655]         {
[18:01:55.655]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:55.655]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.655]                 ...future.FUN(...future.X_jj, ...)
[18:01:55.655]             })
[18:01:55.655]         }
[18:01:55.655]     }, args = future.call.arguments)
[18:01:55.655] }
[18:01:55.655] Lazy evaluation: FALSE
[18:01:55.655] Asynchronous evaluation: FALSE
[18:01:55.655] Local evaluation: TRUE
[18:01:55.655] Environment: R_GlobalEnv
[18:01:55.655] Capture standard output: TRUE
[18:01:55.655] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:55.655] Globals: 11 objects totaling 93.71 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:55.655] Packages: 1 packages (‘future.apply’)
[18:01:55.655] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:55.655] Resolved: TRUE
[18:01:55.655] Value: 480 bytes of class ‘list’
[18:01:55.655] Early signaling: FALSE
[18:01:55.655] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:55.655] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:55.657] Chunk #1 of 1 ... DONE
[18:01:55.658] Launching 1 futures (chunks) ... DONE
[18:01:55.658] Resolving 1 futures (chunks) ...
[18:01:55.658] resolve() on list ...
[18:01:55.658]  recursive: 0
[18:01:55.658]  length: 1
[18:01:55.659] 
[18:01:55.659] resolved() for ‘SequentialFuture’ ...
[18:01:55.659] - state: ‘finished’
[18:01:55.659] - run: TRUE
[18:01:55.659] - result: ‘FutureResult’
[18:01:55.660] resolved() for ‘SequentialFuture’ ... done
[18:01:55.660] Future #1
[18:01:55.660] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:55.660] - nx: 1
[18:01:55.660] - relay: TRUE
[18:01:55.661] - stdout: TRUE
[18:01:55.661] - signal: TRUE
[18:01:55.661] - resignal: FALSE
[18:01:55.661] - force: TRUE
[18:01:55.661] - relayed: [n=1] FALSE
[18:01:55.661] - queued futures: [n=1] FALSE
[18:01:55.662]  - until=1
[18:01:55.662]  - relaying element #1
[18:01:55.662] - relayed: [n=1] TRUE
[18:01:55.662] - queued futures: [n=1] TRUE
[18:01:55.663] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:55.663]  length: 0 (resolved future 1)
[18:01:55.663] Relaying remaining futures
[18:01:55.663] signalConditionsASAP(NULL, pos=0) ...
[18:01:55.663] - nx: 1
[18:01:55.664] - relay: TRUE
[18:01:55.664] - stdout: TRUE
[18:01:55.664] - signal: TRUE
[18:01:55.664] - resignal: FALSE
[18:01:55.664] - force: TRUE
[18:01:55.664] - relayed: [n=1] TRUE
[18:01:55.665] - queued futures: [n=1] TRUE
 - flush all
[18:01:55.665] - relayed: [n=1] TRUE
[18:01:55.665] - queued futures: [n=1] TRUE
[18:01:55.665] signalConditionsASAP(NULL, pos=0) ... done
[18:01:55.665] resolve() on list ... DONE
[18:01:55.666]  - Number of value chunks collected: 1
[18:01:55.666] Resolving 1 futures (chunks) ... DONE
[18:01:55.666] Reducing values from 1 chunks ...
[18:01:55.666]  - Number of values collected after concatenation: 10
[18:01:55.667]  - Number of values expected: 10
[18:01:55.667] Reducing values from 1 chunks ... DONE
[18:01:55.667] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[18:01:55.668] future_lapply() ...
[18:01:55.672] Number of chunks: 1
[18:01:55.672] getGlobalsAndPackagesXApply() ...
[18:01:55.672]  - future.globals: TRUE
[18:01:55.673] getGlobalsAndPackages() ...
[18:01:55.673] Searching for globals...
[18:01:55.681] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:01:55.681] Searching for globals ... DONE
[18:01:55.682] Resolving globals: FALSE
[18:01:55.683] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[18:01:55.684] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:55.684] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:55.685] - packages: [1] ‘future.apply’
[18:01:55.685] getGlobalsAndPackages() ... DONE
[18:01:55.685]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:55.685]  - needed namespaces: [n=1] ‘future.apply’
[18:01:55.686] Finding globals ... DONE
[18:01:55.686]  - use_args: TRUE
[18:01:55.686]  - Getting '...' globals ...
[18:01:55.687] resolve() on list ...
[18:01:55.687]  recursive: 0
[18:01:55.687]  length: 1
[18:01:55.687]  elements: ‘...’
[18:01:55.687]  length: 0 (resolved future 1)
[18:01:55.688] resolve() on list ... DONE
[18:01:55.688]    - '...' content: [n=0] 
[18:01:55.688] List of 1
[18:01:55.688]  $ ...: list()
[18:01:55.688]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.688]  - attr(*, "where")=List of 1
[18:01:55.688]   ..$ ...:<environment: 0x6183c0d48a98> 
[18:01:55.688]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.688]  - attr(*, "resolved")= logi TRUE
[18:01:55.688]  - attr(*, "total_size")= num NA
[18:01:55.693]  - Getting '...' globals ... DONE
[18:01:55.694] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:55.694] List of 8
[18:01:55.694]  $ ...future.FUN:function (x, ...)  
[18:01:55.694]  $ x_FUN        :function (x)  
[18:01:55.694]  $ times        : int 1
[18:01:55.694]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:55.694]  $ stop_if_not  :function (...)  
[18:01:55.694]  $ dim          : NULL
[18:01:55.694]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:55.694]  $ ...          : list()
[18:01:55.694]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.694]  - attr(*, "where")=List of 8
[18:01:55.694]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:55.694]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:55.694]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:55.694]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:55.694]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:55.694]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:55.694]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:55.694]   ..$ ...          :<environment: 0x6183c0d48a98> 
[18:01:55.694]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.694]  - attr(*, "resolved")= logi FALSE
[18:01:55.694]  - attr(*, "total_size")= num 94336
[18:01:55.706] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:55.706] getGlobalsAndPackagesXApply() ... DONE
[18:01:55.706] Number of futures (= number of chunks): 1
[18:01:55.707] Launching 1 futures (chunks) ...
[18:01:55.707] Chunk #1 of 1 ...
[18:01:55.707]  - Finding globals in 'X' for chunk #1 ...
[18:01:55.707] getGlobalsAndPackages() ...
[18:01:55.708] Searching for globals...
[18:01:55.708] 
[18:01:55.708] Searching for globals ... DONE
[18:01:55.709] - globals: [0] <none>
[18:01:55.709] getGlobalsAndPackages() ... DONE
[18:01:55.709]    + additional globals found: [n=0] 
[18:01:55.709]    + additional namespaces needed: [n=0] 
[18:01:55.709]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:55.710]  - seeds: <none>
[18:01:55.710]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.710] getGlobalsAndPackages() ...
[18:01:55.710] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.711] Resolving globals: FALSE
[18:01:55.711] Tweak future expression to call with '...' arguments ...
[18:01:55.711] {
[18:01:55.711]     do.call(function(...) {
[18:01:55.711]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.711]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:55.711]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.711]             on.exit(options(oopts), add = TRUE)
[18:01:55.711]         }
[18:01:55.711]         {
[18:01:55.711]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:55.711]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.711]                 ...future.FUN(...future.X_jj, ...)
[18:01:55.711]             })
[18:01:55.711]         }
[18:01:55.711]     }, args = future.call.arguments)
[18:01:55.711] }
[18:01:55.712] Tweak future expression to call with '...' arguments ... DONE
[18:01:55.713] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.713] - packages: [1] ‘future.apply’
[18:01:55.713] getGlobalsAndPackages() ... DONE
[18:01:55.714] run() for ‘Future’ ...
[18:01:55.714] - state: ‘created’
[18:01:55.714] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:55.715] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:55.715] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:55.716]   - Field: ‘label’
[18:01:55.716]   - Field: ‘local’
[18:01:55.716]   - Field: ‘owner’
[18:01:55.716]   - Field: ‘envir’
[18:01:55.716]   - Field: ‘packages’
[18:01:55.717]   - Field: ‘gc’
[18:01:55.717]   - Field: ‘conditions’
[18:01:55.717]   - Field: ‘expr’
[18:01:55.717]   - Field: ‘uuid’
[18:01:55.717]   - Field: ‘seed’
[18:01:55.718]   - Field: ‘version’
[18:01:55.718]   - Field: ‘result’
[18:01:55.718]   - Field: ‘asynchronous’
[18:01:55.718]   - Field: ‘calls’
[18:01:55.718]   - Field: ‘globals’
[18:01:55.719]   - Field: ‘stdout’
[18:01:55.719]   - Field: ‘earlySignal’
[18:01:55.719]   - Field: ‘lazy’
[18:01:55.719]   - Field: ‘state’
[18:01:55.719] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:55.720] - Launch lazy future ...
[18:01:55.720] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:55.720] Packages needed by future strategies (n = 0): <none>
[18:01:55.722] {
[18:01:55.722]     {
[18:01:55.722]         {
[18:01:55.722]             ...future.startTime <- base::Sys.time()
[18:01:55.722]             {
[18:01:55.722]                 {
[18:01:55.722]                   {
[18:01:55.722]                     {
[18:01:55.722]                       base::local({
[18:01:55.722]                         has_future <- base::requireNamespace("future", 
[18:01:55.722]                           quietly = TRUE)
[18:01:55.722]                         if (has_future) {
[18:01:55.722]                           ns <- base::getNamespace("future")
[18:01:55.722]                           version <- ns[[".package"]][["version"]]
[18:01:55.722]                           if (is.null(version)) 
[18:01:55.722]                             version <- utils::packageVersion("future")
[18:01:55.722]                         }
[18:01:55.722]                         else {
[18:01:55.722]                           version <- NULL
[18:01:55.722]                         }
[18:01:55.722]                         if (!has_future || version < "1.8.0") {
[18:01:55.722]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:55.722]                             "", base::R.version$version.string), 
[18:01:55.722]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:55.722]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:55.722]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:55.722]                               "release", "version")], collapse = " "), 
[18:01:55.722]                             hostname = base::Sys.info()[["nodename"]])
[18:01:55.722]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:55.722]                             info)
[18:01:55.722]                           info <- base::paste(info, collapse = "; ")
[18:01:55.722]                           if (!has_future) {
[18:01:55.722]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:55.722]                               info)
[18:01:55.722]                           }
[18:01:55.722]                           else {
[18:01:55.722]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:55.722]                               info, version)
[18:01:55.722]                           }
[18:01:55.722]                           base::stop(msg)
[18:01:55.722]                         }
[18:01:55.722]                       })
[18:01:55.722]                     }
[18:01:55.722]                     base::local({
[18:01:55.722]                       for (pkg in "future.apply") {
[18:01:55.722]                         base::loadNamespace(pkg)
[18:01:55.722]                         base::library(pkg, character.only = TRUE)
[18:01:55.722]                       }
[18:01:55.722]                     })
[18:01:55.722]                   }
[18:01:55.722]                   ...future.strategy.old <- future::plan("list")
[18:01:55.722]                   options(future.plan = NULL)
[18:01:55.722]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:55.722]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:55.722]                 }
[18:01:55.722]                 ...future.workdir <- getwd()
[18:01:55.722]             }
[18:01:55.722]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:55.722]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:55.722]         }
[18:01:55.722]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:55.722]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:55.722]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:55.722]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:55.722]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:55.722]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:55.722]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:55.722]             base::names(...future.oldOptions))
[18:01:55.722]     }
[18:01:55.722]     if (FALSE) {
[18:01:55.722]     }
[18:01:55.722]     else {
[18:01:55.722]         if (TRUE) {
[18:01:55.722]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:55.722]                 open = "w")
[18:01:55.722]         }
[18:01:55.722]         else {
[18:01:55.722]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:55.722]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:55.722]         }
[18:01:55.722]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:55.722]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:55.722]             base::sink(type = "output", split = FALSE)
[18:01:55.722]             base::close(...future.stdout)
[18:01:55.722]         }, add = TRUE)
[18:01:55.722]     }
[18:01:55.722]     ...future.frame <- base::sys.nframe()
[18:01:55.722]     ...future.conditions <- base::list()
[18:01:55.722]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:55.722]     if (FALSE) {
[18:01:55.722]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:55.722]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:55.722]     }
[18:01:55.722]     ...future.result <- base::tryCatch({
[18:01:55.722]         base::withCallingHandlers({
[18:01:55.722]             ...future.value <- base::withVisible(base::local({
[18:01:55.722]                 do.call(function(...) {
[18:01:55.722]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.722]                   if (!identical(...future.globals.maxSize.org, 
[18:01:55.722]                     ...future.globals.maxSize)) {
[18:01:55.722]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.722]                     on.exit(options(oopts), add = TRUE)
[18:01:55.722]                   }
[18:01:55.722]                   {
[18:01:55.722]                     lapply(seq_along(...future.elements_ii), 
[18:01:55.722]                       FUN = function(jj) {
[18:01:55.722]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.722]                         ...future.FUN(...future.X_jj, ...)
[18:01:55.722]                       })
[18:01:55.722]                   }
[18:01:55.722]                 }, args = future.call.arguments)
[18:01:55.722]             }))
[18:01:55.722]             future::FutureResult(value = ...future.value$value, 
[18:01:55.722]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:55.722]                   ...future.rng), globalenv = if (FALSE) 
[18:01:55.722]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:55.722]                     ...future.globalenv.names))
[18:01:55.722]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:55.722]         }, condition = base::local({
[18:01:55.722]             c <- base::c
[18:01:55.722]             inherits <- base::inherits
[18:01:55.722]             invokeRestart <- base::invokeRestart
[18:01:55.722]             length <- base::length
[18:01:55.722]             list <- base::list
[18:01:55.722]             seq.int <- base::seq.int
[18:01:55.722]             signalCondition <- base::signalCondition
[18:01:55.722]             sys.calls <- base::sys.calls
[18:01:55.722]             `[[` <- base::`[[`
[18:01:55.722]             `+` <- base::`+`
[18:01:55.722]             `<<-` <- base::`<<-`
[18:01:55.722]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:55.722]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:55.722]                   3L)]
[18:01:55.722]             }
[18:01:55.722]             function(cond) {
[18:01:55.722]                 is_error <- inherits(cond, "error")
[18:01:55.722]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:55.722]                   NULL)
[18:01:55.722]                 if (is_error) {
[18:01:55.722]                   sessionInformation <- function() {
[18:01:55.722]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:55.722]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:55.722]                       search = base::search(), system = base::Sys.info())
[18:01:55.722]                   }
[18:01:55.722]                   ...future.conditions[[length(...future.conditions) + 
[18:01:55.722]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:55.722]                     cond$call), session = sessionInformation(), 
[18:01:55.722]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:55.722]                   signalCondition(cond)
[18:01:55.722]                 }
[18:01:55.722]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:55.722]                 "immediateCondition"))) {
[18:01:55.722]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:55.722]                   ...future.conditions[[length(...future.conditions) + 
[18:01:55.722]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:55.722]                   if (TRUE && !signal) {
[18:01:55.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:55.722]                     {
[18:01:55.722]                       inherits <- base::inherits
[18:01:55.722]                       invokeRestart <- base::invokeRestart
[18:01:55.722]                       is.null <- base::is.null
[18:01:55.722]                       muffled <- FALSE
[18:01:55.722]                       if (inherits(cond, "message")) {
[18:01:55.722]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:55.722]                         if (muffled) 
[18:01:55.722]                           invokeRestart("muffleMessage")
[18:01:55.722]                       }
[18:01:55.722]                       else if (inherits(cond, "warning")) {
[18:01:55.722]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:55.722]                         if (muffled) 
[18:01:55.722]                           invokeRestart("muffleWarning")
[18:01:55.722]                       }
[18:01:55.722]                       else if (inherits(cond, "condition")) {
[18:01:55.722]                         if (!is.null(pattern)) {
[18:01:55.722]                           computeRestarts <- base::computeRestarts
[18:01:55.722]                           grepl <- base::grepl
[18:01:55.722]                           restarts <- computeRestarts(cond)
[18:01:55.722]                           for (restart in restarts) {
[18:01:55.722]                             name <- restart$name
[18:01:55.722]                             if (is.null(name)) 
[18:01:55.722]                               next
[18:01:55.722]                             if (!grepl(pattern, name)) 
[18:01:55.722]                               next
[18:01:55.722]                             invokeRestart(restart)
[18:01:55.722]                             muffled <- TRUE
[18:01:55.722]                             break
[18:01:55.722]                           }
[18:01:55.722]                         }
[18:01:55.722]                       }
[18:01:55.722]                       invisible(muffled)
[18:01:55.722]                     }
[18:01:55.722]                     muffleCondition(cond, pattern = "^muffle")
[18:01:55.722]                   }
[18:01:55.722]                 }
[18:01:55.722]                 else {
[18:01:55.722]                   if (TRUE) {
[18:01:55.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:55.722]                     {
[18:01:55.722]                       inherits <- base::inherits
[18:01:55.722]                       invokeRestart <- base::invokeRestart
[18:01:55.722]                       is.null <- base::is.null
[18:01:55.722]                       muffled <- FALSE
[18:01:55.722]                       if (inherits(cond, "message")) {
[18:01:55.722]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:55.722]                         if (muffled) 
[18:01:55.722]                           invokeRestart("muffleMessage")
[18:01:55.722]                       }
[18:01:55.722]                       else if (inherits(cond, "warning")) {
[18:01:55.722]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:55.722]                         if (muffled) 
[18:01:55.722]                           invokeRestart("muffleWarning")
[18:01:55.722]                       }
[18:01:55.722]                       else if (inherits(cond, "condition")) {
[18:01:55.722]                         if (!is.null(pattern)) {
[18:01:55.722]                           computeRestarts <- base::computeRestarts
[18:01:55.722]                           grepl <- base::grepl
[18:01:55.722]                           restarts <- computeRestarts(cond)
[18:01:55.722]                           for (restart in restarts) {
[18:01:55.722]                             name <- restart$name
[18:01:55.722]                             if (is.null(name)) 
[18:01:55.722]                               next
[18:01:55.722]                             if (!grepl(pattern, name)) 
[18:01:55.722]                               next
[18:01:55.722]                             invokeRestart(restart)
[18:01:55.722]                             muffled <- TRUE
[18:01:55.722]                             break
[18:01:55.722]                           }
[18:01:55.722]                         }
[18:01:55.722]                       }
[18:01:55.722]                       invisible(muffled)
[18:01:55.722]                     }
[18:01:55.722]                     muffleCondition(cond, pattern = "^muffle")
[18:01:55.722]                   }
[18:01:55.722]                 }
[18:01:55.722]             }
[18:01:55.722]         }))
[18:01:55.722]     }, error = function(ex) {
[18:01:55.722]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:55.722]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:55.722]                 ...future.rng), started = ...future.startTime, 
[18:01:55.722]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:55.722]             version = "1.8"), class = "FutureResult")
[18:01:55.722]     }, finally = {
[18:01:55.722]         if (!identical(...future.workdir, getwd())) 
[18:01:55.722]             setwd(...future.workdir)
[18:01:55.722]         {
[18:01:55.722]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:55.722]                 ...future.oldOptions$nwarnings <- NULL
[18:01:55.722]             }
[18:01:55.722]             base::options(...future.oldOptions)
[18:01:55.722]             if (.Platform$OS.type == "windows") {
[18:01:55.722]                 old_names <- names(...future.oldEnvVars)
[18:01:55.722]                 envs <- base::Sys.getenv()
[18:01:55.722]                 names <- names(envs)
[18:01:55.722]                 common <- intersect(names, old_names)
[18:01:55.722]                 added <- setdiff(names, old_names)
[18:01:55.722]                 removed <- setdiff(old_names, names)
[18:01:55.722]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:55.722]                   envs[common]]
[18:01:55.722]                 NAMES <- toupper(changed)
[18:01:55.722]                 args <- list()
[18:01:55.722]                 for (kk in seq_along(NAMES)) {
[18:01:55.722]                   name <- changed[[kk]]
[18:01:55.722]                   NAME <- NAMES[[kk]]
[18:01:55.722]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.722]                     next
[18:01:55.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:55.722]                 }
[18:01:55.722]                 NAMES <- toupper(added)
[18:01:55.722]                 for (kk in seq_along(NAMES)) {
[18:01:55.722]                   name <- added[[kk]]
[18:01:55.722]                   NAME <- NAMES[[kk]]
[18:01:55.722]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.722]                     next
[18:01:55.722]                   args[[name]] <- ""
[18:01:55.722]                 }
[18:01:55.722]                 NAMES <- toupper(removed)
[18:01:55.722]                 for (kk in seq_along(NAMES)) {
[18:01:55.722]                   name <- removed[[kk]]
[18:01:55.722]                   NAME <- NAMES[[kk]]
[18:01:55.722]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.722]                     next
[18:01:55.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:55.722]                 }
[18:01:55.722]                 if (length(args) > 0) 
[18:01:55.722]                   base::do.call(base::Sys.setenv, args = args)
[18:01:55.722]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:55.722]             }
[18:01:55.722]             else {
[18:01:55.722]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:55.722]             }
[18:01:55.722]             {
[18:01:55.722]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:55.722]                   0L) {
[18:01:55.722]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:55.722]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:55.722]                   base::options(opts)
[18:01:55.722]                 }
[18:01:55.722]                 {
[18:01:55.722]                   {
[18:01:55.722]                     NULL
[18:01:55.722]                     RNGkind("Mersenne-Twister")
[18:01:55.722]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:55.722]                       inherits = FALSE)
[18:01:55.722]                   }
[18:01:55.722]                   options(future.plan = NULL)
[18:01:55.722]                   if (is.na(NA_character_)) 
[18:01:55.722]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:55.722]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:55.722]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:55.722]                     .init = FALSE)
[18:01:55.722]                 }
[18:01:55.722]             }
[18:01:55.722]         }
[18:01:55.722]     })
[18:01:55.722]     if (TRUE) {
[18:01:55.722]         base::sink(type = "output", split = FALSE)
[18:01:55.722]         if (TRUE) {
[18:01:55.722]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:55.722]         }
[18:01:55.722]         else {
[18:01:55.722]             ...future.result["stdout"] <- base::list(NULL)
[18:01:55.722]         }
[18:01:55.722]         base::close(...future.stdout)
[18:01:55.722]         ...future.stdout <- NULL
[18:01:55.722]     }
[18:01:55.722]     ...future.result$conditions <- ...future.conditions
[18:01:55.722]     ...future.result$finished <- base::Sys.time()
[18:01:55.722]     ...future.result
[18:01:55.722] }
[18:01:55.725] assign_globals() ...
[18:01:55.725] List of 11
[18:01:55.725]  $ ...future.FUN            :function (x, ...)  
[18:01:55.725]  $ x_FUN                    :function (x)  
[18:01:55.725]  $ times                    : int 1
[18:01:55.725]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:55.725]  $ stop_if_not              :function (...)  
[18:01:55.725]  $ dim                      : NULL
[18:01:55.725]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:55.725]  $ future.call.arguments    : list()
[18:01:55.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.725]  $ ...future.elements_ii    :List of 10
[18:01:55.725]   ..$ : int 1
[18:01:55.725]   ..$ : int 2
[18:01:55.725]   ..$ : int 3
[18:01:55.725]   ..$ : int 4
[18:01:55.725]   ..$ : int 5
[18:01:55.725]   ..$ : int 6
[18:01:55.725]   ..$ : int 7
[18:01:55.725]   ..$ : int 8
[18:01:55.725]   ..$ : int 9
[18:01:55.725]   ..$ : int 10
[18:01:55.725]  $ ...future.seeds_ii       : NULL
[18:01:55.725]  $ ...future.globals.maxSize: NULL
[18:01:55.725]  - attr(*, "where")=List of 11
[18:01:55.725]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:55.725]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:55.725]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:55.725]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:55.725]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:55.725]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:55.725]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:55.725]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:55.725]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:55.725]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:55.725]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:55.725]  - attr(*, "resolved")= logi FALSE
[18:01:55.725]  - attr(*, "total_size")= num 94336
[18:01:55.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.725]  - attr(*, "already-done")= logi TRUE
[18:01:55.749] - copied ‘...future.FUN’ to environment
[18:01:55.749] - copied ‘x_FUN’ to environment
[18:01:55.749] - copied ‘times’ to environment
[18:01:55.749] - copied ‘stopf’ to environment
[18:01:55.750] - copied ‘stop_if_not’ to environment
[18:01:55.750] - copied ‘dim’ to environment
[18:01:55.750] - copied ‘valid_types’ to environment
[18:01:55.750] - copied ‘future.call.arguments’ to environment
[18:01:55.750] - copied ‘...future.elements_ii’ to environment
[18:01:55.751] - copied ‘...future.seeds_ii’ to environment
[18:01:55.751] - copied ‘...future.globals.maxSize’ to environment
[18:01:55.751] assign_globals() ... done
[18:01:55.752] plan(): Setting new future strategy stack:
[18:01:55.752] List of future strategies:
[18:01:55.752] 1. sequential:
[18:01:55.752]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:55.752]    - tweaked: FALSE
[18:01:55.752]    - call: NULL
[18:01:55.753] plan(): nbrOfWorkers() = 1
[18:01:55.755] plan(): Setting new future strategy stack:
[18:01:55.755] List of future strategies:
[18:01:55.755] 1. sequential:
[18:01:55.755]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:55.755]    - tweaked: FALSE
[18:01:55.755]    - call: plan(strategy)
[18:01:55.756] plan(): nbrOfWorkers() = 1
[18:01:55.757] SequentialFuture started (and completed)
[18:01:55.757] - Launch lazy future ... done
[18:01:55.757] run() for ‘SequentialFuture’ ... done
[18:01:55.757] Created future:
[18:01:55.757] SequentialFuture:
[18:01:55.757] Label: ‘future_vapply-1’
[18:01:55.757] Expression:
[18:01:55.757] {
[18:01:55.757]     do.call(function(...) {
[18:01:55.757]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.757]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:55.757]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.757]             on.exit(options(oopts), add = TRUE)
[18:01:55.757]         }
[18:01:55.757]         {
[18:01:55.757]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:55.757]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.757]                 ...future.FUN(...future.X_jj, ...)
[18:01:55.757]             })
[18:01:55.757]         }
[18:01:55.757]     }, args = future.call.arguments)
[18:01:55.757] }
[18:01:55.757] Lazy evaluation: FALSE
[18:01:55.757] Asynchronous evaluation: FALSE
[18:01:55.757] Local evaluation: TRUE
[18:01:55.757] Environment: R_GlobalEnv
[18:01:55.757] Capture standard output: TRUE
[18:01:55.757] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:55.757] Globals: 11 objects totaling 92.67 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:55.757] Packages: 1 packages (‘future.apply’)
[18:01:55.757] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:55.757] Resolved: TRUE
[18:01:55.757] Value: 560 bytes of class ‘list’
[18:01:55.757] Early signaling: FALSE
[18:01:55.757] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:55.757] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:55.760] Chunk #1 of 1 ... DONE
[18:01:55.760] Launching 1 futures (chunks) ... DONE
[18:01:55.761] Resolving 1 futures (chunks) ...
[18:01:55.761] resolve() on list ...
[18:01:55.761]  recursive: 0
[18:01:55.761]  length: 1
[18:01:55.761] 
[18:01:55.762] resolved() for ‘SequentialFuture’ ...
[18:01:55.762] - state: ‘finished’
[18:01:55.762] - run: TRUE
[18:01:55.762] - result: ‘FutureResult’
[18:01:55.762] resolved() for ‘SequentialFuture’ ... done
[18:01:55.763] Future #1
[18:01:55.763] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:55.763] - nx: 1
[18:01:55.763] - relay: TRUE
[18:01:55.764] - stdout: TRUE
[18:01:55.764] - signal: TRUE
[18:01:55.764] - resignal: FALSE
[18:01:55.764] - force: TRUE
[18:01:55.764] - relayed: [n=1] FALSE
[18:01:55.764] - queued futures: [n=1] FALSE
[18:01:55.765]  - until=1
[18:01:55.765]  - relaying element #1
[18:01:55.765] - relayed: [n=1] TRUE
[18:01:55.766] - queued futures: [n=1] TRUE
[18:01:55.766] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:55.766]  length: 0 (resolved future 1)
[18:01:55.766] Relaying remaining futures
[18:01:55.766] signalConditionsASAP(NULL, pos=0) ...
[18:01:55.767] - nx: 1
[18:01:55.767] - relay: TRUE
[18:01:55.767] - stdout: TRUE
[18:01:55.767] - signal: TRUE
[18:01:55.767] - resignal: FALSE
[18:01:55.767] - force: TRUE
[18:01:55.768] - relayed: [n=1] TRUE
[18:01:55.768] - queued futures: [n=1] TRUE
 - flush all
[18:01:55.768] - relayed: [n=1] TRUE
[18:01:55.768] - queued futures: [n=1] TRUE
[18:01:55.769] signalConditionsASAP(NULL, pos=0) ... done
[18:01:55.769] resolve() on list ... DONE
[18:01:55.769]  - Number of value chunks collected: 1
[18:01:55.769] Resolving 1 futures (chunks) ... DONE
[18:01:55.770] Reducing values from 1 chunks ...
[18:01:55.770]  - Number of values collected after concatenation: 10
[18:01:55.770]  - Number of values expected: 10
[18:01:55.770] Reducing values from 1 chunks ... DONE
[18:01:55.770] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[18:01:55.772] future_lapply() ...
[18:01:55.776] Number of chunks: 1
[18:01:55.776] getGlobalsAndPackagesXApply() ...
[18:01:55.776]  - future.globals: TRUE
[18:01:55.776] getGlobalsAndPackages() ...
[18:01:55.777] Searching for globals...
[18:01:55.787] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[18:01:55.787] Searching for globals ... DONE
[18:01:55.787] Resolving globals: FALSE
[18:01:55.789] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[18:01:55.790] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:55.790] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:55.790] - packages: [1] ‘future.apply’
[18:01:55.791] getGlobalsAndPackages() ... DONE
[18:01:55.791]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:55.791]  - needed namespaces: [n=1] ‘future.apply’
[18:01:55.791] Finding globals ... DONE
[18:01:55.792]  - use_args: TRUE
[18:01:55.792]  - Getting '...' globals ...
[18:01:55.792] resolve() on list ...
[18:01:55.793]  recursive: 0
[18:01:55.793]  length: 1
[18:01:55.793]  elements: ‘...’
[18:01:55.793]  length: 0 (resolved future 1)
[18:01:55.793] resolve() on list ... DONE
[18:01:55.794]    - '...' content: [n=0] 
[18:01:55.794] List of 1
[18:01:55.794]  $ ...: list()
[18:01:55.794]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.794]  - attr(*, "where")=List of 1
[18:01:55.794]   ..$ ...:<environment: 0x6183c0d78bf0> 
[18:01:55.794]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.794]  - attr(*, "resolved")= logi TRUE
[18:01:55.794]  - attr(*, "total_size")= num NA
[18:01:55.799]  - Getting '...' globals ... DONE
[18:01:55.799] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:55.799] List of 8
[18:01:55.799]  $ ...future.FUN:function (x, ...)  
[18:01:55.799]  $ x_FUN        :function (x)  
[18:01:55.799]  $ times        : int 2
[18:01:55.799]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:55.799]  $ stop_if_not  :function (...)  
[18:01:55.799]  $ dim          : NULL
[18:01:55.799]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:55.799]  $ ...          : list()
[18:01:55.799]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.799]  - attr(*, "where")=List of 8
[18:01:55.799]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:55.799]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:55.799]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:55.799]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:55.799]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:55.799]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:55.799]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:55.799]   ..$ ...          :<environment: 0x6183c0d78bf0> 
[18:01:55.799]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.799]  - attr(*, "resolved")= logi FALSE
[18:01:55.799]  - attr(*, "total_size")= num 96456
[18:01:55.810] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:55.810] getGlobalsAndPackagesXApply() ... DONE
[18:01:55.811] Number of futures (= number of chunks): 1
[18:01:55.811] Launching 1 futures (chunks) ...
[18:01:55.811] Chunk #1 of 1 ...
[18:01:55.811]  - Finding globals in 'X' for chunk #1 ...
[18:01:55.812] getGlobalsAndPackages() ...
[18:01:55.812] Searching for globals...
[18:01:55.812] 
[18:01:55.812] Searching for globals ... DONE
[18:01:55.813] - globals: [0] <none>
[18:01:55.813] getGlobalsAndPackages() ... DONE
[18:01:55.813]    + additional globals found: [n=0] 
[18:01:55.813]    + additional namespaces needed: [n=0] 
[18:01:55.813]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:55.814]  - seeds: <none>
[18:01:55.814]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.814] getGlobalsAndPackages() ...
[18:01:55.814] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.814] Resolving globals: FALSE
[18:01:55.815] Tweak future expression to call with '...' arguments ...
[18:01:55.815] {
[18:01:55.815]     do.call(function(...) {
[18:01:55.815]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.815]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:55.815]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.815]             on.exit(options(oopts), add = TRUE)
[18:01:55.815]         }
[18:01:55.815]         {
[18:01:55.815]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:55.815]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.815]                 ...future.FUN(...future.X_jj, ...)
[18:01:55.815]             })
[18:01:55.815]         }
[18:01:55.815]     }, args = future.call.arguments)
[18:01:55.815] }
[18:01:55.815] Tweak future expression to call with '...' arguments ... DONE
[18:01:55.816] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.817] - packages: [1] ‘future.apply’
[18:01:55.817] getGlobalsAndPackages() ... DONE
[18:01:55.818] run() for ‘Future’ ...
[18:01:55.818] - state: ‘created’
[18:01:55.818] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:55.819] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:55.819] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:55.819]   - Field: ‘label’
[18:01:55.819]   - Field: ‘local’
[18:01:55.819]   - Field: ‘owner’
[18:01:55.820]   - Field: ‘envir’
[18:01:55.820]   - Field: ‘packages’
[18:01:55.820]   - Field: ‘gc’
[18:01:55.820]   - Field: ‘conditions’
[18:01:55.820]   - Field: ‘expr’
[18:01:55.821]   - Field: ‘uuid’
[18:01:55.821]   - Field: ‘seed’
[18:01:55.821]   - Field: ‘version’
[18:01:55.821]   - Field: ‘result’
[18:01:55.821]   - Field: ‘asynchronous’
[18:01:55.822]   - Field: ‘calls’
[18:01:55.822]   - Field: ‘globals’
[18:01:55.822]   - Field: ‘stdout’
[18:01:55.822]   - Field: ‘earlySignal’
[18:01:55.822]   - Field: ‘lazy’
[18:01:55.823]   - Field: ‘state’
[18:01:55.823] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:55.823] - Launch lazy future ...
[18:01:55.823] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:55.824] Packages needed by future strategies (n = 0): <none>
[18:01:55.827] {
[18:01:55.827]     {
[18:01:55.827]         {
[18:01:55.827]             ...future.startTime <- base::Sys.time()
[18:01:55.827]             {
[18:01:55.827]                 {
[18:01:55.827]                   {
[18:01:55.827]                     {
[18:01:55.827]                       base::local({
[18:01:55.827]                         has_future <- base::requireNamespace("future", 
[18:01:55.827]                           quietly = TRUE)
[18:01:55.827]                         if (has_future) {
[18:01:55.827]                           ns <- base::getNamespace("future")
[18:01:55.827]                           version <- ns[[".package"]][["version"]]
[18:01:55.827]                           if (is.null(version)) 
[18:01:55.827]                             version <- utils::packageVersion("future")
[18:01:55.827]                         }
[18:01:55.827]                         else {
[18:01:55.827]                           version <- NULL
[18:01:55.827]                         }
[18:01:55.827]                         if (!has_future || version < "1.8.0") {
[18:01:55.827]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:55.827]                             "", base::R.version$version.string), 
[18:01:55.827]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:55.827]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:55.827]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:55.827]                               "release", "version")], collapse = " "), 
[18:01:55.827]                             hostname = base::Sys.info()[["nodename"]])
[18:01:55.827]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:55.827]                             info)
[18:01:55.827]                           info <- base::paste(info, collapse = "; ")
[18:01:55.827]                           if (!has_future) {
[18:01:55.827]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:55.827]                               info)
[18:01:55.827]                           }
[18:01:55.827]                           else {
[18:01:55.827]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:55.827]                               info, version)
[18:01:55.827]                           }
[18:01:55.827]                           base::stop(msg)
[18:01:55.827]                         }
[18:01:55.827]                       })
[18:01:55.827]                     }
[18:01:55.827]                     base::local({
[18:01:55.827]                       for (pkg in "future.apply") {
[18:01:55.827]                         base::loadNamespace(pkg)
[18:01:55.827]                         base::library(pkg, character.only = TRUE)
[18:01:55.827]                       }
[18:01:55.827]                     })
[18:01:55.827]                   }
[18:01:55.827]                   ...future.strategy.old <- future::plan("list")
[18:01:55.827]                   options(future.plan = NULL)
[18:01:55.827]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:55.827]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:55.827]                 }
[18:01:55.827]                 ...future.workdir <- getwd()
[18:01:55.827]             }
[18:01:55.827]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:55.827]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:55.827]         }
[18:01:55.827]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:55.827]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:55.827]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:55.827]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:55.827]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:55.827]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:55.827]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:55.827]             base::names(...future.oldOptions))
[18:01:55.827]     }
[18:01:55.827]     if (FALSE) {
[18:01:55.827]     }
[18:01:55.827]     else {
[18:01:55.827]         if (TRUE) {
[18:01:55.827]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:55.827]                 open = "w")
[18:01:55.827]         }
[18:01:55.827]         else {
[18:01:55.827]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:55.827]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:55.827]         }
[18:01:55.827]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:55.827]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:55.827]             base::sink(type = "output", split = FALSE)
[18:01:55.827]             base::close(...future.stdout)
[18:01:55.827]         }, add = TRUE)
[18:01:55.827]     }
[18:01:55.827]     ...future.frame <- base::sys.nframe()
[18:01:55.827]     ...future.conditions <- base::list()
[18:01:55.827]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:55.827]     if (FALSE) {
[18:01:55.827]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:55.827]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:55.827]     }
[18:01:55.827]     ...future.result <- base::tryCatch({
[18:01:55.827]         base::withCallingHandlers({
[18:01:55.827]             ...future.value <- base::withVisible(base::local({
[18:01:55.827]                 do.call(function(...) {
[18:01:55.827]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.827]                   if (!identical(...future.globals.maxSize.org, 
[18:01:55.827]                     ...future.globals.maxSize)) {
[18:01:55.827]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.827]                     on.exit(options(oopts), add = TRUE)
[18:01:55.827]                   }
[18:01:55.827]                   {
[18:01:55.827]                     lapply(seq_along(...future.elements_ii), 
[18:01:55.827]                       FUN = function(jj) {
[18:01:55.827]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.827]                         ...future.FUN(...future.X_jj, ...)
[18:01:55.827]                       })
[18:01:55.827]                   }
[18:01:55.827]                 }, args = future.call.arguments)
[18:01:55.827]             }))
[18:01:55.827]             future::FutureResult(value = ...future.value$value, 
[18:01:55.827]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:55.827]                   ...future.rng), globalenv = if (FALSE) 
[18:01:55.827]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:55.827]                     ...future.globalenv.names))
[18:01:55.827]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:55.827]         }, condition = base::local({
[18:01:55.827]             c <- base::c
[18:01:55.827]             inherits <- base::inherits
[18:01:55.827]             invokeRestart <- base::invokeRestart
[18:01:55.827]             length <- base::length
[18:01:55.827]             list <- base::list
[18:01:55.827]             seq.int <- base::seq.int
[18:01:55.827]             signalCondition <- base::signalCondition
[18:01:55.827]             sys.calls <- base::sys.calls
[18:01:55.827]             `[[` <- base::`[[`
[18:01:55.827]             `+` <- base::`+`
[18:01:55.827]             `<<-` <- base::`<<-`
[18:01:55.827]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:55.827]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:55.827]                   3L)]
[18:01:55.827]             }
[18:01:55.827]             function(cond) {
[18:01:55.827]                 is_error <- inherits(cond, "error")
[18:01:55.827]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:55.827]                   NULL)
[18:01:55.827]                 if (is_error) {
[18:01:55.827]                   sessionInformation <- function() {
[18:01:55.827]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:55.827]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:55.827]                       search = base::search(), system = base::Sys.info())
[18:01:55.827]                   }
[18:01:55.827]                   ...future.conditions[[length(...future.conditions) + 
[18:01:55.827]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:55.827]                     cond$call), session = sessionInformation(), 
[18:01:55.827]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:55.827]                   signalCondition(cond)
[18:01:55.827]                 }
[18:01:55.827]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:55.827]                 "immediateCondition"))) {
[18:01:55.827]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:55.827]                   ...future.conditions[[length(...future.conditions) + 
[18:01:55.827]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:55.827]                   if (TRUE && !signal) {
[18:01:55.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:55.827]                     {
[18:01:55.827]                       inherits <- base::inherits
[18:01:55.827]                       invokeRestart <- base::invokeRestart
[18:01:55.827]                       is.null <- base::is.null
[18:01:55.827]                       muffled <- FALSE
[18:01:55.827]                       if (inherits(cond, "message")) {
[18:01:55.827]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:55.827]                         if (muffled) 
[18:01:55.827]                           invokeRestart("muffleMessage")
[18:01:55.827]                       }
[18:01:55.827]                       else if (inherits(cond, "warning")) {
[18:01:55.827]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:55.827]                         if (muffled) 
[18:01:55.827]                           invokeRestart("muffleWarning")
[18:01:55.827]                       }
[18:01:55.827]                       else if (inherits(cond, "condition")) {
[18:01:55.827]                         if (!is.null(pattern)) {
[18:01:55.827]                           computeRestarts <- base::computeRestarts
[18:01:55.827]                           grepl <- base::grepl
[18:01:55.827]                           restarts <- computeRestarts(cond)
[18:01:55.827]                           for (restart in restarts) {
[18:01:55.827]                             name <- restart$name
[18:01:55.827]                             if (is.null(name)) 
[18:01:55.827]                               next
[18:01:55.827]                             if (!grepl(pattern, name)) 
[18:01:55.827]                               next
[18:01:55.827]                             invokeRestart(restart)
[18:01:55.827]                             muffled <- TRUE
[18:01:55.827]                             break
[18:01:55.827]                           }
[18:01:55.827]                         }
[18:01:55.827]                       }
[18:01:55.827]                       invisible(muffled)
[18:01:55.827]                     }
[18:01:55.827]                     muffleCondition(cond, pattern = "^muffle")
[18:01:55.827]                   }
[18:01:55.827]                 }
[18:01:55.827]                 else {
[18:01:55.827]                   if (TRUE) {
[18:01:55.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:55.827]                     {
[18:01:55.827]                       inherits <- base::inherits
[18:01:55.827]                       invokeRestart <- base::invokeRestart
[18:01:55.827]                       is.null <- base::is.null
[18:01:55.827]                       muffled <- FALSE
[18:01:55.827]                       if (inherits(cond, "message")) {
[18:01:55.827]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:55.827]                         if (muffled) 
[18:01:55.827]                           invokeRestart("muffleMessage")
[18:01:55.827]                       }
[18:01:55.827]                       else if (inherits(cond, "warning")) {
[18:01:55.827]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:55.827]                         if (muffled) 
[18:01:55.827]                           invokeRestart("muffleWarning")
[18:01:55.827]                       }
[18:01:55.827]                       else if (inherits(cond, "condition")) {
[18:01:55.827]                         if (!is.null(pattern)) {
[18:01:55.827]                           computeRestarts <- base::computeRestarts
[18:01:55.827]                           grepl <- base::grepl
[18:01:55.827]                           restarts <- computeRestarts(cond)
[18:01:55.827]                           for (restart in restarts) {
[18:01:55.827]                             name <- restart$name
[18:01:55.827]                             if (is.null(name)) 
[18:01:55.827]                               next
[18:01:55.827]                             if (!grepl(pattern, name)) 
[18:01:55.827]                               next
[18:01:55.827]                             invokeRestart(restart)
[18:01:55.827]                             muffled <- TRUE
[18:01:55.827]                             break
[18:01:55.827]                           }
[18:01:55.827]                         }
[18:01:55.827]                       }
[18:01:55.827]                       invisible(muffled)
[18:01:55.827]                     }
[18:01:55.827]                     muffleCondition(cond, pattern = "^muffle")
[18:01:55.827]                   }
[18:01:55.827]                 }
[18:01:55.827]             }
[18:01:55.827]         }))
[18:01:55.827]     }, error = function(ex) {
[18:01:55.827]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:55.827]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:55.827]                 ...future.rng), started = ...future.startTime, 
[18:01:55.827]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:55.827]             version = "1.8"), class = "FutureResult")
[18:01:55.827]     }, finally = {
[18:01:55.827]         if (!identical(...future.workdir, getwd())) 
[18:01:55.827]             setwd(...future.workdir)
[18:01:55.827]         {
[18:01:55.827]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:55.827]                 ...future.oldOptions$nwarnings <- NULL
[18:01:55.827]             }
[18:01:55.827]             base::options(...future.oldOptions)
[18:01:55.827]             if (.Platform$OS.type == "windows") {
[18:01:55.827]                 old_names <- names(...future.oldEnvVars)
[18:01:55.827]                 envs <- base::Sys.getenv()
[18:01:55.827]                 names <- names(envs)
[18:01:55.827]                 common <- intersect(names, old_names)
[18:01:55.827]                 added <- setdiff(names, old_names)
[18:01:55.827]                 removed <- setdiff(old_names, names)
[18:01:55.827]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:55.827]                   envs[common]]
[18:01:55.827]                 NAMES <- toupper(changed)
[18:01:55.827]                 args <- list()
[18:01:55.827]                 for (kk in seq_along(NAMES)) {
[18:01:55.827]                   name <- changed[[kk]]
[18:01:55.827]                   NAME <- NAMES[[kk]]
[18:01:55.827]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.827]                     next
[18:01:55.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:55.827]                 }
[18:01:55.827]                 NAMES <- toupper(added)
[18:01:55.827]                 for (kk in seq_along(NAMES)) {
[18:01:55.827]                   name <- added[[kk]]
[18:01:55.827]                   NAME <- NAMES[[kk]]
[18:01:55.827]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.827]                     next
[18:01:55.827]                   args[[name]] <- ""
[18:01:55.827]                 }
[18:01:55.827]                 NAMES <- toupper(removed)
[18:01:55.827]                 for (kk in seq_along(NAMES)) {
[18:01:55.827]                   name <- removed[[kk]]
[18:01:55.827]                   NAME <- NAMES[[kk]]
[18:01:55.827]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.827]                     next
[18:01:55.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:55.827]                 }
[18:01:55.827]                 if (length(args) > 0) 
[18:01:55.827]                   base::do.call(base::Sys.setenv, args = args)
[18:01:55.827]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:55.827]             }
[18:01:55.827]             else {
[18:01:55.827]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:55.827]             }
[18:01:55.827]             {
[18:01:55.827]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:55.827]                   0L) {
[18:01:55.827]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:55.827]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:55.827]                   base::options(opts)
[18:01:55.827]                 }
[18:01:55.827]                 {
[18:01:55.827]                   {
[18:01:55.827]                     NULL
[18:01:55.827]                     RNGkind("Mersenne-Twister")
[18:01:55.827]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:55.827]                       inherits = FALSE)
[18:01:55.827]                   }
[18:01:55.827]                   options(future.plan = NULL)
[18:01:55.827]                   if (is.na(NA_character_)) 
[18:01:55.827]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:55.827]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:55.827]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:55.827]                     .init = FALSE)
[18:01:55.827]                 }
[18:01:55.827]             }
[18:01:55.827]         }
[18:01:55.827]     })
[18:01:55.827]     if (TRUE) {
[18:01:55.827]         base::sink(type = "output", split = FALSE)
[18:01:55.827]         if (TRUE) {
[18:01:55.827]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:55.827]         }
[18:01:55.827]         else {
[18:01:55.827]             ...future.result["stdout"] <- base::list(NULL)
[18:01:55.827]         }
[18:01:55.827]         base::close(...future.stdout)
[18:01:55.827]         ...future.stdout <- NULL
[18:01:55.827]     }
[18:01:55.827]     ...future.result$conditions <- ...future.conditions
[18:01:55.827]     ...future.result$finished <- base::Sys.time()
[18:01:55.827]     ...future.result
[18:01:55.827] }
[18:01:55.830] assign_globals() ...
[18:01:55.830] List of 11
[18:01:55.830]  $ ...future.FUN            :function (x, ...)  
[18:01:55.830]  $ x_FUN                    :function (x)  
[18:01:55.830]  $ times                    : int 2
[18:01:55.830]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:55.830]  $ stop_if_not              :function (...)  
[18:01:55.830]  $ dim                      : NULL
[18:01:55.830]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:55.830]  $ future.call.arguments    : list()
[18:01:55.830]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.830]  $ ...future.elements_ii    :List of 10
[18:01:55.830]   ..$ : int 1
[18:01:55.830]   ..$ : int 2
[18:01:55.830]   ..$ : int 3
[18:01:55.830]   ..$ : int 4
[18:01:55.830]   ..$ : int 5
[18:01:55.830]   ..$ : int 6
[18:01:55.830]   ..$ : int 7
[18:01:55.830]   ..$ : int 8
[18:01:55.830]   ..$ : int 9
[18:01:55.830]   ..$ : int 10
[18:01:55.830]  $ ...future.seeds_ii       : NULL
[18:01:55.830]  $ ...future.globals.maxSize: NULL
[18:01:55.830]  - attr(*, "where")=List of 11
[18:01:55.830]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:55.830]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:55.830]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:55.830]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:55.830]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:55.830]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:55.830]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:55.830]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:55.830]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:55.830]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:55.830]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:55.830]  - attr(*, "resolved")= logi FALSE
[18:01:55.830]  - attr(*, "total_size")= num 96456
[18:01:55.830]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.830]  - attr(*, "already-done")= logi TRUE
[18:01:55.851] - copied ‘...future.FUN’ to environment
[18:01:55.851] - reassign environment for ‘x_FUN’
[18:01:55.851] - copied ‘x_FUN’ to environment
[18:01:55.851] - copied ‘times’ to environment
[18:01:55.852] - copied ‘stopf’ to environment
[18:01:55.852] - copied ‘stop_if_not’ to environment
[18:01:55.852] - copied ‘dim’ to environment
[18:01:55.852] - copied ‘valid_types’ to environment
[18:01:55.852] - copied ‘future.call.arguments’ to environment
[18:01:55.853] - copied ‘...future.elements_ii’ to environment
[18:01:55.853] - copied ‘...future.seeds_ii’ to environment
[18:01:55.853] - copied ‘...future.globals.maxSize’ to environment
[18:01:55.853] assign_globals() ... done
[18:01:55.854] plan(): Setting new future strategy stack:
[18:01:55.854] List of future strategies:
[18:01:55.854] 1. sequential:
[18:01:55.854]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:55.854]    - tweaked: FALSE
[18:01:55.854]    - call: NULL
[18:01:55.855] plan(): nbrOfWorkers() = 1
[18:01:55.857] plan(): Setting new future strategy stack:
[18:01:55.857] List of future strategies:
[18:01:55.857] 1. sequential:
[18:01:55.857]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:55.857]    - tweaked: FALSE
[18:01:55.857]    - call: plan(strategy)
[18:01:55.858] plan(): nbrOfWorkers() = 1
[18:01:55.858] SequentialFuture started (and completed)
[18:01:55.858] - Launch lazy future ... done
[18:01:55.858] run() for ‘SequentialFuture’ ... done
[18:01:55.859] Created future:
[18:01:55.859] SequentialFuture:
[18:01:55.859] Label: ‘future_vapply-1’
[18:01:55.859] Expression:
[18:01:55.859] {
[18:01:55.859]     do.call(function(...) {
[18:01:55.859]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.859]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:55.859]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.859]             on.exit(options(oopts), add = TRUE)
[18:01:55.859]         }
[18:01:55.859]         {
[18:01:55.859]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:55.859]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.859]                 ...future.FUN(...future.X_jj, ...)
[18:01:55.859]             })
[18:01:55.859]         }
[18:01:55.859]     }, args = future.call.arguments)
[18:01:55.859] }
[18:01:55.859] Lazy evaluation: FALSE
[18:01:55.859] Asynchronous evaluation: FALSE
[18:01:55.859] Local evaluation: TRUE
[18:01:55.859] Environment: R_GlobalEnv
[18:01:55.859] Capture standard output: TRUE
[18:01:55.859] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:55.859] Globals: 11 objects totaling 94.74 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:55.859] Packages: 1 packages (‘future.apply’)
[18:01:55.859] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:55.859] Resolved: TRUE
[18:01:55.859] Value: 640 bytes of class ‘list’
[18:01:55.859] Early signaling: FALSE
[18:01:55.859] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:55.859] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:55.861] Chunk #1 of 1 ... DONE
[18:01:55.862] Launching 1 futures (chunks) ... DONE
[18:01:55.862] Resolving 1 futures (chunks) ...
[18:01:55.862] resolve() on list ...
[18:01:55.862]  recursive: 0
[18:01:55.862]  length: 1
[18:01:55.863] 
[18:01:55.863] resolved() for ‘SequentialFuture’ ...
[18:01:55.863] - state: ‘finished’
[18:01:55.863] - run: TRUE
[18:01:55.863] - result: ‘FutureResult’
[18:01:55.864] resolved() for ‘SequentialFuture’ ... done
[18:01:55.864] Future #1
[18:01:55.864] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:55.864] - nx: 1
[18:01:55.864] - relay: TRUE
[18:01:55.865] - stdout: TRUE
[18:01:55.865] - signal: TRUE
[18:01:55.865] - resignal: FALSE
[18:01:55.865] - force: TRUE
[18:01:55.865] - relayed: [n=1] FALSE
[18:01:55.865] - queued futures: [n=1] FALSE
[18:01:55.866]  - until=1
[18:01:55.866]  - relaying element #1
[18:01:55.866] - relayed: [n=1] TRUE
[18:01:55.866] - queued futures: [n=1] TRUE
[18:01:55.867] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:55.867]  length: 0 (resolved future 1)
[18:01:55.867] Relaying remaining futures
[18:01:55.867] signalConditionsASAP(NULL, pos=0) ...
[18:01:55.867] - nx: 1
[18:01:55.868] - relay: TRUE
[18:01:55.868] - stdout: TRUE
[18:01:55.868] - signal: TRUE
[18:01:55.868] - resignal: FALSE
[18:01:55.868] - force: TRUE
[18:01:55.868] - relayed: [n=1] TRUE
[18:01:55.869] - queued futures: [n=1] TRUE
 - flush all
[18:01:55.869] - relayed: [n=1] TRUE
[18:01:55.869] - queued futures: [n=1] TRUE
[18:01:55.869] signalConditionsASAP(NULL, pos=0) ... done
[18:01:55.869] resolve() on list ... DONE
[18:01:55.870]  - Number of value chunks collected: 1
[18:01:55.870] Resolving 1 futures (chunks) ... DONE
[18:01:55.870] Reducing values from 1 chunks ...
[18:01:55.870]  - Number of values collected after concatenation: 10
[18:01:55.870]  - Number of values expected: 10
[18:01:55.871] Reducing values from 1 chunks ... DONE
[18:01:55.871] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[18:01:55.873] future_lapply() ...
[18:01:55.878] Number of chunks: 1
[18:01:55.879] getGlobalsAndPackagesXApply() ...
[18:01:55.879]  - future.globals: TRUE
[18:01:55.879] getGlobalsAndPackages() ...
[18:01:55.879] Searching for globals...
[18:01:55.886] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[18:01:55.887] Searching for globals ... DONE
[18:01:55.887] Resolving globals: FALSE
[18:01:55.889] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[18:01:55.890] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:55.890] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:55.890] - packages: [1] ‘future.apply’
[18:01:55.891] getGlobalsAndPackages() ... DONE
[18:01:55.891]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:55.892]  - needed namespaces: [n=1] ‘future.apply’
[18:01:55.892] Finding globals ... DONE
[18:01:55.892]  - use_args: TRUE
[18:01:55.892]  - Getting '...' globals ...
[18:01:55.893] resolve() on list ...
[18:01:55.893]  recursive: 0
[18:01:55.893]  length: 1
[18:01:55.893]  elements: ‘...’
[18:01:55.894]  length: 0 (resolved future 1)
[18:01:55.894] resolve() on list ... DONE
[18:01:55.894]    - '...' content: [n=0] 
[18:01:55.894] List of 1
[18:01:55.894]  $ ...: list()
[18:01:55.894]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.894]  - attr(*, "where")=List of 1
[18:01:55.894]   ..$ ...:<environment: 0x6183c0f33390> 
[18:01:55.894]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.894]  - attr(*, "resolved")= logi TRUE
[18:01:55.894]  - attr(*, "total_size")= num NA
[18:01:55.899]  - Getting '...' globals ... DONE
[18:01:55.900] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:55.900] List of 8
[18:01:55.900]  $ ...future.FUN:function (x, ...)  
[18:01:55.900]  $ x_FUN        :function (x)  
[18:01:55.900]  $ times        : int 4
[18:01:55.900]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:55.900]  $ stop_if_not  :function (...)  
[18:01:55.900]  $ dim          : int [1:2] 2 2
[18:01:55.900]  $ valid_types  : chr [1:2] "logical" "integer"
[18:01:55.900]  $ ...          : list()
[18:01:55.900]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.900]  - attr(*, "where")=List of 8
[18:01:55.900]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:55.900]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:55.900]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:55.900]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:55.900]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:55.900]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:55.900]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:55.900]   ..$ ...          :<environment: 0x6183c0f33390> 
[18:01:55.900]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.900]  - attr(*, "resolved")= logi FALSE
[18:01:55.900]  - attr(*, "total_size")= num 97232
[18:01:55.911] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:55.911] getGlobalsAndPackagesXApply() ... DONE
[18:01:55.912] Number of futures (= number of chunks): 1
[18:01:55.912] Launching 1 futures (chunks) ...
[18:01:55.912] Chunk #1 of 1 ...
[18:01:55.913]  - Finding globals in 'X' for chunk #1 ...
[18:01:55.913] getGlobalsAndPackages() ...
[18:01:55.913] Searching for globals...
[18:01:55.913] 
[18:01:55.914] Searching for globals ... DONE
[18:01:55.914] - globals: [0] <none>
[18:01:55.914] getGlobalsAndPackages() ... DONE
[18:01:55.914]    + additional globals found: [n=0] 
[18:01:55.914]    + additional namespaces needed: [n=0] 
[18:01:55.915]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:55.915]  - seeds: <none>
[18:01:55.915]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.915] getGlobalsAndPackages() ...
[18:01:55.915] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.916] Resolving globals: FALSE
[18:01:55.916] Tweak future expression to call with '...' arguments ...
[18:01:55.916] {
[18:01:55.916]     do.call(function(...) {
[18:01:55.916]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.916]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:55.916]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.916]             on.exit(options(oopts), add = TRUE)
[18:01:55.916]         }
[18:01:55.916]         {
[18:01:55.916]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:55.916]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.916]                 ...future.FUN(...future.X_jj, ...)
[18:01:55.916]             })
[18:01:55.916]         }
[18:01:55.916]     }, args = future.call.arguments)
[18:01:55.916] }
[18:01:55.917] Tweak future expression to call with '...' arguments ... DONE
[18:01:55.918] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:55.918] - packages: [1] ‘future.apply’
[18:01:55.918] getGlobalsAndPackages() ... DONE
[18:01:55.919] run() for ‘Future’ ...
[18:01:55.919] - state: ‘created’
[18:01:55.919] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:55.920] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:55.922] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:55.923]   - Field: ‘label’
[18:01:55.923]   - Field: ‘local’
[18:01:55.923]   - Field: ‘owner’
[18:01:55.923]   - Field: ‘envir’
[18:01:55.923]   - Field: ‘packages’
[18:01:55.924]   - Field: ‘gc’
[18:01:55.924]   - Field: ‘conditions’
[18:01:55.924]   - Field: ‘expr’
[18:01:55.924]   - Field: ‘uuid’
[18:01:55.924]   - Field: ‘seed’
[18:01:55.925]   - Field: ‘version’
[18:01:55.925]   - Field: ‘result’
[18:01:55.925]   - Field: ‘asynchronous’
[18:01:55.925]   - Field: ‘calls’
[18:01:55.925]   - Field: ‘globals’
[18:01:55.926]   - Field: ‘stdout’
[18:01:55.926]   - Field: ‘earlySignal’
[18:01:55.926]   - Field: ‘lazy’
[18:01:55.926]   - Field: ‘state’
[18:01:55.926] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:55.927] - Launch lazy future ...
[18:01:55.927] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:55.927] Packages needed by future strategies (n = 0): <none>
[18:01:55.928] {
[18:01:55.928]     {
[18:01:55.928]         {
[18:01:55.928]             ...future.startTime <- base::Sys.time()
[18:01:55.928]             {
[18:01:55.928]                 {
[18:01:55.928]                   {
[18:01:55.928]                     {
[18:01:55.928]                       base::local({
[18:01:55.928]                         has_future <- base::requireNamespace("future", 
[18:01:55.928]                           quietly = TRUE)
[18:01:55.928]                         if (has_future) {
[18:01:55.928]                           ns <- base::getNamespace("future")
[18:01:55.928]                           version <- ns[[".package"]][["version"]]
[18:01:55.928]                           if (is.null(version)) 
[18:01:55.928]                             version <- utils::packageVersion("future")
[18:01:55.928]                         }
[18:01:55.928]                         else {
[18:01:55.928]                           version <- NULL
[18:01:55.928]                         }
[18:01:55.928]                         if (!has_future || version < "1.8.0") {
[18:01:55.928]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:55.928]                             "", base::R.version$version.string), 
[18:01:55.928]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:55.928]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:55.928]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:55.928]                               "release", "version")], collapse = " "), 
[18:01:55.928]                             hostname = base::Sys.info()[["nodename"]])
[18:01:55.928]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:55.928]                             info)
[18:01:55.928]                           info <- base::paste(info, collapse = "; ")
[18:01:55.928]                           if (!has_future) {
[18:01:55.928]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:55.928]                               info)
[18:01:55.928]                           }
[18:01:55.928]                           else {
[18:01:55.928]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:55.928]                               info, version)
[18:01:55.928]                           }
[18:01:55.928]                           base::stop(msg)
[18:01:55.928]                         }
[18:01:55.928]                       })
[18:01:55.928]                     }
[18:01:55.928]                     base::local({
[18:01:55.928]                       for (pkg in "future.apply") {
[18:01:55.928]                         base::loadNamespace(pkg)
[18:01:55.928]                         base::library(pkg, character.only = TRUE)
[18:01:55.928]                       }
[18:01:55.928]                     })
[18:01:55.928]                   }
[18:01:55.928]                   ...future.strategy.old <- future::plan("list")
[18:01:55.928]                   options(future.plan = NULL)
[18:01:55.928]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:55.928]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:55.928]                 }
[18:01:55.928]                 ...future.workdir <- getwd()
[18:01:55.928]             }
[18:01:55.928]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:55.928]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:55.928]         }
[18:01:55.928]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:55.928]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:55.928]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:55.928]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:55.928]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:55.928]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:55.928]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:55.928]             base::names(...future.oldOptions))
[18:01:55.928]     }
[18:01:55.928]     if (FALSE) {
[18:01:55.928]     }
[18:01:55.928]     else {
[18:01:55.928]         if (TRUE) {
[18:01:55.928]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:55.928]                 open = "w")
[18:01:55.928]         }
[18:01:55.928]         else {
[18:01:55.928]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:55.928]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:55.928]         }
[18:01:55.928]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:55.928]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:55.928]             base::sink(type = "output", split = FALSE)
[18:01:55.928]             base::close(...future.stdout)
[18:01:55.928]         }, add = TRUE)
[18:01:55.928]     }
[18:01:55.928]     ...future.frame <- base::sys.nframe()
[18:01:55.928]     ...future.conditions <- base::list()
[18:01:55.928]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:55.928]     if (FALSE) {
[18:01:55.928]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:55.928]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:55.928]     }
[18:01:55.928]     ...future.result <- base::tryCatch({
[18:01:55.928]         base::withCallingHandlers({
[18:01:55.928]             ...future.value <- base::withVisible(base::local({
[18:01:55.928]                 do.call(function(...) {
[18:01:55.928]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.928]                   if (!identical(...future.globals.maxSize.org, 
[18:01:55.928]                     ...future.globals.maxSize)) {
[18:01:55.928]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.928]                     on.exit(options(oopts), add = TRUE)
[18:01:55.928]                   }
[18:01:55.928]                   {
[18:01:55.928]                     lapply(seq_along(...future.elements_ii), 
[18:01:55.928]                       FUN = function(jj) {
[18:01:55.928]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.928]                         ...future.FUN(...future.X_jj, ...)
[18:01:55.928]                       })
[18:01:55.928]                   }
[18:01:55.928]                 }, args = future.call.arguments)
[18:01:55.928]             }))
[18:01:55.928]             future::FutureResult(value = ...future.value$value, 
[18:01:55.928]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:55.928]                   ...future.rng), globalenv = if (FALSE) 
[18:01:55.928]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:55.928]                     ...future.globalenv.names))
[18:01:55.928]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:55.928]         }, condition = base::local({
[18:01:55.928]             c <- base::c
[18:01:55.928]             inherits <- base::inherits
[18:01:55.928]             invokeRestart <- base::invokeRestart
[18:01:55.928]             length <- base::length
[18:01:55.928]             list <- base::list
[18:01:55.928]             seq.int <- base::seq.int
[18:01:55.928]             signalCondition <- base::signalCondition
[18:01:55.928]             sys.calls <- base::sys.calls
[18:01:55.928]             `[[` <- base::`[[`
[18:01:55.928]             `+` <- base::`+`
[18:01:55.928]             `<<-` <- base::`<<-`
[18:01:55.928]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:55.928]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:55.928]                   3L)]
[18:01:55.928]             }
[18:01:55.928]             function(cond) {
[18:01:55.928]                 is_error <- inherits(cond, "error")
[18:01:55.928]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:55.928]                   NULL)
[18:01:55.928]                 if (is_error) {
[18:01:55.928]                   sessionInformation <- function() {
[18:01:55.928]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:55.928]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:55.928]                       search = base::search(), system = base::Sys.info())
[18:01:55.928]                   }
[18:01:55.928]                   ...future.conditions[[length(...future.conditions) + 
[18:01:55.928]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:55.928]                     cond$call), session = sessionInformation(), 
[18:01:55.928]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:55.928]                   signalCondition(cond)
[18:01:55.928]                 }
[18:01:55.928]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:55.928]                 "immediateCondition"))) {
[18:01:55.928]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:55.928]                   ...future.conditions[[length(...future.conditions) + 
[18:01:55.928]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:55.928]                   if (TRUE && !signal) {
[18:01:55.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:55.928]                     {
[18:01:55.928]                       inherits <- base::inherits
[18:01:55.928]                       invokeRestart <- base::invokeRestart
[18:01:55.928]                       is.null <- base::is.null
[18:01:55.928]                       muffled <- FALSE
[18:01:55.928]                       if (inherits(cond, "message")) {
[18:01:55.928]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:55.928]                         if (muffled) 
[18:01:55.928]                           invokeRestart("muffleMessage")
[18:01:55.928]                       }
[18:01:55.928]                       else if (inherits(cond, "warning")) {
[18:01:55.928]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:55.928]                         if (muffled) 
[18:01:55.928]                           invokeRestart("muffleWarning")
[18:01:55.928]                       }
[18:01:55.928]                       else if (inherits(cond, "condition")) {
[18:01:55.928]                         if (!is.null(pattern)) {
[18:01:55.928]                           computeRestarts <- base::computeRestarts
[18:01:55.928]                           grepl <- base::grepl
[18:01:55.928]                           restarts <- computeRestarts(cond)
[18:01:55.928]                           for (restart in restarts) {
[18:01:55.928]                             name <- restart$name
[18:01:55.928]                             if (is.null(name)) 
[18:01:55.928]                               next
[18:01:55.928]                             if (!grepl(pattern, name)) 
[18:01:55.928]                               next
[18:01:55.928]                             invokeRestart(restart)
[18:01:55.928]                             muffled <- TRUE
[18:01:55.928]                             break
[18:01:55.928]                           }
[18:01:55.928]                         }
[18:01:55.928]                       }
[18:01:55.928]                       invisible(muffled)
[18:01:55.928]                     }
[18:01:55.928]                     muffleCondition(cond, pattern = "^muffle")
[18:01:55.928]                   }
[18:01:55.928]                 }
[18:01:55.928]                 else {
[18:01:55.928]                   if (TRUE) {
[18:01:55.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:55.928]                     {
[18:01:55.928]                       inherits <- base::inherits
[18:01:55.928]                       invokeRestart <- base::invokeRestart
[18:01:55.928]                       is.null <- base::is.null
[18:01:55.928]                       muffled <- FALSE
[18:01:55.928]                       if (inherits(cond, "message")) {
[18:01:55.928]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:55.928]                         if (muffled) 
[18:01:55.928]                           invokeRestart("muffleMessage")
[18:01:55.928]                       }
[18:01:55.928]                       else if (inherits(cond, "warning")) {
[18:01:55.928]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:55.928]                         if (muffled) 
[18:01:55.928]                           invokeRestart("muffleWarning")
[18:01:55.928]                       }
[18:01:55.928]                       else if (inherits(cond, "condition")) {
[18:01:55.928]                         if (!is.null(pattern)) {
[18:01:55.928]                           computeRestarts <- base::computeRestarts
[18:01:55.928]                           grepl <- base::grepl
[18:01:55.928]                           restarts <- computeRestarts(cond)
[18:01:55.928]                           for (restart in restarts) {
[18:01:55.928]                             name <- restart$name
[18:01:55.928]                             if (is.null(name)) 
[18:01:55.928]                               next
[18:01:55.928]                             if (!grepl(pattern, name)) 
[18:01:55.928]                               next
[18:01:55.928]                             invokeRestart(restart)
[18:01:55.928]                             muffled <- TRUE
[18:01:55.928]                             break
[18:01:55.928]                           }
[18:01:55.928]                         }
[18:01:55.928]                       }
[18:01:55.928]                       invisible(muffled)
[18:01:55.928]                     }
[18:01:55.928]                     muffleCondition(cond, pattern = "^muffle")
[18:01:55.928]                   }
[18:01:55.928]                 }
[18:01:55.928]             }
[18:01:55.928]         }))
[18:01:55.928]     }, error = function(ex) {
[18:01:55.928]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:55.928]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:55.928]                 ...future.rng), started = ...future.startTime, 
[18:01:55.928]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:55.928]             version = "1.8"), class = "FutureResult")
[18:01:55.928]     }, finally = {
[18:01:55.928]         if (!identical(...future.workdir, getwd())) 
[18:01:55.928]             setwd(...future.workdir)
[18:01:55.928]         {
[18:01:55.928]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:55.928]                 ...future.oldOptions$nwarnings <- NULL
[18:01:55.928]             }
[18:01:55.928]             base::options(...future.oldOptions)
[18:01:55.928]             if (.Platform$OS.type == "windows") {
[18:01:55.928]                 old_names <- names(...future.oldEnvVars)
[18:01:55.928]                 envs <- base::Sys.getenv()
[18:01:55.928]                 names <- names(envs)
[18:01:55.928]                 common <- intersect(names, old_names)
[18:01:55.928]                 added <- setdiff(names, old_names)
[18:01:55.928]                 removed <- setdiff(old_names, names)
[18:01:55.928]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:55.928]                   envs[common]]
[18:01:55.928]                 NAMES <- toupper(changed)
[18:01:55.928]                 args <- list()
[18:01:55.928]                 for (kk in seq_along(NAMES)) {
[18:01:55.928]                   name <- changed[[kk]]
[18:01:55.928]                   NAME <- NAMES[[kk]]
[18:01:55.928]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.928]                     next
[18:01:55.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:55.928]                 }
[18:01:55.928]                 NAMES <- toupper(added)
[18:01:55.928]                 for (kk in seq_along(NAMES)) {
[18:01:55.928]                   name <- added[[kk]]
[18:01:55.928]                   NAME <- NAMES[[kk]]
[18:01:55.928]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.928]                     next
[18:01:55.928]                   args[[name]] <- ""
[18:01:55.928]                 }
[18:01:55.928]                 NAMES <- toupper(removed)
[18:01:55.928]                 for (kk in seq_along(NAMES)) {
[18:01:55.928]                   name <- removed[[kk]]
[18:01:55.928]                   NAME <- NAMES[[kk]]
[18:01:55.928]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:55.928]                     next
[18:01:55.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:55.928]                 }
[18:01:55.928]                 if (length(args) > 0) 
[18:01:55.928]                   base::do.call(base::Sys.setenv, args = args)
[18:01:55.928]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:55.928]             }
[18:01:55.928]             else {
[18:01:55.928]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:55.928]             }
[18:01:55.928]             {
[18:01:55.928]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:55.928]                   0L) {
[18:01:55.928]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:55.928]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:55.928]                   base::options(opts)
[18:01:55.928]                 }
[18:01:55.928]                 {
[18:01:55.928]                   {
[18:01:55.928]                     NULL
[18:01:55.928]                     RNGkind("Mersenne-Twister")
[18:01:55.928]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:55.928]                       inherits = FALSE)
[18:01:55.928]                   }
[18:01:55.928]                   options(future.plan = NULL)
[18:01:55.928]                   if (is.na(NA_character_)) 
[18:01:55.928]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:55.928]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:55.928]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:55.928]                     .init = FALSE)
[18:01:55.928]                 }
[18:01:55.928]             }
[18:01:55.928]         }
[18:01:55.928]     })
[18:01:55.928]     if (TRUE) {
[18:01:55.928]         base::sink(type = "output", split = FALSE)
[18:01:55.928]         if (TRUE) {
[18:01:55.928]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:55.928]         }
[18:01:55.928]         else {
[18:01:55.928]             ...future.result["stdout"] <- base::list(NULL)
[18:01:55.928]         }
[18:01:55.928]         base::close(...future.stdout)
[18:01:55.928]         ...future.stdout <- NULL
[18:01:55.928]     }
[18:01:55.928]     ...future.result$conditions <- ...future.conditions
[18:01:55.928]     ...future.result$finished <- base::Sys.time()
[18:01:55.928]     ...future.result
[18:01:55.928] }
[18:01:55.931] assign_globals() ...
[18:01:55.932] List of 11
[18:01:55.932]  $ ...future.FUN            :function (x, ...)  
[18:01:55.932]  $ x_FUN                    :function (x)  
[18:01:55.932]  $ times                    : int 4
[18:01:55.932]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:55.932]  $ stop_if_not              :function (...)  
[18:01:55.932]  $ dim                      : int [1:2] 2 2
[18:01:55.932]  $ valid_types              : chr [1:2] "logical" "integer"
[18:01:55.932]  $ future.call.arguments    : list()
[18:01:55.932]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.932]  $ ...future.elements_ii    :List of 10
[18:01:55.932]   ..$ : int 1
[18:01:55.932]   ..$ : int 2
[18:01:55.932]   ..$ : int 3
[18:01:55.932]   ..$ : int 4
[18:01:55.932]   ..$ : int 5
[18:01:55.932]   ..$ : int 6
[18:01:55.932]   ..$ : int 7
[18:01:55.932]   ..$ : int 8
[18:01:55.932]   ..$ : int 9
[18:01:55.932]   ..$ : int 10
[18:01:55.932]  $ ...future.seeds_ii       : NULL
[18:01:55.932]  $ ...future.globals.maxSize: NULL
[18:01:55.932]  - attr(*, "where")=List of 11
[18:01:55.932]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:55.932]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:55.932]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:55.932]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:55.932]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:55.932]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:55.932]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:55.932]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:55.932]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:55.932]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:55.932]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:55.932]  - attr(*, "resolved")= logi FALSE
[18:01:55.932]  - attr(*, "total_size")= num 97232
[18:01:55.932]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.932]  - attr(*, "already-done")= logi TRUE
[18:01:55.952] - copied ‘...future.FUN’ to environment
[18:01:55.952] - reassign environment for ‘x_FUN’
[18:01:55.952] - copied ‘x_FUN’ to environment
[18:01:55.953] - copied ‘times’ to environment
[18:01:55.953] - copied ‘stopf’ to environment
[18:01:55.953] - copied ‘stop_if_not’ to environment
[18:01:55.953] - copied ‘dim’ to environment
[18:01:55.953] - copied ‘valid_types’ to environment
[18:01:55.954] - copied ‘future.call.arguments’ to environment
[18:01:55.954] - copied ‘...future.elements_ii’ to environment
[18:01:55.954] - copied ‘...future.seeds_ii’ to environment
[18:01:55.954] - copied ‘...future.globals.maxSize’ to environment
[18:01:55.954] assign_globals() ... done
[18:01:55.955] plan(): Setting new future strategy stack:
[18:01:55.955] List of future strategies:
[18:01:55.955] 1. sequential:
[18:01:55.955]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:55.955]    - tweaked: FALSE
[18:01:55.955]    - call: NULL
[18:01:55.956] plan(): nbrOfWorkers() = 1
[18:01:55.958] plan(): Setting new future strategy stack:
[18:01:55.958] List of future strategies:
[18:01:55.958] 1. sequential:
[18:01:55.958]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:55.958]    - tweaked: FALSE
[18:01:55.958]    - call: plan(strategy)
[18:01:55.959] plan(): nbrOfWorkers() = 1
[18:01:55.959] SequentialFuture started (and completed)
[18:01:55.959] - Launch lazy future ... done
[18:01:55.960] run() for ‘SequentialFuture’ ... done
[18:01:55.960] Created future:
[18:01:55.960] SequentialFuture:
[18:01:55.960] Label: ‘future_vapply-1’
[18:01:55.960] Expression:
[18:01:55.960] {
[18:01:55.960]     do.call(function(...) {
[18:01:55.960]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:55.960]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:55.960]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:55.960]             on.exit(options(oopts), add = TRUE)
[18:01:55.960]         }
[18:01:55.960]         {
[18:01:55.960]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:55.960]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:55.960]                 ...future.FUN(...future.X_jj, ...)
[18:01:55.960]             })
[18:01:55.960]         }
[18:01:55.960]     }, args = future.call.arguments)
[18:01:55.960] }
[18:01:55.960] Lazy evaluation: FALSE
[18:01:55.960] Asynchronous evaluation: FALSE
[18:01:55.960] Local evaluation: TRUE
[18:01:55.960] Environment: R_GlobalEnv
[18:01:55.960] Capture standard output: TRUE
[18:01:55.960] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:55.960] Globals: 11 objects totaling 95.50 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:55.960] Packages: 1 packages (‘future.apply’)
[18:01:55.960] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:55.960] Resolved: TRUE
[18:01:55.960] Value: 2.27 KiB of class ‘list’
[18:01:55.960] Early signaling: FALSE
[18:01:55.960] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:55.960] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:55.963] Chunk #1 of 1 ... DONE
[18:01:55.963] Launching 1 futures (chunks) ... DONE
[18:01:55.963] Resolving 1 futures (chunks) ...
[18:01:55.963] resolve() on list ...
[18:01:55.963]  recursive: 0
[18:01:55.964]  length: 1
[18:01:55.964] 
[18:01:55.964] resolved() for ‘SequentialFuture’ ...
[18:01:55.964] - state: ‘finished’
[18:01:55.964] - run: TRUE
[18:01:55.965] - result: ‘FutureResult’
[18:01:55.965] resolved() for ‘SequentialFuture’ ... done
[18:01:55.965] Future #1
[18:01:55.965] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:55.965] - nx: 1
[18:01:55.966] - relay: TRUE
[18:01:55.966] - stdout: TRUE
[18:01:55.966] - signal: TRUE
[18:01:55.966] - resignal: FALSE
[18:01:55.966] - force: TRUE
[18:01:55.966] - relayed: [n=1] FALSE
[18:01:55.967] - queued futures: [n=1] FALSE
[18:01:55.967]  - until=1
[18:01:55.967]  - relaying element #1
[18:01:55.967] - relayed: [n=1] TRUE
[18:01:55.968] - queued futures: [n=1] TRUE
[18:01:55.968] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:55.968]  length: 0 (resolved future 1)
[18:01:55.968] Relaying remaining futures
[18:01:55.971] signalConditionsASAP(NULL, pos=0) ...
[18:01:55.971] - nx: 1
[18:01:55.971] - relay: TRUE
[18:01:55.971] - stdout: TRUE
[18:01:55.972] - signal: TRUE
[18:01:55.972] - resignal: FALSE
[18:01:55.972] - force: TRUE
[18:01:55.972] - relayed: [n=1] TRUE
[18:01:55.972] - queued futures: [n=1] TRUE
 - flush all
[18:01:55.973] - relayed: [n=1] TRUE
[18:01:55.973] - queued futures: [n=1] TRUE
[18:01:55.973] signalConditionsASAP(NULL, pos=0) ... done
[18:01:55.973] resolve() on list ... DONE
[18:01:55.973]  - Number of value chunks collected: 1
[18:01:55.974] Resolving 1 futures (chunks) ... DONE
[18:01:55.974] Reducing values from 1 chunks ...
[18:01:55.974]  - Number of values collected after concatenation: 10
[18:01:55.974]  - Number of values expected: 10
[18:01:55.974] Reducing values from 1 chunks ... DONE
[18:01:55.975] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[18:01:55.976] future_lapply() ...
[18:01:55.980] Number of chunks: 1
[18:01:55.980] getGlobalsAndPackagesXApply() ...
[18:01:55.980]  - future.globals: TRUE
[18:01:55.980] getGlobalsAndPackages() ...
[18:01:55.981] Searching for globals...
[18:01:55.988] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[18:01:55.989] Searching for globals ... DONE
[18:01:55.989] Resolving globals: FALSE
[18:01:55.991] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[18:01:55.992] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:55.992] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:55.992] - packages: [1] ‘future.apply’
[18:01:55.992] getGlobalsAndPackages() ... DONE
[18:01:55.993]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:55.993]  - needed namespaces: [n=1] ‘future.apply’
[18:01:55.993] Finding globals ... DONE
[18:01:55.993]  - use_args: TRUE
[18:01:55.994]  - Getting '...' globals ...
[18:01:55.994] resolve() on list ...
[18:01:55.995]  recursive: 0
[18:01:55.995]  length: 1
[18:01:55.995]  elements: ‘...’
[18:01:55.995]  length: 0 (resolved future 1)
[18:01:55.995] resolve() on list ... DONE
[18:01:55.996]    - '...' content: [n=0] 
[18:01:55.996] List of 1
[18:01:55.996]  $ ...: list()
[18:01:55.996]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:55.996]  - attr(*, "where")=List of 1
[18:01:55.996]   ..$ ...:<environment: 0x6183be7dc868> 
[18:01:55.996]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:55.996]  - attr(*, "resolved")= logi TRUE
[18:01:55.996]  - attr(*, "total_size")= num NA
[18:01:56.001]  - Getting '...' globals ... DONE
[18:01:56.002] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:56.002] List of 8
[18:01:56.002]  $ ...future.FUN:function (x, ...)  
[18:01:56.002]  $ x_FUN        :function (x)  
[18:01:56.002]  $ times        : int 4
[18:01:56.002]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.002]  $ stop_if_not  :function (...)  
[18:01:56.002]  $ dim          : int [1:2] 2 2
[18:01:56.002]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:56.002]  $ ...          : list()
[18:01:56.002]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.002]  - attr(*, "where")=List of 8
[18:01:56.002]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:56.002]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:56.002]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:56.002]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:56.002]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:56.002]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:56.002]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:56.002]   ..$ ...          :<environment: 0x6183be7dc868> 
[18:01:56.002]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.002]  - attr(*, "resolved")= logi FALSE
[18:01:56.002]  - attr(*, "total_size")= num 97304
[18:01:56.014] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:56.015] getGlobalsAndPackagesXApply() ... DONE
[18:01:56.015] Number of futures (= number of chunks): 1
[18:01:56.015] Launching 1 futures (chunks) ...
[18:01:56.015] Chunk #1 of 1 ...
[18:01:56.016]  - Finding globals in 'X' for chunk #1 ...
[18:01:56.016] getGlobalsAndPackages() ...
[18:01:56.016] Searching for globals...
[18:01:56.019] 
[18:01:56.019] Searching for globals ... DONE
[18:01:56.020] - globals: [0] <none>
[18:01:56.020] getGlobalsAndPackages() ... DONE
[18:01:56.020]    + additional globals found: [n=0] 
[18:01:56.021]    + additional namespaces needed: [n=0] 
[18:01:56.021]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:56.021]  - seeds: <none>
[18:01:56.021]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.022] getGlobalsAndPackages() ...
[18:01:56.022] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.022] Resolving globals: FALSE
[18:01:56.022] Tweak future expression to call with '...' arguments ...
[18:01:56.023] {
[18:01:56.023]     do.call(function(...) {
[18:01:56.023]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.023]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.023]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.023]             on.exit(options(oopts), add = TRUE)
[18:01:56.023]         }
[18:01:56.023]         {
[18:01:56.023]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.023]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.023]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.023]             })
[18:01:56.023]         }
[18:01:56.023]     }, args = future.call.arguments)
[18:01:56.023] }
[18:01:56.023] Tweak future expression to call with '...' arguments ... DONE
[18:01:56.024] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.025] - packages: [1] ‘future.apply’
[18:01:56.025] getGlobalsAndPackages() ... DONE
[18:01:56.025] run() for ‘Future’ ...
[18:01:56.026] - state: ‘created’
[18:01:56.026] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:56.027] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.027] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:56.027]   - Field: ‘label’
[18:01:56.027]   - Field: ‘local’
[18:01:56.028]   - Field: ‘owner’
[18:01:56.028]   - Field: ‘envir’
[18:01:56.028]   - Field: ‘packages’
[18:01:56.028]   - Field: ‘gc’
[18:01:56.028]   - Field: ‘conditions’
[18:01:56.029]   - Field: ‘expr’
[18:01:56.029]   - Field: ‘uuid’
[18:01:56.029]   - Field: ‘seed’
[18:01:56.029]   - Field: ‘version’
[18:01:56.029]   - Field: ‘result’
[18:01:56.030]   - Field: ‘asynchronous’
[18:01:56.030]   - Field: ‘calls’
[18:01:56.030]   - Field: ‘globals’
[18:01:56.030]   - Field: ‘stdout’
[18:01:56.030]   - Field: ‘earlySignal’
[18:01:56.031]   - Field: ‘lazy’
[18:01:56.031]   - Field: ‘state’
[18:01:56.031] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:56.031] - Launch lazy future ...
[18:01:56.032] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:56.032] Packages needed by future strategies (n = 0): <none>
[18:01:56.033] {
[18:01:56.033]     {
[18:01:56.033]         {
[18:01:56.033]             ...future.startTime <- base::Sys.time()
[18:01:56.033]             {
[18:01:56.033]                 {
[18:01:56.033]                   {
[18:01:56.033]                     {
[18:01:56.033]                       base::local({
[18:01:56.033]                         has_future <- base::requireNamespace("future", 
[18:01:56.033]                           quietly = TRUE)
[18:01:56.033]                         if (has_future) {
[18:01:56.033]                           ns <- base::getNamespace("future")
[18:01:56.033]                           version <- ns[[".package"]][["version"]]
[18:01:56.033]                           if (is.null(version)) 
[18:01:56.033]                             version <- utils::packageVersion("future")
[18:01:56.033]                         }
[18:01:56.033]                         else {
[18:01:56.033]                           version <- NULL
[18:01:56.033]                         }
[18:01:56.033]                         if (!has_future || version < "1.8.0") {
[18:01:56.033]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:56.033]                             "", base::R.version$version.string), 
[18:01:56.033]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:56.033]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:56.033]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:56.033]                               "release", "version")], collapse = " "), 
[18:01:56.033]                             hostname = base::Sys.info()[["nodename"]])
[18:01:56.033]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:56.033]                             info)
[18:01:56.033]                           info <- base::paste(info, collapse = "; ")
[18:01:56.033]                           if (!has_future) {
[18:01:56.033]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:56.033]                               info)
[18:01:56.033]                           }
[18:01:56.033]                           else {
[18:01:56.033]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:56.033]                               info, version)
[18:01:56.033]                           }
[18:01:56.033]                           base::stop(msg)
[18:01:56.033]                         }
[18:01:56.033]                       })
[18:01:56.033]                     }
[18:01:56.033]                     base::local({
[18:01:56.033]                       for (pkg in "future.apply") {
[18:01:56.033]                         base::loadNamespace(pkg)
[18:01:56.033]                         base::library(pkg, character.only = TRUE)
[18:01:56.033]                       }
[18:01:56.033]                     })
[18:01:56.033]                   }
[18:01:56.033]                   ...future.strategy.old <- future::plan("list")
[18:01:56.033]                   options(future.plan = NULL)
[18:01:56.033]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.033]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:56.033]                 }
[18:01:56.033]                 ...future.workdir <- getwd()
[18:01:56.033]             }
[18:01:56.033]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:56.033]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:56.033]         }
[18:01:56.033]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:56.033]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:56.033]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:56.033]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:56.033]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:56.033]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:56.033]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:56.033]             base::names(...future.oldOptions))
[18:01:56.033]     }
[18:01:56.033]     if (FALSE) {
[18:01:56.033]     }
[18:01:56.033]     else {
[18:01:56.033]         if (TRUE) {
[18:01:56.033]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:56.033]                 open = "w")
[18:01:56.033]         }
[18:01:56.033]         else {
[18:01:56.033]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:56.033]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:56.033]         }
[18:01:56.033]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:56.033]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:56.033]             base::sink(type = "output", split = FALSE)
[18:01:56.033]             base::close(...future.stdout)
[18:01:56.033]         }, add = TRUE)
[18:01:56.033]     }
[18:01:56.033]     ...future.frame <- base::sys.nframe()
[18:01:56.033]     ...future.conditions <- base::list()
[18:01:56.033]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:56.033]     if (FALSE) {
[18:01:56.033]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:56.033]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:56.033]     }
[18:01:56.033]     ...future.result <- base::tryCatch({
[18:01:56.033]         base::withCallingHandlers({
[18:01:56.033]             ...future.value <- base::withVisible(base::local({
[18:01:56.033]                 do.call(function(...) {
[18:01:56.033]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.033]                   if (!identical(...future.globals.maxSize.org, 
[18:01:56.033]                     ...future.globals.maxSize)) {
[18:01:56.033]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.033]                     on.exit(options(oopts), add = TRUE)
[18:01:56.033]                   }
[18:01:56.033]                   {
[18:01:56.033]                     lapply(seq_along(...future.elements_ii), 
[18:01:56.033]                       FUN = function(jj) {
[18:01:56.033]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.033]                         ...future.FUN(...future.X_jj, ...)
[18:01:56.033]                       })
[18:01:56.033]                   }
[18:01:56.033]                 }, args = future.call.arguments)
[18:01:56.033]             }))
[18:01:56.033]             future::FutureResult(value = ...future.value$value, 
[18:01:56.033]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.033]                   ...future.rng), globalenv = if (FALSE) 
[18:01:56.033]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:56.033]                     ...future.globalenv.names))
[18:01:56.033]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:56.033]         }, condition = base::local({
[18:01:56.033]             c <- base::c
[18:01:56.033]             inherits <- base::inherits
[18:01:56.033]             invokeRestart <- base::invokeRestart
[18:01:56.033]             length <- base::length
[18:01:56.033]             list <- base::list
[18:01:56.033]             seq.int <- base::seq.int
[18:01:56.033]             signalCondition <- base::signalCondition
[18:01:56.033]             sys.calls <- base::sys.calls
[18:01:56.033]             `[[` <- base::`[[`
[18:01:56.033]             `+` <- base::`+`
[18:01:56.033]             `<<-` <- base::`<<-`
[18:01:56.033]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:56.033]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:56.033]                   3L)]
[18:01:56.033]             }
[18:01:56.033]             function(cond) {
[18:01:56.033]                 is_error <- inherits(cond, "error")
[18:01:56.033]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:56.033]                   NULL)
[18:01:56.033]                 if (is_error) {
[18:01:56.033]                   sessionInformation <- function() {
[18:01:56.033]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:56.033]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:56.033]                       search = base::search(), system = base::Sys.info())
[18:01:56.033]                   }
[18:01:56.033]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.033]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:56.033]                     cond$call), session = sessionInformation(), 
[18:01:56.033]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:56.033]                   signalCondition(cond)
[18:01:56.033]                 }
[18:01:56.033]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:56.033]                 "immediateCondition"))) {
[18:01:56.033]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:56.033]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.033]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:56.033]                   if (TRUE && !signal) {
[18:01:56.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.033]                     {
[18:01:56.033]                       inherits <- base::inherits
[18:01:56.033]                       invokeRestart <- base::invokeRestart
[18:01:56.033]                       is.null <- base::is.null
[18:01:56.033]                       muffled <- FALSE
[18:01:56.033]                       if (inherits(cond, "message")) {
[18:01:56.033]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.033]                         if (muffled) 
[18:01:56.033]                           invokeRestart("muffleMessage")
[18:01:56.033]                       }
[18:01:56.033]                       else if (inherits(cond, "warning")) {
[18:01:56.033]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.033]                         if (muffled) 
[18:01:56.033]                           invokeRestart("muffleWarning")
[18:01:56.033]                       }
[18:01:56.033]                       else if (inherits(cond, "condition")) {
[18:01:56.033]                         if (!is.null(pattern)) {
[18:01:56.033]                           computeRestarts <- base::computeRestarts
[18:01:56.033]                           grepl <- base::grepl
[18:01:56.033]                           restarts <- computeRestarts(cond)
[18:01:56.033]                           for (restart in restarts) {
[18:01:56.033]                             name <- restart$name
[18:01:56.033]                             if (is.null(name)) 
[18:01:56.033]                               next
[18:01:56.033]                             if (!grepl(pattern, name)) 
[18:01:56.033]                               next
[18:01:56.033]                             invokeRestart(restart)
[18:01:56.033]                             muffled <- TRUE
[18:01:56.033]                             break
[18:01:56.033]                           }
[18:01:56.033]                         }
[18:01:56.033]                       }
[18:01:56.033]                       invisible(muffled)
[18:01:56.033]                     }
[18:01:56.033]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.033]                   }
[18:01:56.033]                 }
[18:01:56.033]                 else {
[18:01:56.033]                   if (TRUE) {
[18:01:56.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.033]                     {
[18:01:56.033]                       inherits <- base::inherits
[18:01:56.033]                       invokeRestart <- base::invokeRestart
[18:01:56.033]                       is.null <- base::is.null
[18:01:56.033]                       muffled <- FALSE
[18:01:56.033]                       if (inherits(cond, "message")) {
[18:01:56.033]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.033]                         if (muffled) 
[18:01:56.033]                           invokeRestart("muffleMessage")
[18:01:56.033]                       }
[18:01:56.033]                       else if (inherits(cond, "warning")) {
[18:01:56.033]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.033]                         if (muffled) 
[18:01:56.033]                           invokeRestart("muffleWarning")
[18:01:56.033]                       }
[18:01:56.033]                       else if (inherits(cond, "condition")) {
[18:01:56.033]                         if (!is.null(pattern)) {
[18:01:56.033]                           computeRestarts <- base::computeRestarts
[18:01:56.033]                           grepl <- base::grepl
[18:01:56.033]                           restarts <- computeRestarts(cond)
[18:01:56.033]                           for (restart in restarts) {
[18:01:56.033]                             name <- restart$name
[18:01:56.033]                             if (is.null(name)) 
[18:01:56.033]                               next
[18:01:56.033]                             if (!grepl(pattern, name)) 
[18:01:56.033]                               next
[18:01:56.033]                             invokeRestart(restart)
[18:01:56.033]                             muffled <- TRUE
[18:01:56.033]                             break
[18:01:56.033]                           }
[18:01:56.033]                         }
[18:01:56.033]                       }
[18:01:56.033]                       invisible(muffled)
[18:01:56.033]                     }
[18:01:56.033]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.033]                   }
[18:01:56.033]                 }
[18:01:56.033]             }
[18:01:56.033]         }))
[18:01:56.033]     }, error = function(ex) {
[18:01:56.033]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:56.033]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.033]                 ...future.rng), started = ...future.startTime, 
[18:01:56.033]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:56.033]             version = "1.8"), class = "FutureResult")
[18:01:56.033]     }, finally = {
[18:01:56.033]         if (!identical(...future.workdir, getwd())) 
[18:01:56.033]             setwd(...future.workdir)
[18:01:56.033]         {
[18:01:56.033]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:56.033]                 ...future.oldOptions$nwarnings <- NULL
[18:01:56.033]             }
[18:01:56.033]             base::options(...future.oldOptions)
[18:01:56.033]             if (.Platform$OS.type == "windows") {
[18:01:56.033]                 old_names <- names(...future.oldEnvVars)
[18:01:56.033]                 envs <- base::Sys.getenv()
[18:01:56.033]                 names <- names(envs)
[18:01:56.033]                 common <- intersect(names, old_names)
[18:01:56.033]                 added <- setdiff(names, old_names)
[18:01:56.033]                 removed <- setdiff(old_names, names)
[18:01:56.033]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:56.033]                   envs[common]]
[18:01:56.033]                 NAMES <- toupper(changed)
[18:01:56.033]                 args <- list()
[18:01:56.033]                 for (kk in seq_along(NAMES)) {
[18:01:56.033]                   name <- changed[[kk]]
[18:01:56.033]                   NAME <- NAMES[[kk]]
[18:01:56.033]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.033]                     next
[18:01:56.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.033]                 }
[18:01:56.033]                 NAMES <- toupper(added)
[18:01:56.033]                 for (kk in seq_along(NAMES)) {
[18:01:56.033]                   name <- added[[kk]]
[18:01:56.033]                   NAME <- NAMES[[kk]]
[18:01:56.033]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.033]                     next
[18:01:56.033]                   args[[name]] <- ""
[18:01:56.033]                 }
[18:01:56.033]                 NAMES <- toupper(removed)
[18:01:56.033]                 for (kk in seq_along(NAMES)) {
[18:01:56.033]                   name <- removed[[kk]]
[18:01:56.033]                   NAME <- NAMES[[kk]]
[18:01:56.033]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.033]                     next
[18:01:56.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.033]                 }
[18:01:56.033]                 if (length(args) > 0) 
[18:01:56.033]                   base::do.call(base::Sys.setenv, args = args)
[18:01:56.033]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:56.033]             }
[18:01:56.033]             else {
[18:01:56.033]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:56.033]             }
[18:01:56.033]             {
[18:01:56.033]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:56.033]                   0L) {
[18:01:56.033]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:56.033]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:56.033]                   base::options(opts)
[18:01:56.033]                 }
[18:01:56.033]                 {
[18:01:56.033]                   {
[18:01:56.033]                     NULL
[18:01:56.033]                     RNGkind("Mersenne-Twister")
[18:01:56.033]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:56.033]                       inherits = FALSE)
[18:01:56.033]                   }
[18:01:56.033]                   options(future.plan = NULL)
[18:01:56.033]                   if (is.na(NA_character_)) 
[18:01:56.033]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.033]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:56.033]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:56.033]                     .init = FALSE)
[18:01:56.033]                 }
[18:01:56.033]             }
[18:01:56.033]         }
[18:01:56.033]     })
[18:01:56.033]     if (TRUE) {
[18:01:56.033]         base::sink(type = "output", split = FALSE)
[18:01:56.033]         if (TRUE) {
[18:01:56.033]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:56.033]         }
[18:01:56.033]         else {
[18:01:56.033]             ...future.result["stdout"] <- base::list(NULL)
[18:01:56.033]         }
[18:01:56.033]         base::close(...future.stdout)
[18:01:56.033]         ...future.stdout <- NULL
[18:01:56.033]     }
[18:01:56.033]     ...future.result$conditions <- ...future.conditions
[18:01:56.033]     ...future.result$finished <- base::Sys.time()
[18:01:56.033]     ...future.result
[18:01:56.033] }
[18:01:56.036] assign_globals() ...
[18:01:56.037] List of 11
[18:01:56.037]  $ ...future.FUN            :function (x, ...)  
[18:01:56.037]  $ x_FUN                    :function (x)  
[18:01:56.037]  $ times                    : int 4
[18:01:56.037]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.037]  $ stop_if_not              :function (...)  
[18:01:56.037]  $ dim                      : int [1:2] 2 2
[18:01:56.037]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:56.037]  $ future.call.arguments    : list()
[18:01:56.037]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.037]  $ ...future.elements_ii    :List of 10
[18:01:56.037]   ..$ : int 1
[18:01:56.037]   ..$ : int 2
[18:01:56.037]   ..$ : int 3
[18:01:56.037]   ..$ : int 4
[18:01:56.037]   ..$ : int 5
[18:01:56.037]   ..$ : int 6
[18:01:56.037]   ..$ : int 7
[18:01:56.037]   ..$ : int 8
[18:01:56.037]   ..$ : int 9
[18:01:56.037]   ..$ : int 10
[18:01:56.037]  $ ...future.seeds_ii       : NULL
[18:01:56.037]  $ ...future.globals.maxSize: NULL
[18:01:56.037]  - attr(*, "where")=List of 11
[18:01:56.037]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:56.037]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:56.037]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:56.037]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:56.037]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:56.037]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:56.037]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:56.037]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:56.037]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:56.037]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:56.037]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:56.037]  - attr(*, "resolved")= logi FALSE
[18:01:56.037]  - attr(*, "total_size")= num 97304
[18:01:56.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.037]  - attr(*, "already-done")= logi TRUE
[18:01:56.059] - copied ‘...future.FUN’ to environment
[18:01:56.059] - reassign environment for ‘x_FUN’
[18:01:56.059] - copied ‘x_FUN’ to environment
[18:01:56.060] - copied ‘times’ to environment
[18:01:56.060] - copied ‘stopf’ to environment
[18:01:56.061] - copied ‘stop_if_not’ to environment
[18:01:56.061] - copied ‘dim’ to environment
[18:01:56.061] - copied ‘valid_types’ to environment
[18:01:56.062] - copied ‘future.call.arguments’ to environment
[18:01:56.062] - copied ‘...future.elements_ii’ to environment
[18:01:56.062] - copied ‘...future.seeds_ii’ to environment
[18:01:56.062] - copied ‘...future.globals.maxSize’ to environment
[18:01:56.063] assign_globals() ... done
[18:01:56.063] plan(): Setting new future strategy stack:
[18:01:56.063] List of future strategies:
[18:01:56.063] 1. sequential:
[18:01:56.063]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.063]    - tweaked: FALSE
[18:01:56.063]    - call: NULL
[18:01:56.064] plan(): nbrOfWorkers() = 1
[18:01:56.066] plan(): Setting new future strategy stack:
[18:01:56.066] List of future strategies:
[18:01:56.066] 1. sequential:
[18:01:56.066]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.066]    - tweaked: FALSE
[18:01:56.066]    - call: plan(strategy)
[18:01:56.067] plan(): nbrOfWorkers() = 1
[18:01:56.067] SequentialFuture started (and completed)
[18:01:56.068] - Launch lazy future ... done
[18:01:56.068] run() for ‘SequentialFuture’ ... done
[18:01:56.068] Created future:
[18:01:56.068] SequentialFuture:
[18:01:56.068] Label: ‘future_vapply-1’
[18:01:56.068] Expression:
[18:01:56.068] {
[18:01:56.068]     do.call(function(...) {
[18:01:56.068]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.068]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.068]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.068]             on.exit(options(oopts), add = TRUE)
[18:01:56.068]         }
[18:01:56.068]         {
[18:01:56.068]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.068]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.068]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.068]             })
[18:01:56.068]         }
[18:01:56.068]     }, args = future.call.arguments)
[18:01:56.068] }
[18:01:56.068] Lazy evaluation: FALSE
[18:01:56.068] Asynchronous evaluation: FALSE
[18:01:56.068] Local evaluation: TRUE
[18:01:56.068] Environment: R_GlobalEnv
[18:01:56.068] Capture standard output: TRUE
[18:01:56.068] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:56.068] Globals: 11 objects totaling 95.57 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:56.068] Packages: 1 packages (‘future.apply’)
[18:01:56.068] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:56.068] Resolved: TRUE
[18:01:56.068] Value: 2.27 KiB of class ‘list’
[18:01:56.068] Early signaling: FALSE
[18:01:56.068] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:56.068] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.073] Chunk #1 of 1 ... DONE
[18:01:56.074] Launching 1 futures (chunks) ... DONE
[18:01:56.074] Resolving 1 futures (chunks) ...
[18:01:56.074] resolve() on list ...
[18:01:56.074]  recursive: 0
[18:01:56.074]  length: 1
[18:01:56.075] 
[18:01:56.075] resolved() for ‘SequentialFuture’ ...
[18:01:56.075] - state: ‘finished’
[18:01:56.075] - run: TRUE
[18:01:56.075] - result: ‘FutureResult’
[18:01:56.076] resolved() for ‘SequentialFuture’ ... done
[18:01:56.076] Future #1
[18:01:56.076] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:56.076] - nx: 1
[18:01:56.076] - relay: TRUE
[18:01:56.077] - stdout: TRUE
[18:01:56.077] - signal: TRUE
[18:01:56.077] - resignal: FALSE
[18:01:56.077] - force: TRUE
[18:01:56.077] - relayed: [n=1] FALSE
[18:01:56.077] - queued futures: [n=1] FALSE
[18:01:56.078]  - until=1
[18:01:56.078]  - relaying element #1
[18:01:56.078] - relayed: [n=1] TRUE
[18:01:56.078] - queued futures: [n=1] TRUE
[18:01:56.079] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:56.079]  length: 0 (resolved future 1)
[18:01:56.079] Relaying remaining futures
[18:01:56.079] signalConditionsASAP(NULL, pos=0) ...
[18:01:56.079] - nx: 1
[18:01:56.079] - relay: TRUE
[18:01:56.080] - stdout: TRUE
[18:01:56.080] - signal: TRUE
[18:01:56.080] - resignal: FALSE
[18:01:56.080] - force: TRUE
[18:01:56.080] - relayed: [n=1] TRUE
[18:01:56.081] - queued futures: [n=1] TRUE
 - flush all
[18:01:56.081] - relayed: [n=1] TRUE
[18:01:56.081] - queued futures: [n=1] TRUE
[18:01:56.081] signalConditionsASAP(NULL, pos=0) ... done
[18:01:56.081] resolve() on list ... DONE
[18:01:56.082]  - Number of value chunks collected: 1
[18:01:56.082] Resolving 1 futures (chunks) ... DONE
[18:01:56.082] Reducing values from 1 chunks ...
[18:01:56.082]  - Number of values collected after concatenation: 10
[18:01:56.083]  - Number of values expected: 10
[18:01:56.083] Reducing values from 1 chunks ... DONE
[18:01:56.083] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[18:01:56.087] future_lapply() ...
[18:01:56.091] Number of chunks: 1
[18:01:56.091] getGlobalsAndPackagesXApply() ...
[18:01:56.091]  - future.globals: TRUE
[18:01:56.091] getGlobalsAndPackages() ...
[18:01:56.092] Searching for globals...
[18:01:56.100] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[18:01:56.101] Searching for globals ... DONE
[18:01:56.101] Resolving globals: FALSE
[18:01:56.103] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[18:01:56.104] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:56.104] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:56.105] - packages: [1] ‘future.apply’
[18:01:56.105] getGlobalsAndPackages() ... DONE
[18:01:56.105]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:56.105]  - needed namespaces: [n=1] ‘future.apply’
[18:01:56.106] Finding globals ... DONE
[18:01:56.106]  - use_args: TRUE
[18:01:56.106]  - Getting '...' globals ...
[18:01:56.107] resolve() on list ...
[18:01:56.107]  recursive: 0
[18:01:56.107]  length: 1
[18:01:56.107]  elements: ‘...’
[18:01:56.108]  length: 0 (resolved future 1)
[18:01:56.108] resolve() on list ... DONE
[18:01:56.108]    - '...' content: [n=0] 
[18:01:56.108] List of 1
[18:01:56.108]  $ ...: list()
[18:01:56.108]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.108]  - attr(*, "where")=List of 1
[18:01:56.108]   ..$ ...:<environment: 0x6183bee6ae40> 
[18:01:56.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.108]  - attr(*, "resolved")= logi TRUE
[18:01:56.108]  - attr(*, "total_size")= num NA
[18:01:56.114]  - Getting '...' globals ... DONE
[18:01:56.114] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:56.114] List of 8
[18:01:56.114]  $ ...future.FUN:function (x, ...)  
[18:01:56.114]  $ x_FUN        :function (x)  
[18:01:56.114]  $ times        : int 4
[18:01:56.114]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.114]  $ stop_if_not  :function (...)  
[18:01:56.114]  $ dim          : int [1:2] 2 2
[18:01:56.114]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:56.114]  $ ...          : list()
[18:01:56.114]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.114]  - attr(*, "where")=List of 8
[18:01:56.114]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:56.114]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:56.114]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:56.114]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:56.114]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:56.114]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:56.114]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:56.114]   ..$ ...          :<environment: 0x6183bee6ae40> 
[18:01:56.114]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.114]  - attr(*, "resolved")= logi FALSE
[18:01:56.114]  - attr(*, "total_size")= num 105552
[18:01:56.157] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:56.157] getGlobalsAndPackagesXApply() ... DONE
[18:01:56.158] Number of futures (= number of chunks): 1
[18:01:56.158] Launching 1 futures (chunks) ...
[18:01:56.158] Chunk #1 of 1 ...
[18:01:56.158]  - Finding globals in 'X' for chunk #1 ...
[18:01:56.159] getGlobalsAndPackages() ...
[18:01:56.159] Searching for globals...
[18:01:56.159] 
[18:01:56.159] Searching for globals ... DONE
[18:01:56.160] - globals: [0] <none>
[18:01:56.160] getGlobalsAndPackages() ... DONE
[18:01:56.160]    + additional globals found: [n=0] 
[18:01:56.160]    + additional namespaces needed: [n=0] 
[18:01:56.160]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:56.161]  - seeds: <none>
[18:01:56.161]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.161] getGlobalsAndPackages() ...
[18:01:56.161] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.161] Resolving globals: FALSE
[18:01:56.162] Tweak future expression to call with '...' arguments ...
[18:01:56.162] {
[18:01:56.162]     do.call(function(...) {
[18:01:56.162]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.162]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.162]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.162]             on.exit(options(oopts), add = TRUE)
[18:01:56.162]         }
[18:01:56.162]         {
[18:01:56.162]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.162]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.162]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.162]             })
[18:01:56.162]         }
[18:01:56.162]     }, args = future.call.arguments)
[18:01:56.162] }
[18:01:56.162] Tweak future expression to call with '...' arguments ... DONE
[18:01:56.163] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.164] - packages: [1] ‘future.apply’
[18:01:56.164] getGlobalsAndPackages() ... DONE
[18:01:56.164] run() for ‘Future’ ...
[18:01:56.165] - state: ‘created’
[18:01:56.165] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:56.165] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.166] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:56.166]   - Field: ‘label’
[18:01:56.166]   - Field: ‘local’
[18:01:56.166]   - Field: ‘owner’
[18:01:56.167]   - Field: ‘envir’
[18:01:56.167]   - Field: ‘packages’
[18:01:56.167]   - Field: ‘gc’
[18:01:56.167]   - Field: ‘conditions’
[18:01:56.167]   - Field: ‘expr’
[18:01:56.168]   - Field: ‘uuid’
[18:01:56.168]   - Field: ‘seed’
[18:01:56.168]   - Field: ‘version’
[18:01:56.168]   - Field: ‘result’
[18:01:56.168]   - Field: ‘asynchronous’
[18:01:56.169]   - Field: ‘calls’
[18:01:56.169]   - Field: ‘globals’
[18:01:56.169]   - Field: ‘stdout’
[18:01:56.169]   - Field: ‘earlySignal’
[18:01:56.169]   - Field: ‘lazy’
[18:01:56.169]   - Field: ‘state’
[18:01:56.170] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:56.170] - Launch lazy future ...
[18:01:56.170] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:56.171] Packages needed by future strategies (n = 0): <none>
[18:01:56.172] {
[18:01:56.172]     {
[18:01:56.172]         {
[18:01:56.172]             ...future.startTime <- base::Sys.time()
[18:01:56.172]             {
[18:01:56.172]                 {
[18:01:56.172]                   {
[18:01:56.172]                     {
[18:01:56.172]                       base::local({
[18:01:56.172]                         has_future <- base::requireNamespace("future", 
[18:01:56.172]                           quietly = TRUE)
[18:01:56.172]                         if (has_future) {
[18:01:56.172]                           ns <- base::getNamespace("future")
[18:01:56.172]                           version <- ns[[".package"]][["version"]]
[18:01:56.172]                           if (is.null(version)) 
[18:01:56.172]                             version <- utils::packageVersion("future")
[18:01:56.172]                         }
[18:01:56.172]                         else {
[18:01:56.172]                           version <- NULL
[18:01:56.172]                         }
[18:01:56.172]                         if (!has_future || version < "1.8.0") {
[18:01:56.172]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:56.172]                             "", base::R.version$version.string), 
[18:01:56.172]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:56.172]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:56.172]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:56.172]                               "release", "version")], collapse = " "), 
[18:01:56.172]                             hostname = base::Sys.info()[["nodename"]])
[18:01:56.172]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:56.172]                             info)
[18:01:56.172]                           info <- base::paste(info, collapse = "; ")
[18:01:56.172]                           if (!has_future) {
[18:01:56.172]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:56.172]                               info)
[18:01:56.172]                           }
[18:01:56.172]                           else {
[18:01:56.172]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:56.172]                               info, version)
[18:01:56.172]                           }
[18:01:56.172]                           base::stop(msg)
[18:01:56.172]                         }
[18:01:56.172]                       })
[18:01:56.172]                     }
[18:01:56.172]                     base::local({
[18:01:56.172]                       for (pkg in "future.apply") {
[18:01:56.172]                         base::loadNamespace(pkg)
[18:01:56.172]                         base::library(pkg, character.only = TRUE)
[18:01:56.172]                       }
[18:01:56.172]                     })
[18:01:56.172]                   }
[18:01:56.172]                   ...future.strategy.old <- future::plan("list")
[18:01:56.172]                   options(future.plan = NULL)
[18:01:56.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:56.172]                 }
[18:01:56.172]                 ...future.workdir <- getwd()
[18:01:56.172]             }
[18:01:56.172]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:56.172]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:56.172]         }
[18:01:56.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:56.172]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:56.172]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:56.172]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:56.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:56.172]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:56.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:56.172]             base::names(...future.oldOptions))
[18:01:56.172]     }
[18:01:56.172]     if (FALSE) {
[18:01:56.172]     }
[18:01:56.172]     else {
[18:01:56.172]         if (TRUE) {
[18:01:56.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:56.172]                 open = "w")
[18:01:56.172]         }
[18:01:56.172]         else {
[18:01:56.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:56.172]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:56.172]         }
[18:01:56.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:56.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:56.172]             base::sink(type = "output", split = FALSE)
[18:01:56.172]             base::close(...future.stdout)
[18:01:56.172]         }, add = TRUE)
[18:01:56.172]     }
[18:01:56.172]     ...future.frame <- base::sys.nframe()
[18:01:56.172]     ...future.conditions <- base::list()
[18:01:56.172]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:56.172]     if (FALSE) {
[18:01:56.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:56.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:56.172]     }
[18:01:56.172]     ...future.result <- base::tryCatch({
[18:01:56.172]         base::withCallingHandlers({
[18:01:56.172]             ...future.value <- base::withVisible(base::local({
[18:01:56.172]                 do.call(function(...) {
[18:01:56.172]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.172]                   if (!identical(...future.globals.maxSize.org, 
[18:01:56.172]                     ...future.globals.maxSize)) {
[18:01:56.172]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.172]                     on.exit(options(oopts), add = TRUE)
[18:01:56.172]                   }
[18:01:56.172]                   {
[18:01:56.172]                     lapply(seq_along(...future.elements_ii), 
[18:01:56.172]                       FUN = function(jj) {
[18:01:56.172]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.172]                         ...future.FUN(...future.X_jj, ...)
[18:01:56.172]                       })
[18:01:56.172]                   }
[18:01:56.172]                 }, args = future.call.arguments)
[18:01:56.172]             }))
[18:01:56.172]             future::FutureResult(value = ...future.value$value, 
[18:01:56.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.172]                   ...future.rng), globalenv = if (FALSE) 
[18:01:56.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:56.172]                     ...future.globalenv.names))
[18:01:56.172]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:56.172]         }, condition = base::local({
[18:01:56.172]             c <- base::c
[18:01:56.172]             inherits <- base::inherits
[18:01:56.172]             invokeRestart <- base::invokeRestart
[18:01:56.172]             length <- base::length
[18:01:56.172]             list <- base::list
[18:01:56.172]             seq.int <- base::seq.int
[18:01:56.172]             signalCondition <- base::signalCondition
[18:01:56.172]             sys.calls <- base::sys.calls
[18:01:56.172]             `[[` <- base::`[[`
[18:01:56.172]             `+` <- base::`+`
[18:01:56.172]             `<<-` <- base::`<<-`
[18:01:56.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:56.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:56.172]                   3L)]
[18:01:56.172]             }
[18:01:56.172]             function(cond) {
[18:01:56.172]                 is_error <- inherits(cond, "error")
[18:01:56.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:56.172]                   NULL)
[18:01:56.172]                 if (is_error) {
[18:01:56.172]                   sessionInformation <- function() {
[18:01:56.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:56.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:56.172]                       search = base::search(), system = base::Sys.info())
[18:01:56.172]                   }
[18:01:56.172]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:56.172]                     cond$call), session = sessionInformation(), 
[18:01:56.172]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:56.172]                   signalCondition(cond)
[18:01:56.172]                 }
[18:01:56.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:56.172]                 "immediateCondition"))) {
[18:01:56.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:56.172]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:56.172]                   if (TRUE && !signal) {
[18:01:56.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.172]                     {
[18:01:56.172]                       inherits <- base::inherits
[18:01:56.172]                       invokeRestart <- base::invokeRestart
[18:01:56.172]                       is.null <- base::is.null
[18:01:56.172]                       muffled <- FALSE
[18:01:56.172]                       if (inherits(cond, "message")) {
[18:01:56.172]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.172]                         if (muffled) 
[18:01:56.172]                           invokeRestart("muffleMessage")
[18:01:56.172]                       }
[18:01:56.172]                       else if (inherits(cond, "warning")) {
[18:01:56.172]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.172]                         if (muffled) 
[18:01:56.172]                           invokeRestart("muffleWarning")
[18:01:56.172]                       }
[18:01:56.172]                       else if (inherits(cond, "condition")) {
[18:01:56.172]                         if (!is.null(pattern)) {
[18:01:56.172]                           computeRestarts <- base::computeRestarts
[18:01:56.172]                           grepl <- base::grepl
[18:01:56.172]                           restarts <- computeRestarts(cond)
[18:01:56.172]                           for (restart in restarts) {
[18:01:56.172]                             name <- restart$name
[18:01:56.172]                             if (is.null(name)) 
[18:01:56.172]                               next
[18:01:56.172]                             if (!grepl(pattern, name)) 
[18:01:56.172]                               next
[18:01:56.172]                             invokeRestart(restart)
[18:01:56.172]                             muffled <- TRUE
[18:01:56.172]                             break
[18:01:56.172]                           }
[18:01:56.172]                         }
[18:01:56.172]                       }
[18:01:56.172]                       invisible(muffled)
[18:01:56.172]                     }
[18:01:56.172]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.172]                   }
[18:01:56.172]                 }
[18:01:56.172]                 else {
[18:01:56.172]                   if (TRUE) {
[18:01:56.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.172]                     {
[18:01:56.172]                       inherits <- base::inherits
[18:01:56.172]                       invokeRestart <- base::invokeRestart
[18:01:56.172]                       is.null <- base::is.null
[18:01:56.172]                       muffled <- FALSE
[18:01:56.172]                       if (inherits(cond, "message")) {
[18:01:56.172]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.172]                         if (muffled) 
[18:01:56.172]                           invokeRestart("muffleMessage")
[18:01:56.172]                       }
[18:01:56.172]                       else if (inherits(cond, "warning")) {
[18:01:56.172]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.172]                         if (muffled) 
[18:01:56.172]                           invokeRestart("muffleWarning")
[18:01:56.172]                       }
[18:01:56.172]                       else if (inherits(cond, "condition")) {
[18:01:56.172]                         if (!is.null(pattern)) {
[18:01:56.172]                           computeRestarts <- base::computeRestarts
[18:01:56.172]                           grepl <- base::grepl
[18:01:56.172]                           restarts <- computeRestarts(cond)
[18:01:56.172]                           for (restart in restarts) {
[18:01:56.172]                             name <- restart$name
[18:01:56.172]                             if (is.null(name)) 
[18:01:56.172]                               next
[18:01:56.172]                             if (!grepl(pattern, name)) 
[18:01:56.172]                               next
[18:01:56.172]                             invokeRestart(restart)
[18:01:56.172]                             muffled <- TRUE
[18:01:56.172]                             break
[18:01:56.172]                           }
[18:01:56.172]                         }
[18:01:56.172]                       }
[18:01:56.172]                       invisible(muffled)
[18:01:56.172]                     }
[18:01:56.172]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.172]                   }
[18:01:56.172]                 }
[18:01:56.172]             }
[18:01:56.172]         }))
[18:01:56.172]     }, error = function(ex) {
[18:01:56.172]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:56.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.172]                 ...future.rng), started = ...future.startTime, 
[18:01:56.172]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:56.172]             version = "1.8"), class = "FutureResult")
[18:01:56.172]     }, finally = {
[18:01:56.172]         if (!identical(...future.workdir, getwd())) 
[18:01:56.172]             setwd(...future.workdir)
[18:01:56.172]         {
[18:01:56.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:56.172]                 ...future.oldOptions$nwarnings <- NULL
[18:01:56.172]             }
[18:01:56.172]             base::options(...future.oldOptions)
[18:01:56.172]             if (.Platform$OS.type == "windows") {
[18:01:56.172]                 old_names <- names(...future.oldEnvVars)
[18:01:56.172]                 envs <- base::Sys.getenv()
[18:01:56.172]                 names <- names(envs)
[18:01:56.172]                 common <- intersect(names, old_names)
[18:01:56.172]                 added <- setdiff(names, old_names)
[18:01:56.172]                 removed <- setdiff(old_names, names)
[18:01:56.172]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:56.172]                   envs[common]]
[18:01:56.172]                 NAMES <- toupper(changed)
[18:01:56.172]                 args <- list()
[18:01:56.172]                 for (kk in seq_along(NAMES)) {
[18:01:56.172]                   name <- changed[[kk]]
[18:01:56.172]                   NAME <- NAMES[[kk]]
[18:01:56.172]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.172]                     next
[18:01:56.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.172]                 }
[18:01:56.172]                 NAMES <- toupper(added)
[18:01:56.172]                 for (kk in seq_along(NAMES)) {
[18:01:56.172]                   name <- added[[kk]]
[18:01:56.172]                   NAME <- NAMES[[kk]]
[18:01:56.172]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.172]                     next
[18:01:56.172]                   args[[name]] <- ""
[18:01:56.172]                 }
[18:01:56.172]                 NAMES <- toupper(removed)
[18:01:56.172]                 for (kk in seq_along(NAMES)) {
[18:01:56.172]                   name <- removed[[kk]]
[18:01:56.172]                   NAME <- NAMES[[kk]]
[18:01:56.172]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.172]                     next
[18:01:56.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.172]                 }
[18:01:56.172]                 if (length(args) > 0) 
[18:01:56.172]                   base::do.call(base::Sys.setenv, args = args)
[18:01:56.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:56.172]             }
[18:01:56.172]             else {
[18:01:56.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:56.172]             }
[18:01:56.172]             {
[18:01:56.172]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:56.172]                   0L) {
[18:01:56.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:56.172]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:56.172]                   base::options(opts)
[18:01:56.172]                 }
[18:01:56.172]                 {
[18:01:56.172]                   {
[18:01:56.172]                     NULL
[18:01:56.172]                     RNGkind("Mersenne-Twister")
[18:01:56.172]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:56.172]                       inherits = FALSE)
[18:01:56.172]                   }
[18:01:56.172]                   options(future.plan = NULL)
[18:01:56.172]                   if (is.na(NA_character_)) 
[18:01:56.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:56.172]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:56.172]                     .init = FALSE)
[18:01:56.172]                 }
[18:01:56.172]             }
[18:01:56.172]         }
[18:01:56.172]     })
[18:01:56.172]     if (TRUE) {
[18:01:56.172]         base::sink(type = "output", split = FALSE)
[18:01:56.172]         if (TRUE) {
[18:01:56.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:56.172]         }
[18:01:56.172]         else {
[18:01:56.172]             ...future.result["stdout"] <- base::list(NULL)
[18:01:56.172]         }
[18:01:56.172]         base::close(...future.stdout)
[18:01:56.172]         ...future.stdout <- NULL
[18:01:56.172]     }
[18:01:56.172]     ...future.result$conditions <- ...future.conditions
[18:01:56.172]     ...future.result$finished <- base::Sys.time()
[18:01:56.172]     ...future.result
[18:01:56.172] }
[18:01:56.175] assign_globals() ...
[18:01:56.175] List of 11
[18:01:56.175]  $ ...future.FUN            :function (x, ...)  
[18:01:56.175]  $ x_FUN                    :function (x)  
[18:01:56.175]  $ times                    : int 4
[18:01:56.175]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.175]  $ stop_if_not              :function (...)  
[18:01:56.175]  $ dim                      : int [1:2] 2 2
[18:01:56.175]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:56.175]  $ future.call.arguments    : list()
[18:01:56.175]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.175]  $ ...future.elements_ii    :List of 10
[18:01:56.175]   ..$ : int 1
[18:01:56.175]   ..$ : int 2
[18:01:56.175]   ..$ : int 3
[18:01:56.175]   ..$ : int 4
[18:01:56.175]   ..$ : int 5
[18:01:56.175]   ..$ : int 6
[18:01:56.175]   ..$ : int 7
[18:01:56.175]   ..$ : int 8
[18:01:56.175]   ..$ : int 9
[18:01:56.175]   ..$ : int 10
[18:01:56.175]  $ ...future.seeds_ii       : NULL
[18:01:56.175]  $ ...future.globals.maxSize: NULL
[18:01:56.175]  - attr(*, "where")=List of 11
[18:01:56.175]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:56.175]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:56.175]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:56.175]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:56.175]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:56.175]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:56.175]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:56.175]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:56.175]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:56.175]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:56.175]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:56.175]  - attr(*, "resolved")= logi FALSE
[18:01:56.175]  - attr(*, "total_size")= num 105552
[18:01:56.175]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.175]  - attr(*, "already-done")= logi TRUE
[18:01:56.195] - copied ‘...future.FUN’ to environment
[18:01:56.196] - reassign environment for ‘x_FUN’
[18:01:56.196] - copied ‘x_FUN’ to environment
[18:01:56.196] - copied ‘times’ to environment
[18:01:56.196] - copied ‘stopf’ to environment
[18:01:56.196] - copied ‘stop_if_not’ to environment
[18:01:56.197] - copied ‘dim’ to environment
[18:01:56.197] - copied ‘valid_types’ to environment
[18:01:56.197] - copied ‘future.call.arguments’ to environment
[18:01:56.197] - copied ‘...future.elements_ii’ to environment
[18:01:56.197] - copied ‘...future.seeds_ii’ to environment
[18:01:56.198] - copied ‘...future.globals.maxSize’ to environment
[18:01:56.198] assign_globals() ... done
[18:01:56.199] plan(): Setting new future strategy stack:
[18:01:56.199] List of future strategies:
[18:01:56.199] 1. sequential:
[18:01:56.199]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.199]    - tweaked: FALSE
[18:01:56.199]    - call: NULL
[18:01:56.202] plan(): nbrOfWorkers() = 1
[18:01:56.204] plan(): Setting new future strategy stack:
[18:01:56.204] List of future strategies:
[18:01:56.204] 1. sequential:
[18:01:56.204]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.204]    - tweaked: FALSE
[18:01:56.204]    - call: plan(strategy)
[18:01:56.205] plan(): nbrOfWorkers() = 1
[18:01:56.205] SequentialFuture started (and completed)
[18:01:56.205] - Launch lazy future ... done
[18:01:56.206] run() for ‘SequentialFuture’ ... done
[18:01:56.206] Created future:
[18:01:56.206] SequentialFuture:
[18:01:56.206] Label: ‘future_vapply-1’
[18:01:56.206] Expression:
[18:01:56.206] {
[18:01:56.206]     do.call(function(...) {
[18:01:56.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.206]             on.exit(options(oopts), add = TRUE)
[18:01:56.206]         }
[18:01:56.206]         {
[18:01:56.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.206]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.206]             })
[18:01:56.206]         }
[18:01:56.206]     }, args = future.call.arguments)
[18:01:56.206] }
[18:01:56.206] Lazy evaluation: FALSE
[18:01:56.206] Asynchronous evaluation: FALSE
[18:01:56.206] Local evaluation: TRUE
[18:01:56.206] Environment: R_GlobalEnv
[18:01:56.206] Capture standard output: TRUE
[18:01:56.206] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:56.206] Globals: 11 objects totaling 103.62 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:56.206] Packages: 1 packages (‘future.apply’)
[18:01:56.206] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:56.206] Resolved: TRUE
[18:01:56.206] Value: 7.42 KiB of class ‘list’
[18:01:56.206] Early signaling: FALSE
[18:01:56.206] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:56.206] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.209] Chunk #1 of 1 ... DONE
[18:01:56.209] Launching 1 futures (chunks) ... DONE
[18:01:56.209] Resolving 1 futures (chunks) ...
[18:01:56.209] resolve() on list ...
[18:01:56.209]  recursive: 0
[18:01:56.210]  length: 1
[18:01:56.210] 
[18:01:56.210] resolved() for ‘SequentialFuture’ ...
[18:01:56.210] - state: ‘finished’
[18:01:56.210] - run: TRUE
[18:01:56.211] - result: ‘FutureResult’
[18:01:56.211] resolved() for ‘SequentialFuture’ ... done
[18:01:56.211] Future #1
[18:01:56.211] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:56.211] - nx: 1
[18:01:56.212] - relay: TRUE
[18:01:56.212] - stdout: TRUE
[18:01:56.212] - signal: TRUE
[18:01:56.212] - resignal: FALSE
[18:01:56.212] - force: TRUE
[18:01:56.212] - relayed: [n=1] FALSE
[18:01:56.213] - queued futures: [n=1] FALSE
[18:01:56.213]  - until=1
[18:01:56.213]  - relaying element #1
[18:01:56.213] - relayed: [n=1] TRUE
[18:01:56.214] - queued futures: [n=1] TRUE
[18:01:56.214] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:56.214]  length: 0 (resolved future 1)
[18:01:56.214] Relaying remaining futures
[18:01:56.214] signalConditionsASAP(NULL, pos=0) ...
[18:01:56.215] - nx: 1
[18:01:56.215] - relay: TRUE
[18:01:56.215] - stdout: TRUE
[18:01:56.215] - signal: TRUE
[18:01:56.215] - resignal: FALSE
[18:01:56.215] - force: TRUE
[18:01:56.216] - relayed: [n=1] TRUE
[18:01:56.216] - queued futures: [n=1] TRUE
 - flush all
[18:01:56.216] - relayed: [n=1] TRUE
[18:01:56.216] - queued futures: [n=1] TRUE
[18:01:56.216] signalConditionsASAP(NULL, pos=0) ... done
[18:01:56.217] resolve() on list ... DONE
[18:01:56.217]  - Number of value chunks collected: 1
[18:01:56.217] Resolving 1 futures (chunks) ... DONE
[18:01:56.217] Reducing values from 1 chunks ...
[18:01:56.217]  - Number of values collected after concatenation: 10
[18:01:56.218]  - Number of values expected: 10
[18:01:56.218] Reducing values from 1 chunks ... DONE
[18:01:56.218] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[18:01:56.225] future_lapply() ...
[18:01:56.229] Number of chunks: 1
[18:01:56.229] getGlobalsAndPackagesXApply() ...
[18:01:56.229]  - future.globals: TRUE
[18:01:56.230] getGlobalsAndPackages() ...
[18:01:56.230] Searching for globals...
[18:01:56.237] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[18:01:56.237] Searching for globals ... DONE
[18:01:56.237] Resolving globals: FALSE
[18:01:56.239] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[18:01:56.240] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:56.240] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:56.240] - packages: [2] ‘stats’, ‘future.apply’
[18:01:56.241] getGlobalsAndPackages() ... DONE
[18:01:56.241]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:56.241]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[18:01:56.241] Finding globals ... DONE
[18:01:56.241]  - use_args: TRUE
[18:01:56.242]  - Getting '...' globals ...
[18:01:56.242] resolve() on list ...
[18:01:56.242]  recursive: 0
[18:01:56.243]  length: 1
[18:01:56.243]  elements: ‘...’
[18:01:56.243]  length: 0 (resolved future 1)
[18:01:56.243] resolve() on list ... DONE
[18:01:56.243]    - '...' content: [n=0] 
[18:01:56.244] List of 1
[18:01:56.244]  $ ...: list()
[18:01:56.244]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.244]  - attr(*, "where")=List of 1
[18:01:56.244]   ..$ ...:<environment: 0x6183c025cf50> 
[18:01:56.244]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.244]  - attr(*, "resolved")= logi TRUE
[18:01:56.244]  - attr(*, "total_size")= num NA
[18:01:56.249]  - Getting '...' globals ... DONE
[18:01:56.249] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:56.249] List of 8
[18:01:56.249]  $ ...future.FUN:function (x, ...)  
[18:01:56.249]  $ x_FUN        :function (x, ...)  
[18:01:56.249]  $ times        : int 5
[18:01:56.249]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.249]  $ stop_if_not  :function (...)  
[18:01:56.249]  $ dim          : NULL
[18:01:56.249]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:56.249]  $ ...          : list()
[18:01:56.249]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.249]  - attr(*, "where")=List of 8
[18:01:56.249]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:56.249]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:56.249]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:56.249]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:56.249]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:56.249]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:56.249]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:56.249]   ..$ ...          :<environment: 0x6183c025cf50> 
[18:01:56.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.249]  - attr(*, "resolved")= logi FALSE
[18:01:56.249]  - attr(*, "total_size")= num 95528
[18:01:56.263] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[18:01:56.263] getGlobalsAndPackagesXApply() ... DONE
[18:01:56.263] Number of futures (= number of chunks): 1
[18:01:56.264] Launching 1 futures (chunks) ...
[18:01:56.264] Chunk #1 of 1 ...
[18:01:56.264]  - Finding globals in 'X' for chunk #1 ...
[18:01:56.264] getGlobalsAndPackages() ...
[18:01:56.264] Searching for globals...
[18:01:56.265] 
[18:01:56.265] Searching for globals ... DONE
[18:01:56.265] - globals: [0] <none>
[18:01:56.266] getGlobalsAndPackages() ... DONE
[18:01:56.266]    + additional globals found: [n=0] 
[18:01:56.266]    + additional namespaces needed: [n=0] 
[18:01:56.266]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:56.266]  - seeds: <none>
[18:01:56.267]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.267] getGlobalsAndPackages() ...
[18:01:56.267] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.267] Resolving globals: FALSE
[18:01:56.267] Tweak future expression to call with '...' arguments ...
[18:01:56.268] {
[18:01:56.268]     do.call(function(...) {
[18:01:56.268]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.268]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.268]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.268]             on.exit(options(oopts), add = TRUE)
[18:01:56.268]         }
[18:01:56.268]         {
[18:01:56.268]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.268]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.268]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.268]             })
[18:01:56.268]         }
[18:01:56.268]     }, args = future.call.arguments)
[18:01:56.268] }
[18:01:56.268] Tweak future expression to call with '...' arguments ... DONE
[18:01:56.269] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.270] - packages: [2] ‘stats’, ‘future.apply’
[18:01:56.270] getGlobalsAndPackages() ... DONE
[18:01:56.270] run() for ‘Future’ ...
[18:01:56.270] - state: ‘created’
[18:01:56.271] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:56.271] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.271] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:56.272]   - Field: ‘label’
[18:01:56.272]   - Field: ‘local’
[18:01:56.272]   - Field: ‘owner’
[18:01:56.272]   - Field: ‘envir’
[18:01:56.273]   - Field: ‘packages’
[18:01:56.273]   - Field: ‘gc’
[18:01:56.273]   - Field: ‘conditions’
[18:01:56.273]   - Field: ‘expr’
[18:01:56.273]   - Field: ‘uuid’
[18:01:56.274]   - Field: ‘seed’
[18:01:56.274]   - Field: ‘version’
[18:01:56.274]   - Field: ‘result’
[18:01:56.274]   - Field: ‘asynchronous’
[18:01:56.274]   - Field: ‘calls’
[18:01:56.274]   - Field: ‘globals’
[18:01:56.275]   - Field: ‘stdout’
[18:01:56.275]   - Field: ‘earlySignal’
[18:01:56.275]   - Field: ‘lazy’
[18:01:56.275]   - Field: ‘state’
[18:01:56.275] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:56.276] - Launch lazy future ...
[18:01:56.276] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[18:01:56.276] Packages needed by future strategies (n = 0): <none>
[18:01:56.277] {
[18:01:56.277]     {
[18:01:56.277]         {
[18:01:56.277]             ...future.startTime <- base::Sys.time()
[18:01:56.277]             {
[18:01:56.277]                 {
[18:01:56.277]                   {
[18:01:56.277]                     {
[18:01:56.277]                       base::local({
[18:01:56.277]                         has_future <- base::requireNamespace("future", 
[18:01:56.277]                           quietly = TRUE)
[18:01:56.277]                         if (has_future) {
[18:01:56.277]                           ns <- base::getNamespace("future")
[18:01:56.277]                           version <- ns[[".package"]][["version"]]
[18:01:56.277]                           if (is.null(version)) 
[18:01:56.277]                             version <- utils::packageVersion("future")
[18:01:56.277]                         }
[18:01:56.277]                         else {
[18:01:56.277]                           version <- NULL
[18:01:56.277]                         }
[18:01:56.277]                         if (!has_future || version < "1.8.0") {
[18:01:56.277]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:56.277]                             "", base::R.version$version.string), 
[18:01:56.277]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:56.277]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:56.277]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:56.277]                               "release", "version")], collapse = " "), 
[18:01:56.277]                             hostname = base::Sys.info()[["nodename"]])
[18:01:56.277]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:56.277]                             info)
[18:01:56.277]                           info <- base::paste(info, collapse = "; ")
[18:01:56.277]                           if (!has_future) {
[18:01:56.277]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:56.277]                               info)
[18:01:56.277]                           }
[18:01:56.277]                           else {
[18:01:56.277]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:56.277]                               info, version)
[18:01:56.277]                           }
[18:01:56.277]                           base::stop(msg)
[18:01:56.277]                         }
[18:01:56.277]                       })
[18:01:56.277]                     }
[18:01:56.277]                     base::local({
[18:01:56.277]                       for (pkg in c("stats", "future.apply")) {
[18:01:56.277]                         base::loadNamespace(pkg)
[18:01:56.277]                         base::library(pkg, character.only = TRUE)
[18:01:56.277]                       }
[18:01:56.277]                     })
[18:01:56.277]                   }
[18:01:56.277]                   ...future.strategy.old <- future::plan("list")
[18:01:56.277]                   options(future.plan = NULL)
[18:01:56.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:56.277]                 }
[18:01:56.277]                 ...future.workdir <- getwd()
[18:01:56.277]             }
[18:01:56.277]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:56.277]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:56.277]         }
[18:01:56.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:56.277]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:56.277]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:56.277]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:56.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:56.277]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:56.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:56.277]             base::names(...future.oldOptions))
[18:01:56.277]     }
[18:01:56.277]     if (FALSE) {
[18:01:56.277]     }
[18:01:56.277]     else {
[18:01:56.277]         if (TRUE) {
[18:01:56.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:56.277]                 open = "w")
[18:01:56.277]         }
[18:01:56.277]         else {
[18:01:56.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:56.277]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:56.277]         }
[18:01:56.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:56.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:56.277]             base::sink(type = "output", split = FALSE)
[18:01:56.277]             base::close(...future.stdout)
[18:01:56.277]         }, add = TRUE)
[18:01:56.277]     }
[18:01:56.277]     ...future.frame <- base::sys.nframe()
[18:01:56.277]     ...future.conditions <- base::list()
[18:01:56.277]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:56.277]     if (FALSE) {
[18:01:56.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:56.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:56.277]     }
[18:01:56.277]     ...future.result <- base::tryCatch({
[18:01:56.277]         base::withCallingHandlers({
[18:01:56.277]             ...future.value <- base::withVisible(base::local({
[18:01:56.277]                 do.call(function(...) {
[18:01:56.277]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.277]                   if (!identical(...future.globals.maxSize.org, 
[18:01:56.277]                     ...future.globals.maxSize)) {
[18:01:56.277]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.277]                     on.exit(options(oopts), add = TRUE)
[18:01:56.277]                   }
[18:01:56.277]                   {
[18:01:56.277]                     lapply(seq_along(...future.elements_ii), 
[18:01:56.277]                       FUN = function(jj) {
[18:01:56.277]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.277]                         ...future.FUN(...future.X_jj, ...)
[18:01:56.277]                       })
[18:01:56.277]                   }
[18:01:56.277]                 }, args = future.call.arguments)
[18:01:56.277]             }))
[18:01:56.277]             future::FutureResult(value = ...future.value$value, 
[18:01:56.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.277]                   ...future.rng), globalenv = if (FALSE) 
[18:01:56.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:56.277]                     ...future.globalenv.names))
[18:01:56.277]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:56.277]         }, condition = base::local({
[18:01:56.277]             c <- base::c
[18:01:56.277]             inherits <- base::inherits
[18:01:56.277]             invokeRestart <- base::invokeRestart
[18:01:56.277]             length <- base::length
[18:01:56.277]             list <- base::list
[18:01:56.277]             seq.int <- base::seq.int
[18:01:56.277]             signalCondition <- base::signalCondition
[18:01:56.277]             sys.calls <- base::sys.calls
[18:01:56.277]             `[[` <- base::`[[`
[18:01:56.277]             `+` <- base::`+`
[18:01:56.277]             `<<-` <- base::`<<-`
[18:01:56.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:56.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:56.277]                   3L)]
[18:01:56.277]             }
[18:01:56.277]             function(cond) {
[18:01:56.277]                 is_error <- inherits(cond, "error")
[18:01:56.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:56.277]                   NULL)
[18:01:56.277]                 if (is_error) {
[18:01:56.277]                   sessionInformation <- function() {
[18:01:56.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:56.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:56.277]                       search = base::search(), system = base::Sys.info())
[18:01:56.277]                   }
[18:01:56.277]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:56.277]                     cond$call), session = sessionInformation(), 
[18:01:56.277]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:56.277]                   signalCondition(cond)
[18:01:56.277]                 }
[18:01:56.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:56.277]                 "immediateCondition"))) {
[18:01:56.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:56.277]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:56.277]                   if (TRUE && !signal) {
[18:01:56.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.277]                     {
[18:01:56.277]                       inherits <- base::inherits
[18:01:56.277]                       invokeRestart <- base::invokeRestart
[18:01:56.277]                       is.null <- base::is.null
[18:01:56.277]                       muffled <- FALSE
[18:01:56.277]                       if (inherits(cond, "message")) {
[18:01:56.277]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.277]                         if (muffled) 
[18:01:56.277]                           invokeRestart("muffleMessage")
[18:01:56.277]                       }
[18:01:56.277]                       else if (inherits(cond, "warning")) {
[18:01:56.277]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.277]                         if (muffled) 
[18:01:56.277]                           invokeRestart("muffleWarning")
[18:01:56.277]                       }
[18:01:56.277]                       else if (inherits(cond, "condition")) {
[18:01:56.277]                         if (!is.null(pattern)) {
[18:01:56.277]                           computeRestarts <- base::computeRestarts
[18:01:56.277]                           grepl <- base::grepl
[18:01:56.277]                           restarts <- computeRestarts(cond)
[18:01:56.277]                           for (restart in restarts) {
[18:01:56.277]                             name <- restart$name
[18:01:56.277]                             if (is.null(name)) 
[18:01:56.277]                               next
[18:01:56.277]                             if (!grepl(pattern, name)) 
[18:01:56.277]                               next
[18:01:56.277]                             invokeRestart(restart)
[18:01:56.277]                             muffled <- TRUE
[18:01:56.277]                             break
[18:01:56.277]                           }
[18:01:56.277]                         }
[18:01:56.277]                       }
[18:01:56.277]                       invisible(muffled)
[18:01:56.277]                     }
[18:01:56.277]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.277]                   }
[18:01:56.277]                 }
[18:01:56.277]                 else {
[18:01:56.277]                   if (TRUE) {
[18:01:56.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.277]                     {
[18:01:56.277]                       inherits <- base::inherits
[18:01:56.277]                       invokeRestart <- base::invokeRestart
[18:01:56.277]                       is.null <- base::is.null
[18:01:56.277]                       muffled <- FALSE
[18:01:56.277]                       if (inherits(cond, "message")) {
[18:01:56.277]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.277]                         if (muffled) 
[18:01:56.277]                           invokeRestart("muffleMessage")
[18:01:56.277]                       }
[18:01:56.277]                       else if (inherits(cond, "warning")) {
[18:01:56.277]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.277]                         if (muffled) 
[18:01:56.277]                           invokeRestart("muffleWarning")
[18:01:56.277]                       }
[18:01:56.277]                       else if (inherits(cond, "condition")) {
[18:01:56.277]                         if (!is.null(pattern)) {
[18:01:56.277]                           computeRestarts <- base::computeRestarts
[18:01:56.277]                           grepl <- base::grepl
[18:01:56.277]                           restarts <- computeRestarts(cond)
[18:01:56.277]                           for (restart in restarts) {
[18:01:56.277]                             name <- restart$name
[18:01:56.277]                             if (is.null(name)) 
[18:01:56.277]                               next
[18:01:56.277]                             if (!grepl(pattern, name)) 
[18:01:56.277]                               next
[18:01:56.277]                             invokeRestart(restart)
[18:01:56.277]                             muffled <- TRUE
[18:01:56.277]                             break
[18:01:56.277]                           }
[18:01:56.277]                         }
[18:01:56.277]                       }
[18:01:56.277]                       invisible(muffled)
[18:01:56.277]                     }
[18:01:56.277]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.277]                   }
[18:01:56.277]                 }
[18:01:56.277]             }
[18:01:56.277]         }))
[18:01:56.277]     }, error = function(ex) {
[18:01:56.277]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:56.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.277]                 ...future.rng), started = ...future.startTime, 
[18:01:56.277]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:56.277]             version = "1.8"), class = "FutureResult")
[18:01:56.277]     }, finally = {
[18:01:56.277]         if (!identical(...future.workdir, getwd())) 
[18:01:56.277]             setwd(...future.workdir)
[18:01:56.277]         {
[18:01:56.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:56.277]                 ...future.oldOptions$nwarnings <- NULL
[18:01:56.277]             }
[18:01:56.277]             base::options(...future.oldOptions)
[18:01:56.277]             if (.Platform$OS.type == "windows") {
[18:01:56.277]                 old_names <- names(...future.oldEnvVars)
[18:01:56.277]                 envs <- base::Sys.getenv()
[18:01:56.277]                 names <- names(envs)
[18:01:56.277]                 common <- intersect(names, old_names)
[18:01:56.277]                 added <- setdiff(names, old_names)
[18:01:56.277]                 removed <- setdiff(old_names, names)
[18:01:56.277]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:56.277]                   envs[common]]
[18:01:56.277]                 NAMES <- toupper(changed)
[18:01:56.277]                 args <- list()
[18:01:56.277]                 for (kk in seq_along(NAMES)) {
[18:01:56.277]                   name <- changed[[kk]]
[18:01:56.277]                   NAME <- NAMES[[kk]]
[18:01:56.277]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.277]                     next
[18:01:56.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.277]                 }
[18:01:56.277]                 NAMES <- toupper(added)
[18:01:56.277]                 for (kk in seq_along(NAMES)) {
[18:01:56.277]                   name <- added[[kk]]
[18:01:56.277]                   NAME <- NAMES[[kk]]
[18:01:56.277]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.277]                     next
[18:01:56.277]                   args[[name]] <- ""
[18:01:56.277]                 }
[18:01:56.277]                 NAMES <- toupper(removed)
[18:01:56.277]                 for (kk in seq_along(NAMES)) {
[18:01:56.277]                   name <- removed[[kk]]
[18:01:56.277]                   NAME <- NAMES[[kk]]
[18:01:56.277]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.277]                     next
[18:01:56.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.277]                 }
[18:01:56.277]                 if (length(args) > 0) 
[18:01:56.277]                   base::do.call(base::Sys.setenv, args = args)
[18:01:56.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:56.277]             }
[18:01:56.277]             else {
[18:01:56.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:56.277]             }
[18:01:56.277]             {
[18:01:56.277]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:56.277]                   0L) {
[18:01:56.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:56.277]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:56.277]                   base::options(opts)
[18:01:56.277]                 }
[18:01:56.277]                 {
[18:01:56.277]                   {
[18:01:56.277]                     NULL
[18:01:56.277]                     RNGkind("Mersenne-Twister")
[18:01:56.277]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:56.277]                       inherits = FALSE)
[18:01:56.277]                   }
[18:01:56.277]                   options(future.plan = NULL)
[18:01:56.277]                   if (is.na(NA_character_)) 
[18:01:56.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:56.277]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:56.277]                     .init = FALSE)
[18:01:56.277]                 }
[18:01:56.277]             }
[18:01:56.277]         }
[18:01:56.277]     })
[18:01:56.277]     if (TRUE) {
[18:01:56.277]         base::sink(type = "output", split = FALSE)
[18:01:56.277]         if (TRUE) {
[18:01:56.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:56.277]         }
[18:01:56.277]         else {
[18:01:56.277]             ...future.result["stdout"] <- base::list(NULL)
[18:01:56.277]         }
[18:01:56.277]         base::close(...future.stdout)
[18:01:56.277]         ...future.stdout <- NULL
[18:01:56.277]     }
[18:01:56.277]     ...future.result$conditions <- ...future.conditions
[18:01:56.277]     ...future.result$finished <- base::Sys.time()
[18:01:56.277]     ...future.result
[18:01:56.277] }
[18:01:56.281] assign_globals() ...
[18:01:56.281] List of 11
[18:01:56.281]  $ ...future.FUN            :function (x, ...)  
[18:01:56.281]  $ x_FUN                    :function (x, ...)  
[18:01:56.281]  $ times                    : int 5
[18:01:56.281]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.281]  $ stop_if_not              :function (...)  
[18:01:56.281]  $ dim                      : NULL
[18:01:56.281]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:56.281]  $ future.call.arguments    : list()
[18:01:56.281]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.281]  $ ...future.elements_ii    :List of 3
[18:01:56.281]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[18:01:56.281]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[18:01:56.281]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[18:01:56.281]  $ ...future.seeds_ii       : NULL
[18:01:56.281]  $ ...future.globals.maxSize: NULL
[18:01:56.281]  - attr(*, "where")=List of 11
[18:01:56.281]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:56.281]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:56.281]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:56.281]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:56.281]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:56.281]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:56.281]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:56.281]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:56.281]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:56.281]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:56.281]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:56.281]  - attr(*, "resolved")= logi FALSE
[18:01:56.281]  - attr(*, "total_size")= num 95528
[18:01:56.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.281]  - attr(*, "already-done")= logi TRUE
[18:01:56.297] - copied ‘...future.FUN’ to environment
[18:01:56.297] - copied ‘x_FUN’ to environment
[18:01:56.297] - copied ‘times’ to environment
[18:01:56.298] - copied ‘stopf’ to environment
[18:01:56.298] - copied ‘stop_if_not’ to environment
[18:01:56.298] - copied ‘dim’ to environment
[18:01:56.298] - copied ‘valid_types’ to environment
[18:01:56.298] - copied ‘future.call.arguments’ to environment
[18:01:56.299] - copied ‘...future.elements_ii’ to environment
[18:01:56.299] - copied ‘...future.seeds_ii’ to environment
[18:01:56.299] - copied ‘...future.globals.maxSize’ to environment
[18:01:56.299] assign_globals() ... done
[18:01:56.300] plan(): Setting new future strategy stack:
[18:01:56.300] List of future strategies:
[18:01:56.300] 1. sequential:
[18:01:56.300]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.300]    - tweaked: FALSE
[18:01:56.300]    - call: NULL
[18:01:56.301] plan(): nbrOfWorkers() = 1
[18:01:56.306] plan(): Setting new future strategy stack:
[18:01:56.306] List of future strategies:
[18:01:56.306] 1. sequential:
[18:01:56.306]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.306]    - tweaked: FALSE
[18:01:56.306]    - call: plan(strategy)
[18:01:56.308] plan(): nbrOfWorkers() = 1
[18:01:56.308] SequentialFuture started (and completed)
[18:01:56.308] - Launch lazy future ... done
[18:01:56.309] run() for ‘SequentialFuture’ ... done
[18:01:56.309] Created future:
[18:01:56.309] SequentialFuture:
[18:01:56.309] Label: ‘future_vapply-1’
[18:01:56.309] Expression:
[18:01:56.309] {
[18:01:56.309]     do.call(function(...) {
[18:01:56.309]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.309]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.309]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.309]             on.exit(options(oopts), add = TRUE)
[18:01:56.309]         }
[18:01:56.309]         {
[18:01:56.309]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.309]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.309]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.309]             })
[18:01:56.309]         }
[18:01:56.309]     }, args = future.call.arguments)
[18:01:56.309] }
[18:01:56.309] Lazy evaluation: FALSE
[18:01:56.309] Asynchronous evaluation: FALSE
[18:01:56.309] Local evaluation: TRUE
[18:01:56.309] Environment: R_GlobalEnv
[18:01:56.309] Capture standard output: TRUE
[18:01:56.309] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:56.309] Globals: 11 objects totaling 93.55 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:56.309] Packages: 2 packages (‘stats’, ‘future.apply’)
[18:01:56.309] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:56.309] Resolved: TRUE
[18:01:56.309] Value: 1.71 KiB of class ‘list’
[18:01:56.309] Early signaling: FALSE
[18:01:56.309] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:56.309] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.312] Chunk #1 of 1 ... DONE
[18:01:56.312] Launching 1 futures (chunks) ... DONE
[18:01:56.312] Resolving 1 futures (chunks) ...
[18:01:56.312] resolve() on list ...
[18:01:56.313]  recursive: 0
[18:01:56.313]  length: 1
[18:01:56.313] 
[18:01:56.313] resolved() for ‘SequentialFuture’ ...
[18:01:56.313] - state: ‘finished’
[18:01:56.314] - run: TRUE
[18:01:56.314] - result: ‘FutureResult’
[18:01:56.314] resolved() for ‘SequentialFuture’ ... done
[18:01:56.314] Future #1
[18:01:56.315] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:56.315] - nx: 1
[18:01:56.315] - relay: TRUE
[18:01:56.316] - stdout: TRUE
[18:01:56.316] - signal: TRUE
[18:01:56.316] - resignal: FALSE
[18:01:56.316] - force: TRUE
[18:01:56.316] - relayed: [n=1] FALSE
[18:01:56.316] - queued futures: [n=1] FALSE
[18:01:56.317]  - until=1
[18:01:56.317]  - relaying element #1
[18:01:56.317] - relayed: [n=1] TRUE
[18:01:56.318] - queued futures: [n=1] TRUE
[18:01:56.318] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:56.318]  length: 0 (resolved future 1)
[18:01:56.318] Relaying remaining futures
[18:01:56.318] signalConditionsASAP(NULL, pos=0) ...
[18:01:56.319] - nx: 1
[18:01:56.319] - relay: TRUE
[18:01:56.319] - stdout: TRUE
[18:01:56.319] - signal: TRUE
[18:01:56.319] - resignal: FALSE
[18:01:56.319] - force: TRUE
[18:01:56.320] - relayed: [n=1] TRUE
[18:01:56.320] - queued futures: [n=1] TRUE
 - flush all
[18:01:56.320] - relayed: [n=1] TRUE
[18:01:56.320] - queued futures: [n=1] TRUE
[18:01:56.320] signalConditionsASAP(NULL, pos=0) ... done
[18:01:56.321] resolve() on list ... DONE
[18:01:56.321]  - Number of value chunks collected: 1
[18:01:56.321] Resolving 1 futures (chunks) ... DONE
[18:01:56.321] Reducing values from 1 chunks ...
[18:01:56.322]  - Number of values collected after concatenation: 3
[18:01:56.322]  - Number of values expected: 3
[18:01:56.322] Reducing values from 1 chunks ... DONE
[18:01:56.322] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[18:01:56.326] future_lapply() ...
[18:01:56.334] Number of chunks: 1
[18:01:56.335] getGlobalsAndPackagesXApply() ...
[18:01:56.335]  - future.globals: TRUE
[18:01:56.335] getGlobalsAndPackages() ...
[18:01:56.335] Searching for globals...
[18:01:56.346] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[18:01:56.346] Searching for globals ... DONE
[18:01:56.347] Resolving globals: FALSE
[18:01:56.349] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[18:01:56.349] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[18:01:56.350] - globals: [1] ‘FUN’
[18:01:56.350] - packages: [1] ‘stats’
[18:01:56.350] getGlobalsAndPackages() ... DONE
[18:01:56.350]  - globals found/used: [n=1] ‘FUN’
[18:01:56.351]  - needed namespaces: [n=1] ‘stats’
[18:01:56.351] Finding globals ... DONE
[18:01:56.351]  - use_args: TRUE
[18:01:56.351]  - Getting '...' globals ...
[18:01:56.352] resolve() on list ...
[18:01:56.352]  recursive: 0
[18:01:56.352]  length: 1
[18:01:56.353]  elements: ‘...’
[18:01:56.353]  length: 0 (resolved future 1)
[18:01:56.353] resolve() on list ... DONE
[18:01:56.353]    - '...' content: [n=0] 
[18:01:56.354] List of 1
[18:01:56.354]  $ ...: list()
[18:01:56.354]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.354]  - attr(*, "where")=List of 1
[18:01:56.354]   ..$ ...:<environment: 0x6183bee8d978> 
[18:01:56.354]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.354]  - attr(*, "resolved")= logi TRUE
[18:01:56.354]  - attr(*, "total_size")= num NA
[18:01:56.362]  - Getting '...' globals ... DONE
[18:01:56.362] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:01:56.362] List of 2
[18:01:56.362]  $ ...future.FUN:function (x, na.rm = TRUE)  
[18:01:56.362]  $ ...          : list()
[18:01:56.362]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.362]  - attr(*, "where")=List of 2
[18:01:56.362]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:56.362]   ..$ ...          :<environment: 0x6183bee8d978> 
[18:01:56.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.362]  - attr(*, "resolved")= logi FALSE
[18:01:56.362]  - attr(*, "total_size")= num 46960
[18:01:56.368] Packages to be attached in all futures: [n=1] ‘stats’
[18:01:56.369] getGlobalsAndPackagesXApply() ... DONE
[18:01:56.369] Number of futures (= number of chunks): 1
[18:01:56.370] Launching 1 futures (chunks) ...
[18:01:56.370] Chunk #1 of 1 ...
[18:01:56.370]  - Finding globals in 'X' for chunk #1 ...
[18:01:56.370] getGlobalsAndPackages() ...
[18:01:56.370] Searching for globals...
[18:01:56.371] 
[18:01:56.371] Searching for globals ... DONE
[18:01:56.371] - globals: [0] <none>
[18:01:56.372] getGlobalsAndPackages() ... DONE
[18:01:56.372]    + additional globals found: [n=0] 
[18:01:56.372]    + additional namespaces needed: [n=0] 
[18:01:56.372]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:56.372]  - seeds: <none>
[18:01:56.373]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.373] getGlobalsAndPackages() ...
[18:01:56.373] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.373] Resolving globals: FALSE
[18:01:56.374] Tweak future expression to call with '...' arguments ...
[18:01:56.374] {
[18:01:56.374]     do.call(function(...) {
[18:01:56.374]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.374]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.374]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.374]             on.exit(options(oopts), add = TRUE)
[18:01:56.374]         }
[18:01:56.374]         {
[18:01:56.374]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.374]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.374]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.374]             })
[18:01:56.374]         }
[18:01:56.374]     }, args = future.call.arguments)
[18:01:56.374] }
[18:01:56.374] Tweak future expression to call with '...' arguments ... DONE
[18:01:56.375] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.376] - packages: [1] ‘stats’
[18:01:56.376] getGlobalsAndPackages() ... DONE
[18:01:56.376] run() for ‘Future’ ...
[18:01:56.377] - state: ‘created’
[18:01:56.377] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:56.377] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.378] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:56.378]   - Field: ‘label’
[18:01:56.378]   - Field: ‘local’
[18:01:56.378]   - Field: ‘owner’
[18:01:56.379]   - Field: ‘envir’
[18:01:56.379]   - Field: ‘packages’
[18:01:56.379]   - Field: ‘gc’
[18:01:56.379]   - Field: ‘conditions’
[18:01:56.379]   - Field: ‘expr’
[18:01:56.380]   - Field: ‘uuid’
[18:01:56.380]   - Field: ‘seed’
[18:01:56.380]   - Field: ‘version’
[18:01:56.380]   - Field: ‘result’
[18:01:56.381]   - Field: ‘asynchronous’
[18:01:56.381]   - Field: ‘calls’
[18:01:56.381]   - Field: ‘globals’
[18:01:56.381]   - Field: ‘stdout’
[18:01:56.381]   - Field: ‘earlySignal’
[18:01:56.382]   - Field: ‘lazy’
[18:01:56.382]   - Field: ‘state’
[18:01:56.382] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:56.382] - Launch lazy future ...
[18:01:56.383] Packages needed by the future expression (n = 1): ‘stats’
[18:01:56.383] Packages needed by future strategies (n = 0): <none>
[18:01:56.384] {
[18:01:56.384]     {
[18:01:56.384]         {
[18:01:56.384]             ...future.startTime <- base::Sys.time()
[18:01:56.384]             {
[18:01:56.384]                 {
[18:01:56.384]                   {
[18:01:56.384]                     {
[18:01:56.384]                       base::local({
[18:01:56.384]                         has_future <- base::requireNamespace("future", 
[18:01:56.384]                           quietly = TRUE)
[18:01:56.384]                         if (has_future) {
[18:01:56.384]                           ns <- base::getNamespace("future")
[18:01:56.384]                           version <- ns[[".package"]][["version"]]
[18:01:56.384]                           if (is.null(version)) 
[18:01:56.384]                             version <- utils::packageVersion("future")
[18:01:56.384]                         }
[18:01:56.384]                         else {
[18:01:56.384]                           version <- NULL
[18:01:56.384]                         }
[18:01:56.384]                         if (!has_future || version < "1.8.0") {
[18:01:56.384]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:56.384]                             "", base::R.version$version.string), 
[18:01:56.384]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:56.384]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:56.384]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:56.384]                               "release", "version")], collapse = " "), 
[18:01:56.384]                             hostname = base::Sys.info()[["nodename"]])
[18:01:56.384]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:56.384]                             info)
[18:01:56.384]                           info <- base::paste(info, collapse = "; ")
[18:01:56.384]                           if (!has_future) {
[18:01:56.384]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:56.384]                               info)
[18:01:56.384]                           }
[18:01:56.384]                           else {
[18:01:56.384]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:56.384]                               info, version)
[18:01:56.384]                           }
[18:01:56.384]                           base::stop(msg)
[18:01:56.384]                         }
[18:01:56.384]                       })
[18:01:56.384]                     }
[18:01:56.384]                     base::local({
[18:01:56.384]                       for (pkg in "stats") {
[18:01:56.384]                         base::loadNamespace(pkg)
[18:01:56.384]                         base::library(pkg, character.only = TRUE)
[18:01:56.384]                       }
[18:01:56.384]                     })
[18:01:56.384]                   }
[18:01:56.384]                   ...future.strategy.old <- future::plan("list")
[18:01:56.384]                   options(future.plan = NULL)
[18:01:56.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:56.384]                 }
[18:01:56.384]                 ...future.workdir <- getwd()
[18:01:56.384]             }
[18:01:56.384]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:56.384]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:56.384]         }
[18:01:56.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:56.384]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:56.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:56.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:56.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:56.384]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:56.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:56.384]             base::names(...future.oldOptions))
[18:01:56.384]     }
[18:01:56.384]     if (FALSE) {
[18:01:56.384]     }
[18:01:56.384]     else {
[18:01:56.384]         if (TRUE) {
[18:01:56.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:56.384]                 open = "w")
[18:01:56.384]         }
[18:01:56.384]         else {
[18:01:56.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:56.384]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:56.384]         }
[18:01:56.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:56.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:56.384]             base::sink(type = "output", split = FALSE)
[18:01:56.384]             base::close(...future.stdout)
[18:01:56.384]         }, add = TRUE)
[18:01:56.384]     }
[18:01:56.384]     ...future.frame <- base::sys.nframe()
[18:01:56.384]     ...future.conditions <- base::list()
[18:01:56.384]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:56.384]     if (FALSE) {
[18:01:56.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:56.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:56.384]     }
[18:01:56.384]     ...future.result <- base::tryCatch({
[18:01:56.384]         base::withCallingHandlers({
[18:01:56.384]             ...future.value <- base::withVisible(base::local({
[18:01:56.384]                 do.call(function(...) {
[18:01:56.384]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.384]                   if (!identical(...future.globals.maxSize.org, 
[18:01:56.384]                     ...future.globals.maxSize)) {
[18:01:56.384]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.384]                     on.exit(options(oopts), add = TRUE)
[18:01:56.384]                   }
[18:01:56.384]                   {
[18:01:56.384]                     lapply(seq_along(...future.elements_ii), 
[18:01:56.384]                       FUN = function(jj) {
[18:01:56.384]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.384]                         ...future.FUN(...future.X_jj, ...)
[18:01:56.384]                       })
[18:01:56.384]                   }
[18:01:56.384]                 }, args = future.call.arguments)
[18:01:56.384]             }))
[18:01:56.384]             future::FutureResult(value = ...future.value$value, 
[18:01:56.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.384]                   ...future.rng), globalenv = if (FALSE) 
[18:01:56.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:56.384]                     ...future.globalenv.names))
[18:01:56.384]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:56.384]         }, condition = base::local({
[18:01:56.384]             c <- base::c
[18:01:56.384]             inherits <- base::inherits
[18:01:56.384]             invokeRestart <- base::invokeRestart
[18:01:56.384]             length <- base::length
[18:01:56.384]             list <- base::list
[18:01:56.384]             seq.int <- base::seq.int
[18:01:56.384]             signalCondition <- base::signalCondition
[18:01:56.384]             sys.calls <- base::sys.calls
[18:01:56.384]             `[[` <- base::`[[`
[18:01:56.384]             `+` <- base::`+`
[18:01:56.384]             `<<-` <- base::`<<-`
[18:01:56.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:56.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:56.384]                   3L)]
[18:01:56.384]             }
[18:01:56.384]             function(cond) {
[18:01:56.384]                 is_error <- inherits(cond, "error")
[18:01:56.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:56.384]                   NULL)
[18:01:56.384]                 if (is_error) {
[18:01:56.384]                   sessionInformation <- function() {
[18:01:56.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:56.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:56.384]                       search = base::search(), system = base::Sys.info())
[18:01:56.384]                   }
[18:01:56.384]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:56.384]                     cond$call), session = sessionInformation(), 
[18:01:56.384]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:56.384]                   signalCondition(cond)
[18:01:56.384]                 }
[18:01:56.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:56.384]                 "immediateCondition"))) {
[18:01:56.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:56.384]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:56.384]                   if (TRUE && !signal) {
[18:01:56.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.384]                     {
[18:01:56.384]                       inherits <- base::inherits
[18:01:56.384]                       invokeRestart <- base::invokeRestart
[18:01:56.384]                       is.null <- base::is.null
[18:01:56.384]                       muffled <- FALSE
[18:01:56.384]                       if (inherits(cond, "message")) {
[18:01:56.384]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.384]                         if (muffled) 
[18:01:56.384]                           invokeRestart("muffleMessage")
[18:01:56.384]                       }
[18:01:56.384]                       else if (inherits(cond, "warning")) {
[18:01:56.384]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.384]                         if (muffled) 
[18:01:56.384]                           invokeRestart("muffleWarning")
[18:01:56.384]                       }
[18:01:56.384]                       else if (inherits(cond, "condition")) {
[18:01:56.384]                         if (!is.null(pattern)) {
[18:01:56.384]                           computeRestarts <- base::computeRestarts
[18:01:56.384]                           grepl <- base::grepl
[18:01:56.384]                           restarts <- computeRestarts(cond)
[18:01:56.384]                           for (restart in restarts) {
[18:01:56.384]                             name <- restart$name
[18:01:56.384]                             if (is.null(name)) 
[18:01:56.384]                               next
[18:01:56.384]                             if (!grepl(pattern, name)) 
[18:01:56.384]                               next
[18:01:56.384]                             invokeRestart(restart)
[18:01:56.384]                             muffled <- TRUE
[18:01:56.384]                             break
[18:01:56.384]                           }
[18:01:56.384]                         }
[18:01:56.384]                       }
[18:01:56.384]                       invisible(muffled)
[18:01:56.384]                     }
[18:01:56.384]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.384]                   }
[18:01:56.384]                 }
[18:01:56.384]                 else {
[18:01:56.384]                   if (TRUE) {
[18:01:56.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.384]                     {
[18:01:56.384]                       inherits <- base::inherits
[18:01:56.384]                       invokeRestart <- base::invokeRestart
[18:01:56.384]                       is.null <- base::is.null
[18:01:56.384]                       muffled <- FALSE
[18:01:56.384]                       if (inherits(cond, "message")) {
[18:01:56.384]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.384]                         if (muffled) 
[18:01:56.384]                           invokeRestart("muffleMessage")
[18:01:56.384]                       }
[18:01:56.384]                       else if (inherits(cond, "warning")) {
[18:01:56.384]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.384]                         if (muffled) 
[18:01:56.384]                           invokeRestart("muffleWarning")
[18:01:56.384]                       }
[18:01:56.384]                       else if (inherits(cond, "condition")) {
[18:01:56.384]                         if (!is.null(pattern)) {
[18:01:56.384]                           computeRestarts <- base::computeRestarts
[18:01:56.384]                           grepl <- base::grepl
[18:01:56.384]                           restarts <- computeRestarts(cond)
[18:01:56.384]                           for (restart in restarts) {
[18:01:56.384]                             name <- restart$name
[18:01:56.384]                             if (is.null(name)) 
[18:01:56.384]                               next
[18:01:56.384]                             if (!grepl(pattern, name)) 
[18:01:56.384]                               next
[18:01:56.384]                             invokeRestart(restart)
[18:01:56.384]                             muffled <- TRUE
[18:01:56.384]                             break
[18:01:56.384]                           }
[18:01:56.384]                         }
[18:01:56.384]                       }
[18:01:56.384]                       invisible(muffled)
[18:01:56.384]                     }
[18:01:56.384]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.384]                   }
[18:01:56.384]                 }
[18:01:56.384]             }
[18:01:56.384]         }))
[18:01:56.384]     }, error = function(ex) {
[18:01:56.384]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:56.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.384]                 ...future.rng), started = ...future.startTime, 
[18:01:56.384]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:56.384]             version = "1.8"), class = "FutureResult")
[18:01:56.384]     }, finally = {
[18:01:56.384]         if (!identical(...future.workdir, getwd())) 
[18:01:56.384]             setwd(...future.workdir)
[18:01:56.384]         {
[18:01:56.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:56.384]                 ...future.oldOptions$nwarnings <- NULL
[18:01:56.384]             }
[18:01:56.384]             base::options(...future.oldOptions)
[18:01:56.384]             if (.Platform$OS.type == "windows") {
[18:01:56.384]                 old_names <- names(...future.oldEnvVars)
[18:01:56.384]                 envs <- base::Sys.getenv()
[18:01:56.384]                 names <- names(envs)
[18:01:56.384]                 common <- intersect(names, old_names)
[18:01:56.384]                 added <- setdiff(names, old_names)
[18:01:56.384]                 removed <- setdiff(old_names, names)
[18:01:56.384]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:56.384]                   envs[common]]
[18:01:56.384]                 NAMES <- toupper(changed)
[18:01:56.384]                 args <- list()
[18:01:56.384]                 for (kk in seq_along(NAMES)) {
[18:01:56.384]                   name <- changed[[kk]]
[18:01:56.384]                   NAME <- NAMES[[kk]]
[18:01:56.384]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.384]                     next
[18:01:56.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.384]                 }
[18:01:56.384]                 NAMES <- toupper(added)
[18:01:56.384]                 for (kk in seq_along(NAMES)) {
[18:01:56.384]                   name <- added[[kk]]
[18:01:56.384]                   NAME <- NAMES[[kk]]
[18:01:56.384]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.384]                     next
[18:01:56.384]                   args[[name]] <- ""
[18:01:56.384]                 }
[18:01:56.384]                 NAMES <- toupper(removed)
[18:01:56.384]                 for (kk in seq_along(NAMES)) {
[18:01:56.384]                   name <- removed[[kk]]
[18:01:56.384]                   NAME <- NAMES[[kk]]
[18:01:56.384]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.384]                     next
[18:01:56.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.384]                 }
[18:01:56.384]                 if (length(args) > 0) 
[18:01:56.384]                   base::do.call(base::Sys.setenv, args = args)
[18:01:56.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:56.384]             }
[18:01:56.384]             else {
[18:01:56.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:56.384]             }
[18:01:56.384]             {
[18:01:56.384]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:56.384]                   0L) {
[18:01:56.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:56.384]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:56.384]                   base::options(opts)
[18:01:56.384]                 }
[18:01:56.384]                 {
[18:01:56.384]                   {
[18:01:56.384]                     NULL
[18:01:56.384]                     RNGkind("Mersenne-Twister")
[18:01:56.384]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:56.384]                       inherits = FALSE)
[18:01:56.384]                   }
[18:01:56.384]                   options(future.plan = NULL)
[18:01:56.384]                   if (is.na(NA_character_)) 
[18:01:56.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:56.384]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:56.384]                     .init = FALSE)
[18:01:56.384]                 }
[18:01:56.384]             }
[18:01:56.384]         }
[18:01:56.384]     })
[18:01:56.384]     if (TRUE) {
[18:01:56.384]         base::sink(type = "output", split = FALSE)
[18:01:56.384]         if (TRUE) {
[18:01:56.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:56.384]         }
[18:01:56.384]         else {
[18:01:56.384]             ...future.result["stdout"] <- base::list(NULL)
[18:01:56.384]         }
[18:01:56.384]         base::close(...future.stdout)
[18:01:56.384]         ...future.stdout <- NULL
[18:01:56.384]     }
[18:01:56.384]     ...future.result$conditions <- ...future.conditions
[18:01:56.384]     ...future.result$finished <- base::Sys.time()
[18:01:56.384]     ...future.result
[18:01:56.384] }
[18:01:56.388] assign_globals() ...
[18:01:56.388] List of 5
[18:01:56.388]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[18:01:56.388]  $ future.call.arguments    : list()
[18:01:56.388]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.388]  $ ...future.elements_ii    :List of 7
[18:01:56.388]   ..$ : int [1:3] 1 2 3
[18:01:56.388]   ..$ : int [1:4] 1 2 3 4
[18:01:56.388]   ..$ : int [1:5] 1 2 3 4 5
[18:01:56.388]   ..$ : int [1:6] 1 2 3 4 5 6
[18:01:56.388]   ..$ : int [1:7] 1 2 3 4 5 6 7
[18:01:56.388]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[18:01:56.388]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[18:01:56.388]  $ ...future.seeds_ii       : NULL
[18:01:56.388]  $ ...future.globals.maxSize: NULL
[18:01:56.388]  - attr(*, "where")=List of 5
[18:01:56.388]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:56.388]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:56.388]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:56.388]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:56.388]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:56.388]  - attr(*, "resolved")= logi FALSE
[18:01:56.388]  - attr(*, "total_size")= num 46960
[18:01:56.388]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.388]  - attr(*, "already-done")= logi TRUE
[18:01:56.402] - copied ‘...future.FUN’ to environment
[18:01:56.402] - copied ‘future.call.arguments’ to environment
[18:01:56.403] - copied ‘...future.elements_ii’ to environment
[18:01:56.403] - copied ‘...future.seeds_ii’ to environment
[18:01:56.403] - copied ‘...future.globals.maxSize’ to environment
[18:01:56.403] assign_globals() ... done
[18:01:56.404] plan(): Setting new future strategy stack:
[18:01:56.404] List of future strategies:
[18:01:56.404] 1. sequential:
[18:01:56.404]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.404]    - tweaked: FALSE
[18:01:56.404]    - call: NULL
[18:01:56.405] plan(): nbrOfWorkers() = 1
[18:01:56.407] plan(): Setting new future strategy stack:
[18:01:56.408] List of future strategies:
[18:01:56.408] 1. sequential:
[18:01:56.408]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.408]    - tweaked: FALSE
[18:01:56.408]    - call: plan(strategy)
[18:01:56.409] plan(): nbrOfWorkers() = 1
[18:01:56.409] SequentialFuture started (and completed)
[18:01:56.409] - Launch lazy future ... done
[18:01:56.409] run() for ‘SequentialFuture’ ... done
[18:01:56.410] Created future:
[18:01:56.410] SequentialFuture:
[18:01:56.410] Label: ‘future_sapply-1’
[18:01:56.410] Expression:
[18:01:56.410] {
[18:01:56.410]     do.call(function(...) {
[18:01:56.410]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.410]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.410]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.410]             on.exit(options(oopts), add = TRUE)
[18:01:56.410]         }
[18:01:56.410]         {
[18:01:56.410]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.410]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.410]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.410]             })
[18:01:56.410]         }
[18:01:56.410]     }, args = future.call.arguments)
[18:01:56.410] }
[18:01:56.410] Lazy evaluation: FALSE
[18:01:56.410] Asynchronous evaluation: FALSE
[18:01:56.410] Local evaluation: TRUE
[18:01:56.410] Environment: R_GlobalEnv
[18:01:56.410] Capture standard output: TRUE
[18:01:56.410] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:56.410] Globals: 5 objects totaling 46.39 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 544 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:56.410] Packages: 1 packages (‘stats’)
[18:01:56.410] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:56.410] Resolved: TRUE
[18:01:56.410] Value: 672 bytes of class ‘list’
[18:01:56.410] Early signaling: FALSE
[18:01:56.410] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:56.410] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.415] Chunk #1 of 1 ... DONE
[18:01:56.415] Launching 1 futures (chunks) ... DONE
[18:01:56.415] Resolving 1 futures (chunks) ...
[18:01:56.415] resolve() on list ...
[18:01:56.416]  recursive: 0
[18:01:56.416]  length: 1
[18:01:56.416] 
[18:01:56.416] resolved() for ‘SequentialFuture’ ...
[18:01:56.417] - state: ‘finished’
[18:01:56.417] - run: TRUE
[18:01:56.417] - result: ‘FutureResult’
[18:01:56.417] resolved() for ‘SequentialFuture’ ... done
[18:01:56.418] Future #1
[18:01:56.418] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:56.418] - nx: 1
[18:01:56.418] - relay: TRUE
[18:01:56.418] - stdout: TRUE
[18:01:56.419] - signal: TRUE
[18:01:56.419] - resignal: FALSE
[18:01:56.419] - force: TRUE
[18:01:56.419] - relayed: [n=1] FALSE
[18:01:56.419] - queued futures: [n=1] FALSE
[18:01:56.420]  - until=1
[18:01:56.420]  - relaying element #1
[18:01:56.420] - relayed: [n=1] TRUE
[18:01:56.420] - queued futures: [n=1] TRUE
[18:01:56.421] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:56.421]  length: 0 (resolved future 1)
[18:01:56.421] Relaying remaining futures
[18:01:56.421] signalConditionsASAP(NULL, pos=0) ...
[18:01:56.421] - nx: 1
[18:01:56.422] - relay: TRUE
[18:01:56.422] - stdout: TRUE
[18:01:56.422] - signal: TRUE
[18:01:56.422] - resignal: FALSE
[18:01:56.422] - force: TRUE
[18:01:56.422] - relayed: [n=1] TRUE
[18:01:56.423] - queued futures: [n=1] TRUE
 - flush all
[18:01:56.423] - relayed: [n=1] TRUE
[18:01:56.423] - queued futures: [n=1] TRUE
[18:01:56.423] signalConditionsASAP(NULL, pos=0) ... done
[18:01:56.424] resolve() on list ... DONE
[18:01:56.424]  - Number of value chunks collected: 1
[18:01:56.424] Resolving 1 futures (chunks) ... DONE
[18:01:56.424] Reducing values from 1 chunks ...
[18:01:56.425]  - Number of values collected after concatenation: 7
[18:01:56.425]  - Number of values expected: 7
[18:01:56.425] Reducing values from 1 chunks ... DONE
[18:01:56.425] future_lapply() ... DONE
[18:01:56.426] future_lapply() ...
[18:01:56.430] Number of chunks: 1
[18:01:56.430] getGlobalsAndPackagesXApply() ...
[18:01:56.430]  - future.globals: TRUE
[18:01:56.431] getGlobalsAndPackages() ...
[18:01:56.431] Searching for globals...
[18:01:56.447] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[18:01:56.447] Searching for globals ... DONE
[18:01:56.447] Resolving globals: FALSE
[18:01:56.450] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[18:01:56.451] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[18:01:56.451] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:56.451] - packages: [2] ‘stats’, ‘future.apply’
[18:01:56.451] getGlobalsAndPackages() ... DONE
[18:01:56.452]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:56.452]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[18:01:56.452] Finding globals ... DONE
[18:01:56.452]  - use_args: TRUE
[18:01:56.453]  - Getting '...' globals ...
[18:01:56.453] resolve() on list ...
[18:01:56.453]  recursive: 0
[18:01:56.454]  length: 1
[18:01:56.454]  elements: ‘...’
[18:01:56.454]  length: 0 (resolved future 1)
[18:01:56.454] resolve() on list ... DONE
[18:01:56.454]    - '...' content: [n=0] 
[18:01:56.455] List of 1
[18:01:56.455]  $ ...: list()
[18:01:56.455]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.455]  - attr(*, "where")=List of 1
[18:01:56.455]   ..$ ...:<environment: 0x6183be6882c0> 
[18:01:56.455]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.455]  - attr(*, "resolved")= logi TRUE
[18:01:56.455]  - attr(*, "total_size")= num NA
[18:01:56.460]  - Getting '...' globals ... DONE
[18:01:56.462] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:56.462] List of 8
[18:01:56.462]  $ ...future.FUN:function (x, ...)  
[18:01:56.462]  $ x_FUN        :function (x, na.rm = TRUE)  
[18:01:56.462]  $ times        : int 5
[18:01:56.462]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.462]  $ stop_if_not  :function (...)  
[18:01:56.462]  $ dim          : NULL
[18:01:56.462]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:56.462]  $ ...          : list()
[18:01:56.462]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.462]  - attr(*, "where")=List of 8
[18:01:56.462]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:56.462]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:56.462]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:56.462]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:56.462]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:56.462]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:56.462]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:56.462]   ..$ ...          :<environment: 0x6183be6882c0> 
[18:01:56.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.462]  - attr(*, "resolved")= logi FALSE
[18:01:56.462]  - attr(*, "total_size")= num 141240
[18:01:56.474] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[18:01:56.474] getGlobalsAndPackagesXApply() ... DONE
[18:01:56.474] Number of futures (= number of chunks): 1
[18:01:56.475] Launching 1 futures (chunks) ...
[18:01:56.475] Chunk #1 of 1 ...
[18:01:56.475]  - Finding globals in 'X' for chunk #1 ...
[18:01:56.475] getGlobalsAndPackages() ...
[18:01:56.476] Searching for globals...
[18:01:56.476] 
[18:01:56.476] Searching for globals ... DONE
[18:01:56.477] - globals: [0] <none>
[18:01:56.477] getGlobalsAndPackages() ... DONE
[18:01:56.477]    + additional globals found: [n=0] 
[18:01:56.477]    + additional namespaces needed: [n=0] 
[18:01:56.477]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:56.478]  - seeds: <none>
[18:01:56.478]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.478] getGlobalsAndPackages() ...
[18:01:56.478] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.478] Resolving globals: FALSE
[18:01:56.479] Tweak future expression to call with '...' arguments ...
[18:01:56.479] {
[18:01:56.479]     do.call(function(...) {
[18:01:56.479]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.479]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.479]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.479]             on.exit(options(oopts), add = TRUE)
[18:01:56.479]         }
[18:01:56.479]         {
[18:01:56.479]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.479]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.479]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.479]             })
[18:01:56.479]         }
[18:01:56.479]     }, args = future.call.arguments)
[18:01:56.479] }
[18:01:56.480] Tweak future expression to call with '...' arguments ... DONE
[18:01:56.481] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.481] - packages: [2] ‘stats’, ‘future.apply’
[18:01:56.481] getGlobalsAndPackages() ... DONE
[18:01:56.482] run() for ‘Future’ ...
[18:01:56.482] - state: ‘created’
[18:01:56.482] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:56.483] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.483] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:56.484]   - Field: ‘label’
[18:01:56.484]   - Field: ‘local’
[18:01:56.484]   - Field: ‘owner’
[18:01:56.484]   - Field: ‘envir’
[18:01:56.484]   - Field: ‘packages’
[18:01:56.485]   - Field: ‘gc’
[18:01:56.485]   - Field: ‘conditions’
[18:01:56.485]   - Field: ‘expr’
[18:01:56.485]   - Field: ‘uuid’
[18:01:56.485]   - Field: ‘seed’
[18:01:56.486]   - Field: ‘version’
[18:01:56.486]   - Field: ‘result’
[18:01:56.486]   - Field: ‘asynchronous’
[18:01:56.486]   - Field: ‘calls’
[18:01:56.486]   - Field: ‘globals’
[18:01:56.487]   - Field: ‘stdout’
[18:01:56.487]   - Field: ‘earlySignal’
[18:01:56.487]   - Field: ‘lazy’
[18:01:56.487]   - Field: ‘state’
[18:01:56.487] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:56.488] - Launch lazy future ...
[18:01:56.488] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[18:01:56.488] Packages needed by future strategies (n = 0): <none>
[18:01:56.489] {
[18:01:56.489]     {
[18:01:56.489]         {
[18:01:56.489]             ...future.startTime <- base::Sys.time()
[18:01:56.489]             {
[18:01:56.489]                 {
[18:01:56.489]                   {
[18:01:56.489]                     {
[18:01:56.489]                       base::local({
[18:01:56.489]                         has_future <- base::requireNamespace("future", 
[18:01:56.489]                           quietly = TRUE)
[18:01:56.489]                         if (has_future) {
[18:01:56.489]                           ns <- base::getNamespace("future")
[18:01:56.489]                           version <- ns[[".package"]][["version"]]
[18:01:56.489]                           if (is.null(version)) 
[18:01:56.489]                             version <- utils::packageVersion("future")
[18:01:56.489]                         }
[18:01:56.489]                         else {
[18:01:56.489]                           version <- NULL
[18:01:56.489]                         }
[18:01:56.489]                         if (!has_future || version < "1.8.0") {
[18:01:56.489]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:56.489]                             "", base::R.version$version.string), 
[18:01:56.489]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:56.489]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:56.489]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:56.489]                               "release", "version")], collapse = " "), 
[18:01:56.489]                             hostname = base::Sys.info()[["nodename"]])
[18:01:56.489]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:56.489]                             info)
[18:01:56.489]                           info <- base::paste(info, collapse = "; ")
[18:01:56.489]                           if (!has_future) {
[18:01:56.489]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:56.489]                               info)
[18:01:56.489]                           }
[18:01:56.489]                           else {
[18:01:56.489]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:56.489]                               info, version)
[18:01:56.489]                           }
[18:01:56.489]                           base::stop(msg)
[18:01:56.489]                         }
[18:01:56.489]                       })
[18:01:56.489]                     }
[18:01:56.489]                     base::local({
[18:01:56.489]                       for (pkg in c("stats", "future.apply")) {
[18:01:56.489]                         base::loadNamespace(pkg)
[18:01:56.489]                         base::library(pkg, character.only = TRUE)
[18:01:56.489]                       }
[18:01:56.489]                     })
[18:01:56.489]                   }
[18:01:56.489]                   ...future.strategy.old <- future::plan("list")
[18:01:56.489]                   options(future.plan = NULL)
[18:01:56.489]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.489]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:56.489]                 }
[18:01:56.489]                 ...future.workdir <- getwd()
[18:01:56.489]             }
[18:01:56.489]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:56.489]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:56.489]         }
[18:01:56.489]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:56.489]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:56.489]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:56.489]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:56.489]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:56.489]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:56.489]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:56.489]             base::names(...future.oldOptions))
[18:01:56.489]     }
[18:01:56.489]     if (FALSE) {
[18:01:56.489]     }
[18:01:56.489]     else {
[18:01:56.489]         if (TRUE) {
[18:01:56.489]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:56.489]                 open = "w")
[18:01:56.489]         }
[18:01:56.489]         else {
[18:01:56.489]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:56.489]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:56.489]         }
[18:01:56.489]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:56.489]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:56.489]             base::sink(type = "output", split = FALSE)
[18:01:56.489]             base::close(...future.stdout)
[18:01:56.489]         }, add = TRUE)
[18:01:56.489]     }
[18:01:56.489]     ...future.frame <- base::sys.nframe()
[18:01:56.489]     ...future.conditions <- base::list()
[18:01:56.489]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:56.489]     if (FALSE) {
[18:01:56.489]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:56.489]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:56.489]     }
[18:01:56.489]     ...future.result <- base::tryCatch({
[18:01:56.489]         base::withCallingHandlers({
[18:01:56.489]             ...future.value <- base::withVisible(base::local({
[18:01:56.489]                 do.call(function(...) {
[18:01:56.489]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.489]                   if (!identical(...future.globals.maxSize.org, 
[18:01:56.489]                     ...future.globals.maxSize)) {
[18:01:56.489]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.489]                     on.exit(options(oopts), add = TRUE)
[18:01:56.489]                   }
[18:01:56.489]                   {
[18:01:56.489]                     lapply(seq_along(...future.elements_ii), 
[18:01:56.489]                       FUN = function(jj) {
[18:01:56.489]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.489]                         ...future.FUN(...future.X_jj, ...)
[18:01:56.489]                       })
[18:01:56.489]                   }
[18:01:56.489]                 }, args = future.call.arguments)
[18:01:56.489]             }))
[18:01:56.489]             future::FutureResult(value = ...future.value$value, 
[18:01:56.489]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.489]                   ...future.rng), globalenv = if (FALSE) 
[18:01:56.489]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:56.489]                     ...future.globalenv.names))
[18:01:56.489]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:56.489]         }, condition = base::local({
[18:01:56.489]             c <- base::c
[18:01:56.489]             inherits <- base::inherits
[18:01:56.489]             invokeRestart <- base::invokeRestart
[18:01:56.489]             length <- base::length
[18:01:56.489]             list <- base::list
[18:01:56.489]             seq.int <- base::seq.int
[18:01:56.489]             signalCondition <- base::signalCondition
[18:01:56.489]             sys.calls <- base::sys.calls
[18:01:56.489]             `[[` <- base::`[[`
[18:01:56.489]             `+` <- base::`+`
[18:01:56.489]             `<<-` <- base::`<<-`
[18:01:56.489]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:56.489]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:56.489]                   3L)]
[18:01:56.489]             }
[18:01:56.489]             function(cond) {
[18:01:56.489]                 is_error <- inherits(cond, "error")
[18:01:56.489]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:56.489]                   NULL)
[18:01:56.489]                 if (is_error) {
[18:01:56.489]                   sessionInformation <- function() {
[18:01:56.489]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:56.489]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:56.489]                       search = base::search(), system = base::Sys.info())
[18:01:56.489]                   }
[18:01:56.489]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.489]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:56.489]                     cond$call), session = sessionInformation(), 
[18:01:56.489]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:56.489]                   signalCondition(cond)
[18:01:56.489]                 }
[18:01:56.489]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:56.489]                 "immediateCondition"))) {
[18:01:56.489]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:56.489]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.489]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:56.489]                   if (TRUE && !signal) {
[18:01:56.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.489]                     {
[18:01:56.489]                       inherits <- base::inherits
[18:01:56.489]                       invokeRestart <- base::invokeRestart
[18:01:56.489]                       is.null <- base::is.null
[18:01:56.489]                       muffled <- FALSE
[18:01:56.489]                       if (inherits(cond, "message")) {
[18:01:56.489]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.489]                         if (muffled) 
[18:01:56.489]                           invokeRestart("muffleMessage")
[18:01:56.489]                       }
[18:01:56.489]                       else if (inherits(cond, "warning")) {
[18:01:56.489]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.489]                         if (muffled) 
[18:01:56.489]                           invokeRestart("muffleWarning")
[18:01:56.489]                       }
[18:01:56.489]                       else if (inherits(cond, "condition")) {
[18:01:56.489]                         if (!is.null(pattern)) {
[18:01:56.489]                           computeRestarts <- base::computeRestarts
[18:01:56.489]                           grepl <- base::grepl
[18:01:56.489]                           restarts <- computeRestarts(cond)
[18:01:56.489]                           for (restart in restarts) {
[18:01:56.489]                             name <- restart$name
[18:01:56.489]                             if (is.null(name)) 
[18:01:56.489]                               next
[18:01:56.489]                             if (!grepl(pattern, name)) 
[18:01:56.489]                               next
[18:01:56.489]                             invokeRestart(restart)
[18:01:56.489]                             muffled <- TRUE
[18:01:56.489]                             break
[18:01:56.489]                           }
[18:01:56.489]                         }
[18:01:56.489]                       }
[18:01:56.489]                       invisible(muffled)
[18:01:56.489]                     }
[18:01:56.489]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.489]                   }
[18:01:56.489]                 }
[18:01:56.489]                 else {
[18:01:56.489]                   if (TRUE) {
[18:01:56.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.489]                     {
[18:01:56.489]                       inherits <- base::inherits
[18:01:56.489]                       invokeRestart <- base::invokeRestart
[18:01:56.489]                       is.null <- base::is.null
[18:01:56.489]                       muffled <- FALSE
[18:01:56.489]                       if (inherits(cond, "message")) {
[18:01:56.489]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.489]                         if (muffled) 
[18:01:56.489]                           invokeRestart("muffleMessage")
[18:01:56.489]                       }
[18:01:56.489]                       else if (inherits(cond, "warning")) {
[18:01:56.489]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.489]                         if (muffled) 
[18:01:56.489]                           invokeRestart("muffleWarning")
[18:01:56.489]                       }
[18:01:56.489]                       else if (inherits(cond, "condition")) {
[18:01:56.489]                         if (!is.null(pattern)) {
[18:01:56.489]                           computeRestarts <- base::computeRestarts
[18:01:56.489]                           grepl <- base::grepl
[18:01:56.489]                           restarts <- computeRestarts(cond)
[18:01:56.489]                           for (restart in restarts) {
[18:01:56.489]                             name <- restart$name
[18:01:56.489]                             if (is.null(name)) 
[18:01:56.489]                               next
[18:01:56.489]                             if (!grepl(pattern, name)) 
[18:01:56.489]                               next
[18:01:56.489]                             invokeRestart(restart)
[18:01:56.489]                             muffled <- TRUE
[18:01:56.489]                             break
[18:01:56.489]                           }
[18:01:56.489]                         }
[18:01:56.489]                       }
[18:01:56.489]                       invisible(muffled)
[18:01:56.489]                     }
[18:01:56.489]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.489]                   }
[18:01:56.489]                 }
[18:01:56.489]             }
[18:01:56.489]         }))
[18:01:56.489]     }, error = function(ex) {
[18:01:56.489]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:56.489]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.489]                 ...future.rng), started = ...future.startTime, 
[18:01:56.489]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:56.489]             version = "1.8"), class = "FutureResult")
[18:01:56.489]     }, finally = {
[18:01:56.489]         if (!identical(...future.workdir, getwd())) 
[18:01:56.489]             setwd(...future.workdir)
[18:01:56.489]         {
[18:01:56.489]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:56.489]                 ...future.oldOptions$nwarnings <- NULL
[18:01:56.489]             }
[18:01:56.489]             base::options(...future.oldOptions)
[18:01:56.489]             if (.Platform$OS.type == "windows") {
[18:01:56.489]                 old_names <- names(...future.oldEnvVars)
[18:01:56.489]                 envs <- base::Sys.getenv()
[18:01:56.489]                 names <- names(envs)
[18:01:56.489]                 common <- intersect(names, old_names)
[18:01:56.489]                 added <- setdiff(names, old_names)
[18:01:56.489]                 removed <- setdiff(old_names, names)
[18:01:56.489]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:56.489]                   envs[common]]
[18:01:56.489]                 NAMES <- toupper(changed)
[18:01:56.489]                 args <- list()
[18:01:56.489]                 for (kk in seq_along(NAMES)) {
[18:01:56.489]                   name <- changed[[kk]]
[18:01:56.489]                   NAME <- NAMES[[kk]]
[18:01:56.489]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.489]                     next
[18:01:56.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.489]                 }
[18:01:56.489]                 NAMES <- toupper(added)
[18:01:56.489]                 for (kk in seq_along(NAMES)) {
[18:01:56.489]                   name <- added[[kk]]
[18:01:56.489]                   NAME <- NAMES[[kk]]
[18:01:56.489]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.489]                     next
[18:01:56.489]                   args[[name]] <- ""
[18:01:56.489]                 }
[18:01:56.489]                 NAMES <- toupper(removed)
[18:01:56.489]                 for (kk in seq_along(NAMES)) {
[18:01:56.489]                   name <- removed[[kk]]
[18:01:56.489]                   NAME <- NAMES[[kk]]
[18:01:56.489]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.489]                     next
[18:01:56.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.489]                 }
[18:01:56.489]                 if (length(args) > 0) 
[18:01:56.489]                   base::do.call(base::Sys.setenv, args = args)
[18:01:56.489]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:56.489]             }
[18:01:56.489]             else {
[18:01:56.489]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:56.489]             }
[18:01:56.489]             {
[18:01:56.489]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:56.489]                   0L) {
[18:01:56.489]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:56.489]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:56.489]                   base::options(opts)
[18:01:56.489]                 }
[18:01:56.489]                 {
[18:01:56.489]                   {
[18:01:56.489]                     NULL
[18:01:56.489]                     RNGkind("Mersenne-Twister")
[18:01:56.489]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:56.489]                       inherits = FALSE)
[18:01:56.489]                   }
[18:01:56.489]                   options(future.plan = NULL)
[18:01:56.489]                   if (is.na(NA_character_)) 
[18:01:56.489]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.489]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:56.489]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:56.489]                     .init = FALSE)
[18:01:56.489]                 }
[18:01:56.489]             }
[18:01:56.489]         }
[18:01:56.489]     })
[18:01:56.489]     if (TRUE) {
[18:01:56.489]         base::sink(type = "output", split = FALSE)
[18:01:56.489]         if (TRUE) {
[18:01:56.489]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:56.489]         }
[18:01:56.489]         else {
[18:01:56.489]             ...future.result["stdout"] <- base::list(NULL)
[18:01:56.489]         }
[18:01:56.489]         base::close(...future.stdout)
[18:01:56.489]         ...future.stdout <- NULL
[18:01:56.489]     }
[18:01:56.489]     ...future.result$conditions <- ...future.conditions
[18:01:56.489]     ...future.result$finished <- base::Sys.time()
[18:01:56.489]     ...future.result
[18:01:56.489] }
[18:01:56.493] assign_globals() ...
[18:01:56.493] List of 11
[18:01:56.493]  $ ...future.FUN            :function (x, ...)  
[18:01:56.493]  $ x_FUN                    :function (x, na.rm = TRUE)  
[18:01:56.493]  $ times                    : int 5
[18:01:56.493]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.493]  $ stop_if_not              :function (...)  
[18:01:56.493]  $ dim                      : NULL
[18:01:56.493]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:56.493]  $ future.call.arguments    : list()
[18:01:56.493]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.493]  $ ...future.elements_ii    :List of 7
[18:01:56.493]   ..$ : int [1:3] 1 2 3
[18:01:56.493]   ..$ : int [1:4] 1 2 3 4
[18:01:56.493]   ..$ : int [1:5] 1 2 3 4 5
[18:01:56.493]   ..$ : int [1:6] 1 2 3 4 5 6
[18:01:56.493]   ..$ : int [1:7] 1 2 3 4 5 6 7
[18:01:56.493]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[18:01:56.493]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[18:01:56.493]  $ ...future.seeds_ii       : NULL
[18:01:56.493]  $ ...future.globals.maxSize: NULL
[18:01:56.493]  - attr(*, "where")=List of 11
[18:01:56.493]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:56.493]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:56.493]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:56.493]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:56.493]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:56.493]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:56.493]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:56.493]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:56.493]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:56.493]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:56.493]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:56.493]  - attr(*, "resolved")= logi FALSE
[18:01:56.493]  - attr(*, "total_size")= num 141240
[18:01:56.493]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.493]  - attr(*, "already-done")= logi TRUE
[18:01:56.515] - copied ‘...future.FUN’ to environment
[18:01:56.515] - copied ‘x_FUN’ to environment
[18:01:56.515] - copied ‘times’ to environment
[18:01:56.516] - copied ‘stopf’ to environment
[18:01:56.516] - copied ‘stop_if_not’ to environment
[18:01:56.516] - copied ‘dim’ to environment
[18:01:56.516] - copied ‘valid_types’ to environment
[18:01:56.517] - copied ‘future.call.arguments’ to environment
[18:01:56.517] - copied ‘...future.elements_ii’ to environment
[18:01:56.517] - copied ‘...future.seeds_ii’ to environment
[18:01:56.517] - copied ‘...future.globals.maxSize’ to environment
[18:01:56.517] assign_globals() ... done
[18:01:56.518] plan(): Setting new future strategy stack:
[18:01:56.518] List of future strategies:
[18:01:56.518] 1. sequential:
[18:01:56.518]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.518]    - tweaked: FALSE
[18:01:56.518]    - call: NULL
[18:01:56.519] plan(): nbrOfWorkers() = 1
[18:01:56.521] plan(): Setting new future strategy stack:
[18:01:56.521] List of future strategies:
[18:01:56.521] 1. sequential:
[18:01:56.521]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.521]    - tweaked: FALSE
[18:01:56.521]    - call: plan(strategy)
[18:01:56.522] plan(): nbrOfWorkers() = 1
[18:01:56.523] SequentialFuture started (and completed)
[18:01:56.523] - Launch lazy future ... done
[18:01:56.523] run() for ‘SequentialFuture’ ... done
[18:01:56.523] Created future:
[18:01:56.523] SequentialFuture:
[18:01:56.523] Label: ‘future_vapply-1’
[18:01:56.523] Expression:
[18:01:56.523] {
[18:01:56.523]     do.call(function(...) {
[18:01:56.523]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.523]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.523]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.523]             on.exit(options(oopts), add = TRUE)
[18:01:56.523]         }
[18:01:56.523]         {
[18:01:56.523]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.523]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.523]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.523]             })
[18:01:56.523]         }
[18:01:56.523]     }, args = future.call.arguments)
[18:01:56.523] }
[18:01:56.523] Lazy evaluation: FALSE
[18:01:56.523] Asynchronous evaluation: FALSE
[18:01:56.523] Local evaluation: TRUE
[18:01:56.523] Environment: R_GlobalEnv
[18:01:56.523] Capture standard output: TRUE
[18:01:56.523] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:56.523] Globals: 11 objects totaling 138.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:56.523] Packages: 2 packages (‘stats’, ‘future.apply’)
[18:01:56.523] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:56.523] Resolved: TRUE
[18:01:56.523] Value: 672 bytes of class ‘list’
[18:01:56.523] Early signaling: FALSE
[18:01:56.523] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:56.523] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.526] Chunk #1 of 1 ... DONE
[18:01:56.526] Launching 1 futures (chunks) ... DONE
[18:01:56.526] Resolving 1 futures (chunks) ...
[18:01:56.526] resolve() on list ...
[18:01:56.527]  recursive: 0
[18:01:56.527]  length: 1
[18:01:56.527] 
[18:01:56.527] resolved() for ‘SequentialFuture’ ...
[18:01:56.527] - state: ‘finished’
[18:01:56.528] - run: TRUE
[18:01:56.528] - result: ‘FutureResult’
[18:01:56.528] resolved() for ‘SequentialFuture’ ... done
[18:01:56.528] Future #1
[18:01:56.529] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:56.529] - nx: 1
[18:01:56.529] - relay: TRUE
[18:01:56.529] - stdout: TRUE
[18:01:56.529] - signal: TRUE
[18:01:56.529] - resignal: FALSE
[18:01:56.530] - force: TRUE
[18:01:56.530] - relayed: [n=1] FALSE
[18:01:56.530] - queued futures: [n=1] FALSE
[18:01:56.530]  - until=1
[18:01:56.530]  - relaying element #1
[18:01:56.531] - relayed: [n=1] TRUE
[18:01:56.531] - queued futures: [n=1] TRUE
[18:01:56.531] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:56.531]  length: 0 (resolved future 1)
[18:01:56.531] Relaying remaining futures
[18:01:56.532] signalConditionsASAP(NULL, pos=0) ...
[18:01:56.532] - nx: 1
[18:01:56.532] - relay: TRUE
[18:01:56.532] - stdout: TRUE
[18:01:56.532] - signal: TRUE
[18:01:56.533] - resignal: FALSE
[18:01:56.533] - force: TRUE
[18:01:56.533] - relayed: [n=1] TRUE
[18:01:56.533] - queued futures: [n=1] TRUE
 - flush all
[18:01:56.533] - relayed: [n=1] TRUE
[18:01:56.534] - queued futures: [n=1] TRUE
[18:01:56.534] signalConditionsASAP(NULL, pos=0) ... done
[18:01:56.534] resolve() on list ... DONE
[18:01:56.534]  - Number of value chunks collected: 1
[18:01:56.534] Resolving 1 futures (chunks) ... DONE
[18:01:56.535] Reducing values from 1 chunks ...
[18:01:56.535]  - Number of values collected after concatenation: 7
[18:01:56.535]  - Number of values expected: 7
[18:01:56.535] Reducing values from 1 chunks ... DONE
[18:01:56.535] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[18:01:56.538] future_lapply() ...
[18:01:56.540] Number of chunks: 1
[18:01:56.540] getGlobalsAndPackagesXApply() ...
[18:01:56.540]  - future.globals: TRUE
[18:01:56.540] getGlobalsAndPackages() ...
[18:01:56.540] Searching for globals...
[18:01:56.543] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[18:01:56.543] Searching for globals ... DONE
[18:01:56.543] Resolving globals: FALSE
[18:01:56.544] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[18:01:56.545] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[18:01:56.545] - globals: [1] ‘FUN’
[18:01:56.545] 
[18:01:56.545] getGlobalsAndPackages() ... DONE
[18:01:56.545]  - globals found/used: [n=1] ‘FUN’
[18:01:56.546]  - needed namespaces: [n=0] 
[18:01:56.546] Finding globals ... DONE
[18:01:56.546]  - use_args: TRUE
[18:01:56.546]  - Getting '...' globals ...
[18:01:56.547] resolve() on list ...
[18:01:56.547]  recursive: 0
[18:01:56.547]  length: 1
[18:01:56.547]  elements: ‘...’
[18:01:56.548]  length: 0 (resolved future 1)
[18:01:56.548] resolve() on list ... DONE
[18:01:56.548]    - '...' content: [n=1] ‘y’
[18:01:56.548] List of 1
[18:01:56.548]  $ ...:List of 1
[18:01:56.548]   ..$ y: num [1:5] 2 4 6 8 10
[18:01:56.548]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.548]  - attr(*, "where")=List of 1
[18:01:56.548]   ..$ ...:<environment: 0x6183c076c440> 
[18:01:56.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.548]  - attr(*, "resolved")= logi TRUE
[18:01:56.548]  - attr(*, "total_size")= num NA
[18:01:56.554]  - Getting '...' globals ... DONE
[18:01:56.554] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:01:56.555] List of 2
[18:01:56.555]  $ ...future.FUN:function (x, y)  
[18:01:56.555]  $ ...          :List of 1
[18:01:56.555]   ..$ y: num [1:5] 2 4 6 8 10
[18:01:56.555]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.555]  - attr(*, "where")=List of 2
[18:01:56.555]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:56.555]   ..$ ...          :<environment: 0x6183c076c440> 
[18:01:56.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.555]  - attr(*, "resolved")= logi FALSE
[18:01:56.555]  - attr(*, "total_size")= num 4264
[18:01:56.563] Packages to be attached in all futures: [n=0] 
[18:01:56.563] getGlobalsAndPackagesXApply() ... DONE
[18:01:56.564] Number of futures (= number of chunks): 1
[18:01:56.564] Launching 1 futures (chunks) ...
[18:01:56.564] Chunk #1 of 1 ...
[18:01:56.565]  - Finding globals in 'X' for chunk #1 ...
[18:01:56.565] getGlobalsAndPackages() ...
[18:01:56.565] Searching for globals...
[18:01:56.566] 
[18:01:56.566] Searching for globals ... DONE
[18:01:56.566] - globals: [0] <none>
[18:01:56.566] getGlobalsAndPackages() ... DONE
[18:01:56.567]    + additional globals found: [n=0] 
[18:01:56.567]    + additional namespaces needed: [n=0] 
[18:01:56.567]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:56.567]  - seeds: <none>
[18:01:56.567]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.568] getGlobalsAndPackages() ...
[18:01:56.568] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.568] Resolving globals: FALSE
[18:01:56.568] Tweak future expression to call with '...' arguments ...
[18:01:56.569] {
[18:01:56.569]     do.call(function(...) {
[18:01:56.569]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.569]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.569]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.569]             on.exit(options(oopts), add = TRUE)
[18:01:56.569]         }
[18:01:56.569]         {
[18:01:56.569]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.569]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.569]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.569]             })
[18:01:56.569]         }
[18:01:56.569]     }, args = future.call.arguments)
[18:01:56.569] }
[18:01:56.569] Tweak future expression to call with '...' arguments ... DONE
[18:01:56.570] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.570] 
[18:01:56.570] getGlobalsAndPackages() ... DONE
[18:01:56.571] run() for ‘Future’ ...
[18:01:56.571] - state: ‘created’
[18:01:56.571] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:56.572] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.572] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:56.573]   - Field: ‘label’
[18:01:56.573]   - Field: ‘local’
[18:01:56.573]   - Field: ‘owner’
[18:01:56.573]   - Field: ‘envir’
[18:01:56.573]   - Field: ‘packages’
[18:01:56.574]   - Field: ‘gc’
[18:01:56.574]   - Field: ‘conditions’
[18:01:56.574]   - Field: ‘expr’
[18:01:56.574]   - Field: ‘uuid’
[18:01:56.574]   - Field: ‘seed’
[18:01:56.575]   - Field: ‘version’
[18:01:56.575]   - Field: ‘result’
[18:01:56.575]   - Field: ‘asynchronous’
[18:01:56.575]   - Field: ‘calls’
[18:01:56.576]   - Field: ‘globals’
[18:01:56.576]   - Field: ‘stdout’
[18:01:56.576]   - Field: ‘earlySignal’
[18:01:56.576]   - Field: ‘lazy’
[18:01:56.576]   - Field: ‘state’
[18:01:56.577] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:56.577] - Launch lazy future ...
[18:01:56.577] Packages needed by the future expression (n = 0): <none>
[18:01:56.577] Packages needed by future strategies (n = 0): <none>
[18:01:56.578] {
[18:01:56.578]     {
[18:01:56.578]         {
[18:01:56.578]             ...future.startTime <- base::Sys.time()
[18:01:56.578]             {
[18:01:56.578]                 {
[18:01:56.578]                   {
[18:01:56.578]                     base::local({
[18:01:56.578]                       has_future <- base::requireNamespace("future", 
[18:01:56.578]                         quietly = TRUE)
[18:01:56.578]                       if (has_future) {
[18:01:56.578]                         ns <- base::getNamespace("future")
[18:01:56.578]                         version <- ns[[".package"]][["version"]]
[18:01:56.578]                         if (is.null(version)) 
[18:01:56.578]                           version <- utils::packageVersion("future")
[18:01:56.578]                       }
[18:01:56.578]                       else {
[18:01:56.578]                         version <- NULL
[18:01:56.578]                       }
[18:01:56.578]                       if (!has_future || version < "1.8.0") {
[18:01:56.578]                         info <- base::c(r_version = base::gsub("R version ", 
[18:01:56.578]                           "", base::R.version$version.string), 
[18:01:56.578]                           platform = base::sprintf("%s (%s-bit)", 
[18:01:56.578]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:56.578]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:56.578]                             "release", "version")], collapse = " "), 
[18:01:56.578]                           hostname = base::Sys.info()[["nodename"]])
[18:01:56.578]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:01:56.578]                           info)
[18:01:56.578]                         info <- base::paste(info, collapse = "; ")
[18:01:56.578]                         if (!has_future) {
[18:01:56.578]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:56.578]                             info)
[18:01:56.578]                         }
[18:01:56.578]                         else {
[18:01:56.578]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:56.578]                             info, version)
[18:01:56.578]                         }
[18:01:56.578]                         base::stop(msg)
[18:01:56.578]                       }
[18:01:56.578]                     })
[18:01:56.578]                   }
[18:01:56.578]                   ...future.strategy.old <- future::plan("list")
[18:01:56.578]                   options(future.plan = NULL)
[18:01:56.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:56.578]                 }
[18:01:56.578]                 ...future.workdir <- getwd()
[18:01:56.578]             }
[18:01:56.578]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:56.578]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:56.578]         }
[18:01:56.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:56.578]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:56.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:56.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:56.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:56.578]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:56.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:56.578]             base::names(...future.oldOptions))
[18:01:56.578]     }
[18:01:56.578]     if (FALSE) {
[18:01:56.578]     }
[18:01:56.578]     else {
[18:01:56.578]         if (TRUE) {
[18:01:56.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:56.578]                 open = "w")
[18:01:56.578]         }
[18:01:56.578]         else {
[18:01:56.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:56.578]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:56.578]         }
[18:01:56.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:56.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:56.578]             base::sink(type = "output", split = FALSE)
[18:01:56.578]             base::close(...future.stdout)
[18:01:56.578]         }, add = TRUE)
[18:01:56.578]     }
[18:01:56.578]     ...future.frame <- base::sys.nframe()
[18:01:56.578]     ...future.conditions <- base::list()
[18:01:56.578]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:56.578]     if (FALSE) {
[18:01:56.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:56.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:56.578]     }
[18:01:56.578]     ...future.result <- base::tryCatch({
[18:01:56.578]         base::withCallingHandlers({
[18:01:56.578]             ...future.value <- base::withVisible(base::local({
[18:01:56.578]                 do.call(function(...) {
[18:01:56.578]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.578]                   if (!identical(...future.globals.maxSize.org, 
[18:01:56.578]                     ...future.globals.maxSize)) {
[18:01:56.578]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.578]                     on.exit(options(oopts), add = TRUE)
[18:01:56.578]                   }
[18:01:56.578]                   {
[18:01:56.578]                     lapply(seq_along(...future.elements_ii), 
[18:01:56.578]                       FUN = function(jj) {
[18:01:56.578]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.578]                         ...future.FUN(...future.X_jj, ...)
[18:01:56.578]                       })
[18:01:56.578]                   }
[18:01:56.578]                 }, args = future.call.arguments)
[18:01:56.578]             }))
[18:01:56.578]             future::FutureResult(value = ...future.value$value, 
[18:01:56.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.578]                   ...future.rng), globalenv = if (FALSE) 
[18:01:56.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:56.578]                     ...future.globalenv.names))
[18:01:56.578]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:56.578]         }, condition = base::local({
[18:01:56.578]             c <- base::c
[18:01:56.578]             inherits <- base::inherits
[18:01:56.578]             invokeRestart <- base::invokeRestart
[18:01:56.578]             length <- base::length
[18:01:56.578]             list <- base::list
[18:01:56.578]             seq.int <- base::seq.int
[18:01:56.578]             signalCondition <- base::signalCondition
[18:01:56.578]             sys.calls <- base::sys.calls
[18:01:56.578]             `[[` <- base::`[[`
[18:01:56.578]             `+` <- base::`+`
[18:01:56.578]             `<<-` <- base::`<<-`
[18:01:56.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:56.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:56.578]                   3L)]
[18:01:56.578]             }
[18:01:56.578]             function(cond) {
[18:01:56.578]                 is_error <- inherits(cond, "error")
[18:01:56.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:56.578]                   NULL)
[18:01:56.578]                 if (is_error) {
[18:01:56.578]                   sessionInformation <- function() {
[18:01:56.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:56.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:56.578]                       search = base::search(), system = base::Sys.info())
[18:01:56.578]                   }
[18:01:56.578]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:56.578]                     cond$call), session = sessionInformation(), 
[18:01:56.578]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:56.578]                   signalCondition(cond)
[18:01:56.578]                 }
[18:01:56.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:56.578]                 "immediateCondition"))) {
[18:01:56.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:56.578]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:56.578]                   if (TRUE && !signal) {
[18:01:56.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.578]                     {
[18:01:56.578]                       inherits <- base::inherits
[18:01:56.578]                       invokeRestart <- base::invokeRestart
[18:01:56.578]                       is.null <- base::is.null
[18:01:56.578]                       muffled <- FALSE
[18:01:56.578]                       if (inherits(cond, "message")) {
[18:01:56.578]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.578]                         if (muffled) 
[18:01:56.578]                           invokeRestart("muffleMessage")
[18:01:56.578]                       }
[18:01:56.578]                       else if (inherits(cond, "warning")) {
[18:01:56.578]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.578]                         if (muffled) 
[18:01:56.578]                           invokeRestart("muffleWarning")
[18:01:56.578]                       }
[18:01:56.578]                       else if (inherits(cond, "condition")) {
[18:01:56.578]                         if (!is.null(pattern)) {
[18:01:56.578]                           computeRestarts <- base::computeRestarts
[18:01:56.578]                           grepl <- base::grepl
[18:01:56.578]                           restarts <- computeRestarts(cond)
[18:01:56.578]                           for (restart in restarts) {
[18:01:56.578]                             name <- restart$name
[18:01:56.578]                             if (is.null(name)) 
[18:01:56.578]                               next
[18:01:56.578]                             if (!grepl(pattern, name)) 
[18:01:56.578]                               next
[18:01:56.578]                             invokeRestart(restart)
[18:01:56.578]                             muffled <- TRUE
[18:01:56.578]                             break
[18:01:56.578]                           }
[18:01:56.578]                         }
[18:01:56.578]                       }
[18:01:56.578]                       invisible(muffled)
[18:01:56.578]                     }
[18:01:56.578]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.578]                   }
[18:01:56.578]                 }
[18:01:56.578]                 else {
[18:01:56.578]                   if (TRUE) {
[18:01:56.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.578]                     {
[18:01:56.578]                       inherits <- base::inherits
[18:01:56.578]                       invokeRestart <- base::invokeRestart
[18:01:56.578]                       is.null <- base::is.null
[18:01:56.578]                       muffled <- FALSE
[18:01:56.578]                       if (inherits(cond, "message")) {
[18:01:56.578]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.578]                         if (muffled) 
[18:01:56.578]                           invokeRestart("muffleMessage")
[18:01:56.578]                       }
[18:01:56.578]                       else if (inherits(cond, "warning")) {
[18:01:56.578]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.578]                         if (muffled) 
[18:01:56.578]                           invokeRestart("muffleWarning")
[18:01:56.578]                       }
[18:01:56.578]                       else if (inherits(cond, "condition")) {
[18:01:56.578]                         if (!is.null(pattern)) {
[18:01:56.578]                           computeRestarts <- base::computeRestarts
[18:01:56.578]                           grepl <- base::grepl
[18:01:56.578]                           restarts <- computeRestarts(cond)
[18:01:56.578]                           for (restart in restarts) {
[18:01:56.578]                             name <- restart$name
[18:01:56.578]                             if (is.null(name)) 
[18:01:56.578]                               next
[18:01:56.578]                             if (!grepl(pattern, name)) 
[18:01:56.578]                               next
[18:01:56.578]                             invokeRestart(restart)
[18:01:56.578]                             muffled <- TRUE
[18:01:56.578]                             break
[18:01:56.578]                           }
[18:01:56.578]                         }
[18:01:56.578]                       }
[18:01:56.578]                       invisible(muffled)
[18:01:56.578]                     }
[18:01:56.578]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.578]                   }
[18:01:56.578]                 }
[18:01:56.578]             }
[18:01:56.578]         }))
[18:01:56.578]     }, error = function(ex) {
[18:01:56.578]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:56.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.578]                 ...future.rng), started = ...future.startTime, 
[18:01:56.578]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:56.578]             version = "1.8"), class = "FutureResult")
[18:01:56.578]     }, finally = {
[18:01:56.578]         if (!identical(...future.workdir, getwd())) 
[18:01:56.578]             setwd(...future.workdir)
[18:01:56.578]         {
[18:01:56.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:56.578]                 ...future.oldOptions$nwarnings <- NULL
[18:01:56.578]             }
[18:01:56.578]             base::options(...future.oldOptions)
[18:01:56.578]             if (.Platform$OS.type == "windows") {
[18:01:56.578]                 old_names <- names(...future.oldEnvVars)
[18:01:56.578]                 envs <- base::Sys.getenv()
[18:01:56.578]                 names <- names(envs)
[18:01:56.578]                 common <- intersect(names, old_names)
[18:01:56.578]                 added <- setdiff(names, old_names)
[18:01:56.578]                 removed <- setdiff(old_names, names)
[18:01:56.578]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:56.578]                   envs[common]]
[18:01:56.578]                 NAMES <- toupper(changed)
[18:01:56.578]                 args <- list()
[18:01:56.578]                 for (kk in seq_along(NAMES)) {
[18:01:56.578]                   name <- changed[[kk]]
[18:01:56.578]                   NAME <- NAMES[[kk]]
[18:01:56.578]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.578]                     next
[18:01:56.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.578]                 }
[18:01:56.578]                 NAMES <- toupper(added)
[18:01:56.578]                 for (kk in seq_along(NAMES)) {
[18:01:56.578]                   name <- added[[kk]]
[18:01:56.578]                   NAME <- NAMES[[kk]]
[18:01:56.578]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.578]                     next
[18:01:56.578]                   args[[name]] <- ""
[18:01:56.578]                 }
[18:01:56.578]                 NAMES <- toupper(removed)
[18:01:56.578]                 for (kk in seq_along(NAMES)) {
[18:01:56.578]                   name <- removed[[kk]]
[18:01:56.578]                   NAME <- NAMES[[kk]]
[18:01:56.578]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.578]                     next
[18:01:56.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.578]                 }
[18:01:56.578]                 if (length(args) > 0) 
[18:01:56.578]                   base::do.call(base::Sys.setenv, args = args)
[18:01:56.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:56.578]             }
[18:01:56.578]             else {
[18:01:56.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:56.578]             }
[18:01:56.578]             {
[18:01:56.578]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:56.578]                   0L) {
[18:01:56.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:56.578]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:56.578]                   base::options(opts)
[18:01:56.578]                 }
[18:01:56.578]                 {
[18:01:56.578]                   {
[18:01:56.578]                     NULL
[18:01:56.578]                     RNGkind("Mersenne-Twister")
[18:01:56.578]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:56.578]                       inherits = FALSE)
[18:01:56.578]                   }
[18:01:56.578]                   options(future.plan = NULL)
[18:01:56.578]                   if (is.na(NA_character_)) 
[18:01:56.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:56.578]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:56.578]                     .init = FALSE)
[18:01:56.578]                 }
[18:01:56.578]             }
[18:01:56.578]         }
[18:01:56.578]     })
[18:01:56.578]     if (TRUE) {
[18:01:56.578]         base::sink(type = "output", split = FALSE)
[18:01:56.578]         if (TRUE) {
[18:01:56.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:56.578]         }
[18:01:56.578]         else {
[18:01:56.578]             ...future.result["stdout"] <- base::list(NULL)
[18:01:56.578]         }
[18:01:56.578]         base::close(...future.stdout)
[18:01:56.578]         ...future.stdout <- NULL
[18:01:56.578]     }
[18:01:56.578]     ...future.result$conditions <- ...future.conditions
[18:01:56.578]     ...future.result$finished <- base::Sys.time()
[18:01:56.578]     ...future.result
[18:01:56.578] }
[18:01:56.582] assign_globals() ...
[18:01:56.582] List of 5
[18:01:56.582]  $ ...future.FUN            :function (x, y)  
[18:01:56.582]  $ future.call.arguments    :List of 1
[18:01:56.582]   ..$ y: num [1:5] 2 4 6 8 10
[18:01:56.582]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.582]  $ ...future.elements_ii    :List of 4
[18:01:56.582]   ..$ A: num 50
[18:01:56.582]   ..$ B: num 60
[18:01:56.582]   ..$ C: num 70
[18:01:56.582]   ..$ D: num 80
[18:01:56.582]  $ ...future.seeds_ii       : NULL
[18:01:56.582]  $ ...future.globals.maxSize: NULL
[18:01:56.582]  - attr(*, "where")=List of 5
[18:01:56.582]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:56.582]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:56.582]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:56.582]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:56.582]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:56.582]  - attr(*, "resolved")= logi FALSE
[18:01:56.582]  - attr(*, "total_size")= num 4264
[18:01:56.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.582]  - attr(*, "already-done")= logi TRUE
[18:01:56.594] - reassign environment for ‘...future.FUN’
[18:01:56.594] - copied ‘...future.FUN’ to environment
[18:01:56.594] - copied ‘future.call.arguments’ to environment
[18:01:56.595] - copied ‘...future.elements_ii’ to environment
[18:01:56.595] - copied ‘...future.seeds_ii’ to environment
[18:01:56.595] - copied ‘...future.globals.maxSize’ to environment
[18:01:56.595] assign_globals() ... done
[18:01:56.596] plan(): Setting new future strategy stack:
[18:01:56.596] List of future strategies:
[18:01:56.596] 1. sequential:
[18:01:56.596]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.596]    - tweaked: FALSE
[18:01:56.596]    - call: NULL
[18:01:56.597] plan(): nbrOfWorkers() = 1
[18:01:56.598] plan(): Setting new future strategy stack:
[18:01:56.598] List of future strategies:
[18:01:56.598] 1. sequential:
[18:01:56.598]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.598]    - tweaked: FALSE
[18:01:56.598]    - call: plan(strategy)
[18:01:56.599] plan(): nbrOfWorkers() = 1
[18:01:56.600] SequentialFuture started (and completed)
[18:01:56.600] - Launch lazy future ... done
[18:01:56.600] run() for ‘SequentialFuture’ ... done
[18:01:56.600] Created future:
[18:01:56.601] SequentialFuture:
[18:01:56.601] Label: ‘future_sapply-1’
[18:01:56.601] Expression:
[18:01:56.601] {
[18:01:56.601]     do.call(function(...) {
[18:01:56.601]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.601]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.601]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.601]             on.exit(options(oopts), add = TRUE)
[18:01:56.601]         }
[18:01:56.601]         {
[18:01:56.601]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.601]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.601]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.601]             })
[18:01:56.601]         }
[18:01:56.601]     }, args = future.call.arguments)
[18:01:56.601] }
[18:01:56.601] Lazy evaluation: FALSE
[18:01:56.601] Asynchronous evaluation: FALSE
[18:01:56.601] Local evaluation: TRUE
[18:01:56.601] Environment: R_GlobalEnv
[18:01:56.601] Capture standard output: TRUE
[18:01:56.601] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:56.601] Globals: 5 objects totaling 4.38 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:56.601] Packages: <none>
[18:01:56.601] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:56.601] Resolved: TRUE
[18:01:56.601] Value: 1.34 KiB of class ‘list’
[18:01:56.601] Early signaling: FALSE
[18:01:56.601] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:56.601] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.603] Chunk #1 of 1 ... DONE
[18:01:56.603] Launching 1 futures (chunks) ... DONE
[18:01:56.603] Resolving 1 futures (chunks) ...
[18:01:56.603] resolve() on list ...
[18:01:56.603]  recursive: 0
[18:01:56.604]  length: 1
[18:01:56.604] 
[18:01:56.604] resolved() for ‘SequentialFuture’ ...
[18:01:56.604] - state: ‘finished’
[18:01:56.604] - run: TRUE
[18:01:56.605] - result: ‘FutureResult’
[18:01:56.605] resolved() for ‘SequentialFuture’ ... done
[18:01:56.605] Future #1
[18:01:56.605] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:56.605] - nx: 1
[18:01:56.606] - relay: TRUE
[18:01:56.606] - stdout: TRUE
[18:01:56.606] - signal: TRUE
[18:01:56.606] - resignal: FALSE
[18:01:56.606] - force: TRUE
[18:01:56.607] - relayed: [n=1] FALSE
[18:01:56.607] - queued futures: [n=1] FALSE
[18:01:56.607]  - until=1
[18:01:56.607]  - relaying element #1
[18:01:56.607] - relayed: [n=1] TRUE
[18:01:56.608] - queued futures: [n=1] TRUE
[18:01:56.608] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:56.608]  length: 0 (resolved future 1)
[18:01:56.608] Relaying remaining futures
[18:01:56.608] signalConditionsASAP(NULL, pos=0) ...
[18:01:56.609] - nx: 1
[18:01:56.609] - relay: TRUE
[18:01:56.609] - stdout: TRUE
[18:01:56.609] - signal: TRUE
[18:01:56.609] - resignal: FALSE
[18:01:56.609] - force: TRUE
[18:01:56.610] - relayed: [n=1] TRUE
[18:01:56.610] - queued futures: [n=1] TRUE
 - flush all
[18:01:56.610] - relayed: [n=1] TRUE
[18:01:56.610] - queued futures: [n=1] TRUE
[18:01:56.610] signalConditionsASAP(NULL, pos=0) ... done
[18:01:56.611] resolve() on list ... DONE
[18:01:56.611]  - Number of value chunks collected: 1
[18:01:56.611] Resolving 1 futures (chunks) ... DONE
[18:01:56.611] Reducing values from 1 chunks ...
[18:01:56.612]  - Number of values collected after concatenation: 4
[18:01:56.612]  - Number of values expected: 4
[18:01:56.612] Reducing values from 1 chunks ... DONE
[18:01:56.612] future_lapply() ... DONE
[18:01:56.615] future_lapply() ...
[18:01:56.619] Number of chunks: 1
[18:01:56.619] getGlobalsAndPackagesXApply() ...
[18:01:56.619]  - future.globals: TRUE
[18:01:56.620] getGlobalsAndPackages() ...
[18:01:56.620] Searching for globals...
[18:01:56.627] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[18:01:56.628] Searching for globals ... DONE
[18:01:56.628] Resolving globals: FALSE
[18:01:56.630] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[18:01:56.630] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:56.631] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:56.631] - packages: [1] ‘future.apply’
[18:01:56.631] getGlobalsAndPackages() ... DONE
[18:01:56.631]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:56.632]  - needed namespaces: [n=1] ‘future.apply’
[18:01:56.632] Finding globals ... DONE
[18:01:56.632]  - use_args: TRUE
[18:01:56.632]  - Getting '...' globals ...
[18:01:56.633] resolve() on list ...
[18:01:56.633]  recursive: 0
[18:01:56.633]  length: 1
[18:01:56.633]  elements: ‘...’
[18:01:56.634]  length: 0 (resolved future 1)
[18:01:56.634] resolve() on list ... DONE
[18:01:56.634]    - '...' content: [n=1] ‘y’
[18:01:56.634] List of 1
[18:01:56.634]  $ ...:List of 1
[18:01:56.634]   ..$ y: num [1:5] 2 4 6 8 10
[18:01:56.634]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.634]  - attr(*, "where")=List of 1
[18:01:56.634]   ..$ ...:<environment: 0x6183bf549750> 
[18:01:56.634]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.634]  - attr(*, "resolved")= logi TRUE
[18:01:56.634]  - attr(*, "total_size")= num NA
[18:01:56.640]  - Getting '...' globals ... DONE
[18:01:56.640] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:56.641] List of 8
[18:01:56.641]  $ ...future.FUN:function (x, ...)  
[18:01:56.641]  $ x_FUN        :function (x, y)  
[18:01:56.641]  $ times        : int 15
[18:01:56.641]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.641]  $ stop_if_not  :function (...)  
[18:01:56.641]  $ dim          : int [1:2] 3 5
[18:01:56.641]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:56.641]  $ ...          :List of 1
[18:01:56.641]   ..$ y: num [1:5] 2 4 6 8 10
[18:01:56.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.641]  - attr(*, "where")=List of 8
[18:01:56.641]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:56.641]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:56.641]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:56.641]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:56.641]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:56.641]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:56.641]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:56.641]   ..$ ...          :<environment: 0x6183bf549750> 
[18:01:56.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.641]  - attr(*, "resolved")= logi FALSE
[18:01:56.641]  - attr(*, "total_size")= num 98600
[18:01:56.653] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:56.653] getGlobalsAndPackagesXApply() ... DONE
[18:01:56.653] Number of futures (= number of chunks): 1
[18:01:56.653] Launching 1 futures (chunks) ...
[18:01:56.654] Chunk #1 of 1 ...
[18:01:56.654]  - Finding globals in 'X' for chunk #1 ...
[18:01:56.654] getGlobalsAndPackages() ...
[18:01:56.654] Searching for globals...
[18:01:56.655] 
[18:01:56.655] Searching for globals ... DONE
[18:01:56.655] - globals: [0] <none>
[18:01:56.655] getGlobalsAndPackages() ... DONE
[18:01:56.656]    + additional globals found: [n=0] 
[18:01:56.656]    + additional namespaces needed: [n=0] 
[18:01:56.656]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:56.656]  - seeds: <none>
[18:01:56.656]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.657] getGlobalsAndPackages() ...
[18:01:56.657] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.657] Resolving globals: FALSE
[18:01:56.657] Tweak future expression to call with '...' arguments ...
[18:01:56.658] {
[18:01:56.658]     do.call(function(...) {
[18:01:56.658]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.658]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.658]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.658]             on.exit(options(oopts), add = TRUE)
[18:01:56.658]         }
[18:01:56.658]         {
[18:01:56.658]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.658]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.658]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.658]             })
[18:01:56.658]         }
[18:01:56.658]     }, args = future.call.arguments)
[18:01:56.658] }
[18:01:56.658] Tweak future expression to call with '...' arguments ... DONE
[18:01:56.661] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.662] - packages: [1] ‘future.apply’
[18:01:56.662] getGlobalsAndPackages() ... DONE
[18:01:56.662] run() for ‘Future’ ...
[18:01:56.663] - state: ‘created’
[18:01:56.663] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:56.664] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.664] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:56.664]   - Field: ‘label’
[18:01:56.664]   - Field: ‘local’
[18:01:56.664]   - Field: ‘owner’
[18:01:56.665]   - Field: ‘envir’
[18:01:56.665]   - Field: ‘packages’
[18:01:56.665]   - Field: ‘gc’
[18:01:56.665]   - Field: ‘conditions’
[18:01:56.666]   - Field: ‘expr’
[18:01:56.666]   - Field: ‘uuid’
[18:01:56.666]   - Field: ‘seed’
[18:01:56.666]   - Field: ‘version’
[18:01:56.666]   - Field: ‘result’
[18:01:56.666]   - Field: ‘asynchronous’
[18:01:56.667]   - Field: ‘calls’
[18:01:56.667]   - Field: ‘globals’
[18:01:56.667]   - Field: ‘stdout’
[18:01:56.667]   - Field: ‘earlySignal’
[18:01:56.667]   - Field: ‘lazy’
[18:01:56.668]   - Field: ‘state’
[18:01:56.668] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:56.668] - Launch lazy future ...
[18:01:56.668] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:56.669] Packages needed by future strategies (n = 0): <none>
[18:01:56.670] {
[18:01:56.670]     {
[18:01:56.670]         {
[18:01:56.670]             ...future.startTime <- base::Sys.time()
[18:01:56.670]             {
[18:01:56.670]                 {
[18:01:56.670]                   {
[18:01:56.670]                     {
[18:01:56.670]                       base::local({
[18:01:56.670]                         has_future <- base::requireNamespace("future", 
[18:01:56.670]                           quietly = TRUE)
[18:01:56.670]                         if (has_future) {
[18:01:56.670]                           ns <- base::getNamespace("future")
[18:01:56.670]                           version <- ns[[".package"]][["version"]]
[18:01:56.670]                           if (is.null(version)) 
[18:01:56.670]                             version <- utils::packageVersion("future")
[18:01:56.670]                         }
[18:01:56.670]                         else {
[18:01:56.670]                           version <- NULL
[18:01:56.670]                         }
[18:01:56.670]                         if (!has_future || version < "1.8.0") {
[18:01:56.670]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:56.670]                             "", base::R.version$version.string), 
[18:01:56.670]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:56.670]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:56.670]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:56.670]                               "release", "version")], collapse = " "), 
[18:01:56.670]                             hostname = base::Sys.info()[["nodename"]])
[18:01:56.670]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:56.670]                             info)
[18:01:56.670]                           info <- base::paste(info, collapse = "; ")
[18:01:56.670]                           if (!has_future) {
[18:01:56.670]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:56.670]                               info)
[18:01:56.670]                           }
[18:01:56.670]                           else {
[18:01:56.670]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:56.670]                               info, version)
[18:01:56.670]                           }
[18:01:56.670]                           base::stop(msg)
[18:01:56.670]                         }
[18:01:56.670]                       })
[18:01:56.670]                     }
[18:01:56.670]                     base::local({
[18:01:56.670]                       for (pkg in "future.apply") {
[18:01:56.670]                         base::loadNamespace(pkg)
[18:01:56.670]                         base::library(pkg, character.only = TRUE)
[18:01:56.670]                       }
[18:01:56.670]                     })
[18:01:56.670]                   }
[18:01:56.670]                   ...future.strategy.old <- future::plan("list")
[18:01:56.670]                   options(future.plan = NULL)
[18:01:56.670]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.670]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:56.670]                 }
[18:01:56.670]                 ...future.workdir <- getwd()
[18:01:56.670]             }
[18:01:56.670]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:56.670]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:56.670]         }
[18:01:56.670]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:56.670]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:56.670]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:56.670]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:56.670]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:56.670]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:56.670]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:56.670]             base::names(...future.oldOptions))
[18:01:56.670]     }
[18:01:56.670]     if (FALSE) {
[18:01:56.670]     }
[18:01:56.670]     else {
[18:01:56.670]         if (TRUE) {
[18:01:56.670]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:56.670]                 open = "w")
[18:01:56.670]         }
[18:01:56.670]         else {
[18:01:56.670]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:56.670]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:56.670]         }
[18:01:56.670]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:56.670]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:56.670]             base::sink(type = "output", split = FALSE)
[18:01:56.670]             base::close(...future.stdout)
[18:01:56.670]         }, add = TRUE)
[18:01:56.670]     }
[18:01:56.670]     ...future.frame <- base::sys.nframe()
[18:01:56.670]     ...future.conditions <- base::list()
[18:01:56.670]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:56.670]     if (FALSE) {
[18:01:56.670]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:56.670]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:56.670]     }
[18:01:56.670]     ...future.result <- base::tryCatch({
[18:01:56.670]         base::withCallingHandlers({
[18:01:56.670]             ...future.value <- base::withVisible(base::local({
[18:01:56.670]                 do.call(function(...) {
[18:01:56.670]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.670]                   if (!identical(...future.globals.maxSize.org, 
[18:01:56.670]                     ...future.globals.maxSize)) {
[18:01:56.670]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.670]                     on.exit(options(oopts), add = TRUE)
[18:01:56.670]                   }
[18:01:56.670]                   {
[18:01:56.670]                     lapply(seq_along(...future.elements_ii), 
[18:01:56.670]                       FUN = function(jj) {
[18:01:56.670]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.670]                         ...future.FUN(...future.X_jj, ...)
[18:01:56.670]                       })
[18:01:56.670]                   }
[18:01:56.670]                 }, args = future.call.arguments)
[18:01:56.670]             }))
[18:01:56.670]             future::FutureResult(value = ...future.value$value, 
[18:01:56.670]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.670]                   ...future.rng), globalenv = if (FALSE) 
[18:01:56.670]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:56.670]                     ...future.globalenv.names))
[18:01:56.670]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:56.670]         }, condition = base::local({
[18:01:56.670]             c <- base::c
[18:01:56.670]             inherits <- base::inherits
[18:01:56.670]             invokeRestart <- base::invokeRestart
[18:01:56.670]             length <- base::length
[18:01:56.670]             list <- base::list
[18:01:56.670]             seq.int <- base::seq.int
[18:01:56.670]             signalCondition <- base::signalCondition
[18:01:56.670]             sys.calls <- base::sys.calls
[18:01:56.670]             `[[` <- base::`[[`
[18:01:56.670]             `+` <- base::`+`
[18:01:56.670]             `<<-` <- base::`<<-`
[18:01:56.670]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:56.670]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:56.670]                   3L)]
[18:01:56.670]             }
[18:01:56.670]             function(cond) {
[18:01:56.670]                 is_error <- inherits(cond, "error")
[18:01:56.670]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:56.670]                   NULL)
[18:01:56.670]                 if (is_error) {
[18:01:56.670]                   sessionInformation <- function() {
[18:01:56.670]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:56.670]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:56.670]                       search = base::search(), system = base::Sys.info())
[18:01:56.670]                   }
[18:01:56.670]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.670]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:56.670]                     cond$call), session = sessionInformation(), 
[18:01:56.670]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:56.670]                   signalCondition(cond)
[18:01:56.670]                 }
[18:01:56.670]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:56.670]                 "immediateCondition"))) {
[18:01:56.670]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:56.670]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.670]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:56.670]                   if (TRUE && !signal) {
[18:01:56.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.670]                     {
[18:01:56.670]                       inherits <- base::inherits
[18:01:56.670]                       invokeRestart <- base::invokeRestart
[18:01:56.670]                       is.null <- base::is.null
[18:01:56.670]                       muffled <- FALSE
[18:01:56.670]                       if (inherits(cond, "message")) {
[18:01:56.670]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.670]                         if (muffled) 
[18:01:56.670]                           invokeRestart("muffleMessage")
[18:01:56.670]                       }
[18:01:56.670]                       else if (inherits(cond, "warning")) {
[18:01:56.670]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.670]                         if (muffled) 
[18:01:56.670]                           invokeRestart("muffleWarning")
[18:01:56.670]                       }
[18:01:56.670]                       else if (inherits(cond, "condition")) {
[18:01:56.670]                         if (!is.null(pattern)) {
[18:01:56.670]                           computeRestarts <- base::computeRestarts
[18:01:56.670]                           grepl <- base::grepl
[18:01:56.670]                           restarts <- computeRestarts(cond)
[18:01:56.670]                           for (restart in restarts) {
[18:01:56.670]                             name <- restart$name
[18:01:56.670]                             if (is.null(name)) 
[18:01:56.670]                               next
[18:01:56.670]                             if (!grepl(pattern, name)) 
[18:01:56.670]                               next
[18:01:56.670]                             invokeRestart(restart)
[18:01:56.670]                             muffled <- TRUE
[18:01:56.670]                             break
[18:01:56.670]                           }
[18:01:56.670]                         }
[18:01:56.670]                       }
[18:01:56.670]                       invisible(muffled)
[18:01:56.670]                     }
[18:01:56.670]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.670]                   }
[18:01:56.670]                 }
[18:01:56.670]                 else {
[18:01:56.670]                   if (TRUE) {
[18:01:56.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.670]                     {
[18:01:56.670]                       inherits <- base::inherits
[18:01:56.670]                       invokeRestart <- base::invokeRestart
[18:01:56.670]                       is.null <- base::is.null
[18:01:56.670]                       muffled <- FALSE
[18:01:56.670]                       if (inherits(cond, "message")) {
[18:01:56.670]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.670]                         if (muffled) 
[18:01:56.670]                           invokeRestart("muffleMessage")
[18:01:56.670]                       }
[18:01:56.670]                       else if (inherits(cond, "warning")) {
[18:01:56.670]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.670]                         if (muffled) 
[18:01:56.670]                           invokeRestart("muffleWarning")
[18:01:56.670]                       }
[18:01:56.670]                       else if (inherits(cond, "condition")) {
[18:01:56.670]                         if (!is.null(pattern)) {
[18:01:56.670]                           computeRestarts <- base::computeRestarts
[18:01:56.670]                           grepl <- base::grepl
[18:01:56.670]                           restarts <- computeRestarts(cond)
[18:01:56.670]                           for (restart in restarts) {
[18:01:56.670]                             name <- restart$name
[18:01:56.670]                             if (is.null(name)) 
[18:01:56.670]                               next
[18:01:56.670]                             if (!grepl(pattern, name)) 
[18:01:56.670]                               next
[18:01:56.670]                             invokeRestart(restart)
[18:01:56.670]                             muffled <- TRUE
[18:01:56.670]                             break
[18:01:56.670]                           }
[18:01:56.670]                         }
[18:01:56.670]                       }
[18:01:56.670]                       invisible(muffled)
[18:01:56.670]                     }
[18:01:56.670]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.670]                   }
[18:01:56.670]                 }
[18:01:56.670]             }
[18:01:56.670]         }))
[18:01:56.670]     }, error = function(ex) {
[18:01:56.670]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:56.670]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.670]                 ...future.rng), started = ...future.startTime, 
[18:01:56.670]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:56.670]             version = "1.8"), class = "FutureResult")
[18:01:56.670]     }, finally = {
[18:01:56.670]         if (!identical(...future.workdir, getwd())) 
[18:01:56.670]             setwd(...future.workdir)
[18:01:56.670]         {
[18:01:56.670]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:56.670]                 ...future.oldOptions$nwarnings <- NULL
[18:01:56.670]             }
[18:01:56.670]             base::options(...future.oldOptions)
[18:01:56.670]             if (.Platform$OS.type == "windows") {
[18:01:56.670]                 old_names <- names(...future.oldEnvVars)
[18:01:56.670]                 envs <- base::Sys.getenv()
[18:01:56.670]                 names <- names(envs)
[18:01:56.670]                 common <- intersect(names, old_names)
[18:01:56.670]                 added <- setdiff(names, old_names)
[18:01:56.670]                 removed <- setdiff(old_names, names)
[18:01:56.670]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:56.670]                   envs[common]]
[18:01:56.670]                 NAMES <- toupper(changed)
[18:01:56.670]                 args <- list()
[18:01:56.670]                 for (kk in seq_along(NAMES)) {
[18:01:56.670]                   name <- changed[[kk]]
[18:01:56.670]                   NAME <- NAMES[[kk]]
[18:01:56.670]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.670]                     next
[18:01:56.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.670]                 }
[18:01:56.670]                 NAMES <- toupper(added)
[18:01:56.670]                 for (kk in seq_along(NAMES)) {
[18:01:56.670]                   name <- added[[kk]]
[18:01:56.670]                   NAME <- NAMES[[kk]]
[18:01:56.670]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.670]                     next
[18:01:56.670]                   args[[name]] <- ""
[18:01:56.670]                 }
[18:01:56.670]                 NAMES <- toupper(removed)
[18:01:56.670]                 for (kk in seq_along(NAMES)) {
[18:01:56.670]                   name <- removed[[kk]]
[18:01:56.670]                   NAME <- NAMES[[kk]]
[18:01:56.670]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.670]                     next
[18:01:56.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.670]                 }
[18:01:56.670]                 if (length(args) > 0) 
[18:01:56.670]                   base::do.call(base::Sys.setenv, args = args)
[18:01:56.670]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:56.670]             }
[18:01:56.670]             else {
[18:01:56.670]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:56.670]             }
[18:01:56.670]             {
[18:01:56.670]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:56.670]                   0L) {
[18:01:56.670]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:56.670]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:56.670]                   base::options(opts)
[18:01:56.670]                 }
[18:01:56.670]                 {
[18:01:56.670]                   {
[18:01:56.670]                     NULL
[18:01:56.670]                     RNGkind("Mersenne-Twister")
[18:01:56.670]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:56.670]                       inherits = FALSE)
[18:01:56.670]                   }
[18:01:56.670]                   options(future.plan = NULL)
[18:01:56.670]                   if (is.na(NA_character_)) 
[18:01:56.670]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.670]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:56.670]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:56.670]                     .init = FALSE)
[18:01:56.670]                 }
[18:01:56.670]             }
[18:01:56.670]         }
[18:01:56.670]     })
[18:01:56.670]     if (TRUE) {
[18:01:56.670]         base::sink(type = "output", split = FALSE)
[18:01:56.670]         if (TRUE) {
[18:01:56.670]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:56.670]         }
[18:01:56.670]         else {
[18:01:56.670]             ...future.result["stdout"] <- base::list(NULL)
[18:01:56.670]         }
[18:01:56.670]         base::close(...future.stdout)
[18:01:56.670]         ...future.stdout <- NULL
[18:01:56.670]     }
[18:01:56.670]     ...future.result$conditions <- ...future.conditions
[18:01:56.670]     ...future.result$finished <- base::Sys.time()
[18:01:56.670]     ...future.result
[18:01:56.670] }
[18:01:56.673] assign_globals() ...
[18:01:56.674] List of 11
[18:01:56.674]  $ ...future.FUN            :function (x, ...)  
[18:01:56.674]  $ x_FUN                    :function (x, y)  
[18:01:56.674]  $ times                    : int 15
[18:01:56.674]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.674]  $ stop_if_not              :function (...)  
[18:01:56.674]  $ dim                      : int [1:2] 3 5
[18:01:56.674]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:56.674]  $ future.call.arguments    :List of 1
[18:01:56.674]   ..$ y: num [1:5] 2 4 6 8 10
[18:01:56.674]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.674]  $ ...future.elements_ii    :List of 4
[18:01:56.674]   ..$ A: num 50
[18:01:56.674]   ..$ B: num 60
[18:01:56.674]   ..$ C: num 70
[18:01:56.674]   ..$ D: num 80
[18:01:56.674]  $ ...future.seeds_ii       : NULL
[18:01:56.674]  $ ...future.globals.maxSize: NULL
[18:01:56.674]  - attr(*, "where")=List of 11
[18:01:56.674]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:56.674]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:56.674]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:56.674]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:56.674]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:56.674]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:56.674]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:56.674]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:56.674]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:56.674]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:56.674]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:56.674]  - attr(*, "resolved")= logi FALSE
[18:01:56.674]  - attr(*, "total_size")= num 98600
[18:01:56.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.674]  - attr(*, "already-done")= logi TRUE
[18:01:56.691] - copied ‘...future.FUN’ to environment
[18:01:56.691] - reassign environment for ‘x_FUN’
[18:01:56.692] - copied ‘x_FUN’ to environment
[18:01:56.692] - copied ‘times’ to environment
[18:01:56.692] - copied ‘stopf’ to environment
[18:01:56.692] - copied ‘stop_if_not’ to environment
[18:01:56.692] - copied ‘dim’ to environment
[18:01:56.693] - copied ‘valid_types’ to environment
[18:01:56.693] - copied ‘future.call.arguments’ to environment
[18:01:56.693] - copied ‘...future.elements_ii’ to environment
[18:01:56.693] - copied ‘...future.seeds_ii’ to environment
[18:01:56.694] - copied ‘...future.globals.maxSize’ to environment
[18:01:56.694] assign_globals() ... done
[18:01:56.694] plan(): Setting new future strategy stack:
[18:01:56.695] List of future strategies:
[18:01:56.695] 1. sequential:
[18:01:56.695]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.695]    - tweaked: FALSE
[18:01:56.695]    - call: NULL
[18:01:56.696] plan(): nbrOfWorkers() = 1
[18:01:56.697] plan(): Setting new future strategy stack:
[18:01:56.697] List of future strategies:
[18:01:56.697] 1. sequential:
[18:01:56.697]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.697]    - tweaked: FALSE
[18:01:56.697]    - call: plan(strategy)
[18:01:56.699] plan(): nbrOfWorkers() = 1
[18:01:56.699] SequentialFuture started (and completed)
[18:01:56.699] - Launch lazy future ... done
[18:01:56.699] run() for ‘SequentialFuture’ ... done
[18:01:56.700] Created future:
[18:01:56.700] SequentialFuture:
[18:01:56.700] Label: ‘future_vapply-1’
[18:01:56.700] Expression:
[18:01:56.700] {
[18:01:56.700]     do.call(function(...) {
[18:01:56.700]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.700]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.700]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.700]             on.exit(options(oopts), add = TRUE)
[18:01:56.700]         }
[18:01:56.700]         {
[18:01:56.700]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.700]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.700]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.700]             })
[18:01:56.700]         }
[18:01:56.700]     }, args = future.call.arguments)
[18:01:56.700] }
[18:01:56.700] Lazy evaluation: FALSE
[18:01:56.700] Asynchronous evaluation: FALSE
[18:01:56.700] Local evaluation: TRUE
[18:01:56.700] Environment: R_GlobalEnv
[18:01:56.700] Capture standard output: TRUE
[18:01:56.700] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:56.700] Globals: 11 objects totaling 96.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:56.700] Packages: 1 packages (‘future.apply’)
[18:01:56.700] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:56.700] Resolved: TRUE
[18:01:56.700] Value: 1.34 KiB of class ‘list’
[18:01:56.700] Early signaling: FALSE
[18:01:56.700] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:56.700] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.703] Chunk #1 of 1 ... DONE
[18:01:56.703] Launching 1 futures (chunks) ... DONE
[18:01:56.703] Resolving 1 futures (chunks) ...
[18:01:56.703] resolve() on list ...
[18:01:56.703]  recursive: 0
[18:01:56.704]  length: 1
[18:01:56.704] 
[18:01:56.704] resolved() for ‘SequentialFuture’ ...
[18:01:56.704] - state: ‘finished’
[18:01:56.704] - run: TRUE
[18:01:56.705] - result: ‘FutureResult’
[18:01:56.705] resolved() for ‘SequentialFuture’ ... done
[18:01:56.705] Future #1
[18:01:56.705] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:56.706] - nx: 1
[18:01:56.706] - relay: TRUE
[18:01:56.706] - stdout: TRUE
[18:01:56.706] - signal: TRUE
[18:01:56.706] - resignal: FALSE
[18:01:56.706] - force: TRUE
[18:01:56.707] - relayed: [n=1] FALSE
[18:01:56.707] - queued futures: [n=1] FALSE
[18:01:56.707]  - until=1
[18:01:56.707]  - relaying element #1
[18:01:56.708] - relayed: [n=1] TRUE
[18:01:56.708] - queued futures: [n=1] TRUE
[18:01:56.708] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:56.708]  length: 0 (resolved future 1)
[18:01:56.709] Relaying remaining futures
[18:01:56.709] signalConditionsASAP(NULL, pos=0) ...
[18:01:56.709] - nx: 1
[18:01:56.709] - relay: TRUE
[18:01:56.709] - stdout: TRUE
[18:01:56.709] - signal: TRUE
[18:01:56.710] - resignal: FALSE
[18:01:56.710] - force: TRUE
[18:01:56.710] - relayed: [n=1] TRUE
[18:01:56.710] - queued futures: [n=1] TRUE
 - flush all
[18:01:56.713] - relayed: [n=1] TRUE
[18:01:56.713] - queued futures: [n=1] TRUE
[18:01:56.713] signalConditionsASAP(NULL, pos=0) ... done
[18:01:56.714] resolve() on list ... DONE
[18:01:56.714]  - Number of value chunks collected: 1
[18:01:56.714] Resolving 1 futures (chunks) ... DONE
[18:01:56.714] Reducing values from 1 chunks ...
[18:01:56.715]  - Number of values collected after concatenation: 4
[18:01:56.715]  - Number of values expected: 4
[18:01:56.715] Reducing values from 1 chunks ... DONE
[18:01:56.715] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[18:01:56.720] future_lapply() ...
[18:01:56.723] Number of chunks: 1
[18:01:56.724] getGlobalsAndPackagesXApply() ...
[18:01:56.724]  - future.globals: TRUE
[18:01:56.724] getGlobalsAndPackages() ...
[18:01:56.724] Searching for globals...
[18:01:56.731] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:01:56.731] Searching for globals ... DONE
[18:01:56.732] Resolving globals: FALSE
[18:01:56.733] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[18:01:56.734] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:56.735] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:56.735] - packages: [1] ‘future.apply’
[18:01:56.735] getGlobalsAndPackages() ... DONE
[18:01:56.736]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:56.736]  - needed namespaces: [n=1] ‘future.apply’
[18:01:56.736] Finding globals ... DONE
[18:01:56.736]  - use_args: TRUE
[18:01:56.736]  - Getting '...' globals ...
[18:01:56.737] resolve() on list ...
[18:01:56.738]  recursive: 0
[18:01:56.738]  length: 1
[18:01:56.738]  elements: ‘...’
[18:01:56.739]  length: 0 (resolved future 1)
[18:01:56.739] resolve() on list ... DONE
[18:01:56.739]    - '...' content: [n=0] 
[18:01:56.739] List of 1
[18:01:56.739]  $ ...: list()
[18:01:56.739]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.739]  - attr(*, "where")=List of 1
[18:01:56.739]   ..$ ...:<environment: 0x6183bf2ffd60> 
[18:01:56.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.739]  - attr(*, "resolved")= logi TRUE
[18:01:56.739]  - attr(*, "total_size")= num NA
[18:01:56.745]  - Getting '...' globals ... DONE
[18:01:56.746] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:56.746] List of 8
[18:01:56.746]  $ ...future.FUN:function (x, ...)  
[18:01:56.746]  $ x_FUN        :function (x)  
[18:01:56.746]  $ times        : int 1
[18:01:56.746]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.746]  $ stop_if_not  :function (...)  
[18:01:56.746]  $ dim          : NULL
[18:01:56.746]  $ valid_types  : chr "logical"
[18:01:56.746]  $ ...          : list()
[18:01:56.746]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.746]  - attr(*, "where")=List of 8
[18:01:56.746]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:56.746]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:56.746]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:56.746]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:56.746]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:56.746]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:56.746]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:56.746]   ..$ ...          :<environment: 0x6183bf2ffd60> 
[18:01:56.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.746]  - attr(*, "resolved")= logi FALSE
[18:01:56.746]  - attr(*, "total_size")= num 94200
[18:01:56.758] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:56.758] getGlobalsAndPackagesXApply() ... DONE
[18:01:56.758] Number of futures (= number of chunks): 1
[18:01:56.759] Launching 1 futures (chunks) ...
[18:01:56.759] Chunk #1 of 1 ...
[18:01:56.759]  - Finding globals in 'X' for chunk #1 ...
[18:01:56.759] getGlobalsAndPackages() ...
[18:01:56.759] Searching for globals...
[18:01:56.760] 
[18:01:56.760] Searching for globals ... DONE
[18:01:56.760] - globals: [0] <none>
[18:01:56.761] getGlobalsAndPackages() ... DONE
[18:01:56.761]    + additional globals found: [n=0] 
[18:01:56.761]    + additional namespaces needed: [n=0] 
[18:01:56.761]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:56.761]  - seeds: <none>
[18:01:56.762]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.764] getGlobalsAndPackages() ...
[18:01:56.765] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.765] Resolving globals: FALSE
[18:01:56.765] Tweak future expression to call with '...' arguments ...
[18:01:56.765] {
[18:01:56.765]     do.call(function(...) {
[18:01:56.765]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.765]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.765]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.765]             on.exit(options(oopts), add = TRUE)
[18:01:56.765]         }
[18:01:56.765]         {
[18:01:56.765]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.765]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.765]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.765]             })
[18:01:56.765]         }
[18:01:56.765]     }, args = future.call.arguments)
[18:01:56.765] }
[18:01:56.766] Tweak future expression to call with '...' arguments ... DONE
[18:01:56.767] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.768] - packages: [1] ‘future.apply’
[18:01:56.768] getGlobalsAndPackages() ... DONE
[18:01:56.769] run() for ‘Future’ ...
[18:01:56.769] - state: ‘created’
[18:01:56.769] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:56.770] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.770] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:56.770]   - Field: ‘label’
[18:01:56.771]   - Field: ‘local’
[18:01:56.771]   - Field: ‘owner’
[18:01:56.771]   - Field: ‘envir’
[18:01:56.771]   - Field: ‘packages’
[18:01:56.771]   - Field: ‘gc’
[18:01:56.772]   - Field: ‘conditions’
[18:01:56.772]   - Field: ‘expr’
[18:01:56.772]   - Field: ‘uuid’
[18:01:56.772]   - Field: ‘seed’
[18:01:56.772]   - Field: ‘version’
[18:01:56.773]   - Field: ‘result’
[18:01:56.773]   - Field: ‘asynchronous’
[18:01:56.773]   - Field: ‘calls’
[18:01:56.773]   - Field: ‘globals’
[18:01:56.773]   - Field: ‘stdout’
[18:01:56.774]   - Field: ‘earlySignal’
[18:01:56.774]   - Field: ‘lazy’
[18:01:56.774]   - Field: ‘state’
[18:01:56.774] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:56.774] - Launch lazy future ...
[18:01:56.775] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:56.775] Packages needed by future strategies (n = 0): <none>
[18:01:56.776] {
[18:01:56.776]     {
[18:01:56.776]         {
[18:01:56.776]             ...future.startTime <- base::Sys.time()
[18:01:56.776]             {
[18:01:56.776]                 {
[18:01:56.776]                   {
[18:01:56.776]                     {
[18:01:56.776]                       base::local({
[18:01:56.776]                         has_future <- base::requireNamespace("future", 
[18:01:56.776]                           quietly = TRUE)
[18:01:56.776]                         if (has_future) {
[18:01:56.776]                           ns <- base::getNamespace("future")
[18:01:56.776]                           version <- ns[[".package"]][["version"]]
[18:01:56.776]                           if (is.null(version)) 
[18:01:56.776]                             version <- utils::packageVersion("future")
[18:01:56.776]                         }
[18:01:56.776]                         else {
[18:01:56.776]                           version <- NULL
[18:01:56.776]                         }
[18:01:56.776]                         if (!has_future || version < "1.8.0") {
[18:01:56.776]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:56.776]                             "", base::R.version$version.string), 
[18:01:56.776]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:56.776]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:56.776]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:56.776]                               "release", "version")], collapse = " "), 
[18:01:56.776]                             hostname = base::Sys.info()[["nodename"]])
[18:01:56.776]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:56.776]                             info)
[18:01:56.776]                           info <- base::paste(info, collapse = "; ")
[18:01:56.776]                           if (!has_future) {
[18:01:56.776]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:56.776]                               info)
[18:01:56.776]                           }
[18:01:56.776]                           else {
[18:01:56.776]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:56.776]                               info, version)
[18:01:56.776]                           }
[18:01:56.776]                           base::stop(msg)
[18:01:56.776]                         }
[18:01:56.776]                       })
[18:01:56.776]                     }
[18:01:56.776]                     base::local({
[18:01:56.776]                       for (pkg in "future.apply") {
[18:01:56.776]                         base::loadNamespace(pkg)
[18:01:56.776]                         base::library(pkg, character.only = TRUE)
[18:01:56.776]                       }
[18:01:56.776]                     })
[18:01:56.776]                   }
[18:01:56.776]                   ...future.strategy.old <- future::plan("list")
[18:01:56.776]                   options(future.plan = NULL)
[18:01:56.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:56.776]                 }
[18:01:56.776]                 ...future.workdir <- getwd()
[18:01:56.776]             }
[18:01:56.776]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:56.776]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:56.776]         }
[18:01:56.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:56.776]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:56.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:56.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:56.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:56.776]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:56.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:56.776]             base::names(...future.oldOptions))
[18:01:56.776]     }
[18:01:56.776]     if (FALSE) {
[18:01:56.776]     }
[18:01:56.776]     else {
[18:01:56.776]         if (TRUE) {
[18:01:56.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:56.776]                 open = "w")
[18:01:56.776]         }
[18:01:56.776]         else {
[18:01:56.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:56.776]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:56.776]         }
[18:01:56.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:56.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:56.776]             base::sink(type = "output", split = FALSE)
[18:01:56.776]             base::close(...future.stdout)
[18:01:56.776]         }, add = TRUE)
[18:01:56.776]     }
[18:01:56.776]     ...future.frame <- base::sys.nframe()
[18:01:56.776]     ...future.conditions <- base::list()
[18:01:56.776]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:56.776]     if (FALSE) {
[18:01:56.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:56.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:56.776]     }
[18:01:56.776]     ...future.result <- base::tryCatch({
[18:01:56.776]         base::withCallingHandlers({
[18:01:56.776]             ...future.value <- base::withVisible(base::local({
[18:01:56.776]                 do.call(function(...) {
[18:01:56.776]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.776]                   if (!identical(...future.globals.maxSize.org, 
[18:01:56.776]                     ...future.globals.maxSize)) {
[18:01:56.776]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.776]                     on.exit(options(oopts), add = TRUE)
[18:01:56.776]                   }
[18:01:56.776]                   {
[18:01:56.776]                     lapply(seq_along(...future.elements_ii), 
[18:01:56.776]                       FUN = function(jj) {
[18:01:56.776]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.776]                         ...future.FUN(...future.X_jj, ...)
[18:01:56.776]                       })
[18:01:56.776]                   }
[18:01:56.776]                 }, args = future.call.arguments)
[18:01:56.776]             }))
[18:01:56.776]             future::FutureResult(value = ...future.value$value, 
[18:01:56.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.776]                   ...future.rng), globalenv = if (FALSE) 
[18:01:56.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:56.776]                     ...future.globalenv.names))
[18:01:56.776]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:56.776]         }, condition = base::local({
[18:01:56.776]             c <- base::c
[18:01:56.776]             inherits <- base::inherits
[18:01:56.776]             invokeRestart <- base::invokeRestart
[18:01:56.776]             length <- base::length
[18:01:56.776]             list <- base::list
[18:01:56.776]             seq.int <- base::seq.int
[18:01:56.776]             signalCondition <- base::signalCondition
[18:01:56.776]             sys.calls <- base::sys.calls
[18:01:56.776]             `[[` <- base::`[[`
[18:01:56.776]             `+` <- base::`+`
[18:01:56.776]             `<<-` <- base::`<<-`
[18:01:56.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:56.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:56.776]                   3L)]
[18:01:56.776]             }
[18:01:56.776]             function(cond) {
[18:01:56.776]                 is_error <- inherits(cond, "error")
[18:01:56.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:56.776]                   NULL)
[18:01:56.776]                 if (is_error) {
[18:01:56.776]                   sessionInformation <- function() {
[18:01:56.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:56.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:56.776]                       search = base::search(), system = base::Sys.info())
[18:01:56.776]                   }
[18:01:56.776]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:56.776]                     cond$call), session = sessionInformation(), 
[18:01:56.776]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:56.776]                   signalCondition(cond)
[18:01:56.776]                 }
[18:01:56.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:56.776]                 "immediateCondition"))) {
[18:01:56.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:56.776]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:56.776]                   if (TRUE && !signal) {
[18:01:56.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.776]                     {
[18:01:56.776]                       inherits <- base::inherits
[18:01:56.776]                       invokeRestart <- base::invokeRestart
[18:01:56.776]                       is.null <- base::is.null
[18:01:56.776]                       muffled <- FALSE
[18:01:56.776]                       if (inherits(cond, "message")) {
[18:01:56.776]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.776]                         if (muffled) 
[18:01:56.776]                           invokeRestart("muffleMessage")
[18:01:56.776]                       }
[18:01:56.776]                       else if (inherits(cond, "warning")) {
[18:01:56.776]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.776]                         if (muffled) 
[18:01:56.776]                           invokeRestart("muffleWarning")
[18:01:56.776]                       }
[18:01:56.776]                       else if (inherits(cond, "condition")) {
[18:01:56.776]                         if (!is.null(pattern)) {
[18:01:56.776]                           computeRestarts <- base::computeRestarts
[18:01:56.776]                           grepl <- base::grepl
[18:01:56.776]                           restarts <- computeRestarts(cond)
[18:01:56.776]                           for (restart in restarts) {
[18:01:56.776]                             name <- restart$name
[18:01:56.776]                             if (is.null(name)) 
[18:01:56.776]                               next
[18:01:56.776]                             if (!grepl(pattern, name)) 
[18:01:56.776]                               next
[18:01:56.776]                             invokeRestart(restart)
[18:01:56.776]                             muffled <- TRUE
[18:01:56.776]                             break
[18:01:56.776]                           }
[18:01:56.776]                         }
[18:01:56.776]                       }
[18:01:56.776]                       invisible(muffled)
[18:01:56.776]                     }
[18:01:56.776]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.776]                   }
[18:01:56.776]                 }
[18:01:56.776]                 else {
[18:01:56.776]                   if (TRUE) {
[18:01:56.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.776]                     {
[18:01:56.776]                       inherits <- base::inherits
[18:01:56.776]                       invokeRestart <- base::invokeRestart
[18:01:56.776]                       is.null <- base::is.null
[18:01:56.776]                       muffled <- FALSE
[18:01:56.776]                       if (inherits(cond, "message")) {
[18:01:56.776]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.776]                         if (muffled) 
[18:01:56.776]                           invokeRestart("muffleMessage")
[18:01:56.776]                       }
[18:01:56.776]                       else if (inherits(cond, "warning")) {
[18:01:56.776]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.776]                         if (muffled) 
[18:01:56.776]                           invokeRestart("muffleWarning")
[18:01:56.776]                       }
[18:01:56.776]                       else if (inherits(cond, "condition")) {
[18:01:56.776]                         if (!is.null(pattern)) {
[18:01:56.776]                           computeRestarts <- base::computeRestarts
[18:01:56.776]                           grepl <- base::grepl
[18:01:56.776]                           restarts <- computeRestarts(cond)
[18:01:56.776]                           for (restart in restarts) {
[18:01:56.776]                             name <- restart$name
[18:01:56.776]                             if (is.null(name)) 
[18:01:56.776]                               next
[18:01:56.776]                             if (!grepl(pattern, name)) 
[18:01:56.776]                               next
[18:01:56.776]                             invokeRestart(restart)
[18:01:56.776]                             muffled <- TRUE
[18:01:56.776]                             break
[18:01:56.776]                           }
[18:01:56.776]                         }
[18:01:56.776]                       }
[18:01:56.776]                       invisible(muffled)
[18:01:56.776]                     }
[18:01:56.776]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.776]                   }
[18:01:56.776]                 }
[18:01:56.776]             }
[18:01:56.776]         }))
[18:01:56.776]     }, error = function(ex) {
[18:01:56.776]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:56.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.776]                 ...future.rng), started = ...future.startTime, 
[18:01:56.776]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:56.776]             version = "1.8"), class = "FutureResult")
[18:01:56.776]     }, finally = {
[18:01:56.776]         if (!identical(...future.workdir, getwd())) 
[18:01:56.776]             setwd(...future.workdir)
[18:01:56.776]         {
[18:01:56.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:56.776]                 ...future.oldOptions$nwarnings <- NULL
[18:01:56.776]             }
[18:01:56.776]             base::options(...future.oldOptions)
[18:01:56.776]             if (.Platform$OS.type == "windows") {
[18:01:56.776]                 old_names <- names(...future.oldEnvVars)
[18:01:56.776]                 envs <- base::Sys.getenv()
[18:01:56.776]                 names <- names(envs)
[18:01:56.776]                 common <- intersect(names, old_names)
[18:01:56.776]                 added <- setdiff(names, old_names)
[18:01:56.776]                 removed <- setdiff(old_names, names)
[18:01:56.776]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:56.776]                   envs[common]]
[18:01:56.776]                 NAMES <- toupper(changed)
[18:01:56.776]                 args <- list()
[18:01:56.776]                 for (kk in seq_along(NAMES)) {
[18:01:56.776]                   name <- changed[[kk]]
[18:01:56.776]                   NAME <- NAMES[[kk]]
[18:01:56.776]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.776]                     next
[18:01:56.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.776]                 }
[18:01:56.776]                 NAMES <- toupper(added)
[18:01:56.776]                 for (kk in seq_along(NAMES)) {
[18:01:56.776]                   name <- added[[kk]]
[18:01:56.776]                   NAME <- NAMES[[kk]]
[18:01:56.776]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.776]                     next
[18:01:56.776]                   args[[name]] <- ""
[18:01:56.776]                 }
[18:01:56.776]                 NAMES <- toupper(removed)
[18:01:56.776]                 for (kk in seq_along(NAMES)) {
[18:01:56.776]                   name <- removed[[kk]]
[18:01:56.776]                   NAME <- NAMES[[kk]]
[18:01:56.776]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.776]                     next
[18:01:56.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.776]                 }
[18:01:56.776]                 if (length(args) > 0) 
[18:01:56.776]                   base::do.call(base::Sys.setenv, args = args)
[18:01:56.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:56.776]             }
[18:01:56.776]             else {
[18:01:56.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:56.776]             }
[18:01:56.776]             {
[18:01:56.776]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:56.776]                   0L) {
[18:01:56.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:56.776]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:56.776]                   base::options(opts)
[18:01:56.776]                 }
[18:01:56.776]                 {
[18:01:56.776]                   {
[18:01:56.776]                     NULL
[18:01:56.776]                     RNGkind("Mersenne-Twister")
[18:01:56.776]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:56.776]                       inherits = FALSE)
[18:01:56.776]                   }
[18:01:56.776]                   options(future.plan = NULL)
[18:01:56.776]                   if (is.na(NA_character_)) 
[18:01:56.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:56.776]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:56.776]                     .init = FALSE)
[18:01:56.776]                 }
[18:01:56.776]             }
[18:01:56.776]         }
[18:01:56.776]     })
[18:01:56.776]     if (TRUE) {
[18:01:56.776]         base::sink(type = "output", split = FALSE)
[18:01:56.776]         if (TRUE) {
[18:01:56.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:56.776]         }
[18:01:56.776]         else {
[18:01:56.776]             ...future.result["stdout"] <- base::list(NULL)
[18:01:56.776]         }
[18:01:56.776]         base::close(...future.stdout)
[18:01:56.776]         ...future.stdout <- NULL
[18:01:56.776]     }
[18:01:56.776]     ...future.result$conditions <- ...future.conditions
[18:01:56.776]     ...future.result$finished <- base::Sys.time()
[18:01:56.776]     ...future.result
[18:01:56.776] }
[18:01:56.780] assign_globals() ...
[18:01:56.780] List of 11
[18:01:56.780]  $ ...future.FUN            :function (x, ...)  
[18:01:56.780]  $ x_FUN                    :function (x)  
[18:01:56.780]  $ times                    : int 1
[18:01:56.780]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.780]  $ stop_if_not              :function (...)  
[18:01:56.780]  $ dim                      : NULL
[18:01:56.780]  $ valid_types              : chr "logical"
[18:01:56.780]  $ future.call.arguments    : list()
[18:01:56.780]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.780]  $ ...future.elements_ii    :List of 11
[18:01:56.780]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[18:01:56.780]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[18:01:56.780]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[18:01:56.780]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[18:01:56.780]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[18:01:56.780]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[18:01:56.780]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[18:01:56.780]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[18:01:56.780]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[18:01:56.780]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[18:01:56.780]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[18:01:56.780]  $ ...future.seeds_ii       : NULL
[18:01:56.780]  $ ...future.globals.maxSize: NULL
[18:01:56.780]  - attr(*, "where")=List of 11
[18:01:56.780]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:56.780]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:56.780]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:56.780]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:56.780]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:56.780]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:56.780]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:56.780]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:56.780]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:56.780]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:56.780]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:56.780]  - attr(*, "resolved")= logi FALSE
[18:01:56.780]  - attr(*, "total_size")= num 94200
[18:01:56.780]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.780]  - attr(*, "already-done")= logi TRUE
[18:01:56.803] - copied ‘...future.FUN’ to environment
[18:01:56.803] - copied ‘x_FUN’ to environment
[18:01:56.803] - copied ‘times’ to environment
[18:01:56.803] - copied ‘stopf’ to environment
[18:01:56.804] - copied ‘stop_if_not’ to environment
[18:01:56.804] - copied ‘dim’ to environment
[18:01:56.804] - copied ‘valid_types’ to environment
[18:01:56.804] - copied ‘future.call.arguments’ to environment
[18:01:56.805] - copied ‘...future.elements_ii’ to environment
[18:01:56.805] - copied ‘...future.seeds_ii’ to environment
[18:01:56.805] - copied ‘...future.globals.maxSize’ to environment
[18:01:56.805] assign_globals() ... done
[18:01:56.806] plan(): Setting new future strategy stack:
[18:01:56.806] List of future strategies:
[18:01:56.806] 1. sequential:
[18:01:56.806]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.806]    - tweaked: FALSE
[18:01:56.806]    - call: NULL
[18:01:56.807] plan(): nbrOfWorkers() = 1
[18:01:56.809] plan(): Setting new future strategy stack:
[18:01:56.809] List of future strategies:
[18:01:56.809] 1. sequential:
[18:01:56.809]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.809]    - tweaked: FALSE
[18:01:56.809]    - call: plan(strategy)
[18:01:56.810] plan(): nbrOfWorkers() = 1
[18:01:56.810] SequentialFuture started (and completed)
[18:01:56.810] - Launch lazy future ... done
[18:01:56.810] run() for ‘SequentialFuture’ ... done
[18:01:56.811] Created future:
[18:01:56.811] SequentialFuture:
[18:01:56.811] Label: ‘future_vapply-1’
[18:01:56.811] Expression:
[18:01:56.811] {
[18:01:56.811]     do.call(function(...) {
[18:01:56.811]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.811]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.811]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.811]             on.exit(options(oopts), add = TRUE)
[18:01:56.811]         }
[18:01:56.811]         {
[18:01:56.811]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.811]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.811]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.811]             })
[18:01:56.811]         }
[18:01:56.811]     }, args = future.call.arguments)
[18:01:56.811] }
[18:01:56.811] Lazy evaluation: FALSE
[18:01:56.811] Asynchronous evaluation: FALSE
[18:01:56.811] Local evaluation: TRUE
[18:01:56.811] Environment: R_GlobalEnv
[18:01:56.811] Capture standard output: TRUE
[18:01:56.811] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:56.811] Globals: 11 objects totaling 95.26 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:56.811] Packages: 1 packages (‘future.apply’)
[18:01:56.811] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:56.811] Resolved: TRUE
[18:01:56.811] Value: 616 bytes of class ‘list’
[18:01:56.811] Early signaling: FALSE
[18:01:56.811] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:56.811] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.813] Chunk #1 of 1 ... DONE
[18:01:56.814] Launching 1 futures (chunks) ... DONE
[18:01:56.814] Resolving 1 futures (chunks) ...
[18:01:56.814] resolve() on list ...
[18:01:56.814]  recursive: 0
[18:01:56.817]  length: 1
[18:01:56.817] 
[18:01:56.817] resolved() for ‘SequentialFuture’ ...
[18:01:56.818] - state: ‘finished’
[18:01:56.818] - run: TRUE
[18:01:56.818] - result: ‘FutureResult’
[18:01:56.818] resolved() for ‘SequentialFuture’ ... done
[18:01:56.818] Future #1
[18:01:56.819] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:56.819] - nx: 1
[18:01:56.819] - relay: TRUE
[18:01:56.819] - stdout: TRUE
[18:01:56.820] - signal: TRUE
[18:01:56.820] - resignal: FALSE
[18:01:56.820] - force: TRUE
[18:01:56.820] - relayed: [n=1] FALSE
[18:01:56.820] - queued futures: [n=1] FALSE
[18:01:56.821]  - until=1
[18:01:56.821]  - relaying element #1
[18:01:56.821] - relayed: [n=1] TRUE
[18:01:56.822] - queued futures: [n=1] TRUE
[18:01:56.822] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:56.822]  length: 0 (resolved future 1)
[18:01:56.822] Relaying remaining futures
[18:01:56.822] signalConditionsASAP(NULL, pos=0) ...
[18:01:56.823] - nx: 1
[18:01:56.823] - relay: TRUE
[18:01:56.823] - stdout: TRUE
[18:01:56.823] - signal: TRUE
[18:01:56.823] - resignal: FALSE
[18:01:56.823] - force: TRUE
[18:01:56.824] - relayed: [n=1] TRUE
[18:01:56.824] - queued futures: [n=1] TRUE
 - flush all
[18:01:56.824] - relayed: [n=1] TRUE
[18:01:56.824] - queued futures: [n=1] TRUE
[18:01:56.824] signalConditionsASAP(NULL, pos=0) ... done
[18:01:56.825] resolve() on list ... DONE
[18:01:56.825]  - Number of value chunks collected: 1
[18:01:56.825] Resolving 1 futures (chunks) ... DONE
[18:01:56.825] Reducing values from 1 chunks ...
[18:01:56.826]  - Number of values collected after concatenation: 11
[18:01:56.826]  - Number of values expected: 11
[18:01:56.826] Reducing values from 1 chunks ... DONE
[18:01:56.826] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[18:01:56.828] future_lapply() ...
[18:01:56.832] Number of chunks: 1
[18:01:56.832] getGlobalsAndPackagesXApply() ...
[18:01:56.832]  - future.globals: TRUE
[18:01:56.832] getGlobalsAndPackages() ...
[18:01:56.833] Searching for globals...
[18:01:56.839] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:01:56.840] Searching for globals ... DONE
[18:01:56.840] Resolving globals: FALSE
[18:01:56.842] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[18:01:56.843] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:56.843] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:56.844] - packages: [1] ‘future.apply’
[18:01:56.844] getGlobalsAndPackages() ... DONE
[18:01:56.844]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:56.844]  - needed namespaces: [n=1] ‘future.apply’
[18:01:56.844] Finding globals ... DONE
[18:01:56.845]  - use_args: TRUE
[18:01:56.845]  - Getting '...' globals ...
[18:01:56.846] resolve() on list ...
[18:01:56.846]  recursive: 0
[18:01:56.846]  length: 1
[18:01:56.846]  elements: ‘...’
[18:01:56.846]  length: 0 (resolved future 1)
[18:01:56.847] resolve() on list ... DONE
[18:01:56.847]    - '...' content: [n=0] 
[18:01:56.847] List of 1
[18:01:56.847]  $ ...: list()
[18:01:56.847]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.847]  - attr(*, "where")=List of 1
[18:01:56.847]   ..$ ...:<environment: 0x6183be6a8f08> 
[18:01:56.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.847]  - attr(*, "resolved")= logi TRUE
[18:01:56.847]  - attr(*, "total_size")= num NA
[18:01:56.852]  - Getting '...' globals ... DONE
[18:01:56.852] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:56.853] List of 8
[18:01:56.853]  $ ...future.FUN:function (x, ...)  
[18:01:56.853]  $ x_FUN        :function (x)  
[18:01:56.853]  $ times        : int 1
[18:01:56.853]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.853]  $ stop_if_not  :function (...)  
[18:01:56.853]  $ dim          : NULL
[18:01:56.853]  $ valid_types  : chr [1:2] "logical" "integer"
[18:01:56.853]  $ ...          : list()
[18:01:56.853]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.853]  - attr(*, "where")=List of 8
[18:01:56.853]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:56.853]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:56.853]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:56.853]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:56.853]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:56.853]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:56.853]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:56.853]   ..$ ...          :<environment: 0x6183be6a8f08> 
[18:01:56.853]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.853]  - attr(*, "resolved")= logi FALSE
[18:01:56.853]  - attr(*, "total_size")= num 94264
[18:01:56.866] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:56.866] getGlobalsAndPackagesXApply() ... DONE
[18:01:56.867] Number of futures (= number of chunks): 1
[18:01:56.867] Launching 1 futures (chunks) ...
[18:01:56.867] Chunk #1 of 1 ...
[18:01:56.867]  - Finding globals in 'X' for chunk #1 ...
[18:01:56.868] getGlobalsAndPackages() ...
[18:01:56.868] Searching for globals...
[18:01:56.868] 
[18:01:56.868] Searching for globals ... DONE
[18:01:56.869] - globals: [0] <none>
[18:01:56.869] getGlobalsAndPackages() ... DONE
[18:01:56.869]    + additional globals found: [n=0] 
[18:01:56.869]    + additional namespaces needed: [n=0] 
[18:01:56.869]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:56.870]  - seeds: <none>
[18:01:56.870]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.870] getGlobalsAndPackages() ...
[18:01:56.870] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.870] Resolving globals: FALSE
[18:01:56.871] Tweak future expression to call with '...' arguments ...
[18:01:56.871] {
[18:01:56.871]     do.call(function(...) {
[18:01:56.871]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.871]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.871]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.871]             on.exit(options(oopts), add = TRUE)
[18:01:56.871]         }
[18:01:56.871]         {
[18:01:56.871]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.871]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.871]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.871]             })
[18:01:56.871]         }
[18:01:56.871]     }, args = future.call.arguments)
[18:01:56.871] }
[18:01:56.871] Tweak future expression to call with '...' arguments ... DONE
[18:01:56.872] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.873] - packages: [1] ‘future.apply’
[18:01:56.873] getGlobalsAndPackages() ... DONE
[18:01:56.874] run() for ‘Future’ ...
[18:01:56.874] - state: ‘created’
[18:01:56.874] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:56.875] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.875] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:56.875]   - Field: ‘label’
[18:01:56.875]   - Field: ‘local’
[18:01:56.875]   - Field: ‘owner’
[18:01:56.876]   - Field: ‘envir’
[18:01:56.876]   - Field: ‘packages’
[18:01:56.876]   - Field: ‘gc’
[18:01:56.876]   - Field: ‘conditions’
[18:01:56.876]   - Field: ‘expr’
[18:01:56.877]   - Field: ‘uuid’
[18:01:56.877]   - Field: ‘seed’
[18:01:56.877]   - Field: ‘version’
[18:01:56.877]   - Field: ‘result’
[18:01:56.877]   - Field: ‘asynchronous’
[18:01:56.878]   - Field: ‘calls’
[18:01:56.878]   - Field: ‘globals’
[18:01:56.878]   - Field: ‘stdout’
[18:01:56.878]   - Field: ‘earlySignal’
[18:01:56.878]   - Field: ‘lazy’
[18:01:56.878]   - Field: ‘state’
[18:01:56.879] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:56.879] - Launch lazy future ...
[18:01:56.879] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:56.880] Packages needed by future strategies (n = 0): <none>
[18:01:56.881] {
[18:01:56.881]     {
[18:01:56.881]         {
[18:01:56.881]             ...future.startTime <- base::Sys.time()
[18:01:56.881]             {
[18:01:56.881]                 {
[18:01:56.881]                   {
[18:01:56.881]                     {
[18:01:56.881]                       base::local({
[18:01:56.881]                         has_future <- base::requireNamespace("future", 
[18:01:56.881]                           quietly = TRUE)
[18:01:56.881]                         if (has_future) {
[18:01:56.881]                           ns <- base::getNamespace("future")
[18:01:56.881]                           version <- ns[[".package"]][["version"]]
[18:01:56.881]                           if (is.null(version)) 
[18:01:56.881]                             version <- utils::packageVersion("future")
[18:01:56.881]                         }
[18:01:56.881]                         else {
[18:01:56.881]                           version <- NULL
[18:01:56.881]                         }
[18:01:56.881]                         if (!has_future || version < "1.8.0") {
[18:01:56.881]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:56.881]                             "", base::R.version$version.string), 
[18:01:56.881]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:56.881]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:56.881]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:56.881]                               "release", "version")], collapse = " "), 
[18:01:56.881]                             hostname = base::Sys.info()[["nodename"]])
[18:01:56.881]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:56.881]                             info)
[18:01:56.881]                           info <- base::paste(info, collapse = "; ")
[18:01:56.881]                           if (!has_future) {
[18:01:56.881]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:56.881]                               info)
[18:01:56.881]                           }
[18:01:56.881]                           else {
[18:01:56.881]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:56.881]                               info, version)
[18:01:56.881]                           }
[18:01:56.881]                           base::stop(msg)
[18:01:56.881]                         }
[18:01:56.881]                       })
[18:01:56.881]                     }
[18:01:56.881]                     base::local({
[18:01:56.881]                       for (pkg in "future.apply") {
[18:01:56.881]                         base::loadNamespace(pkg)
[18:01:56.881]                         base::library(pkg, character.only = TRUE)
[18:01:56.881]                       }
[18:01:56.881]                     })
[18:01:56.881]                   }
[18:01:56.881]                   ...future.strategy.old <- future::plan("list")
[18:01:56.881]                   options(future.plan = NULL)
[18:01:56.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.881]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:56.881]                 }
[18:01:56.881]                 ...future.workdir <- getwd()
[18:01:56.881]             }
[18:01:56.881]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:56.881]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:56.881]         }
[18:01:56.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:56.881]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:56.881]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:56.881]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:56.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:56.881]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:56.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:56.881]             base::names(...future.oldOptions))
[18:01:56.881]     }
[18:01:56.881]     if (FALSE) {
[18:01:56.881]     }
[18:01:56.881]     else {
[18:01:56.881]         if (TRUE) {
[18:01:56.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:56.881]                 open = "w")
[18:01:56.881]         }
[18:01:56.881]         else {
[18:01:56.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:56.881]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:56.881]         }
[18:01:56.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:56.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:56.881]             base::sink(type = "output", split = FALSE)
[18:01:56.881]             base::close(...future.stdout)
[18:01:56.881]         }, add = TRUE)
[18:01:56.881]     }
[18:01:56.881]     ...future.frame <- base::sys.nframe()
[18:01:56.881]     ...future.conditions <- base::list()
[18:01:56.881]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:56.881]     if (FALSE) {
[18:01:56.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:56.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:56.881]     }
[18:01:56.881]     ...future.result <- base::tryCatch({
[18:01:56.881]         base::withCallingHandlers({
[18:01:56.881]             ...future.value <- base::withVisible(base::local({
[18:01:56.881]                 do.call(function(...) {
[18:01:56.881]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.881]                   if (!identical(...future.globals.maxSize.org, 
[18:01:56.881]                     ...future.globals.maxSize)) {
[18:01:56.881]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.881]                     on.exit(options(oopts), add = TRUE)
[18:01:56.881]                   }
[18:01:56.881]                   {
[18:01:56.881]                     lapply(seq_along(...future.elements_ii), 
[18:01:56.881]                       FUN = function(jj) {
[18:01:56.881]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.881]                         ...future.FUN(...future.X_jj, ...)
[18:01:56.881]                       })
[18:01:56.881]                   }
[18:01:56.881]                 }, args = future.call.arguments)
[18:01:56.881]             }))
[18:01:56.881]             future::FutureResult(value = ...future.value$value, 
[18:01:56.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.881]                   ...future.rng), globalenv = if (FALSE) 
[18:01:56.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:56.881]                     ...future.globalenv.names))
[18:01:56.881]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:56.881]         }, condition = base::local({
[18:01:56.881]             c <- base::c
[18:01:56.881]             inherits <- base::inherits
[18:01:56.881]             invokeRestart <- base::invokeRestart
[18:01:56.881]             length <- base::length
[18:01:56.881]             list <- base::list
[18:01:56.881]             seq.int <- base::seq.int
[18:01:56.881]             signalCondition <- base::signalCondition
[18:01:56.881]             sys.calls <- base::sys.calls
[18:01:56.881]             `[[` <- base::`[[`
[18:01:56.881]             `+` <- base::`+`
[18:01:56.881]             `<<-` <- base::`<<-`
[18:01:56.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:56.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:56.881]                   3L)]
[18:01:56.881]             }
[18:01:56.881]             function(cond) {
[18:01:56.881]                 is_error <- inherits(cond, "error")
[18:01:56.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:56.881]                   NULL)
[18:01:56.881]                 if (is_error) {
[18:01:56.881]                   sessionInformation <- function() {
[18:01:56.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:56.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:56.881]                       search = base::search(), system = base::Sys.info())
[18:01:56.881]                   }
[18:01:56.881]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:56.881]                     cond$call), session = sessionInformation(), 
[18:01:56.881]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:56.881]                   signalCondition(cond)
[18:01:56.881]                 }
[18:01:56.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:56.881]                 "immediateCondition"))) {
[18:01:56.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:56.881]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:56.881]                   if (TRUE && !signal) {
[18:01:56.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.881]                     {
[18:01:56.881]                       inherits <- base::inherits
[18:01:56.881]                       invokeRestart <- base::invokeRestart
[18:01:56.881]                       is.null <- base::is.null
[18:01:56.881]                       muffled <- FALSE
[18:01:56.881]                       if (inherits(cond, "message")) {
[18:01:56.881]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.881]                         if (muffled) 
[18:01:56.881]                           invokeRestart("muffleMessage")
[18:01:56.881]                       }
[18:01:56.881]                       else if (inherits(cond, "warning")) {
[18:01:56.881]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.881]                         if (muffled) 
[18:01:56.881]                           invokeRestart("muffleWarning")
[18:01:56.881]                       }
[18:01:56.881]                       else if (inherits(cond, "condition")) {
[18:01:56.881]                         if (!is.null(pattern)) {
[18:01:56.881]                           computeRestarts <- base::computeRestarts
[18:01:56.881]                           grepl <- base::grepl
[18:01:56.881]                           restarts <- computeRestarts(cond)
[18:01:56.881]                           for (restart in restarts) {
[18:01:56.881]                             name <- restart$name
[18:01:56.881]                             if (is.null(name)) 
[18:01:56.881]                               next
[18:01:56.881]                             if (!grepl(pattern, name)) 
[18:01:56.881]                               next
[18:01:56.881]                             invokeRestart(restart)
[18:01:56.881]                             muffled <- TRUE
[18:01:56.881]                             break
[18:01:56.881]                           }
[18:01:56.881]                         }
[18:01:56.881]                       }
[18:01:56.881]                       invisible(muffled)
[18:01:56.881]                     }
[18:01:56.881]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.881]                   }
[18:01:56.881]                 }
[18:01:56.881]                 else {
[18:01:56.881]                   if (TRUE) {
[18:01:56.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.881]                     {
[18:01:56.881]                       inherits <- base::inherits
[18:01:56.881]                       invokeRestart <- base::invokeRestart
[18:01:56.881]                       is.null <- base::is.null
[18:01:56.881]                       muffled <- FALSE
[18:01:56.881]                       if (inherits(cond, "message")) {
[18:01:56.881]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.881]                         if (muffled) 
[18:01:56.881]                           invokeRestart("muffleMessage")
[18:01:56.881]                       }
[18:01:56.881]                       else if (inherits(cond, "warning")) {
[18:01:56.881]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.881]                         if (muffled) 
[18:01:56.881]                           invokeRestart("muffleWarning")
[18:01:56.881]                       }
[18:01:56.881]                       else if (inherits(cond, "condition")) {
[18:01:56.881]                         if (!is.null(pattern)) {
[18:01:56.881]                           computeRestarts <- base::computeRestarts
[18:01:56.881]                           grepl <- base::grepl
[18:01:56.881]                           restarts <- computeRestarts(cond)
[18:01:56.881]                           for (restart in restarts) {
[18:01:56.881]                             name <- restart$name
[18:01:56.881]                             if (is.null(name)) 
[18:01:56.881]                               next
[18:01:56.881]                             if (!grepl(pattern, name)) 
[18:01:56.881]                               next
[18:01:56.881]                             invokeRestart(restart)
[18:01:56.881]                             muffled <- TRUE
[18:01:56.881]                             break
[18:01:56.881]                           }
[18:01:56.881]                         }
[18:01:56.881]                       }
[18:01:56.881]                       invisible(muffled)
[18:01:56.881]                     }
[18:01:56.881]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.881]                   }
[18:01:56.881]                 }
[18:01:56.881]             }
[18:01:56.881]         }))
[18:01:56.881]     }, error = function(ex) {
[18:01:56.881]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:56.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.881]                 ...future.rng), started = ...future.startTime, 
[18:01:56.881]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:56.881]             version = "1.8"), class = "FutureResult")
[18:01:56.881]     }, finally = {
[18:01:56.881]         if (!identical(...future.workdir, getwd())) 
[18:01:56.881]             setwd(...future.workdir)
[18:01:56.881]         {
[18:01:56.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:56.881]                 ...future.oldOptions$nwarnings <- NULL
[18:01:56.881]             }
[18:01:56.881]             base::options(...future.oldOptions)
[18:01:56.881]             if (.Platform$OS.type == "windows") {
[18:01:56.881]                 old_names <- names(...future.oldEnvVars)
[18:01:56.881]                 envs <- base::Sys.getenv()
[18:01:56.881]                 names <- names(envs)
[18:01:56.881]                 common <- intersect(names, old_names)
[18:01:56.881]                 added <- setdiff(names, old_names)
[18:01:56.881]                 removed <- setdiff(old_names, names)
[18:01:56.881]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:56.881]                   envs[common]]
[18:01:56.881]                 NAMES <- toupper(changed)
[18:01:56.881]                 args <- list()
[18:01:56.881]                 for (kk in seq_along(NAMES)) {
[18:01:56.881]                   name <- changed[[kk]]
[18:01:56.881]                   NAME <- NAMES[[kk]]
[18:01:56.881]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.881]                     next
[18:01:56.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.881]                 }
[18:01:56.881]                 NAMES <- toupper(added)
[18:01:56.881]                 for (kk in seq_along(NAMES)) {
[18:01:56.881]                   name <- added[[kk]]
[18:01:56.881]                   NAME <- NAMES[[kk]]
[18:01:56.881]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.881]                     next
[18:01:56.881]                   args[[name]] <- ""
[18:01:56.881]                 }
[18:01:56.881]                 NAMES <- toupper(removed)
[18:01:56.881]                 for (kk in seq_along(NAMES)) {
[18:01:56.881]                   name <- removed[[kk]]
[18:01:56.881]                   NAME <- NAMES[[kk]]
[18:01:56.881]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.881]                     next
[18:01:56.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.881]                 }
[18:01:56.881]                 if (length(args) > 0) 
[18:01:56.881]                   base::do.call(base::Sys.setenv, args = args)
[18:01:56.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:56.881]             }
[18:01:56.881]             else {
[18:01:56.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:56.881]             }
[18:01:56.881]             {
[18:01:56.881]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:56.881]                   0L) {
[18:01:56.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:56.881]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:56.881]                   base::options(opts)
[18:01:56.881]                 }
[18:01:56.881]                 {
[18:01:56.881]                   {
[18:01:56.881]                     NULL
[18:01:56.881]                     RNGkind("Mersenne-Twister")
[18:01:56.881]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:56.881]                       inherits = FALSE)
[18:01:56.881]                   }
[18:01:56.881]                   options(future.plan = NULL)
[18:01:56.881]                   if (is.na(NA_character_)) 
[18:01:56.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:56.881]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:56.881]                     .init = FALSE)
[18:01:56.881]                 }
[18:01:56.881]             }
[18:01:56.881]         }
[18:01:56.881]     })
[18:01:56.881]     if (TRUE) {
[18:01:56.881]         base::sink(type = "output", split = FALSE)
[18:01:56.881]         if (TRUE) {
[18:01:56.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:56.881]         }
[18:01:56.881]         else {
[18:01:56.881]             ...future.result["stdout"] <- base::list(NULL)
[18:01:56.881]         }
[18:01:56.881]         base::close(...future.stdout)
[18:01:56.881]         ...future.stdout <- NULL
[18:01:56.881]     }
[18:01:56.881]     ...future.result$conditions <- ...future.conditions
[18:01:56.881]     ...future.result$finished <- base::Sys.time()
[18:01:56.881]     ...future.result
[18:01:56.881] }
[18:01:56.884] assign_globals() ...
[18:01:56.884] List of 11
[18:01:56.884]  $ ...future.FUN            :function (x, ...)  
[18:01:56.884]  $ x_FUN                    :function (x)  
[18:01:56.884]  $ times                    : int 1
[18:01:56.884]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.884]  $ stop_if_not              :function (...)  
[18:01:56.884]  $ dim                      : NULL
[18:01:56.884]  $ valid_types              : chr [1:2] "logical" "integer"
[18:01:56.884]  $ future.call.arguments    : list()
[18:01:56.884]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.884]  $ ...future.elements_ii    :List of 3
[18:01:56.884]   ..$ a: num 1
[18:01:56.884]   ..$ b: num 2
[18:01:56.884]   ..$ c: num 3
[18:01:56.884]  $ ...future.seeds_ii       : NULL
[18:01:56.884]  $ ...future.globals.maxSize: NULL
[18:01:56.884]  - attr(*, "where")=List of 11
[18:01:56.884]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:56.884]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:56.884]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:56.884]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:56.884]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:56.884]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:56.884]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:56.884]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:56.884]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:56.884]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:56.884]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:56.884]  - attr(*, "resolved")= logi FALSE
[18:01:56.884]  - attr(*, "total_size")= num 94264
[18:01:56.884]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.884]  - attr(*, "already-done")= logi TRUE
[18:01:56.900] - copied ‘...future.FUN’ to environment
[18:01:56.900] - copied ‘x_FUN’ to environment
[18:01:56.900] - copied ‘times’ to environment
[18:01:56.901] - copied ‘stopf’ to environment
[18:01:56.901] - copied ‘stop_if_not’ to environment
[18:01:56.901] - copied ‘dim’ to environment
[18:01:56.901] - copied ‘valid_types’ to environment
[18:01:56.901] - copied ‘future.call.arguments’ to environment
[18:01:56.902] - copied ‘...future.elements_ii’ to environment
[18:01:56.902] - copied ‘...future.seeds_ii’ to environment
[18:01:56.902] - copied ‘...future.globals.maxSize’ to environment
[18:01:56.902] assign_globals() ... done
[18:01:56.903] plan(): Setting new future strategy stack:
[18:01:56.903] List of future strategies:
[18:01:56.903] 1. sequential:
[18:01:56.903]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.903]    - tweaked: FALSE
[18:01:56.903]    - call: NULL
[18:01:56.904] plan(): nbrOfWorkers() = 1
[18:01:56.906] plan(): Setting new future strategy stack:
[18:01:56.906] List of future strategies:
[18:01:56.906] 1. sequential:
[18:01:56.906]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.906]    - tweaked: FALSE
[18:01:56.906]    - call: plan(strategy)
[18:01:56.907] plan(): nbrOfWorkers() = 1
[18:01:56.907] SequentialFuture started (and completed)
[18:01:56.907] - Launch lazy future ... done
[18:01:56.907] run() for ‘SequentialFuture’ ... done
[18:01:56.908] Created future:
[18:01:56.908] SequentialFuture:
[18:01:56.908] Label: ‘future_vapply-1’
[18:01:56.908] Expression:
[18:01:56.908] {
[18:01:56.908]     do.call(function(...) {
[18:01:56.908]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.908]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.908]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.908]             on.exit(options(oopts), add = TRUE)
[18:01:56.908]         }
[18:01:56.908]         {
[18:01:56.908]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.908]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.908]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.908]             })
[18:01:56.908]         }
[18:01:56.908]     }, args = future.call.arguments)
[18:01:56.908] }
[18:01:56.908] Lazy evaluation: FALSE
[18:01:56.908] Asynchronous evaluation: FALSE
[18:01:56.908] Local evaluation: TRUE
[18:01:56.908] Environment: R_GlobalEnv
[18:01:56.908] Capture standard output: TRUE
[18:01:56.908] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:56.908] Globals: 11 objects totaling 92.22 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:56.908] Packages: 1 packages (‘future.apply’)
[18:01:56.908] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:56.908] Resolved: TRUE
[18:01:56.908] Value: 168 bytes of class ‘list’
[18:01:56.908] Early signaling: FALSE
[18:01:56.908] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:56.908] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.910] Chunk #1 of 1 ... DONE
[18:01:56.910] Launching 1 futures (chunks) ... DONE
[18:01:56.911] Resolving 1 futures (chunks) ...
[18:01:56.911] resolve() on list ...
[18:01:56.911]  recursive: 0
[18:01:56.911]  length: 1
[18:01:56.911] 
[18:01:56.912] resolved() for ‘SequentialFuture’ ...
[18:01:56.914] - state: ‘finished’
[18:01:56.915] - run: TRUE
[18:01:56.915] - result: ‘FutureResult’
[18:01:56.915] resolved() for ‘SequentialFuture’ ... done
[18:01:56.915] Future #1
[18:01:56.916] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:56.916] - nx: 1
[18:01:56.916] - relay: TRUE
[18:01:56.916] - stdout: TRUE
[18:01:56.916] - signal: TRUE
[18:01:56.917] - resignal: FALSE
[18:01:56.917] - force: TRUE
[18:01:56.917] - relayed: [n=1] FALSE
[18:01:56.917] - queued futures: [n=1] FALSE
[18:01:56.917]  - until=1
[18:01:56.918]  - relaying element #1
[18:01:56.918] - relayed: [n=1] TRUE
[18:01:56.918] - queued futures: [n=1] TRUE
[18:01:56.918] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:56.919]  length: 0 (resolved future 1)
[18:01:56.919] Relaying remaining futures
[18:01:56.919] signalConditionsASAP(NULL, pos=0) ...
[18:01:56.919] - nx: 1
[18:01:56.919] - relay: TRUE
[18:01:56.919] - stdout: TRUE
[18:01:56.920] - signal: TRUE
[18:01:56.920] - resignal: FALSE
[18:01:56.920] - force: TRUE
[18:01:56.920] - relayed: [n=1] TRUE
[18:01:56.920] - queued futures: [n=1] TRUE
 - flush all
[18:01:56.921] - relayed: [n=1] TRUE
[18:01:56.921] - queued futures: [n=1] TRUE
[18:01:56.921] signalConditionsASAP(NULL, pos=0) ... done
[18:01:56.921] resolve() on list ... DONE
[18:01:56.921]  - Number of value chunks collected: 1
[18:01:56.922] Resolving 1 futures (chunks) ... DONE
[18:01:56.922] Reducing values from 1 chunks ...
[18:01:56.922]  - Number of values collected after concatenation: 3
[18:01:56.922]  - Number of values expected: 3
[18:01:56.922] Reducing values from 1 chunks ... DONE
[18:01:56.923] future_lapply() ... DONE
- exceptions ...
[18:01:56.923] future_lapply() ...
[18:01:56.927] Number of chunks: 1
[18:01:56.927] getGlobalsAndPackagesXApply() ...
[18:01:56.927]  - future.globals: TRUE
[18:01:56.927] getGlobalsAndPackages() ...
[18:01:56.927] Searching for globals...
[18:01:56.934] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:01:56.935] Searching for globals ... DONE
[18:01:56.935] Resolving globals: FALSE
[18:01:56.937] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[18:01:56.937] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:56.938] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:56.938] - packages: [1] ‘future.apply’
[18:01:56.938] getGlobalsAndPackages() ... DONE
[18:01:56.938]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:56.939]  - needed namespaces: [n=1] ‘future.apply’
[18:01:56.939] Finding globals ... DONE
[18:01:56.939]  - use_args: TRUE
[18:01:56.939]  - Getting '...' globals ...
[18:01:56.940] resolve() on list ...
[18:01:56.940]  recursive: 0
[18:01:56.940]  length: 1
[18:01:56.940]  elements: ‘...’
[18:01:56.941]  length: 0 (resolved future 1)
[18:01:56.941] resolve() on list ... DONE
[18:01:56.941]    - '...' content: [n=0] 
[18:01:56.941] List of 1
[18:01:56.941]  $ ...: list()
[18:01:56.941]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.941]  - attr(*, "where")=List of 1
[18:01:56.941]   ..$ ...:<environment: 0x6183be80c8c8> 
[18:01:56.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.941]  - attr(*, "resolved")= logi TRUE
[18:01:56.941]  - attr(*, "total_size")= num NA
[18:01:56.946]  - Getting '...' globals ... DONE
[18:01:56.947] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:56.947] List of 8
[18:01:56.947]  $ ...future.FUN:function (x, ...)  
[18:01:56.947]  $ x_FUN        :function (x)  
[18:01:56.947]  $ times        : int 2
[18:01:56.947]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.947]  $ stop_if_not  :function (...)  
[18:01:56.947]  $ dim          : NULL
[18:01:56.947]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:56.947]  $ ...          : list()
[18:01:56.947]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.947]  - attr(*, "where")=List of 8
[18:01:56.947]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:56.947]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:56.947]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:56.947]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:56.947]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:56.947]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:56.947]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:56.947]   ..$ ...          :<environment: 0x6183be80c8c8> 
[18:01:56.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.947]  - attr(*, "resolved")= logi FALSE
[18:01:56.947]  - attr(*, "total_size")= num 95128
[18:01:56.960] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:56.960] getGlobalsAndPackagesXApply() ... DONE
[18:01:56.961] Number of futures (= number of chunks): 1
[18:01:56.961] Launching 1 futures (chunks) ...
[18:01:56.961] Chunk #1 of 1 ...
[18:01:56.961]  - Finding globals in 'X' for chunk #1 ...
[18:01:56.962] getGlobalsAndPackages() ...
[18:01:56.962] Searching for globals...
[18:01:56.962] 
[18:01:56.963] Searching for globals ... DONE
[18:01:56.963] - globals: [0] <none>
[18:01:56.963] getGlobalsAndPackages() ... DONE
[18:01:56.963]    + additional globals found: [n=0] 
[18:01:56.963]    + additional namespaces needed: [n=0] 
[18:01:56.964]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:56.964]  - seeds: <none>
[18:01:56.964]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.964] getGlobalsAndPackages() ...
[18:01:56.964] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.965] Resolving globals: FALSE
[18:01:56.965] Tweak future expression to call with '...' arguments ...
[18:01:56.965] {
[18:01:56.965]     do.call(function(...) {
[18:01:56.965]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.965]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:56.965]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.965]             on.exit(options(oopts), add = TRUE)
[18:01:56.965]         }
[18:01:56.965]         {
[18:01:56.965]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:56.965]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.965]                 ...future.FUN(...future.X_jj, ...)
[18:01:56.965]             })
[18:01:56.965]         }
[18:01:56.965]     }, args = future.call.arguments)
[18:01:56.965] }
[18:01:56.966] Tweak future expression to call with '...' arguments ... DONE
[18:01:56.967] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:56.967] - packages: [1] ‘future.apply’
[18:01:56.967] getGlobalsAndPackages() ... DONE
[18:01:56.968] run() for ‘Future’ ...
[18:01:56.968] - state: ‘created’
[18:01:56.968] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:01:56.969] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:56.969] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:01:56.969]   - Field: ‘label’
[18:01:56.969]   - Field: ‘local’
[18:01:56.970]   - Field: ‘owner’
[18:01:56.970]   - Field: ‘envir’
[18:01:56.970]   - Field: ‘packages’
[18:01:56.970]   - Field: ‘gc’
[18:01:56.970]   - Field: ‘conditions’
[18:01:56.971]   - Field: ‘expr’
[18:01:56.971]   - Field: ‘uuid’
[18:01:56.971]   - Field: ‘seed’
[18:01:56.971]   - Field: ‘version’
[18:01:56.971]   - Field: ‘result’
[18:01:56.972]   - Field: ‘asynchronous’
[18:01:56.972]   - Field: ‘calls’
[18:01:56.972]   - Field: ‘globals’
[18:01:56.972]   - Field: ‘stdout’
[18:01:56.972]   - Field: ‘earlySignal’
[18:01:56.972]   - Field: ‘lazy’
[18:01:56.973]   - Field: ‘state’
[18:01:56.973] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:01:56.973] - Launch lazy future ...
[18:01:56.973] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:56.974] Packages needed by future strategies (n = 0): <none>
[18:01:56.975] {
[18:01:56.975]     {
[18:01:56.975]         {
[18:01:56.975]             ...future.startTime <- base::Sys.time()
[18:01:56.975]             {
[18:01:56.975]                 {
[18:01:56.975]                   {
[18:01:56.975]                     {
[18:01:56.975]                       base::local({
[18:01:56.975]                         has_future <- base::requireNamespace("future", 
[18:01:56.975]                           quietly = TRUE)
[18:01:56.975]                         if (has_future) {
[18:01:56.975]                           ns <- base::getNamespace("future")
[18:01:56.975]                           version <- ns[[".package"]][["version"]]
[18:01:56.975]                           if (is.null(version)) 
[18:01:56.975]                             version <- utils::packageVersion("future")
[18:01:56.975]                         }
[18:01:56.975]                         else {
[18:01:56.975]                           version <- NULL
[18:01:56.975]                         }
[18:01:56.975]                         if (!has_future || version < "1.8.0") {
[18:01:56.975]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:56.975]                             "", base::R.version$version.string), 
[18:01:56.975]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:56.975]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:56.975]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:56.975]                               "release", "version")], collapse = " "), 
[18:01:56.975]                             hostname = base::Sys.info()[["nodename"]])
[18:01:56.975]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:56.975]                             info)
[18:01:56.975]                           info <- base::paste(info, collapse = "; ")
[18:01:56.975]                           if (!has_future) {
[18:01:56.975]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:56.975]                               info)
[18:01:56.975]                           }
[18:01:56.975]                           else {
[18:01:56.975]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:56.975]                               info, version)
[18:01:56.975]                           }
[18:01:56.975]                           base::stop(msg)
[18:01:56.975]                         }
[18:01:56.975]                       })
[18:01:56.975]                     }
[18:01:56.975]                     base::local({
[18:01:56.975]                       for (pkg in "future.apply") {
[18:01:56.975]                         base::loadNamespace(pkg)
[18:01:56.975]                         base::library(pkg, character.only = TRUE)
[18:01:56.975]                       }
[18:01:56.975]                     })
[18:01:56.975]                   }
[18:01:56.975]                   ...future.strategy.old <- future::plan("list")
[18:01:56.975]                   options(future.plan = NULL)
[18:01:56.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:56.975]                 }
[18:01:56.975]                 ...future.workdir <- getwd()
[18:01:56.975]             }
[18:01:56.975]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:56.975]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:56.975]         }
[18:01:56.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:56.975]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:01:56.975]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:56.975]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:56.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:56.975]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:56.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:56.975]             base::names(...future.oldOptions))
[18:01:56.975]     }
[18:01:56.975]     if (FALSE) {
[18:01:56.975]     }
[18:01:56.975]     else {
[18:01:56.975]         if (TRUE) {
[18:01:56.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:56.975]                 open = "w")
[18:01:56.975]         }
[18:01:56.975]         else {
[18:01:56.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:56.975]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:56.975]         }
[18:01:56.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:56.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:56.975]             base::sink(type = "output", split = FALSE)
[18:01:56.975]             base::close(...future.stdout)
[18:01:56.975]         }, add = TRUE)
[18:01:56.975]     }
[18:01:56.975]     ...future.frame <- base::sys.nframe()
[18:01:56.975]     ...future.conditions <- base::list()
[18:01:56.975]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:56.975]     if (FALSE) {
[18:01:56.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:56.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:56.975]     }
[18:01:56.975]     ...future.result <- base::tryCatch({
[18:01:56.975]         base::withCallingHandlers({
[18:01:56.975]             ...future.value <- base::withVisible(base::local({
[18:01:56.975]                 do.call(function(...) {
[18:01:56.975]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:56.975]                   if (!identical(...future.globals.maxSize.org, 
[18:01:56.975]                     ...future.globals.maxSize)) {
[18:01:56.975]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:56.975]                     on.exit(options(oopts), add = TRUE)
[18:01:56.975]                   }
[18:01:56.975]                   {
[18:01:56.975]                     lapply(seq_along(...future.elements_ii), 
[18:01:56.975]                       FUN = function(jj) {
[18:01:56.975]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:56.975]                         ...future.FUN(...future.X_jj, ...)
[18:01:56.975]                       })
[18:01:56.975]                   }
[18:01:56.975]                 }, args = future.call.arguments)
[18:01:56.975]             }))
[18:01:56.975]             future::FutureResult(value = ...future.value$value, 
[18:01:56.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.975]                   ...future.rng), globalenv = if (FALSE) 
[18:01:56.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:56.975]                     ...future.globalenv.names))
[18:01:56.975]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:56.975]         }, condition = base::local({
[18:01:56.975]             c <- base::c
[18:01:56.975]             inherits <- base::inherits
[18:01:56.975]             invokeRestart <- base::invokeRestart
[18:01:56.975]             length <- base::length
[18:01:56.975]             list <- base::list
[18:01:56.975]             seq.int <- base::seq.int
[18:01:56.975]             signalCondition <- base::signalCondition
[18:01:56.975]             sys.calls <- base::sys.calls
[18:01:56.975]             `[[` <- base::`[[`
[18:01:56.975]             `+` <- base::`+`
[18:01:56.975]             `<<-` <- base::`<<-`
[18:01:56.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:56.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:56.975]                   3L)]
[18:01:56.975]             }
[18:01:56.975]             function(cond) {
[18:01:56.975]                 is_error <- inherits(cond, "error")
[18:01:56.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:56.975]                   NULL)
[18:01:56.975]                 if (is_error) {
[18:01:56.975]                   sessionInformation <- function() {
[18:01:56.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:56.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:56.975]                       search = base::search(), system = base::Sys.info())
[18:01:56.975]                   }
[18:01:56.975]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:56.975]                     cond$call), session = sessionInformation(), 
[18:01:56.975]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:56.975]                   signalCondition(cond)
[18:01:56.975]                 }
[18:01:56.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:56.975]                 "immediateCondition"))) {
[18:01:56.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:56.975]                   ...future.conditions[[length(...future.conditions) + 
[18:01:56.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:56.975]                   if (TRUE && !signal) {
[18:01:56.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.975]                     {
[18:01:56.975]                       inherits <- base::inherits
[18:01:56.975]                       invokeRestart <- base::invokeRestart
[18:01:56.975]                       is.null <- base::is.null
[18:01:56.975]                       muffled <- FALSE
[18:01:56.975]                       if (inherits(cond, "message")) {
[18:01:56.975]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.975]                         if (muffled) 
[18:01:56.975]                           invokeRestart("muffleMessage")
[18:01:56.975]                       }
[18:01:56.975]                       else if (inherits(cond, "warning")) {
[18:01:56.975]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.975]                         if (muffled) 
[18:01:56.975]                           invokeRestart("muffleWarning")
[18:01:56.975]                       }
[18:01:56.975]                       else if (inherits(cond, "condition")) {
[18:01:56.975]                         if (!is.null(pattern)) {
[18:01:56.975]                           computeRestarts <- base::computeRestarts
[18:01:56.975]                           grepl <- base::grepl
[18:01:56.975]                           restarts <- computeRestarts(cond)
[18:01:56.975]                           for (restart in restarts) {
[18:01:56.975]                             name <- restart$name
[18:01:56.975]                             if (is.null(name)) 
[18:01:56.975]                               next
[18:01:56.975]                             if (!grepl(pattern, name)) 
[18:01:56.975]                               next
[18:01:56.975]                             invokeRestart(restart)
[18:01:56.975]                             muffled <- TRUE
[18:01:56.975]                             break
[18:01:56.975]                           }
[18:01:56.975]                         }
[18:01:56.975]                       }
[18:01:56.975]                       invisible(muffled)
[18:01:56.975]                     }
[18:01:56.975]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.975]                   }
[18:01:56.975]                 }
[18:01:56.975]                 else {
[18:01:56.975]                   if (TRUE) {
[18:01:56.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:56.975]                     {
[18:01:56.975]                       inherits <- base::inherits
[18:01:56.975]                       invokeRestart <- base::invokeRestart
[18:01:56.975]                       is.null <- base::is.null
[18:01:56.975]                       muffled <- FALSE
[18:01:56.975]                       if (inherits(cond, "message")) {
[18:01:56.975]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:56.975]                         if (muffled) 
[18:01:56.975]                           invokeRestart("muffleMessage")
[18:01:56.975]                       }
[18:01:56.975]                       else if (inherits(cond, "warning")) {
[18:01:56.975]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:56.975]                         if (muffled) 
[18:01:56.975]                           invokeRestart("muffleWarning")
[18:01:56.975]                       }
[18:01:56.975]                       else if (inherits(cond, "condition")) {
[18:01:56.975]                         if (!is.null(pattern)) {
[18:01:56.975]                           computeRestarts <- base::computeRestarts
[18:01:56.975]                           grepl <- base::grepl
[18:01:56.975]                           restarts <- computeRestarts(cond)
[18:01:56.975]                           for (restart in restarts) {
[18:01:56.975]                             name <- restart$name
[18:01:56.975]                             if (is.null(name)) 
[18:01:56.975]                               next
[18:01:56.975]                             if (!grepl(pattern, name)) 
[18:01:56.975]                               next
[18:01:56.975]                             invokeRestart(restart)
[18:01:56.975]                             muffled <- TRUE
[18:01:56.975]                             break
[18:01:56.975]                           }
[18:01:56.975]                         }
[18:01:56.975]                       }
[18:01:56.975]                       invisible(muffled)
[18:01:56.975]                     }
[18:01:56.975]                     muffleCondition(cond, pattern = "^muffle")
[18:01:56.975]                   }
[18:01:56.975]                 }
[18:01:56.975]             }
[18:01:56.975]         }))
[18:01:56.975]     }, error = function(ex) {
[18:01:56.975]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:56.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:56.975]                 ...future.rng), started = ...future.startTime, 
[18:01:56.975]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:56.975]             version = "1.8"), class = "FutureResult")
[18:01:56.975]     }, finally = {
[18:01:56.975]         if (!identical(...future.workdir, getwd())) 
[18:01:56.975]             setwd(...future.workdir)
[18:01:56.975]         {
[18:01:56.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:56.975]                 ...future.oldOptions$nwarnings <- NULL
[18:01:56.975]             }
[18:01:56.975]             base::options(...future.oldOptions)
[18:01:56.975]             if (.Platform$OS.type == "windows") {
[18:01:56.975]                 old_names <- names(...future.oldEnvVars)
[18:01:56.975]                 envs <- base::Sys.getenv()
[18:01:56.975]                 names <- names(envs)
[18:01:56.975]                 common <- intersect(names, old_names)
[18:01:56.975]                 added <- setdiff(names, old_names)
[18:01:56.975]                 removed <- setdiff(old_names, names)
[18:01:56.975]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:56.975]                   envs[common]]
[18:01:56.975]                 NAMES <- toupper(changed)
[18:01:56.975]                 args <- list()
[18:01:56.975]                 for (kk in seq_along(NAMES)) {
[18:01:56.975]                   name <- changed[[kk]]
[18:01:56.975]                   NAME <- NAMES[[kk]]
[18:01:56.975]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.975]                     next
[18:01:56.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.975]                 }
[18:01:56.975]                 NAMES <- toupper(added)
[18:01:56.975]                 for (kk in seq_along(NAMES)) {
[18:01:56.975]                   name <- added[[kk]]
[18:01:56.975]                   NAME <- NAMES[[kk]]
[18:01:56.975]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.975]                     next
[18:01:56.975]                   args[[name]] <- ""
[18:01:56.975]                 }
[18:01:56.975]                 NAMES <- toupper(removed)
[18:01:56.975]                 for (kk in seq_along(NAMES)) {
[18:01:56.975]                   name <- removed[[kk]]
[18:01:56.975]                   NAME <- NAMES[[kk]]
[18:01:56.975]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:56.975]                     next
[18:01:56.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:56.975]                 }
[18:01:56.975]                 if (length(args) > 0) 
[18:01:56.975]                   base::do.call(base::Sys.setenv, args = args)
[18:01:56.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:56.975]             }
[18:01:56.975]             else {
[18:01:56.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:56.975]             }
[18:01:56.975]             {
[18:01:56.975]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:56.975]                   0L) {
[18:01:56.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:56.975]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:56.975]                   base::options(opts)
[18:01:56.975]                 }
[18:01:56.975]                 {
[18:01:56.975]                   {
[18:01:56.975]                     NULL
[18:01:56.975]                     RNGkind("Mersenne-Twister")
[18:01:56.975]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:01:56.975]                       inherits = FALSE)
[18:01:56.975]                   }
[18:01:56.975]                   options(future.plan = NULL)
[18:01:56.975]                   if (is.na(NA_character_)) 
[18:01:56.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:56.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:56.975]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:56.975]                     .init = FALSE)
[18:01:56.975]                 }
[18:01:56.975]             }
[18:01:56.975]         }
[18:01:56.975]     })
[18:01:56.975]     if (TRUE) {
[18:01:56.975]         base::sink(type = "output", split = FALSE)
[18:01:56.975]         if (TRUE) {
[18:01:56.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:56.975]         }
[18:01:56.975]         else {
[18:01:56.975]             ...future.result["stdout"] <- base::list(NULL)
[18:01:56.975]         }
[18:01:56.975]         base::close(...future.stdout)
[18:01:56.975]         ...future.stdout <- NULL
[18:01:56.975]     }
[18:01:56.975]     ...future.result$conditions <- ...future.conditions
[18:01:56.975]     ...future.result$finished <- base::Sys.time()
[18:01:56.975]     ...future.result
[18:01:56.975] }
[18:01:56.978] assign_globals() ...
[18:01:56.979] List of 11
[18:01:56.979]  $ ...future.FUN            :function (x, ...)  
[18:01:56.979]  $ x_FUN                    :function (x)  
[18:01:56.979]  $ times                    : int 2
[18:01:56.979]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:56.979]  $ stop_if_not              :function (...)  
[18:01:56.979]  $ dim                      : NULL
[18:01:56.979]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:56.979]  $ future.call.arguments    : list()
[18:01:56.979]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:56.979]  $ ...future.elements_ii    :List of 3
[18:01:56.979]   ..$ : int 1
[18:01:56.979]   ..$ : int 2
[18:01:56.979]   ..$ : int 3
[18:01:56.979]  $ ...future.seeds_ii       : NULL
[18:01:56.979]  $ ...future.globals.maxSize: NULL
[18:01:56.979]  - attr(*, "where")=List of 11
[18:01:56.979]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:56.979]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:56.979]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:56.979]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:56.979]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:56.979]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:56.979]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:56.979]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:56.979]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:56.979]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:56.979]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:56.979]  - attr(*, "resolved")= logi FALSE
[18:01:56.979]  - attr(*, "total_size")= num 95128
[18:01:56.979]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:56.979]  - attr(*, "already-done")= logi TRUE
[18:01:56.995] - copied ‘...future.FUN’ to environment
[18:01:56.995] - copied ‘x_FUN’ to environment
[18:01:56.995] - copied ‘times’ to environment
[18:01:56.995] - copied ‘stopf’ to environment
[18:01:56.995] - copied ‘stop_if_not’ to environment
[18:01:56.996] - copied ‘dim’ to environment
[18:01:56.996] - copied ‘valid_types’ to environment
[18:01:56.996] - copied ‘future.call.arguments’ to environment
[18:01:56.996] - copied ‘...future.elements_ii’ to environment
[18:01:56.996] - copied ‘...future.seeds_ii’ to environment
[18:01:56.997] - copied ‘...future.globals.maxSize’ to environment
[18:01:56.997] assign_globals() ... done
[18:01:56.998] plan(): Setting new future strategy stack:
[18:01:56.998] List of future strategies:
[18:01:56.998] 1. sequential:
[18:01:56.998]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:56.998]    - tweaked: FALSE
[18:01:56.998]    - call: NULL
[18:01:56.999] plan(): nbrOfWorkers() = 1
[18:01:57.001] plan(): Setting new future strategy stack:
[18:01:57.001] List of future strategies:
[18:01:57.001] 1. sequential:
[18:01:57.001]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:57.001]    - tweaked: FALSE
[18:01:57.001]    - call: plan(strategy)
[18:01:57.002] plan(): nbrOfWorkers() = 1
[18:01:57.002] SequentialFuture started (and completed)
[18:01:57.002] signalConditions() ...
[18:01:57.002]  - include = ‘immediateCondition’
[18:01:57.003]  - exclude = 
[18:01:57.003]  - resignal = FALSE
[18:01:57.003]  - Number of conditions: 1
[18:01:57.003] signalConditions() ... done
[18:01:57.003] - Launch lazy future ... done
[18:01:57.004] run() for ‘SequentialFuture’ ... done
[18:01:57.004] Created future:
[18:01:57.004] SequentialFuture:
[18:01:57.004] Label: ‘future_vapply-1’
[18:01:57.004] Expression:
[18:01:57.004] {
[18:01:57.004]     do.call(function(...) {
[18:01:57.004]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.004]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.004]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.004]             on.exit(options(oopts), add = TRUE)
[18:01:57.004]         }
[18:01:57.004]         {
[18:01:57.004]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.004]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.004]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.004]             })
[18:01:57.004]         }
[18:01:57.004]     }, args = future.call.arguments)
[18:01:57.004] }
[18:01:57.004] Lazy evaluation: FALSE
[18:01:57.004] Asynchronous evaluation: FALSE
[18:01:57.004] Local evaluation: TRUE
[18:01:57.004] Environment: R_GlobalEnv
[18:01:57.004] Capture standard output: TRUE
[18:01:57.004] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:57.004] Globals: 11 objects totaling 93.06 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:57.004] Packages: 1 packages (‘future.apply’)
[18:01:57.004] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:57.004] Resolved: TRUE
[18:01:57.004] Value: 0 bytes of class ‘NULL’
[18:01:57.004] Conditions captured: [n=1] ‘simpleError’
[18:01:57.004] Early signaling: FALSE
[18:01:57.004] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:57.004] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:01:57.007] Chunk #1 of 1 ... DONE
[18:01:57.009] Launching 1 futures (chunks) ... DONE
[18:01:57.010] Resolving 1 futures (chunks) ...
[18:01:57.010] resolve() on list ...
[18:01:57.010]  recursive: 0
[18:01:57.010]  length: 1
[18:01:57.010] 
[18:01:57.011] resolved() for ‘SequentialFuture’ ...
[18:01:57.011] - state: ‘finished’
[18:01:57.011] - run: TRUE
[18:01:57.011] - result: ‘FutureResult’
[18:01:57.012] resolved() for ‘SequentialFuture’ ... done
[18:01:57.012] Future #1
[18:01:57.012] signalConditions() ...
[18:01:57.012]  - include = ‘immediateCondition’
[18:01:57.012]  - exclude = 
[18:01:57.013]  - resignal = FALSE
[18:01:57.013]  - Number of conditions: 1
[18:01:57.013] signalConditions() ... done
[18:01:57.013] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:01:57.013] - nx: 1
[18:01:57.014] - relay: TRUE
[18:01:57.014] - stdout: TRUE
[18:01:57.014] - signal: TRUE
[18:01:57.014] - resignal: FALSE
[18:01:57.014] - force: TRUE
[18:01:57.014] - relayed: [n=1] FALSE
[18:01:57.015] - queued futures: [n=1] FALSE
[18:01:57.015]  - until=1
[18:01:57.015]  - relaying element #1
[18:01:57.015] signalConditions() ...
[18:01:57.015]  - include = ‘immediateCondition’
[18:01:57.016]  - exclude = 
[18:01:57.016]  - resignal = FALSE
[18:01:57.016]  - Number of conditions: 1
[18:01:57.016] signalConditions() ... done
[18:01:57.016] signalConditions() ...
[18:01:57.017]  - include = ‘immediateCondition’
[18:01:57.017]  - exclude = 
[18:01:57.017]  - resignal = FALSE
[18:01:57.017]  - Number of conditions: 1
[18:01:57.017] signalConditions() ... done
[18:01:57.018] signalConditions() ...
[18:01:57.018]  - include = ‘condition’
[18:01:57.018]  - exclude = ‘immediateCondition’
[18:01:57.018]  - resignal = TRUE
[18:01:57.018]  - Number of conditions: 1
[18:01:57.018]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:01:57.019] signalConditions() ... done
[18:01:57.019] - relayed: [n=1] FALSE
[18:01:57.019] - queued futures: [n=1] TRUE
[18:01:57.019] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:01:57.020] plan(): Setting new future strategy stack:
[18:01:57.020] List of future strategies:
[18:01:57.020] 1. sequential:
[18:01:57.020]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:57.020]    - tweaked: FALSE
[18:01:57.020]    - call: plan(sequential)
[18:01:57.021] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[18:01:57.022] plan(): Setting new future strategy stack:
[18:01:57.022] List of future strategies:
[18:01:57.022] 1. multicore:
[18:01:57.022]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:57.022]    - tweaked: FALSE
[18:01:57.022]    - call: plan(strategy)
[18:01:57.029] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[18:01:57.033] future_lapply() ...
[18:01:57.044] Number of chunks: 2
[18:01:57.044] getGlobalsAndPackagesXApply() ...
[18:01:57.044]  - future.globals: TRUE
[18:01:57.044] getGlobalsAndPackages() ...
[18:01:57.044] Searching for globals...
[18:01:57.051] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:01:57.052] Searching for globals ... DONE
[18:01:57.052] Resolving globals: FALSE
[18:01:57.054] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[18:01:57.055] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:57.055] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:57.055] - packages: [1] ‘future.apply’
[18:01:57.056] getGlobalsAndPackages() ... DONE
[18:01:57.056]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:57.056]  - needed namespaces: [n=1] ‘future.apply’
[18:01:57.056] Finding globals ... DONE
[18:01:57.056]  - use_args: TRUE
[18:01:57.057]  - Getting '...' globals ...
[18:01:57.057] resolve() on list ...
[18:01:57.058]  recursive: 0
[18:01:57.058]  length: 1
[18:01:57.058]  elements: ‘...’
[18:01:57.058]  length: 0 (resolved future 1)
[18:01:57.058] resolve() on list ... DONE
[18:01:57.059]    - '...' content: [n=0] 
[18:01:57.059] List of 1
[18:01:57.059]  $ ...: list()
[18:01:57.059]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.059]  - attr(*, "where")=List of 1
[18:01:57.059]   ..$ ...:<environment: 0x6183c0298d20> 
[18:01:57.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.059]  - attr(*, "resolved")= logi TRUE
[18:01:57.059]  - attr(*, "total_size")= num NA
[18:01:57.067]  - Getting '...' globals ... DONE
[18:01:57.068] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:57.068] List of 8
[18:01:57.068]  $ ...future.FUN:function (x, ...)  
[18:01:57.068]  $ x_FUN        :function (x)  
[18:01:57.068]  $ times        : int 1
[18:01:57.068]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:57.068]  $ stop_if_not  :function (...)  
[18:01:57.068]  $ dim          : NULL
[18:01:57.068]  $ valid_types  : chr "character"
[18:01:57.068]  $ ...          : list()
[18:01:57.068]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.068]  - attr(*, "where")=List of 8
[18:01:57.068]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:57.068]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:57.068]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:57.068]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:57.068]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:57.068]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:57.068]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:57.068]   ..$ ...          :<environment: 0x6183c0298d20> 
[18:01:57.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.068]  - attr(*, "resolved")= logi FALSE
[18:01:57.068]  - attr(*, "total_size")= num 94208
[18:01:57.080] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:57.081] getGlobalsAndPackagesXApply() ... DONE
[18:01:57.081] Number of futures (= number of chunks): 2
[18:01:57.081] Launching 2 futures (chunks) ...
[18:01:57.081] Chunk #1 of 2 ...
[18:01:57.082]  - Finding globals in 'X' for chunk #1 ...
[18:01:57.082] getGlobalsAndPackages() ...
[18:01:57.082] Searching for globals...
[18:01:57.083] 
[18:01:57.083] Searching for globals ... DONE
[18:01:57.083] - globals: [0] <none>
[18:01:57.083] getGlobalsAndPackages() ... DONE
[18:01:57.083]    + additional globals found: [n=0] 
[18:01:57.083]    + additional namespaces needed: [n=0] 
[18:01:57.084]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:57.084]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:57.084]  - seeds: <none>
[18:01:57.084]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.084] getGlobalsAndPackages() ...
[18:01:57.085] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.085] Resolving globals: FALSE
[18:01:57.085] Tweak future expression to call with '...' arguments ...
[18:01:57.085] {
[18:01:57.085]     do.call(function(...) {
[18:01:57.085]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.085]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.085]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.085]             on.exit(options(oopts), add = TRUE)
[18:01:57.085]         }
[18:01:57.085]         {
[18:01:57.085]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.085]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.085]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.085]             })
[18:01:57.085]         }
[18:01:57.085]     }, args = future.call.arguments)
[18:01:57.085] }
[18:01:57.086] Tweak future expression to call with '...' arguments ... DONE
[18:01:57.087] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.087] - packages: [1] ‘future.apply’
[18:01:57.087] getGlobalsAndPackages() ... DONE
[18:01:57.088] run() for ‘Future’ ...
[18:01:57.088] - state: ‘created’
[18:01:57.088] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:57.095] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.095] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:57.095]   - Field: ‘label’
[18:01:57.096]   - Field: ‘local’
[18:01:57.096]   - Field: ‘owner’
[18:01:57.096]   - Field: ‘envir’
[18:01:57.096]   - Field: ‘workers’
[18:01:57.096]   - Field: ‘packages’
[18:01:57.097]   - Field: ‘gc’
[18:01:57.097]   - Field: ‘job’
[18:01:57.097]   - Field: ‘conditions’
[18:01:57.097]   - Field: ‘expr’
[18:01:57.097]   - Field: ‘uuid’
[18:01:57.098]   - Field: ‘seed’
[18:01:57.098]   - Field: ‘version’
[18:01:57.098]   - Field: ‘result’
[18:01:57.098]   - Field: ‘asynchronous’
[18:01:57.098]   - Field: ‘calls’
[18:01:57.099]   - Field: ‘globals’
[18:01:57.099]   - Field: ‘stdout’
[18:01:57.099]   - Field: ‘earlySignal’
[18:01:57.099]   - Field: ‘lazy’
[18:01:57.099]   - Field: ‘state’
[18:01:57.100] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:57.100] - Launch lazy future ...
[18:01:57.102] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:57.102] Packages needed by future strategies (n = 0): <none>
[18:01:57.103] {
[18:01:57.103]     {
[18:01:57.103]         {
[18:01:57.103]             ...future.startTime <- base::Sys.time()
[18:01:57.103]             {
[18:01:57.103]                 {
[18:01:57.103]                   {
[18:01:57.103]                     {
[18:01:57.103]                       {
[18:01:57.103]                         base::local({
[18:01:57.103]                           has_future <- base::requireNamespace("future", 
[18:01:57.103]                             quietly = TRUE)
[18:01:57.103]                           if (has_future) {
[18:01:57.103]                             ns <- base::getNamespace("future")
[18:01:57.103]                             version <- ns[[".package"]][["version"]]
[18:01:57.103]                             if (is.null(version)) 
[18:01:57.103]                               version <- utils::packageVersion("future")
[18:01:57.103]                           }
[18:01:57.103]                           else {
[18:01:57.103]                             version <- NULL
[18:01:57.103]                           }
[18:01:57.103]                           if (!has_future || version < "1.8.0") {
[18:01:57.103]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:57.103]                               "", base::R.version$version.string), 
[18:01:57.103]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:57.103]                                 base::R.version$platform, 8 * 
[18:01:57.103]                                   base::.Machine$sizeof.pointer), 
[18:01:57.103]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:57.103]                                 "release", "version")], collapse = " "), 
[18:01:57.103]                               hostname = base::Sys.info()[["nodename"]])
[18:01:57.103]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:57.103]                               info)
[18:01:57.103]                             info <- base::paste(info, collapse = "; ")
[18:01:57.103]                             if (!has_future) {
[18:01:57.103]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:57.103]                                 info)
[18:01:57.103]                             }
[18:01:57.103]                             else {
[18:01:57.103]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:57.103]                                 info, version)
[18:01:57.103]                             }
[18:01:57.103]                             base::stop(msg)
[18:01:57.103]                           }
[18:01:57.103]                         })
[18:01:57.103]                       }
[18:01:57.103]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:57.103]                       base::options(mc.cores = 1L)
[18:01:57.103]                     }
[18:01:57.103]                     base::local({
[18:01:57.103]                       for (pkg in "future.apply") {
[18:01:57.103]                         base::loadNamespace(pkg)
[18:01:57.103]                         base::library(pkg, character.only = TRUE)
[18:01:57.103]                       }
[18:01:57.103]                     })
[18:01:57.103]                   }
[18:01:57.103]                   ...future.strategy.old <- future::plan("list")
[18:01:57.103]                   options(future.plan = NULL)
[18:01:57.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:57.103]                 }
[18:01:57.103]                 ...future.workdir <- getwd()
[18:01:57.103]             }
[18:01:57.103]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:57.103]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:57.103]         }
[18:01:57.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:57.103]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:57.103]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:57.103]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:57.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:57.103]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:57.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:57.103]             base::names(...future.oldOptions))
[18:01:57.103]     }
[18:01:57.103]     if (FALSE) {
[18:01:57.103]     }
[18:01:57.103]     else {
[18:01:57.103]         if (TRUE) {
[18:01:57.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:57.103]                 open = "w")
[18:01:57.103]         }
[18:01:57.103]         else {
[18:01:57.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:57.103]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:57.103]         }
[18:01:57.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:57.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:57.103]             base::sink(type = "output", split = FALSE)
[18:01:57.103]             base::close(...future.stdout)
[18:01:57.103]         }, add = TRUE)
[18:01:57.103]     }
[18:01:57.103]     ...future.frame <- base::sys.nframe()
[18:01:57.103]     ...future.conditions <- base::list()
[18:01:57.103]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:57.103]     if (FALSE) {
[18:01:57.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:57.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:57.103]     }
[18:01:57.103]     ...future.result <- base::tryCatch({
[18:01:57.103]         base::withCallingHandlers({
[18:01:57.103]             ...future.value <- base::withVisible(base::local({
[18:01:57.103]                 withCallingHandlers({
[18:01:57.103]                   {
[18:01:57.103]                     do.call(function(...) {
[18:01:57.103]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.103]                       if (!identical(...future.globals.maxSize.org, 
[18:01:57.103]                         ...future.globals.maxSize)) {
[18:01:57.103]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.103]                         on.exit(options(oopts), add = TRUE)
[18:01:57.103]                       }
[18:01:57.103]                       {
[18:01:57.103]                         lapply(seq_along(...future.elements_ii), 
[18:01:57.103]                           FUN = function(jj) {
[18:01:57.103]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.103]                             ...future.FUN(...future.X_jj, ...)
[18:01:57.103]                           })
[18:01:57.103]                       }
[18:01:57.103]                     }, args = future.call.arguments)
[18:01:57.103]                   }
[18:01:57.103]                 }, immediateCondition = function(cond) {
[18:01:57.103]                   save_rds <- function (object, pathname, ...) 
[18:01:57.103]                   {
[18:01:57.103]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:57.103]                     if (file_test("-f", pathname_tmp)) {
[18:01:57.103]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.103]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:57.103]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.103]                         fi_tmp[["mtime"]])
[18:01:57.103]                     }
[18:01:57.103]                     tryCatch({
[18:01:57.103]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:57.103]                     }, error = function(ex) {
[18:01:57.103]                       msg <- conditionMessage(ex)
[18:01:57.103]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.103]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:57.103]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.103]                         fi_tmp[["mtime"]], msg)
[18:01:57.103]                       ex$message <- msg
[18:01:57.103]                       stop(ex)
[18:01:57.103]                     })
[18:01:57.103]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:57.103]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:57.103]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:57.103]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.103]                       fi <- file.info(pathname)
[18:01:57.103]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:57.103]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.103]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:57.103]                         fi[["size"]], fi[["mtime"]])
[18:01:57.103]                       stop(msg)
[18:01:57.103]                     }
[18:01:57.103]                     invisible(pathname)
[18:01:57.103]                   }
[18:01:57.103]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:57.103]                     rootPath = tempdir()) 
[18:01:57.103]                   {
[18:01:57.103]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:57.103]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:57.103]                       tmpdir = path, fileext = ".rds")
[18:01:57.103]                     save_rds(obj, file)
[18:01:57.103]                   }
[18:01:57.103]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:57.103]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.103]                   {
[18:01:57.103]                     inherits <- base::inherits
[18:01:57.103]                     invokeRestart <- base::invokeRestart
[18:01:57.103]                     is.null <- base::is.null
[18:01:57.103]                     muffled <- FALSE
[18:01:57.103]                     if (inherits(cond, "message")) {
[18:01:57.103]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:57.103]                       if (muffled) 
[18:01:57.103]                         invokeRestart("muffleMessage")
[18:01:57.103]                     }
[18:01:57.103]                     else if (inherits(cond, "warning")) {
[18:01:57.103]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:57.103]                       if (muffled) 
[18:01:57.103]                         invokeRestart("muffleWarning")
[18:01:57.103]                     }
[18:01:57.103]                     else if (inherits(cond, "condition")) {
[18:01:57.103]                       if (!is.null(pattern)) {
[18:01:57.103]                         computeRestarts <- base::computeRestarts
[18:01:57.103]                         grepl <- base::grepl
[18:01:57.103]                         restarts <- computeRestarts(cond)
[18:01:57.103]                         for (restart in restarts) {
[18:01:57.103]                           name <- restart$name
[18:01:57.103]                           if (is.null(name)) 
[18:01:57.103]                             next
[18:01:57.103]                           if (!grepl(pattern, name)) 
[18:01:57.103]                             next
[18:01:57.103]                           invokeRestart(restart)
[18:01:57.103]                           muffled <- TRUE
[18:01:57.103]                           break
[18:01:57.103]                         }
[18:01:57.103]                       }
[18:01:57.103]                     }
[18:01:57.103]                     invisible(muffled)
[18:01:57.103]                   }
[18:01:57.103]                   muffleCondition(cond)
[18:01:57.103]                 })
[18:01:57.103]             }))
[18:01:57.103]             future::FutureResult(value = ...future.value$value, 
[18:01:57.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.103]                   ...future.rng), globalenv = if (FALSE) 
[18:01:57.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:57.103]                     ...future.globalenv.names))
[18:01:57.103]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:57.103]         }, condition = base::local({
[18:01:57.103]             c <- base::c
[18:01:57.103]             inherits <- base::inherits
[18:01:57.103]             invokeRestart <- base::invokeRestart
[18:01:57.103]             length <- base::length
[18:01:57.103]             list <- base::list
[18:01:57.103]             seq.int <- base::seq.int
[18:01:57.103]             signalCondition <- base::signalCondition
[18:01:57.103]             sys.calls <- base::sys.calls
[18:01:57.103]             `[[` <- base::`[[`
[18:01:57.103]             `+` <- base::`+`
[18:01:57.103]             `<<-` <- base::`<<-`
[18:01:57.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:57.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:57.103]                   3L)]
[18:01:57.103]             }
[18:01:57.103]             function(cond) {
[18:01:57.103]                 is_error <- inherits(cond, "error")
[18:01:57.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:57.103]                   NULL)
[18:01:57.103]                 if (is_error) {
[18:01:57.103]                   sessionInformation <- function() {
[18:01:57.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:57.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:57.103]                       search = base::search(), system = base::Sys.info())
[18:01:57.103]                   }
[18:01:57.103]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:57.103]                     cond$call), session = sessionInformation(), 
[18:01:57.103]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:57.103]                   signalCondition(cond)
[18:01:57.103]                 }
[18:01:57.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:57.103]                 "immediateCondition"))) {
[18:01:57.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:57.103]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:57.103]                   if (TRUE && !signal) {
[18:01:57.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.103]                     {
[18:01:57.103]                       inherits <- base::inherits
[18:01:57.103]                       invokeRestart <- base::invokeRestart
[18:01:57.103]                       is.null <- base::is.null
[18:01:57.103]                       muffled <- FALSE
[18:01:57.103]                       if (inherits(cond, "message")) {
[18:01:57.103]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.103]                         if (muffled) 
[18:01:57.103]                           invokeRestart("muffleMessage")
[18:01:57.103]                       }
[18:01:57.103]                       else if (inherits(cond, "warning")) {
[18:01:57.103]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.103]                         if (muffled) 
[18:01:57.103]                           invokeRestart("muffleWarning")
[18:01:57.103]                       }
[18:01:57.103]                       else if (inherits(cond, "condition")) {
[18:01:57.103]                         if (!is.null(pattern)) {
[18:01:57.103]                           computeRestarts <- base::computeRestarts
[18:01:57.103]                           grepl <- base::grepl
[18:01:57.103]                           restarts <- computeRestarts(cond)
[18:01:57.103]                           for (restart in restarts) {
[18:01:57.103]                             name <- restart$name
[18:01:57.103]                             if (is.null(name)) 
[18:01:57.103]                               next
[18:01:57.103]                             if (!grepl(pattern, name)) 
[18:01:57.103]                               next
[18:01:57.103]                             invokeRestart(restart)
[18:01:57.103]                             muffled <- TRUE
[18:01:57.103]                             break
[18:01:57.103]                           }
[18:01:57.103]                         }
[18:01:57.103]                       }
[18:01:57.103]                       invisible(muffled)
[18:01:57.103]                     }
[18:01:57.103]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.103]                   }
[18:01:57.103]                 }
[18:01:57.103]                 else {
[18:01:57.103]                   if (TRUE) {
[18:01:57.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.103]                     {
[18:01:57.103]                       inherits <- base::inherits
[18:01:57.103]                       invokeRestart <- base::invokeRestart
[18:01:57.103]                       is.null <- base::is.null
[18:01:57.103]                       muffled <- FALSE
[18:01:57.103]                       if (inherits(cond, "message")) {
[18:01:57.103]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.103]                         if (muffled) 
[18:01:57.103]                           invokeRestart("muffleMessage")
[18:01:57.103]                       }
[18:01:57.103]                       else if (inherits(cond, "warning")) {
[18:01:57.103]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.103]                         if (muffled) 
[18:01:57.103]                           invokeRestart("muffleWarning")
[18:01:57.103]                       }
[18:01:57.103]                       else if (inherits(cond, "condition")) {
[18:01:57.103]                         if (!is.null(pattern)) {
[18:01:57.103]                           computeRestarts <- base::computeRestarts
[18:01:57.103]                           grepl <- base::grepl
[18:01:57.103]                           restarts <- computeRestarts(cond)
[18:01:57.103]                           for (restart in restarts) {
[18:01:57.103]                             name <- restart$name
[18:01:57.103]                             if (is.null(name)) 
[18:01:57.103]                               next
[18:01:57.103]                             if (!grepl(pattern, name)) 
[18:01:57.103]                               next
[18:01:57.103]                             invokeRestart(restart)
[18:01:57.103]                             muffled <- TRUE
[18:01:57.103]                             break
[18:01:57.103]                           }
[18:01:57.103]                         }
[18:01:57.103]                       }
[18:01:57.103]                       invisible(muffled)
[18:01:57.103]                     }
[18:01:57.103]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.103]                   }
[18:01:57.103]                 }
[18:01:57.103]             }
[18:01:57.103]         }))
[18:01:57.103]     }, error = function(ex) {
[18:01:57.103]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:57.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.103]                 ...future.rng), started = ...future.startTime, 
[18:01:57.103]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:57.103]             version = "1.8"), class = "FutureResult")
[18:01:57.103]     }, finally = {
[18:01:57.103]         if (!identical(...future.workdir, getwd())) 
[18:01:57.103]             setwd(...future.workdir)
[18:01:57.103]         {
[18:01:57.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:57.103]                 ...future.oldOptions$nwarnings <- NULL
[18:01:57.103]             }
[18:01:57.103]             base::options(...future.oldOptions)
[18:01:57.103]             if (.Platform$OS.type == "windows") {
[18:01:57.103]                 old_names <- names(...future.oldEnvVars)
[18:01:57.103]                 envs <- base::Sys.getenv()
[18:01:57.103]                 names <- names(envs)
[18:01:57.103]                 common <- intersect(names, old_names)
[18:01:57.103]                 added <- setdiff(names, old_names)
[18:01:57.103]                 removed <- setdiff(old_names, names)
[18:01:57.103]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:57.103]                   envs[common]]
[18:01:57.103]                 NAMES <- toupper(changed)
[18:01:57.103]                 args <- list()
[18:01:57.103]                 for (kk in seq_along(NAMES)) {
[18:01:57.103]                   name <- changed[[kk]]
[18:01:57.103]                   NAME <- NAMES[[kk]]
[18:01:57.103]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.103]                     next
[18:01:57.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.103]                 }
[18:01:57.103]                 NAMES <- toupper(added)
[18:01:57.103]                 for (kk in seq_along(NAMES)) {
[18:01:57.103]                   name <- added[[kk]]
[18:01:57.103]                   NAME <- NAMES[[kk]]
[18:01:57.103]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.103]                     next
[18:01:57.103]                   args[[name]] <- ""
[18:01:57.103]                 }
[18:01:57.103]                 NAMES <- toupper(removed)
[18:01:57.103]                 for (kk in seq_along(NAMES)) {
[18:01:57.103]                   name <- removed[[kk]]
[18:01:57.103]                   NAME <- NAMES[[kk]]
[18:01:57.103]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.103]                     next
[18:01:57.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.103]                 }
[18:01:57.103]                 if (length(args) > 0) 
[18:01:57.103]                   base::do.call(base::Sys.setenv, args = args)
[18:01:57.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:57.103]             }
[18:01:57.103]             else {
[18:01:57.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:57.103]             }
[18:01:57.103]             {
[18:01:57.103]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:57.103]                   0L) {
[18:01:57.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:57.103]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:57.103]                   base::options(opts)
[18:01:57.103]                 }
[18:01:57.103]                 {
[18:01:57.103]                   {
[18:01:57.103]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:57.103]                     NULL
[18:01:57.103]                   }
[18:01:57.103]                   options(future.plan = NULL)
[18:01:57.103]                   if (is.na(NA_character_)) 
[18:01:57.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:57.103]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:57.103]                     .init = FALSE)
[18:01:57.103]                 }
[18:01:57.103]             }
[18:01:57.103]         }
[18:01:57.103]     })
[18:01:57.103]     if (TRUE) {
[18:01:57.103]         base::sink(type = "output", split = FALSE)
[18:01:57.103]         if (TRUE) {
[18:01:57.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:57.103]         }
[18:01:57.103]         else {
[18:01:57.103]             ...future.result["stdout"] <- base::list(NULL)
[18:01:57.103]         }
[18:01:57.103]         base::close(...future.stdout)
[18:01:57.103]         ...future.stdout <- NULL
[18:01:57.103]     }
[18:01:57.103]     ...future.result$conditions <- ...future.conditions
[18:01:57.103]     ...future.result$finished <- base::Sys.time()
[18:01:57.103]     ...future.result
[18:01:57.103] }
[18:01:57.108] assign_globals() ...
[18:01:57.108] List of 11
[18:01:57.108]  $ ...future.FUN            :function (x, ...)  
[18:01:57.108]  $ x_FUN                    :function (x)  
[18:01:57.108]  $ times                    : int 1
[18:01:57.108]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:57.108]  $ stop_if_not              :function (...)  
[18:01:57.108]  $ dim                      : NULL
[18:01:57.108]  $ valid_types              : chr "character"
[18:01:57.108]  $ future.call.arguments    : list()
[18:01:57.108]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.108]  $ ...future.elements_ii    :List of 1
[18:01:57.108]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[18:01:57.108]  $ ...future.seeds_ii       : NULL
[18:01:57.108]  $ ...future.globals.maxSize: NULL
[18:01:57.108]  - attr(*, "where")=List of 11
[18:01:57.108]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:57.108]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:57.108]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:57.108]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:57.108]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:57.108]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:57.108]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:57.108]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:57.108]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:57.108]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:57.108]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:57.108]  - attr(*, "resolved")= logi FALSE
[18:01:57.108]  - attr(*, "total_size")= num 94208
[18:01:57.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.108]  - attr(*, "already-done")= logi TRUE
[18:01:57.128] - copied ‘...future.FUN’ to environment
[18:01:57.128] - copied ‘x_FUN’ to environment
[18:01:57.129] - copied ‘times’ to environment
[18:01:57.129] - copied ‘stopf’ to environment
[18:01:57.129] - copied ‘stop_if_not’ to environment
[18:01:57.129] - copied ‘dim’ to environment
[18:01:57.129] - copied ‘valid_types’ to environment
[18:01:57.130] - copied ‘future.call.arguments’ to environment
[18:01:57.130] - copied ‘...future.elements_ii’ to environment
[18:01:57.130] - copied ‘...future.seeds_ii’ to environment
[18:01:57.130] - copied ‘...future.globals.maxSize’ to environment
[18:01:57.130] assign_globals() ... done
[18:01:57.131] requestCore(): workers = 2
[18:01:57.135] MulticoreFuture started
[18:01:57.136] - Launch lazy future ... done
[18:01:57.137] run() for ‘MulticoreFuture’ ... done
[18:01:57.137] Created future:
[18:01:57.138] plan(): Setting new future strategy stack:
[18:01:57.138] List of future strategies:
[18:01:57.138] 1. sequential:
[18:01:57.138]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:57.138]    - tweaked: FALSE
[18:01:57.138]    - call: NULL
[18:01:57.141] plan(): nbrOfWorkers() = 1
[18:01:57.145] plan(): Setting new future strategy stack:
[18:01:57.145] List of future strategies:
[18:01:57.145] 1. multicore:
[18:01:57.145]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:57.145]    - tweaked: FALSE
[18:01:57.145]    - call: plan(strategy)
[18:01:57.154] plan(): nbrOfWorkers() = 2
[18:01:57.138] MulticoreFuture:
[18:01:57.138] Label: ‘future_vapply-1’
[18:01:57.138] Expression:
[18:01:57.138] {
[18:01:57.138]     do.call(function(...) {
[18:01:57.138]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.138]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.138]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.138]             on.exit(options(oopts), add = TRUE)
[18:01:57.138]         }
[18:01:57.138]         {
[18:01:57.138]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.138]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.138]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.138]             })
[18:01:57.138]         }
[18:01:57.138]     }, args = future.call.arguments)
[18:01:57.138] }
[18:01:57.138] Lazy evaluation: FALSE
[18:01:57.138] Asynchronous evaluation: TRUE
[18:01:57.138] Local evaluation: TRUE
[18:01:57.138] Environment: R_GlobalEnv
[18:01:57.138] Capture standard output: TRUE
[18:01:57.138] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:57.138] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:57.138] Packages: 1 packages (‘future.apply’)
[18:01:57.138] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:57.138] Resolved: TRUE
[18:01:57.138] Value: <not collected>
[18:01:57.138] Conditions captured: <none>
[18:01:57.138] Early signaling: FALSE
[18:01:57.138] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:57.138] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.156] Chunk #1 of 2 ... DONE
[18:01:57.156] Chunk #2 of 2 ...
[18:01:57.157]  - Finding globals in 'X' for chunk #2 ...
[18:01:57.157] getGlobalsAndPackages() ...
[18:01:57.157] Searching for globals...
[18:01:57.158] 
[18:01:57.158] Searching for globals ... DONE
[18:01:57.159] - globals: [0] <none>
[18:01:57.159] getGlobalsAndPackages() ... DONE
[18:01:57.159]    + additional globals found: [n=0] 
[18:01:57.160]    + additional namespaces needed: [n=0] 
[18:01:57.160]  - Finding globals in 'X' for chunk #2 ... DONE
[18:01:57.160]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:57.161]  - seeds: <none>
[18:01:57.161]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.162] getGlobalsAndPackages() ...
[18:01:57.162] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.162] Resolving globals: FALSE
[18:01:57.163] Tweak future expression to call with '...' arguments ...
[18:01:57.163] {
[18:01:57.163]     do.call(function(...) {
[18:01:57.163]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.163]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.163]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.163]             on.exit(options(oopts), add = TRUE)
[18:01:57.163]         }
[18:01:57.163]         {
[18:01:57.163]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.163]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.163]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.163]             })
[18:01:57.163]         }
[18:01:57.163]     }, args = future.call.arguments)
[18:01:57.163] }
[18:01:57.164] Tweak future expression to call with '...' arguments ... DONE
[18:01:57.166] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.166] - packages: [1] ‘future.apply’
[18:01:57.167] getGlobalsAndPackages() ... DONE
[18:01:57.167] run() for ‘Future’ ...
[18:01:57.168] - state: ‘created’
[18:01:57.168] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:57.176] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.177] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:57.177]   - Field: ‘label’
[18:01:57.177]   - Field: ‘local’
[18:01:57.178]   - Field: ‘owner’
[18:01:57.178]   - Field: ‘envir’
[18:01:57.178]   - Field: ‘workers’
[18:01:57.179]   - Field: ‘packages’
[18:01:57.179]   - Field: ‘gc’
[18:01:57.179]   - Field: ‘job’
[18:01:57.180]   - Field: ‘conditions’
[18:01:57.180]   - Field: ‘expr’
[18:01:57.180]   - Field: ‘uuid’
[18:01:57.181]   - Field: ‘seed’
[18:01:57.181]   - Field: ‘version’
[18:01:57.181]   - Field: ‘result’
[18:01:57.182]   - Field: ‘asynchronous’
[18:01:57.182]   - Field: ‘calls’
[18:01:57.182]   - Field: ‘globals’
[18:01:57.183]   - Field: ‘stdout’
[18:01:57.183]   - Field: ‘earlySignal’
[18:01:57.183]   - Field: ‘lazy’
[18:01:57.183]   - Field: ‘state’
[18:01:57.184] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:57.184] - Launch lazy future ...
[18:01:57.185] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:57.185] Packages needed by future strategies (n = 0): <none>
[18:01:57.187] {
[18:01:57.187]     {
[18:01:57.187]         {
[18:01:57.187]             ...future.startTime <- base::Sys.time()
[18:01:57.187]             {
[18:01:57.187]                 {
[18:01:57.187]                   {
[18:01:57.187]                     {
[18:01:57.187]                       {
[18:01:57.187]                         base::local({
[18:01:57.187]                           has_future <- base::requireNamespace("future", 
[18:01:57.187]                             quietly = TRUE)
[18:01:57.187]                           if (has_future) {
[18:01:57.187]                             ns <- base::getNamespace("future")
[18:01:57.187]                             version <- ns[[".package"]][["version"]]
[18:01:57.187]                             if (is.null(version)) 
[18:01:57.187]                               version <- utils::packageVersion("future")
[18:01:57.187]                           }
[18:01:57.187]                           else {
[18:01:57.187]                             version <- NULL
[18:01:57.187]                           }
[18:01:57.187]                           if (!has_future || version < "1.8.0") {
[18:01:57.187]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:57.187]                               "", base::R.version$version.string), 
[18:01:57.187]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:57.187]                                 base::R.version$platform, 8 * 
[18:01:57.187]                                   base::.Machine$sizeof.pointer), 
[18:01:57.187]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:57.187]                                 "release", "version")], collapse = " "), 
[18:01:57.187]                               hostname = base::Sys.info()[["nodename"]])
[18:01:57.187]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:57.187]                               info)
[18:01:57.187]                             info <- base::paste(info, collapse = "; ")
[18:01:57.187]                             if (!has_future) {
[18:01:57.187]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:57.187]                                 info)
[18:01:57.187]                             }
[18:01:57.187]                             else {
[18:01:57.187]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:57.187]                                 info, version)
[18:01:57.187]                             }
[18:01:57.187]                             base::stop(msg)
[18:01:57.187]                           }
[18:01:57.187]                         })
[18:01:57.187]                       }
[18:01:57.187]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:57.187]                       base::options(mc.cores = 1L)
[18:01:57.187]                     }
[18:01:57.187]                     base::local({
[18:01:57.187]                       for (pkg in "future.apply") {
[18:01:57.187]                         base::loadNamespace(pkg)
[18:01:57.187]                         base::library(pkg, character.only = TRUE)
[18:01:57.187]                       }
[18:01:57.187]                     })
[18:01:57.187]                   }
[18:01:57.187]                   ...future.strategy.old <- future::plan("list")
[18:01:57.187]                   options(future.plan = NULL)
[18:01:57.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:57.187]                 }
[18:01:57.187]                 ...future.workdir <- getwd()
[18:01:57.187]             }
[18:01:57.187]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:57.187]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:57.187]         }
[18:01:57.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:57.187]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:57.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:57.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:57.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:57.187]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:57.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:57.187]             base::names(...future.oldOptions))
[18:01:57.187]     }
[18:01:57.187]     if (FALSE) {
[18:01:57.187]     }
[18:01:57.187]     else {
[18:01:57.187]         if (TRUE) {
[18:01:57.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:57.187]                 open = "w")
[18:01:57.187]         }
[18:01:57.187]         else {
[18:01:57.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:57.187]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:57.187]         }
[18:01:57.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:57.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:57.187]             base::sink(type = "output", split = FALSE)
[18:01:57.187]             base::close(...future.stdout)
[18:01:57.187]         }, add = TRUE)
[18:01:57.187]     }
[18:01:57.187]     ...future.frame <- base::sys.nframe()
[18:01:57.187]     ...future.conditions <- base::list()
[18:01:57.187]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:57.187]     if (FALSE) {
[18:01:57.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:57.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:57.187]     }
[18:01:57.187]     ...future.result <- base::tryCatch({
[18:01:57.187]         base::withCallingHandlers({
[18:01:57.187]             ...future.value <- base::withVisible(base::local({
[18:01:57.187]                 withCallingHandlers({
[18:01:57.187]                   {
[18:01:57.187]                     do.call(function(...) {
[18:01:57.187]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.187]                       if (!identical(...future.globals.maxSize.org, 
[18:01:57.187]                         ...future.globals.maxSize)) {
[18:01:57.187]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.187]                         on.exit(options(oopts), add = TRUE)
[18:01:57.187]                       }
[18:01:57.187]                       {
[18:01:57.187]                         lapply(seq_along(...future.elements_ii), 
[18:01:57.187]                           FUN = function(jj) {
[18:01:57.187]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.187]                             ...future.FUN(...future.X_jj, ...)
[18:01:57.187]                           })
[18:01:57.187]                       }
[18:01:57.187]                     }, args = future.call.arguments)
[18:01:57.187]                   }
[18:01:57.187]                 }, immediateCondition = function(cond) {
[18:01:57.187]                   save_rds <- function (object, pathname, ...) 
[18:01:57.187]                   {
[18:01:57.187]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:57.187]                     if (file_test("-f", pathname_tmp)) {
[18:01:57.187]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.187]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:57.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.187]                         fi_tmp[["mtime"]])
[18:01:57.187]                     }
[18:01:57.187]                     tryCatch({
[18:01:57.187]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:57.187]                     }, error = function(ex) {
[18:01:57.187]                       msg <- conditionMessage(ex)
[18:01:57.187]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.187]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:57.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.187]                         fi_tmp[["mtime"]], msg)
[18:01:57.187]                       ex$message <- msg
[18:01:57.187]                       stop(ex)
[18:01:57.187]                     })
[18:01:57.187]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:57.187]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:57.187]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:57.187]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.187]                       fi <- file.info(pathname)
[18:01:57.187]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:57.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.187]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:57.187]                         fi[["size"]], fi[["mtime"]])
[18:01:57.187]                       stop(msg)
[18:01:57.187]                     }
[18:01:57.187]                     invisible(pathname)
[18:01:57.187]                   }
[18:01:57.187]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:57.187]                     rootPath = tempdir()) 
[18:01:57.187]                   {
[18:01:57.187]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:57.187]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:57.187]                       tmpdir = path, fileext = ".rds")
[18:01:57.187]                     save_rds(obj, file)
[18:01:57.187]                   }
[18:01:57.187]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:57.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.187]                   {
[18:01:57.187]                     inherits <- base::inherits
[18:01:57.187]                     invokeRestart <- base::invokeRestart
[18:01:57.187]                     is.null <- base::is.null
[18:01:57.187]                     muffled <- FALSE
[18:01:57.187]                     if (inherits(cond, "message")) {
[18:01:57.187]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:57.187]                       if (muffled) 
[18:01:57.187]                         invokeRestart("muffleMessage")
[18:01:57.187]                     }
[18:01:57.187]                     else if (inherits(cond, "warning")) {
[18:01:57.187]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:57.187]                       if (muffled) 
[18:01:57.187]                         invokeRestart("muffleWarning")
[18:01:57.187]                     }
[18:01:57.187]                     else if (inherits(cond, "condition")) {
[18:01:57.187]                       if (!is.null(pattern)) {
[18:01:57.187]                         computeRestarts <- base::computeRestarts
[18:01:57.187]                         grepl <- base::grepl
[18:01:57.187]                         restarts <- computeRestarts(cond)
[18:01:57.187]                         for (restart in restarts) {
[18:01:57.187]                           name <- restart$name
[18:01:57.187]                           if (is.null(name)) 
[18:01:57.187]                             next
[18:01:57.187]                           if (!grepl(pattern, name)) 
[18:01:57.187]                             next
[18:01:57.187]                           invokeRestart(restart)
[18:01:57.187]                           muffled <- TRUE
[18:01:57.187]                           break
[18:01:57.187]                         }
[18:01:57.187]                       }
[18:01:57.187]                     }
[18:01:57.187]                     invisible(muffled)
[18:01:57.187]                   }
[18:01:57.187]                   muffleCondition(cond)
[18:01:57.187]                 })
[18:01:57.187]             }))
[18:01:57.187]             future::FutureResult(value = ...future.value$value, 
[18:01:57.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.187]                   ...future.rng), globalenv = if (FALSE) 
[18:01:57.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:57.187]                     ...future.globalenv.names))
[18:01:57.187]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:57.187]         }, condition = base::local({
[18:01:57.187]             c <- base::c
[18:01:57.187]             inherits <- base::inherits
[18:01:57.187]             invokeRestart <- base::invokeRestart
[18:01:57.187]             length <- base::length
[18:01:57.187]             list <- base::list
[18:01:57.187]             seq.int <- base::seq.int
[18:01:57.187]             signalCondition <- base::signalCondition
[18:01:57.187]             sys.calls <- base::sys.calls
[18:01:57.187]             `[[` <- base::`[[`
[18:01:57.187]             `+` <- base::`+`
[18:01:57.187]             `<<-` <- base::`<<-`
[18:01:57.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:57.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:57.187]                   3L)]
[18:01:57.187]             }
[18:01:57.187]             function(cond) {
[18:01:57.187]                 is_error <- inherits(cond, "error")
[18:01:57.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:57.187]                   NULL)
[18:01:57.187]                 if (is_error) {
[18:01:57.187]                   sessionInformation <- function() {
[18:01:57.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:57.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:57.187]                       search = base::search(), system = base::Sys.info())
[18:01:57.187]                   }
[18:01:57.187]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:57.187]                     cond$call), session = sessionInformation(), 
[18:01:57.187]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:57.187]                   signalCondition(cond)
[18:01:57.187]                 }
[18:01:57.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:57.187]                 "immediateCondition"))) {
[18:01:57.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:57.187]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:57.187]                   if (TRUE && !signal) {
[18:01:57.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.187]                     {
[18:01:57.187]                       inherits <- base::inherits
[18:01:57.187]                       invokeRestart <- base::invokeRestart
[18:01:57.187]                       is.null <- base::is.null
[18:01:57.187]                       muffled <- FALSE
[18:01:57.187]                       if (inherits(cond, "message")) {
[18:01:57.187]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.187]                         if (muffled) 
[18:01:57.187]                           invokeRestart("muffleMessage")
[18:01:57.187]                       }
[18:01:57.187]                       else if (inherits(cond, "warning")) {
[18:01:57.187]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.187]                         if (muffled) 
[18:01:57.187]                           invokeRestart("muffleWarning")
[18:01:57.187]                       }
[18:01:57.187]                       else if (inherits(cond, "condition")) {
[18:01:57.187]                         if (!is.null(pattern)) {
[18:01:57.187]                           computeRestarts <- base::computeRestarts
[18:01:57.187]                           grepl <- base::grepl
[18:01:57.187]                           restarts <- computeRestarts(cond)
[18:01:57.187]                           for (restart in restarts) {
[18:01:57.187]                             name <- restart$name
[18:01:57.187]                             if (is.null(name)) 
[18:01:57.187]                               next
[18:01:57.187]                             if (!grepl(pattern, name)) 
[18:01:57.187]                               next
[18:01:57.187]                             invokeRestart(restart)
[18:01:57.187]                             muffled <- TRUE
[18:01:57.187]                             break
[18:01:57.187]                           }
[18:01:57.187]                         }
[18:01:57.187]                       }
[18:01:57.187]                       invisible(muffled)
[18:01:57.187]                     }
[18:01:57.187]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.187]                   }
[18:01:57.187]                 }
[18:01:57.187]                 else {
[18:01:57.187]                   if (TRUE) {
[18:01:57.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.187]                     {
[18:01:57.187]                       inherits <- base::inherits
[18:01:57.187]                       invokeRestart <- base::invokeRestart
[18:01:57.187]                       is.null <- base::is.null
[18:01:57.187]                       muffled <- FALSE
[18:01:57.187]                       if (inherits(cond, "message")) {
[18:01:57.187]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.187]                         if (muffled) 
[18:01:57.187]                           invokeRestart("muffleMessage")
[18:01:57.187]                       }
[18:01:57.187]                       else if (inherits(cond, "warning")) {
[18:01:57.187]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.187]                         if (muffled) 
[18:01:57.187]                           invokeRestart("muffleWarning")
[18:01:57.187]                       }
[18:01:57.187]                       else if (inherits(cond, "condition")) {
[18:01:57.187]                         if (!is.null(pattern)) {
[18:01:57.187]                           computeRestarts <- base::computeRestarts
[18:01:57.187]                           grepl <- base::grepl
[18:01:57.187]                           restarts <- computeRestarts(cond)
[18:01:57.187]                           for (restart in restarts) {
[18:01:57.187]                             name <- restart$name
[18:01:57.187]                             if (is.null(name)) 
[18:01:57.187]                               next
[18:01:57.187]                             if (!grepl(pattern, name)) 
[18:01:57.187]                               next
[18:01:57.187]                             invokeRestart(restart)
[18:01:57.187]                             muffled <- TRUE
[18:01:57.187]                             break
[18:01:57.187]                           }
[18:01:57.187]                         }
[18:01:57.187]                       }
[18:01:57.187]                       invisible(muffled)
[18:01:57.187]                     }
[18:01:57.187]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.187]                   }
[18:01:57.187]                 }
[18:01:57.187]             }
[18:01:57.187]         }))
[18:01:57.187]     }, error = function(ex) {
[18:01:57.187]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:57.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.187]                 ...future.rng), started = ...future.startTime, 
[18:01:57.187]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:57.187]             version = "1.8"), class = "FutureResult")
[18:01:57.187]     }, finally = {
[18:01:57.187]         if (!identical(...future.workdir, getwd())) 
[18:01:57.187]             setwd(...future.workdir)
[18:01:57.187]         {
[18:01:57.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:57.187]                 ...future.oldOptions$nwarnings <- NULL
[18:01:57.187]             }
[18:01:57.187]             base::options(...future.oldOptions)
[18:01:57.187]             if (.Platform$OS.type == "windows") {
[18:01:57.187]                 old_names <- names(...future.oldEnvVars)
[18:01:57.187]                 envs <- base::Sys.getenv()
[18:01:57.187]                 names <- names(envs)
[18:01:57.187]                 common <- intersect(names, old_names)
[18:01:57.187]                 added <- setdiff(names, old_names)
[18:01:57.187]                 removed <- setdiff(old_names, names)
[18:01:57.187]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:57.187]                   envs[common]]
[18:01:57.187]                 NAMES <- toupper(changed)
[18:01:57.187]                 args <- list()
[18:01:57.187]                 for (kk in seq_along(NAMES)) {
[18:01:57.187]                   name <- changed[[kk]]
[18:01:57.187]                   NAME <- NAMES[[kk]]
[18:01:57.187]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.187]                     next
[18:01:57.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.187]                 }
[18:01:57.187]                 NAMES <- toupper(added)
[18:01:57.187]                 for (kk in seq_along(NAMES)) {
[18:01:57.187]                   name <- added[[kk]]
[18:01:57.187]                   NAME <- NAMES[[kk]]
[18:01:57.187]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.187]                     next
[18:01:57.187]                   args[[name]] <- ""
[18:01:57.187]                 }
[18:01:57.187]                 NAMES <- toupper(removed)
[18:01:57.187]                 for (kk in seq_along(NAMES)) {
[18:01:57.187]                   name <- removed[[kk]]
[18:01:57.187]                   NAME <- NAMES[[kk]]
[18:01:57.187]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.187]                     next
[18:01:57.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.187]                 }
[18:01:57.187]                 if (length(args) > 0) 
[18:01:57.187]                   base::do.call(base::Sys.setenv, args = args)
[18:01:57.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:57.187]             }
[18:01:57.187]             else {
[18:01:57.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:57.187]             }
[18:01:57.187]             {
[18:01:57.187]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:57.187]                   0L) {
[18:01:57.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:57.187]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:57.187]                   base::options(opts)
[18:01:57.187]                 }
[18:01:57.187]                 {
[18:01:57.187]                   {
[18:01:57.187]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:57.187]                     NULL
[18:01:57.187]                   }
[18:01:57.187]                   options(future.plan = NULL)
[18:01:57.187]                   if (is.na(NA_character_)) 
[18:01:57.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:57.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:57.187]                     .init = FALSE)
[18:01:57.187]                 }
[18:01:57.187]             }
[18:01:57.187]         }
[18:01:57.187]     })
[18:01:57.187]     if (TRUE) {
[18:01:57.187]         base::sink(type = "output", split = FALSE)
[18:01:57.187]         if (TRUE) {
[18:01:57.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:57.187]         }
[18:01:57.187]         else {
[18:01:57.187]             ...future.result["stdout"] <- base::list(NULL)
[18:01:57.187]         }
[18:01:57.187]         base::close(...future.stdout)
[18:01:57.187]         ...future.stdout <- NULL
[18:01:57.187]     }
[18:01:57.187]     ...future.result$conditions <- ...future.conditions
[18:01:57.187]     ...future.result$finished <- base::Sys.time()
[18:01:57.187]     ...future.result
[18:01:57.187] }
[18:01:57.194] assign_globals() ...
[18:01:57.194] List of 11
[18:01:57.194]  $ ...future.FUN            :function (x, ...)  
[18:01:57.194]  $ x_FUN                    :function (x)  
[18:01:57.194]  $ times                    : int 1
[18:01:57.194]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:57.194]  $ stop_if_not              :function (...)  
[18:01:57.194]  $ dim                      : NULL
[18:01:57.194]  $ valid_types              : chr "character"
[18:01:57.194]  $ future.call.arguments    : list()
[18:01:57.194]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.194]  $ ...future.elements_ii    :List of 1
[18:01:57.194]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[18:01:57.194]  $ ...future.seeds_ii       : NULL
[18:01:57.194]  $ ...future.globals.maxSize: NULL
[18:01:57.194]  - attr(*, "where")=List of 11
[18:01:57.194]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:57.194]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:57.194]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:57.194]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:57.194]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:57.194]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:57.194]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:57.194]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:57.194]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:57.194]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:57.194]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:57.194]  - attr(*, "resolved")= logi FALSE
[18:01:57.194]  - attr(*, "total_size")= num 94208
[18:01:57.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.194]  - attr(*, "already-done")= logi TRUE
[18:01:57.223] - copied ‘...future.FUN’ to environment
[18:01:57.223] - copied ‘x_FUN’ to environment
[18:01:57.223] - copied ‘times’ to environment
[18:01:57.223] - copied ‘stopf’ to environment
[18:01:57.224] - copied ‘stop_if_not’ to environment
[18:01:57.224] - copied ‘dim’ to environment
[18:01:57.225] - copied ‘valid_types’ to environment
[18:01:57.225] - copied ‘future.call.arguments’ to environment
[18:01:57.225] - copied ‘...future.elements_ii’ to environment
[18:01:57.225] - copied ‘...future.seeds_ii’ to environment
[18:01:57.226] - copied ‘...future.globals.maxSize’ to environment
[18:01:57.226] assign_globals() ... done
[18:01:57.226] requestCore(): workers = 2
[18:01:57.236] MulticoreFuture started
[18:01:57.237] - Launch lazy future ... done
[18:01:57.237] run() for ‘MulticoreFuture’ ... done
[18:01:57.238] Created future:
[18:01:57.239] plan(): Setting new future strategy stack:
[18:01:57.239] List of future strategies:
[18:01:57.239] 1. sequential:
[18:01:57.239]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:57.239]    - tweaked: FALSE
[18:01:57.239]    - call: NULL
[18:01:57.241] plan(): nbrOfWorkers() = 1
[18:01:57.245] plan(): Setting new future strategy stack:
[18:01:57.246] List of future strategies:
[18:01:57.246] 1. multicore:
[18:01:57.246]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:57.246]    - tweaked: FALSE
[18:01:57.246]    - call: plan(strategy)
[18:01:57.238] MulticoreFuture:
[18:01:57.238] Label: ‘future_vapply-2’
[18:01:57.238] Expression:
[18:01:57.238] {
[18:01:57.238]     do.call(function(...) {
[18:01:57.238]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.238]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.238]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.238]             on.exit(options(oopts), add = TRUE)
[18:01:57.238]         }
[18:01:57.238]         {
[18:01:57.238]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.238]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.238]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.238]             })
[18:01:57.238]         }
[18:01:57.238]     }, args = future.call.arguments)
[18:01:57.238] }
[18:01:57.238] Lazy evaluation: FALSE
[18:01:57.238] Asynchronous evaluation: TRUE
[18:01:57.238] Local evaluation: TRUE
[18:01:57.238] Environment: R_GlobalEnv
[18:01:57.238] Capture standard output: TRUE
[18:01:57.238] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:57.238] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:57.238] Packages: 1 packages (‘future.apply’)
[18:01:57.238] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:57.238] Resolved: FALSE
[18:01:57.238] Value: <not collected>
[18:01:57.238] Conditions captured: <none>
[18:01:57.238] Early signaling: FALSE
[18:01:57.238] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:57.238] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.254] Chunk #2 of 2 ... DONE
[18:01:57.254] Launching 2 futures (chunks) ... DONE
[18:01:57.255] Resolving 2 futures (chunks) ...
[18:01:57.255] resolve() on list ...
[18:01:57.255]  recursive: 0
[18:01:57.255] plan(): nbrOfWorkers() = 2
[18:01:57.256]  length: 2
[18:01:57.256] 
[18:01:57.257] Future #1
[18:01:57.258] result() for MulticoreFuture ...
[18:01:57.261] result() for MulticoreFuture ...
[18:01:57.261] result() for MulticoreFuture ... done
[18:01:57.262] result() for MulticoreFuture ... done
[18:01:57.262] result() for MulticoreFuture ...
[18:01:57.262] result() for MulticoreFuture ... done
[18:01:57.263] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:57.263] - nx: 2
[18:01:57.263] - relay: TRUE
[18:01:57.264] - stdout: TRUE
[18:01:57.264] - signal: TRUE
[18:01:57.264] - resignal: FALSE
[18:01:57.265] - force: TRUE
[18:01:57.265] - relayed: [n=2] FALSE, FALSE
[18:01:57.265] - queued futures: [n=2] FALSE, FALSE
[18:01:57.266]  - until=1
[18:01:57.266]  - relaying element #1
[18:01:57.266] result() for MulticoreFuture ...
[18:01:57.267] result() for MulticoreFuture ... done
[18:01:57.267] result() for MulticoreFuture ...
[18:01:57.267] result() for MulticoreFuture ... done
[18:01:57.268] result() for MulticoreFuture ...
[18:01:57.268] result() for MulticoreFuture ... done
[18:01:57.268] result() for MulticoreFuture ...
[18:01:57.269] result() for MulticoreFuture ... done
[18:01:57.269] - relayed: [n=2] TRUE, FALSE
[18:01:57.269] - queued futures: [n=2] TRUE, FALSE
[18:01:57.270] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:57.270]  length: 1 (resolved future 1)
[18:01:57.271] Future #2
[18:01:57.271] result() for MulticoreFuture ...
[18:01:57.272] result() for MulticoreFuture ...
[18:01:57.273] result() for MulticoreFuture ... done
[18:01:57.273] result() for MulticoreFuture ... done
[18:01:57.273] result() for MulticoreFuture ...
[18:01:57.274] result() for MulticoreFuture ... done
[18:01:57.274] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:57.274] - nx: 2
[18:01:57.274] - relay: TRUE
[18:01:57.275] - stdout: TRUE
[18:01:57.275] - signal: TRUE
[18:01:57.275] - resignal: FALSE
[18:01:57.275] - force: TRUE
[18:01:57.276] - relayed: [n=2] TRUE, FALSE
[18:01:57.276] - queued futures: [n=2] TRUE, FALSE
[18:01:57.276]  - until=2
[18:01:57.276]  - relaying element #2
[18:01:57.276] result() for MulticoreFuture ...
[18:01:57.277] result() for MulticoreFuture ... done
[18:01:57.277] result() for MulticoreFuture ...
[18:01:57.277] result() for MulticoreFuture ... done
[18:01:57.277] result() for MulticoreFuture ...
[18:01:57.278] result() for MulticoreFuture ... done
[18:01:57.278] result() for MulticoreFuture ...
[18:01:57.278] result() for MulticoreFuture ... done
[18:01:57.278] - relayed: [n=2] TRUE, TRUE
[18:01:57.279] - queued futures: [n=2] TRUE, TRUE
[18:01:57.279] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:57.279]  length: 0 (resolved future 2)
[18:01:57.279] Relaying remaining futures
[18:01:57.280] signalConditionsASAP(NULL, pos=0) ...
[18:01:57.280] - nx: 2
[18:01:57.280] - relay: TRUE
[18:01:57.280] - stdout: TRUE
[18:01:57.280] - signal: TRUE
[18:01:57.281] - resignal: FALSE
[18:01:57.281] - force: TRUE
[18:01:57.281] - relayed: [n=2] TRUE, TRUE
[18:01:57.281] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:57.282] - relayed: [n=2] TRUE, TRUE
[18:01:57.282] - queued futures: [n=2] TRUE, TRUE
[18:01:57.282] signalConditionsASAP(NULL, pos=0) ... done
[18:01:57.282] resolve() on list ... DONE
[18:01:57.282] result() for MulticoreFuture ...
[18:01:57.283] result() for MulticoreFuture ... done
[18:01:57.283] result() for MulticoreFuture ...
[18:01:57.283] result() for MulticoreFuture ... done
[18:01:57.283] result() for MulticoreFuture ...
[18:01:57.284] result() for MulticoreFuture ... done
[18:01:57.284] result() for MulticoreFuture ...
[18:01:57.284] result() for MulticoreFuture ... done
[18:01:57.284]  - Number of value chunks collected: 2
[18:01:57.284] Resolving 2 futures (chunks) ... DONE
[18:01:57.285] Reducing values from 2 chunks ...
[18:01:57.285]  - Number of values collected after concatenation: 2
[18:01:57.285]  - Number of values expected: 2
[18:01:57.285] Reducing values from 2 chunks ... DONE
[18:01:57.286] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[18:01:57.288] future_lapply() ...
[18:01:57.307] Number of chunks: 2
[18:01:57.307] getGlobalsAndPackagesXApply() ...
[18:01:57.308]  - future.globals: TRUE
[18:01:57.308] getGlobalsAndPackages() ...
[18:01:57.308] Searching for globals...
[18:01:57.317] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[18:01:57.317] Searching for globals ... DONE
[18:01:57.317] Resolving globals: FALSE
[18:01:57.319] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[18:01:57.320] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:57.320] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:57.321] - packages: [1] ‘future.apply’
[18:01:57.321] getGlobalsAndPackages() ... DONE
[18:01:57.321]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:57.321]  - needed namespaces: [n=1] ‘future.apply’
[18:01:57.321] Finding globals ... DONE
[18:01:57.322]  - use_args: TRUE
[18:01:57.322]  - Getting '...' globals ...
[18:01:57.322] resolve() on list ...
[18:01:57.323]  recursive: 0
[18:01:57.323]  length: 1
[18:01:57.323]  elements: ‘...’
[18:01:57.323]  length: 0 (resolved future 1)
[18:01:57.324] resolve() on list ... DONE
[18:01:57.324]    - '...' content: [n=0] 
[18:01:57.324] List of 1
[18:01:57.324]  $ ...: list()
[18:01:57.324]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.324]  - attr(*, "where")=List of 1
[18:01:57.324]   ..$ ...:<environment: 0x6183c0d24cb8> 
[18:01:57.324]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.324]  - attr(*, "resolved")= logi TRUE
[18:01:57.324]  - attr(*, "total_size")= num NA
[18:01:57.329]  - Getting '...' globals ... DONE
[18:01:57.329] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:57.330] List of 8
[18:01:57.330]  $ ...future.FUN:function (x, ...)  
[18:01:57.330]  $ x_FUN        :function (x)  
[18:01:57.330]  $ times        : int 0
[18:01:57.330]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:57.330]  $ stop_if_not  :function (...)  
[18:01:57.330]  $ dim          : NULL
[18:01:57.330]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:57.330]  $ ...          : list()
[18:01:57.330]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.330]  - attr(*, "where")=List of 8
[18:01:57.330]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:57.330]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:57.330]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:57.330]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:57.330]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:57.330]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:57.330]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:57.330]   ..$ ...          :<environment: 0x6183c0d24cb8> 
[18:01:57.330]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.330]  - attr(*, "resolved")= logi FALSE
[18:01:57.330]  - attr(*, "total_size")= num 95472
[18:01:57.341] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:57.342] getGlobalsAndPackagesXApply() ... DONE
[18:01:57.342] Number of futures (= number of chunks): 2
[18:01:57.342] Launching 2 futures (chunks) ...
[18:01:57.343] Chunk #1 of 2 ...
[18:01:57.343]  - Finding globals in 'X' for chunk #1 ...
[18:01:57.343] getGlobalsAndPackages() ...
[18:01:57.343] Searching for globals...
[18:01:57.344] 
[18:01:57.344] Searching for globals ... DONE
[18:01:57.344] - globals: [0] <none>
[18:01:57.344] getGlobalsAndPackages() ... DONE
[18:01:57.345]    + additional globals found: [n=0] 
[18:01:57.345]    + additional namespaces needed: [n=0] 
[18:01:57.345]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:57.345]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:57.345]  - seeds: <none>
[18:01:57.346]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.346] getGlobalsAndPackages() ...
[18:01:57.346] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.346] Resolving globals: FALSE
[18:01:57.346] Tweak future expression to call with '...' arguments ...
[18:01:57.347] {
[18:01:57.347]     do.call(function(...) {
[18:01:57.347]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.347]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.347]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.347]             on.exit(options(oopts), add = TRUE)
[18:01:57.347]         }
[18:01:57.347]         {
[18:01:57.347]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.347]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.347]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.347]             })
[18:01:57.347]         }
[18:01:57.347]     }, args = future.call.arguments)
[18:01:57.347] }
[18:01:57.347] Tweak future expression to call with '...' arguments ... DONE
[18:01:57.348] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.349] - packages: [1] ‘future.apply’
[18:01:57.349] getGlobalsAndPackages() ... DONE
[18:01:57.350] run() for ‘Future’ ...
[18:01:57.352] - state: ‘created’
[18:01:57.353] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:57.359] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.359] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:57.360]   - Field: ‘label’
[18:01:57.360]   - Field: ‘local’
[18:01:57.360]   - Field: ‘owner’
[18:01:57.360]   - Field: ‘envir’
[18:01:57.360]   - Field: ‘workers’
[18:01:57.361]   - Field: ‘packages’
[18:01:57.361]   - Field: ‘gc’
[18:01:57.361]   - Field: ‘job’
[18:01:57.361]   - Field: ‘conditions’
[18:01:57.362]   - Field: ‘expr’
[18:01:57.362]   - Field: ‘uuid’
[18:01:57.362]   - Field: ‘seed’
[18:01:57.362]   - Field: ‘version’
[18:01:57.362]   - Field: ‘result’
[18:01:57.363]   - Field: ‘asynchronous’
[18:01:57.363]   - Field: ‘calls’
[18:01:57.363]   - Field: ‘globals’
[18:01:57.363]   - Field: ‘stdout’
[18:01:57.363]   - Field: ‘earlySignal’
[18:01:57.364]   - Field: ‘lazy’
[18:01:57.364]   - Field: ‘state’
[18:01:57.364] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:57.364] - Launch lazy future ...
[18:01:57.365] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:57.365] Packages needed by future strategies (n = 0): <none>
[18:01:57.366] {
[18:01:57.366]     {
[18:01:57.366]         {
[18:01:57.366]             ...future.startTime <- base::Sys.time()
[18:01:57.366]             {
[18:01:57.366]                 {
[18:01:57.366]                   {
[18:01:57.366]                     {
[18:01:57.366]                       {
[18:01:57.366]                         base::local({
[18:01:57.366]                           has_future <- base::requireNamespace("future", 
[18:01:57.366]                             quietly = TRUE)
[18:01:57.366]                           if (has_future) {
[18:01:57.366]                             ns <- base::getNamespace("future")
[18:01:57.366]                             version <- ns[[".package"]][["version"]]
[18:01:57.366]                             if (is.null(version)) 
[18:01:57.366]                               version <- utils::packageVersion("future")
[18:01:57.366]                           }
[18:01:57.366]                           else {
[18:01:57.366]                             version <- NULL
[18:01:57.366]                           }
[18:01:57.366]                           if (!has_future || version < "1.8.0") {
[18:01:57.366]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:57.366]                               "", base::R.version$version.string), 
[18:01:57.366]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:57.366]                                 base::R.version$platform, 8 * 
[18:01:57.366]                                   base::.Machine$sizeof.pointer), 
[18:01:57.366]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:57.366]                                 "release", "version")], collapse = " "), 
[18:01:57.366]                               hostname = base::Sys.info()[["nodename"]])
[18:01:57.366]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:57.366]                               info)
[18:01:57.366]                             info <- base::paste(info, collapse = "; ")
[18:01:57.366]                             if (!has_future) {
[18:01:57.366]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:57.366]                                 info)
[18:01:57.366]                             }
[18:01:57.366]                             else {
[18:01:57.366]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:57.366]                                 info, version)
[18:01:57.366]                             }
[18:01:57.366]                             base::stop(msg)
[18:01:57.366]                           }
[18:01:57.366]                         })
[18:01:57.366]                       }
[18:01:57.366]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:57.366]                       base::options(mc.cores = 1L)
[18:01:57.366]                     }
[18:01:57.366]                     base::local({
[18:01:57.366]                       for (pkg in "future.apply") {
[18:01:57.366]                         base::loadNamespace(pkg)
[18:01:57.366]                         base::library(pkg, character.only = TRUE)
[18:01:57.366]                       }
[18:01:57.366]                     })
[18:01:57.366]                   }
[18:01:57.366]                   ...future.strategy.old <- future::plan("list")
[18:01:57.366]                   options(future.plan = NULL)
[18:01:57.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:57.366]                 }
[18:01:57.366]                 ...future.workdir <- getwd()
[18:01:57.366]             }
[18:01:57.366]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:57.366]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:57.366]         }
[18:01:57.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:57.366]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:57.366]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:57.366]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:57.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:57.366]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:57.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:57.366]             base::names(...future.oldOptions))
[18:01:57.366]     }
[18:01:57.366]     if (FALSE) {
[18:01:57.366]     }
[18:01:57.366]     else {
[18:01:57.366]         if (TRUE) {
[18:01:57.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:57.366]                 open = "w")
[18:01:57.366]         }
[18:01:57.366]         else {
[18:01:57.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:57.366]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:57.366]         }
[18:01:57.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:57.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:57.366]             base::sink(type = "output", split = FALSE)
[18:01:57.366]             base::close(...future.stdout)
[18:01:57.366]         }, add = TRUE)
[18:01:57.366]     }
[18:01:57.366]     ...future.frame <- base::sys.nframe()
[18:01:57.366]     ...future.conditions <- base::list()
[18:01:57.366]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:57.366]     if (FALSE) {
[18:01:57.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:57.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:57.366]     }
[18:01:57.366]     ...future.result <- base::tryCatch({
[18:01:57.366]         base::withCallingHandlers({
[18:01:57.366]             ...future.value <- base::withVisible(base::local({
[18:01:57.366]                 withCallingHandlers({
[18:01:57.366]                   {
[18:01:57.366]                     do.call(function(...) {
[18:01:57.366]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.366]                       if (!identical(...future.globals.maxSize.org, 
[18:01:57.366]                         ...future.globals.maxSize)) {
[18:01:57.366]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.366]                         on.exit(options(oopts), add = TRUE)
[18:01:57.366]                       }
[18:01:57.366]                       {
[18:01:57.366]                         lapply(seq_along(...future.elements_ii), 
[18:01:57.366]                           FUN = function(jj) {
[18:01:57.366]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.366]                             ...future.FUN(...future.X_jj, ...)
[18:01:57.366]                           })
[18:01:57.366]                       }
[18:01:57.366]                     }, args = future.call.arguments)
[18:01:57.366]                   }
[18:01:57.366]                 }, immediateCondition = function(cond) {
[18:01:57.366]                   save_rds <- function (object, pathname, ...) 
[18:01:57.366]                   {
[18:01:57.366]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:57.366]                     if (file_test("-f", pathname_tmp)) {
[18:01:57.366]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.366]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:57.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.366]                         fi_tmp[["mtime"]])
[18:01:57.366]                     }
[18:01:57.366]                     tryCatch({
[18:01:57.366]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:57.366]                     }, error = function(ex) {
[18:01:57.366]                       msg <- conditionMessage(ex)
[18:01:57.366]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.366]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:57.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.366]                         fi_tmp[["mtime"]], msg)
[18:01:57.366]                       ex$message <- msg
[18:01:57.366]                       stop(ex)
[18:01:57.366]                     })
[18:01:57.366]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:57.366]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:57.366]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:57.366]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.366]                       fi <- file.info(pathname)
[18:01:57.366]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:57.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.366]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:57.366]                         fi[["size"]], fi[["mtime"]])
[18:01:57.366]                       stop(msg)
[18:01:57.366]                     }
[18:01:57.366]                     invisible(pathname)
[18:01:57.366]                   }
[18:01:57.366]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:57.366]                     rootPath = tempdir()) 
[18:01:57.366]                   {
[18:01:57.366]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:57.366]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:57.366]                       tmpdir = path, fileext = ".rds")
[18:01:57.366]                     save_rds(obj, file)
[18:01:57.366]                   }
[18:01:57.366]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:57.366]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.366]                   {
[18:01:57.366]                     inherits <- base::inherits
[18:01:57.366]                     invokeRestart <- base::invokeRestart
[18:01:57.366]                     is.null <- base::is.null
[18:01:57.366]                     muffled <- FALSE
[18:01:57.366]                     if (inherits(cond, "message")) {
[18:01:57.366]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:57.366]                       if (muffled) 
[18:01:57.366]                         invokeRestart("muffleMessage")
[18:01:57.366]                     }
[18:01:57.366]                     else if (inherits(cond, "warning")) {
[18:01:57.366]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:57.366]                       if (muffled) 
[18:01:57.366]                         invokeRestart("muffleWarning")
[18:01:57.366]                     }
[18:01:57.366]                     else if (inherits(cond, "condition")) {
[18:01:57.366]                       if (!is.null(pattern)) {
[18:01:57.366]                         computeRestarts <- base::computeRestarts
[18:01:57.366]                         grepl <- base::grepl
[18:01:57.366]                         restarts <- computeRestarts(cond)
[18:01:57.366]                         for (restart in restarts) {
[18:01:57.366]                           name <- restart$name
[18:01:57.366]                           if (is.null(name)) 
[18:01:57.366]                             next
[18:01:57.366]                           if (!grepl(pattern, name)) 
[18:01:57.366]                             next
[18:01:57.366]                           invokeRestart(restart)
[18:01:57.366]                           muffled <- TRUE
[18:01:57.366]                           break
[18:01:57.366]                         }
[18:01:57.366]                       }
[18:01:57.366]                     }
[18:01:57.366]                     invisible(muffled)
[18:01:57.366]                   }
[18:01:57.366]                   muffleCondition(cond)
[18:01:57.366]                 })
[18:01:57.366]             }))
[18:01:57.366]             future::FutureResult(value = ...future.value$value, 
[18:01:57.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.366]                   ...future.rng), globalenv = if (FALSE) 
[18:01:57.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:57.366]                     ...future.globalenv.names))
[18:01:57.366]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:57.366]         }, condition = base::local({
[18:01:57.366]             c <- base::c
[18:01:57.366]             inherits <- base::inherits
[18:01:57.366]             invokeRestart <- base::invokeRestart
[18:01:57.366]             length <- base::length
[18:01:57.366]             list <- base::list
[18:01:57.366]             seq.int <- base::seq.int
[18:01:57.366]             signalCondition <- base::signalCondition
[18:01:57.366]             sys.calls <- base::sys.calls
[18:01:57.366]             `[[` <- base::`[[`
[18:01:57.366]             `+` <- base::`+`
[18:01:57.366]             `<<-` <- base::`<<-`
[18:01:57.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:57.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:57.366]                   3L)]
[18:01:57.366]             }
[18:01:57.366]             function(cond) {
[18:01:57.366]                 is_error <- inherits(cond, "error")
[18:01:57.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:57.366]                   NULL)
[18:01:57.366]                 if (is_error) {
[18:01:57.366]                   sessionInformation <- function() {
[18:01:57.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:57.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:57.366]                       search = base::search(), system = base::Sys.info())
[18:01:57.366]                   }
[18:01:57.366]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:57.366]                     cond$call), session = sessionInformation(), 
[18:01:57.366]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:57.366]                   signalCondition(cond)
[18:01:57.366]                 }
[18:01:57.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:57.366]                 "immediateCondition"))) {
[18:01:57.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:57.366]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:57.366]                   if (TRUE && !signal) {
[18:01:57.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.366]                     {
[18:01:57.366]                       inherits <- base::inherits
[18:01:57.366]                       invokeRestart <- base::invokeRestart
[18:01:57.366]                       is.null <- base::is.null
[18:01:57.366]                       muffled <- FALSE
[18:01:57.366]                       if (inherits(cond, "message")) {
[18:01:57.366]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.366]                         if (muffled) 
[18:01:57.366]                           invokeRestart("muffleMessage")
[18:01:57.366]                       }
[18:01:57.366]                       else if (inherits(cond, "warning")) {
[18:01:57.366]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.366]                         if (muffled) 
[18:01:57.366]                           invokeRestart("muffleWarning")
[18:01:57.366]                       }
[18:01:57.366]                       else if (inherits(cond, "condition")) {
[18:01:57.366]                         if (!is.null(pattern)) {
[18:01:57.366]                           computeRestarts <- base::computeRestarts
[18:01:57.366]                           grepl <- base::grepl
[18:01:57.366]                           restarts <- computeRestarts(cond)
[18:01:57.366]                           for (restart in restarts) {
[18:01:57.366]                             name <- restart$name
[18:01:57.366]                             if (is.null(name)) 
[18:01:57.366]                               next
[18:01:57.366]                             if (!grepl(pattern, name)) 
[18:01:57.366]                               next
[18:01:57.366]                             invokeRestart(restart)
[18:01:57.366]                             muffled <- TRUE
[18:01:57.366]                             break
[18:01:57.366]                           }
[18:01:57.366]                         }
[18:01:57.366]                       }
[18:01:57.366]                       invisible(muffled)
[18:01:57.366]                     }
[18:01:57.366]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.366]                   }
[18:01:57.366]                 }
[18:01:57.366]                 else {
[18:01:57.366]                   if (TRUE) {
[18:01:57.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.366]                     {
[18:01:57.366]                       inherits <- base::inherits
[18:01:57.366]                       invokeRestart <- base::invokeRestart
[18:01:57.366]                       is.null <- base::is.null
[18:01:57.366]                       muffled <- FALSE
[18:01:57.366]                       if (inherits(cond, "message")) {
[18:01:57.366]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.366]                         if (muffled) 
[18:01:57.366]                           invokeRestart("muffleMessage")
[18:01:57.366]                       }
[18:01:57.366]                       else if (inherits(cond, "warning")) {
[18:01:57.366]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.366]                         if (muffled) 
[18:01:57.366]                           invokeRestart("muffleWarning")
[18:01:57.366]                       }
[18:01:57.366]                       else if (inherits(cond, "condition")) {
[18:01:57.366]                         if (!is.null(pattern)) {
[18:01:57.366]                           computeRestarts <- base::computeRestarts
[18:01:57.366]                           grepl <- base::grepl
[18:01:57.366]                           restarts <- computeRestarts(cond)
[18:01:57.366]                           for (restart in restarts) {
[18:01:57.366]                             name <- restart$name
[18:01:57.366]                             if (is.null(name)) 
[18:01:57.366]                               next
[18:01:57.366]                             if (!grepl(pattern, name)) 
[18:01:57.366]                               next
[18:01:57.366]                             invokeRestart(restart)
[18:01:57.366]                             muffled <- TRUE
[18:01:57.366]                             break
[18:01:57.366]                           }
[18:01:57.366]                         }
[18:01:57.366]                       }
[18:01:57.366]                       invisible(muffled)
[18:01:57.366]                     }
[18:01:57.366]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.366]                   }
[18:01:57.366]                 }
[18:01:57.366]             }
[18:01:57.366]         }))
[18:01:57.366]     }, error = function(ex) {
[18:01:57.366]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:57.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.366]                 ...future.rng), started = ...future.startTime, 
[18:01:57.366]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:57.366]             version = "1.8"), class = "FutureResult")
[18:01:57.366]     }, finally = {
[18:01:57.366]         if (!identical(...future.workdir, getwd())) 
[18:01:57.366]             setwd(...future.workdir)
[18:01:57.366]         {
[18:01:57.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:57.366]                 ...future.oldOptions$nwarnings <- NULL
[18:01:57.366]             }
[18:01:57.366]             base::options(...future.oldOptions)
[18:01:57.366]             if (.Platform$OS.type == "windows") {
[18:01:57.366]                 old_names <- names(...future.oldEnvVars)
[18:01:57.366]                 envs <- base::Sys.getenv()
[18:01:57.366]                 names <- names(envs)
[18:01:57.366]                 common <- intersect(names, old_names)
[18:01:57.366]                 added <- setdiff(names, old_names)
[18:01:57.366]                 removed <- setdiff(old_names, names)
[18:01:57.366]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:57.366]                   envs[common]]
[18:01:57.366]                 NAMES <- toupper(changed)
[18:01:57.366]                 args <- list()
[18:01:57.366]                 for (kk in seq_along(NAMES)) {
[18:01:57.366]                   name <- changed[[kk]]
[18:01:57.366]                   NAME <- NAMES[[kk]]
[18:01:57.366]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.366]                     next
[18:01:57.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.366]                 }
[18:01:57.366]                 NAMES <- toupper(added)
[18:01:57.366]                 for (kk in seq_along(NAMES)) {
[18:01:57.366]                   name <- added[[kk]]
[18:01:57.366]                   NAME <- NAMES[[kk]]
[18:01:57.366]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.366]                     next
[18:01:57.366]                   args[[name]] <- ""
[18:01:57.366]                 }
[18:01:57.366]                 NAMES <- toupper(removed)
[18:01:57.366]                 for (kk in seq_along(NAMES)) {
[18:01:57.366]                   name <- removed[[kk]]
[18:01:57.366]                   NAME <- NAMES[[kk]]
[18:01:57.366]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.366]                     next
[18:01:57.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.366]                 }
[18:01:57.366]                 if (length(args) > 0) 
[18:01:57.366]                   base::do.call(base::Sys.setenv, args = args)
[18:01:57.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:57.366]             }
[18:01:57.366]             else {
[18:01:57.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:57.366]             }
[18:01:57.366]             {
[18:01:57.366]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:57.366]                   0L) {
[18:01:57.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:57.366]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:57.366]                   base::options(opts)
[18:01:57.366]                 }
[18:01:57.366]                 {
[18:01:57.366]                   {
[18:01:57.366]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:57.366]                     NULL
[18:01:57.366]                   }
[18:01:57.366]                   options(future.plan = NULL)
[18:01:57.366]                   if (is.na(NA_character_)) 
[18:01:57.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:57.366]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:57.366]                     .init = FALSE)
[18:01:57.366]                 }
[18:01:57.366]             }
[18:01:57.366]         }
[18:01:57.366]     })
[18:01:57.366]     if (TRUE) {
[18:01:57.366]         base::sink(type = "output", split = FALSE)
[18:01:57.366]         if (TRUE) {
[18:01:57.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:57.366]         }
[18:01:57.366]         else {
[18:01:57.366]             ...future.result["stdout"] <- base::list(NULL)
[18:01:57.366]         }
[18:01:57.366]         base::close(...future.stdout)
[18:01:57.366]         ...future.stdout <- NULL
[18:01:57.366]     }
[18:01:57.366]     ...future.result$conditions <- ...future.conditions
[18:01:57.366]     ...future.result$finished <- base::Sys.time()
[18:01:57.366]     ...future.result
[18:01:57.366] }
[18:01:57.371] assign_globals() ...
[18:01:57.371] List of 11
[18:01:57.371]  $ ...future.FUN            :function (x, ...)  
[18:01:57.371]  $ x_FUN                    :function (x)  
[18:01:57.371]  $ times                    : int 0
[18:01:57.371]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:57.371]  $ stop_if_not              :function (...)  
[18:01:57.371]  $ dim                      : NULL
[18:01:57.371]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:57.371]  $ future.call.arguments    : list()
[18:01:57.371]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.371]  $ ...future.elements_ii    :List of 5
[18:01:57.371]   ..$ : int 1
[18:01:57.371]   ..$ : int 2
[18:01:57.371]   ..$ : int 3
[18:01:57.371]   ..$ : int 4
[18:01:57.371]   ..$ : int 5
[18:01:57.371]  $ ...future.seeds_ii       : NULL
[18:01:57.371]  $ ...future.globals.maxSize: NULL
[18:01:57.371]  - attr(*, "where")=List of 11
[18:01:57.371]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:57.371]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:57.371]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:57.371]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:57.371]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:57.371]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:57.371]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:57.371]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:57.371]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:57.371]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:57.371]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:57.371]  - attr(*, "resolved")= logi FALSE
[18:01:57.371]  - attr(*, "total_size")= num 95472
[18:01:57.371]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.371]  - attr(*, "already-done")= logi TRUE
[18:01:57.389] - copied ‘...future.FUN’ to environment
[18:01:57.389] - reassign environment for ‘x_FUN’
[18:01:57.390] - copied ‘x_FUN’ to environment
[18:01:57.390] - copied ‘times’ to environment
[18:01:57.390] - copied ‘stopf’ to environment
[18:01:57.390] - copied ‘stop_if_not’ to environment
[18:01:57.390] - copied ‘dim’ to environment
[18:01:57.391] - copied ‘valid_types’ to environment
[18:01:57.391] - copied ‘future.call.arguments’ to environment
[18:01:57.391] - copied ‘...future.elements_ii’ to environment
[18:01:57.391] - copied ‘...future.seeds_ii’ to environment
[18:01:57.391] - copied ‘...future.globals.maxSize’ to environment
[18:01:57.392] assign_globals() ... done
[18:01:57.392] requestCore(): workers = 2
[18:01:57.395] MulticoreFuture started
[18:01:57.396] - Launch lazy future ... done
[18:01:57.397] run() for ‘MulticoreFuture’ ... done
[18:01:57.397] Created future:
[18:01:57.400] plan(): Setting new future strategy stack:
[18:01:57.401] List of future strategies:
[18:01:57.401] 1. sequential:
[18:01:57.401]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:57.401]    - tweaked: FALSE
[18:01:57.401]    - call: NULL
[18:01:57.403] plan(): nbrOfWorkers() = 1
[18:01:57.407] plan(): Setting new future strategy stack:
[18:01:57.407] List of future strategies:
[18:01:57.407] 1. multicore:
[18:01:57.407]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:57.407]    - tweaked: FALSE
[18:01:57.407]    - call: plan(strategy)
[18:01:57.417] plan(): nbrOfWorkers() = 2
[18:01:57.398] MulticoreFuture:
[18:01:57.398] Label: ‘future_vapply-1’
[18:01:57.398] Expression:
[18:01:57.398] {
[18:01:57.398]     do.call(function(...) {
[18:01:57.398]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.398]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.398]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.398]             on.exit(options(oopts), add = TRUE)
[18:01:57.398]         }
[18:01:57.398]         {
[18:01:57.398]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.398]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.398]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.398]             })
[18:01:57.398]         }
[18:01:57.398]     }, args = future.call.arguments)
[18:01:57.398] }
[18:01:57.398] Lazy evaluation: FALSE
[18:01:57.398] Asynchronous evaluation: TRUE
[18:01:57.398] Local evaluation: TRUE
[18:01:57.398] Environment: R_GlobalEnv
[18:01:57.398] Capture standard output: TRUE
[18:01:57.398] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:57.398] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:57.398] Packages: 1 packages (‘future.apply’)
[18:01:57.398] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:57.398] Resolved: FALSE
[18:01:57.398] Value: <not collected>
[18:01:57.398] Conditions captured: <none>
[18:01:57.398] Early signaling: FALSE
[18:01:57.398] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:57.398] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.418] Chunk #1 of 2 ... DONE
[18:01:57.418] Chunk #2 of 2 ...
[18:01:57.419]  - Finding globals in 'X' for chunk #2 ...
[18:01:57.419] getGlobalsAndPackages() ...
[18:01:57.419] Searching for globals...
[18:01:57.420] 
[18:01:57.421] Searching for globals ... DONE
[18:01:57.421] - globals: [0] <none>
[18:01:57.421] getGlobalsAndPackages() ... DONE
[18:01:57.422]    + additional globals found: [n=0] 
[18:01:57.422]    + additional namespaces needed: [n=0] 
[18:01:57.422]  - Finding globals in 'X' for chunk #2 ... DONE
[18:01:57.422]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:57.423]  - seeds: <none>
[18:01:57.423]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.423] getGlobalsAndPackages() ...
[18:01:57.424] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.424] Resolving globals: FALSE
[18:01:57.424] Tweak future expression to call with '...' arguments ...
[18:01:57.425] {
[18:01:57.425]     do.call(function(...) {
[18:01:57.425]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.425]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.425]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.425]             on.exit(options(oopts), add = TRUE)
[18:01:57.425]         }
[18:01:57.425]         {
[18:01:57.425]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.425]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.425]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.425]             })
[18:01:57.425]         }
[18:01:57.425]     }, args = future.call.arguments)
[18:01:57.425] }
[18:01:57.426] Tweak future expression to call with '...' arguments ... DONE
[18:01:57.428] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.428] - packages: [1] ‘future.apply’
[18:01:57.428] getGlobalsAndPackages() ... DONE
[18:01:57.429] run() for ‘Future’ ...
[18:01:57.430] - state: ‘created’
[18:01:57.430] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:57.445] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.446] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:57.447]   - Field: ‘label’
[18:01:57.447]   - Field: ‘local’
[18:01:57.448]   - Field: ‘owner’
[18:01:57.448]   - Field: ‘envir’
[18:01:57.449]   - Field: ‘workers’
[18:01:57.449]   - Field: ‘packages’
[18:01:57.450]   - Field: ‘gc’
[18:01:57.450]   - Field: ‘job’
[18:01:57.451]   - Field: ‘conditions’
[18:01:57.451]   - Field: ‘expr’
[18:01:57.452]   - Field: ‘uuid’
[18:01:57.452]   - Field: ‘seed’
[18:01:57.453]   - Field: ‘version’
[18:01:57.453]   - Field: ‘result’
[18:01:57.454]   - Field: ‘asynchronous’
[18:01:57.454]   - Field: ‘calls’
[18:01:57.455]   - Field: ‘globals’
[18:01:57.455]   - Field: ‘stdout’
[18:01:57.455]   - Field: ‘earlySignal’
[18:01:57.456]   - Field: ‘lazy’
[18:01:57.456]   - Field: ‘state’
[18:01:57.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:57.457] - Launch lazy future ...
[18:01:57.458] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:57.458] Packages needed by future strategies (n = 0): <none>
[18:01:57.460] {
[18:01:57.460]     {
[18:01:57.460]         {
[18:01:57.460]             ...future.startTime <- base::Sys.time()
[18:01:57.460]             {
[18:01:57.460]                 {
[18:01:57.460]                   {
[18:01:57.460]                     {
[18:01:57.460]                       {
[18:01:57.460]                         base::local({
[18:01:57.460]                           has_future <- base::requireNamespace("future", 
[18:01:57.460]                             quietly = TRUE)
[18:01:57.460]                           if (has_future) {
[18:01:57.460]                             ns <- base::getNamespace("future")
[18:01:57.460]                             version <- ns[[".package"]][["version"]]
[18:01:57.460]                             if (is.null(version)) 
[18:01:57.460]                               version <- utils::packageVersion("future")
[18:01:57.460]                           }
[18:01:57.460]                           else {
[18:01:57.460]                             version <- NULL
[18:01:57.460]                           }
[18:01:57.460]                           if (!has_future || version < "1.8.0") {
[18:01:57.460]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:57.460]                               "", base::R.version$version.string), 
[18:01:57.460]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:57.460]                                 base::R.version$platform, 8 * 
[18:01:57.460]                                   base::.Machine$sizeof.pointer), 
[18:01:57.460]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:57.460]                                 "release", "version")], collapse = " "), 
[18:01:57.460]                               hostname = base::Sys.info()[["nodename"]])
[18:01:57.460]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:57.460]                               info)
[18:01:57.460]                             info <- base::paste(info, collapse = "; ")
[18:01:57.460]                             if (!has_future) {
[18:01:57.460]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:57.460]                                 info)
[18:01:57.460]                             }
[18:01:57.460]                             else {
[18:01:57.460]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:57.460]                                 info, version)
[18:01:57.460]                             }
[18:01:57.460]                             base::stop(msg)
[18:01:57.460]                           }
[18:01:57.460]                         })
[18:01:57.460]                       }
[18:01:57.460]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:57.460]                       base::options(mc.cores = 1L)
[18:01:57.460]                     }
[18:01:57.460]                     base::local({
[18:01:57.460]                       for (pkg in "future.apply") {
[18:01:57.460]                         base::loadNamespace(pkg)
[18:01:57.460]                         base::library(pkg, character.only = TRUE)
[18:01:57.460]                       }
[18:01:57.460]                     })
[18:01:57.460]                   }
[18:01:57.460]                   ...future.strategy.old <- future::plan("list")
[18:01:57.460]                   options(future.plan = NULL)
[18:01:57.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:57.460]                 }
[18:01:57.460]                 ...future.workdir <- getwd()
[18:01:57.460]             }
[18:01:57.460]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:57.460]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:57.460]         }
[18:01:57.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:57.460]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:57.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:57.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:57.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:57.460]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:57.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:57.460]             base::names(...future.oldOptions))
[18:01:57.460]     }
[18:01:57.460]     if (FALSE) {
[18:01:57.460]     }
[18:01:57.460]     else {
[18:01:57.460]         if (TRUE) {
[18:01:57.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:57.460]                 open = "w")
[18:01:57.460]         }
[18:01:57.460]         else {
[18:01:57.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:57.460]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:57.460]         }
[18:01:57.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:57.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:57.460]             base::sink(type = "output", split = FALSE)
[18:01:57.460]             base::close(...future.stdout)
[18:01:57.460]         }, add = TRUE)
[18:01:57.460]     }
[18:01:57.460]     ...future.frame <- base::sys.nframe()
[18:01:57.460]     ...future.conditions <- base::list()
[18:01:57.460]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:57.460]     if (FALSE) {
[18:01:57.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:57.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:57.460]     }
[18:01:57.460]     ...future.result <- base::tryCatch({
[18:01:57.460]         base::withCallingHandlers({
[18:01:57.460]             ...future.value <- base::withVisible(base::local({
[18:01:57.460]                 withCallingHandlers({
[18:01:57.460]                   {
[18:01:57.460]                     do.call(function(...) {
[18:01:57.460]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.460]                       if (!identical(...future.globals.maxSize.org, 
[18:01:57.460]                         ...future.globals.maxSize)) {
[18:01:57.460]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.460]                         on.exit(options(oopts), add = TRUE)
[18:01:57.460]                       }
[18:01:57.460]                       {
[18:01:57.460]                         lapply(seq_along(...future.elements_ii), 
[18:01:57.460]                           FUN = function(jj) {
[18:01:57.460]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.460]                             ...future.FUN(...future.X_jj, ...)
[18:01:57.460]                           })
[18:01:57.460]                       }
[18:01:57.460]                     }, args = future.call.arguments)
[18:01:57.460]                   }
[18:01:57.460]                 }, immediateCondition = function(cond) {
[18:01:57.460]                   save_rds <- function (object, pathname, ...) 
[18:01:57.460]                   {
[18:01:57.460]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:57.460]                     if (file_test("-f", pathname_tmp)) {
[18:01:57.460]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.460]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:57.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.460]                         fi_tmp[["mtime"]])
[18:01:57.460]                     }
[18:01:57.460]                     tryCatch({
[18:01:57.460]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:57.460]                     }, error = function(ex) {
[18:01:57.460]                       msg <- conditionMessage(ex)
[18:01:57.460]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.460]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:57.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.460]                         fi_tmp[["mtime"]], msg)
[18:01:57.460]                       ex$message <- msg
[18:01:57.460]                       stop(ex)
[18:01:57.460]                     })
[18:01:57.460]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:57.460]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:57.460]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:57.460]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.460]                       fi <- file.info(pathname)
[18:01:57.460]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:57.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.460]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:57.460]                         fi[["size"]], fi[["mtime"]])
[18:01:57.460]                       stop(msg)
[18:01:57.460]                     }
[18:01:57.460]                     invisible(pathname)
[18:01:57.460]                   }
[18:01:57.460]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:57.460]                     rootPath = tempdir()) 
[18:01:57.460]                   {
[18:01:57.460]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:57.460]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:57.460]                       tmpdir = path, fileext = ".rds")
[18:01:57.460]                     save_rds(obj, file)
[18:01:57.460]                   }
[18:01:57.460]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:57.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.460]                   {
[18:01:57.460]                     inherits <- base::inherits
[18:01:57.460]                     invokeRestart <- base::invokeRestart
[18:01:57.460]                     is.null <- base::is.null
[18:01:57.460]                     muffled <- FALSE
[18:01:57.460]                     if (inherits(cond, "message")) {
[18:01:57.460]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:57.460]                       if (muffled) 
[18:01:57.460]                         invokeRestart("muffleMessage")
[18:01:57.460]                     }
[18:01:57.460]                     else if (inherits(cond, "warning")) {
[18:01:57.460]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:57.460]                       if (muffled) 
[18:01:57.460]                         invokeRestart("muffleWarning")
[18:01:57.460]                     }
[18:01:57.460]                     else if (inherits(cond, "condition")) {
[18:01:57.460]                       if (!is.null(pattern)) {
[18:01:57.460]                         computeRestarts <- base::computeRestarts
[18:01:57.460]                         grepl <- base::grepl
[18:01:57.460]                         restarts <- computeRestarts(cond)
[18:01:57.460]                         for (restart in restarts) {
[18:01:57.460]                           name <- restart$name
[18:01:57.460]                           if (is.null(name)) 
[18:01:57.460]                             next
[18:01:57.460]                           if (!grepl(pattern, name)) 
[18:01:57.460]                             next
[18:01:57.460]                           invokeRestart(restart)
[18:01:57.460]                           muffled <- TRUE
[18:01:57.460]                           break
[18:01:57.460]                         }
[18:01:57.460]                       }
[18:01:57.460]                     }
[18:01:57.460]                     invisible(muffled)
[18:01:57.460]                   }
[18:01:57.460]                   muffleCondition(cond)
[18:01:57.460]                 })
[18:01:57.460]             }))
[18:01:57.460]             future::FutureResult(value = ...future.value$value, 
[18:01:57.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.460]                   ...future.rng), globalenv = if (FALSE) 
[18:01:57.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:57.460]                     ...future.globalenv.names))
[18:01:57.460]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:57.460]         }, condition = base::local({
[18:01:57.460]             c <- base::c
[18:01:57.460]             inherits <- base::inherits
[18:01:57.460]             invokeRestart <- base::invokeRestart
[18:01:57.460]             length <- base::length
[18:01:57.460]             list <- base::list
[18:01:57.460]             seq.int <- base::seq.int
[18:01:57.460]             signalCondition <- base::signalCondition
[18:01:57.460]             sys.calls <- base::sys.calls
[18:01:57.460]             `[[` <- base::`[[`
[18:01:57.460]             `+` <- base::`+`
[18:01:57.460]             `<<-` <- base::`<<-`
[18:01:57.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:57.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:57.460]                   3L)]
[18:01:57.460]             }
[18:01:57.460]             function(cond) {
[18:01:57.460]                 is_error <- inherits(cond, "error")
[18:01:57.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:57.460]                   NULL)
[18:01:57.460]                 if (is_error) {
[18:01:57.460]                   sessionInformation <- function() {
[18:01:57.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:57.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:57.460]                       search = base::search(), system = base::Sys.info())
[18:01:57.460]                   }
[18:01:57.460]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:57.460]                     cond$call), session = sessionInformation(), 
[18:01:57.460]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:57.460]                   signalCondition(cond)
[18:01:57.460]                 }
[18:01:57.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:57.460]                 "immediateCondition"))) {
[18:01:57.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:57.460]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:57.460]                   if (TRUE && !signal) {
[18:01:57.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.460]                     {
[18:01:57.460]                       inherits <- base::inherits
[18:01:57.460]                       invokeRestart <- base::invokeRestart
[18:01:57.460]                       is.null <- base::is.null
[18:01:57.460]                       muffled <- FALSE
[18:01:57.460]                       if (inherits(cond, "message")) {
[18:01:57.460]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.460]                         if (muffled) 
[18:01:57.460]                           invokeRestart("muffleMessage")
[18:01:57.460]                       }
[18:01:57.460]                       else if (inherits(cond, "warning")) {
[18:01:57.460]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.460]                         if (muffled) 
[18:01:57.460]                           invokeRestart("muffleWarning")
[18:01:57.460]                       }
[18:01:57.460]                       else if (inherits(cond, "condition")) {
[18:01:57.460]                         if (!is.null(pattern)) {
[18:01:57.460]                           computeRestarts <- base::computeRestarts
[18:01:57.460]                           grepl <- base::grepl
[18:01:57.460]                           restarts <- computeRestarts(cond)
[18:01:57.460]                           for (restart in restarts) {
[18:01:57.460]                             name <- restart$name
[18:01:57.460]                             if (is.null(name)) 
[18:01:57.460]                               next
[18:01:57.460]                             if (!grepl(pattern, name)) 
[18:01:57.460]                               next
[18:01:57.460]                             invokeRestart(restart)
[18:01:57.460]                             muffled <- TRUE
[18:01:57.460]                             break
[18:01:57.460]                           }
[18:01:57.460]                         }
[18:01:57.460]                       }
[18:01:57.460]                       invisible(muffled)
[18:01:57.460]                     }
[18:01:57.460]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.460]                   }
[18:01:57.460]                 }
[18:01:57.460]                 else {
[18:01:57.460]                   if (TRUE) {
[18:01:57.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.460]                     {
[18:01:57.460]                       inherits <- base::inherits
[18:01:57.460]                       invokeRestart <- base::invokeRestart
[18:01:57.460]                       is.null <- base::is.null
[18:01:57.460]                       muffled <- FALSE
[18:01:57.460]                       if (inherits(cond, "message")) {
[18:01:57.460]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.460]                         if (muffled) 
[18:01:57.460]                           invokeRestart("muffleMessage")
[18:01:57.460]                       }
[18:01:57.460]                       else if (inherits(cond, "warning")) {
[18:01:57.460]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.460]                         if (muffled) 
[18:01:57.460]                           invokeRestart("muffleWarning")
[18:01:57.460]                       }
[18:01:57.460]                       else if (inherits(cond, "condition")) {
[18:01:57.460]                         if (!is.null(pattern)) {
[18:01:57.460]                           computeRestarts <- base::computeRestarts
[18:01:57.460]                           grepl <- base::grepl
[18:01:57.460]                           restarts <- computeRestarts(cond)
[18:01:57.460]                           for (restart in restarts) {
[18:01:57.460]                             name <- restart$name
[18:01:57.460]                             if (is.null(name)) 
[18:01:57.460]                               next
[18:01:57.460]                             if (!grepl(pattern, name)) 
[18:01:57.460]                               next
[18:01:57.460]                             invokeRestart(restart)
[18:01:57.460]                             muffled <- TRUE
[18:01:57.460]                             break
[18:01:57.460]                           }
[18:01:57.460]                         }
[18:01:57.460]                       }
[18:01:57.460]                       invisible(muffled)
[18:01:57.460]                     }
[18:01:57.460]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.460]                   }
[18:01:57.460]                 }
[18:01:57.460]             }
[18:01:57.460]         }))
[18:01:57.460]     }, error = function(ex) {
[18:01:57.460]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:57.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.460]                 ...future.rng), started = ...future.startTime, 
[18:01:57.460]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:57.460]             version = "1.8"), class = "FutureResult")
[18:01:57.460]     }, finally = {
[18:01:57.460]         if (!identical(...future.workdir, getwd())) 
[18:01:57.460]             setwd(...future.workdir)
[18:01:57.460]         {
[18:01:57.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:57.460]                 ...future.oldOptions$nwarnings <- NULL
[18:01:57.460]             }
[18:01:57.460]             base::options(...future.oldOptions)
[18:01:57.460]             if (.Platform$OS.type == "windows") {
[18:01:57.460]                 old_names <- names(...future.oldEnvVars)
[18:01:57.460]                 envs <- base::Sys.getenv()
[18:01:57.460]                 names <- names(envs)
[18:01:57.460]                 common <- intersect(names, old_names)
[18:01:57.460]                 added <- setdiff(names, old_names)
[18:01:57.460]                 removed <- setdiff(old_names, names)
[18:01:57.460]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:57.460]                   envs[common]]
[18:01:57.460]                 NAMES <- toupper(changed)
[18:01:57.460]                 args <- list()
[18:01:57.460]                 for (kk in seq_along(NAMES)) {
[18:01:57.460]                   name <- changed[[kk]]
[18:01:57.460]                   NAME <- NAMES[[kk]]
[18:01:57.460]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.460]                     next
[18:01:57.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.460]                 }
[18:01:57.460]                 NAMES <- toupper(added)
[18:01:57.460]                 for (kk in seq_along(NAMES)) {
[18:01:57.460]                   name <- added[[kk]]
[18:01:57.460]                   NAME <- NAMES[[kk]]
[18:01:57.460]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.460]                     next
[18:01:57.460]                   args[[name]] <- ""
[18:01:57.460]                 }
[18:01:57.460]                 NAMES <- toupper(removed)
[18:01:57.460]                 for (kk in seq_along(NAMES)) {
[18:01:57.460]                   name <- removed[[kk]]
[18:01:57.460]                   NAME <- NAMES[[kk]]
[18:01:57.460]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.460]                     next
[18:01:57.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.460]                 }
[18:01:57.460]                 if (length(args) > 0) 
[18:01:57.460]                   base::do.call(base::Sys.setenv, args = args)
[18:01:57.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:57.460]             }
[18:01:57.460]             else {
[18:01:57.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:57.460]             }
[18:01:57.460]             {
[18:01:57.460]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:57.460]                   0L) {
[18:01:57.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:57.460]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:57.460]                   base::options(opts)
[18:01:57.460]                 }
[18:01:57.460]                 {
[18:01:57.460]                   {
[18:01:57.460]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:57.460]                     NULL
[18:01:57.460]                   }
[18:01:57.460]                   options(future.plan = NULL)
[18:01:57.460]                   if (is.na(NA_character_)) 
[18:01:57.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:57.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:57.460]                     .init = FALSE)
[18:01:57.460]                 }
[18:01:57.460]             }
[18:01:57.460]         }
[18:01:57.460]     })
[18:01:57.460]     if (TRUE) {
[18:01:57.460]         base::sink(type = "output", split = FALSE)
[18:01:57.460]         if (TRUE) {
[18:01:57.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:57.460]         }
[18:01:57.460]         else {
[18:01:57.460]             ...future.result["stdout"] <- base::list(NULL)
[18:01:57.460]         }
[18:01:57.460]         base::close(...future.stdout)
[18:01:57.460]         ...future.stdout <- NULL
[18:01:57.460]     }
[18:01:57.460]     ...future.result$conditions <- ...future.conditions
[18:01:57.460]     ...future.result$finished <- base::Sys.time()
[18:01:57.460]     ...future.result
[18:01:57.460] }
[18:01:57.465] assign_globals() ...
[18:01:57.465] List of 11
[18:01:57.465]  $ ...future.FUN            :function (x, ...)  
[18:01:57.465]  $ x_FUN                    :function (x)  
[18:01:57.465]  $ times                    : int 0
[18:01:57.465]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:57.465]  $ stop_if_not              :function (...)  
[18:01:57.465]  $ dim                      : NULL
[18:01:57.465]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:57.465]  $ future.call.arguments    : list()
[18:01:57.465]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.465]  $ ...future.elements_ii    :List of 5
[18:01:57.465]   ..$ : int 6
[18:01:57.465]   ..$ : int 7
[18:01:57.465]   ..$ : int 8
[18:01:57.465]   ..$ : int 9
[18:01:57.465]   ..$ : int 10
[18:01:57.465]  $ ...future.seeds_ii       : NULL
[18:01:57.465]  $ ...future.globals.maxSize: NULL
[18:01:57.465]  - attr(*, "where")=List of 11
[18:01:57.465]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:57.465]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:57.465]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:57.465]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:57.465]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:57.465]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:57.465]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:57.465]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:57.465]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:57.465]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:57.465]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:57.465]  - attr(*, "resolved")= logi FALSE
[18:01:57.465]  - attr(*, "total_size")= num 95472
[18:01:57.465]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.465]  - attr(*, "already-done")= logi TRUE
[18:01:57.488] - copied ‘...future.FUN’ to environment
[18:01:57.488] - reassign environment for ‘x_FUN’
[18:01:57.489] - copied ‘x_FUN’ to environment
[18:01:57.489] - copied ‘times’ to environment
[18:01:57.489] - copied ‘stopf’ to environment
[18:01:57.489] - copied ‘stop_if_not’ to environment
[18:01:57.490] - copied ‘dim’ to environment
[18:01:57.490] - copied ‘valid_types’ to environment
[18:01:57.490] - copied ‘future.call.arguments’ to environment
[18:01:57.490] - copied ‘...future.elements_ii’ to environment
[18:01:57.491] - copied ‘...future.seeds_ii’ to environment
[18:01:57.491] - copied ‘...future.globals.maxSize’ to environment
[18:01:57.491] assign_globals() ... done
[18:01:57.492] requestCore(): workers = 2
[18:01:57.495] MulticoreFuture started
[18:01:57.496] - Launch lazy future ... done
[18:01:57.496] run() for ‘MulticoreFuture’ ... done
[18:01:57.497] Created future:
[18:01:57.498] plan(): Setting new future strategy stack:
[18:01:57.498] List of future strategies:
[18:01:57.498] 1. sequential:
[18:01:57.498]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:57.498]    - tweaked: FALSE
[18:01:57.498]    - call: NULL
[18:01:57.500] plan(): nbrOfWorkers() = 1
[18:01:57.504] plan(): Setting new future strategy stack:
[18:01:57.505] List of future strategies:
[18:01:57.505] 1. multicore:
[18:01:57.505]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:57.505]    - tweaked: FALSE
[18:01:57.505]    - call: plan(strategy)
[18:01:57.497] MulticoreFuture:
[18:01:57.497] Label: ‘future_vapply-2’
[18:01:57.497] Expression:
[18:01:57.497] {
[18:01:57.497]     do.call(function(...) {
[18:01:57.497]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.497]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.497]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.497]             on.exit(options(oopts), add = TRUE)
[18:01:57.497]         }
[18:01:57.497]         {
[18:01:57.497]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.497]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.497]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.497]             })
[18:01:57.497]         }
[18:01:57.497]     }, args = future.call.arguments)
[18:01:57.497] }
[18:01:57.497] Lazy evaluation: FALSE
[18:01:57.497] Asynchronous evaluation: TRUE
[18:01:57.497] Local evaluation: TRUE
[18:01:57.497] Environment: R_GlobalEnv
[18:01:57.497] Capture standard output: TRUE
[18:01:57.497] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:57.497] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:57.497] Packages: 1 packages (‘future.apply’)
[18:01:57.497] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:57.497] Resolved: FALSE
[18:01:57.497] Value: <not collected>
[18:01:57.497] Conditions captured: <none>
[18:01:57.497] Early signaling: FALSE
[18:01:57.497] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:57.497] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.513] Chunk #2 of 2 ... DONE
[18:01:57.514] Launching 2 futures (chunks) ... DONE
[18:01:57.514] plan(): nbrOfWorkers() = 2
[18:01:57.514] Resolving 2 futures (chunks) ...
[18:01:57.514] resolve() on list ...
[18:01:57.515]  recursive: 0
[18:01:57.515]  length: 2
[18:01:57.515] 
[18:01:57.516] Future #1
[18:01:57.516] result() for MulticoreFuture ...
[18:01:57.518] result() for MulticoreFuture ...
[18:01:57.518] result() for MulticoreFuture ... done
[18:01:57.518] result() for MulticoreFuture ... done
[18:01:57.519] result() for MulticoreFuture ...
[18:01:57.519] result() for MulticoreFuture ... done
[18:01:57.519] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:57.520] - nx: 2
[18:01:57.520] - relay: TRUE
[18:01:57.520] - stdout: TRUE
[18:01:57.520] - signal: TRUE
[18:01:57.521] - resignal: FALSE
[18:01:57.521] - force: TRUE
[18:01:57.521] - relayed: [n=2] FALSE, FALSE
[18:01:57.522] - queued futures: [n=2] FALSE, FALSE
[18:01:57.522]  - until=1
[18:01:57.522]  - relaying element #1
[18:01:57.522] result() for MulticoreFuture ...
[18:01:57.523] result() for MulticoreFuture ... done
[18:01:57.523] result() for MulticoreFuture ...
[18:01:57.523] result() for MulticoreFuture ... done
[18:01:57.524] result() for MulticoreFuture ...
[18:01:57.524] result() for MulticoreFuture ... done
[18:01:57.524] result() for MulticoreFuture ...
[18:01:57.525] result() for MulticoreFuture ... done
[18:01:57.525] - relayed: [n=2] TRUE, FALSE
[18:01:57.525] - queued futures: [n=2] TRUE, FALSE
[18:01:57.526] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:57.526]  length: 1 (resolved future 1)
[18:01:57.527] Future #2
[18:01:57.527] result() for MulticoreFuture ...
[18:01:57.528] result() for MulticoreFuture ...
[18:01:57.529] result() for MulticoreFuture ... done
[18:01:57.533] result() for MulticoreFuture ... done
[18:01:57.534] result() for MulticoreFuture ...
[18:01:57.534] result() for MulticoreFuture ... done
[18:01:57.534] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:57.535] - nx: 2
[18:01:57.535] - relay: TRUE
[18:01:57.535] - stdout: TRUE
[18:01:57.536] - signal: TRUE
[18:01:57.536] - resignal: FALSE
[18:01:57.536] - force: TRUE
[18:01:57.537] - relayed: [n=2] TRUE, FALSE
[18:01:57.537] - queued futures: [n=2] TRUE, FALSE
[18:01:57.537]  - until=2
[18:01:57.537]  - relaying element #2
[18:01:57.538] result() for MulticoreFuture ...
[18:01:57.538] result() for MulticoreFuture ... done
[18:01:57.538] result() for MulticoreFuture ...
[18:01:57.539] result() for MulticoreFuture ... done
[18:01:57.539] result() for MulticoreFuture ...
[18:01:57.539] result() for MulticoreFuture ... done
[18:01:57.540] result() for MulticoreFuture ...
[18:01:57.540] result() for MulticoreFuture ... done
[18:01:57.540] - relayed: [n=2] TRUE, TRUE
[18:01:57.540] - queued futures: [n=2] TRUE, TRUE
[18:01:57.541] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:57.541]  length: 0 (resolved future 2)
[18:01:57.541] Relaying remaining futures
[18:01:57.542] signalConditionsASAP(NULL, pos=0) ...
[18:01:57.542] - nx: 2
[18:01:57.542] - relay: TRUE
[18:01:57.542] - stdout: TRUE
[18:01:57.543] - signal: TRUE
[18:01:57.543] - resignal: FALSE
[18:01:57.543] - force: TRUE
[18:01:57.543] - relayed: [n=2] TRUE, TRUE
[18:01:57.543] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:57.544] - relayed: [n=2] TRUE, TRUE
[18:01:57.544] - queued futures: [n=2] TRUE, TRUE
[18:01:57.544] signalConditionsASAP(NULL, pos=0) ... done
[18:01:57.544] resolve() on list ... DONE
[18:01:57.545] result() for MulticoreFuture ...
[18:01:57.545] result() for MulticoreFuture ... done
[18:01:57.545] result() for MulticoreFuture ...
[18:01:57.545] result() for MulticoreFuture ... done
[18:01:57.546] result() for MulticoreFuture ...
[18:01:57.546] result() for MulticoreFuture ... done
[18:01:57.546] result() for MulticoreFuture ...
[18:01:57.546] result() for MulticoreFuture ... done
[18:01:57.547]  - Number of value chunks collected: 2
[18:01:57.547] Resolving 2 futures (chunks) ... DONE
[18:01:57.547] Reducing values from 2 chunks ...
[18:01:57.547]  - Number of values collected after concatenation: 10
[18:01:57.547]  - Number of values expected: 10
[18:01:57.548] Reducing values from 2 chunks ... DONE
[18:01:57.548] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[18:01:57.550] future_lapply() ...
[18:01:57.560] Number of chunks: 2
[18:01:57.561] getGlobalsAndPackagesXApply() ...
[18:01:57.561]  - future.globals: TRUE
[18:01:57.561] getGlobalsAndPackages() ...
[18:01:57.561] Searching for globals...
[18:01:57.569] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[18:01:57.570] Searching for globals ... DONE
[18:01:57.570] Resolving globals: FALSE
[18:01:57.572] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[18:01:57.573] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:57.573] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:57.573] - packages: [1] ‘future.apply’
[18:01:57.573] getGlobalsAndPackages() ... DONE
[18:01:57.574]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:57.574]  - needed namespaces: [n=1] ‘future.apply’
[18:01:57.574] Finding globals ... DONE
[18:01:57.574]  - use_args: TRUE
[18:01:57.574]  - Getting '...' globals ...
[18:01:57.575] resolve() on list ...
[18:01:57.575]  recursive: 0
[18:01:57.575]  length: 1
[18:01:57.576]  elements: ‘...’
[18:01:57.576]  length: 0 (resolved future 1)
[18:01:57.576] resolve() on list ... DONE
[18:01:57.576]    - '...' content: [n=0] 
[18:01:57.577] List of 1
[18:01:57.577]  $ ...: list()
[18:01:57.577]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.577]  - attr(*, "where")=List of 1
[18:01:57.577]   ..$ ...:<environment: 0x6183be6f40b0> 
[18:01:57.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.577]  - attr(*, "resolved")= logi TRUE
[18:01:57.577]  - attr(*, "total_size")= num NA
[18:01:57.582]  - Getting '...' globals ... DONE
[18:01:57.582] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:57.582] List of 8
[18:01:57.582]  $ ...future.FUN:function (x, ...)  
[18:01:57.582]  $ x_FUN        :function (x)  
[18:01:57.582]  $ times        : int 0
[18:01:57.582]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:57.582]  $ stop_if_not  :function (...)  
[18:01:57.582]  $ dim          : NULL
[18:01:57.582]  $ valid_types  : chr [1:2] "logical" "integer"
[18:01:57.582]  $ ...          : list()
[18:01:57.582]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.582]  - attr(*, "where")=List of 8
[18:01:57.582]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:57.582]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:57.582]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:57.582]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:57.582]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:57.582]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:57.582]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:57.582]   ..$ ...          :<environment: 0x6183be6f40b0> 
[18:01:57.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.582]  - attr(*, "resolved")= logi FALSE
[18:01:57.582]  - attr(*, "total_size")= num 95400
[18:01:57.597] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:57.598] getGlobalsAndPackagesXApply() ... DONE
[18:01:57.598] Number of futures (= number of chunks): 2
[18:01:57.598] Launching 2 futures (chunks) ...
[18:01:57.599] Chunk #1 of 2 ...
[18:01:57.599]  - Finding globals in 'X' for chunk #1 ...
[18:01:57.599] getGlobalsAndPackages() ...
[18:01:57.599] Searching for globals...
[18:01:57.600] 
[18:01:57.600] Searching for globals ... DONE
[18:01:57.600] - globals: [0] <none>
[18:01:57.600] getGlobalsAndPackages() ... DONE
[18:01:57.601]    + additional globals found: [n=0] 
[18:01:57.601]    + additional namespaces needed: [n=0] 
[18:01:57.601]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:57.601]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:57.602]  - seeds: <none>
[18:01:57.602]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.602] getGlobalsAndPackages() ...
[18:01:57.602] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.602] Resolving globals: FALSE
[18:01:57.603] Tweak future expression to call with '...' arguments ...
[18:01:57.603] {
[18:01:57.603]     do.call(function(...) {
[18:01:57.603]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.603]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.603]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.603]             on.exit(options(oopts), add = TRUE)
[18:01:57.603]         }
[18:01:57.603]         {
[18:01:57.603]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.603]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.603]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.603]             })
[18:01:57.603]         }
[18:01:57.603]     }, args = future.call.arguments)
[18:01:57.603] }
[18:01:57.603] Tweak future expression to call with '...' arguments ... DONE
[18:01:57.605] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.605] - packages: [1] ‘future.apply’
[18:01:57.605] getGlobalsAndPackages() ... DONE
[18:01:57.606] run() for ‘Future’ ...
[18:01:57.606] - state: ‘created’
[18:01:57.606] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:57.613] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.613] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:57.613]   - Field: ‘label’
[18:01:57.614]   - Field: ‘local’
[18:01:57.614]   - Field: ‘owner’
[18:01:57.614]   - Field: ‘envir’
[18:01:57.614]   - Field: ‘workers’
[18:01:57.615]   - Field: ‘packages’
[18:01:57.615]   - Field: ‘gc’
[18:01:57.615]   - Field: ‘job’
[18:01:57.615]   - Field: ‘conditions’
[18:01:57.615]   - Field: ‘expr’
[18:01:57.616]   - Field: ‘uuid’
[18:01:57.616]   - Field: ‘seed’
[18:01:57.616]   - Field: ‘version’
[18:01:57.616]   - Field: ‘result’
[18:01:57.616]   - Field: ‘asynchronous’
[18:01:57.617]   - Field: ‘calls’
[18:01:57.617]   - Field: ‘globals’
[18:01:57.617]   - Field: ‘stdout’
[18:01:57.617]   - Field: ‘earlySignal’
[18:01:57.618]   - Field: ‘lazy’
[18:01:57.618]   - Field: ‘state’
[18:01:57.618] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:57.618] - Launch lazy future ...
[18:01:57.619] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:57.619] Packages needed by future strategies (n = 0): <none>
[18:01:57.620] {
[18:01:57.620]     {
[18:01:57.620]         {
[18:01:57.620]             ...future.startTime <- base::Sys.time()
[18:01:57.620]             {
[18:01:57.620]                 {
[18:01:57.620]                   {
[18:01:57.620]                     {
[18:01:57.620]                       {
[18:01:57.620]                         base::local({
[18:01:57.620]                           has_future <- base::requireNamespace("future", 
[18:01:57.620]                             quietly = TRUE)
[18:01:57.620]                           if (has_future) {
[18:01:57.620]                             ns <- base::getNamespace("future")
[18:01:57.620]                             version <- ns[[".package"]][["version"]]
[18:01:57.620]                             if (is.null(version)) 
[18:01:57.620]                               version <- utils::packageVersion("future")
[18:01:57.620]                           }
[18:01:57.620]                           else {
[18:01:57.620]                             version <- NULL
[18:01:57.620]                           }
[18:01:57.620]                           if (!has_future || version < "1.8.0") {
[18:01:57.620]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:57.620]                               "", base::R.version$version.string), 
[18:01:57.620]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:57.620]                                 base::R.version$platform, 8 * 
[18:01:57.620]                                   base::.Machine$sizeof.pointer), 
[18:01:57.620]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:57.620]                                 "release", "version")], collapse = " "), 
[18:01:57.620]                               hostname = base::Sys.info()[["nodename"]])
[18:01:57.620]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:57.620]                               info)
[18:01:57.620]                             info <- base::paste(info, collapse = "; ")
[18:01:57.620]                             if (!has_future) {
[18:01:57.620]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:57.620]                                 info)
[18:01:57.620]                             }
[18:01:57.620]                             else {
[18:01:57.620]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:57.620]                                 info, version)
[18:01:57.620]                             }
[18:01:57.620]                             base::stop(msg)
[18:01:57.620]                           }
[18:01:57.620]                         })
[18:01:57.620]                       }
[18:01:57.620]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:57.620]                       base::options(mc.cores = 1L)
[18:01:57.620]                     }
[18:01:57.620]                     base::local({
[18:01:57.620]                       for (pkg in "future.apply") {
[18:01:57.620]                         base::loadNamespace(pkg)
[18:01:57.620]                         base::library(pkg, character.only = TRUE)
[18:01:57.620]                       }
[18:01:57.620]                     })
[18:01:57.620]                   }
[18:01:57.620]                   ...future.strategy.old <- future::plan("list")
[18:01:57.620]                   options(future.plan = NULL)
[18:01:57.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.620]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:57.620]                 }
[18:01:57.620]                 ...future.workdir <- getwd()
[18:01:57.620]             }
[18:01:57.620]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:57.620]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:57.620]         }
[18:01:57.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:57.620]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:57.620]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:57.620]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:57.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:57.620]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:57.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:57.620]             base::names(...future.oldOptions))
[18:01:57.620]     }
[18:01:57.620]     if (FALSE) {
[18:01:57.620]     }
[18:01:57.620]     else {
[18:01:57.620]         if (TRUE) {
[18:01:57.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:57.620]                 open = "w")
[18:01:57.620]         }
[18:01:57.620]         else {
[18:01:57.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:57.620]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:57.620]         }
[18:01:57.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:57.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:57.620]             base::sink(type = "output", split = FALSE)
[18:01:57.620]             base::close(...future.stdout)
[18:01:57.620]         }, add = TRUE)
[18:01:57.620]     }
[18:01:57.620]     ...future.frame <- base::sys.nframe()
[18:01:57.620]     ...future.conditions <- base::list()
[18:01:57.620]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:57.620]     if (FALSE) {
[18:01:57.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:57.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:57.620]     }
[18:01:57.620]     ...future.result <- base::tryCatch({
[18:01:57.620]         base::withCallingHandlers({
[18:01:57.620]             ...future.value <- base::withVisible(base::local({
[18:01:57.620]                 withCallingHandlers({
[18:01:57.620]                   {
[18:01:57.620]                     do.call(function(...) {
[18:01:57.620]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.620]                       if (!identical(...future.globals.maxSize.org, 
[18:01:57.620]                         ...future.globals.maxSize)) {
[18:01:57.620]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.620]                         on.exit(options(oopts), add = TRUE)
[18:01:57.620]                       }
[18:01:57.620]                       {
[18:01:57.620]                         lapply(seq_along(...future.elements_ii), 
[18:01:57.620]                           FUN = function(jj) {
[18:01:57.620]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.620]                             ...future.FUN(...future.X_jj, ...)
[18:01:57.620]                           })
[18:01:57.620]                       }
[18:01:57.620]                     }, args = future.call.arguments)
[18:01:57.620]                   }
[18:01:57.620]                 }, immediateCondition = function(cond) {
[18:01:57.620]                   save_rds <- function (object, pathname, ...) 
[18:01:57.620]                   {
[18:01:57.620]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:57.620]                     if (file_test("-f", pathname_tmp)) {
[18:01:57.620]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.620]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:57.620]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.620]                         fi_tmp[["mtime"]])
[18:01:57.620]                     }
[18:01:57.620]                     tryCatch({
[18:01:57.620]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:57.620]                     }, error = function(ex) {
[18:01:57.620]                       msg <- conditionMessage(ex)
[18:01:57.620]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.620]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:57.620]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.620]                         fi_tmp[["mtime"]], msg)
[18:01:57.620]                       ex$message <- msg
[18:01:57.620]                       stop(ex)
[18:01:57.620]                     })
[18:01:57.620]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:57.620]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:57.620]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:57.620]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.620]                       fi <- file.info(pathname)
[18:01:57.620]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:57.620]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.620]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:57.620]                         fi[["size"]], fi[["mtime"]])
[18:01:57.620]                       stop(msg)
[18:01:57.620]                     }
[18:01:57.620]                     invisible(pathname)
[18:01:57.620]                   }
[18:01:57.620]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:57.620]                     rootPath = tempdir()) 
[18:01:57.620]                   {
[18:01:57.620]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:57.620]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:57.620]                       tmpdir = path, fileext = ".rds")
[18:01:57.620]                     save_rds(obj, file)
[18:01:57.620]                   }
[18:01:57.620]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:57.620]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.620]                   {
[18:01:57.620]                     inherits <- base::inherits
[18:01:57.620]                     invokeRestart <- base::invokeRestart
[18:01:57.620]                     is.null <- base::is.null
[18:01:57.620]                     muffled <- FALSE
[18:01:57.620]                     if (inherits(cond, "message")) {
[18:01:57.620]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:57.620]                       if (muffled) 
[18:01:57.620]                         invokeRestart("muffleMessage")
[18:01:57.620]                     }
[18:01:57.620]                     else if (inherits(cond, "warning")) {
[18:01:57.620]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:57.620]                       if (muffled) 
[18:01:57.620]                         invokeRestart("muffleWarning")
[18:01:57.620]                     }
[18:01:57.620]                     else if (inherits(cond, "condition")) {
[18:01:57.620]                       if (!is.null(pattern)) {
[18:01:57.620]                         computeRestarts <- base::computeRestarts
[18:01:57.620]                         grepl <- base::grepl
[18:01:57.620]                         restarts <- computeRestarts(cond)
[18:01:57.620]                         for (restart in restarts) {
[18:01:57.620]                           name <- restart$name
[18:01:57.620]                           if (is.null(name)) 
[18:01:57.620]                             next
[18:01:57.620]                           if (!grepl(pattern, name)) 
[18:01:57.620]                             next
[18:01:57.620]                           invokeRestart(restart)
[18:01:57.620]                           muffled <- TRUE
[18:01:57.620]                           break
[18:01:57.620]                         }
[18:01:57.620]                       }
[18:01:57.620]                     }
[18:01:57.620]                     invisible(muffled)
[18:01:57.620]                   }
[18:01:57.620]                   muffleCondition(cond)
[18:01:57.620]                 })
[18:01:57.620]             }))
[18:01:57.620]             future::FutureResult(value = ...future.value$value, 
[18:01:57.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.620]                   ...future.rng), globalenv = if (FALSE) 
[18:01:57.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:57.620]                     ...future.globalenv.names))
[18:01:57.620]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:57.620]         }, condition = base::local({
[18:01:57.620]             c <- base::c
[18:01:57.620]             inherits <- base::inherits
[18:01:57.620]             invokeRestart <- base::invokeRestart
[18:01:57.620]             length <- base::length
[18:01:57.620]             list <- base::list
[18:01:57.620]             seq.int <- base::seq.int
[18:01:57.620]             signalCondition <- base::signalCondition
[18:01:57.620]             sys.calls <- base::sys.calls
[18:01:57.620]             `[[` <- base::`[[`
[18:01:57.620]             `+` <- base::`+`
[18:01:57.620]             `<<-` <- base::`<<-`
[18:01:57.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:57.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:57.620]                   3L)]
[18:01:57.620]             }
[18:01:57.620]             function(cond) {
[18:01:57.620]                 is_error <- inherits(cond, "error")
[18:01:57.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:57.620]                   NULL)
[18:01:57.620]                 if (is_error) {
[18:01:57.620]                   sessionInformation <- function() {
[18:01:57.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:57.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:57.620]                       search = base::search(), system = base::Sys.info())
[18:01:57.620]                   }
[18:01:57.620]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:57.620]                     cond$call), session = sessionInformation(), 
[18:01:57.620]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:57.620]                   signalCondition(cond)
[18:01:57.620]                 }
[18:01:57.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:57.620]                 "immediateCondition"))) {
[18:01:57.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:57.620]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:57.620]                   if (TRUE && !signal) {
[18:01:57.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.620]                     {
[18:01:57.620]                       inherits <- base::inherits
[18:01:57.620]                       invokeRestart <- base::invokeRestart
[18:01:57.620]                       is.null <- base::is.null
[18:01:57.620]                       muffled <- FALSE
[18:01:57.620]                       if (inherits(cond, "message")) {
[18:01:57.620]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.620]                         if (muffled) 
[18:01:57.620]                           invokeRestart("muffleMessage")
[18:01:57.620]                       }
[18:01:57.620]                       else if (inherits(cond, "warning")) {
[18:01:57.620]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.620]                         if (muffled) 
[18:01:57.620]                           invokeRestart("muffleWarning")
[18:01:57.620]                       }
[18:01:57.620]                       else if (inherits(cond, "condition")) {
[18:01:57.620]                         if (!is.null(pattern)) {
[18:01:57.620]                           computeRestarts <- base::computeRestarts
[18:01:57.620]                           grepl <- base::grepl
[18:01:57.620]                           restarts <- computeRestarts(cond)
[18:01:57.620]                           for (restart in restarts) {
[18:01:57.620]                             name <- restart$name
[18:01:57.620]                             if (is.null(name)) 
[18:01:57.620]                               next
[18:01:57.620]                             if (!grepl(pattern, name)) 
[18:01:57.620]                               next
[18:01:57.620]                             invokeRestart(restart)
[18:01:57.620]                             muffled <- TRUE
[18:01:57.620]                             break
[18:01:57.620]                           }
[18:01:57.620]                         }
[18:01:57.620]                       }
[18:01:57.620]                       invisible(muffled)
[18:01:57.620]                     }
[18:01:57.620]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.620]                   }
[18:01:57.620]                 }
[18:01:57.620]                 else {
[18:01:57.620]                   if (TRUE) {
[18:01:57.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.620]                     {
[18:01:57.620]                       inherits <- base::inherits
[18:01:57.620]                       invokeRestart <- base::invokeRestart
[18:01:57.620]                       is.null <- base::is.null
[18:01:57.620]                       muffled <- FALSE
[18:01:57.620]                       if (inherits(cond, "message")) {
[18:01:57.620]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.620]                         if (muffled) 
[18:01:57.620]                           invokeRestart("muffleMessage")
[18:01:57.620]                       }
[18:01:57.620]                       else if (inherits(cond, "warning")) {
[18:01:57.620]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.620]                         if (muffled) 
[18:01:57.620]                           invokeRestart("muffleWarning")
[18:01:57.620]                       }
[18:01:57.620]                       else if (inherits(cond, "condition")) {
[18:01:57.620]                         if (!is.null(pattern)) {
[18:01:57.620]                           computeRestarts <- base::computeRestarts
[18:01:57.620]                           grepl <- base::grepl
[18:01:57.620]                           restarts <- computeRestarts(cond)
[18:01:57.620]                           for (restart in restarts) {
[18:01:57.620]                             name <- restart$name
[18:01:57.620]                             if (is.null(name)) 
[18:01:57.620]                               next
[18:01:57.620]                             if (!grepl(pattern, name)) 
[18:01:57.620]                               next
[18:01:57.620]                             invokeRestart(restart)
[18:01:57.620]                             muffled <- TRUE
[18:01:57.620]                             break
[18:01:57.620]                           }
[18:01:57.620]                         }
[18:01:57.620]                       }
[18:01:57.620]                       invisible(muffled)
[18:01:57.620]                     }
[18:01:57.620]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.620]                   }
[18:01:57.620]                 }
[18:01:57.620]             }
[18:01:57.620]         }))
[18:01:57.620]     }, error = function(ex) {
[18:01:57.620]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:57.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.620]                 ...future.rng), started = ...future.startTime, 
[18:01:57.620]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:57.620]             version = "1.8"), class = "FutureResult")
[18:01:57.620]     }, finally = {
[18:01:57.620]         if (!identical(...future.workdir, getwd())) 
[18:01:57.620]             setwd(...future.workdir)
[18:01:57.620]         {
[18:01:57.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:57.620]                 ...future.oldOptions$nwarnings <- NULL
[18:01:57.620]             }
[18:01:57.620]             base::options(...future.oldOptions)
[18:01:57.620]             if (.Platform$OS.type == "windows") {
[18:01:57.620]                 old_names <- names(...future.oldEnvVars)
[18:01:57.620]                 envs <- base::Sys.getenv()
[18:01:57.620]                 names <- names(envs)
[18:01:57.620]                 common <- intersect(names, old_names)
[18:01:57.620]                 added <- setdiff(names, old_names)
[18:01:57.620]                 removed <- setdiff(old_names, names)
[18:01:57.620]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:57.620]                   envs[common]]
[18:01:57.620]                 NAMES <- toupper(changed)
[18:01:57.620]                 args <- list()
[18:01:57.620]                 for (kk in seq_along(NAMES)) {
[18:01:57.620]                   name <- changed[[kk]]
[18:01:57.620]                   NAME <- NAMES[[kk]]
[18:01:57.620]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.620]                     next
[18:01:57.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.620]                 }
[18:01:57.620]                 NAMES <- toupper(added)
[18:01:57.620]                 for (kk in seq_along(NAMES)) {
[18:01:57.620]                   name <- added[[kk]]
[18:01:57.620]                   NAME <- NAMES[[kk]]
[18:01:57.620]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.620]                     next
[18:01:57.620]                   args[[name]] <- ""
[18:01:57.620]                 }
[18:01:57.620]                 NAMES <- toupper(removed)
[18:01:57.620]                 for (kk in seq_along(NAMES)) {
[18:01:57.620]                   name <- removed[[kk]]
[18:01:57.620]                   NAME <- NAMES[[kk]]
[18:01:57.620]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.620]                     next
[18:01:57.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.620]                 }
[18:01:57.620]                 if (length(args) > 0) 
[18:01:57.620]                   base::do.call(base::Sys.setenv, args = args)
[18:01:57.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:57.620]             }
[18:01:57.620]             else {
[18:01:57.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:57.620]             }
[18:01:57.620]             {
[18:01:57.620]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:57.620]                   0L) {
[18:01:57.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:57.620]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:57.620]                   base::options(opts)
[18:01:57.620]                 }
[18:01:57.620]                 {
[18:01:57.620]                   {
[18:01:57.620]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:57.620]                     NULL
[18:01:57.620]                   }
[18:01:57.620]                   options(future.plan = NULL)
[18:01:57.620]                   if (is.na(NA_character_)) 
[18:01:57.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:57.620]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:57.620]                     .init = FALSE)
[18:01:57.620]                 }
[18:01:57.620]             }
[18:01:57.620]         }
[18:01:57.620]     })
[18:01:57.620]     if (TRUE) {
[18:01:57.620]         base::sink(type = "output", split = FALSE)
[18:01:57.620]         if (TRUE) {
[18:01:57.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:57.620]         }
[18:01:57.620]         else {
[18:01:57.620]             ...future.result["stdout"] <- base::list(NULL)
[18:01:57.620]         }
[18:01:57.620]         base::close(...future.stdout)
[18:01:57.620]         ...future.stdout <- NULL
[18:01:57.620]     }
[18:01:57.620]     ...future.result$conditions <- ...future.conditions
[18:01:57.620]     ...future.result$finished <- base::Sys.time()
[18:01:57.620]     ...future.result
[18:01:57.620] }
[18:01:57.625] assign_globals() ...
[18:01:57.625] List of 11
[18:01:57.625]  $ ...future.FUN            :function (x, ...)  
[18:01:57.625]  $ x_FUN                    :function (x)  
[18:01:57.625]  $ times                    : int 0
[18:01:57.625]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:57.625]  $ stop_if_not              :function (...)  
[18:01:57.625]  $ dim                      : NULL
[18:01:57.625]  $ valid_types              : chr [1:2] "logical" "integer"
[18:01:57.625]  $ future.call.arguments    : list()
[18:01:57.625]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.625]  $ ...future.elements_ii    :List of 5
[18:01:57.625]   ..$ : int 1
[18:01:57.625]   ..$ : int 2
[18:01:57.625]   ..$ : int 3
[18:01:57.625]   ..$ : int 4
[18:01:57.625]   ..$ : int 5
[18:01:57.625]  $ ...future.seeds_ii       : NULL
[18:01:57.625]  $ ...future.globals.maxSize: NULL
[18:01:57.625]  - attr(*, "where")=List of 11
[18:01:57.625]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:57.625]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:57.625]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:57.625]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:57.625]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:57.625]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:57.625]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:57.625]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:57.625]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:57.625]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:57.625]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:57.625]  - attr(*, "resolved")= logi FALSE
[18:01:57.625]  - attr(*, "total_size")= num 95400
[18:01:57.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.625]  - attr(*, "already-done")= logi TRUE
[18:01:57.647] - copied ‘...future.FUN’ to environment
[18:01:57.647] - reassign environment for ‘x_FUN’
[18:01:57.647] - copied ‘x_FUN’ to environment
[18:01:57.647] - copied ‘times’ to environment
[18:01:57.648] - copied ‘stopf’ to environment
[18:01:57.648] - copied ‘stop_if_not’ to environment
[18:01:57.648] - copied ‘dim’ to environment
[18:01:57.648] - copied ‘valid_types’ to environment
[18:01:57.649] - copied ‘future.call.arguments’ to environment
[18:01:57.649] - copied ‘...future.elements_ii’ to environment
[18:01:57.649] - copied ‘...future.seeds_ii’ to environment
[18:01:57.649] - copied ‘...future.globals.maxSize’ to environment
[18:01:57.649] assign_globals() ... done
[18:01:57.650] requestCore(): workers = 2
[18:01:57.654] MulticoreFuture started
[18:01:57.655] - Launch lazy future ... done
[18:01:57.656] run() for ‘MulticoreFuture’ ... done
[18:01:57.657] Created future:
[18:01:57.657] plan(): Setting new future strategy stack:
[18:01:57.658] List of future strategies:
[18:01:57.658] 1. sequential:
[18:01:57.658]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:57.658]    - tweaked: FALSE
[18:01:57.658]    - call: NULL
[18:01:57.660] plan(): nbrOfWorkers() = 1
[18:01:57.665] plan(): Setting new future strategy stack:
[18:01:57.666] List of future strategies:
[18:01:57.666] 1. multicore:
[18:01:57.666]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:57.666]    - tweaked: FALSE
[18:01:57.666]    - call: plan(strategy)
[18:01:57.658] MulticoreFuture:
[18:01:57.658] Label: ‘future_vapply-1’
[18:01:57.658] Expression:
[18:01:57.658] {
[18:01:57.658]     do.call(function(...) {
[18:01:57.658]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.658]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.658]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.658]             on.exit(options(oopts), add = TRUE)
[18:01:57.658]         }
[18:01:57.658]         {
[18:01:57.658]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.658]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.658]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.658]             })
[18:01:57.658]         }
[18:01:57.658]     }, args = future.call.arguments)
[18:01:57.658] }
[18:01:57.658] Lazy evaluation: FALSE
[18:01:57.658] Asynchronous evaluation: TRUE
[18:01:57.658] Local evaluation: TRUE
[18:01:57.658] Environment: R_GlobalEnv
[18:01:57.658] Capture standard output: TRUE
[18:01:57.658] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:57.658] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:57.658] Packages: 1 packages (‘future.apply’)
[18:01:57.658] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:57.658] Resolved: FALSE
[18:01:57.658] Value: <not collected>
[18:01:57.658] Conditions captured: <none>
[18:01:57.658] Early signaling: FALSE
[18:01:57.658] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:57.658] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.674] Chunk #1 of 2 ... DONE
[18:01:57.675] Chunk #2 of 2 ...
[18:01:57.675]  - Finding globals in 'X' for chunk #2 ...
[18:01:57.676] getGlobalsAndPackages() ...
[18:01:57.676] Searching for globals...
[18:01:57.677] 
[18:01:57.677] plan(): nbrOfWorkers() = 2
[18:01:57.677] Searching for globals ... DONE
[18:01:57.678] - globals: [0] <none>
[18:01:57.678] getGlobalsAndPackages() ... DONE
[18:01:57.678]    + additional globals found: [n=0] 
[18:01:57.678]    + additional namespaces needed: [n=0] 
[18:01:57.679]  - Finding globals in 'X' for chunk #2 ... DONE
[18:01:57.679]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:57.679]  - seeds: <none>
[18:01:57.679]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.680] getGlobalsAndPackages() ...
[18:01:57.680] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.681] Resolving globals: FALSE
[18:01:57.681] Tweak future expression to call with '...' arguments ...
[18:01:57.682] {
[18:01:57.682]     do.call(function(...) {
[18:01:57.682]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.682]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.682]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.682]             on.exit(options(oopts), add = TRUE)
[18:01:57.682]         }
[18:01:57.682]         {
[18:01:57.682]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.682]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.682]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.682]             })
[18:01:57.682]         }
[18:01:57.682]     }, args = future.call.arguments)
[18:01:57.682] }
[18:01:57.682] Tweak future expression to call with '...' arguments ... DONE
[18:01:57.685] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.685] - packages: [1] ‘future.apply’
[18:01:57.685] getGlobalsAndPackages() ... DONE
[18:01:57.686] run() for ‘Future’ ...
[18:01:57.687] - state: ‘created’
[18:01:57.687] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:57.695] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.696] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:57.696]   - Field: ‘label’
[18:01:57.697]   - Field: ‘local’
[18:01:57.697]   - Field: ‘owner’
[18:01:57.697]   - Field: ‘envir’
[18:01:57.698]   - Field: ‘workers’
[18:01:57.698]   - Field: ‘packages’
[18:01:57.698]   - Field: ‘gc’
[18:01:57.699]   - Field: ‘job’
[18:01:57.699]   - Field: ‘conditions’
[18:01:57.699]   - Field: ‘expr’
[18:01:57.700]   - Field: ‘uuid’
[18:01:57.700]   - Field: ‘seed’
[18:01:57.700]   - Field: ‘version’
[18:01:57.701]   - Field: ‘result’
[18:01:57.701]   - Field: ‘asynchronous’
[18:01:57.701]   - Field: ‘calls’
[18:01:57.702]   - Field: ‘globals’
[18:01:57.702]   - Field: ‘stdout’
[18:01:57.702]   - Field: ‘earlySignal’
[18:01:57.703]   - Field: ‘lazy’
[18:01:57.703]   - Field: ‘state’
[18:01:57.703] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:57.703] - Launch lazy future ...
[18:01:57.704] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:57.705] Packages needed by future strategies (n = 0): <none>
[18:01:57.707] {
[18:01:57.707]     {
[18:01:57.707]         {
[18:01:57.707]             ...future.startTime <- base::Sys.time()
[18:01:57.707]             {
[18:01:57.707]                 {
[18:01:57.707]                   {
[18:01:57.707]                     {
[18:01:57.707]                       {
[18:01:57.707]                         base::local({
[18:01:57.707]                           has_future <- base::requireNamespace("future", 
[18:01:57.707]                             quietly = TRUE)
[18:01:57.707]                           if (has_future) {
[18:01:57.707]                             ns <- base::getNamespace("future")
[18:01:57.707]                             version <- ns[[".package"]][["version"]]
[18:01:57.707]                             if (is.null(version)) 
[18:01:57.707]                               version <- utils::packageVersion("future")
[18:01:57.707]                           }
[18:01:57.707]                           else {
[18:01:57.707]                             version <- NULL
[18:01:57.707]                           }
[18:01:57.707]                           if (!has_future || version < "1.8.0") {
[18:01:57.707]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:57.707]                               "", base::R.version$version.string), 
[18:01:57.707]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:57.707]                                 base::R.version$platform, 8 * 
[18:01:57.707]                                   base::.Machine$sizeof.pointer), 
[18:01:57.707]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:57.707]                                 "release", "version")], collapse = " "), 
[18:01:57.707]                               hostname = base::Sys.info()[["nodename"]])
[18:01:57.707]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:57.707]                               info)
[18:01:57.707]                             info <- base::paste(info, collapse = "; ")
[18:01:57.707]                             if (!has_future) {
[18:01:57.707]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:57.707]                                 info)
[18:01:57.707]                             }
[18:01:57.707]                             else {
[18:01:57.707]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:57.707]                                 info, version)
[18:01:57.707]                             }
[18:01:57.707]                             base::stop(msg)
[18:01:57.707]                           }
[18:01:57.707]                         })
[18:01:57.707]                       }
[18:01:57.707]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:57.707]                       base::options(mc.cores = 1L)
[18:01:57.707]                     }
[18:01:57.707]                     base::local({
[18:01:57.707]                       for (pkg in "future.apply") {
[18:01:57.707]                         base::loadNamespace(pkg)
[18:01:57.707]                         base::library(pkg, character.only = TRUE)
[18:01:57.707]                       }
[18:01:57.707]                     })
[18:01:57.707]                   }
[18:01:57.707]                   ...future.strategy.old <- future::plan("list")
[18:01:57.707]                   options(future.plan = NULL)
[18:01:57.707]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.707]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:57.707]                 }
[18:01:57.707]                 ...future.workdir <- getwd()
[18:01:57.707]             }
[18:01:57.707]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:57.707]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:57.707]         }
[18:01:57.707]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:57.707]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:57.707]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:57.707]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:57.707]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:57.707]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:57.707]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:57.707]             base::names(...future.oldOptions))
[18:01:57.707]     }
[18:01:57.707]     if (FALSE) {
[18:01:57.707]     }
[18:01:57.707]     else {
[18:01:57.707]         if (TRUE) {
[18:01:57.707]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:57.707]                 open = "w")
[18:01:57.707]         }
[18:01:57.707]         else {
[18:01:57.707]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:57.707]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:57.707]         }
[18:01:57.707]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:57.707]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:57.707]             base::sink(type = "output", split = FALSE)
[18:01:57.707]             base::close(...future.stdout)
[18:01:57.707]         }, add = TRUE)
[18:01:57.707]     }
[18:01:57.707]     ...future.frame <- base::sys.nframe()
[18:01:57.707]     ...future.conditions <- base::list()
[18:01:57.707]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:57.707]     if (FALSE) {
[18:01:57.707]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:57.707]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:57.707]     }
[18:01:57.707]     ...future.result <- base::tryCatch({
[18:01:57.707]         base::withCallingHandlers({
[18:01:57.707]             ...future.value <- base::withVisible(base::local({
[18:01:57.707]                 withCallingHandlers({
[18:01:57.707]                   {
[18:01:57.707]                     do.call(function(...) {
[18:01:57.707]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.707]                       if (!identical(...future.globals.maxSize.org, 
[18:01:57.707]                         ...future.globals.maxSize)) {
[18:01:57.707]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.707]                         on.exit(options(oopts), add = TRUE)
[18:01:57.707]                       }
[18:01:57.707]                       {
[18:01:57.707]                         lapply(seq_along(...future.elements_ii), 
[18:01:57.707]                           FUN = function(jj) {
[18:01:57.707]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.707]                             ...future.FUN(...future.X_jj, ...)
[18:01:57.707]                           })
[18:01:57.707]                       }
[18:01:57.707]                     }, args = future.call.arguments)
[18:01:57.707]                   }
[18:01:57.707]                 }, immediateCondition = function(cond) {
[18:01:57.707]                   save_rds <- function (object, pathname, ...) 
[18:01:57.707]                   {
[18:01:57.707]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:57.707]                     if (file_test("-f", pathname_tmp)) {
[18:01:57.707]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.707]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:57.707]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.707]                         fi_tmp[["mtime"]])
[18:01:57.707]                     }
[18:01:57.707]                     tryCatch({
[18:01:57.707]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:57.707]                     }, error = function(ex) {
[18:01:57.707]                       msg <- conditionMessage(ex)
[18:01:57.707]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.707]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:57.707]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.707]                         fi_tmp[["mtime"]], msg)
[18:01:57.707]                       ex$message <- msg
[18:01:57.707]                       stop(ex)
[18:01:57.707]                     })
[18:01:57.707]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:57.707]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:57.707]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:57.707]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.707]                       fi <- file.info(pathname)
[18:01:57.707]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:57.707]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.707]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:57.707]                         fi[["size"]], fi[["mtime"]])
[18:01:57.707]                       stop(msg)
[18:01:57.707]                     }
[18:01:57.707]                     invisible(pathname)
[18:01:57.707]                   }
[18:01:57.707]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:57.707]                     rootPath = tempdir()) 
[18:01:57.707]                   {
[18:01:57.707]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:57.707]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:57.707]                       tmpdir = path, fileext = ".rds")
[18:01:57.707]                     save_rds(obj, file)
[18:01:57.707]                   }
[18:01:57.707]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:57.707]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.707]                   {
[18:01:57.707]                     inherits <- base::inherits
[18:01:57.707]                     invokeRestart <- base::invokeRestart
[18:01:57.707]                     is.null <- base::is.null
[18:01:57.707]                     muffled <- FALSE
[18:01:57.707]                     if (inherits(cond, "message")) {
[18:01:57.707]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:57.707]                       if (muffled) 
[18:01:57.707]                         invokeRestart("muffleMessage")
[18:01:57.707]                     }
[18:01:57.707]                     else if (inherits(cond, "warning")) {
[18:01:57.707]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:57.707]                       if (muffled) 
[18:01:57.707]                         invokeRestart("muffleWarning")
[18:01:57.707]                     }
[18:01:57.707]                     else if (inherits(cond, "condition")) {
[18:01:57.707]                       if (!is.null(pattern)) {
[18:01:57.707]                         computeRestarts <- base::computeRestarts
[18:01:57.707]                         grepl <- base::grepl
[18:01:57.707]                         restarts <- computeRestarts(cond)
[18:01:57.707]                         for (restart in restarts) {
[18:01:57.707]                           name <- restart$name
[18:01:57.707]                           if (is.null(name)) 
[18:01:57.707]                             next
[18:01:57.707]                           if (!grepl(pattern, name)) 
[18:01:57.707]                             next
[18:01:57.707]                           invokeRestart(restart)
[18:01:57.707]                           muffled <- TRUE
[18:01:57.707]                           break
[18:01:57.707]                         }
[18:01:57.707]                       }
[18:01:57.707]                     }
[18:01:57.707]                     invisible(muffled)
[18:01:57.707]                   }
[18:01:57.707]                   muffleCondition(cond)
[18:01:57.707]                 })
[18:01:57.707]             }))
[18:01:57.707]             future::FutureResult(value = ...future.value$value, 
[18:01:57.707]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.707]                   ...future.rng), globalenv = if (FALSE) 
[18:01:57.707]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:57.707]                     ...future.globalenv.names))
[18:01:57.707]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:57.707]         }, condition = base::local({
[18:01:57.707]             c <- base::c
[18:01:57.707]             inherits <- base::inherits
[18:01:57.707]             invokeRestart <- base::invokeRestart
[18:01:57.707]             length <- base::length
[18:01:57.707]             list <- base::list
[18:01:57.707]             seq.int <- base::seq.int
[18:01:57.707]             signalCondition <- base::signalCondition
[18:01:57.707]             sys.calls <- base::sys.calls
[18:01:57.707]             `[[` <- base::`[[`
[18:01:57.707]             `+` <- base::`+`
[18:01:57.707]             `<<-` <- base::`<<-`
[18:01:57.707]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:57.707]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:57.707]                   3L)]
[18:01:57.707]             }
[18:01:57.707]             function(cond) {
[18:01:57.707]                 is_error <- inherits(cond, "error")
[18:01:57.707]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:57.707]                   NULL)
[18:01:57.707]                 if (is_error) {
[18:01:57.707]                   sessionInformation <- function() {
[18:01:57.707]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:57.707]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:57.707]                       search = base::search(), system = base::Sys.info())
[18:01:57.707]                   }
[18:01:57.707]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.707]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:57.707]                     cond$call), session = sessionInformation(), 
[18:01:57.707]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:57.707]                   signalCondition(cond)
[18:01:57.707]                 }
[18:01:57.707]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:57.707]                 "immediateCondition"))) {
[18:01:57.707]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:57.707]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.707]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:57.707]                   if (TRUE && !signal) {
[18:01:57.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.707]                     {
[18:01:57.707]                       inherits <- base::inherits
[18:01:57.707]                       invokeRestart <- base::invokeRestart
[18:01:57.707]                       is.null <- base::is.null
[18:01:57.707]                       muffled <- FALSE
[18:01:57.707]                       if (inherits(cond, "message")) {
[18:01:57.707]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.707]                         if (muffled) 
[18:01:57.707]                           invokeRestart("muffleMessage")
[18:01:57.707]                       }
[18:01:57.707]                       else if (inherits(cond, "warning")) {
[18:01:57.707]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.707]                         if (muffled) 
[18:01:57.707]                           invokeRestart("muffleWarning")
[18:01:57.707]                       }
[18:01:57.707]                       else if (inherits(cond, "condition")) {
[18:01:57.707]                         if (!is.null(pattern)) {
[18:01:57.707]                           computeRestarts <- base::computeRestarts
[18:01:57.707]                           grepl <- base::grepl
[18:01:57.707]                           restarts <- computeRestarts(cond)
[18:01:57.707]                           for (restart in restarts) {
[18:01:57.707]                             name <- restart$name
[18:01:57.707]                             if (is.null(name)) 
[18:01:57.707]                               next
[18:01:57.707]                             if (!grepl(pattern, name)) 
[18:01:57.707]                               next
[18:01:57.707]                             invokeRestart(restart)
[18:01:57.707]                             muffled <- TRUE
[18:01:57.707]                             break
[18:01:57.707]                           }
[18:01:57.707]                         }
[18:01:57.707]                       }
[18:01:57.707]                       invisible(muffled)
[18:01:57.707]                     }
[18:01:57.707]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.707]                   }
[18:01:57.707]                 }
[18:01:57.707]                 else {
[18:01:57.707]                   if (TRUE) {
[18:01:57.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.707]                     {
[18:01:57.707]                       inherits <- base::inherits
[18:01:57.707]                       invokeRestart <- base::invokeRestart
[18:01:57.707]                       is.null <- base::is.null
[18:01:57.707]                       muffled <- FALSE
[18:01:57.707]                       if (inherits(cond, "message")) {
[18:01:57.707]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.707]                         if (muffled) 
[18:01:57.707]                           invokeRestart("muffleMessage")
[18:01:57.707]                       }
[18:01:57.707]                       else if (inherits(cond, "warning")) {
[18:01:57.707]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.707]                         if (muffled) 
[18:01:57.707]                           invokeRestart("muffleWarning")
[18:01:57.707]                       }
[18:01:57.707]                       else if (inherits(cond, "condition")) {
[18:01:57.707]                         if (!is.null(pattern)) {
[18:01:57.707]                           computeRestarts <- base::computeRestarts
[18:01:57.707]                           grepl <- base::grepl
[18:01:57.707]                           restarts <- computeRestarts(cond)
[18:01:57.707]                           for (restart in restarts) {
[18:01:57.707]                             name <- restart$name
[18:01:57.707]                             if (is.null(name)) 
[18:01:57.707]                               next
[18:01:57.707]                             if (!grepl(pattern, name)) 
[18:01:57.707]                               next
[18:01:57.707]                             invokeRestart(restart)
[18:01:57.707]                             muffled <- TRUE
[18:01:57.707]                             break
[18:01:57.707]                           }
[18:01:57.707]                         }
[18:01:57.707]                       }
[18:01:57.707]                       invisible(muffled)
[18:01:57.707]                     }
[18:01:57.707]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.707]                   }
[18:01:57.707]                 }
[18:01:57.707]             }
[18:01:57.707]         }))
[18:01:57.707]     }, error = function(ex) {
[18:01:57.707]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:57.707]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.707]                 ...future.rng), started = ...future.startTime, 
[18:01:57.707]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:57.707]             version = "1.8"), class = "FutureResult")
[18:01:57.707]     }, finally = {
[18:01:57.707]         if (!identical(...future.workdir, getwd())) 
[18:01:57.707]             setwd(...future.workdir)
[18:01:57.707]         {
[18:01:57.707]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:57.707]                 ...future.oldOptions$nwarnings <- NULL
[18:01:57.707]             }
[18:01:57.707]             base::options(...future.oldOptions)
[18:01:57.707]             if (.Platform$OS.type == "windows") {
[18:01:57.707]                 old_names <- names(...future.oldEnvVars)
[18:01:57.707]                 envs <- base::Sys.getenv()
[18:01:57.707]                 names <- names(envs)
[18:01:57.707]                 common <- intersect(names, old_names)
[18:01:57.707]                 added <- setdiff(names, old_names)
[18:01:57.707]                 removed <- setdiff(old_names, names)
[18:01:57.707]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:57.707]                   envs[common]]
[18:01:57.707]                 NAMES <- toupper(changed)
[18:01:57.707]                 args <- list()
[18:01:57.707]                 for (kk in seq_along(NAMES)) {
[18:01:57.707]                   name <- changed[[kk]]
[18:01:57.707]                   NAME <- NAMES[[kk]]
[18:01:57.707]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.707]                     next
[18:01:57.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.707]                 }
[18:01:57.707]                 NAMES <- toupper(added)
[18:01:57.707]                 for (kk in seq_along(NAMES)) {
[18:01:57.707]                   name <- added[[kk]]
[18:01:57.707]                   NAME <- NAMES[[kk]]
[18:01:57.707]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.707]                     next
[18:01:57.707]                   args[[name]] <- ""
[18:01:57.707]                 }
[18:01:57.707]                 NAMES <- toupper(removed)
[18:01:57.707]                 for (kk in seq_along(NAMES)) {
[18:01:57.707]                   name <- removed[[kk]]
[18:01:57.707]                   NAME <- NAMES[[kk]]
[18:01:57.707]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.707]                     next
[18:01:57.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.707]                 }
[18:01:57.707]                 if (length(args) > 0) 
[18:01:57.707]                   base::do.call(base::Sys.setenv, args = args)
[18:01:57.707]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:57.707]             }
[18:01:57.707]             else {
[18:01:57.707]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:57.707]             }
[18:01:57.707]             {
[18:01:57.707]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:57.707]                   0L) {
[18:01:57.707]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:57.707]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:57.707]                   base::options(opts)
[18:01:57.707]                 }
[18:01:57.707]                 {
[18:01:57.707]                   {
[18:01:57.707]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:57.707]                     NULL
[18:01:57.707]                   }
[18:01:57.707]                   options(future.plan = NULL)
[18:01:57.707]                   if (is.na(NA_character_)) 
[18:01:57.707]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.707]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:57.707]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:57.707]                     .init = FALSE)
[18:01:57.707]                 }
[18:01:57.707]             }
[18:01:57.707]         }
[18:01:57.707]     })
[18:01:57.707]     if (TRUE) {
[18:01:57.707]         base::sink(type = "output", split = FALSE)
[18:01:57.707]         if (TRUE) {
[18:01:57.707]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:57.707]         }
[18:01:57.707]         else {
[18:01:57.707]             ...future.result["stdout"] <- base::list(NULL)
[18:01:57.707]         }
[18:01:57.707]         base::close(...future.stdout)
[18:01:57.707]         ...future.stdout <- NULL
[18:01:57.707]     }
[18:01:57.707]     ...future.result$conditions <- ...future.conditions
[18:01:57.707]     ...future.result$finished <- base::Sys.time()
[18:01:57.707]     ...future.result
[18:01:57.707] }
[18:01:57.714] assign_globals() ...
[18:01:57.714] List of 11
[18:01:57.714]  $ ...future.FUN            :function (x, ...)  
[18:01:57.714]  $ x_FUN                    :function (x)  
[18:01:57.714]  $ times                    : int 0
[18:01:57.714]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:57.714]  $ stop_if_not              :function (...)  
[18:01:57.714]  $ dim                      : NULL
[18:01:57.714]  $ valid_types              : chr [1:2] "logical" "integer"
[18:01:57.714]  $ future.call.arguments    : list()
[18:01:57.714]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.714]  $ ...future.elements_ii    :List of 5
[18:01:57.714]   ..$ : int 6
[18:01:57.714]   ..$ : int 7
[18:01:57.714]   ..$ : int 8
[18:01:57.714]   ..$ : int 9
[18:01:57.714]   ..$ : int 10
[18:01:57.714]  $ ...future.seeds_ii       : NULL
[18:01:57.714]  $ ...future.globals.maxSize: NULL
[18:01:57.714]  - attr(*, "where")=List of 11
[18:01:57.714]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:57.714]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:57.714]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:57.714]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:57.714]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:57.714]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:57.714]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:57.714]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:57.714]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:57.714]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:57.714]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:57.714]  - attr(*, "resolved")= logi FALSE
[18:01:57.714]  - attr(*, "total_size")= num 95400
[18:01:57.714]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.714]  - attr(*, "already-done")= logi TRUE
[18:01:57.743] - copied ‘...future.FUN’ to environment
[18:01:57.743] - reassign environment for ‘x_FUN’
[18:01:57.743] - copied ‘x_FUN’ to environment
[18:01:57.744] - copied ‘times’ to environment
[18:01:57.744] - copied ‘stopf’ to environment
[18:01:57.744] - copied ‘stop_if_not’ to environment
[18:01:57.745] - copied ‘dim’ to environment
[18:01:57.745] - copied ‘valid_types’ to environment
[18:01:57.745] - copied ‘future.call.arguments’ to environment
[18:01:57.746] - copied ‘...future.elements_ii’ to environment
[18:01:57.746] - copied ‘...future.seeds_ii’ to environment
[18:01:57.746] - copied ‘...future.globals.maxSize’ to environment
[18:01:57.747] assign_globals() ... done
[18:01:57.747] requestCore(): workers = 2
[18:01:57.751] MulticoreFuture started
[18:01:57.752] - Launch lazy future ... done
[18:01:57.754] run() for ‘MulticoreFuture’ ... done
[18:01:57.755] Created future:
[18:01:57.755] plan(): Setting new future strategy stack:
[18:01:57.756] List of future strategies:
[18:01:57.756] 1. sequential:
[18:01:57.756]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:57.756]    - tweaked: FALSE
[18:01:57.756]    - call: NULL
[18:01:57.759] plan(): nbrOfWorkers() = 1
[18:01:57.763] plan(): Setting new future strategy stack:
[18:01:57.764] List of future strategies:
[18:01:57.764] 1. multicore:
[18:01:57.764]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:57.764]    - tweaked: FALSE
[18:01:57.764]    - call: plan(strategy)
[18:01:57.755] MulticoreFuture:
[18:01:57.755] Label: ‘future_vapply-2’
[18:01:57.755] Expression:
[18:01:57.755] {
[18:01:57.755]     do.call(function(...) {
[18:01:57.755]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.755]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.755]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.755]             on.exit(options(oopts), add = TRUE)
[18:01:57.755]         }
[18:01:57.755]         {
[18:01:57.755]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.755]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.755]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.755]             })
[18:01:57.755]         }
[18:01:57.755]     }, args = future.call.arguments)
[18:01:57.755] }
[18:01:57.755] Lazy evaluation: FALSE
[18:01:57.755] Asynchronous evaluation: TRUE
[18:01:57.755] Local evaluation: TRUE
[18:01:57.755] Environment: R_GlobalEnv
[18:01:57.755] Capture standard output: TRUE
[18:01:57.755] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:57.755] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:57.755] Packages: 1 packages (‘future.apply’)
[18:01:57.755] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:57.755] Resolved: FALSE
[18:01:57.755] Value: <not collected>
[18:01:57.755] Conditions captured: <none>
[18:01:57.755] Early signaling: FALSE
[18:01:57.755] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:57.755] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.773] Chunk #2 of 2 ... DONE
[18:01:57.773] Launching 2 futures (chunks) ... DONE
[18:01:57.773] Resolving 2 futures (chunks) ...
[18:01:57.774] resolve() on list ...
[18:01:57.774]  recursive: 0
[18:01:57.774] plan(): nbrOfWorkers() = 2
[18:01:57.774]  length: 2
[18:01:57.775] 
[18:01:57.775] Future #1
[18:01:57.776] result() for MulticoreFuture ...
[18:01:57.777] result() for MulticoreFuture ...
[18:01:57.778] result() for MulticoreFuture ... done
[18:01:57.778] result() for MulticoreFuture ... done
[18:01:57.778] result() for MulticoreFuture ...
[18:01:57.778] result() for MulticoreFuture ... done
[18:01:57.779] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:57.779] - nx: 2
[18:01:57.779] - relay: TRUE
[18:01:57.780] - stdout: TRUE
[18:01:57.780] - signal: TRUE
[18:01:57.780] - resignal: FALSE
[18:01:57.781] - force: TRUE
[18:01:57.781] - relayed: [n=2] FALSE, FALSE
[18:01:57.781] - queued futures: [n=2] FALSE, FALSE
[18:01:57.782]  - until=1
[18:01:57.782]  - relaying element #1
[18:01:57.782] result() for MulticoreFuture ...
[18:01:57.783] result() for MulticoreFuture ... done
[18:01:57.783] result() for MulticoreFuture ...
[18:01:57.783] result() for MulticoreFuture ... done
[18:01:57.784] result() for MulticoreFuture ...
[18:01:57.784] result() for MulticoreFuture ... done
[18:01:57.784] result() for MulticoreFuture ...
[18:01:57.785] result() for MulticoreFuture ... done
[18:01:57.785] - relayed: [n=2] TRUE, FALSE
[18:01:57.785] - queued futures: [n=2] TRUE, FALSE
[18:01:57.785] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:57.786]  length: 1 (resolved future 1)
[18:01:57.786] Future #2
[18:01:57.787] result() for MulticoreFuture ...
[18:01:57.788] result() for MulticoreFuture ...
[18:01:57.788] result() for MulticoreFuture ... done
[18:01:57.789] result() for MulticoreFuture ... done
[18:01:57.789] result() for MulticoreFuture ...
[18:01:57.789] result() for MulticoreFuture ... done
[18:01:57.790] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:57.790] - nx: 2
[18:01:57.790] - relay: TRUE
[18:01:57.790] - stdout: TRUE
[18:01:57.790] - signal: TRUE
[18:01:57.791] - resignal: FALSE
[18:01:57.791] - force: TRUE
[18:01:57.791] - relayed: [n=2] TRUE, FALSE
[18:01:57.791] - queued futures: [n=2] TRUE, FALSE
[18:01:57.792]  - until=2
[18:01:57.792]  - relaying element #2
[18:01:57.792] result() for MulticoreFuture ...
[18:01:57.792] result() for MulticoreFuture ... done
[18:01:57.793] result() for MulticoreFuture ...
[18:01:57.793] result() for MulticoreFuture ... done
[18:01:57.793] result() for MulticoreFuture ...
[18:01:57.793] result() for MulticoreFuture ... done
[18:01:57.794] result() for MulticoreFuture ...
[18:01:57.794] result() for MulticoreFuture ... done
[18:01:57.794] - relayed: [n=2] TRUE, TRUE
[18:01:57.794] - queued futures: [n=2] TRUE, TRUE
[18:01:57.794] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:57.795]  length: 0 (resolved future 2)
[18:01:57.795] Relaying remaining futures
[18:01:57.795] signalConditionsASAP(NULL, pos=0) ...
[18:01:57.795] - nx: 2
[18:01:57.795] - relay: TRUE
[18:01:57.796] - stdout: TRUE
[18:01:57.796] - signal: TRUE
[18:01:57.796] - resignal: FALSE
[18:01:57.796] - force: TRUE
[18:01:57.796] - relayed: [n=2] TRUE, TRUE
[18:01:57.797] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:57.797] - relayed: [n=2] TRUE, TRUE
[18:01:57.797] - queued futures: [n=2] TRUE, TRUE
[18:01:57.798] signalConditionsASAP(NULL, pos=0) ... done
[18:01:57.798] resolve() on list ... DONE
[18:01:57.798] result() for MulticoreFuture ...
[18:01:57.798] result() for MulticoreFuture ... done
[18:01:57.798] result() for MulticoreFuture ...
[18:01:57.799] result() for MulticoreFuture ... done
[18:01:57.799] result() for MulticoreFuture ...
[18:01:57.799] result() for MulticoreFuture ... done
[18:01:57.799] result() for MulticoreFuture ...
[18:01:57.800] result() for MulticoreFuture ... done
[18:01:57.800]  - Number of value chunks collected: 2
[18:01:57.800] Resolving 2 futures (chunks) ... DONE
[18:01:57.800] Reducing values from 2 chunks ...
[18:01:57.800]  - Number of values collected after concatenation: 10
[18:01:57.801]  - Number of values expected: 10
[18:01:57.801] Reducing values from 2 chunks ... DONE
[18:01:57.801] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[18:01:57.803] future_lapply() ...
[18:01:57.814] Number of chunks: 2
[18:01:57.814] getGlobalsAndPackagesXApply() ...
[18:01:57.815]  - future.globals: TRUE
[18:01:57.815] getGlobalsAndPackages() ...
[18:01:57.815] Searching for globals...
[18:01:57.825] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:01:57.825] Searching for globals ... DONE
[18:01:57.825] Resolving globals: FALSE
[18:01:57.827] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[18:01:57.828] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:57.829] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:57.829] - packages: [1] ‘future.apply’
[18:01:57.829] getGlobalsAndPackages() ... DONE
[18:01:57.830]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:57.830]  - needed namespaces: [n=1] ‘future.apply’
[18:01:57.830] Finding globals ... DONE
[18:01:57.830]  - use_args: TRUE
[18:01:57.830]  - Getting '...' globals ...
[18:01:57.831] resolve() on list ...
[18:01:57.831]  recursive: 0
[18:01:57.832]  length: 1
[18:01:57.832]  elements: ‘...’
[18:01:57.832]  length: 0 (resolved future 1)
[18:01:57.832] resolve() on list ... DONE
[18:01:57.832]    - '...' content: [n=0] 
[18:01:57.833] List of 1
[18:01:57.833]  $ ...: list()
[18:01:57.833]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.833]  - attr(*, "where")=List of 1
[18:01:57.833]   ..$ ...:<environment: 0x6183c09940e8> 
[18:01:57.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.833]  - attr(*, "resolved")= logi TRUE
[18:01:57.833]  - attr(*, "total_size")= num NA
[18:01:57.838]  - Getting '...' globals ... DONE
[18:01:57.838] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:57.838] List of 8
[18:01:57.838]  $ ...future.FUN:function (x, ...)  
[18:01:57.838]  $ x_FUN        :function (x)  
[18:01:57.838]  $ times        : int 1
[18:01:57.838]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:57.838]  $ stop_if_not  :function (...)  
[18:01:57.838]  $ dim          : NULL
[18:01:57.838]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:57.838]  $ ...          : list()
[18:01:57.838]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.838]  - attr(*, "where")=List of 8
[18:01:57.838]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:57.838]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:57.838]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:57.838]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:57.838]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:57.838]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:57.838]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:57.838]   ..$ ...          :<environment: 0x6183c09940e8> 
[18:01:57.838]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.838]  - attr(*, "resolved")= logi FALSE
[18:01:57.838]  - attr(*, "total_size")= num 94336
[18:01:57.849] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:57.849] getGlobalsAndPackagesXApply() ... DONE
[18:01:57.850] Number of futures (= number of chunks): 2
[18:01:57.850] Launching 2 futures (chunks) ...
[18:01:57.850] Chunk #1 of 2 ...
[18:01:57.851]  - Finding globals in 'X' for chunk #1 ...
[18:01:57.851] getGlobalsAndPackages() ...
[18:01:57.851] Searching for globals...
[18:01:57.851] 
[18:01:57.852] Searching for globals ... DONE
[18:01:57.852] - globals: [0] <none>
[18:01:57.852] getGlobalsAndPackages() ... DONE
[18:01:57.852]    + additional globals found: [n=0] 
[18:01:57.852]    + additional namespaces needed: [n=0] 
[18:01:57.853]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:57.853]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:57.853]  - seeds: <none>
[18:01:57.853]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.853] getGlobalsAndPackages() ...
[18:01:57.854] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.854] Resolving globals: FALSE
[18:01:57.854] Tweak future expression to call with '...' arguments ...
[18:01:57.854] {
[18:01:57.854]     do.call(function(...) {
[18:01:57.854]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.854]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.854]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.854]             on.exit(options(oopts), add = TRUE)
[18:01:57.854]         }
[18:01:57.854]         {
[18:01:57.854]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.854]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.854]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.854]             })
[18:01:57.854]         }
[18:01:57.854]     }, args = future.call.arguments)
[18:01:57.854] }
[18:01:57.855] Tweak future expression to call with '...' arguments ... DONE
[18:01:57.856] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.856] - packages: [1] ‘future.apply’
[18:01:57.856] getGlobalsAndPackages() ... DONE
[18:01:57.857] run() for ‘Future’ ...
[18:01:57.857] - state: ‘created’
[18:01:57.858] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:57.864] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.864] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:57.865]   - Field: ‘label’
[18:01:57.865]   - Field: ‘local’
[18:01:57.865]   - Field: ‘owner’
[18:01:57.865]   - Field: ‘envir’
[18:01:57.866]   - Field: ‘workers’
[18:01:57.866]   - Field: ‘packages’
[18:01:57.866]   - Field: ‘gc’
[18:01:57.866]   - Field: ‘job’
[18:01:57.866]   - Field: ‘conditions’
[18:01:57.867]   - Field: ‘expr’
[18:01:57.867]   - Field: ‘uuid’
[18:01:57.867]   - Field: ‘seed’
[18:01:57.867]   - Field: ‘version’
[18:01:57.867]   - Field: ‘result’
[18:01:57.868]   - Field: ‘asynchronous’
[18:01:57.868]   - Field: ‘calls’
[18:01:57.868]   - Field: ‘globals’
[18:01:57.868]   - Field: ‘stdout’
[18:01:57.868]   - Field: ‘earlySignal’
[18:01:57.869]   - Field: ‘lazy’
[18:01:57.869]   - Field: ‘state’
[18:01:57.869] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:57.869] - Launch lazy future ...
[18:01:57.870] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:57.870] Packages needed by future strategies (n = 0): <none>
[18:01:57.874] {
[18:01:57.874]     {
[18:01:57.874]         {
[18:01:57.874]             ...future.startTime <- base::Sys.time()
[18:01:57.874]             {
[18:01:57.874]                 {
[18:01:57.874]                   {
[18:01:57.874]                     {
[18:01:57.874]                       {
[18:01:57.874]                         base::local({
[18:01:57.874]                           has_future <- base::requireNamespace("future", 
[18:01:57.874]                             quietly = TRUE)
[18:01:57.874]                           if (has_future) {
[18:01:57.874]                             ns <- base::getNamespace("future")
[18:01:57.874]                             version <- ns[[".package"]][["version"]]
[18:01:57.874]                             if (is.null(version)) 
[18:01:57.874]                               version <- utils::packageVersion("future")
[18:01:57.874]                           }
[18:01:57.874]                           else {
[18:01:57.874]                             version <- NULL
[18:01:57.874]                           }
[18:01:57.874]                           if (!has_future || version < "1.8.0") {
[18:01:57.874]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:57.874]                               "", base::R.version$version.string), 
[18:01:57.874]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:57.874]                                 base::R.version$platform, 8 * 
[18:01:57.874]                                   base::.Machine$sizeof.pointer), 
[18:01:57.874]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:57.874]                                 "release", "version")], collapse = " "), 
[18:01:57.874]                               hostname = base::Sys.info()[["nodename"]])
[18:01:57.874]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:57.874]                               info)
[18:01:57.874]                             info <- base::paste(info, collapse = "; ")
[18:01:57.874]                             if (!has_future) {
[18:01:57.874]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:57.874]                                 info)
[18:01:57.874]                             }
[18:01:57.874]                             else {
[18:01:57.874]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:57.874]                                 info, version)
[18:01:57.874]                             }
[18:01:57.874]                             base::stop(msg)
[18:01:57.874]                           }
[18:01:57.874]                         })
[18:01:57.874]                       }
[18:01:57.874]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:57.874]                       base::options(mc.cores = 1L)
[18:01:57.874]                     }
[18:01:57.874]                     base::local({
[18:01:57.874]                       for (pkg in "future.apply") {
[18:01:57.874]                         base::loadNamespace(pkg)
[18:01:57.874]                         base::library(pkg, character.only = TRUE)
[18:01:57.874]                       }
[18:01:57.874]                     })
[18:01:57.874]                   }
[18:01:57.874]                   ...future.strategy.old <- future::plan("list")
[18:01:57.874]                   options(future.plan = NULL)
[18:01:57.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:57.874]                 }
[18:01:57.874]                 ...future.workdir <- getwd()
[18:01:57.874]             }
[18:01:57.874]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:57.874]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:57.874]         }
[18:01:57.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:57.874]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:57.874]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:57.874]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:57.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:57.874]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:57.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:57.874]             base::names(...future.oldOptions))
[18:01:57.874]     }
[18:01:57.874]     if (FALSE) {
[18:01:57.874]     }
[18:01:57.874]     else {
[18:01:57.874]         if (TRUE) {
[18:01:57.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:57.874]                 open = "w")
[18:01:57.874]         }
[18:01:57.874]         else {
[18:01:57.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:57.874]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:57.874]         }
[18:01:57.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:57.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:57.874]             base::sink(type = "output", split = FALSE)
[18:01:57.874]             base::close(...future.stdout)
[18:01:57.874]         }, add = TRUE)
[18:01:57.874]     }
[18:01:57.874]     ...future.frame <- base::sys.nframe()
[18:01:57.874]     ...future.conditions <- base::list()
[18:01:57.874]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:57.874]     if (FALSE) {
[18:01:57.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:57.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:57.874]     }
[18:01:57.874]     ...future.result <- base::tryCatch({
[18:01:57.874]         base::withCallingHandlers({
[18:01:57.874]             ...future.value <- base::withVisible(base::local({
[18:01:57.874]                 withCallingHandlers({
[18:01:57.874]                   {
[18:01:57.874]                     do.call(function(...) {
[18:01:57.874]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.874]                       if (!identical(...future.globals.maxSize.org, 
[18:01:57.874]                         ...future.globals.maxSize)) {
[18:01:57.874]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.874]                         on.exit(options(oopts), add = TRUE)
[18:01:57.874]                       }
[18:01:57.874]                       {
[18:01:57.874]                         lapply(seq_along(...future.elements_ii), 
[18:01:57.874]                           FUN = function(jj) {
[18:01:57.874]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.874]                             ...future.FUN(...future.X_jj, ...)
[18:01:57.874]                           })
[18:01:57.874]                       }
[18:01:57.874]                     }, args = future.call.arguments)
[18:01:57.874]                   }
[18:01:57.874]                 }, immediateCondition = function(cond) {
[18:01:57.874]                   save_rds <- function (object, pathname, ...) 
[18:01:57.874]                   {
[18:01:57.874]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:57.874]                     if (file_test("-f", pathname_tmp)) {
[18:01:57.874]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.874]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:57.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.874]                         fi_tmp[["mtime"]])
[18:01:57.874]                     }
[18:01:57.874]                     tryCatch({
[18:01:57.874]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:57.874]                     }, error = function(ex) {
[18:01:57.874]                       msg <- conditionMessage(ex)
[18:01:57.874]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.874]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:57.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.874]                         fi_tmp[["mtime"]], msg)
[18:01:57.874]                       ex$message <- msg
[18:01:57.874]                       stop(ex)
[18:01:57.874]                     })
[18:01:57.874]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:57.874]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:57.874]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:57.874]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.874]                       fi <- file.info(pathname)
[18:01:57.874]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:57.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.874]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:57.874]                         fi[["size"]], fi[["mtime"]])
[18:01:57.874]                       stop(msg)
[18:01:57.874]                     }
[18:01:57.874]                     invisible(pathname)
[18:01:57.874]                   }
[18:01:57.874]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:57.874]                     rootPath = tempdir()) 
[18:01:57.874]                   {
[18:01:57.874]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:57.874]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:57.874]                       tmpdir = path, fileext = ".rds")
[18:01:57.874]                     save_rds(obj, file)
[18:01:57.874]                   }
[18:01:57.874]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:57.874]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.874]                   {
[18:01:57.874]                     inherits <- base::inherits
[18:01:57.874]                     invokeRestart <- base::invokeRestart
[18:01:57.874]                     is.null <- base::is.null
[18:01:57.874]                     muffled <- FALSE
[18:01:57.874]                     if (inherits(cond, "message")) {
[18:01:57.874]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:57.874]                       if (muffled) 
[18:01:57.874]                         invokeRestart("muffleMessage")
[18:01:57.874]                     }
[18:01:57.874]                     else if (inherits(cond, "warning")) {
[18:01:57.874]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:57.874]                       if (muffled) 
[18:01:57.874]                         invokeRestart("muffleWarning")
[18:01:57.874]                     }
[18:01:57.874]                     else if (inherits(cond, "condition")) {
[18:01:57.874]                       if (!is.null(pattern)) {
[18:01:57.874]                         computeRestarts <- base::computeRestarts
[18:01:57.874]                         grepl <- base::grepl
[18:01:57.874]                         restarts <- computeRestarts(cond)
[18:01:57.874]                         for (restart in restarts) {
[18:01:57.874]                           name <- restart$name
[18:01:57.874]                           if (is.null(name)) 
[18:01:57.874]                             next
[18:01:57.874]                           if (!grepl(pattern, name)) 
[18:01:57.874]                             next
[18:01:57.874]                           invokeRestart(restart)
[18:01:57.874]                           muffled <- TRUE
[18:01:57.874]                           break
[18:01:57.874]                         }
[18:01:57.874]                       }
[18:01:57.874]                     }
[18:01:57.874]                     invisible(muffled)
[18:01:57.874]                   }
[18:01:57.874]                   muffleCondition(cond)
[18:01:57.874]                 })
[18:01:57.874]             }))
[18:01:57.874]             future::FutureResult(value = ...future.value$value, 
[18:01:57.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.874]                   ...future.rng), globalenv = if (FALSE) 
[18:01:57.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:57.874]                     ...future.globalenv.names))
[18:01:57.874]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:57.874]         }, condition = base::local({
[18:01:57.874]             c <- base::c
[18:01:57.874]             inherits <- base::inherits
[18:01:57.874]             invokeRestart <- base::invokeRestart
[18:01:57.874]             length <- base::length
[18:01:57.874]             list <- base::list
[18:01:57.874]             seq.int <- base::seq.int
[18:01:57.874]             signalCondition <- base::signalCondition
[18:01:57.874]             sys.calls <- base::sys.calls
[18:01:57.874]             `[[` <- base::`[[`
[18:01:57.874]             `+` <- base::`+`
[18:01:57.874]             `<<-` <- base::`<<-`
[18:01:57.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:57.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:57.874]                   3L)]
[18:01:57.874]             }
[18:01:57.874]             function(cond) {
[18:01:57.874]                 is_error <- inherits(cond, "error")
[18:01:57.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:57.874]                   NULL)
[18:01:57.874]                 if (is_error) {
[18:01:57.874]                   sessionInformation <- function() {
[18:01:57.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:57.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:57.874]                       search = base::search(), system = base::Sys.info())
[18:01:57.874]                   }
[18:01:57.874]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:57.874]                     cond$call), session = sessionInformation(), 
[18:01:57.874]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:57.874]                   signalCondition(cond)
[18:01:57.874]                 }
[18:01:57.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:57.874]                 "immediateCondition"))) {
[18:01:57.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:57.874]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:57.874]                   if (TRUE && !signal) {
[18:01:57.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.874]                     {
[18:01:57.874]                       inherits <- base::inherits
[18:01:57.874]                       invokeRestart <- base::invokeRestart
[18:01:57.874]                       is.null <- base::is.null
[18:01:57.874]                       muffled <- FALSE
[18:01:57.874]                       if (inherits(cond, "message")) {
[18:01:57.874]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.874]                         if (muffled) 
[18:01:57.874]                           invokeRestart("muffleMessage")
[18:01:57.874]                       }
[18:01:57.874]                       else if (inherits(cond, "warning")) {
[18:01:57.874]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.874]                         if (muffled) 
[18:01:57.874]                           invokeRestart("muffleWarning")
[18:01:57.874]                       }
[18:01:57.874]                       else if (inherits(cond, "condition")) {
[18:01:57.874]                         if (!is.null(pattern)) {
[18:01:57.874]                           computeRestarts <- base::computeRestarts
[18:01:57.874]                           grepl <- base::grepl
[18:01:57.874]                           restarts <- computeRestarts(cond)
[18:01:57.874]                           for (restart in restarts) {
[18:01:57.874]                             name <- restart$name
[18:01:57.874]                             if (is.null(name)) 
[18:01:57.874]                               next
[18:01:57.874]                             if (!grepl(pattern, name)) 
[18:01:57.874]                               next
[18:01:57.874]                             invokeRestart(restart)
[18:01:57.874]                             muffled <- TRUE
[18:01:57.874]                             break
[18:01:57.874]                           }
[18:01:57.874]                         }
[18:01:57.874]                       }
[18:01:57.874]                       invisible(muffled)
[18:01:57.874]                     }
[18:01:57.874]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.874]                   }
[18:01:57.874]                 }
[18:01:57.874]                 else {
[18:01:57.874]                   if (TRUE) {
[18:01:57.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.874]                     {
[18:01:57.874]                       inherits <- base::inherits
[18:01:57.874]                       invokeRestart <- base::invokeRestart
[18:01:57.874]                       is.null <- base::is.null
[18:01:57.874]                       muffled <- FALSE
[18:01:57.874]                       if (inherits(cond, "message")) {
[18:01:57.874]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.874]                         if (muffled) 
[18:01:57.874]                           invokeRestart("muffleMessage")
[18:01:57.874]                       }
[18:01:57.874]                       else if (inherits(cond, "warning")) {
[18:01:57.874]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.874]                         if (muffled) 
[18:01:57.874]                           invokeRestart("muffleWarning")
[18:01:57.874]                       }
[18:01:57.874]                       else if (inherits(cond, "condition")) {
[18:01:57.874]                         if (!is.null(pattern)) {
[18:01:57.874]                           computeRestarts <- base::computeRestarts
[18:01:57.874]                           grepl <- base::grepl
[18:01:57.874]                           restarts <- computeRestarts(cond)
[18:01:57.874]                           for (restart in restarts) {
[18:01:57.874]                             name <- restart$name
[18:01:57.874]                             if (is.null(name)) 
[18:01:57.874]                               next
[18:01:57.874]                             if (!grepl(pattern, name)) 
[18:01:57.874]                               next
[18:01:57.874]                             invokeRestart(restart)
[18:01:57.874]                             muffled <- TRUE
[18:01:57.874]                             break
[18:01:57.874]                           }
[18:01:57.874]                         }
[18:01:57.874]                       }
[18:01:57.874]                       invisible(muffled)
[18:01:57.874]                     }
[18:01:57.874]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.874]                   }
[18:01:57.874]                 }
[18:01:57.874]             }
[18:01:57.874]         }))
[18:01:57.874]     }, error = function(ex) {
[18:01:57.874]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:57.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.874]                 ...future.rng), started = ...future.startTime, 
[18:01:57.874]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:57.874]             version = "1.8"), class = "FutureResult")
[18:01:57.874]     }, finally = {
[18:01:57.874]         if (!identical(...future.workdir, getwd())) 
[18:01:57.874]             setwd(...future.workdir)
[18:01:57.874]         {
[18:01:57.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:57.874]                 ...future.oldOptions$nwarnings <- NULL
[18:01:57.874]             }
[18:01:57.874]             base::options(...future.oldOptions)
[18:01:57.874]             if (.Platform$OS.type == "windows") {
[18:01:57.874]                 old_names <- names(...future.oldEnvVars)
[18:01:57.874]                 envs <- base::Sys.getenv()
[18:01:57.874]                 names <- names(envs)
[18:01:57.874]                 common <- intersect(names, old_names)
[18:01:57.874]                 added <- setdiff(names, old_names)
[18:01:57.874]                 removed <- setdiff(old_names, names)
[18:01:57.874]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:57.874]                   envs[common]]
[18:01:57.874]                 NAMES <- toupper(changed)
[18:01:57.874]                 args <- list()
[18:01:57.874]                 for (kk in seq_along(NAMES)) {
[18:01:57.874]                   name <- changed[[kk]]
[18:01:57.874]                   NAME <- NAMES[[kk]]
[18:01:57.874]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.874]                     next
[18:01:57.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.874]                 }
[18:01:57.874]                 NAMES <- toupper(added)
[18:01:57.874]                 for (kk in seq_along(NAMES)) {
[18:01:57.874]                   name <- added[[kk]]
[18:01:57.874]                   NAME <- NAMES[[kk]]
[18:01:57.874]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.874]                     next
[18:01:57.874]                   args[[name]] <- ""
[18:01:57.874]                 }
[18:01:57.874]                 NAMES <- toupper(removed)
[18:01:57.874]                 for (kk in seq_along(NAMES)) {
[18:01:57.874]                   name <- removed[[kk]]
[18:01:57.874]                   NAME <- NAMES[[kk]]
[18:01:57.874]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.874]                     next
[18:01:57.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.874]                 }
[18:01:57.874]                 if (length(args) > 0) 
[18:01:57.874]                   base::do.call(base::Sys.setenv, args = args)
[18:01:57.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:57.874]             }
[18:01:57.874]             else {
[18:01:57.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:57.874]             }
[18:01:57.874]             {
[18:01:57.874]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:57.874]                   0L) {
[18:01:57.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:57.874]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:57.874]                   base::options(opts)
[18:01:57.874]                 }
[18:01:57.874]                 {
[18:01:57.874]                   {
[18:01:57.874]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:57.874]                     NULL
[18:01:57.874]                   }
[18:01:57.874]                   options(future.plan = NULL)
[18:01:57.874]                   if (is.na(NA_character_)) 
[18:01:57.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:57.874]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:57.874]                     .init = FALSE)
[18:01:57.874]                 }
[18:01:57.874]             }
[18:01:57.874]         }
[18:01:57.874]     })
[18:01:57.874]     if (TRUE) {
[18:01:57.874]         base::sink(type = "output", split = FALSE)
[18:01:57.874]         if (TRUE) {
[18:01:57.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:57.874]         }
[18:01:57.874]         else {
[18:01:57.874]             ...future.result["stdout"] <- base::list(NULL)
[18:01:57.874]         }
[18:01:57.874]         base::close(...future.stdout)
[18:01:57.874]         ...future.stdout <- NULL
[18:01:57.874]     }
[18:01:57.874]     ...future.result$conditions <- ...future.conditions
[18:01:57.874]     ...future.result$finished <- base::Sys.time()
[18:01:57.874]     ...future.result
[18:01:57.874] }
[18:01:57.878] assign_globals() ...
[18:01:57.879] List of 11
[18:01:57.879]  $ ...future.FUN            :function (x, ...)  
[18:01:57.879]  $ x_FUN                    :function (x)  
[18:01:57.879]  $ times                    : int 1
[18:01:57.879]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:57.879]  $ stop_if_not              :function (...)  
[18:01:57.879]  $ dim                      : NULL
[18:01:57.879]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:57.879]  $ future.call.arguments    : list()
[18:01:57.879]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.879]  $ ...future.elements_ii    :List of 5
[18:01:57.879]   ..$ : int 1
[18:01:57.879]   ..$ : int 2
[18:01:57.879]   ..$ : int 3
[18:01:57.879]   ..$ : int 4
[18:01:57.879]   ..$ : int 5
[18:01:57.879]  $ ...future.seeds_ii       : NULL
[18:01:57.879]  $ ...future.globals.maxSize: NULL
[18:01:57.879]  - attr(*, "where")=List of 11
[18:01:57.879]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:57.879]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:57.879]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:57.879]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:57.879]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:57.879]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:57.879]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:57.879]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:57.879]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:57.879]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:57.879]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:57.879]  - attr(*, "resolved")= logi FALSE
[18:01:57.879]  - attr(*, "total_size")= num 94336
[18:01:57.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.879]  - attr(*, "already-done")= logi TRUE
[18:01:57.897] - copied ‘...future.FUN’ to environment
[18:01:57.897] - copied ‘x_FUN’ to environment
[18:01:57.897] - copied ‘times’ to environment
[18:01:57.898] - copied ‘stopf’ to environment
[18:01:57.898] - copied ‘stop_if_not’ to environment
[18:01:57.898] - copied ‘dim’ to environment
[18:01:57.898] - copied ‘valid_types’ to environment
[18:01:57.898] - copied ‘future.call.arguments’ to environment
[18:01:57.899] - copied ‘...future.elements_ii’ to environment
[18:01:57.899] - copied ‘...future.seeds_ii’ to environment
[18:01:57.899] - copied ‘...future.globals.maxSize’ to environment
[18:01:57.899] assign_globals() ... done
[18:01:57.900] requestCore(): workers = 2
[18:01:57.903] MulticoreFuture started
[18:01:57.904] - Launch lazy future ... done
[18:01:57.904] run() for ‘MulticoreFuture’ ... done
[18:01:57.905] Created future:
[18:01:57.910] plan(): Setting new future strategy stack:
[18:01:57.910] List of future strategies:
[18:01:57.910] 1. sequential:
[18:01:57.910]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:57.910]    - tweaked: FALSE
[18:01:57.910]    - call: NULL
[18:01:57.912] plan(): nbrOfWorkers() = 1
[18:01:57.917] plan(): Setting new future strategy stack:
[18:01:57.917] List of future strategies:
[18:01:57.917] 1. multicore:
[18:01:57.917]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:57.917]    - tweaked: FALSE
[18:01:57.917]    - call: plan(strategy)
[18:01:57.905] MulticoreFuture:
[18:01:57.905] Label: ‘future_vapply-1’
[18:01:57.905] Expression:
[18:01:57.905] {
[18:01:57.905]     do.call(function(...) {
[18:01:57.905]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.905]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.905]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.905]             on.exit(options(oopts), add = TRUE)
[18:01:57.905]         }
[18:01:57.905]         {
[18:01:57.905]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.905]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.905]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.905]             })
[18:01:57.905]         }
[18:01:57.905]     }, args = future.call.arguments)
[18:01:57.905] }
[18:01:57.905] Lazy evaluation: FALSE
[18:01:57.905] Asynchronous evaluation: TRUE
[18:01:57.905] Local evaluation: TRUE
[18:01:57.905] Environment: R_GlobalEnv
[18:01:57.905] Capture standard output: TRUE
[18:01:57.905] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:57.905] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:57.905] Packages: 1 packages (‘future.apply’)
[18:01:57.905] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:57.905] Resolved: FALSE
[18:01:57.905] Value: <not collected>
[18:01:57.905] Conditions captured: <none>
[18:01:57.905] Early signaling: FALSE
[18:01:57.905] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:57.905] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.922] Chunk #1 of 2 ... DONE
[18:01:57.922] Chunk #2 of 2 ...
[18:01:57.922]  - Finding globals in 'X' for chunk #2 ...
[18:01:57.927] getGlobalsAndPackages() ...
[18:01:57.927] plan(): nbrOfWorkers() = 2
[18:01:57.927] Searching for globals...
[18:01:57.928] 
[18:01:57.928] Searching for globals ... DONE
[18:01:57.929] - globals: [0] <none>
[18:01:57.929] getGlobalsAndPackages() ... DONE
[18:01:57.929]    + additional globals found: [n=0] 
[18:01:57.930]    + additional namespaces needed: [n=0] 
[18:01:57.930]  - Finding globals in 'X' for chunk #2 ... DONE
[18:01:57.930]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:57.930]  - seeds: <none>
[18:01:57.931]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.931] getGlobalsAndPackages() ...
[18:01:57.931] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.932] Resolving globals: FALSE
[18:01:57.932] Tweak future expression to call with '...' arguments ...
[18:01:57.933] {
[18:01:57.933]     do.call(function(...) {
[18:01:57.933]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.933]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:57.933]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.933]             on.exit(options(oopts), add = TRUE)
[18:01:57.933]         }
[18:01:57.933]         {
[18:01:57.933]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:57.933]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.933]                 ...future.FUN(...future.X_jj, ...)
[18:01:57.933]             })
[18:01:57.933]         }
[18:01:57.933]     }, args = future.call.arguments)
[18:01:57.933] }
[18:01:57.933] Tweak future expression to call with '...' arguments ... DONE
[18:01:57.936] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:57.936] - packages: [1] ‘future.apply’
[18:01:57.936] getGlobalsAndPackages() ... DONE
[18:01:57.938] run() for ‘Future’ ...
[18:01:57.938] - state: ‘created’
[18:01:57.938] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:57.947] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:57.947] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:57.947]   - Field: ‘label’
[18:01:57.948]   - Field: ‘local’
[18:01:57.948]   - Field: ‘owner’
[18:01:57.949]   - Field: ‘envir’
[18:01:57.949]   - Field: ‘workers’
[18:01:57.949]   - Field: ‘packages’
[18:01:57.949]   - Field: ‘gc’
[18:01:57.950]   - Field: ‘job’
[18:01:57.950]   - Field: ‘conditions’
[18:01:57.950]   - Field: ‘expr’
[18:01:57.951]   - Field: ‘uuid’
[18:01:57.951]   - Field: ‘seed’
[18:01:57.951]   - Field: ‘version’
[18:01:57.952]   - Field: ‘result’
[18:01:57.952]   - Field: ‘asynchronous’
[18:01:57.952]   - Field: ‘calls’
[18:01:57.953]   - Field: ‘globals’
[18:01:57.953]   - Field: ‘stdout’
[18:01:57.953]   - Field: ‘earlySignal’
[18:01:57.954]   - Field: ‘lazy’
[18:01:57.954]   - Field: ‘state’
[18:01:57.954] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:57.955] - Launch lazy future ...
[18:01:57.956] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:57.956] Packages needed by future strategies (n = 0): <none>
[18:01:57.964] {
[18:01:57.964]     {
[18:01:57.964]         {
[18:01:57.964]             ...future.startTime <- base::Sys.time()
[18:01:57.964]             {
[18:01:57.964]                 {
[18:01:57.964]                   {
[18:01:57.964]                     {
[18:01:57.964]                       {
[18:01:57.964]                         base::local({
[18:01:57.964]                           has_future <- base::requireNamespace("future", 
[18:01:57.964]                             quietly = TRUE)
[18:01:57.964]                           if (has_future) {
[18:01:57.964]                             ns <- base::getNamespace("future")
[18:01:57.964]                             version <- ns[[".package"]][["version"]]
[18:01:57.964]                             if (is.null(version)) 
[18:01:57.964]                               version <- utils::packageVersion("future")
[18:01:57.964]                           }
[18:01:57.964]                           else {
[18:01:57.964]                             version <- NULL
[18:01:57.964]                           }
[18:01:57.964]                           if (!has_future || version < "1.8.0") {
[18:01:57.964]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:57.964]                               "", base::R.version$version.string), 
[18:01:57.964]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:57.964]                                 base::R.version$platform, 8 * 
[18:01:57.964]                                   base::.Machine$sizeof.pointer), 
[18:01:57.964]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:57.964]                                 "release", "version")], collapse = " "), 
[18:01:57.964]                               hostname = base::Sys.info()[["nodename"]])
[18:01:57.964]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:57.964]                               info)
[18:01:57.964]                             info <- base::paste(info, collapse = "; ")
[18:01:57.964]                             if (!has_future) {
[18:01:57.964]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:57.964]                                 info)
[18:01:57.964]                             }
[18:01:57.964]                             else {
[18:01:57.964]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:57.964]                                 info, version)
[18:01:57.964]                             }
[18:01:57.964]                             base::stop(msg)
[18:01:57.964]                           }
[18:01:57.964]                         })
[18:01:57.964]                       }
[18:01:57.964]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:57.964]                       base::options(mc.cores = 1L)
[18:01:57.964]                     }
[18:01:57.964]                     base::local({
[18:01:57.964]                       for (pkg in "future.apply") {
[18:01:57.964]                         base::loadNamespace(pkg)
[18:01:57.964]                         base::library(pkg, character.only = TRUE)
[18:01:57.964]                       }
[18:01:57.964]                     })
[18:01:57.964]                   }
[18:01:57.964]                   ...future.strategy.old <- future::plan("list")
[18:01:57.964]                   options(future.plan = NULL)
[18:01:57.964]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.964]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:57.964]                 }
[18:01:57.964]                 ...future.workdir <- getwd()
[18:01:57.964]             }
[18:01:57.964]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:57.964]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:57.964]         }
[18:01:57.964]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:57.964]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:57.964]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:57.964]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:57.964]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:57.964]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:57.964]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:57.964]             base::names(...future.oldOptions))
[18:01:57.964]     }
[18:01:57.964]     if (FALSE) {
[18:01:57.964]     }
[18:01:57.964]     else {
[18:01:57.964]         if (TRUE) {
[18:01:57.964]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:57.964]                 open = "w")
[18:01:57.964]         }
[18:01:57.964]         else {
[18:01:57.964]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:57.964]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:57.964]         }
[18:01:57.964]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:57.964]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:57.964]             base::sink(type = "output", split = FALSE)
[18:01:57.964]             base::close(...future.stdout)
[18:01:57.964]         }, add = TRUE)
[18:01:57.964]     }
[18:01:57.964]     ...future.frame <- base::sys.nframe()
[18:01:57.964]     ...future.conditions <- base::list()
[18:01:57.964]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:57.964]     if (FALSE) {
[18:01:57.964]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:57.964]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:57.964]     }
[18:01:57.964]     ...future.result <- base::tryCatch({
[18:01:57.964]         base::withCallingHandlers({
[18:01:57.964]             ...future.value <- base::withVisible(base::local({
[18:01:57.964]                 withCallingHandlers({
[18:01:57.964]                   {
[18:01:57.964]                     do.call(function(...) {
[18:01:57.964]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:57.964]                       if (!identical(...future.globals.maxSize.org, 
[18:01:57.964]                         ...future.globals.maxSize)) {
[18:01:57.964]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:57.964]                         on.exit(options(oopts), add = TRUE)
[18:01:57.964]                       }
[18:01:57.964]                       {
[18:01:57.964]                         lapply(seq_along(...future.elements_ii), 
[18:01:57.964]                           FUN = function(jj) {
[18:01:57.964]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:57.964]                             ...future.FUN(...future.X_jj, ...)
[18:01:57.964]                           })
[18:01:57.964]                       }
[18:01:57.964]                     }, args = future.call.arguments)
[18:01:57.964]                   }
[18:01:57.964]                 }, immediateCondition = function(cond) {
[18:01:57.964]                   save_rds <- function (object, pathname, ...) 
[18:01:57.964]                   {
[18:01:57.964]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:57.964]                     if (file_test("-f", pathname_tmp)) {
[18:01:57.964]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.964]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:57.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.964]                         fi_tmp[["mtime"]])
[18:01:57.964]                     }
[18:01:57.964]                     tryCatch({
[18:01:57.964]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:57.964]                     }, error = function(ex) {
[18:01:57.964]                       msg <- conditionMessage(ex)
[18:01:57.964]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.964]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:57.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.964]                         fi_tmp[["mtime"]], msg)
[18:01:57.964]                       ex$message <- msg
[18:01:57.964]                       stop(ex)
[18:01:57.964]                     })
[18:01:57.964]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:57.964]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:57.964]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:57.964]                       fi_tmp <- file.info(pathname_tmp)
[18:01:57.964]                       fi <- file.info(pathname)
[18:01:57.964]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:57.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:57.964]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:57.964]                         fi[["size"]], fi[["mtime"]])
[18:01:57.964]                       stop(msg)
[18:01:57.964]                     }
[18:01:57.964]                     invisible(pathname)
[18:01:57.964]                   }
[18:01:57.964]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:57.964]                     rootPath = tempdir()) 
[18:01:57.964]                   {
[18:01:57.964]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:57.964]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:57.964]                       tmpdir = path, fileext = ".rds")
[18:01:57.964]                     save_rds(obj, file)
[18:01:57.964]                   }
[18:01:57.964]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:57.964]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.964]                   {
[18:01:57.964]                     inherits <- base::inherits
[18:01:57.964]                     invokeRestart <- base::invokeRestart
[18:01:57.964]                     is.null <- base::is.null
[18:01:57.964]                     muffled <- FALSE
[18:01:57.964]                     if (inherits(cond, "message")) {
[18:01:57.964]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:57.964]                       if (muffled) 
[18:01:57.964]                         invokeRestart("muffleMessage")
[18:01:57.964]                     }
[18:01:57.964]                     else if (inherits(cond, "warning")) {
[18:01:57.964]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:57.964]                       if (muffled) 
[18:01:57.964]                         invokeRestart("muffleWarning")
[18:01:57.964]                     }
[18:01:57.964]                     else if (inherits(cond, "condition")) {
[18:01:57.964]                       if (!is.null(pattern)) {
[18:01:57.964]                         computeRestarts <- base::computeRestarts
[18:01:57.964]                         grepl <- base::grepl
[18:01:57.964]                         restarts <- computeRestarts(cond)
[18:01:57.964]                         for (restart in restarts) {
[18:01:57.964]                           name <- restart$name
[18:01:57.964]                           if (is.null(name)) 
[18:01:57.964]                             next
[18:01:57.964]                           if (!grepl(pattern, name)) 
[18:01:57.964]                             next
[18:01:57.964]                           invokeRestart(restart)
[18:01:57.964]                           muffled <- TRUE
[18:01:57.964]                           break
[18:01:57.964]                         }
[18:01:57.964]                       }
[18:01:57.964]                     }
[18:01:57.964]                     invisible(muffled)
[18:01:57.964]                   }
[18:01:57.964]                   muffleCondition(cond)
[18:01:57.964]                 })
[18:01:57.964]             }))
[18:01:57.964]             future::FutureResult(value = ...future.value$value, 
[18:01:57.964]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.964]                   ...future.rng), globalenv = if (FALSE) 
[18:01:57.964]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:57.964]                     ...future.globalenv.names))
[18:01:57.964]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:57.964]         }, condition = base::local({
[18:01:57.964]             c <- base::c
[18:01:57.964]             inherits <- base::inherits
[18:01:57.964]             invokeRestart <- base::invokeRestart
[18:01:57.964]             length <- base::length
[18:01:57.964]             list <- base::list
[18:01:57.964]             seq.int <- base::seq.int
[18:01:57.964]             signalCondition <- base::signalCondition
[18:01:57.964]             sys.calls <- base::sys.calls
[18:01:57.964]             `[[` <- base::`[[`
[18:01:57.964]             `+` <- base::`+`
[18:01:57.964]             `<<-` <- base::`<<-`
[18:01:57.964]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:57.964]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:57.964]                   3L)]
[18:01:57.964]             }
[18:01:57.964]             function(cond) {
[18:01:57.964]                 is_error <- inherits(cond, "error")
[18:01:57.964]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:57.964]                   NULL)
[18:01:57.964]                 if (is_error) {
[18:01:57.964]                   sessionInformation <- function() {
[18:01:57.964]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:57.964]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:57.964]                       search = base::search(), system = base::Sys.info())
[18:01:57.964]                   }
[18:01:57.964]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.964]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:57.964]                     cond$call), session = sessionInformation(), 
[18:01:57.964]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:57.964]                   signalCondition(cond)
[18:01:57.964]                 }
[18:01:57.964]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:57.964]                 "immediateCondition"))) {
[18:01:57.964]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:57.964]                   ...future.conditions[[length(...future.conditions) + 
[18:01:57.964]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:57.964]                   if (TRUE && !signal) {
[18:01:57.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.964]                     {
[18:01:57.964]                       inherits <- base::inherits
[18:01:57.964]                       invokeRestart <- base::invokeRestart
[18:01:57.964]                       is.null <- base::is.null
[18:01:57.964]                       muffled <- FALSE
[18:01:57.964]                       if (inherits(cond, "message")) {
[18:01:57.964]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.964]                         if (muffled) 
[18:01:57.964]                           invokeRestart("muffleMessage")
[18:01:57.964]                       }
[18:01:57.964]                       else if (inherits(cond, "warning")) {
[18:01:57.964]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.964]                         if (muffled) 
[18:01:57.964]                           invokeRestart("muffleWarning")
[18:01:57.964]                       }
[18:01:57.964]                       else if (inherits(cond, "condition")) {
[18:01:57.964]                         if (!is.null(pattern)) {
[18:01:57.964]                           computeRestarts <- base::computeRestarts
[18:01:57.964]                           grepl <- base::grepl
[18:01:57.964]                           restarts <- computeRestarts(cond)
[18:01:57.964]                           for (restart in restarts) {
[18:01:57.964]                             name <- restart$name
[18:01:57.964]                             if (is.null(name)) 
[18:01:57.964]                               next
[18:01:57.964]                             if (!grepl(pattern, name)) 
[18:01:57.964]                               next
[18:01:57.964]                             invokeRestart(restart)
[18:01:57.964]                             muffled <- TRUE
[18:01:57.964]                             break
[18:01:57.964]                           }
[18:01:57.964]                         }
[18:01:57.964]                       }
[18:01:57.964]                       invisible(muffled)
[18:01:57.964]                     }
[18:01:57.964]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.964]                   }
[18:01:57.964]                 }
[18:01:57.964]                 else {
[18:01:57.964]                   if (TRUE) {
[18:01:57.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:57.964]                     {
[18:01:57.964]                       inherits <- base::inherits
[18:01:57.964]                       invokeRestart <- base::invokeRestart
[18:01:57.964]                       is.null <- base::is.null
[18:01:57.964]                       muffled <- FALSE
[18:01:57.964]                       if (inherits(cond, "message")) {
[18:01:57.964]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:57.964]                         if (muffled) 
[18:01:57.964]                           invokeRestart("muffleMessage")
[18:01:57.964]                       }
[18:01:57.964]                       else if (inherits(cond, "warning")) {
[18:01:57.964]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:57.964]                         if (muffled) 
[18:01:57.964]                           invokeRestart("muffleWarning")
[18:01:57.964]                       }
[18:01:57.964]                       else if (inherits(cond, "condition")) {
[18:01:57.964]                         if (!is.null(pattern)) {
[18:01:57.964]                           computeRestarts <- base::computeRestarts
[18:01:57.964]                           grepl <- base::grepl
[18:01:57.964]                           restarts <- computeRestarts(cond)
[18:01:57.964]                           for (restart in restarts) {
[18:01:57.964]                             name <- restart$name
[18:01:57.964]                             if (is.null(name)) 
[18:01:57.964]                               next
[18:01:57.964]                             if (!grepl(pattern, name)) 
[18:01:57.964]                               next
[18:01:57.964]                             invokeRestart(restart)
[18:01:57.964]                             muffled <- TRUE
[18:01:57.964]                             break
[18:01:57.964]                           }
[18:01:57.964]                         }
[18:01:57.964]                       }
[18:01:57.964]                       invisible(muffled)
[18:01:57.964]                     }
[18:01:57.964]                     muffleCondition(cond, pattern = "^muffle")
[18:01:57.964]                   }
[18:01:57.964]                 }
[18:01:57.964]             }
[18:01:57.964]         }))
[18:01:57.964]     }, error = function(ex) {
[18:01:57.964]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:57.964]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:57.964]                 ...future.rng), started = ...future.startTime, 
[18:01:57.964]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:57.964]             version = "1.8"), class = "FutureResult")
[18:01:57.964]     }, finally = {
[18:01:57.964]         if (!identical(...future.workdir, getwd())) 
[18:01:57.964]             setwd(...future.workdir)
[18:01:57.964]         {
[18:01:57.964]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:57.964]                 ...future.oldOptions$nwarnings <- NULL
[18:01:57.964]             }
[18:01:57.964]             base::options(...future.oldOptions)
[18:01:57.964]             if (.Platform$OS.type == "windows") {
[18:01:57.964]                 old_names <- names(...future.oldEnvVars)
[18:01:57.964]                 envs <- base::Sys.getenv()
[18:01:57.964]                 names <- names(envs)
[18:01:57.964]                 common <- intersect(names, old_names)
[18:01:57.964]                 added <- setdiff(names, old_names)
[18:01:57.964]                 removed <- setdiff(old_names, names)
[18:01:57.964]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:57.964]                   envs[common]]
[18:01:57.964]                 NAMES <- toupper(changed)
[18:01:57.964]                 args <- list()
[18:01:57.964]                 for (kk in seq_along(NAMES)) {
[18:01:57.964]                   name <- changed[[kk]]
[18:01:57.964]                   NAME <- NAMES[[kk]]
[18:01:57.964]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.964]                     next
[18:01:57.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.964]                 }
[18:01:57.964]                 NAMES <- toupper(added)
[18:01:57.964]                 for (kk in seq_along(NAMES)) {
[18:01:57.964]                   name <- added[[kk]]
[18:01:57.964]                   NAME <- NAMES[[kk]]
[18:01:57.964]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.964]                     next
[18:01:57.964]                   args[[name]] <- ""
[18:01:57.964]                 }
[18:01:57.964]                 NAMES <- toupper(removed)
[18:01:57.964]                 for (kk in seq_along(NAMES)) {
[18:01:57.964]                   name <- removed[[kk]]
[18:01:57.964]                   NAME <- NAMES[[kk]]
[18:01:57.964]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:57.964]                     next
[18:01:57.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:57.964]                 }
[18:01:57.964]                 if (length(args) > 0) 
[18:01:57.964]                   base::do.call(base::Sys.setenv, args = args)
[18:01:57.964]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:57.964]             }
[18:01:57.964]             else {
[18:01:57.964]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:57.964]             }
[18:01:57.964]             {
[18:01:57.964]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:57.964]                   0L) {
[18:01:57.964]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:57.964]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:57.964]                   base::options(opts)
[18:01:57.964]                 }
[18:01:57.964]                 {
[18:01:57.964]                   {
[18:01:57.964]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:57.964]                     NULL
[18:01:57.964]                   }
[18:01:57.964]                   options(future.plan = NULL)
[18:01:57.964]                   if (is.na(NA_character_)) 
[18:01:57.964]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:57.964]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:57.964]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:57.964]                     .init = FALSE)
[18:01:57.964]                 }
[18:01:57.964]             }
[18:01:57.964]         }
[18:01:57.964]     })
[18:01:57.964]     if (TRUE) {
[18:01:57.964]         base::sink(type = "output", split = FALSE)
[18:01:57.964]         if (TRUE) {
[18:01:57.964]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:57.964]         }
[18:01:57.964]         else {
[18:01:57.964]             ...future.result["stdout"] <- base::list(NULL)
[18:01:57.964]         }
[18:01:57.964]         base::close(...future.stdout)
[18:01:57.964]         ...future.stdout <- NULL
[18:01:57.964]     }
[18:01:57.964]     ...future.result$conditions <- ...future.conditions
[18:01:57.964]     ...future.result$finished <- base::Sys.time()
[18:01:57.964]     ...future.result
[18:01:57.964] }
[18:01:57.970] assign_globals() ...
[18:01:57.971] List of 11
[18:01:57.971]  $ ...future.FUN            :function (x, ...)  
[18:01:57.971]  $ x_FUN                    :function (x)  
[18:01:57.971]  $ times                    : int 1
[18:01:57.971]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:57.971]  $ stop_if_not              :function (...)  
[18:01:57.971]  $ dim                      : NULL
[18:01:57.971]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:57.971]  $ future.call.arguments    : list()
[18:01:57.971]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:57.971]  $ ...future.elements_ii    :List of 5
[18:01:57.971]   ..$ : int 6
[18:01:57.971]   ..$ : int 7
[18:01:57.971]   ..$ : int 8
[18:01:57.971]   ..$ : int 9
[18:01:57.971]   ..$ : int 10
[18:01:57.971]  $ ...future.seeds_ii       : NULL
[18:01:57.971]  $ ...future.globals.maxSize: NULL
[18:01:57.971]  - attr(*, "where")=List of 11
[18:01:57.971]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:57.971]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:57.971]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:57.971]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:57.971]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:57.971]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:57.971]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:57.971]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:57.971]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:57.971]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:57.971]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:57.971]  - attr(*, "resolved")= logi FALSE
[18:01:57.971]  - attr(*, "total_size")= num 94336
[18:01:57.971]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:57.971]  - attr(*, "already-done")= logi TRUE
[18:01:57.999] - copied ‘...future.FUN’ to environment
[18:01:57.999] - copied ‘x_FUN’ to environment
[18:01:58.000] - copied ‘times’ to environment
[18:01:58.000] - copied ‘stopf’ to environment
[18:01:58.000] - copied ‘stop_if_not’ to environment
[18:01:58.000] - copied ‘dim’ to environment
[18:01:58.001] - copied ‘valid_types’ to environment
[18:01:58.001] - copied ‘future.call.arguments’ to environment
[18:01:58.001] - copied ‘...future.elements_ii’ to environment
[18:01:58.001] - copied ‘...future.seeds_ii’ to environment
[18:01:58.002] - copied ‘...future.globals.maxSize’ to environment
[18:01:58.002] assign_globals() ... done
[18:01:58.002] requestCore(): workers = 2
[18:01:58.006] MulticoreFuture started
[18:01:58.007] - Launch lazy future ... done
[18:01:58.007] run() for ‘MulticoreFuture’ ... done
[18:01:58.008] Created future:
[18:01:58.009] plan(): Setting new future strategy stack:
[18:01:58.009] List of future strategies:
[18:01:58.009] 1. sequential:
[18:01:58.009]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:58.009]    - tweaked: FALSE
[18:01:58.009]    - call: NULL
[18:01:58.011] plan(): nbrOfWorkers() = 1
[18:01:58.015] plan(): Setting new future strategy stack:
[18:01:58.016] List of future strategies:
[18:01:58.016] 1. multicore:
[18:01:58.016]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:58.016]    - tweaked: FALSE
[18:01:58.016]    - call: plan(strategy)
[18:01:58.026] plan(): nbrOfWorkers() = 2
[18:01:58.008] MulticoreFuture:
[18:01:58.008] Label: ‘future_vapply-2’
[18:01:58.008] Expression:
[18:01:58.008] {
[18:01:58.008]     do.call(function(...) {
[18:01:58.008]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.008]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.008]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.008]             on.exit(options(oopts), add = TRUE)
[18:01:58.008]         }
[18:01:58.008]         {
[18:01:58.008]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.008]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.008]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.008]             })
[18:01:58.008]         }
[18:01:58.008]     }, args = future.call.arguments)
[18:01:58.008] }
[18:01:58.008] Lazy evaluation: FALSE
[18:01:58.008] Asynchronous evaluation: TRUE
[18:01:58.008] Local evaluation: TRUE
[18:01:58.008] Environment: R_GlobalEnv
[18:01:58.008] Capture standard output: TRUE
[18:01:58.008] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:58.008] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:58.008] Packages: 1 packages (‘future.apply’)
[18:01:58.008] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:58.008] Resolved: FALSE
[18:01:58.008] Value: <not collected>
[18:01:58.008] Conditions captured: <none>
[18:01:58.008] Early signaling: FALSE
[18:01:58.008] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:58.008] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.026] Chunk #2 of 2 ... DONE
[18:01:58.026] Launching 2 futures (chunks) ... DONE
[18:01:58.027] Resolving 2 futures (chunks) ...
[18:01:58.027] resolve() on list ...
[18:01:58.029]  recursive: 0
[18:01:58.029]  length: 2
[18:01:58.030] 
[18:01:58.030] Future #1
[18:01:58.031] result() for MulticoreFuture ...
[18:01:58.033] result() for MulticoreFuture ...
[18:01:58.035] result() for MulticoreFuture ... done
[18:01:58.035] result() for MulticoreFuture ... done
[18:01:58.036] result() for MulticoreFuture ...
[18:01:58.036] result() for MulticoreFuture ... done
[18:01:58.036] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:58.039] - nx: 2
[18:01:58.039] - relay: TRUE
[18:01:58.040] - stdout: TRUE
[18:01:58.040] - signal: TRUE
[18:01:58.040] - resignal: FALSE
[18:01:58.041] - force: TRUE
[18:01:58.041] - relayed: [n=2] FALSE, FALSE
[18:01:58.041] - queued futures: [n=2] FALSE, FALSE
[18:01:58.042]  - until=1
[18:01:58.042]  - relaying element #1
[18:01:58.043] result() for MulticoreFuture ...
[18:01:58.043] result() for MulticoreFuture ... done
[18:01:58.043] result() for MulticoreFuture ...
[18:01:58.043] result() for MulticoreFuture ... done
[18:01:58.044] result() for MulticoreFuture ...
[18:01:58.044] result() for MulticoreFuture ... done
[18:01:58.044] result() for MulticoreFuture ...
[18:01:58.045] result() for MulticoreFuture ... done
[18:01:58.045] - relayed: [n=2] TRUE, FALSE
[18:01:58.045] - queued futures: [n=2] TRUE, FALSE
[18:01:58.046] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:58.046]  length: 1 (resolved future 1)
[18:01:58.047] Future #2
[18:01:58.047] result() for MulticoreFuture ...
[18:01:58.048] result() for MulticoreFuture ...
[18:01:58.050] result() for MulticoreFuture ... done
[18:01:58.050] result() for MulticoreFuture ... done
[18:01:58.051] result() for MulticoreFuture ...
[18:01:58.051] result() for MulticoreFuture ... done
[18:01:58.051] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:58.052] - nx: 2
[18:01:58.052] - relay: TRUE
[18:01:58.052] - stdout: TRUE
[18:01:58.052] - signal: TRUE
[18:01:58.053] - resignal: FALSE
[18:01:58.053] - force: TRUE
[18:01:58.053] - relayed: [n=2] TRUE, FALSE
[18:01:58.053] - queued futures: [n=2] TRUE, FALSE
[18:01:58.053]  - until=2
[18:01:58.054]  - relaying element #2
[18:01:58.054] result() for MulticoreFuture ...
[18:01:58.054] result() for MulticoreFuture ... done
[18:01:58.054] result() for MulticoreFuture ...
[18:01:58.055] result() for MulticoreFuture ... done
[18:01:58.055] result() for MulticoreFuture ...
[18:01:58.055] result() for MulticoreFuture ... done
[18:01:58.055] result() for MulticoreFuture ...
[18:01:58.056] result() for MulticoreFuture ... done
[18:01:58.056] - relayed: [n=2] TRUE, TRUE
[18:01:58.056] - queued futures: [n=2] TRUE, TRUE
[18:01:58.056] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:58.057]  length: 0 (resolved future 2)
[18:01:58.057] Relaying remaining futures
[18:01:58.057] signalConditionsASAP(NULL, pos=0) ...
[18:01:58.057] - nx: 2
[18:01:58.061] - relay: TRUE
[18:01:58.061] - stdout: TRUE
[18:01:58.062] - signal: TRUE
[18:01:58.062] - resignal: FALSE
[18:01:58.062] - force: TRUE
[18:01:58.062] - relayed: [n=2] TRUE, TRUE
[18:01:58.063] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:58.063] - relayed: [n=2] TRUE, TRUE
[18:01:58.064] - queued futures: [n=2] TRUE, TRUE
[18:01:58.064] signalConditionsASAP(NULL, pos=0) ... done
[18:01:58.064] resolve() on list ... DONE
[18:01:58.065] result() for MulticoreFuture ...
[18:01:58.065] result() for MulticoreFuture ... done
[18:01:58.065] result() for MulticoreFuture ...
[18:01:58.065] result() for MulticoreFuture ... done
[18:01:58.066] result() for MulticoreFuture ...
[18:01:58.066] result() for MulticoreFuture ... done
[18:01:58.066] result() for MulticoreFuture ...
[18:01:58.067] result() for MulticoreFuture ... done
[18:01:58.067]  - Number of value chunks collected: 2
[18:01:58.067] Resolving 2 futures (chunks) ... DONE
[18:01:58.067] Reducing values from 2 chunks ...
[18:01:58.068]  - Number of values collected after concatenation: 10
[18:01:58.068]  - Number of values expected: 10
[18:01:58.068] Reducing values from 2 chunks ... DONE
[18:01:58.069] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[18:01:58.071] future_lapply() ...
[18:01:58.081] Number of chunks: 2
[18:01:58.082] getGlobalsAndPackagesXApply() ...
[18:01:58.082]  - future.globals: TRUE
[18:01:58.082] getGlobalsAndPackages() ...
[18:01:58.082] Searching for globals...
[18:01:58.091] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[18:01:58.091] Searching for globals ... DONE
[18:01:58.091] Resolving globals: FALSE
[18:01:58.093] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[18:01:58.094] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:58.094] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:58.095] - packages: [1] ‘future.apply’
[18:01:58.095] getGlobalsAndPackages() ... DONE
[18:01:58.095]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:58.095]  - needed namespaces: [n=1] ‘future.apply’
[18:01:58.096] Finding globals ... DONE
[18:01:58.096]  - use_args: TRUE
[18:01:58.096]  - Getting '...' globals ...
[18:01:58.097] resolve() on list ...
[18:01:58.097]  recursive: 0
[18:01:58.097]  length: 1
[18:01:58.097]  elements: ‘...’
[18:01:58.098]  length: 0 (resolved future 1)
[18:01:58.098] resolve() on list ... DONE
[18:01:58.098]    - '...' content: [n=0] 
[18:01:58.098] List of 1
[18:01:58.098]  $ ...: list()
[18:01:58.098]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.098]  - attr(*, "where")=List of 1
[18:01:58.098]   ..$ ...:<environment: 0x6183bfef9de8> 
[18:01:58.098]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.098]  - attr(*, "resolved")= logi TRUE
[18:01:58.098]  - attr(*, "total_size")= num NA
[18:01:58.103]  - Getting '...' globals ... DONE
[18:01:58.104] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:58.104] List of 8
[18:01:58.104]  $ ...future.FUN:function (x, ...)  
[18:01:58.104]  $ x_FUN        :function (x)  
[18:01:58.104]  $ times        : int 2
[18:01:58.104]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:58.104]  $ stop_if_not  :function (...)  
[18:01:58.104]  $ dim          : NULL
[18:01:58.104]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:58.104]  $ ...          : list()
[18:01:58.104]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.104]  - attr(*, "where")=List of 8
[18:01:58.104]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:58.104]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:58.104]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:58.104]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:58.104]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:58.104]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:58.104]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:58.104]   ..$ ...          :<environment: 0x6183bfef9de8> 
[18:01:58.104]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.104]  - attr(*, "resolved")= logi FALSE
[18:01:58.104]  - attr(*, "total_size")= num 96456
[18:01:58.118] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:58.118] getGlobalsAndPackagesXApply() ... DONE
[18:01:58.118] Number of futures (= number of chunks): 2
[18:01:58.119] Launching 2 futures (chunks) ...
[18:01:58.119] Chunk #1 of 2 ...
[18:01:58.119]  - Finding globals in 'X' for chunk #1 ...
[18:01:58.119] getGlobalsAndPackages() ...
[18:01:58.120] Searching for globals...
[18:01:58.120] 
[18:01:58.120] Searching for globals ... DONE
[18:01:58.120] - globals: [0] <none>
[18:01:58.121] getGlobalsAndPackages() ... DONE
[18:01:58.121]    + additional globals found: [n=0] 
[18:01:58.121]    + additional namespaces needed: [n=0] 
[18:01:58.121]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:58.121]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:58.122]  - seeds: <none>
[18:01:58.122]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.122] getGlobalsAndPackages() ...
[18:01:58.122] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.123] Resolving globals: FALSE
[18:01:58.123] Tweak future expression to call with '...' arguments ...
[18:01:58.123] {
[18:01:58.123]     do.call(function(...) {
[18:01:58.123]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.123]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.123]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.123]             on.exit(options(oopts), add = TRUE)
[18:01:58.123]         }
[18:01:58.123]         {
[18:01:58.123]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.123]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.123]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.123]             })
[18:01:58.123]         }
[18:01:58.123]     }, args = future.call.arguments)
[18:01:58.123] }
[18:01:58.124] Tweak future expression to call with '...' arguments ... DONE
[18:01:58.125] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.125] - packages: [1] ‘future.apply’
[18:01:58.125] getGlobalsAndPackages() ... DONE
[18:01:58.126] run() for ‘Future’ ...
[18:01:58.126] - state: ‘created’
[18:01:58.126] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:58.133] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.133] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:58.133]   - Field: ‘label’
[18:01:58.133]   - Field: ‘local’
[18:01:58.134]   - Field: ‘owner’
[18:01:58.134]   - Field: ‘envir’
[18:01:58.134]   - Field: ‘workers’
[18:01:58.134]   - Field: ‘packages’
[18:01:58.134]   - Field: ‘gc’
[18:01:58.135]   - Field: ‘job’
[18:01:58.135]   - Field: ‘conditions’
[18:01:58.135]   - Field: ‘expr’
[18:01:58.135]   - Field: ‘uuid’
[18:01:58.135]   - Field: ‘seed’
[18:01:58.136]   - Field: ‘version’
[18:01:58.136]   - Field: ‘result’
[18:01:58.136]   - Field: ‘asynchronous’
[18:01:58.136]   - Field: ‘calls’
[18:01:58.136]   - Field: ‘globals’
[18:01:58.137]   - Field: ‘stdout’
[18:01:58.137]   - Field: ‘earlySignal’
[18:01:58.137]   - Field: ‘lazy’
[18:01:58.137]   - Field: ‘state’
[18:01:58.137] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:58.138] - Launch lazy future ...
[18:01:58.138] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:58.138] Packages needed by future strategies (n = 0): <none>
[18:01:58.140] {
[18:01:58.140]     {
[18:01:58.140]         {
[18:01:58.140]             ...future.startTime <- base::Sys.time()
[18:01:58.140]             {
[18:01:58.140]                 {
[18:01:58.140]                   {
[18:01:58.140]                     {
[18:01:58.140]                       {
[18:01:58.140]                         base::local({
[18:01:58.140]                           has_future <- base::requireNamespace("future", 
[18:01:58.140]                             quietly = TRUE)
[18:01:58.140]                           if (has_future) {
[18:01:58.140]                             ns <- base::getNamespace("future")
[18:01:58.140]                             version <- ns[[".package"]][["version"]]
[18:01:58.140]                             if (is.null(version)) 
[18:01:58.140]                               version <- utils::packageVersion("future")
[18:01:58.140]                           }
[18:01:58.140]                           else {
[18:01:58.140]                             version <- NULL
[18:01:58.140]                           }
[18:01:58.140]                           if (!has_future || version < "1.8.0") {
[18:01:58.140]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:58.140]                               "", base::R.version$version.string), 
[18:01:58.140]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:58.140]                                 base::R.version$platform, 8 * 
[18:01:58.140]                                   base::.Machine$sizeof.pointer), 
[18:01:58.140]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:58.140]                                 "release", "version")], collapse = " "), 
[18:01:58.140]                               hostname = base::Sys.info()[["nodename"]])
[18:01:58.140]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:58.140]                               info)
[18:01:58.140]                             info <- base::paste(info, collapse = "; ")
[18:01:58.140]                             if (!has_future) {
[18:01:58.140]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:58.140]                                 info)
[18:01:58.140]                             }
[18:01:58.140]                             else {
[18:01:58.140]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:58.140]                                 info, version)
[18:01:58.140]                             }
[18:01:58.140]                             base::stop(msg)
[18:01:58.140]                           }
[18:01:58.140]                         })
[18:01:58.140]                       }
[18:01:58.140]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:58.140]                       base::options(mc.cores = 1L)
[18:01:58.140]                     }
[18:01:58.140]                     base::local({
[18:01:58.140]                       for (pkg in "future.apply") {
[18:01:58.140]                         base::loadNamespace(pkg)
[18:01:58.140]                         base::library(pkg, character.only = TRUE)
[18:01:58.140]                       }
[18:01:58.140]                     })
[18:01:58.140]                   }
[18:01:58.140]                   ...future.strategy.old <- future::plan("list")
[18:01:58.140]                   options(future.plan = NULL)
[18:01:58.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:58.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:58.140]                 }
[18:01:58.140]                 ...future.workdir <- getwd()
[18:01:58.140]             }
[18:01:58.140]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:58.140]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:58.140]         }
[18:01:58.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:58.140]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:58.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:58.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:58.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:58.140]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:58.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:58.140]             base::names(...future.oldOptions))
[18:01:58.140]     }
[18:01:58.140]     if (FALSE) {
[18:01:58.140]     }
[18:01:58.140]     else {
[18:01:58.140]         if (TRUE) {
[18:01:58.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:58.140]                 open = "w")
[18:01:58.140]         }
[18:01:58.140]         else {
[18:01:58.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:58.140]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:58.140]         }
[18:01:58.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:58.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:58.140]             base::sink(type = "output", split = FALSE)
[18:01:58.140]             base::close(...future.stdout)
[18:01:58.140]         }, add = TRUE)
[18:01:58.140]     }
[18:01:58.140]     ...future.frame <- base::sys.nframe()
[18:01:58.140]     ...future.conditions <- base::list()
[18:01:58.140]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:58.140]     if (FALSE) {
[18:01:58.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:58.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:58.140]     }
[18:01:58.140]     ...future.result <- base::tryCatch({
[18:01:58.140]         base::withCallingHandlers({
[18:01:58.140]             ...future.value <- base::withVisible(base::local({
[18:01:58.140]                 withCallingHandlers({
[18:01:58.140]                   {
[18:01:58.140]                     do.call(function(...) {
[18:01:58.140]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.140]                       if (!identical(...future.globals.maxSize.org, 
[18:01:58.140]                         ...future.globals.maxSize)) {
[18:01:58.140]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.140]                         on.exit(options(oopts), add = TRUE)
[18:01:58.140]                       }
[18:01:58.140]                       {
[18:01:58.140]                         lapply(seq_along(...future.elements_ii), 
[18:01:58.140]                           FUN = function(jj) {
[18:01:58.140]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.140]                             ...future.FUN(...future.X_jj, ...)
[18:01:58.140]                           })
[18:01:58.140]                       }
[18:01:58.140]                     }, args = future.call.arguments)
[18:01:58.140]                   }
[18:01:58.140]                 }, immediateCondition = function(cond) {
[18:01:58.140]                   save_rds <- function (object, pathname, ...) 
[18:01:58.140]                   {
[18:01:58.140]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:58.140]                     if (file_test("-f", pathname_tmp)) {
[18:01:58.140]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.140]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:58.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.140]                         fi_tmp[["mtime"]])
[18:01:58.140]                     }
[18:01:58.140]                     tryCatch({
[18:01:58.140]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:58.140]                     }, error = function(ex) {
[18:01:58.140]                       msg <- conditionMessage(ex)
[18:01:58.140]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.140]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:58.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.140]                         fi_tmp[["mtime"]], msg)
[18:01:58.140]                       ex$message <- msg
[18:01:58.140]                       stop(ex)
[18:01:58.140]                     })
[18:01:58.140]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:58.140]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:58.140]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:58.140]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.140]                       fi <- file.info(pathname)
[18:01:58.140]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:58.140]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.140]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:58.140]                         fi[["size"]], fi[["mtime"]])
[18:01:58.140]                       stop(msg)
[18:01:58.140]                     }
[18:01:58.140]                     invisible(pathname)
[18:01:58.140]                   }
[18:01:58.140]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:58.140]                     rootPath = tempdir()) 
[18:01:58.140]                   {
[18:01:58.140]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:58.140]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:58.140]                       tmpdir = path, fileext = ".rds")
[18:01:58.140]                     save_rds(obj, file)
[18:01:58.140]                   }
[18:01:58.140]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:58.140]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.140]                   {
[18:01:58.140]                     inherits <- base::inherits
[18:01:58.140]                     invokeRestart <- base::invokeRestart
[18:01:58.140]                     is.null <- base::is.null
[18:01:58.140]                     muffled <- FALSE
[18:01:58.140]                     if (inherits(cond, "message")) {
[18:01:58.140]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:58.140]                       if (muffled) 
[18:01:58.140]                         invokeRestart("muffleMessage")
[18:01:58.140]                     }
[18:01:58.140]                     else if (inherits(cond, "warning")) {
[18:01:58.140]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:58.140]                       if (muffled) 
[18:01:58.140]                         invokeRestart("muffleWarning")
[18:01:58.140]                     }
[18:01:58.140]                     else if (inherits(cond, "condition")) {
[18:01:58.140]                       if (!is.null(pattern)) {
[18:01:58.140]                         computeRestarts <- base::computeRestarts
[18:01:58.140]                         grepl <- base::grepl
[18:01:58.140]                         restarts <- computeRestarts(cond)
[18:01:58.140]                         for (restart in restarts) {
[18:01:58.140]                           name <- restart$name
[18:01:58.140]                           if (is.null(name)) 
[18:01:58.140]                             next
[18:01:58.140]                           if (!grepl(pattern, name)) 
[18:01:58.140]                             next
[18:01:58.140]                           invokeRestart(restart)
[18:01:58.140]                           muffled <- TRUE
[18:01:58.140]                           break
[18:01:58.140]                         }
[18:01:58.140]                       }
[18:01:58.140]                     }
[18:01:58.140]                     invisible(muffled)
[18:01:58.140]                   }
[18:01:58.140]                   muffleCondition(cond)
[18:01:58.140]                 })
[18:01:58.140]             }))
[18:01:58.140]             future::FutureResult(value = ...future.value$value, 
[18:01:58.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:58.140]                   ...future.rng), globalenv = if (FALSE) 
[18:01:58.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:58.140]                     ...future.globalenv.names))
[18:01:58.140]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:58.140]         }, condition = base::local({
[18:01:58.140]             c <- base::c
[18:01:58.140]             inherits <- base::inherits
[18:01:58.140]             invokeRestart <- base::invokeRestart
[18:01:58.140]             length <- base::length
[18:01:58.140]             list <- base::list
[18:01:58.140]             seq.int <- base::seq.int
[18:01:58.140]             signalCondition <- base::signalCondition
[18:01:58.140]             sys.calls <- base::sys.calls
[18:01:58.140]             `[[` <- base::`[[`
[18:01:58.140]             `+` <- base::`+`
[18:01:58.140]             `<<-` <- base::`<<-`
[18:01:58.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:58.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:58.140]                   3L)]
[18:01:58.140]             }
[18:01:58.140]             function(cond) {
[18:01:58.140]                 is_error <- inherits(cond, "error")
[18:01:58.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:58.140]                   NULL)
[18:01:58.140]                 if (is_error) {
[18:01:58.140]                   sessionInformation <- function() {
[18:01:58.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:58.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:58.140]                       search = base::search(), system = base::Sys.info())
[18:01:58.140]                   }
[18:01:58.140]                   ...future.conditions[[length(...future.conditions) + 
[18:01:58.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:58.140]                     cond$call), session = sessionInformation(), 
[18:01:58.140]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:58.140]                   signalCondition(cond)
[18:01:58.140]                 }
[18:01:58.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:58.140]                 "immediateCondition"))) {
[18:01:58.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:58.140]                   ...future.conditions[[length(...future.conditions) + 
[18:01:58.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:58.140]                   if (TRUE && !signal) {
[18:01:58.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.140]                     {
[18:01:58.140]                       inherits <- base::inherits
[18:01:58.140]                       invokeRestart <- base::invokeRestart
[18:01:58.140]                       is.null <- base::is.null
[18:01:58.140]                       muffled <- FALSE
[18:01:58.140]                       if (inherits(cond, "message")) {
[18:01:58.140]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:58.140]                         if (muffled) 
[18:01:58.140]                           invokeRestart("muffleMessage")
[18:01:58.140]                       }
[18:01:58.140]                       else if (inherits(cond, "warning")) {
[18:01:58.140]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:58.140]                         if (muffled) 
[18:01:58.140]                           invokeRestart("muffleWarning")
[18:01:58.140]                       }
[18:01:58.140]                       else if (inherits(cond, "condition")) {
[18:01:58.140]                         if (!is.null(pattern)) {
[18:01:58.140]                           computeRestarts <- base::computeRestarts
[18:01:58.140]                           grepl <- base::grepl
[18:01:58.140]                           restarts <- computeRestarts(cond)
[18:01:58.140]                           for (restart in restarts) {
[18:01:58.140]                             name <- restart$name
[18:01:58.140]                             if (is.null(name)) 
[18:01:58.140]                               next
[18:01:58.140]                             if (!grepl(pattern, name)) 
[18:01:58.140]                               next
[18:01:58.140]                             invokeRestart(restart)
[18:01:58.140]                             muffled <- TRUE
[18:01:58.140]                             break
[18:01:58.140]                           }
[18:01:58.140]                         }
[18:01:58.140]                       }
[18:01:58.140]                       invisible(muffled)
[18:01:58.140]                     }
[18:01:58.140]                     muffleCondition(cond, pattern = "^muffle")
[18:01:58.140]                   }
[18:01:58.140]                 }
[18:01:58.140]                 else {
[18:01:58.140]                   if (TRUE) {
[18:01:58.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.140]                     {
[18:01:58.140]                       inherits <- base::inherits
[18:01:58.140]                       invokeRestart <- base::invokeRestart
[18:01:58.140]                       is.null <- base::is.null
[18:01:58.140]                       muffled <- FALSE
[18:01:58.140]                       if (inherits(cond, "message")) {
[18:01:58.140]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:58.140]                         if (muffled) 
[18:01:58.140]                           invokeRestart("muffleMessage")
[18:01:58.140]                       }
[18:01:58.140]                       else if (inherits(cond, "warning")) {
[18:01:58.140]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:58.140]                         if (muffled) 
[18:01:58.140]                           invokeRestart("muffleWarning")
[18:01:58.140]                       }
[18:01:58.140]                       else if (inherits(cond, "condition")) {
[18:01:58.140]                         if (!is.null(pattern)) {
[18:01:58.140]                           computeRestarts <- base::computeRestarts
[18:01:58.140]                           grepl <- base::grepl
[18:01:58.140]                           restarts <- computeRestarts(cond)
[18:01:58.140]                           for (restart in restarts) {
[18:01:58.140]                             name <- restart$name
[18:01:58.140]                             if (is.null(name)) 
[18:01:58.140]                               next
[18:01:58.140]                             if (!grepl(pattern, name)) 
[18:01:58.140]                               next
[18:01:58.140]                             invokeRestart(restart)
[18:01:58.140]                             muffled <- TRUE
[18:01:58.140]                             break
[18:01:58.140]                           }
[18:01:58.140]                         }
[18:01:58.140]                       }
[18:01:58.140]                       invisible(muffled)
[18:01:58.140]                     }
[18:01:58.140]                     muffleCondition(cond, pattern = "^muffle")
[18:01:58.140]                   }
[18:01:58.140]                 }
[18:01:58.140]             }
[18:01:58.140]         }))
[18:01:58.140]     }, error = function(ex) {
[18:01:58.140]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:58.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:58.140]                 ...future.rng), started = ...future.startTime, 
[18:01:58.140]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:58.140]             version = "1.8"), class = "FutureResult")
[18:01:58.140]     }, finally = {
[18:01:58.140]         if (!identical(...future.workdir, getwd())) 
[18:01:58.140]             setwd(...future.workdir)
[18:01:58.140]         {
[18:01:58.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:58.140]                 ...future.oldOptions$nwarnings <- NULL
[18:01:58.140]             }
[18:01:58.140]             base::options(...future.oldOptions)
[18:01:58.140]             if (.Platform$OS.type == "windows") {
[18:01:58.140]                 old_names <- names(...future.oldEnvVars)
[18:01:58.140]                 envs <- base::Sys.getenv()
[18:01:58.140]                 names <- names(envs)
[18:01:58.140]                 common <- intersect(names, old_names)
[18:01:58.140]                 added <- setdiff(names, old_names)
[18:01:58.140]                 removed <- setdiff(old_names, names)
[18:01:58.140]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:58.140]                   envs[common]]
[18:01:58.140]                 NAMES <- toupper(changed)
[18:01:58.140]                 args <- list()
[18:01:58.140]                 for (kk in seq_along(NAMES)) {
[18:01:58.140]                   name <- changed[[kk]]
[18:01:58.140]                   NAME <- NAMES[[kk]]
[18:01:58.140]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.140]                     next
[18:01:58.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:58.140]                 }
[18:01:58.140]                 NAMES <- toupper(added)
[18:01:58.140]                 for (kk in seq_along(NAMES)) {
[18:01:58.140]                   name <- added[[kk]]
[18:01:58.140]                   NAME <- NAMES[[kk]]
[18:01:58.140]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.140]                     next
[18:01:58.140]                   args[[name]] <- ""
[18:01:58.140]                 }
[18:01:58.140]                 NAMES <- toupper(removed)
[18:01:58.140]                 for (kk in seq_along(NAMES)) {
[18:01:58.140]                   name <- removed[[kk]]
[18:01:58.140]                   NAME <- NAMES[[kk]]
[18:01:58.140]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.140]                     next
[18:01:58.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:58.140]                 }
[18:01:58.140]                 if (length(args) > 0) 
[18:01:58.140]                   base::do.call(base::Sys.setenv, args = args)
[18:01:58.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:58.140]             }
[18:01:58.140]             else {
[18:01:58.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:58.140]             }
[18:01:58.140]             {
[18:01:58.140]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:58.140]                   0L) {
[18:01:58.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:58.140]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:58.140]                   base::options(opts)
[18:01:58.140]                 }
[18:01:58.140]                 {
[18:01:58.140]                   {
[18:01:58.140]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:58.140]                     NULL
[18:01:58.140]                   }
[18:01:58.140]                   options(future.plan = NULL)
[18:01:58.140]                   if (is.na(NA_character_)) 
[18:01:58.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:58.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:58.140]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:58.140]                     .init = FALSE)
[18:01:58.140]                 }
[18:01:58.140]             }
[18:01:58.140]         }
[18:01:58.140]     })
[18:01:58.140]     if (TRUE) {
[18:01:58.140]         base::sink(type = "output", split = FALSE)
[18:01:58.140]         if (TRUE) {
[18:01:58.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:58.140]         }
[18:01:58.140]         else {
[18:01:58.140]             ...future.result["stdout"] <- base::list(NULL)
[18:01:58.140]         }
[18:01:58.140]         base::close(...future.stdout)
[18:01:58.140]         ...future.stdout <- NULL
[18:01:58.140]     }
[18:01:58.140]     ...future.result$conditions <- ...future.conditions
[18:01:58.140]     ...future.result$finished <- base::Sys.time()
[18:01:58.140]     ...future.result
[18:01:58.140] }
[18:01:58.144] assign_globals() ...
[18:01:58.144] List of 11
[18:01:58.144]  $ ...future.FUN            :function (x, ...)  
[18:01:58.144]  $ x_FUN                    :function (x)  
[18:01:58.144]  $ times                    : int 2
[18:01:58.144]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:58.144]  $ stop_if_not              :function (...)  
[18:01:58.144]  $ dim                      : NULL
[18:01:58.144]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:58.144]  $ future.call.arguments    : list()
[18:01:58.144]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.144]  $ ...future.elements_ii    :List of 5
[18:01:58.144]   ..$ : int 1
[18:01:58.144]   ..$ : int 2
[18:01:58.144]   ..$ : int 3
[18:01:58.144]   ..$ : int 4
[18:01:58.144]   ..$ : int 5
[18:01:58.144]  $ ...future.seeds_ii       : NULL
[18:01:58.144]  $ ...future.globals.maxSize: NULL
[18:01:58.144]  - attr(*, "where")=List of 11
[18:01:58.144]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:58.144]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:58.144]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:58.144]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:58.144]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:58.144]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:58.144]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:58.144]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:58.144]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:58.144]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:58.144]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:58.144]  - attr(*, "resolved")= logi FALSE
[18:01:58.144]  - attr(*, "total_size")= num 96456
[18:01:58.144]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.144]  - attr(*, "already-done")= logi TRUE
[18:01:58.164] - copied ‘...future.FUN’ to environment
[18:01:58.165] - reassign environment for ‘x_FUN’
[18:01:58.165] - copied ‘x_FUN’ to environment
[18:01:58.165] - copied ‘times’ to environment
[18:01:58.165] - copied ‘stopf’ to environment
[18:01:58.165] - copied ‘stop_if_not’ to environment
[18:01:58.166] - copied ‘dim’ to environment
[18:01:58.166] - copied ‘valid_types’ to environment
[18:01:58.166] - copied ‘future.call.arguments’ to environment
[18:01:58.166] - copied ‘...future.elements_ii’ to environment
[18:01:58.167] - copied ‘...future.seeds_ii’ to environment
[18:01:58.167] - copied ‘...future.globals.maxSize’ to environment
[18:01:58.167] assign_globals() ... done
[18:01:58.167] requestCore(): workers = 2
[18:01:58.172] MulticoreFuture started
[18:01:58.173] - Launch lazy future ... done
[18:01:58.174] run() for ‘MulticoreFuture’ ... done
[18:01:58.175] Created future:
[18:01:58.175] plan(): Setting new future strategy stack:
[18:01:58.176] List of future strategies:
[18:01:58.176] 1. sequential:
[18:01:58.176]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:58.176]    - tweaked: FALSE
[18:01:58.176]    - call: NULL
[18:01:58.180] plan(): nbrOfWorkers() = 1
[18:01:58.184] plan(): Setting new future strategy stack:
[18:01:58.185] List of future strategies:
[18:01:58.185] 1. multicore:
[18:01:58.185]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:58.185]    - tweaked: FALSE
[18:01:58.185]    - call: plan(strategy)
[18:01:58.176] MulticoreFuture:
[18:01:58.176] Label: ‘future_vapply-1’
[18:01:58.176] Expression:
[18:01:58.176] {
[18:01:58.176]     do.call(function(...) {
[18:01:58.176]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.176]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.176]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.176]             on.exit(options(oopts), add = TRUE)
[18:01:58.176]         }
[18:01:58.176]         {
[18:01:58.176]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.176]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.176]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.176]             })
[18:01:58.176]         }
[18:01:58.176]     }, args = future.call.arguments)
[18:01:58.176] }
[18:01:58.176] Lazy evaluation: FALSE
[18:01:58.176] Asynchronous evaluation: TRUE
[18:01:58.176] Local evaluation: TRUE
[18:01:58.176] Environment: R_GlobalEnv
[18:01:58.176] Capture standard output: TRUE
[18:01:58.176] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:58.176] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:58.176] Packages: 1 packages (‘future.apply’)
[18:01:58.176] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:58.176] Resolved: FALSE
[18:01:58.176] Value: <not collected>
[18:01:58.176] Conditions captured: <none>
[18:01:58.176] Early signaling: FALSE
[18:01:58.176] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:58.176] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.193] Chunk #1 of 2 ... DONE
[18:01:58.193] Chunk #2 of 2 ...
[18:01:58.194]  - Finding globals in 'X' for chunk #2 ...
[18:01:58.194] getGlobalsAndPackages() ...
[18:01:58.195] Searching for globals...
[18:01:58.195] plan(): nbrOfWorkers() = 2
[18:01:58.196] 
[18:01:58.196] Searching for globals ... DONE
[18:01:58.196] - globals: [0] <none>
[18:01:58.196] getGlobalsAndPackages() ... DONE
[18:01:58.197]    + additional globals found: [n=0] 
[18:01:58.197]    + additional namespaces needed: [n=0] 
[18:01:58.197]  - Finding globals in 'X' for chunk #2 ... DONE
[18:01:58.198]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:58.198]  - seeds: <none>
[18:01:58.198]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.199] getGlobalsAndPackages() ...
[18:01:58.199] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.199] Resolving globals: FALSE
[18:01:58.200] Tweak future expression to call with '...' arguments ...
[18:01:58.200] {
[18:01:58.200]     do.call(function(...) {
[18:01:58.200]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.200]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.200]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.200]             on.exit(options(oopts), add = TRUE)
[18:01:58.200]         }
[18:01:58.200]         {
[18:01:58.200]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.200]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.200]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.200]             })
[18:01:58.200]         }
[18:01:58.200]     }, args = future.call.arguments)
[18:01:58.200] }
[18:01:58.201] Tweak future expression to call with '...' arguments ... DONE
[18:01:58.203] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.203] - packages: [1] ‘future.apply’
[18:01:58.203] getGlobalsAndPackages() ... DONE
[18:01:58.204] run() for ‘Future’ ...
[18:01:58.205] - state: ‘created’
[18:01:58.205] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:58.213] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.213] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:58.214]   - Field: ‘label’
[18:01:58.214]   - Field: ‘local’
[18:01:58.214]   - Field: ‘owner’
[18:01:58.214]   - Field: ‘envir’
[18:01:58.215]   - Field: ‘workers’
[18:01:58.215]   - Field: ‘packages’
[18:01:58.215]   - Field: ‘gc’
[18:01:58.216]   - Field: ‘job’
[18:01:58.216]   - Field: ‘conditions’
[18:01:58.216]   - Field: ‘expr’
[18:01:58.217]   - Field: ‘uuid’
[18:01:58.217]   - Field: ‘seed’
[18:01:58.217]   - Field: ‘version’
[18:01:58.217]   - Field: ‘result’
[18:01:58.218]   - Field: ‘asynchronous’
[18:01:58.218]   - Field: ‘calls’
[18:01:58.218]   - Field: ‘globals’
[18:01:58.219]   - Field: ‘stdout’
[18:01:58.219]   - Field: ‘earlySignal’
[18:01:58.219]   - Field: ‘lazy’
[18:01:58.220]   - Field: ‘state’
[18:01:58.220] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:58.220] - Launch lazy future ...
[18:01:58.221] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:58.222] Packages needed by future strategies (n = 0): <none>
[18:01:58.223] {
[18:01:58.223]     {
[18:01:58.223]         {
[18:01:58.223]             ...future.startTime <- base::Sys.time()
[18:01:58.223]             {
[18:01:58.223]                 {
[18:01:58.223]                   {
[18:01:58.223]                     {
[18:01:58.223]                       {
[18:01:58.223]                         base::local({
[18:01:58.223]                           has_future <- base::requireNamespace("future", 
[18:01:58.223]                             quietly = TRUE)
[18:01:58.223]                           if (has_future) {
[18:01:58.223]                             ns <- base::getNamespace("future")
[18:01:58.223]                             version <- ns[[".package"]][["version"]]
[18:01:58.223]                             if (is.null(version)) 
[18:01:58.223]                               version <- utils::packageVersion("future")
[18:01:58.223]                           }
[18:01:58.223]                           else {
[18:01:58.223]                             version <- NULL
[18:01:58.223]                           }
[18:01:58.223]                           if (!has_future || version < "1.8.0") {
[18:01:58.223]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:58.223]                               "", base::R.version$version.string), 
[18:01:58.223]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:58.223]                                 base::R.version$platform, 8 * 
[18:01:58.223]                                   base::.Machine$sizeof.pointer), 
[18:01:58.223]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:58.223]                                 "release", "version")], collapse = " "), 
[18:01:58.223]                               hostname = base::Sys.info()[["nodename"]])
[18:01:58.223]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:58.223]                               info)
[18:01:58.223]                             info <- base::paste(info, collapse = "; ")
[18:01:58.223]                             if (!has_future) {
[18:01:58.223]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:58.223]                                 info)
[18:01:58.223]                             }
[18:01:58.223]                             else {
[18:01:58.223]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:58.223]                                 info, version)
[18:01:58.223]                             }
[18:01:58.223]                             base::stop(msg)
[18:01:58.223]                           }
[18:01:58.223]                         })
[18:01:58.223]                       }
[18:01:58.223]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:58.223]                       base::options(mc.cores = 1L)
[18:01:58.223]                     }
[18:01:58.223]                     base::local({
[18:01:58.223]                       for (pkg in "future.apply") {
[18:01:58.223]                         base::loadNamespace(pkg)
[18:01:58.223]                         base::library(pkg, character.only = TRUE)
[18:01:58.223]                       }
[18:01:58.223]                     })
[18:01:58.223]                   }
[18:01:58.223]                   ...future.strategy.old <- future::plan("list")
[18:01:58.223]                   options(future.plan = NULL)
[18:01:58.223]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:58.223]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:58.223]                 }
[18:01:58.223]                 ...future.workdir <- getwd()
[18:01:58.223]             }
[18:01:58.223]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:58.223]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:58.223]         }
[18:01:58.223]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:58.223]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:58.223]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:58.223]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:58.223]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:58.223]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:58.223]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:58.223]             base::names(...future.oldOptions))
[18:01:58.223]     }
[18:01:58.223]     if (FALSE) {
[18:01:58.223]     }
[18:01:58.223]     else {
[18:01:58.223]         if (TRUE) {
[18:01:58.223]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:58.223]                 open = "w")
[18:01:58.223]         }
[18:01:58.223]         else {
[18:01:58.223]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:58.223]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:58.223]         }
[18:01:58.223]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:58.223]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:58.223]             base::sink(type = "output", split = FALSE)
[18:01:58.223]             base::close(...future.stdout)
[18:01:58.223]         }, add = TRUE)
[18:01:58.223]     }
[18:01:58.223]     ...future.frame <- base::sys.nframe()
[18:01:58.223]     ...future.conditions <- base::list()
[18:01:58.223]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:58.223]     if (FALSE) {
[18:01:58.223]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:58.223]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:58.223]     }
[18:01:58.223]     ...future.result <- base::tryCatch({
[18:01:58.223]         base::withCallingHandlers({
[18:01:58.223]             ...future.value <- base::withVisible(base::local({
[18:01:58.223]                 withCallingHandlers({
[18:01:58.223]                   {
[18:01:58.223]                     do.call(function(...) {
[18:01:58.223]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.223]                       if (!identical(...future.globals.maxSize.org, 
[18:01:58.223]                         ...future.globals.maxSize)) {
[18:01:58.223]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.223]                         on.exit(options(oopts), add = TRUE)
[18:01:58.223]                       }
[18:01:58.223]                       {
[18:01:58.223]                         lapply(seq_along(...future.elements_ii), 
[18:01:58.223]                           FUN = function(jj) {
[18:01:58.223]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.223]                             ...future.FUN(...future.X_jj, ...)
[18:01:58.223]                           })
[18:01:58.223]                       }
[18:01:58.223]                     }, args = future.call.arguments)
[18:01:58.223]                   }
[18:01:58.223]                 }, immediateCondition = function(cond) {
[18:01:58.223]                   save_rds <- function (object, pathname, ...) 
[18:01:58.223]                   {
[18:01:58.223]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:58.223]                     if (file_test("-f", pathname_tmp)) {
[18:01:58.223]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.223]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:58.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.223]                         fi_tmp[["mtime"]])
[18:01:58.223]                     }
[18:01:58.223]                     tryCatch({
[18:01:58.223]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:58.223]                     }, error = function(ex) {
[18:01:58.223]                       msg <- conditionMessage(ex)
[18:01:58.223]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.223]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:58.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.223]                         fi_tmp[["mtime"]], msg)
[18:01:58.223]                       ex$message <- msg
[18:01:58.223]                       stop(ex)
[18:01:58.223]                     })
[18:01:58.223]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:58.223]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:58.223]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:58.223]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.223]                       fi <- file.info(pathname)
[18:01:58.223]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:58.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.223]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:58.223]                         fi[["size"]], fi[["mtime"]])
[18:01:58.223]                       stop(msg)
[18:01:58.223]                     }
[18:01:58.223]                     invisible(pathname)
[18:01:58.223]                   }
[18:01:58.223]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:58.223]                     rootPath = tempdir()) 
[18:01:58.223]                   {
[18:01:58.223]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:58.223]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:58.223]                       tmpdir = path, fileext = ".rds")
[18:01:58.223]                     save_rds(obj, file)
[18:01:58.223]                   }
[18:01:58.223]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:58.223]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.223]                   {
[18:01:58.223]                     inherits <- base::inherits
[18:01:58.223]                     invokeRestart <- base::invokeRestart
[18:01:58.223]                     is.null <- base::is.null
[18:01:58.223]                     muffled <- FALSE
[18:01:58.223]                     if (inherits(cond, "message")) {
[18:01:58.223]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:58.223]                       if (muffled) 
[18:01:58.223]                         invokeRestart("muffleMessage")
[18:01:58.223]                     }
[18:01:58.223]                     else if (inherits(cond, "warning")) {
[18:01:58.223]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:58.223]                       if (muffled) 
[18:01:58.223]                         invokeRestart("muffleWarning")
[18:01:58.223]                     }
[18:01:58.223]                     else if (inherits(cond, "condition")) {
[18:01:58.223]                       if (!is.null(pattern)) {
[18:01:58.223]                         computeRestarts <- base::computeRestarts
[18:01:58.223]                         grepl <- base::grepl
[18:01:58.223]                         restarts <- computeRestarts(cond)
[18:01:58.223]                         for (restart in restarts) {
[18:01:58.223]                           name <- restart$name
[18:01:58.223]                           if (is.null(name)) 
[18:01:58.223]                             next
[18:01:58.223]                           if (!grepl(pattern, name)) 
[18:01:58.223]                             next
[18:01:58.223]                           invokeRestart(restart)
[18:01:58.223]                           muffled <- TRUE
[18:01:58.223]                           break
[18:01:58.223]                         }
[18:01:58.223]                       }
[18:01:58.223]                     }
[18:01:58.223]                     invisible(muffled)
[18:01:58.223]                   }
[18:01:58.223]                   muffleCondition(cond)
[18:01:58.223]                 })
[18:01:58.223]             }))
[18:01:58.223]             future::FutureResult(value = ...future.value$value, 
[18:01:58.223]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:58.223]                   ...future.rng), globalenv = if (FALSE) 
[18:01:58.223]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:58.223]                     ...future.globalenv.names))
[18:01:58.223]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:58.223]         }, condition = base::local({
[18:01:58.223]             c <- base::c
[18:01:58.223]             inherits <- base::inherits
[18:01:58.223]             invokeRestart <- base::invokeRestart
[18:01:58.223]             length <- base::length
[18:01:58.223]             list <- base::list
[18:01:58.223]             seq.int <- base::seq.int
[18:01:58.223]             signalCondition <- base::signalCondition
[18:01:58.223]             sys.calls <- base::sys.calls
[18:01:58.223]             `[[` <- base::`[[`
[18:01:58.223]             `+` <- base::`+`
[18:01:58.223]             `<<-` <- base::`<<-`
[18:01:58.223]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:58.223]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:58.223]                   3L)]
[18:01:58.223]             }
[18:01:58.223]             function(cond) {
[18:01:58.223]                 is_error <- inherits(cond, "error")
[18:01:58.223]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:58.223]                   NULL)
[18:01:58.223]                 if (is_error) {
[18:01:58.223]                   sessionInformation <- function() {
[18:01:58.223]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:58.223]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:58.223]                       search = base::search(), system = base::Sys.info())
[18:01:58.223]                   }
[18:01:58.223]                   ...future.conditions[[length(...future.conditions) + 
[18:01:58.223]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:58.223]                     cond$call), session = sessionInformation(), 
[18:01:58.223]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:58.223]                   signalCondition(cond)
[18:01:58.223]                 }
[18:01:58.223]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:58.223]                 "immediateCondition"))) {
[18:01:58.223]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:58.223]                   ...future.conditions[[length(...future.conditions) + 
[18:01:58.223]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:58.223]                   if (TRUE && !signal) {
[18:01:58.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.223]                     {
[18:01:58.223]                       inherits <- base::inherits
[18:01:58.223]                       invokeRestart <- base::invokeRestart
[18:01:58.223]                       is.null <- base::is.null
[18:01:58.223]                       muffled <- FALSE
[18:01:58.223]                       if (inherits(cond, "message")) {
[18:01:58.223]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:58.223]                         if (muffled) 
[18:01:58.223]                           invokeRestart("muffleMessage")
[18:01:58.223]                       }
[18:01:58.223]                       else if (inherits(cond, "warning")) {
[18:01:58.223]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:58.223]                         if (muffled) 
[18:01:58.223]                           invokeRestart("muffleWarning")
[18:01:58.223]                       }
[18:01:58.223]                       else if (inherits(cond, "condition")) {
[18:01:58.223]                         if (!is.null(pattern)) {
[18:01:58.223]                           computeRestarts <- base::computeRestarts
[18:01:58.223]                           grepl <- base::grepl
[18:01:58.223]                           restarts <- computeRestarts(cond)
[18:01:58.223]                           for (restart in restarts) {
[18:01:58.223]                             name <- restart$name
[18:01:58.223]                             if (is.null(name)) 
[18:01:58.223]                               next
[18:01:58.223]                             if (!grepl(pattern, name)) 
[18:01:58.223]                               next
[18:01:58.223]                             invokeRestart(restart)
[18:01:58.223]                             muffled <- TRUE
[18:01:58.223]                             break
[18:01:58.223]                           }
[18:01:58.223]                         }
[18:01:58.223]                       }
[18:01:58.223]                       invisible(muffled)
[18:01:58.223]                     }
[18:01:58.223]                     muffleCondition(cond, pattern = "^muffle")
[18:01:58.223]                   }
[18:01:58.223]                 }
[18:01:58.223]                 else {
[18:01:58.223]                   if (TRUE) {
[18:01:58.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.223]                     {
[18:01:58.223]                       inherits <- base::inherits
[18:01:58.223]                       invokeRestart <- base::invokeRestart
[18:01:58.223]                       is.null <- base::is.null
[18:01:58.223]                       muffled <- FALSE
[18:01:58.223]                       if (inherits(cond, "message")) {
[18:01:58.223]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:58.223]                         if (muffled) 
[18:01:58.223]                           invokeRestart("muffleMessage")
[18:01:58.223]                       }
[18:01:58.223]                       else if (inherits(cond, "warning")) {
[18:01:58.223]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:58.223]                         if (muffled) 
[18:01:58.223]                           invokeRestart("muffleWarning")
[18:01:58.223]                       }
[18:01:58.223]                       else if (inherits(cond, "condition")) {
[18:01:58.223]                         if (!is.null(pattern)) {
[18:01:58.223]                           computeRestarts <- base::computeRestarts
[18:01:58.223]                           grepl <- base::grepl
[18:01:58.223]                           restarts <- computeRestarts(cond)
[18:01:58.223]                           for (restart in restarts) {
[18:01:58.223]                             name <- restart$name
[18:01:58.223]                             if (is.null(name)) 
[18:01:58.223]                               next
[18:01:58.223]                             if (!grepl(pattern, name)) 
[18:01:58.223]                               next
[18:01:58.223]                             invokeRestart(restart)
[18:01:58.223]                             muffled <- TRUE
[18:01:58.223]                             break
[18:01:58.223]                           }
[18:01:58.223]                         }
[18:01:58.223]                       }
[18:01:58.223]                       invisible(muffled)
[18:01:58.223]                     }
[18:01:58.223]                     muffleCondition(cond, pattern = "^muffle")
[18:01:58.223]                   }
[18:01:58.223]                 }
[18:01:58.223]             }
[18:01:58.223]         }))
[18:01:58.223]     }, error = function(ex) {
[18:01:58.223]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:58.223]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:58.223]                 ...future.rng), started = ...future.startTime, 
[18:01:58.223]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:58.223]             version = "1.8"), class = "FutureResult")
[18:01:58.223]     }, finally = {
[18:01:58.223]         if (!identical(...future.workdir, getwd())) 
[18:01:58.223]             setwd(...future.workdir)
[18:01:58.223]         {
[18:01:58.223]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:58.223]                 ...future.oldOptions$nwarnings <- NULL
[18:01:58.223]             }
[18:01:58.223]             base::options(...future.oldOptions)
[18:01:58.223]             if (.Platform$OS.type == "windows") {
[18:01:58.223]                 old_names <- names(...future.oldEnvVars)
[18:01:58.223]                 envs <- base::Sys.getenv()
[18:01:58.223]                 names <- names(envs)
[18:01:58.223]                 common <- intersect(names, old_names)
[18:01:58.223]                 added <- setdiff(names, old_names)
[18:01:58.223]                 removed <- setdiff(old_names, names)
[18:01:58.223]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:58.223]                   envs[common]]
[18:01:58.223]                 NAMES <- toupper(changed)
[18:01:58.223]                 args <- list()
[18:01:58.223]                 for (kk in seq_along(NAMES)) {
[18:01:58.223]                   name <- changed[[kk]]
[18:01:58.223]                   NAME <- NAMES[[kk]]
[18:01:58.223]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.223]                     next
[18:01:58.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:58.223]                 }
[18:01:58.223]                 NAMES <- toupper(added)
[18:01:58.223]                 for (kk in seq_along(NAMES)) {
[18:01:58.223]                   name <- added[[kk]]
[18:01:58.223]                   NAME <- NAMES[[kk]]
[18:01:58.223]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.223]                     next
[18:01:58.223]                   args[[name]] <- ""
[18:01:58.223]                 }
[18:01:58.223]                 NAMES <- toupper(removed)
[18:01:58.223]                 for (kk in seq_along(NAMES)) {
[18:01:58.223]                   name <- removed[[kk]]
[18:01:58.223]                   NAME <- NAMES[[kk]]
[18:01:58.223]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.223]                     next
[18:01:58.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:58.223]                 }
[18:01:58.223]                 if (length(args) > 0) 
[18:01:58.223]                   base::do.call(base::Sys.setenv, args = args)
[18:01:58.223]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:58.223]             }
[18:01:58.223]             else {
[18:01:58.223]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:58.223]             }
[18:01:58.223]             {
[18:01:58.223]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:58.223]                   0L) {
[18:01:58.223]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:58.223]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:58.223]                   base::options(opts)
[18:01:58.223]                 }
[18:01:58.223]                 {
[18:01:58.223]                   {
[18:01:58.223]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:58.223]                     NULL
[18:01:58.223]                   }
[18:01:58.223]                   options(future.plan = NULL)
[18:01:58.223]                   if (is.na(NA_character_)) 
[18:01:58.223]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:58.223]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:58.223]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:58.223]                     .init = FALSE)
[18:01:58.223]                 }
[18:01:58.223]             }
[18:01:58.223]         }
[18:01:58.223]     })
[18:01:58.223]     if (TRUE) {
[18:01:58.223]         base::sink(type = "output", split = FALSE)
[18:01:58.223]         if (TRUE) {
[18:01:58.223]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:58.223]         }
[18:01:58.223]         else {
[18:01:58.223]             ...future.result["stdout"] <- base::list(NULL)
[18:01:58.223]         }
[18:01:58.223]         base::close(...future.stdout)
[18:01:58.223]         ...future.stdout <- NULL
[18:01:58.223]     }
[18:01:58.223]     ...future.result$conditions <- ...future.conditions
[18:01:58.223]     ...future.result$finished <- base::Sys.time()
[18:01:58.223]     ...future.result
[18:01:58.223] }
[18:01:58.231] assign_globals() ...
[18:01:58.231] List of 11
[18:01:58.231]  $ ...future.FUN            :function (x, ...)  
[18:01:58.231]  $ x_FUN                    :function (x)  
[18:01:58.231]  $ times                    : int 2
[18:01:58.231]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:58.231]  $ stop_if_not              :function (...)  
[18:01:58.231]  $ dim                      : NULL
[18:01:58.231]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:58.231]  $ future.call.arguments    : list()
[18:01:58.231]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.231]  $ ...future.elements_ii    :List of 5
[18:01:58.231]   ..$ : int 6
[18:01:58.231]   ..$ : int 7
[18:01:58.231]   ..$ : int 8
[18:01:58.231]   ..$ : int 9
[18:01:58.231]   ..$ : int 10
[18:01:58.231]  $ ...future.seeds_ii       : NULL
[18:01:58.231]  $ ...future.globals.maxSize: NULL
[18:01:58.231]  - attr(*, "where")=List of 11
[18:01:58.231]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:58.231]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:58.231]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:58.231]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:58.231]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:58.231]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:58.231]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:58.231]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:58.231]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:58.231]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:58.231]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:58.231]  - attr(*, "resolved")= logi FALSE
[18:01:58.231]  - attr(*, "total_size")= num 96456
[18:01:58.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.231]  - attr(*, "already-done")= logi TRUE
[18:01:58.260] - copied ‘...future.FUN’ to environment
[18:01:58.261] - reassign environment for ‘x_FUN’
[18:01:58.261] - copied ‘x_FUN’ to environment
[18:01:58.262] - copied ‘times’ to environment
[18:01:58.262] - copied ‘stopf’ to environment
[18:01:58.262] - copied ‘stop_if_not’ to environment
[18:01:58.263] - copied ‘dim’ to environment
[18:01:58.263] - copied ‘valid_types’ to environment
[18:01:58.263] - copied ‘future.call.arguments’ to environment
[18:01:58.264] - copied ‘...future.elements_ii’ to environment
[18:01:58.264] - copied ‘...future.seeds_ii’ to environment
[18:01:58.264] - copied ‘...future.globals.maxSize’ to environment
[18:01:58.264] assign_globals() ... done
[18:01:58.265] requestCore(): workers = 2
[18:01:58.269] MulticoreFuture started
[18:01:58.274] - Launch lazy future ... done
[18:01:58.275] run() for ‘MulticoreFuture’ ... done
[18:01:58.276] plan(): Setting new future strategy stack:
[18:01:58.278] Created future:
[18:01:58.277] List of future strategies:
[18:01:58.277] 1. sequential:
[18:01:58.277]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:58.277]    - tweaked: FALSE
[18:01:58.277]    - call: NULL
[18:01:58.284] plan(): nbrOfWorkers() = 1
[18:01:58.288] plan(): Setting new future strategy stack:
[18:01:58.289] List of future strategies:
[18:01:58.289] 1. multicore:
[18:01:58.289]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:58.289]    - tweaked: FALSE
[18:01:58.289]    - call: plan(strategy)
[18:01:58.278] MulticoreFuture:
[18:01:58.278] Label: ‘future_vapply-2’
[18:01:58.278] Expression:
[18:01:58.278] {
[18:01:58.278]     do.call(function(...) {
[18:01:58.278]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.278]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.278]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.278]             on.exit(options(oopts), add = TRUE)
[18:01:58.278]         }
[18:01:58.278]         {
[18:01:58.278]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.278]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.278]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.278]             })
[18:01:58.278]         }
[18:01:58.278]     }, args = future.call.arguments)
[18:01:58.278] }
[18:01:58.278] Lazy evaluation: FALSE
[18:01:58.278] Asynchronous evaluation: TRUE
[18:01:58.278] Local evaluation: TRUE
[18:01:58.278] Environment: R_GlobalEnv
[18:01:58.278] Capture standard output: TRUE
[18:01:58.278] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:58.278] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:58.278] Packages: 1 packages (‘future.apply’)
[18:01:58.278] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:58.278] Resolved: FALSE
[18:01:58.278] Value: <not collected>
[18:01:58.278] Conditions captured: <none>
[18:01:58.278] Early signaling: FALSE
[18:01:58.278] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:58.278] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.297] Chunk #2 of 2 ... DONE
[18:01:58.297] Launching 2 futures (chunks) ... DONE
[18:01:58.298] Resolving 2 futures (chunks) ...
[18:01:58.298] resolve() on list ...
[18:01:58.298]  recursive: 0
[18:01:58.298] plan(): nbrOfWorkers() = 2
[18:01:58.299]  length: 2
[18:01:58.299] 
[18:01:58.300] Future #1
[18:01:58.300] result() for MulticoreFuture ...
[18:01:58.302] result() for MulticoreFuture ...
[18:01:58.302] result() for MulticoreFuture ... done
[18:01:58.302] result() for MulticoreFuture ... done
[18:01:58.302] result() for MulticoreFuture ...
[18:01:58.303] result() for MulticoreFuture ... done
[18:01:58.303] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:58.304] - nx: 2
[18:01:58.304] - relay: TRUE
[18:01:58.304] - stdout: TRUE
[18:01:58.304] - signal: TRUE
[18:01:58.305] - resignal: FALSE
[18:01:58.305] - force: TRUE
[18:01:58.305] - relayed: [n=2] FALSE, FALSE
[18:01:58.306] - queued futures: [n=2] FALSE, FALSE
[18:01:58.306]  - until=1
[18:01:58.306]  - relaying element #1
[18:01:58.307] result() for MulticoreFuture ...
[18:01:58.307] result() for MulticoreFuture ... done
[18:01:58.307] result() for MulticoreFuture ...
[18:01:58.308] result() for MulticoreFuture ... done
[18:01:58.308] result() for MulticoreFuture ...
[18:01:58.308] result() for MulticoreFuture ... done
[18:01:58.309] result() for MulticoreFuture ...
[18:01:58.309] result() for MulticoreFuture ... done
[18:01:58.309] - relayed: [n=2] TRUE, FALSE
[18:01:58.309] - queued futures: [n=2] TRUE, FALSE
[18:01:58.310] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:58.310]  length: 1 (resolved future 1)
[18:01:58.311] Future #2
[18:01:58.311] result() for MulticoreFuture ...
[18:01:58.312] result() for MulticoreFuture ...
[18:01:58.313] result() for MulticoreFuture ... done
[18:01:58.313] result() for MulticoreFuture ... done
[18:01:58.313] result() for MulticoreFuture ...
[18:01:58.314] result() for MulticoreFuture ... done
[18:01:58.314] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:58.314] - nx: 2
[18:01:58.315] - relay: TRUE
[18:01:58.315] - stdout: TRUE
[18:01:58.315] - signal: TRUE
[18:01:58.315] - resignal: FALSE
[18:01:58.316] - force: TRUE
[18:01:58.316] - relayed: [n=2] TRUE, FALSE
[18:01:58.316] - queued futures: [n=2] TRUE, FALSE
[18:01:58.316]  - until=2
[18:01:58.316]  - relaying element #2
[18:01:58.317] result() for MulticoreFuture ...
[18:01:58.317] result() for MulticoreFuture ... done
[18:01:58.317] result() for MulticoreFuture ...
[18:01:58.317] result() for MulticoreFuture ... done
[18:01:58.318] result() for MulticoreFuture ...
[18:01:58.318] result() for MulticoreFuture ... done
[18:01:58.318] result() for MulticoreFuture ...
[18:01:58.318] result() for MulticoreFuture ... done
[18:01:58.319] - relayed: [n=2] TRUE, TRUE
[18:01:58.319] - queued futures: [n=2] TRUE, TRUE
[18:01:58.319] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:58.319]  length: 0 (resolved future 2)
[18:01:58.319] Relaying remaining futures
[18:01:58.320] signalConditionsASAP(NULL, pos=0) ...
[18:01:58.320] - nx: 2
[18:01:58.320] - relay: TRUE
[18:01:58.320] - stdout: TRUE
[18:01:58.321] - signal: TRUE
[18:01:58.321] - resignal: FALSE
[18:01:58.321] - force: TRUE
[18:01:58.321] - relayed: [n=2] TRUE, TRUE
[18:01:58.321] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:58.322] - relayed: [n=2] TRUE, TRUE
[18:01:58.322] - queued futures: [n=2] TRUE, TRUE
[18:01:58.322] signalConditionsASAP(NULL, pos=0) ... done
[18:01:58.322] resolve() on list ... DONE
[18:01:58.323] result() for MulticoreFuture ...
[18:01:58.323] result() for MulticoreFuture ... done
[18:01:58.323] result() for MulticoreFuture ...
[18:01:58.323] result() for MulticoreFuture ... done
[18:01:58.324] result() for MulticoreFuture ...
[18:01:58.324] result() for MulticoreFuture ... done
[18:01:58.324] result() for MulticoreFuture ...
[18:01:58.324] result() for MulticoreFuture ... done
[18:01:58.325]  - Number of value chunks collected: 2
[18:01:58.325] Resolving 2 futures (chunks) ... DONE
[18:01:58.325] Reducing values from 2 chunks ...
[18:01:58.325]  - Number of values collected after concatenation: 10
[18:01:58.325]  - Number of values expected: 10
[18:01:58.326] Reducing values from 2 chunks ... DONE
[18:01:58.326] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[18:01:58.328] future_lapply() ...
[18:01:58.339] Number of chunks: 2
[18:01:58.339] getGlobalsAndPackagesXApply() ...
[18:01:58.339]  - future.globals: TRUE
[18:01:58.340] getGlobalsAndPackages() ...
[18:01:58.340] Searching for globals...
[18:01:58.353] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[18:01:58.353] Searching for globals ... DONE
[18:01:58.353] Resolving globals: FALSE
[18:01:58.355] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[18:01:58.356] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:58.356] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:58.357] - packages: [1] ‘future.apply’
[18:01:58.357] getGlobalsAndPackages() ... DONE
[18:01:58.357]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:58.357]  - needed namespaces: [n=1] ‘future.apply’
[18:01:58.357] Finding globals ... DONE
[18:01:58.358]  - use_args: TRUE
[18:01:58.358]  - Getting '...' globals ...
[18:01:58.358] resolve() on list ...
[18:01:58.359]  recursive: 0
[18:01:58.359]  length: 1
[18:01:58.359]  elements: ‘...’
[18:01:58.359]  length: 0 (resolved future 1)
[18:01:58.359] resolve() on list ... DONE
[18:01:58.360]    - '...' content: [n=0] 
[18:01:58.360] List of 1
[18:01:58.360]  $ ...: list()
[18:01:58.360]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.360]  - attr(*, "where")=List of 1
[18:01:58.360]   ..$ ...:<environment: 0x6183c0a0d998> 
[18:01:58.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.360]  - attr(*, "resolved")= logi TRUE
[18:01:58.360]  - attr(*, "total_size")= num NA
[18:01:58.365]  - Getting '...' globals ... DONE
[18:01:58.365] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:58.366] List of 8
[18:01:58.366]  $ ...future.FUN:function (x, ...)  
[18:01:58.366]  $ x_FUN        :function (x)  
[18:01:58.366]  $ times        : int 4
[18:01:58.366]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:58.366]  $ stop_if_not  :function (...)  
[18:01:58.366]  $ dim          : int [1:2] 2 2
[18:01:58.366]  $ valid_types  : chr [1:2] "logical" "integer"
[18:01:58.366]  $ ...          : list()
[18:01:58.366]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.366]  - attr(*, "where")=List of 8
[18:01:58.366]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:58.366]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:58.366]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:58.366]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:58.366]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:58.366]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:58.366]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:58.366]   ..$ ...          :<environment: 0x6183c0a0d998> 
[18:01:58.366]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.366]  - attr(*, "resolved")= logi FALSE
[18:01:58.366]  - attr(*, "total_size")= num 97232
[18:01:58.378] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:58.378] getGlobalsAndPackagesXApply() ... DONE
[18:01:58.378] Number of futures (= number of chunks): 2
[18:01:58.379] Launching 2 futures (chunks) ...
[18:01:58.379] Chunk #1 of 2 ...
[18:01:58.379]  - Finding globals in 'X' for chunk #1 ...
[18:01:58.379] getGlobalsAndPackages() ...
[18:01:58.380] Searching for globals...
[18:01:58.380] 
[18:01:58.380] Searching for globals ... DONE
[18:01:58.381] - globals: [0] <none>
[18:01:58.381] getGlobalsAndPackages() ... DONE
[18:01:58.381]    + additional globals found: [n=0] 
[18:01:58.381]    + additional namespaces needed: [n=0] 
[18:01:58.381]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:58.381]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:58.382]  - seeds: <none>
[18:01:58.382]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.382] getGlobalsAndPackages() ...
[18:01:58.382] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.383] Resolving globals: FALSE
[18:01:58.383] Tweak future expression to call with '...' arguments ...
[18:01:58.383] {
[18:01:58.383]     do.call(function(...) {
[18:01:58.383]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.383]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.383]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.383]             on.exit(options(oopts), add = TRUE)
[18:01:58.383]         }
[18:01:58.383]         {
[18:01:58.383]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.383]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.383]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.383]             })
[18:01:58.383]         }
[18:01:58.383]     }, args = future.call.arguments)
[18:01:58.383] }
[18:01:58.384] Tweak future expression to call with '...' arguments ... DONE
[18:01:58.385] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.385] - packages: [1] ‘future.apply’
[18:01:58.385] getGlobalsAndPackages() ... DONE
[18:01:58.386] run() for ‘Future’ ...
[18:01:58.386] - state: ‘created’
[18:01:58.386] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:58.395] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.395] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:58.396]   - Field: ‘label’
[18:01:58.396]   - Field: ‘local’
[18:01:58.396]   - Field: ‘owner’
[18:01:58.396]   - Field: ‘envir’
[18:01:58.396]   - Field: ‘workers’
[18:01:58.397]   - Field: ‘packages’
[18:01:58.397]   - Field: ‘gc’
[18:01:58.397]   - Field: ‘job’
[18:01:58.397]   - Field: ‘conditions’
[18:01:58.397]   - Field: ‘expr’
[18:01:58.398]   - Field: ‘uuid’
[18:01:58.398]   - Field: ‘seed’
[18:01:58.398]   - Field: ‘version’
[18:01:58.398]   - Field: ‘result’
[18:01:58.399]   - Field: ‘asynchronous’
[18:01:58.399]   - Field: ‘calls’
[18:01:58.399]   - Field: ‘globals’
[18:01:58.399]   - Field: ‘stdout’
[18:01:58.399]   - Field: ‘earlySignal’
[18:01:58.400]   - Field: ‘lazy’
[18:01:58.400]   - Field: ‘state’
[18:01:58.400] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:58.400] - Launch lazy future ...
[18:01:58.401] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:58.401] Packages needed by future strategies (n = 0): <none>
[18:01:58.402] {
[18:01:58.402]     {
[18:01:58.402]         {
[18:01:58.402]             ...future.startTime <- base::Sys.time()
[18:01:58.402]             {
[18:01:58.402]                 {
[18:01:58.402]                   {
[18:01:58.402]                     {
[18:01:58.402]                       {
[18:01:58.402]                         base::local({
[18:01:58.402]                           has_future <- base::requireNamespace("future", 
[18:01:58.402]                             quietly = TRUE)
[18:01:58.402]                           if (has_future) {
[18:01:58.402]                             ns <- base::getNamespace("future")
[18:01:58.402]                             version <- ns[[".package"]][["version"]]
[18:01:58.402]                             if (is.null(version)) 
[18:01:58.402]                               version <- utils::packageVersion("future")
[18:01:58.402]                           }
[18:01:58.402]                           else {
[18:01:58.402]                             version <- NULL
[18:01:58.402]                           }
[18:01:58.402]                           if (!has_future || version < "1.8.0") {
[18:01:58.402]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:58.402]                               "", base::R.version$version.string), 
[18:01:58.402]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:58.402]                                 base::R.version$platform, 8 * 
[18:01:58.402]                                   base::.Machine$sizeof.pointer), 
[18:01:58.402]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:58.402]                                 "release", "version")], collapse = " "), 
[18:01:58.402]                               hostname = base::Sys.info()[["nodename"]])
[18:01:58.402]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:58.402]                               info)
[18:01:58.402]                             info <- base::paste(info, collapse = "; ")
[18:01:58.402]                             if (!has_future) {
[18:01:58.402]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:58.402]                                 info)
[18:01:58.402]                             }
[18:01:58.402]                             else {
[18:01:58.402]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:58.402]                                 info, version)
[18:01:58.402]                             }
[18:01:58.402]                             base::stop(msg)
[18:01:58.402]                           }
[18:01:58.402]                         })
[18:01:58.402]                       }
[18:01:58.402]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:58.402]                       base::options(mc.cores = 1L)
[18:01:58.402]                     }
[18:01:58.402]                     base::local({
[18:01:58.402]                       for (pkg in "future.apply") {
[18:01:58.402]                         base::loadNamespace(pkg)
[18:01:58.402]                         base::library(pkg, character.only = TRUE)
[18:01:58.402]                       }
[18:01:58.402]                     })
[18:01:58.402]                   }
[18:01:58.402]                   ...future.strategy.old <- future::plan("list")
[18:01:58.402]                   options(future.plan = NULL)
[18:01:58.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:58.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:58.402]                 }
[18:01:58.402]                 ...future.workdir <- getwd()
[18:01:58.402]             }
[18:01:58.402]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:58.402]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:58.402]         }
[18:01:58.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:58.402]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:58.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:58.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:58.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:58.402]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:58.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:58.402]             base::names(...future.oldOptions))
[18:01:58.402]     }
[18:01:58.402]     if (FALSE) {
[18:01:58.402]     }
[18:01:58.402]     else {
[18:01:58.402]         if (TRUE) {
[18:01:58.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:58.402]                 open = "w")
[18:01:58.402]         }
[18:01:58.402]         else {
[18:01:58.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:58.402]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:58.402]         }
[18:01:58.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:58.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:58.402]             base::sink(type = "output", split = FALSE)
[18:01:58.402]             base::close(...future.stdout)
[18:01:58.402]         }, add = TRUE)
[18:01:58.402]     }
[18:01:58.402]     ...future.frame <- base::sys.nframe()
[18:01:58.402]     ...future.conditions <- base::list()
[18:01:58.402]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:58.402]     if (FALSE) {
[18:01:58.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:58.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:58.402]     }
[18:01:58.402]     ...future.result <- base::tryCatch({
[18:01:58.402]         base::withCallingHandlers({
[18:01:58.402]             ...future.value <- base::withVisible(base::local({
[18:01:58.402]                 withCallingHandlers({
[18:01:58.402]                   {
[18:01:58.402]                     do.call(function(...) {
[18:01:58.402]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.402]                       if (!identical(...future.globals.maxSize.org, 
[18:01:58.402]                         ...future.globals.maxSize)) {
[18:01:58.402]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.402]                         on.exit(options(oopts), add = TRUE)
[18:01:58.402]                       }
[18:01:58.402]                       {
[18:01:58.402]                         lapply(seq_along(...future.elements_ii), 
[18:01:58.402]                           FUN = function(jj) {
[18:01:58.402]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.402]                             ...future.FUN(...future.X_jj, ...)
[18:01:58.402]                           })
[18:01:58.402]                       }
[18:01:58.402]                     }, args = future.call.arguments)
[18:01:58.402]                   }
[18:01:58.402]                 }, immediateCondition = function(cond) {
[18:01:58.402]                   save_rds <- function (object, pathname, ...) 
[18:01:58.402]                   {
[18:01:58.402]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:58.402]                     if (file_test("-f", pathname_tmp)) {
[18:01:58.402]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.402]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:58.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.402]                         fi_tmp[["mtime"]])
[18:01:58.402]                     }
[18:01:58.402]                     tryCatch({
[18:01:58.402]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:58.402]                     }, error = function(ex) {
[18:01:58.402]                       msg <- conditionMessage(ex)
[18:01:58.402]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.402]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:58.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.402]                         fi_tmp[["mtime"]], msg)
[18:01:58.402]                       ex$message <- msg
[18:01:58.402]                       stop(ex)
[18:01:58.402]                     })
[18:01:58.402]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:58.402]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:58.402]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:58.402]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.402]                       fi <- file.info(pathname)
[18:01:58.402]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:58.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.402]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:58.402]                         fi[["size"]], fi[["mtime"]])
[18:01:58.402]                       stop(msg)
[18:01:58.402]                     }
[18:01:58.402]                     invisible(pathname)
[18:01:58.402]                   }
[18:01:58.402]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:58.402]                     rootPath = tempdir()) 
[18:01:58.402]                   {
[18:01:58.402]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:58.402]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:58.402]                       tmpdir = path, fileext = ".rds")
[18:01:58.402]                     save_rds(obj, file)
[18:01:58.402]                   }
[18:01:58.402]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:58.402]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.402]                   {
[18:01:58.402]                     inherits <- base::inherits
[18:01:58.402]                     invokeRestart <- base::invokeRestart
[18:01:58.402]                     is.null <- base::is.null
[18:01:58.402]                     muffled <- FALSE
[18:01:58.402]                     if (inherits(cond, "message")) {
[18:01:58.402]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:58.402]                       if (muffled) 
[18:01:58.402]                         invokeRestart("muffleMessage")
[18:01:58.402]                     }
[18:01:58.402]                     else if (inherits(cond, "warning")) {
[18:01:58.402]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:58.402]                       if (muffled) 
[18:01:58.402]                         invokeRestart("muffleWarning")
[18:01:58.402]                     }
[18:01:58.402]                     else if (inherits(cond, "condition")) {
[18:01:58.402]                       if (!is.null(pattern)) {
[18:01:58.402]                         computeRestarts <- base::computeRestarts
[18:01:58.402]                         grepl <- base::grepl
[18:01:58.402]                         restarts <- computeRestarts(cond)
[18:01:58.402]                         for (restart in restarts) {
[18:01:58.402]                           name <- restart$name
[18:01:58.402]                           if (is.null(name)) 
[18:01:58.402]                             next
[18:01:58.402]                           if (!grepl(pattern, name)) 
[18:01:58.402]                             next
[18:01:58.402]                           invokeRestart(restart)
[18:01:58.402]                           muffled <- TRUE
[18:01:58.402]                           break
[18:01:58.402]                         }
[18:01:58.402]                       }
[18:01:58.402]                     }
[18:01:58.402]                     invisible(muffled)
[18:01:58.402]                   }
[18:01:58.402]                   muffleCondition(cond)
[18:01:58.402]                 })
[18:01:58.402]             }))
[18:01:58.402]             future::FutureResult(value = ...future.value$value, 
[18:01:58.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:58.402]                   ...future.rng), globalenv = if (FALSE) 
[18:01:58.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:58.402]                     ...future.globalenv.names))
[18:01:58.402]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:58.402]         }, condition = base::local({
[18:01:58.402]             c <- base::c
[18:01:58.402]             inherits <- base::inherits
[18:01:58.402]             invokeRestart <- base::invokeRestart
[18:01:58.402]             length <- base::length
[18:01:58.402]             list <- base::list
[18:01:58.402]             seq.int <- base::seq.int
[18:01:58.402]             signalCondition <- base::signalCondition
[18:01:58.402]             sys.calls <- base::sys.calls
[18:01:58.402]             `[[` <- base::`[[`
[18:01:58.402]             `+` <- base::`+`
[18:01:58.402]             `<<-` <- base::`<<-`
[18:01:58.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:58.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:58.402]                   3L)]
[18:01:58.402]             }
[18:01:58.402]             function(cond) {
[18:01:58.402]                 is_error <- inherits(cond, "error")
[18:01:58.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:58.402]                   NULL)
[18:01:58.402]                 if (is_error) {
[18:01:58.402]                   sessionInformation <- function() {
[18:01:58.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:58.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:58.402]                       search = base::search(), system = base::Sys.info())
[18:01:58.402]                   }
[18:01:58.402]                   ...future.conditions[[length(...future.conditions) + 
[18:01:58.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:58.402]                     cond$call), session = sessionInformation(), 
[18:01:58.402]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:58.402]                   signalCondition(cond)
[18:01:58.402]                 }
[18:01:58.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:58.402]                 "immediateCondition"))) {
[18:01:58.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:58.402]                   ...future.conditions[[length(...future.conditions) + 
[18:01:58.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:58.402]                   if (TRUE && !signal) {
[18:01:58.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.402]                     {
[18:01:58.402]                       inherits <- base::inherits
[18:01:58.402]                       invokeRestart <- base::invokeRestart
[18:01:58.402]                       is.null <- base::is.null
[18:01:58.402]                       muffled <- FALSE
[18:01:58.402]                       if (inherits(cond, "message")) {
[18:01:58.402]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:58.402]                         if (muffled) 
[18:01:58.402]                           invokeRestart("muffleMessage")
[18:01:58.402]                       }
[18:01:58.402]                       else if (inherits(cond, "warning")) {
[18:01:58.402]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:58.402]                         if (muffled) 
[18:01:58.402]                           invokeRestart("muffleWarning")
[18:01:58.402]                       }
[18:01:58.402]                       else if (inherits(cond, "condition")) {
[18:01:58.402]                         if (!is.null(pattern)) {
[18:01:58.402]                           computeRestarts <- base::computeRestarts
[18:01:58.402]                           grepl <- base::grepl
[18:01:58.402]                           restarts <- computeRestarts(cond)
[18:01:58.402]                           for (restart in restarts) {
[18:01:58.402]                             name <- restart$name
[18:01:58.402]                             if (is.null(name)) 
[18:01:58.402]                               next
[18:01:58.402]                             if (!grepl(pattern, name)) 
[18:01:58.402]                               next
[18:01:58.402]                             invokeRestart(restart)
[18:01:58.402]                             muffled <- TRUE
[18:01:58.402]                             break
[18:01:58.402]                           }
[18:01:58.402]                         }
[18:01:58.402]                       }
[18:01:58.402]                       invisible(muffled)
[18:01:58.402]                     }
[18:01:58.402]                     muffleCondition(cond, pattern = "^muffle")
[18:01:58.402]                   }
[18:01:58.402]                 }
[18:01:58.402]                 else {
[18:01:58.402]                   if (TRUE) {
[18:01:58.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.402]                     {
[18:01:58.402]                       inherits <- base::inherits
[18:01:58.402]                       invokeRestart <- base::invokeRestart
[18:01:58.402]                       is.null <- base::is.null
[18:01:58.402]                       muffled <- FALSE
[18:01:58.402]                       if (inherits(cond, "message")) {
[18:01:58.402]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:58.402]                         if (muffled) 
[18:01:58.402]                           invokeRestart("muffleMessage")
[18:01:58.402]                       }
[18:01:58.402]                       else if (inherits(cond, "warning")) {
[18:01:58.402]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:58.402]                         if (muffled) 
[18:01:58.402]                           invokeRestart("muffleWarning")
[18:01:58.402]                       }
[18:01:58.402]                       else if (inherits(cond, "condition")) {
[18:01:58.402]                         if (!is.null(pattern)) {
[18:01:58.402]                           computeRestarts <- base::computeRestarts
[18:01:58.402]                           grepl <- base::grepl
[18:01:58.402]                           restarts <- computeRestarts(cond)
[18:01:58.402]                           for (restart in restarts) {
[18:01:58.402]                             name <- restart$name
[18:01:58.402]                             if (is.null(name)) 
[18:01:58.402]                               next
[18:01:58.402]                             if (!grepl(pattern, name)) 
[18:01:58.402]                               next
[18:01:58.402]                             invokeRestart(restart)
[18:01:58.402]                             muffled <- TRUE
[18:01:58.402]                             break
[18:01:58.402]                           }
[18:01:58.402]                         }
[18:01:58.402]                       }
[18:01:58.402]                       invisible(muffled)
[18:01:58.402]                     }
[18:01:58.402]                     muffleCondition(cond, pattern = "^muffle")
[18:01:58.402]                   }
[18:01:58.402]                 }
[18:01:58.402]             }
[18:01:58.402]         }))
[18:01:58.402]     }, error = function(ex) {
[18:01:58.402]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:58.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:58.402]                 ...future.rng), started = ...future.startTime, 
[18:01:58.402]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:58.402]             version = "1.8"), class = "FutureResult")
[18:01:58.402]     }, finally = {
[18:01:58.402]         if (!identical(...future.workdir, getwd())) 
[18:01:58.402]             setwd(...future.workdir)
[18:01:58.402]         {
[18:01:58.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:58.402]                 ...future.oldOptions$nwarnings <- NULL
[18:01:58.402]             }
[18:01:58.402]             base::options(...future.oldOptions)
[18:01:58.402]             if (.Platform$OS.type == "windows") {
[18:01:58.402]                 old_names <- names(...future.oldEnvVars)
[18:01:58.402]                 envs <- base::Sys.getenv()
[18:01:58.402]                 names <- names(envs)
[18:01:58.402]                 common <- intersect(names, old_names)
[18:01:58.402]                 added <- setdiff(names, old_names)
[18:01:58.402]                 removed <- setdiff(old_names, names)
[18:01:58.402]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:58.402]                   envs[common]]
[18:01:58.402]                 NAMES <- toupper(changed)
[18:01:58.402]                 args <- list()
[18:01:58.402]                 for (kk in seq_along(NAMES)) {
[18:01:58.402]                   name <- changed[[kk]]
[18:01:58.402]                   NAME <- NAMES[[kk]]
[18:01:58.402]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.402]                     next
[18:01:58.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:58.402]                 }
[18:01:58.402]                 NAMES <- toupper(added)
[18:01:58.402]                 for (kk in seq_along(NAMES)) {
[18:01:58.402]                   name <- added[[kk]]
[18:01:58.402]                   NAME <- NAMES[[kk]]
[18:01:58.402]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.402]                     next
[18:01:58.402]                   args[[name]] <- ""
[18:01:58.402]                 }
[18:01:58.402]                 NAMES <- toupper(removed)
[18:01:58.402]                 for (kk in seq_along(NAMES)) {
[18:01:58.402]                   name <- removed[[kk]]
[18:01:58.402]                   NAME <- NAMES[[kk]]
[18:01:58.402]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.402]                     next
[18:01:58.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:58.402]                 }
[18:01:58.402]                 if (length(args) > 0) 
[18:01:58.402]                   base::do.call(base::Sys.setenv, args = args)
[18:01:58.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:58.402]             }
[18:01:58.402]             else {
[18:01:58.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:58.402]             }
[18:01:58.402]             {
[18:01:58.402]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:58.402]                   0L) {
[18:01:58.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:58.402]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:58.402]                   base::options(opts)
[18:01:58.402]                 }
[18:01:58.402]                 {
[18:01:58.402]                   {
[18:01:58.402]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:58.402]                     NULL
[18:01:58.402]                   }
[18:01:58.402]                   options(future.plan = NULL)
[18:01:58.402]                   if (is.na(NA_character_)) 
[18:01:58.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:58.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:58.402]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:58.402]                     .init = FALSE)
[18:01:58.402]                 }
[18:01:58.402]             }
[18:01:58.402]         }
[18:01:58.402]     })
[18:01:58.402]     if (TRUE) {
[18:01:58.402]         base::sink(type = "output", split = FALSE)
[18:01:58.402]         if (TRUE) {
[18:01:58.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:58.402]         }
[18:01:58.402]         else {
[18:01:58.402]             ...future.result["stdout"] <- base::list(NULL)
[18:01:58.402]         }
[18:01:58.402]         base::close(...future.stdout)
[18:01:58.402]         ...future.stdout <- NULL
[18:01:58.402]     }
[18:01:58.402]     ...future.result$conditions <- ...future.conditions
[18:01:58.402]     ...future.result$finished <- base::Sys.time()
[18:01:58.402]     ...future.result
[18:01:58.402] }
[18:01:58.407] assign_globals() ...
[18:01:58.407] List of 11
[18:01:58.407]  $ ...future.FUN            :function (x, ...)  
[18:01:58.407]  $ x_FUN                    :function (x)  
[18:01:58.407]  $ times                    : int 4
[18:01:58.407]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:58.407]  $ stop_if_not              :function (...)  
[18:01:58.407]  $ dim                      : int [1:2] 2 2
[18:01:58.407]  $ valid_types              : chr [1:2] "logical" "integer"
[18:01:58.407]  $ future.call.arguments    : list()
[18:01:58.407]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.407]  $ ...future.elements_ii    :List of 5
[18:01:58.407]   ..$ : int 1
[18:01:58.407]   ..$ : int 2
[18:01:58.407]   ..$ : int 3
[18:01:58.407]   ..$ : int 4
[18:01:58.407]   ..$ : int 5
[18:01:58.407]  $ ...future.seeds_ii       : NULL
[18:01:58.407]  $ ...future.globals.maxSize: NULL
[18:01:58.407]  - attr(*, "where")=List of 11
[18:01:58.407]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:58.407]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:58.407]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:58.407]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:58.407]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:58.407]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:58.407]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:58.407]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:58.407]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:58.407]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:58.407]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:58.407]  - attr(*, "resolved")= logi FALSE
[18:01:58.407]  - attr(*, "total_size")= num 97232
[18:01:58.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.407]  - attr(*, "already-done")= logi TRUE
[18:01:58.425] - copied ‘...future.FUN’ to environment
[18:01:58.425] - reassign environment for ‘x_FUN’
[18:01:58.425] - copied ‘x_FUN’ to environment
[18:01:58.425] - copied ‘times’ to environment
[18:01:58.426] - copied ‘stopf’ to environment
[18:01:58.426] - copied ‘stop_if_not’ to environment
[18:01:58.426] - copied ‘dim’ to environment
[18:01:58.426] - copied ‘valid_types’ to environment
[18:01:58.426] - copied ‘future.call.arguments’ to environment
[18:01:58.427] - copied ‘...future.elements_ii’ to environment
[18:01:58.427] - copied ‘...future.seeds_ii’ to environment
[18:01:58.427] - copied ‘...future.globals.maxSize’ to environment
[18:01:58.427] assign_globals() ... done
[18:01:58.427] requestCore(): workers = 2
[18:01:58.431] MulticoreFuture started
[18:01:58.432] - Launch lazy future ... done
[18:01:58.432] run() for ‘MulticoreFuture’ ... done
[18:01:58.433] Created future:
[18:01:58.433] plan(): Setting new future strategy stack:
[18:01:58.434] List of future strategies:
[18:01:58.434] 1. sequential:
[18:01:58.434]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:58.434]    - tweaked: FALSE
[18:01:58.434]    - call: NULL
[18:01:58.436] plan(): nbrOfWorkers() = 1
[18:01:58.440] plan(): Setting new future strategy stack:
[18:01:58.440] List of future strategies:
[18:01:58.440] 1. multicore:
[18:01:58.440]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:58.440]    - tweaked: FALSE
[18:01:58.440]    - call: plan(strategy)
[18:01:58.433] MulticoreFuture:
[18:01:58.433] Label: ‘future_vapply-1’
[18:01:58.433] Expression:
[18:01:58.433] {
[18:01:58.433]     do.call(function(...) {
[18:01:58.433]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.433]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.433]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.433]             on.exit(options(oopts), add = TRUE)
[18:01:58.433]         }
[18:01:58.433]         {
[18:01:58.433]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.433]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.433]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.433]             })
[18:01:58.433]         }
[18:01:58.433]     }, args = future.call.arguments)
[18:01:58.433] }
[18:01:58.433] Lazy evaluation: FALSE
[18:01:58.433] Asynchronous evaluation: TRUE
[18:01:58.433] Local evaluation: TRUE
[18:01:58.433] Environment: R_GlobalEnv
[18:01:58.433] Capture standard output: TRUE
[18:01:58.433] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:58.433] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:58.433] Packages: 1 packages (‘future.apply’)
[18:01:58.433] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:58.433] Resolved: FALSE
[18:01:58.433] Value: <not collected>
[18:01:58.433] Conditions captured: <none>
[18:01:58.433] Early signaling: FALSE
[18:01:58.433] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:58.433] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.449] Chunk #1 of 2 ... DONE
[18:01:58.449] plan(): nbrOfWorkers() = 2
[18:01:58.449] Chunk #2 of 2 ...
[18:01:58.450]  - Finding globals in 'X' for chunk #2 ...
[18:01:58.450] getGlobalsAndPackages() ...
[18:01:58.450] Searching for globals...
[18:01:58.451] 
[18:01:58.452] Searching for globals ... DONE
[18:01:58.452] - globals: [0] <none>
[18:01:58.452] getGlobalsAndPackages() ... DONE
[18:01:58.452]    + additional globals found: [n=0] 
[18:01:58.453]    + additional namespaces needed: [n=0] 
[18:01:58.453]  - Finding globals in 'X' for chunk #2 ... DONE
[18:01:58.453]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:58.453]  - seeds: <none>
[18:01:58.454]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.454] getGlobalsAndPackages() ...
[18:01:58.454] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.455] Resolving globals: FALSE
[18:01:58.455] Tweak future expression to call with '...' arguments ...
[18:01:58.455] {
[18:01:58.455]     do.call(function(...) {
[18:01:58.455]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.455]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.455]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.455]             on.exit(options(oopts), add = TRUE)
[18:01:58.455]         }
[18:01:58.455]         {
[18:01:58.455]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.455]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.455]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.455]             })
[18:01:58.455]         }
[18:01:58.455]     }, args = future.call.arguments)
[18:01:58.455] }
[18:01:58.456] Tweak future expression to call with '...' arguments ... DONE
[18:01:58.458] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.459] - packages: [1] ‘future.apply’
[18:01:58.459] getGlobalsAndPackages() ... DONE
[18:01:58.464] run() for ‘Future’ ...
[18:01:58.466] - state: ‘created’
[18:01:58.467] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:58.478] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.479] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:58.480]   - Field: ‘label’
[18:01:58.480]   - Field: ‘local’
[18:01:58.481]   - Field: ‘owner’
[18:01:58.481]   - Field: ‘envir’
[18:01:58.482]   - Field: ‘workers’
[18:01:58.482]   - Field: ‘packages’
[18:01:58.483]   - Field: ‘gc’
[18:01:58.483]   - Field: ‘job’
[18:01:58.484]   - Field: ‘conditions’
[18:01:58.484]   - Field: ‘expr’
[18:01:58.485]   - Field: ‘uuid’
[18:01:58.485]   - Field: ‘seed’
[18:01:58.486]   - Field: ‘version’
[18:01:58.486]   - Field: ‘result’
[18:01:58.486]   - Field: ‘asynchronous’
[18:01:58.486]   - Field: ‘calls’
[18:01:58.487]   - Field: ‘globals’
[18:01:58.487]   - Field: ‘stdout’
[18:01:58.487]   - Field: ‘earlySignal’
[18:01:58.487]   - Field: ‘lazy’
[18:01:58.488]   - Field: ‘state’
[18:01:58.488] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:58.488] - Launch lazy future ...
[18:01:58.489] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:58.490] Packages needed by future strategies (n = 0): <none>
[18:01:58.492] {
[18:01:58.492]     {
[18:01:58.492]         {
[18:01:58.492]             ...future.startTime <- base::Sys.time()
[18:01:58.492]             {
[18:01:58.492]                 {
[18:01:58.492]                   {
[18:01:58.492]                     {
[18:01:58.492]                       {
[18:01:58.492]                         base::local({
[18:01:58.492]                           has_future <- base::requireNamespace("future", 
[18:01:58.492]                             quietly = TRUE)
[18:01:58.492]                           if (has_future) {
[18:01:58.492]                             ns <- base::getNamespace("future")
[18:01:58.492]                             version <- ns[[".package"]][["version"]]
[18:01:58.492]                             if (is.null(version)) 
[18:01:58.492]                               version <- utils::packageVersion("future")
[18:01:58.492]                           }
[18:01:58.492]                           else {
[18:01:58.492]                             version <- NULL
[18:01:58.492]                           }
[18:01:58.492]                           if (!has_future || version < "1.8.0") {
[18:01:58.492]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:58.492]                               "", base::R.version$version.string), 
[18:01:58.492]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:58.492]                                 base::R.version$platform, 8 * 
[18:01:58.492]                                   base::.Machine$sizeof.pointer), 
[18:01:58.492]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:58.492]                                 "release", "version")], collapse = " "), 
[18:01:58.492]                               hostname = base::Sys.info()[["nodename"]])
[18:01:58.492]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:58.492]                               info)
[18:01:58.492]                             info <- base::paste(info, collapse = "; ")
[18:01:58.492]                             if (!has_future) {
[18:01:58.492]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:58.492]                                 info)
[18:01:58.492]                             }
[18:01:58.492]                             else {
[18:01:58.492]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:58.492]                                 info, version)
[18:01:58.492]                             }
[18:01:58.492]                             base::stop(msg)
[18:01:58.492]                           }
[18:01:58.492]                         })
[18:01:58.492]                       }
[18:01:58.492]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:58.492]                       base::options(mc.cores = 1L)
[18:01:58.492]                     }
[18:01:58.492]                     base::local({
[18:01:58.492]                       for (pkg in "future.apply") {
[18:01:58.492]                         base::loadNamespace(pkg)
[18:01:58.492]                         base::library(pkg, character.only = TRUE)
[18:01:58.492]                       }
[18:01:58.492]                     })
[18:01:58.492]                   }
[18:01:58.492]                   ...future.strategy.old <- future::plan("list")
[18:01:58.492]                   options(future.plan = NULL)
[18:01:58.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:58.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:58.492]                 }
[18:01:58.492]                 ...future.workdir <- getwd()
[18:01:58.492]             }
[18:01:58.492]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:58.492]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:58.492]         }
[18:01:58.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:58.492]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:58.492]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:58.492]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:58.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:58.492]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:58.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:58.492]             base::names(...future.oldOptions))
[18:01:58.492]     }
[18:01:58.492]     if (FALSE) {
[18:01:58.492]     }
[18:01:58.492]     else {
[18:01:58.492]         if (TRUE) {
[18:01:58.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:58.492]                 open = "w")
[18:01:58.492]         }
[18:01:58.492]         else {
[18:01:58.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:58.492]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:58.492]         }
[18:01:58.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:58.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:58.492]             base::sink(type = "output", split = FALSE)
[18:01:58.492]             base::close(...future.stdout)
[18:01:58.492]         }, add = TRUE)
[18:01:58.492]     }
[18:01:58.492]     ...future.frame <- base::sys.nframe()
[18:01:58.492]     ...future.conditions <- base::list()
[18:01:58.492]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:58.492]     if (FALSE) {
[18:01:58.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:58.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:58.492]     }
[18:01:58.492]     ...future.result <- base::tryCatch({
[18:01:58.492]         base::withCallingHandlers({
[18:01:58.492]             ...future.value <- base::withVisible(base::local({
[18:01:58.492]                 withCallingHandlers({
[18:01:58.492]                   {
[18:01:58.492]                     do.call(function(...) {
[18:01:58.492]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.492]                       if (!identical(...future.globals.maxSize.org, 
[18:01:58.492]                         ...future.globals.maxSize)) {
[18:01:58.492]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.492]                         on.exit(options(oopts), add = TRUE)
[18:01:58.492]                       }
[18:01:58.492]                       {
[18:01:58.492]                         lapply(seq_along(...future.elements_ii), 
[18:01:58.492]                           FUN = function(jj) {
[18:01:58.492]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.492]                             ...future.FUN(...future.X_jj, ...)
[18:01:58.492]                           })
[18:01:58.492]                       }
[18:01:58.492]                     }, args = future.call.arguments)
[18:01:58.492]                   }
[18:01:58.492]                 }, immediateCondition = function(cond) {
[18:01:58.492]                   save_rds <- function (object, pathname, ...) 
[18:01:58.492]                   {
[18:01:58.492]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:58.492]                     if (file_test("-f", pathname_tmp)) {
[18:01:58.492]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.492]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:58.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.492]                         fi_tmp[["mtime"]])
[18:01:58.492]                     }
[18:01:58.492]                     tryCatch({
[18:01:58.492]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:58.492]                     }, error = function(ex) {
[18:01:58.492]                       msg <- conditionMessage(ex)
[18:01:58.492]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.492]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:58.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.492]                         fi_tmp[["mtime"]], msg)
[18:01:58.492]                       ex$message <- msg
[18:01:58.492]                       stop(ex)
[18:01:58.492]                     })
[18:01:58.492]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:58.492]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:58.492]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:58.492]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.492]                       fi <- file.info(pathname)
[18:01:58.492]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:58.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.492]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:58.492]                         fi[["size"]], fi[["mtime"]])
[18:01:58.492]                       stop(msg)
[18:01:58.492]                     }
[18:01:58.492]                     invisible(pathname)
[18:01:58.492]                   }
[18:01:58.492]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:58.492]                     rootPath = tempdir()) 
[18:01:58.492]                   {
[18:01:58.492]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:58.492]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:58.492]                       tmpdir = path, fileext = ".rds")
[18:01:58.492]                     save_rds(obj, file)
[18:01:58.492]                   }
[18:01:58.492]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:58.492]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.492]                   {
[18:01:58.492]                     inherits <- base::inherits
[18:01:58.492]                     invokeRestart <- base::invokeRestart
[18:01:58.492]                     is.null <- base::is.null
[18:01:58.492]                     muffled <- FALSE
[18:01:58.492]                     if (inherits(cond, "message")) {
[18:01:58.492]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:58.492]                       if (muffled) 
[18:01:58.492]                         invokeRestart("muffleMessage")
[18:01:58.492]                     }
[18:01:58.492]                     else if (inherits(cond, "warning")) {
[18:01:58.492]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:58.492]                       if (muffled) 
[18:01:58.492]                         invokeRestart("muffleWarning")
[18:01:58.492]                     }
[18:01:58.492]                     else if (inherits(cond, "condition")) {
[18:01:58.492]                       if (!is.null(pattern)) {
[18:01:58.492]                         computeRestarts <- base::computeRestarts
[18:01:58.492]                         grepl <- base::grepl
[18:01:58.492]                         restarts <- computeRestarts(cond)
[18:01:58.492]                         for (restart in restarts) {
[18:01:58.492]                           name <- restart$name
[18:01:58.492]                           if (is.null(name)) 
[18:01:58.492]                             next
[18:01:58.492]                           if (!grepl(pattern, name)) 
[18:01:58.492]                             next
[18:01:58.492]                           invokeRestart(restart)
[18:01:58.492]                           muffled <- TRUE
[18:01:58.492]                           break
[18:01:58.492]                         }
[18:01:58.492]                       }
[18:01:58.492]                     }
[18:01:58.492]                     invisible(muffled)
[18:01:58.492]                   }
[18:01:58.492]                   muffleCondition(cond)
[18:01:58.492]                 })
[18:01:58.492]             }))
[18:01:58.492]             future::FutureResult(value = ...future.value$value, 
[18:01:58.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:58.492]                   ...future.rng), globalenv = if (FALSE) 
[18:01:58.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:58.492]                     ...future.globalenv.names))
[18:01:58.492]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:58.492]         }, condition = base::local({
[18:01:58.492]             c <- base::c
[18:01:58.492]             inherits <- base::inherits
[18:01:58.492]             invokeRestart <- base::invokeRestart
[18:01:58.492]             length <- base::length
[18:01:58.492]             list <- base::list
[18:01:58.492]             seq.int <- base::seq.int
[18:01:58.492]             signalCondition <- base::signalCondition
[18:01:58.492]             sys.calls <- base::sys.calls
[18:01:58.492]             `[[` <- base::`[[`
[18:01:58.492]             `+` <- base::`+`
[18:01:58.492]             `<<-` <- base::`<<-`
[18:01:58.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:58.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:58.492]                   3L)]
[18:01:58.492]             }
[18:01:58.492]             function(cond) {
[18:01:58.492]                 is_error <- inherits(cond, "error")
[18:01:58.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:58.492]                   NULL)
[18:01:58.492]                 if (is_error) {
[18:01:58.492]                   sessionInformation <- function() {
[18:01:58.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:58.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:58.492]                       search = base::search(), system = base::Sys.info())
[18:01:58.492]                   }
[18:01:58.492]                   ...future.conditions[[length(...future.conditions) + 
[18:01:58.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:58.492]                     cond$call), session = sessionInformation(), 
[18:01:58.492]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:58.492]                   signalCondition(cond)
[18:01:58.492]                 }
[18:01:58.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:58.492]                 "immediateCondition"))) {
[18:01:58.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:58.492]                   ...future.conditions[[length(...future.conditions) + 
[18:01:58.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:58.492]                   if (TRUE && !signal) {
[18:01:58.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.492]                     {
[18:01:58.492]                       inherits <- base::inherits
[18:01:58.492]                       invokeRestart <- base::invokeRestart
[18:01:58.492]                       is.null <- base::is.null
[18:01:58.492]                       muffled <- FALSE
[18:01:58.492]                       if (inherits(cond, "message")) {
[18:01:58.492]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:58.492]                         if (muffled) 
[18:01:58.492]                           invokeRestart("muffleMessage")
[18:01:58.492]                       }
[18:01:58.492]                       else if (inherits(cond, "warning")) {
[18:01:58.492]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:58.492]                         if (muffled) 
[18:01:58.492]                           invokeRestart("muffleWarning")
[18:01:58.492]                       }
[18:01:58.492]                       else if (inherits(cond, "condition")) {
[18:01:58.492]                         if (!is.null(pattern)) {
[18:01:58.492]                           computeRestarts <- base::computeRestarts
[18:01:58.492]                           grepl <- base::grepl
[18:01:58.492]                           restarts <- computeRestarts(cond)
[18:01:58.492]                           for (restart in restarts) {
[18:01:58.492]                             name <- restart$name
[18:01:58.492]                             if (is.null(name)) 
[18:01:58.492]                               next
[18:01:58.492]                             if (!grepl(pattern, name)) 
[18:01:58.492]                               next
[18:01:58.492]                             invokeRestart(restart)
[18:01:58.492]                             muffled <- TRUE
[18:01:58.492]                             break
[18:01:58.492]                           }
[18:01:58.492]                         }
[18:01:58.492]                       }
[18:01:58.492]                       invisible(muffled)
[18:01:58.492]                     }
[18:01:58.492]                     muffleCondition(cond, pattern = "^muffle")
[18:01:58.492]                   }
[18:01:58.492]                 }
[18:01:58.492]                 else {
[18:01:58.492]                   if (TRUE) {
[18:01:58.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.492]                     {
[18:01:58.492]                       inherits <- base::inherits
[18:01:58.492]                       invokeRestart <- base::invokeRestart
[18:01:58.492]                       is.null <- base::is.null
[18:01:58.492]                       muffled <- FALSE
[18:01:58.492]                       if (inherits(cond, "message")) {
[18:01:58.492]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:58.492]                         if (muffled) 
[18:01:58.492]                           invokeRestart("muffleMessage")
[18:01:58.492]                       }
[18:01:58.492]                       else if (inherits(cond, "warning")) {
[18:01:58.492]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:58.492]                         if (muffled) 
[18:01:58.492]                           invokeRestart("muffleWarning")
[18:01:58.492]                       }
[18:01:58.492]                       else if (inherits(cond, "condition")) {
[18:01:58.492]                         if (!is.null(pattern)) {
[18:01:58.492]                           computeRestarts <- base::computeRestarts
[18:01:58.492]                           grepl <- base::grepl
[18:01:58.492]                           restarts <- computeRestarts(cond)
[18:01:58.492]                           for (restart in restarts) {
[18:01:58.492]                             name <- restart$name
[18:01:58.492]                             if (is.null(name)) 
[18:01:58.492]                               next
[18:01:58.492]                             if (!grepl(pattern, name)) 
[18:01:58.492]                               next
[18:01:58.492]                             invokeRestart(restart)
[18:01:58.492]                             muffled <- TRUE
[18:01:58.492]                             break
[18:01:58.492]                           }
[18:01:58.492]                         }
[18:01:58.492]                       }
[18:01:58.492]                       invisible(muffled)
[18:01:58.492]                     }
[18:01:58.492]                     muffleCondition(cond, pattern = "^muffle")
[18:01:58.492]                   }
[18:01:58.492]                 }
[18:01:58.492]             }
[18:01:58.492]         }))
[18:01:58.492]     }, error = function(ex) {
[18:01:58.492]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:58.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:58.492]                 ...future.rng), started = ...future.startTime, 
[18:01:58.492]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:58.492]             version = "1.8"), class = "FutureResult")
[18:01:58.492]     }, finally = {
[18:01:58.492]         if (!identical(...future.workdir, getwd())) 
[18:01:58.492]             setwd(...future.workdir)
[18:01:58.492]         {
[18:01:58.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:58.492]                 ...future.oldOptions$nwarnings <- NULL
[18:01:58.492]             }
[18:01:58.492]             base::options(...future.oldOptions)
[18:01:58.492]             if (.Platform$OS.type == "windows") {
[18:01:58.492]                 old_names <- names(...future.oldEnvVars)
[18:01:58.492]                 envs <- base::Sys.getenv()
[18:01:58.492]                 names <- names(envs)
[18:01:58.492]                 common <- intersect(names, old_names)
[18:01:58.492]                 added <- setdiff(names, old_names)
[18:01:58.492]                 removed <- setdiff(old_names, names)
[18:01:58.492]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:58.492]                   envs[common]]
[18:01:58.492]                 NAMES <- toupper(changed)
[18:01:58.492]                 args <- list()
[18:01:58.492]                 for (kk in seq_along(NAMES)) {
[18:01:58.492]                   name <- changed[[kk]]
[18:01:58.492]                   NAME <- NAMES[[kk]]
[18:01:58.492]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.492]                     next
[18:01:58.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:58.492]                 }
[18:01:58.492]                 NAMES <- toupper(added)
[18:01:58.492]                 for (kk in seq_along(NAMES)) {
[18:01:58.492]                   name <- added[[kk]]
[18:01:58.492]                   NAME <- NAMES[[kk]]
[18:01:58.492]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.492]                     next
[18:01:58.492]                   args[[name]] <- ""
[18:01:58.492]                 }
[18:01:58.492]                 NAMES <- toupper(removed)
[18:01:58.492]                 for (kk in seq_along(NAMES)) {
[18:01:58.492]                   name <- removed[[kk]]
[18:01:58.492]                   NAME <- NAMES[[kk]]
[18:01:58.492]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.492]                     next
[18:01:58.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:58.492]                 }
[18:01:58.492]                 if (length(args) > 0) 
[18:01:58.492]                   base::do.call(base::Sys.setenv, args = args)
[18:01:58.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:58.492]             }
[18:01:58.492]             else {
[18:01:58.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:58.492]             }
[18:01:58.492]             {
[18:01:58.492]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:58.492]                   0L) {
[18:01:58.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:58.492]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:58.492]                   base::options(opts)
[18:01:58.492]                 }
[18:01:58.492]                 {
[18:01:58.492]                   {
[18:01:58.492]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:58.492]                     NULL
[18:01:58.492]                   }
[18:01:58.492]                   options(future.plan = NULL)
[18:01:58.492]                   if (is.na(NA_character_)) 
[18:01:58.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:58.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:58.492]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:58.492]                     .init = FALSE)
[18:01:58.492]                 }
[18:01:58.492]             }
[18:01:58.492]         }
[18:01:58.492]     })
[18:01:58.492]     if (TRUE) {
[18:01:58.492]         base::sink(type = "output", split = FALSE)
[18:01:58.492]         if (TRUE) {
[18:01:58.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:58.492]         }
[18:01:58.492]         else {
[18:01:58.492]             ...future.result["stdout"] <- base::list(NULL)
[18:01:58.492]         }
[18:01:58.492]         base::close(...future.stdout)
[18:01:58.492]         ...future.stdout <- NULL
[18:01:58.492]     }
[18:01:58.492]     ...future.result$conditions <- ...future.conditions
[18:01:58.492]     ...future.result$finished <- base::Sys.time()
[18:01:58.492]     ...future.result
[18:01:58.492] }
[18:01:58.497] assign_globals() ...
[18:01:58.497] List of 11
[18:01:58.497]  $ ...future.FUN            :function (x, ...)  
[18:01:58.497]  $ x_FUN                    :function (x)  
[18:01:58.497]  $ times                    : int 4
[18:01:58.497]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:58.497]  $ stop_if_not              :function (...)  
[18:01:58.497]  $ dim                      : int [1:2] 2 2
[18:01:58.497]  $ valid_types              : chr [1:2] "logical" "integer"
[18:01:58.497]  $ future.call.arguments    : list()
[18:01:58.497]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.497]  $ ...future.elements_ii    :List of 5
[18:01:58.497]   ..$ : int 6
[18:01:58.497]   ..$ : int 7
[18:01:58.497]   ..$ : int 8
[18:01:58.497]   ..$ : int 9
[18:01:58.497]   ..$ : int 10
[18:01:58.497]  $ ...future.seeds_ii       : NULL
[18:01:58.497]  $ ...future.globals.maxSize: NULL
[18:01:58.497]  - attr(*, "where")=List of 11
[18:01:58.497]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:58.497]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:58.497]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:58.497]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:58.497]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:58.497]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:58.497]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:58.497]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:58.497]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:58.497]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:58.497]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:58.497]  - attr(*, "resolved")= logi FALSE
[18:01:58.497]  - attr(*, "total_size")= num 97232
[18:01:58.497]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.497]  - attr(*, "already-done")= logi TRUE
[18:01:58.522] - copied ‘...future.FUN’ to environment
[18:01:58.522] - reassign environment for ‘x_FUN’
[18:01:58.522] - copied ‘x_FUN’ to environment
[18:01:58.523] - copied ‘times’ to environment
[18:01:58.523] - copied ‘stopf’ to environment
[18:01:58.523] - copied ‘stop_if_not’ to environment
[18:01:58.523] - copied ‘dim’ to environment
[18:01:58.524] - copied ‘valid_types’ to environment
[18:01:58.524] - copied ‘future.call.arguments’ to environment
[18:01:58.524] - copied ‘...future.elements_ii’ to environment
[18:01:58.524] - copied ‘...future.seeds_ii’ to environment
[18:01:58.524] - copied ‘...future.globals.maxSize’ to environment
[18:01:58.525] assign_globals() ... done
[18:01:58.525] requestCore(): workers = 2
[18:01:58.529] MulticoreFuture started
[18:01:58.529] - Launch lazy future ... done
[18:01:58.530] run() for ‘MulticoreFuture’ ... done
[18:01:58.530] Created future:
[18:01:58.531] plan(): Setting new future strategy stack:
[18:01:58.532] List of future strategies:
[18:01:58.532] 1. sequential:
[18:01:58.532]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:58.532]    - tweaked: FALSE
[18:01:58.532]    - call: NULL
[18:01:58.534] plan(): nbrOfWorkers() = 1
[18:01:58.538] plan(): Setting new future strategy stack:
[18:01:58.538] List of future strategies:
[18:01:58.538] 1. multicore:
[18:01:58.538]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:58.538]    - tweaked: FALSE
[18:01:58.538]    - call: plan(strategy)
[18:01:58.531] MulticoreFuture:
[18:01:58.531] Label: ‘future_vapply-2’
[18:01:58.531] Expression:
[18:01:58.531] {
[18:01:58.531]     do.call(function(...) {
[18:01:58.531]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.531]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.531]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.531]             on.exit(options(oopts), add = TRUE)
[18:01:58.531]         }
[18:01:58.531]         {
[18:01:58.531]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.531]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.531]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.531]             })
[18:01:58.531]         }
[18:01:58.531]     }, args = future.call.arguments)
[18:01:58.531] }
[18:01:58.531] Lazy evaluation: FALSE
[18:01:58.531] Asynchronous evaluation: TRUE
[18:01:58.531] Local evaluation: TRUE
[18:01:58.531] Environment: R_GlobalEnv
[18:01:58.531] Capture standard output: TRUE
[18:01:58.531] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:58.531] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:58.531] Packages: 1 packages (‘future.apply’)
[18:01:58.531] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:58.531] Resolved: FALSE
[18:01:58.531] Value: <not collected>
[18:01:58.531] Conditions captured: <none>
[18:01:58.531] Early signaling: FALSE
[18:01:58.531] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:58.531] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.547] Chunk #2 of 2 ... DONE
[18:01:58.547] Launching 2 futures (chunks) ... DONE
[18:01:58.548] plan(): nbrOfWorkers() = 2
[18:01:58.548] Resolving 2 futures (chunks) ...
[18:01:58.549] resolve() on list ...
[18:01:58.549]  recursive: 0
[18:01:58.550]  length: 2
[18:01:58.550] 
[18:01:58.551] Future #1
[18:01:58.551] result() for MulticoreFuture ...
[18:01:58.555] result() for MulticoreFuture ...
[18:01:58.555] result() for MulticoreFuture ... done
[18:01:58.556] result() for MulticoreFuture ... done
[18:01:58.556] result() for MulticoreFuture ...
[18:01:58.556] result() for MulticoreFuture ... done
[18:01:58.564] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:58.565] - nx: 2
[18:01:58.566] - relay: TRUE
[18:01:58.567] - stdout: TRUE
[18:01:58.568] - signal: TRUE
[18:01:58.568] - resignal: FALSE
[18:01:58.569] - force: TRUE
[18:01:58.570] - relayed: [n=2] FALSE, FALSE
[18:01:58.571] - queued futures: [n=2] FALSE, FALSE
[18:01:58.571]  - until=1
[18:01:58.572]  - relaying element #1
[18:01:58.573] result() for MulticoreFuture ...
[18:01:58.573] result() for MulticoreFuture ... done
[18:01:58.574] result() for MulticoreFuture ...
[18:01:58.574] result() for MulticoreFuture ... done
[18:01:58.575] result() for MulticoreFuture ...
[18:01:58.575] result() for MulticoreFuture ... done
[18:01:58.576] result() for MulticoreFuture ...
[18:01:58.576] result() for MulticoreFuture ... done
[18:01:58.577] - relayed: [n=2] TRUE, FALSE
[18:01:58.577] - queued futures: [n=2] TRUE, FALSE
[18:01:58.578] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:58.579]  length: 1 (resolved future 1)
[18:01:58.580] Future #2
[18:01:58.580] result() for MulticoreFuture ...
[18:01:58.582] result() for MulticoreFuture ...
[18:01:58.582] result() for MulticoreFuture ... done
[18:01:58.583] result() for MulticoreFuture ... done
[18:01:58.583] result() for MulticoreFuture ...
[18:01:58.583] result() for MulticoreFuture ... done
[18:01:58.584] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:58.584] - nx: 2
[18:01:58.584] - relay: TRUE
[18:01:58.584] - stdout: TRUE
[18:01:58.585] - signal: TRUE
[18:01:58.585] - resignal: FALSE
[18:01:58.585] - force: TRUE
[18:01:58.585] - relayed: [n=2] TRUE, FALSE
[18:01:58.586] - queued futures: [n=2] TRUE, FALSE
[18:01:58.586]  - until=2
[18:01:58.586]  - relaying element #2
[18:01:58.586] result() for MulticoreFuture ...
[18:01:58.586] result() for MulticoreFuture ... done
[18:01:58.587] result() for MulticoreFuture ...
[18:01:58.587] result() for MulticoreFuture ... done
[18:01:58.587] result() for MulticoreFuture ...
[18:01:58.587] result() for MulticoreFuture ... done
[18:01:58.588] result() for MulticoreFuture ...
[18:01:58.588] result() for MulticoreFuture ... done
[18:01:58.588] - relayed: [n=2] TRUE, TRUE
[18:01:58.588] - queued futures: [n=2] TRUE, TRUE
[18:01:58.589] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:58.589]  length: 0 (resolved future 2)
[18:01:58.589] Relaying remaining futures
[18:01:58.589] signalConditionsASAP(NULL, pos=0) ...
[18:01:58.589] - nx: 2
[18:01:58.590] - relay: TRUE
[18:01:58.590] - stdout: TRUE
[18:01:58.590] - signal: TRUE
[18:01:58.590] - resignal: FALSE
[18:01:58.590] - force: TRUE
[18:01:58.591] - relayed: [n=2] TRUE, TRUE
[18:01:58.591] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:58.591] - relayed: [n=2] TRUE, TRUE
[18:01:58.591] - queued futures: [n=2] TRUE, TRUE
[18:01:58.592] signalConditionsASAP(NULL, pos=0) ... done
[18:01:58.592] resolve() on list ... DONE
[18:01:58.592] result() for MulticoreFuture ...
[18:01:58.592] result() for MulticoreFuture ... done
[18:01:58.592] result() for MulticoreFuture ...
[18:01:58.593] result() for MulticoreFuture ... done
[18:01:58.593] result() for MulticoreFuture ...
[18:01:58.593] result() for MulticoreFuture ... done
[18:01:58.593] result() for MulticoreFuture ...
[18:01:58.594] result() for MulticoreFuture ... done
[18:01:58.594]  - Number of value chunks collected: 2
[18:01:58.594] Resolving 2 futures (chunks) ... DONE
[18:01:58.594] Reducing values from 2 chunks ...
[18:01:58.594]  - Number of values collected after concatenation: 10
[18:01:58.595]  - Number of values expected: 10
[18:01:58.595] Reducing values from 2 chunks ... DONE
[18:01:58.595] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[18:01:58.597] future_lapply() ...
[18:01:58.607] Number of chunks: 2
[18:01:58.608] getGlobalsAndPackagesXApply() ...
[18:01:58.608]  - future.globals: TRUE
[18:01:58.608] getGlobalsAndPackages() ...
[18:01:58.608] Searching for globals...
[18:01:58.616] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[18:01:58.617] Searching for globals ... DONE
[18:01:58.617] Resolving globals: FALSE
[18:01:58.619] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[18:01:58.619] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:58.620] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:58.620] - packages: [1] ‘future.apply’
[18:01:58.620] getGlobalsAndPackages() ... DONE
[18:01:58.620]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:58.621]  - needed namespaces: [n=1] ‘future.apply’
[18:01:58.621] Finding globals ... DONE
[18:01:58.621]  - use_args: TRUE
[18:01:58.621]  - Getting '...' globals ...
[18:01:58.622] resolve() on list ...
[18:01:58.622]  recursive: 0
[18:01:58.622]  length: 1
[18:01:58.622]  elements: ‘...’
[18:01:58.625]  length: 0 (resolved future 1)
[18:01:58.626] resolve() on list ... DONE
[18:01:58.626]    - '...' content: [n=0] 
[18:01:58.626] List of 1
[18:01:58.626]  $ ...: list()
[18:01:58.626]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.626]  - attr(*, "where")=List of 1
[18:01:58.626]   ..$ ...:<environment: 0x6183bf2a2d50> 
[18:01:58.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.626]  - attr(*, "resolved")= logi TRUE
[18:01:58.626]  - attr(*, "total_size")= num NA
[18:01:58.632]  - Getting '...' globals ... DONE
[18:01:58.632] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:58.632] List of 8
[18:01:58.632]  $ ...future.FUN:function (x, ...)  
[18:01:58.632]  $ x_FUN        :function (x)  
[18:01:58.632]  $ times        : int 4
[18:01:58.632]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:58.632]  $ stop_if_not  :function (...)  
[18:01:58.632]  $ dim          : int [1:2] 2 2
[18:01:58.632]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:58.632]  $ ...          : list()
[18:01:58.632]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.632]  - attr(*, "where")=List of 8
[18:01:58.632]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:58.632]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:58.632]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:58.632]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:58.632]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:58.632]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:58.632]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:58.632]   ..$ ...          :<environment: 0x6183bf2a2d50> 
[18:01:58.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.632]  - attr(*, "resolved")= logi FALSE
[18:01:58.632]  - attr(*, "total_size")= num 97304
[18:01:58.643] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:58.644] getGlobalsAndPackagesXApply() ... DONE
[18:01:58.644] Number of futures (= number of chunks): 2
[18:01:58.644] Launching 2 futures (chunks) ...
[18:01:58.644] Chunk #1 of 2 ...
[18:01:58.645]  - Finding globals in 'X' for chunk #1 ...
[18:01:58.645] getGlobalsAndPackages() ...
[18:01:58.645] Searching for globals...
[18:01:58.646] 
[18:01:58.646] Searching for globals ... DONE
[18:01:58.646] - globals: [0] <none>
[18:01:58.646] getGlobalsAndPackages() ... DONE
[18:01:58.646]    + additional globals found: [n=0] 
[18:01:58.647]    + additional namespaces needed: [n=0] 
[18:01:58.647]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:58.647]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:58.647]  - seeds: <none>
[18:01:58.647]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.648] getGlobalsAndPackages() ...
[18:01:58.648] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.648] Resolving globals: FALSE
[18:01:58.648] Tweak future expression to call with '...' arguments ...
[18:01:58.649] {
[18:01:58.649]     do.call(function(...) {
[18:01:58.649]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.649]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.649]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.649]             on.exit(options(oopts), add = TRUE)
[18:01:58.649]         }
[18:01:58.649]         {
[18:01:58.649]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.649]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.649]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.649]             })
[18:01:58.649]         }
[18:01:58.649]     }, args = future.call.arguments)
[18:01:58.649] }
[18:01:58.649] Tweak future expression to call with '...' arguments ... DONE
[18:01:58.650] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.650] - packages: [1] ‘future.apply’
[18:01:58.651] getGlobalsAndPackages() ... DONE
[18:01:58.651] run() for ‘Future’ ...
[18:01:58.651] - state: ‘created’
[18:01:58.652] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:58.658] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.658] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:58.659]   - Field: ‘label’
[18:01:58.659]   - Field: ‘local’
[18:01:58.659]   - Field: ‘owner’
[18:01:58.659]   - Field: ‘envir’
[18:01:58.660]   - Field: ‘workers’
[18:01:58.660]   - Field: ‘packages’
[18:01:58.660]   - Field: ‘gc’
[18:01:58.660]   - Field: ‘job’
[18:01:58.660]   - Field: ‘conditions’
[18:01:58.661]   - Field: ‘expr’
[18:01:58.661]   - Field: ‘uuid’
[18:01:58.661]   - Field: ‘seed’
[18:01:58.661]   - Field: ‘version’
[18:01:58.661]   - Field: ‘result’
[18:01:58.662]   - Field: ‘asynchronous’
[18:01:58.662]   - Field: ‘calls’
[18:01:58.662]   - Field: ‘globals’
[18:01:58.662]   - Field: ‘stdout’
[18:01:58.662]   - Field: ‘earlySignal’
[18:01:58.663]   - Field: ‘lazy’
[18:01:58.663]   - Field: ‘state’
[18:01:58.663] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:58.663] - Launch lazy future ...
[18:01:58.664] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:58.664] Packages needed by future strategies (n = 0): <none>
[18:01:58.665] {
[18:01:58.665]     {
[18:01:58.665]         {
[18:01:58.665]             ...future.startTime <- base::Sys.time()
[18:01:58.665]             {
[18:01:58.665]                 {
[18:01:58.665]                   {
[18:01:58.665]                     {
[18:01:58.665]                       {
[18:01:58.665]                         base::local({
[18:01:58.665]                           has_future <- base::requireNamespace("future", 
[18:01:58.665]                             quietly = TRUE)
[18:01:58.665]                           if (has_future) {
[18:01:58.665]                             ns <- base::getNamespace("future")
[18:01:58.665]                             version <- ns[[".package"]][["version"]]
[18:01:58.665]                             if (is.null(version)) 
[18:01:58.665]                               version <- utils::packageVersion("future")
[18:01:58.665]                           }
[18:01:58.665]                           else {
[18:01:58.665]                             version <- NULL
[18:01:58.665]                           }
[18:01:58.665]                           if (!has_future || version < "1.8.0") {
[18:01:58.665]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:58.665]                               "", base::R.version$version.string), 
[18:01:58.665]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:58.665]                                 base::R.version$platform, 8 * 
[18:01:58.665]                                   base::.Machine$sizeof.pointer), 
[18:01:58.665]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:58.665]                                 "release", "version")], collapse = " "), 
[18:01:58.665]                               hostname = base::Sys.info()[["nodename"]])
[18:01:58.665]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:58.665]                               info)
[18:01:58.665]                             info <- base::paste(info, collapse = "; ")
[18:01:58.665]                             if (!has_future) {
[18:01:58.665]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:58.665]                                 info)
[18:01:58.665]                             }
[18:01:58.665]                             else {
[18:01:58.665]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:58.665]                                 info, version)
[18:01:58.665]                             }
[18:01:58.665]                             base::stop(msg)
[18:01:58.665]                           }
[18:01:58.665]                         })
[18:01:58.665]                       }
[18:01:58.665]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:58.665]                       base::options(mc.cores = 1L)
[18:01:58.665]                     }
[18:01:58.665]                     base::local({
[18:01:58.665]                       for (pkg in "future.apply") {
[18:01:58.665]                         base::loadNamespace(pkg)
[18:01:58.665]                         base::library(pkg, character.only = TRUE)
[18:01:58.665]                       }
[18:01:58.665]                     })
[18:01:58.665]                   }
[18:01:58.665]                   ...future.strategy.old <- future::plan("list")
[18:01:58.665]                   options(future.plan = NULL)
[18:01:58.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:58.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:58.665]                 }
[18:01:58.665]                 ...future.workdir <- getwd()
[18:01:58.665]             }
[18:01:58.665]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:58.665]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:58.665]         }
[18:01:58.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:58.665]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:58.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:58.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:58.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:58.665]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:58.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:58.665]             base::names(...future.oldOptions))
[18:01:58.665]     }
[18:01:58.665]     if (FALSE) {
[18:01:58.665]     }
[18:01:58.665]     else {
[18:01:58.665]         if (TRUE) {
[18:01:58.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:58.665]                 open = "w")
[18:01:58.665]         }
[18:01:58.665]         else {
[18:01:58.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:58.665]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:58.665]         }
[18:01:58.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:58.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:58.665]             base::sink(type = "output", split = FALSE)
[18:01:58.665]             base::close(...future.stdout)
[18:01:58.665]         }, add = TRUE)
[18:01:58.665]     }
[18:01:58.665]     ...future.frame <- base::sys.nframe()
[18:01:58.665]     ...future.conditions <- base::list()
[18:01:58.665]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:58.665]     if (FALSE) {
[18:01:58.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:58.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:58.665]     }
[18:01:58.665]     ...future.result <- base::tryCatch({
[18:01:58.665]         base::withCallingHandlers({
[18:01:58.665]             ...future.value <- base::withVisible(base::local({
[18:01:58.665]                 withCallingHandlers({
[18:01:58.665]                   {
[18:01:58.665]                     do.call(function(...) {
[18:01:58.665]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.665]                       if (!identical(...future.globals.maxSize.org, 
[18:01:58.665]                         ...future.globals.maxSize)) {
[18:01:58.665]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.665]                         on.exit(options(oopts), add = TRUE)
[18:01:58.665]                       }
[18:01:58.665]                       {
[18:01:58.665]                         lapply(seq_along(...future.elements_ii), 
[18:01:58.665]                           FUN = function(jj) {
[18:01:58.665]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.665]                             ...future.FUN(...future.X_jj, ...)
[18:01:58.665]                           })
[18:01:58.665]                       }
[18:01:58.665]                     }, args = future.call.arguments)
[18:01:58.665]                   }
[18:01:58.665]                 }, immediateCondition = function(cond) {
[18:01:58.665]                   save_rds <- function (object, pathname, ...) 
[18:01:58.665]                   {
[18:01:58.665]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:58.665]                     if (file_test("-f", pathname_tmp)) {
[18:01:58.665]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.665]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:58.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.665]                         fi_tmp[["mtime"]])
[18:01:58.665]                     }
[18:01:58.665]                     tryCatch({
[18:01:58.665]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:58.665]                     }, error = function(ex) {
[18:01:58.665]                       msg <- conditionMessage(ex)
[18:01:58.665]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.665]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:58.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.665]                         fi_tmp[["mtime"]], msg)
[18:01:58.665]                       ex$message <- msg
[18:01:58.665]                       stop(ex)
[18:01:58.665]                     })
[18:01:58.665]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:58.665]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:58.665]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:58.665]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.665]                       fi <- file.info(pathname)
[18:01:58.665]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:58.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.665]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:58.665]                         fi[["size"]], fi[["mtime"]])
[18:01:58.665]                       stop(msg)
[18:01:58.665]                     }
[18:01:58.665]                     invisible(pathname)
[18:01:58.665]                   }
[18:01:58.665]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:58.665]                     rootPath = tempdir()) 
[18:01:58.665]                   {
[18:01:58.665]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:58.665]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:58.665]                       tmpdir = path, fileext = ".rds")
[18:01:58.665]                     save_rds(obj, file)
[18:01:58.665]                   }
[18:01:58.665]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:58.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.665]                   {
[18:01:58.665]                     inherits <- base::inherits
[18:01:58.665]                     invokeRestart <- base::invokeRestart
[18:01:58.665]                     is.null <- base::is.null
[18:01:58.665]                     muffled <- FALSE
[18:01:58.665]                     if (inherits(cond, "message")) {
[18:01:58.665]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:58.665]                       if (muffled) 
[18:01:58.665]                         invokeRestart("muffleMessage")
[18:01:58.665]                     }
[18:01:58.665]                     else if (inherits(cond, "warning")) {
[18:01:58.665]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:58.665]                       if (muffled) 
[18:01:58.665]                         invokeRestart("muffleWarning")
[18:01:58.665]                     }
[18:01:58.665]                     else if (inherits(cond, "condition")) {
[18:01:58.665]                       if (!is.null(pattern)) {
[18:01:58.665]                         computeRestarts <- base::computeRestarts
[18:01:58.665]                         grepl <- base::grepl
[18:01:58.665]                         restarts <- computeRestarts(cond)
[18:01:58.665]                         for (restart in restarts) {
[18:01:58.665]                           name <- restart$name
[18:01:58.665]                           if (is.null(name)) 
[18:01:58.665]                             next
[18:01:58.665]                           if (!grepl(pattern, name)) 
[18:01:58.665]                             next
[18:01:58.665]                           invokeRestart(restart)
[18:01:58.665]                           muffled <- TRUE
[18:01:58.665]                           break
[18:01:58.665]                         }
[18:01:58.665]                       }
[18:01:58.665]                     }
[18:01:58.665]                     invisible(muffled)
[18:01:58.665]                   }
[18:01:58.665]                   muffleCondition(cond)
[18:01:58.665]                 })
[18:01:58.665]             }))
[18:01:58.665]             future::FutureResult(value = ...future.value$value, 
[18:01:58.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:58.665]                   ...future.rng), globalenv = if (FALSE) 
[18:01:58.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:58.665]                     ...future.globalenv.names))
[18:01:58.665]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:58.665]         }, condition = base::local({
[18:01:58.665]             c <- base::c
[18:01:58.665]             inherits <- base::inherits
[18:01:58.665]             invokeRestart <- base::invokeRestart
[18:01:58.665]             length <- base::length
[18:01:58.665]             list <- base::list
[18:01:58.665]             seq.int <- base::seq.int
[18:01:58.665]             signalCondition <- base::signalCondition
[18:01:58.665]             sys.calls <- base::sys.calls
[18:01:58.665]             `[[` <- base::`[[`
[18:01:58.665]             `+` <- base::`+`
[18:01:58.665]             `<<-` <- base::`<<-`
[18:01:58.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:58.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:58.665]                   3L)]
[18:01:58.665]             }
[18:01:58.665]             function(cond) {
[18:01:58.665]                 is_error <- inherits(cond, "error")
[18:01:58.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:58.665]                   NULL)
[18:01:58.665]                 if (is_error) {
[18:01:58.665]                   sessionInformation <- function() {
[18:01:58.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:58.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:58.665]                       search = base::search(), system = base::Sys.info())
[18:01:58.665]                   }
[18:01:58.665]                   ...future.conditions[[length(...future.conditions) + 
[18:01:58.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:58.665]                     cond$call), session = sessionInformation(), 
[18:01:58.665]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:58.665]                   signalCondition(cond)
[18:01:58.665]                 }
[18:01:58.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:58.665]                 "immediateCondition"))) {
[18:01:58.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:58.665]                   ...future.conditions[[length(...future.conditions) + 
[18:01:58.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:58.665]                   if (TRUE && !signal) {
[18:01:58.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.665]                     {
[18:01:58.665]                       inherits <- base::inherits
[18:01:58.665]                       invokeRestart <- base::invokeRestart
[18:01:58.665]                       is.null <- base::is.null
[18:01:58.665]                       muffled <- FALSE
[18:01:58.665]                       if (inherits(cond, "message")) {
[18:01:58.665]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:58.665]                         if (muffled) 
[18:01:58.665]                           invokeRestart("muffleMessage")
[18:01:58.665]                       }
[18:01:58.665]                       else if (inherits(cond, "warning")) {
[18:01:58.665]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:58.665]                         if (muffled) 
[18:01:58.665]                           invokeRestart("muffleWarning")
[18:01:58.665]                       }
[18:01:58.665]                       else if (inherits(cond, "condition")) {
[18:01:58.665]                         if (!is.null(pattern)) {
[18:01:58.665]                           computeRestarts <- base::computeRestarts
[18:01:58.665]                           grepl <- base::grepl
[18:01:58.665]                           restarts <- computeRestarts(cond)
[18:01:58.665]                           for (restart in restarts) {
[18:01:58.665]                             name <- restart$name
[18:01:58.665]                             if (is.null(name)) 
[18:01:58.665]                               next
[18:01:58.665]                             if (!grepl(pattern, name)) 
[18:01:58.665]                               next
[18:01:58.665]                             invokeRestart(restart)
[18:01:58.665]                             muffled <- TRUE
[18:01:58.665]                             break
[18:01:58.665]                           }
[18:01:58.665]                         }
[18:01:58.665]                       }
[18:01:58.665]                       invisible(muffled)
[18:01:58.665]                     }
[18:01:58.665]                     muffleCondition(cond, pattern = "^muffle")
[18:01:58.665]                   }
[18:01:58.665]                 }
[18:01:58.665]                 else {
[18:01:58.665]                   if (TRUE) {
[18:01:58.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.665]                     {
[18:01:58.665]                       inherits <- base::inherits
[18:01:58.665]                       invokeRestart <- base::invokeRestart
[18:01:58.665]                       is.null <- base::is.null
[18:01:58.665]                       muffled <- FALSE
[18:01:58.665]                       if (inherits(cond, "message")) {
[18:01:58.665]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:58.665]                         if (muffled) 
[18:01:58.665]                           invokeRestart("muffleMessage")
[18:01:58.665]                       }
[18:01:58.665]                       else if (inherits(cond, "warning")) {
[18:01:58.665]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:58.665]                         if (muffled) 
[18:01:58.665]                           invokeRestart("muffleWarning")
[18:01:58.665]                       }
[18:01:58.665]                       else if (inherits(cond, "condition")) {
[18:01:58.665]                         if (!is.null(pattern)) {
[18:01:58.665]                           computeRestarts <- base::computeRestarts
[18:01:58.665]                           grepl <- base::grepl
[18:01:58.665]                           restarts <- computeRestarts(cond)
[18:01:58.665]                           for (restart in restarts) {
[18:01:58.665]                             name <- restart$name
[18:01:58.665]                             if (is.null(name)) 
[18:01:58.665]                               next
[18:01:58.665]                             if (!grepl(pattern, name)) 
[18:01:58.665]                               next
[18:01:58.665]                             invokeRestart(restart)
[18:01:58.665]                             muffled <- TRUE
[18:01:58.665]                             break
[18:01:58.665]                           }
[18:01:58.665]                         }
[18:01:58.665]                       }
[18:01:58.665]                       invisible(muffled)
[18:01:58.665]                     }
[18:01:58.665]                     muffleCondition(cond, pattern = "^muffle")
[18:01:58.665]                   }
[18:01:58.665]                 }
[18:01:58.665]             }
[18:01:58.665]         }))
[18:01:58.665]     }, error = function(ex) {
[18:01:58.665]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:58.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:58.665]                 ...future.rng), started = ...future.startTime, 
[18:01:58.665]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:58.665]             version = "1.8"), class = "FutureResult")
[18:01:58.665]     }, finally = {
[18:01:58.665]         if (!identical(...future.workdir, getwd())) 
[18:01:58.665]             setwd(...future.workdir)
[18:01:58.665]         {
[18:01:58.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:58.665]                 ...future.oldOptions$nwarnings <- NULL
[18:01:58.665]             }
[18:01:58.665]             base::options(...future.oldOptions)
[18:01:58.665]             if (.Platform$OS.type == "windows") {
[18:01:58.665]                 old_names <- names(...future.oldEnvVars)
[18:01:58.665]                 envs <- base::Sys.getenv()
[18:01:58.665]                 names <- names(envs)
[18:01:58.665]                 common <- intersect(names, old_names)
[18:01:58.665]                 added <- setdiff(names, old_names)
[18:01:58.665]                 removed <- setdiff(old_names, names)
[18:01:58.665]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:58.665]                   envs[common]]
[18:01:58.665]                 NAMES <- toupper(changed)
[18:01:58.665]                 args <- list()
[18:01:58.665]                 for (kk in seq_along(NAMES)) {
[18:01:58.665]                   name <- changed[[kk]]
[18:01:58.665]                   NAME <- NAMES[[kk]]
[18:01:58.665]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.665]                     next
[18:01:58.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:58.665]                 }
[18:01:58.665]                 NAMES <- toupper(added)
[18:01:58.665]                 for (kk in seq_along(NAMES)) {
[18:01:58.665]                   name <- added[[kk]]
[18:01:58.665]                   NAME <- NAMES[[kk]]
[18:01:58.665]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.665]                     next
[18:01:58.665]                   args[[name]] <- ""
[18:01:58.665]                 }
[18:01:58.665]                 NAMES <- toupper(removed)
[18:01:58.665]                 for (kk in seq_along(NAMES)) {
[18:01:58.665]                   name <- removed[[kk]]
[18:01:58.665]                   NAME <- NAMES[[kk]]
[18:01:58.665]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.665]                     next
[18:01:58.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:58.665]                 }
[18:01:58.665]                 if (length(args) > 0) 
[18:01:58.665]                   base::do.call(base::Sys.setenv, args = args)
[18:01:58.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:58.665]             }
[18:01:58.665]             else {
[18:01:58.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:58.665]             }
[18:01:58.665]             {
[18:01:58.665]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:58.665]                   0L) {
[18:01:58.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:58.665]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:58.665]                   base::options(opts)
[18:01:58.665]                 }
[18:01:58.665]                 {
[18:01:58.665]                   {
[18:01:58.665]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:58.665]                     NULL
[18:01:58.665]                   }
[18:01:58.665]                   options(future.plan = NULL)
[18:01:58.665]                   if (is.na(NA_character_)) 
[18:01:58.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:58.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:58.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:58.665]                     .init = FALSE)
[18:01:58.665]                 }
[18:01:58.665]             }
[18:01:58.665]         }
[18:01:58.665]     })
[18:01:58.665]     if (TRUE) {
[18:01:58.665]         base::sink(type = "output", split = FALSE)
[18:01:58.665]         if (TRUE) {
[18:01:58.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:58.665]         }
[18:01:58.665]         else {
[18:01:58.665]             ...future.result["stdout"] <- base::list(NULL)
[18:01:58.665]         }
[18:01:58.665]         base::close(...future.stdout)
[18:01:58.665]         ...future.stdout <- NULL
[18:01:58.665]     }
[18:01:58.665]     ...future.result$conditions <- ...future.conditions
[18:01:58.665]     ...future.result$finished <- base::Sys.time()
[18:01:58.665]     ...future.result
[18:01:58.665] }
[18:01:58.670] assign_globals() ...
[18:01:58.670] List of 11
[18:01:58.670]  $ ...future.FUN            :function (x, ...)  
[18:01:58.670]  $ x_FUN                    :function (x)  
[18:01:58.670]  $ times                    : int 4
[18:01:58.670]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:58.670]  $ stop_if_not              :function (...)  
[18:01:58.670]  $ dim                      : int [1:2] 2 2
[18:01:58.670]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:58.670]  $ future.call.arguments    : list()
[18:01:58.670]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.670]  $ ...future.elements_ii    :List of 5
[18:01:58.670]   ..$ : int 1
[18:01:58.670]   ..$ : int 2
[18:01:58.670]   ..$ : int 3
[18:01:58.670]   ..$ : int 4
[18:01:58.670]   ..$ : int 5
[18:01:58.670]  $ ...future.seeds_ii       : NULL
[18:01:58.670]  $ ...future.globals.maxSize: NULL
[18:01:58.670]  - attr(*, "where")=List of 11
[18:01:58.670]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:58.670]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:58.670]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:58.670]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:58.670]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:58.670]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:58.670]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:58.670]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:58.670]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:58.670]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:58.670]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:58.670]  - attr(*, "resolved")= logi FALSE
[18:01:58.670]  - attr(*, "total_size")= num 97304
[18:01:58.670]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.670]  - attr(*, "already-done")= logi TRUE
[18:01:58.691] - copied ‘...future.FUN’ to environment
[18:01:58.691] - reassign environment for ‘x_FUN’
[18:01:58.691] - copied ‘x_FUN’ to environment
[18:01:58.691] - copied ‘times’ to environment
[18:01:58.692] - copied ‘stopf’ to environment
[18:01:58.692] - copied ‘stop_if_not’ to environment
[18:01:58.692] - copied ‘dim’ to environment
[18:01:58.692] - copied ‘valid_types’ to environment
[18:01:58.692] - copied ‘future.call.arguments’ to environment
[18:01:58.693] - copied ‘...future.elements_ii’ to environment
[18:01:58.693] - copied ‘...future.seeds_ii’ to environment
[18:01:58.693] - copied ‘...future.globals.maxSize’ to environment
[18:01:58.693] assign_globals() ... done
[18:01:58.694] requestCore(): workers = 2
[18:01:58.697] MulticoreFuture started
[18:01:58.698] - Launch lazy future ... done
[18:01:58.698] run() for ‘MulticoreFuture’ ... done
[18:01:58.699] Created future:
[18:01:58.699] plan(): Setting new future strategy stack:
[18:01:58.700] List of future strategies:
[18:01:58.700] 1. sequential:
[18:01:58.700]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:58.700]    - tweaked: FALSE
[18:01:58.700]    - call: NULL
[18:01:58.702] plan(): nbrOfWorkers() = 1
[18:01:58.707] plan(): Setting new future strategy stack:
[18:01:58.707] List of future strategies:
[18:01:58.707] 1. multicore:
[18:01:58.707]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:58.707]    - tweaked: FALSE
[18:01:58.707]    - call: plan(strategy)
[18:01:58.699] MulticoreFuture:
[18:01:58.699] Label: ‘future_vapply-1’
[18:01:58.699] Expression:
[18:01:58.699] {
[18:01:58.699]     do.call(function(...) {
[18:01:58.699]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.699]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.699]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.699]             on.exit(options(oopts), add = TRUE)
[18:01:58.699]         }
[18:01:58.699]         {
[18:01:58.699]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.699]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.699]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.699]             })
[18:01:58.699]         }
[18:01:58.699]     }, args = future.call.arguments)
[18:01:58.699] }
[18:01:58.699] Lazy evaluation: FALSE
[18:01:58.699] Asynchronous evaluation: TRUE
[18:01:58.699] Local evaluation: TRUE
[18:01:58.699] Environment: R_GlobalEnv
[18:01:58.699] Capture standard output: TRUE
[18:01:58.699] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:58.699] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:58.699] Packages: 1 packages (‘future.apply’)
[18:01:58.699] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:58.699] Resolved: FALSE
[18:01:58.699] Value: <not collected>
[18:01:58.699] Conditions captured: <none>
[18:01:58.699] Early signaling: FALSE
[18:01:58.699] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:58.699] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.715] Chunk #1 of 2 ... DONE
[18:01:58.715] Chunk #2 of 2 ...
[18:01:58.716]  - Finding globals in 'X' for chunk #2 ...
[18:01:58.716] getGlobalsAndPackages() ...
[18:01:58.717] Searching for globals...
[18:01:58.717] 
[18:01:58.718] plan(): nbrOfWorkers() = 2
[18:01:58.718] Searching for globals ... DONE
[18:01:58.718] - globals: [0] <none>
[18:01:58.718] getGlobalsAndPackages() ... DONE
[18:01:58.719]    + additional globals found: [n=0] 
[18:01:58.719]    + additional namespaces needed: [n=0] 
[18:01:58.719]  - Finding globals in 'X' for chunk #2 ... DONE
[18:01:58.719]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:58.720]  - seeds: <none>
[18:01:58.720]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.720] getGlobalsAndPackages() ...
[18:01:58.721] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.721] Resolving globals: FALSE
[18:01:58.721] Tweak future expression to call with '...' arguments ...
[18:01:58.722] {
[18:01:58.722]     do.call(function(...) {
[18:01:58.722]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.722]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.722]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.722]             on.exit(options(oopts), add = TRUE)
[18:01:58.722]         }
[18:01:58.722]         {
[18:01:58.722]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.722]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.722]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.722]             })
[18:01:58.722]         }
[18:01:58.722]     }, args = future.call.arguments)
[18:01:58.722] }
[18:01:58.723] Tweak future expression to call with '...' arguments ... DONE
[18:01:58.725] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.725] - packages: [1] ‘future.apply’
[18:01:58.725] getGlobalsAndPackages() ... DONE
[18:01:58.726] run() for ‘Future’ ...
[18:01:58.727] - state: ‘created’
[18:01:58.727] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:58.735] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.736] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:58.736]   - Field: ‘label’
[18:01:58.736]   - Field: ‘local’
[18:01:58.737]   - Field: ‘owner’
[18:01:58.737]   - Field: ‘envir’
[18:01:58.737]   - Field: ‘workers’
[18:01:58.738]   - Field: ‘packages’
[18:01:58.738]   - Field: ‘gc’
[18:01:58.738]   - Field: ‘job’
[18:01:58.738]   - Field: ‘conditions’
[18:01:58.739]   - Field: ‘expr’
[18:01:58.739]   - Field: ‘uuid’
[18:01:58.739]   - Field: ‘seed’
[18:01:58.740]   - Field: ‘version’
[18:01:58.740]   - Field: ‘result’
[18:01:58.740]   - Field: ‘asynchronous’
[18:01:58.740]   - Field: ‘calls’
[18:01:58.741]   - Field: ‘globals’
[18:01:58.741]   - Field: ‘stdout’
[18:01:58.741]   - Field: ‘earlySignal’
[18:01:58.742]   - Field: ‘lazy’
[18:01:58.742]   - Field: ‘state’
[18:01:58.742] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:58.743] - Launch lazy future ...
[18:01:58.743] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:58.744] Packages needed by future strategies (n = 0): <none>
[18:01:58.749] {
[18:01:58.749]     {
[18:01:58.749]         {
[18:01:58.749]             ...future.startTime <- base::Sys.time()
[18:01:58.749]             {
[18:01:58.749]                 {
[18:01:58.749]                   {
[18:01:58.749]                     {
[18:01:58.749]                       {
[18:01:58.749]                         base::local({
[18:01:58.749]                           has_future <- base::requireNamespace("future", 
[18:01:58.749]                             quietly = TRUE)
[18:01:58.749]                           if (has_future) {
[18:01:58.749]                             ns <- base::getNamespace("future")
[18:01:58.749]                             version <- ns[[".package"]][["version"]]
[18:01:58.749]                             if (is.null(version)) 
[18:01:58.749]                               version <- utils::packageVersion("future")
[18:01:58.749]                           }
[18:01:58.749]                           else {
[18:01:58.749]                             version <- NULL
[18:01:58.749]                           }
[18:01:58.749]                           if (!has_future || version < "1.8.0") {
[18:01:58.749]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:58.749]                               "", base::R.version$version.string), 
[18:01:58.749]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:58.749]                                 base::R.version$platform, 8 * 
[18:01:58.749]                                   base::.Machine$sizeof.pointer), 
[18:01:58.749]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:58.749]                                 "release", "version")], collapse = " "), 
[18:01:58.749]                               hostname = base::Sys.info()[["nodename"]])
[18:01:58.749]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:58.749]                               info)
[18:01:58.749]                             info <- base::paste(info, collapse = "; ")
[18:01:58.749]                             if (!has_future) {
[18:01:58.749]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:58.749]                                 info)
[18:01:58.749]                             }
[18:01:58.749]                             else {
[18:01:58.749]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:58.749]                                 info, version)
[18:01:58.749]                             }
[18:01:58.749]                             base::stop(msg)
[18:01:58.749]                           }
[18:01:58.749]                         })
[18:01:58.749]                       }
[18:01:58.749]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:58.749]                       base::options(mc.cores = 1L)
[18:01:58.749]                     }
[18:01:58.749]                     base::local({
[18:01:58.749]                       for (pkg in "future.apply") {
[18:01:58.749]                         base::loadNamespace(pkg)
[18:01:58.749]                         base::library(pkg, character.only = TRUE)
[18:01:58.749]                       }
[18:01:58.749]                     })
[18:01:58.749]                   }
[18:01:58.749]                   ...future.strategy.old <- future::plan("list")
[18:01:58.749]                   options(future.plan = NULL)
[18:01:58.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:58.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:58.749]                 }
[18:01:58.749]                 ...future.workdir <- getwd()
[18:01:58.749]             }
[18:01:58.749]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:58.749]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:58.749]         }
[18:01:58.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:58.749]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:58.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:58.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:58.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:58.749]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:58.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:58.749]             base::names(...future.oldOptions))
[18:01:58.749]     }
[18:01:58.749]     if (FALSE) {
[18:01:58.749]     }
[18:01:58.749]     else {
[18:01:58.749]         if (TRUE) {
[18:01:58.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:58.749]                 open = "w")
[18:01:58.749]         }
[18:01:58.749]         else {
[18:01:58.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:58.749]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:58.749]         }
[18:01:58.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:58.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:58.749]             base::sink(type = "output", split = FALSE)
[18:01:58.749]             base::close(...future.stdout)
[18:01:58.749]         }, add = TRUE)
[18:01:58.749]     }
[18:01:58.749]     ...future.frame <- base::sys.nframe()
[18:01:58.749]     ...future.conditions <- base::list()
[18:01:58.749]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:58.749]     if (FALSE) {
[18:01:58.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:58.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:58.749]     }
[18:01:58.749]     ...future.result <- base::tryCatch({
[18:01:58.749]         base::withCallingHandlers({
[18:01:58.749]             ...future.value <- base::withVisible(base::local({
[18:01:58.749]                 withCallingHandlers({
[18:01:58.749]                   {
[18:01:58.749]                     do.call(function(...) {
[18:01:58.749]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.749]                       if (!identical(...future.globals.maxSize.org, 
[18:01:58.749]                         ...future.globals.maxSize)) {
[18:01:58.749]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.749]                         on.exit(options(oopts), add = TRUE)
[18:01:58.749]                       }
[18:01:58.749]                       {
[18:01:58.749]                         lapply(seq_along(...future.elements_ii), 
[18:01:58.749]                           FUN = function(jj) {
[18:01:58.749]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.749]                             ...future.FUN(...future.X_jj, ...)
[18:01:58.749]                           })
[18:01:58.749]                       }
[18:01:58.749]                     }, args = future.call.arguments)
[18:01:58.749]                   }
[18:01:58.749]                 }, immediateCondition = function(cond) {
[18:01:58.749]                   save_rds <- function (object, pathname, ...) 
[18:01:58.749]                   {
[18:01:58.749]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:58.749]                     if (file_test("-f", pathname_tmp)) {
[18:01:58.749]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.749]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:58.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.749]                         fi_tmp[["mtime"]])
[18:01:58.749]                     }
[18:01:58.749]                     tryCatch({
[18:01:58.749]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:58.749]                     }, error = function(ex) {
[18:01:58.749]                       msg <- conditionMessage(ex)
[18:01:58.749]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.749]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:58.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.749]                         fi_tmp[["mtime"]], msg)
[18:01:58.749]                       ex$message <- msg
[18:01:58.749]                       stop(ex)
[18:01:58.749]                     })
[18:01:58.749]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:58.749]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:58.749]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:58.749]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.749]                       fi <- file.info(pathname)
[18:01:58.749]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:58.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.749]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:58.749]                         fi[["size"]], fi[["mtime"]])
[18:01:58.749]                       stop(msg)
[18:01:58.749]                     }
[18:01:58.749]                     invisible(pathname)
[18:01:58.749]                   }
[18:01:58.749]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:58.749]                     rootPath = tempdir()) 
[18:01:58.749]                   {
[18:01:58.749]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:58.749]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:58.749]                       tmpdir = path, fileext = ".rds")
[18:01:58.749]                     save_rds(obj, file)
[18:01:58.749]                   }
[18:01:58.749]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:58.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.749]                   {
[18:01:58.749]                     inherits <- base::inherits
[18:01:58.749]                     invokeRestart <- base::invokeRestart
[18:01:58.749]                     is.null <- base::is.null
[18:01:58.749]                     muffled <- FALSE
[18:01:58.749]                     if (inherits(cond, "message")) {
[18:01:58.749]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:58.749]                       if (muffled) 
[18:01:58.749]                         invokeRestart("muffleMessage")
[18:01:58.749]                     }
[18:01:58.749]                     else if (inherits(cond, "warning")) {
[18:01:58.749]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:58.749]                       if (muffled) 
[18:01:58.749]                         invokeRestart("muffleWarning")
[18:01:58.749]                     }
[18:01:58.749]                     else if (inherits(cond, "condition")) {
[18:01:58.749]                       if (!is.null(pattern)) {
[18:01:58.749]                         computeRestarts <- base::computeRestarts
[18:01:58.749]                         grepl <- base::grepl
[18:01:58.749]                         restarts <- computeRestarts(cond)
[18:01:58.749]                         for (restart in restarts) {
[18:01:58.749]                           name <- restart$name
[18:01:58.749]                           if (is.null(name)) 
[18:01:58.749]                             next
[18:01:58.749]                           if (!grepl(pattern, name)) 
[18:01:58.749]                             next
[18:01:58.749]                           invokeRestart(restart)
[18:01:58.749]                           muffled <- TRUE
[18:01:58.749]                           break
[18:01:58.749]                         }
[18:01:58.749]                       }
[18:01:58.749]                     }
[18:01:58.749]                     invisible(muffled)
[18:01:58.749]                   }
[18:01:58.749]                   muffleCondition(cond)
[18:01:58.749]                 })
[18:01:58.749]             }))
[18:01:58.749]             future::FutureResult(value = ...future.value$value, 
[18:01:58.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:58.749]                   ...future.rng), globalenv = if (FALSE) 
[18:01:58.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:58.749]                     ...future.globalenv.names))
[18:01:58.749]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:58.749]         }, condition = base::local({
[18:01:58.749]             c <- base::c
[18:01:58.749]             inherits <- base::inherits
[18:01:58.749]             invokeRestart <- base::invokeRestart
[18:01:58.749]             length <- base::length
[18:01:58.749]             list <- base::list
[18:01:58.749]             seq.int <- base::seq.int
[18:01:58.749]             signalCondition <- base::signalCondition
[18:01:58.749]             sys.calls <- base::sys.calls
[18:01:58.749]             `[[` <- base::`[[`
[18:01:58.749]             `+` <- base::`+`
[18:01:58.749]             `<<-` <- base::`<<-`
[18:01:58.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:58.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:58.749]                   3L)]
[18:01:58.749]             }
[18:01:58.749]             function(cond) {
[18:01:58.749]                 is_error <- inherits(cond, "error")
[18:01:58.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:58.749]                   NULL)
[18:01:58.749]                 if (is_error) {
[18:01:58.749]                   sessionInformation <- function() {
[18:01:58.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:58.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:58.749]                       search = base::search(), system = base::Sys.info())
[18:01:58.749]                   }
[18:01:58.749]                   ...future.conditions[[length(...future.conditions) + 
[18:01:58.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:58.749]                     cond$call), session = sessionInformation(), 
[18:01:58.749]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:58.749]                   signalCondition(cond)
[18:01:58.749]                 }
[18:01:58.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:58.749]                 "immediateCondition"))) {
[18:01:58.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:58.749]                   ...future.conditions[[length(...future.conditions) + 
[18:01:58.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:58.749]                   if (TRUE && !signal) {
[18:01:58.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.749]                     {
[18:01:58.749]                       inherits <- base::inherits
[18:01:58.749]                       invokeRestart <- base::invokeRestart
[18:01:58.749]                       is.null <- base::is.null
[18:01:58.749]                       muffled <- FALSE
[18:01:58.749]                       if (inherits(cond, "message")) {
[18:01:58.749]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:58.749]                         if (muffled) 
[18:01:58.749]                           invokeRestart("muffleMessage")
[18:01:58.749]                       }
[18:01:58.749]                       else if (inherits(cond, "warning")) {
[18:01:58.749]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:58.749]                         if (muffled) 
[18:01:58.749]                           invokeRestart("muffleWarning")
[18:01:58.749]                       }
[18:01:58.749]                       else if (inherits(cond, "condition")) {
[18:01:58.749]                         if (!is.null(pattern)) {
[18:01:58.749]                           computeRestarts <- base::computeRestarts
[18:01:58.749]                           grepl <- base::grepl
[18:01:58.749]                           restarts <- computeRestarts(cond)
[18:01:58.749]                           for (restart in restarts) {
[18:01:58.749]                             name <- restart$name
[18:01:58.749]                             if (is.null(name)) 
[18:01:58.749]                               next
[18:01:58.749]                             if (!grepl(pattern, name)) 
[18:01:58.749]                               next
[18:01:58.749]                             invokeRestart(restart)
[18:01:58.749]                             muffled <- TRUE
[18:01:58.749]                             break
[18:01:58.749]                           }
[18:01:58.749]                         }
[18:01:58.749]                       }
[18:01:58.749]                       invisible(muffled)
[18:01:58.749]                     }
[18:01:58.749]                     muffleCondition(cond, pattern = "^muffle")
[18:01:58.749]                   }
[18:01:58.749]                 }
[18:01:58.749]                 else {
[18:01:58.749]                   if (TRUE) {
[18:01:58.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.749]                     {
[18:01:58.749]                       inherits <- base::inherits
[18:01:58.749]                       invokeRestart <- base::invokeRestart
[18:01:58.749]                       is.null <- base::is.null
[18:01:58.749]                       muffled <- FALSE
[18:01:58.749]                       if (inherits(cond, "message")) {
[18:01:58.749]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:58.749]                         if (muffled) 
[18:01:58.749]                           invokeRestart("muffleMessage")
[18:01:58.749]                       }
[18:01:58.749]                       else if (inherits(cond, "warning")) {
[18:01:58.749]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:58.749]                         if (muffled) 
[18:01:58.749]                           invokeRestart("muffleWarning")
[18:01:58.749]                       }
[18:01:58.749]                       else if (inherits(cond, "condition")) {
[18:01:58.749]                         if (!is.null(pattern)) {
[18:01:58.749]                           computeRestarts <- base::computeRestarts
[18:01:58.749]                           grepl <- base::grepl
[18:01:58.749]                           restarts <- computeRestarts(cond)
[18:01:58.749]                           for (restart in restarts) {
[18:01:58.749]                             name <- restart$name
[18:01:58.749]                             if (is.null(name)) 
[18:01:58.749]                               next
[18:01:58.749]                             if (!grepl(pattern, name)) 
[18:01:58.749]                               next
[18:01:58.749]                             invokeRestart(restart)
[18:01:58.749]                             muffled <- TRUE
[18:01:58.749]                             break
[18:01:58.749]                           }
[18:01:58.749]                         }
[18:01:58.749]                       }
[18:01:58.749]                       invisible(muffled)
[18:01:58.749]                     }
[18:01:58.749]                     muffleCondition(cond, pattern = "^muffle")
[18:01:58.749]                   }
[18:01:58.749]                 }
[18:01:58.749]             }
[18:01:58.749]         }))
[18:01:58.749]     }, error = function(ex) {
[18:01:58.749]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:58.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:58.749]                 ...future.rng), started = ...future.startTime, 
[18:01:58.749]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:58.749]             version = "1.8"), class = "FutureResult")
[18:01:58.749]     }, finally = {
[18:01:58.749]         if (!identical(...future.workdir, getwd())) 
[18:01:58.749]             setwd(...future.workdir)
[18:01:58.749]         {
[18:01:58.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:58.749]                 ...future.oldOptions$nwarnings <- NULL
[18:01:58.749]             }
[18:01:58.749]             base::options(...future.oldOptions)
[18:01:58.749]             if (.Platform$OS.type == "windows") {
[18:01:58.749]                 old_names <- names(...future.oldEnvVars)
[18:01:58.749]                 envs <- base::Sys.getenv()
[18:01:58.749]                 names <- names(envs)
[18:01:58.749]                 common <- intersect(names, old_names)
[18:01:58.749]                 added <- setdiff(names, old_names)
[18:01:58.749]                 removed <- setdiff(old_names, names)
[18:01:58.749]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:58.749]                   envs[common]]
[18:01:58.749]                 NAMES <- toupper(changed)
[18:01:58.749]                 args <- list()
[18:01:58.749]                 for (kk in seq_along(NAMES)) {
[18:01:58.749]                   name <- changed[[kk]]
[18:01:58.749]                   NAME <- NAMES[[kk]]
[18:01:58.749]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.749]                     next
[18:01:58.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:58.749]                 }
[18:01:58.749]                 NAMES <- toupper(added)
[18:01:58.749]                 for (kk in seq_along(NAMES)) {
[18:01:58.749]                   name <- added[[kk]]
[18:01:58.749]                   NAME <- NAMES[[kk]]
[18:01:58.749]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.749]                     next
[18:01:58.749]                   args[[name]] <- ""
[18:01:58.749]                 }
[18:01:58.749]                 NAMES <- toupper(removed)
[18:01:58.749]                 for (kk in seq_along(NAMES)) {
[18:01:58.749]                   name <- removed[[kk]]
[18:01:58.749]                   NAME <- NAMES[[kk]]
[18:01:58.749]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.749]                     next
[18:01:58.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:58.749]                 }
[18:01:58.749]                 if (length(args) > 0) 
[18:01:58.749]                   base::do.call(base::Sys.setenv, args = args)
[18:01:58.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:58.749]             }
[18:01:58.749]             else {
[18:01:58.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:58.749]             }
[18:01:58.749]             {
[18:01:58.749]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:58.749]                   0L) {
[18:01:58.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:58.749]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:58.749]                   base::options(opts)
[18:01:58.749]                 }
[18:01:58.749]                 {
[18:01:58.749]                   {
[18:01:58.749]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:58.749]                     NULL
[18:01:58.749]                   }
[18:01:58.749]                   options(future.plan = NULL)
[18:01:58.749]                   if (is.na(NA_character_)) 
[18:01:58.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:58.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:58.749]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:58.749]                     .init = FALSE)
[18:01:58.749]                 }
[18:01:58.749]             }
[18:01:58.749]         }
[18:01:58.749]     })
[18:01:58.749]     if (TRUE) {
[18:01:58.749]         base::sink(type = "output", split = FALSE)
[18:01:58.749]         if (TRUE) {
[18:01:58.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:58.749]         }
[18:01:58.749]         else {
[18:01:58.749]             ...future.result["stdout"] <- base::list(NULL)
[18:01:58.749]         }
[18:01:58.749]         base::close(...future.stdout)
[18:01:58.749]         ...future.stdout <- NULL
[18:01:58.749]     }
[18:01:58.749]     ...future.result$conditions <- ...future.conditions
[18:01:58.749]     ...future.result$finished <- base::Sys.time()
[18:01:58.749]     ...future.result
[18:01:58.749] }
[18:01:58.757] assign_globals() ...
[18:01:58.757] List of 11
[18:01:58.757]  $ ...future.FUN            :function (x, ...)  
[18:01:58.757]  $ x_FUN                    :function (x)  
[18:01:58.757]  $ times                    : int 4
[18:01:58.757]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:58.757]  $ stop_if_not              :function (...)  
[18:01:58.757]  $ dim                      : int [1:2] 2 2
[18:01:58.757]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:58.757]  $ future.call.arguments    : list()
[18:01:58.757]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.757]  $ ...future.elements_ii    :List of 5
[18:01:58.757]   ..$ : int 6
[18:01:58.757]   ..$ : int 7
[18:01:58.757]   ..$ : int 8
[18:01:58.757]   ..$ : int 9
[18:01:58.757]   ..$ : int 10
[18:01:58.757]  $ ...future.seeds_ii       : NULL
[18:01:58.757]  $ ...future.globals.maxSize: NULL
[18:01:58.757]  - attr(*, "where")=List of 11
[18:01:58.757]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:58.757]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:58.757]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:58.757]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:58.757]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:58.757]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:58.757]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:58.757]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:58.757]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:58.757]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:58.757]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:58.757]  - attr(*, "resolved")= logi FALSE
[18:01:58.757]  - attr(*, "total_size")= num 97304
[18:01:58.757]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.757]  - attr(*, "already-done")= logi TRUE
[18:01:58.788] - copied ‘...future.FUN’ to environment
[18:01:58.788] - reassign environment for ‘x_FUN’
[18:01:58.788] - copied ‘x_FUN’ to environment
[18:01:58.789] - copied ‘times’ to environment
[18:01:58.789] - copied ‘stopf’ to environment
[18:01:58.789] - copied ‘stop_if_not’ to environment
[18:01:58.789] - copied ‘dim’ to environment
[18:01:58.790] - copied ‘valid_types’ to environment
[18:01:58.790] - copied ‘future.call.arguments’ to environment
[18:01:58.790] - copied ‘...future.elements_ii’ to environment
[18:01:58.790] - copied ‘...future.seeds_ii’ to environment
[18:01:58.790] - copied ‘...future.globals.maxSize’ to environment
[18:01:58.791] assign_globals() ... done
[18:01:58.791] requestCore(): workers = 2
[18:01:58.795] MulticoreFuture started
[18:01:58.796] - Launch lazy future ... done
[18:01:58.796] run() for ‘MulticoreFuture’ ... done
[18:01:58.797] Created future:
[18:01:58.801] plan(): Setting new future strategy stack:
[18:01:58.802] List of future strategies:
[18:01:58.802] 1. sequential:
[18:01:58.802]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:58.802]    - tweaked: FALSE
[18:01:58.802]    - call: NULL
[18:01:58.805] plan(): nbrOfWorkers() = 1
[18:01:58.809] plan(): Setting new future strategy stack:
[18:01:58.810] List of future strategies:
[18:01:58.810] 1. multicore:
[18:01:58.810]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:58.810]    - tweaked: FALSE
[18:01:58.810]    - call: plan(strategy)
[18:01:58.797] MulticoreFuture:
[18:01:58.797] Label: ‘future_vapply-2’
[18:01:58.797] Expression:
[18:01:58.797] {
[18:01:58.797]     do.call(function(...) {
[18:01:58.797]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.797]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.797]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.797]             on.exit(options(oopts), add = TRUE)
[18:01:58.797]         }
[18:01:58.797]         {
[18:01:58.797]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.797]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.797]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.797]             })
[18:01:58.797]         }
[18:01:58.797]     }, args = future.call.arguments)
[18:01:58.797] }
[18:01:58.797] Lazy evaluation: FALSE
[18:01:58.797] Asynchronous evaluation: TRUE
[18:01:58.797] Local evaluation: TRUE
[18:01:58.797] Environment: R_GlobalEnv
[18:01:58.797] Capture standard output: TRUE
[18:01:58.797] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:58.797] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:58.797] Packages: 1 packages (‘future.apply’)
[18:01:58.797] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:58.797] Resolved: FALSE
[18:01:58.797] Value: <not collected>
[18:01:58.797] Conditions captured: <none>
[18:01:58.797] Early signaling: FALSE
[18:01:58.797] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:58.797] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.814] Chunk #2 of 2 ... DONE
[18:01:58.814] Launching 2 futures (chunks) ... DONE
[18:01:58.814] Resolving 2 futures (chunks) ...
[18:01:58.815] resolve() on list ...
[18:01:58.815]  recursive: 0
[18:01:58.815]  length: 2
[18:01:58.815] 
[18:01:58.816] Future #1
[18:01:58.817] result() for MulticoreFuture ...
[18:01:58.818] result() for MulticoreFuture ...
[18:01:58.819] plan(): nbrOfWorkers() = 2
[18:01:58.819] result() for MulticoreFuture ... done
[18:01:58.820] result() for MulticoreFuture ... done
[18:01:58.820] result() for MulticoreFuture ...
[18:01:58.820] result() for MulticoreFuture ... done
[18:01:58.821] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:58.821] - nx: 2
[18:01:58.821] - relay: TRUE
[18:01:58.822] - stdout: TRUE
[18:01:58.822] - signal: TRUE
[18:01:58.822] - resignal: FALSE
[18:01:58.823] - force: TRUE
[18:01:58.823] - relayed: [n=2] FALSE, FALSE
[18:01:58.823] - queued futures: [n=2] FALSE, FALSE
[18:01:58.824]  - until=1
[18:01:58.824]  - relaying element #1
[18:01:58.824] result() for MulticoreFuture ...
[18:01:58.824] result() for MulticoreFuture ... done
[18:01:58.825] result() for MulticoreFuture ...
[18:01:58.825] result() for MulticoreFuture ... done
[18:01:58.826] result() for MulticoreFuture ...
[18:01:58.826] result() for MulticoreFuture ... done
[18:01:58.826] result() for MulticoreFuture ...
[18:01:58.826] result() for MulticoreFuture ... done
[18:01:58.827] - relayed: [n=2] TRUE, FALSE
[18:01:58.827] - queued futures: [n=2] TRUE, FALSE
[18:01:58.827] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:58.828]  length: 1 (resolved future 1)
[18:01:58.828] Future #2
[18:01:58.829] result() for MulticoreFuture ...
[18:01:58.830] result() for MulticoreFuture ...
[18:01:58.830] result() for MulticoreFuture ... done
[18:01:58.831] result() for MulticoreFuture ... done
[18:01:58.831] result() for MulticoreFuture ...
[18:01:58.831] result() for MulticoreFuture ... done
[18:01:58.832] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:58.832] - nx: 2
[18:01:58.832] - relay: TRUE
[18:01:58.833] - stdout: TRUE
[18:01:58.833] - signal: TRUE
[18:01:58.833] - resignal: FALSE
[18:01:58.833] - force: TRUE
[18:01:58.833] - relayed: [n=2] TRUE, FALSE
[18:01:58.834] - queued futures: [n=2] TRUE, FALSE
[18:01:58.834]  - until=2
[18:01:58.834]  - relaying element #2
[18:01:58.842] result() for MulticoreFuture ...
[18:01:58.842] result() for MulticoreFuture ... done
[18:01:58.842] result() for MulticoreFuture ...
[18:01:58.843] result() for MulticoreFuture ... done
[18:01:58.843] result() for MulticoreFuture ...
[18:01:58.843] result() for MulticoreFuture ... done
[18:01:58.843] result() for MulticoreFuture ...
[18:01:58.844] result() for MulticoreFuture ... done
[18:01:58.844] - relayed: [n=2] TRUE, TRUE
[18:01:58.844] - queued futures: [n=2] TRUE, TRUE
[18:01:58.844] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:58.844]  length: 0 (resolved future 2)
[18:01:58.845] Relaying remaining futures
[18:01:58.845] signalConditionsASAP(NULL, pos=0) ...
[18:01:58.845] - nx: 2
[18:01:58.845] - relay: TRUE
[18:01:58.845] - stdout: TRUE
[18:01:58.846] - signal: TRUE
[18:01:58.846] - resignal: FALSE
[18:01:58.846] - force: TRUE
[18:01:58.846] - relayed: [n=2] TRUE, TRUE
[18:01:58.847] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:58.847] - relayed: [n=2] TRUE, TRUE
[18:01:58.847] - queued futures: [n=2] TRUE, TRUE
[18:01:58.848] signalConditionsASAP(NULL, pos=0) ... done
[18:01:58.848] resolve() on list ... DONE
[18:01:58.848] result() for MulticoreFuture ...
[18:01:58.848] result() for MulticoreFuture ... done
[18:01:58.849] result() for MulticoreFuture ...
[18:01:58.849] result() for MulticoreFuture ... done
[18:01:58.849] result() for MulticoreFuture ...
[18:01:58.849] result() for MulticoreFuture ... done
[18:01:58.850] result() for MulticoreFuture ...
[18:01:58.850] result() for MulticoreFuture ... done
[18:01:58.850]  - Number of value chunks collected: 2
[18:01:58.851] Resolving 2 futures (chunks) ... DONE
[18:01:58.851] Reducing values from 2 chunks ...
[18:01:58.851]  - Number of values collected after concatenation: 10
[18:01:58.851]  - Number of values expected: 10
[18:01:58.852] Reducing values from 2 chunks ... DONE
[18:01:58.852] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[18:01:58.856] future_lapply() ...
[18:01:58.867] Number of chunks: 2
[18:01:58.867] getGlobalsAndPackagesXApply() ...
[18:01:58.867]  - future.globals: TRUE
[18:01:58.868] getGlobalsAndPackages() ...
[18:01:58.868] Searching for globals...
[18:01:58.876] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[18:01:58.877] Searching for globals ... DONE
[18:01:58.877] Resolving globals: FALSE
[18:01:58.879] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[18:01:58.880] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:58.880] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:58.880] - packages: [1] ‘future.apply’
[18:01:58.880] getGlobalsAndPackages() ... DONE
[18:01:58.881]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:58.881]  - needed namespaces: [n=1] ‘future.apply’
[18:01:58.881] Finding globals ... DONE
[18:01:58.881]  - use_args: TRUE
[18:01:58.881]  - Getting '...' globals ...
[18:01:58.882] resolve() on list ...
[18:01:58.882]  recursive: 0
[18:01:58.882]  length: 1
[18:01:58.883]  elements: ‘...’
[18:01:58.883]  length: 0 (resolved future 1)
[18:01:58.883] resolve() on list ... DONE
[18:01:58.883]    - '...' content: [n=0] 
[18:01:58.883] List of 1
[18:01:58.883]  $ ...: list()
[18:01:58.883]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.883]  - attr(*, "where")=List of 1
[18:01:58.883]   ..$ ...:<environment: 0x6183bf240e28> 
[18:01:58.883]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.883]  - attr(*, "resolved")= logi TRUE
[18:01:58.883]  - attr(*, "total_size")= num NA
[18:01:58.888]  - Getting '...' globals ... DONE
[18:01:58.889] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:58.889] List of 8
[18:01:58.889]  $ ...future.FUN:function (x, ...)  
[18:01:58.889]  $ x_FUN        :function (x)  
[18:01:58.889]  $ times        : int 4
[18:01:58.889]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:58.889]  $ stop_if_not  :function (...)  
[18:01:58.889]  $ dim          : int [1:2] 2 2
[18:01:58.889]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:58.889]  $ ...          : list()
[18:01:58.889]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.889]  - attr(*, "where")=List of 8
[18:01:58.889]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:58.889]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:58.889]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:58.889]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:58.889]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:58.889]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:58.889]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:58.889]   ..$ ...          :<environment: 0x6183bf240e28> 
[18:01:58.889]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.889]  - attr(*, "resolved")= logi FALSE
[18:01:58.889]  - attr(*, "total_size")= num 105552
[18:01:58.904] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:01:58.904] getGlobalsAndPackagesXApply() ... DONE
[18:01:58.904] Number of futures (= number of chunks): 2
[18:01:58.905] Launching 2 futures (chunks) ...
[18:01:58.905] Chunk #1 of 2 ...
[18:01:58.905]  - Finding globals in 'X' for chunk #1 ...
[18:01:58.905] getGlobalsAndPackages() ...
[18:01:58.905] Searching for globals...
[18:01:58.906] 
[18:01:58.906] Searching for globals ... DONE
[18:01:58.906] - globals: [0] <none>
[18:01:58.907] getGlobalsAndPackages() ... DONE
[18:01:58.907]    + additional globals found: [n=0] 
[18:01:58.907]    + additional namespaces needed: [n=0] 
[18:01:58.907]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:58.907]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:58.908]  - seeds: <none>
[18:01:58.908]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.908] getGlobalsAndPackages() ...
[18:01:58.908] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.908] Resolving globals: FALSE
[18:01:58.909] Tweak future expression to call with '...' arguments ...
[18:01:58.909] {
[18:01:58.909]     do.call(function(...) {
[18:01:58.909]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.909]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.909]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.909]             on.exit(options(oopts), add = TRUE)
[18:01:58.909]         }
[18:01:58.909]         {
[18:01:58.909]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.909]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.909]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.909]             })
[18:01:58.909]         }
[18:01:58.909]     }, args = future.call.arguments)
[18:01:58.909] }
[18:01:58.909] Tweak future expression to call with '...' arguments ... DONE
[18:01:58.910] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.911] - packages: [1] ‘future.apply’
[18:01:58.911] getGlobalsAndPackages() ... DONE
[18:01:58.912] run() for ‘Future’ ...
[18:01:58.912] - state: ‘created’
[18:01:58.912] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:58.918] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:58.919]   - Field: ‘label’
[18:01:58.919]   - Field: ‘local’
[18:01:58.919]   - Field: ‘owner’
[18:01:58.919]   - Field: ‘envir’
[18:01:58.920]   - Field: ‘workers’
[18:01:58.920]   - Field: ‘packages’
[18:01:58.920]   - Field: ‘gc’
[18:01:58.920]   - Field: ‘job’
[18:01:58.920]   - Field: ‘conditions’
[18:01:58.921]   - Field: ‘expr’
[18:01:58.921]   - Field: ‘uuid’
[18:01:58.921]   - Field: ‘seed’
[18:01:58.921]   - Field: ‘version’
[18:01:58.921]   - Field: ‘result’
[18:01:58.922]   - Field: ‘asynchronous’
[18:01:58.922]   - Field: ‘calls’
[18:01:58.922]   - Field: ‘globals’
[18:01:58.922]   - Field: ‘stdout’
[18:01:58.922]   - Field: ‘earlySignal’
[18:01:58.923]   - Field: ‘lazy’
[18:01:58.923]   - Field: ‘state’
[18:01:58.923] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:58.923] - Launch lazy future ...
[18:01:58.924] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:58.924] Packages needed by future strategies (n = 0): <none>
[18:01:58.925] {
[18:01:58.925]     {
[18:01:58.925]         {
[18:01:58.925]             ...future.startTime <- base::Sys.time()
[18:01:58.925]             {
[18:01:58.925]                 {
[18:01:58.925]                   {
[18:01:58.925]                     {
[18:01:58.925]                       {
[18:01:58.925]                         base::local({
[18:01:58.925]                           has_future <- base::requireNamespace("future", 
[18:01:58.925]                             quietly = TRUE)
[18:01:58.925]                           if (has_future) {
[18:01:58.925]                             ns <- base::getNamespace("future")
[18:01:58.925]                             version <- ns[[".package"]][["version"]]
[18:01:58.925]                             if (is.null(version)) 
[18:01:58.925]                               version <- utils::packageVersion("future")
[18:01:58.925]                           }
[18:01:58.925]                           else {
[18:01:58.925]                             version <- NULL
[18:01:58.925]                           }
[18:01:58.925]                           if (!has_future || version < "1.8.0") {
[18:01:58.925]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:58.925]                               "", base::R.version$version.string), 
[18:01:58.925]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:58.925]                                 base::R.version$platform, 8 * 
[18:01:58.925]                                   base::.Machine$sizeof.pointer), 
[18:01:58.925]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:58.925]                                 "release", "version")], collapse = " "), 
[18:01:58.925]                               hostname = base::Sys.info()[["nodename"]])
[18:01:58.925]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:58.925]                               info)
[18:01:58.925]                             info <- base::paste(info, collapse = "; ")
[18:01:58.925]                             if (!has_future) {
[18:01:58.925]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:58.925]                                 info)
[18:01:58.925]                             }
[18:01:58.925]                             else {
[18:01:58.925]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:58.925]                                 info, version)
[18:01:58.925]                             }
[18:01:58.925]                             base::stop(msg)
[18:01:58.925]                           }
[18:01:58.925]                         })
[18:01:58.925]                       }
[18:01:58.925]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:58.925]                       base::options(mc.cores = 1L)
[18:01:58.925]                     }
[18:01:58.925]                     base::local({
[18:01:58.925]                       for (pkg in "future.apply") {
[18:01:58.925]                         base::loadNamespace(pkg)
[18:01:58.925]                         base::library(pkg, character.only = TRUE)
[18:01:58.925]                       }
[18:01:58.925]                     })
[18:01:58.925]                   }
[18:01:58.925]                   ...future.strategy.old <- future::plan("list")
[18:01:58.925]                   options(future.plan = NULL)
[18:01:58.925]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:58.925]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:58.925]                 }
[18:01:58.925]                 ...future.workdir <- getwd()
[18:01:58.925]             }
[18:01:58.925]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:58.925]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:58.925]         }
[18:01:58.925]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:58.925]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:58.925]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:58.925]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:58.925]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:58.925]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:58.925]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:58.925]             base::names(...future.oldOptions))
[18:01:58.925]     }
[18:01:58.925]     if (FALSE) {
[18:01:58.925]     }
[18:01:58.925]     else {
[18:01:58.925]         if (TRUE) {
[18:01:58.925]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:58.925]                 open = "w")
[18:01:58.925]         }
[18:01:58.925]         else {
[18:01:58.925]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:58.925]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:58.925]         }
[18:01:58.925]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:58.925]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:58.925]             base::sink(type = "output", split = FALSE)
[18:01:58.925]             base::close(...future.stdout)
[18:01:58.925]         }, add = TRUE)
[18:01:58.925]     }
[18:01:58.925]     ...future.frame <- base::sys.nframe()
[18:01:58.925]     ...future.conditions <- base::list()
[18:01:58.925]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:58.925]     if (FALSE) {
[18:01:58.925]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:58.925]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:58.925]     }
[18:01:58.925]     ...future.result <- base::tryCatch({
[18:01:58.925]         base::withCallingHandlers({
[18:01:58.925]             ...future.value <- base::withVisible(base::local({
[18:01:58.925]                 withCallingHandlers({
[18:01:58.925]                   {
[18:01:58.925]                     do.call(function(...) {
[18:01:58.925]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.925]                       if (!identical(...future.globals.maxSize.org, 
[18:01:58.925]                         ...future.globals.maxSize)) {
[18:01:58.925]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.925]                         on.exit(options(oopts), add = TRUE)
[18:01:58.925]                       }
[18:01:58.925]                       {
[18:01:58.925]                         lapply(seq_along(...future.elements_ii), 
[18:01:58.925]                           FUN = function(jj) {
[18:01:58.925]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.925]                             ...future.FUN(...future.X_jj, ...)
[18:01:58.925]                           })
[18:01:58.925]                       }
[18:01:58.925]                     }, args = future.call.arguments)
[18:01:58.925]                   }
[18:01:58.925]                 }, immediateCondition = function(cond) {
[18:01:58.925]                   save_rds <- function (object, pathname, ...) 
[18:01:58.925]                   {
[18:01:58.925]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:58.925]                     if (file_test("-f", pathname_tmp)) {
[18:01:58.925]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.925]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:58.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.925]                         fi_tmp[["mtime"]])
[18:01:58.925]                     }
[18:01:58.925]                     tryCatch({
[18:01:58.925]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:58.925]                     }, error = function(ex) {
[18:01:58.925]                       msg <- conditionMessage(ex)
[18:01:58.925]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.925]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:58.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.925]                         fi_tmp[["mtime"]], msg)
[18:01:58.925]                       ex$message <- msg
[18:01:58.925]                       stop(ex)
[18:01:58.925]                     })
[18:01:58.925]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:58.925]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:58.925]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:58.925]                       fi_tmp <- file.info(pathname_tmp)
[18:01:58.925]                       fi <- file.info(pathname)
[18:01:58.925]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:58.925]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:58.925]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:58.925]                         fi[["size"]], fi[["mtime"]])
[18:01:58.925]                       stop(msg)
[18:01:58.925]                     }
[18:01:58.925]                     invisible(pathname)
[18:01:58.925]                   }
[18:01:58.925]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:58.925]                     rootPath = tempdir()) 
[18:01:58.925]                   {
[18:01:58.925]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:58.925]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:58.925]                       tmpdir = path, fileext = ".rds")
[18:01:58.925]                     save_rds(obj, file)
[18:01:58.925]                   }
[18:01:58.925]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:58.925]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.925]                   {
[18:01:58.925]                     inherits <- base::inherits
[18:01:58.925]                     invokeRestart <- base::invokeRestart
[18:01:58.925]                     is.null <- base::is.null
[18:01:58.925]                     muffled <- FALSE
[18:01:58.925]                     if (inherits(cond, "message")) {
[18:01:58.925]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:58.925]                       if (muffled) 
[18:01:58.925]                         invokeRestart("muffleMessage")
[18:01:58.925]                     }
[18:01:58.925]                     else if (inherits(cond, "warning")) {
[18:01:58.925]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:58.925]                       if (muffled) 
[18:01:58.925]                         invokeRestart("muffleWarning")
[18:01:58.925]                     }
[18:01:58.925]                     else if (inherits(cond, "condition")) {
[18:01:58.925]                       if (!is.null(pattern)) {
[18:01:58.925]                         computeRestarts <- base::computeRestarts
[18:01:58.925]                         grepl <- base::grepl
[18:01:58.925]                         restarts <- computeRestarts(cond)
[18:01:58.925]                         for (restart in restarts) {
[18:01:58.925]                           name <- restart$name
[18:01:58.925]                           if (is.null(name)) 
[18:01:58.925]                             next
[18:01:58.925]                           if (!grepl(pattern, name)) 
[18:01:58.925]                             next
[18:01:58.925]                           invokeRestart(restart)
[18:01:58.925]                           muffled <- TRUE
[18:01:58.925]                           break
[18:01:58.925]                         }
[18:01:58.925]                       }
[18:01:58.925]                     }
[18:01:58.925]                     invisible(muffled)
[18:01:58.925]                   }
[18:01:58.925]                   muffleCondition(cond)
[18:01:58.925]                 })
[18:01:58.925]             }))
[18:01:58.925]             future::FutureResult(value = ...future.value$value, 
[18:01:58.925]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:58.925]                   ...future.rng), globalenv = if (FALSE) 
[18:01:58.925]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:58.925]                     ...future.globalenv.names))
[18:01:58.925]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:58.925]         }, condition = base::local({
[18:01:58.925]             c <- base::c
[18:01:58.925]             inherits <- base::inherits
[18:01:58.925]             invokeRestart <- base::invokeRestart
[18:01:58.925]             length <- base::length
[18:01:58.925]             list <- base::list
[18:01:58.925]             seq.int <- base::seq.int
[18:01:58.925]             signalCondition <- base::signalCondition
[18:01:58.925]             sys.calls <- base::sys.calls
[18:01:58.925]             `[[` <- base::`[[`
[18:01:58.925]             `+` <- base::`+`
[18:01:58.925]             `<<-` <- base::`<<-`
[18:01:58.925]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:58.925]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:58.925]                   3L)]
[18:01:58.925]             }
[18:01:58.925]             function(cond) {
[18:01:58.925]                 is_error <- inherits(cond, "error")
[18:01:58.925]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:58.925]                   NULL)
[18:01:58.925]                 if (is_error) {
[18:01:58.925]                   sessionInformation <- function() {
[18:01:58.925]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:58.925]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:58.925]                       search = base::search(), system = base::Sys.info())
[18:01:58.925]                   }
[18:01:58.925]                   ...future.conditions[[length(...future.conditions) + 
[18:01:58.925]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:58.925]                     cond$call), session = sessionInformation(), 
[18:01:58.925]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:58.925]                   signalCondition(cond)
[18:01:58.925]                 }
[18:01:58.925]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:58.925]                 "immediateCondition"))) {
[18:01:58.925]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:58.925]                   ...future.conditions[[length(...future.conditions) + 
[18:01:58.925]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:58.925]                   if (TRUE && !signal) {
[18:01:58.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.925]                     {
[18:01:58.925]                       inherits <- base::inherits
[18:01:58.925]                       invokeRestart <- base::invokeRestart
[18:01:58.925]                       is.null <- base::is.null
[18:01:58.925]                       muffled <- FALSE
[18:01:58.925]                       if (inherits(cond, "message")) {
[18:01:58.925]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:58.925]                         if (muffled) 
[18:01:58.925]                           invokeRestart("muffleMessage")
[18:01:58.925]                       }
[18:01:58.925]                       else if (inherits(cond, "warning")) {
[18:01:58.925]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:58.925]                         if (muffled) 
[18:01:58.925]                           invokeRestart("muffleWarning")
[18:01:58.925]                       }
[18:01:58.925]                       else if (inherits(cond, "condition")) {
[18:01:58.925]                         if (!is.null(pattern)) {
[18:01:58.925]                           computeRestarts <- base::computeRestarts
[18:01:58.925]                           grepl <- base::grepl
[18:01:58.925]                           restarts <- computeRestarts(cond)
[18:01:58.925]                           for (restart in restarts) {
[18:01:58.925]                             name <- restart$name
[18:01:58.925]                             if (is.null(name)) 
[18:01:58.925]                               next
[18:01:58.925]                             if (!grepl(pattern, name)) 
[18:01:58.925]                               next
[18:01:58.925]                             invokeRestart(restart)
[18:01:58.925]                             muffled <- TRUE
[18:01:58.925]                             break
[18:01:58.925]                           }
[18:01:58.925]                         }
[18:01:58.925]                       }
[18:01:58.925]                       invisible(muffled)
[18:01:58.925]                     }
[18:01:58.925]                     muffleCondition(cond, pattern = "^muffle")
[18:01:58.925]                   }
[18:01:58.925]                 }
[18:01:58.925]                 else {
[18:01:58.925]                   if (TRUE) {
[18:01:58.925]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:58.925]                     {
[18:01:58.925]                       inherits <- base::inherits
[18:01:58.925]                       invokeRestart <- base::invokeRestart
[18:01:58.925]                       is.null <- base::is.null
[18:01:58.925]                       muffled <- FALSE
[18:01:58.925]                       if (inherits(cond, "message")) {
[18:01:58.925]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:58.925]                         if (muffled) 
[18:01:58.925]                           invokeRestart("muffleMessage")
[18:01:58.925]                       }
[18:01:58.925]                       else if (inherits(cond, "warning")) {
[18:01:58.925]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:58.925]                         if (muffled) 
[18:01:58.925]                           invokeRestart("muffleWarning")
[18:01:58.925]                       }
[18:01:58.925]                       else if (inherits(cond, "condition")) {
[18:01:58.925]                         if (!is.null(pattern)) {
[18:01:58.925]                           computeRestarts <- base::computeRestarts
[18:01:58.925]                           grepl <- base::grepl
[18:01:58.925]                           restarts <- computeRestarts(cond)
[18:01:58.925]                           for (restart in restarts) {
[18:01:58.925]                             name <- restart$name
[18:01:58.925]                             if (is.null(name)) 
[18:01:58.925]                               next
[18:01:58.925]                             if (!grepl(pattern, name)) 
[18:01:58.925]                               next
[18:01:58.925]                             invokeRestart(restart)
[18:01:58.925]                             muffled <- TRUE
[18:01:58.925]                             break
[18:01:58.925]                           }
[18:01:58.925]                         }
[18:01:58.925]                       }
[18:01:58.925]                       invisible(muffled)
[18:01:58.925]                     }
[18:01:58.925]                     muffleCondition(cond, pattern = "^muffle")
[18:01:58.925]                   }
[18:01:58.925]                 }
[18:01:58.925]             }
[18:01:58.925]         }))
[18:01:58.925]     }, error = function(ex) {
[18:01:58.925]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:58.925]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:58.925]                 ...future.rng), started = ...future.startTime, 
[18:01:58.925]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:58.925]             version = "1.8"), class = "FutureResult")
[18:01:58.925]     }, finally = {
[18:01:58.925]         if (!identical(...future.workdir, getwd())) 
[18:01:58.925]             setwd(...future.workdir)
[18:01:58.925]         {
[18:01:58.925]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:58.925]                 ...future.oldOptions$nwarnings <- NULL
[18:01:58.925]             }
[18:01:58.925]             base::options(...future.oldOptions)
[18:01:58.925]             if (.Platform$OS.type == "windows") {
[18:01:58.925]                 old_names <- names(...future.oldEnvVars)
[18:01:58.925]                 envs <- base::Sys.getenv()
[18:01:58.925]                 names <- names(envs)
[18:01:58.925]                 common <- intersect(names, old_names)
[18:01:58.925]                 added <- setdiff(names, old_names)
[18:01:58.925]                 removed <- setdiff(old_names, names)
[18:01:58.925]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:58.925]                   envs[common]]
[18:01:58.925]                 NAMES <- toupper(changed)
[18:01:58.925]                 args <- list()
[18:01:58.925]                 for (kk in seq_along(NAMES)) {
[18:01:58.925]                   name <- changed[[kk]]
[18:01:58.925]                   NAME <- NAMES[[kk]]
[18:01:58.925]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.925]                     next
[18:01:58.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:58.925]                 }
[18:01:58.925]                 NAMES <- toupper(added)
[18:01:58.925]                 for (kk in seq_along(NAMES)) {
[18:01:58.925]                   name <- added[[kk]]
[18:01:58.925]                   NAME <- NAMES[[kk]]
[18:01:58.925]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.925]                     next
[18:01:58.925]                   args[[name]] <- ""
[18:01:58.925]                 }
[18:01:58.925]                 NAMES <- toupper(removed)
[18:01:58.925]                 for (kk in seq_along(NAMES)) {
[18:01:58.925]                   name <- removed[[kk]]
[18:01:58.925]                   NAME <- NAMES[[kk]]
[18:01:58.925]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:58.925]                     next
[18:01:58.925]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:58.925]                 }
[18:01:58.925]                 if (length(args) > 0) 
[18:01:58.925]                   base::do.call(base::Sys.setenv, args = args)
[18:01:58.925]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:58.925]             }
[18:01:58.925]             else {
[18:01:58.925]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:58.925]             }
[18:01:58.925]             {
[18:01:58.925]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:58.925]                   0L) {
[18:01:58.925]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:58.925]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:58.925]                   base::options(opts)
[18:01:58.925]                 }
[18:01:58.925]                 {
[18:01:58.925]                   {
[18:01:58.925]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:58.925]                     NULL
[18:01:58.925]                   }
[18:01:58.925]                   options(future.plan = NULL)
[18:01:58.925]                   if (is.na(NA_character_)) 
[18:01:58.925]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:58.925]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:58.925]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:58.925]                     .init = FALSE)
[18:01:58.925]                 }
[18:01:58.925]             }
[18:01:58.925]         }
[18:01:58.925]     })
[18:01:58.925]     if (TRUE) {
[18:01:58.925]         base::sink(type = "output", split = FALSE)
[18:01:58.925]         if (TRUE) {
[18:01:58.925]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:58.925]         }
[18:01:58.925]         else {
[18:01:58.925]             ...future.result["stdout"] <- base::list(NULL)
[18:01:58.925]         }
[18:01:58.925]         base::close(...future.stdout)
[18:01:58.925]         ...future.stdout <- NULL
[18:01:58.925]     }
[18:01:58.925]     ...future.result$conditions <- ...future.conditions
[18:01:58.925]     ...future.result$finished <- base::Sys.time()
[18:01:58.925]     ...future.result
[18:01:58.925] }
[18:01:58.930] assign_globals() ...
[18:01:58.930] List of 11
[18:01:58.930]  $ ...future.FUN            :function (x, ...)  
[18:01:58.930]  $ x_FUN                    :function (x)  
[18:01:58.930]  $ times                    : int 4
[18:01:58.930]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:58.930]  $ stop_if_not              :function (...)  
[18:01:58.930]  $ dim                      : int [1:2] 2 2
[18:01:58.930]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:58.930]  $ future.call.arguments    : list()
[18:01:58.930]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:58.930]  $ ...future.elements_ii    :List of 5
[18:01:58.930]   ..$ : int 1
[18:01:58.930]   ..$ : int 2
[18:01:58.930]   ..$ : int 3
[18:01:58.930]   ..$ : int 4
[18:01:58.930]   ..$ : int 5
[18:01:58.930]  $ ...future.seeds_ii       : NULL
[18:01:58.930]  $ ...future.globals.maxSize: NULL
[18:01:58.930]  - attr(*, "where")=List of 11
[18:01:58.930]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:58.930]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:58.930]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:58.930]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:58.930]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:58.930]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:58.930]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:58.930]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:58.930]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:58.930]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:58.930]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:58.930]  - attr(*, "resolved")= logi FALSE
[18:01:58.930]  - attr(*, "total_size")= num 105552
[18:01:58.930]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:58.930]  - attr(*, "already-done")= logi TRUE
[18:01:58.951] - copied ‘...future.FUN’ to environment
[18:01:58.951] - reassign environment for ‘x_FUN’
[18:01:58.951] - copied ‘x_FUN’ to environment
[18:01:58.951] - copied ‘times’ to environment
[18:01:58.952] - copied ‘stopf’ to environment
[18:01:58.952] - copied ‘stop_if_not’ to environment
[18:01:58.952] - copied ‘dim’ to environment
[18:01:58.952] - copied ‘valid_types’ to environment
[18:01:58.952] - copied ‘future.call.arguments’ to environment
[18:01:58.953] - copied ‘...future.elements_ii’ to environment
[18:01:58.953] - copied ‘...future.seeds_ii’ to environment
[18:01:58.953] - copied ‘...future.globals.maxSize’ to environment
[18:01:58.953] assign_globals() ... done
[18:01:58.954] requestCore(): workers = 2
[18:01:58.958] MulticoreFuture started
[18:01:58.959] - Launch lazy future ... done
[18:01:58.959] run() for ‘MulticoreFuture’ ... done
[18:01:58.960] Created future:
[18:01:58.960] plan(): Setting new future strategy stack:
[18:01:58.961] List of future strategies:
[18:01:58.961] 1. sequential:
[18:01:58.961]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:58.961]    - tweaked: FALSE
[18:01:58.961]    - call: NULL
[18:01:58.964] plan(): nbrOfWorkers() = 1
[18:01:58.969] plan(): Setting new future strategy stack:
[18:01:58.970] List of future strategies:
[18:01:58.970] 1. multicore:
[18:01:58.970]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:58.970]    - tweaked: FALSE
[18:01:58.970]    - call: plan(strategy)
[18:01:58.961] MulticoreFuture:
[18:01:58.961] Label: ‘future_vapply-1’
[18:01:58.961] Expression:
[18:01:58.961] {
[18:01:58.961]     do.call(function(...) {
[18:01:58.961]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.961]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.961]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.961]             on.exit(options(oopts), add = TRUE)
[18:01:58.961]         }
[18:01:58.961]         {
[18:01:58.961]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.961]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.961]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.961]             })
[18:01:58.961]         }
[18:01:58.961]     }, args = future.call.arguments)
[18:01:58.961] }
[18:01:58.961] Lazy evaluation: FALSE
[18:01:58.961] Asynchronous evaluation: TRUE
[18:01:58.961] Local evaluation: TRUE
[18:01:58.961] Environment: R_GlobalEnv
[18:01:58.961] Capture standard output: TRUE
[18:01:58.961] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:58.961] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:58.961] Packages: 1 packages (‘future.apply’)
[18:01:58.961] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:58.961] Resolved: FALSE
[18:01:58.961] Value: <not collected>
[18:01:58.961] Conditions captured: <none>
[18:01:58.961] Early signaling: FALSE
[18:01:58.961] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:58.961] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.978] Chunk #1 of 2 ... DONE
[18:01:58.978] Chunk #2 of 2 ...
[18:01:58.978]  - Finding globals in 'X' for chunk #2 ...
[18:01:58.979] getGlobalsAndPackages() ...
[18:01:58.980] Searching for globals...
[18:01:58.980] plan(): nbrOfWorkers() = 2
[18:01:58.981] 
[18:01:58.981] Searching for globals ... DONE
[18:01:58.981] - globals: [0] <none>
[18:01:58.981] getGlobalsAndPackages() ... DONE
[18:01:58.982]    + additional globals found: [n=0] 
[18:01:58.982]    + additional namespaces needed: [n=0] 
[18:01:58.982]  - Finding globals in 'X' for chunk #2 ... DONE
[18:01:58.983]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:58.983]  - seeds: <none>
[18:01:58.983]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.984] getGlobalsAndPackages() ...
[18:01:58.984] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.984] Resolving globals: FALSE
[18:01:58.985] Tweak future expression to call with '...' arguments ...
[18:01:58.985] {
[18:01:58.985]     do.call(function(...) {
[18:01:58.985]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:58.985]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:58.985]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:58.985]             on.exit(options(oopts), add = TRUE)
[18:01:58.985]         }
[18:01:58.985]         {
[18:01:58.985]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:58.985]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:58.985]                 ...future.FUN(...future.X_jj, ...)
[18:01:58.985]             })
[18:01:58.985]         }
[18:01:58.985]     }, args = future.call.arguments)
[18:01:58.985] }
[18:01:58.986] Tweak future expression to call with '...' arguments ... DONE
[18:01:58.988] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:58.988] - packages: [1] ‘future.apply’
[18:01:58.989] getGlobalsAndPackages() ... DONE
[18:01:58.990] run() for ‘Future’ ...
[18:01:58.990] - state: ‘created’
[18:01:58.990] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:58.998] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:58.999] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:58.999]   - Field: ‘label’
[18:01:58.999]   - Field: ‘local’
[18:01:59.000]   - Field: ‘owner’
[18:01:59.000]   - Field: ‘envir’
[18:01:59.000]   - Field: ‘workers’
[18:01:59.001]   - Field: ‘packages’
[18:01:59.001]   - Field: ‘gc’
[18:01:59.001]   - Field: ‘job’
[18:01:59.002]   - Field: ‘conditions’
[18:01:59.002]   - Field: ‘expr’
[18:01:59.002]   - Field: ‘uuid’
[18:01:59.002]   - Field: ‘seed’
[18:01:59.003]   - Field: ‘version’
[18:01:59.003]   - Field: ‘result’
[18:01:59.003]   - Field: ‘asynchronous’
[18:01:59.004]   - Field: ‘calls’
[18:01:59.004]   - Field: ‘globals’
[18:01:59.004]   - Field: ‘stdout’
[18:01:59.005]   - Field: ‘earlySignal’
[18:01:59.005]   - Field: ‘lazy’
[18:01:59.005]   - Field: ‘state’
[18:01:59.006] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:59.006] - Launch lazy future ...
[18:01:59.007] Packages needed by the future expression (n = 1): ‘future.apply’
[18:01:59.007] Packages needed by future strategies (n = 0): <none>
[18:01:59.009] {
[18:01:59.009]     {
[18:01:59.009]         {
[18:01:59.009]             ...future.startTime <- base::Sys.time()
[18:01:59.009]             {
[18:01:59.009]                 {
[18:01:59.009]                   {
[18:01:59.009]                     {
[18:01:59.009]                       {
[18:01:59.009]                         base::local({
[18:01:59.009]                           has_future <- base::requireNamespace("future", 
[18:01:59.009]                             quietly = TRUE)
[18:01:59.009]                           if (has_future) {
[18:01:59.009]                             ns <- base::getNamespace("future")
[18:01:59.009]                             version <- ns[[".package"]][["version"]]
[18:01:59.009]                             if (is.null(version)) 
[18:01:59.009]                               version <- utils::packageVersion("future")
[18:01:59.009]                           }
[18:01:59.009]                           else {
[18:01:59.009]                             version <- NULL
[18:01:59.009]                           }
[18:01:59.009]                           if (!has_future || version < "1.8.0") {
[18:01:59.009]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:59.009]                               "", base::R.version$version.string), 
[18:01:59.009]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:59.009]                                 base::R.version$platform, 8 * 
[18:01:59.009]                                   base::.Machine$sizeof.pointer), 
[18:01:59.009]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:59.009]                                 "release", "version")], collapse = " "), 
[18:01:59.009]                               hostname = base::Sys.info()[["nodename"]])
[18:01:59.009]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:59.009]                               info)
[18:01:59.009]                             info <- base::paste(info, collapse = "; ")
[18:01:59.009]                             if (!has_future) {
[18:01:59.009]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:59.009]                                 info)
[18:01:59.009]                             }
[18:01:59.009]                             else {
[18:01:59.009]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:59.009]                                 info, version)
[18:01:59.009]                             }
[18:01:59.009]                             base::stop(msg)
[18:01:59.009]                           }
[18:01:59.009]                         })
[18:01:59.009]                       }
[18:01:59.009]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:59.009]                       base::options(mc.cores = 1L)
[18:01:59.009]                     }
[18:01:59.009]                     base::local({
[18:01:59.009]                       for (pkg in "future.apply") {
[18:01:59.009]                         base::loadNamespace(pkg)
[18:01:59.009]                         base::library(pkg, character.only = TRUE)
[18:01:59.009]                       }
[18:01:59.009]                     })
[18:01:59.009]                   }
[18:01:59.009]                   ...future.strategy.old <- future::plan("list")
[18:01:59.009]                   options(future.plan = NULL)
[18:01:59.009]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.009]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:59.009]                 }
[18:01:59.009]                 ...future.workdir <- getwd()
[18:01:59.009]             }
[18:01:59.009]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:59.009]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:59.009]         }
[18:01:59.009]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:59.009]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:59.009]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:59.009]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:59.009]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:59.009]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:59.009]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:59.009]             base::names(...future.oldOptions))
[18:01:59.009]     }
[18:01:59.009]     if (FALSE) {
[18:01:59.009]     }
[18:01:59.009]     else {
[18:01:59.009]         if (TRUE) {
[18:01:59.009]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:59.009]                 open = "w")
[18:01:59.009]         }
[18:01:59.009]         else {
[18:01:59.009]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:59.009]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:59.009]         }
[18:01:59.009]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:59.009]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:59.009]             base::sink(type = "output", split = FALSE)
[18:01:59.009]             base::close(...future.stdout)
[18:01:59.009]         }, add = TRUE)
[18:01:59.009]     }
[18:01:59.009]     ...future.frame <- base::sys.nframe()
[18:01:59.009]     ...future.conditions <- base::list()
[18:01:59.009]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:59.009]     if (FALSE) {
[18:01:59.009]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:59.009]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:59.009]     }
[18:01:59.009]     ...future.result <- base::tryCatch({
[18:01:59.009]         base::withCallingHandlers({
[18:01:59.009]             ...future.value <- base::withVisible(base::local({
[18:01:59.009]                 withCallingHandlers({
[18:01:59.009]                   {
[18:01:59.009]                     do.call(function(...) {
[18:01:59.009]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.009]                       if (!identical(...future.globals.maxSize.org, 
[18:01:59.009]                         ...future.globals.maxSize)) {
[18:01:59.009]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.009]                         on.exit(options(oopts), add = TRUE)
[18:01:59.009]                       }
[18:01:59.009]                       {
[18:01:59.009]                         lapply(seq_along(...future.elements_ii), 
[18:01:59.009]                           FUN = function(jj) {
[18:01:59.009]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.009]                             ...future.FUN(...future.X_jj, ...)
[18:01:59.009]                           })
[18:01:59.009]                       }
[18:01:59.009]                     }, args = future.call.arguments)
[18:01:59.009]                   }
[18:01:59.009]                 }, immediateCondition = function(cond) {
[18:01:59.009]                   save_rds <- function (object, pathname, ...) 
[18:01:59.009]                   {
[18:01:59.009]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:59.009]                     if (file_test("-f", pathname_tmp)) {
[18:01:59.009]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.009]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:59.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.009]                         fi_tmp[["mtime"]])
[18:01:59.009]                     }
[18:01:59.009]                     tryCatch({
[18:01:59.009]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:59.009]                     }, error = function(ex) {
[18:01:59.009]                       msg <- conditionMessage(ex)
[18:01:59.009]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.009]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:59.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.009]                         fi_tmp[["mtime"]], msg)
[18:01:59.009]                       ex$message <- msg
[18:01:59.009]                       stop(ex)
[18:01:59.009]                     })
[18:01:59.009]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:59.009]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:59.009]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:59.009]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.009]                       fi <- file.info(pathname)
[18:01:59.009]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:59.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.009]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:59.009]                         fi[["size"]], fi[["mtime"]])
[18:01:59.009]                       stop(msg)
[18:01:59.009]                     }
[18:01:59.009]                     invisible(pathname)
[18:01:59.009]                   }
[18:01:59.009]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:59.009]                     rootPath = tempdir()) 
[18:01:59.009]                   {
[18:01:59.009]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:59.009]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:59.009]                       tmpdir = path, fileext = ".rds")
[18:01:59.009]                     save_rds(obj, file)
[18:01:59.009]                   }
[18:01:59.009]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:59.009]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.009]                   {
[18:01:59.009]                     inherits <- base::inherits
[18:01:59.009]                     invokeRestart <- base::invokeRestart
[18:01:59.009]                     is.null <- base::is.null
[18:01:59.009]                     muffled <- FALSE
[18:01:59.009]                     if (inherits(cond, "message")) {
[18:01:59.009]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:59.009]                       if (muffled) 
[18:01:59.009]                         invokeRestart("muffleMessage")
[18:01:59.009]                     }
[18:01:59.009]                     else if (inherits(cond, "warning")) {
[18:01:59.009]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:59.009]                       if (muffled) 
[18:01:59.009]                         invokeRestart("muffleWarning")
[18:01:59.009]                     }
[18:01:59.009]                     else if (inherits(cond, "condition")) {
[18:01:59.009]                       if (!is.null(pattern)) {
[18:01:59.009]                         computeRestarts <- base::computeRestarts
[18:01:59.009]                         grepl <- base::grepl
[18:01:59.009]                         restarts <- computeRestarts(cond)
[18:01:59.009]                         for (restart in restarts) {
[18:01:59.009]                           name <- restart$name
[18:01:59.009]                           if (is.null(name)) 
[18:01:59.009]                             next
[18:01:59.009]                           if (!grepl(pattern, name)) 
[18:01:59.009]                             next
[18:01:59.009]                           invokeRestart(restart)
[18:01:59.009]                           muffled <- TRUE
[18:01:59.009]                           break
[18:01:59.009]                         }
[18:01:59.009]                       }
[18:01:59.009]                     }
[18:01:59.009]                     invisible(muffled)
[18:01:59.009]                   }
[18:01:59.009]                   muffleCondition(cond)
[18:01:59.009]                 })
[18:01:59.009]             }))
[18:01:59.009]             future::FutureResult(value = ...future.value$value, 
[18:01:59.009]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.009]                   ...future.rng), globalenv = if (FALSE) 
[18:01:59.009]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:59.009]                     ...future.globalenv.names))
[18:01:59.009]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:59.009]         }, condition = base::local({
[18:01:59.009]             c <- base::c
[18:01:59.009]             inherits <- base::inherits
[18:01:59.009]             invokeRestart <- base::invokeRestart
[18:01:59.009]             length <- base::length
[18:01:59.009]             list <- base::list
[18:01:59.009]             seq.int <- base::seq.int
[18:01:59.009]             signalCondition <- base::signalCondition
[18:01:59.009]             sys.calls <- base::sys.calls
[18:01:59.009]             `[[` <- base::`[[`
[18:01:59.009]             `+` <- base::`+`
[18:01:59.009]             `<<-` <- base::`<<-`
[18:01:59.009]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:59.009]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:59.009]                   3L)]
[18:01:59.009]             }
[18:01:59.009]             function(cond) {
[18:01:59.009]                 is_error <- inherits(cond, "error")
[18:01:59.009]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:59.009]                   NULL)
[18:01:59.009]                 if (is_error) {
[18:01:59.009]                   sessionInformation <- function() {
[18:01:59.009]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:59.009]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:59.009]                       search = base::search(), system = base::Sys.info())
[18:01:59.009]                   }
[18:01:59.009]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.009]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:59.009]                     cond$call), session = sessionInformation(), 
[18:01:59.009]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:59.009]                   signalCondition(cond)
[18:01:59.009]                 }
[18:01:59.009]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:59.009]                 "immediateCondition"))) {
[18:01:59.009]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:59.009]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.009]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:59.009]                   if (TRUE && !signal) {
[18:01:59.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.009]                     {
[18:01:59.009]                       inherits <- base::inherits
[18:01:59.009]                       invokeRestart <- base::invokeRestart
[18:01:59.009]                       is.null <- base::is.null
[18:01:59.009]                       muffled <- FALSE
[18:01:59.009]                       if (inherits(cond, "message")) {
[18:01:59.009]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.009]                         if (muffled) 
[18:01:59.009]                           invokeRestart("muffleMessage")
[18:01:59.009]                       }
[18:01:59.009]                       else if (inherits(cond, "warning")) {
[18:01:59.009]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.009]                         if (muffled) 
[18:01:59.009]                           invokeRestart("muffleWarning")
[18:01:59.009]                       }
[18:01:59.009]                       else if (inherits(cond, "condition")) {
[18:01:59.009]                         if (!is.null(pattern)) {
[18:01:59.009]                           computeRestarts <- base::computeRestarts
[18:01:59.009]                           grepl <- base::grepl
[18:01:59.009]                           restarts <- computeRestarts(cond)
[18:01:59.009]                           for (restart in restarts) {
[18:01:59.009]                             name <- restart$name
[18:01:59.009]                             if (is.null(name)) 
[18:01:59.009]                               next
[18:01:59.009]                             if (!grepl(pattern, name)) 
[18:01:59.009]                               next
[18:01:59.009]                             invokeRestart(restart)
[18:01:59.009]                             muffled <- TRUE
[18:01:59.009]                             break
[18:01:59.009]                           }
[18:01:59.009]                         }
[18:01:59.009]                       }
[18:01:59.009]                       invisible(muffled)
[18:01:59.009]                     }
[18:01:59.009]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.009]                   }
[18:01:59.009]                 }
[18:01:59.009]                 else {
[18:01:59.009]                   if (TRUE) {
[18:01:59.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.009]                     {
[18:01:59.009]                       inherits <- base::inherits
[18:01:59.009]                       invokeRestart <- base::invokeRestart
[18:01:59.009]                       is.null <- base::is.null
[18:01:59.009]                       muffled <- FALSE
[18:01:59.009]                       if (inherits(cond, "message")) {
[18:01:59.009]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.009]                         if (muffled) 
[18:01:59.009]                           invokeRestart("muffleMessage")
[18:01:59.009]                       }
[18:01:59.009]                       else if (inherits(cond, "warning")) {
[18:01:59.009]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.009]                         if (muffled) 
[18:01:59.009]                           invokeRestart("muffleWarning")
[18:01:59.009]                       }
[18:01:59.009]                       else if (inherits(cond, "condition")) {
[18:01:59.009]                         if (!is.null(pattern)) {
[18:01:59.009]                           computeRestarts <- base::computeRestarts
[18:01:59.009]                           grepl <- base::grepl
[18:01:59.009]                           restarts <- computeRestarts(cond)
[18:01:59.009]                           for (restart in restarts) {
[18:01:59.009]                             name <- restart$name
[18:01:59.009]                             if (is.null(name)) 
[18:01:59.009]                               next
[18:01:59.009]                             if (!grepl(pattern, name)) 
[18:01:59.009]                               next
[18:01:59.009]                             invokeRestart(restart)
[18:01:59.009]                             muffled <- TRUE
[18:01:59.009]                             break
[18:01:59.009]                           }
[18:01:59.009]                         }
[18:01:59.009]                       }
[18:01:59.009]                       invisible(muffled)
[18:01:59.009]                     }
[18:01:59.009]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.009]                   }
[18:01:59.009]                 }
[18:01:59.009]             }
[18:01:59.009]         }))
[18:01:59.009]     }, error = function(ex) {
[18:01:59.009]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:59.009]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.009]                 ...future.rng), started = ...future.startTime, 
[18:01:59.009]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:59.009]             version = "1.8"), class = "FutureResult")
[18:01:59.009]     }, finally = {
[18:01:59.009]         if (!identical(...future.workdir, getwd())) 
[18:01:59.009]             setwd(...future.workdir)
[18:01:59.009]         {
[18:01:59.009]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:59.009]                 ...future.oldOptions$nwarnings <- NULL
[18:01:59.009]             }
[18:01:59.009]             base::options(...future.oldOptions)
[18:01:59.009]             if (.Platform$OS.type == "windows") {
[18:01:59.009]                 old_names <- names(...future.oldEnvVars)
[18:01:59.009]                 envs <- base::Sys.getenv()
[18:01:59.009]                 names <- names(envs)
[18:01:59.009]                 common <- intersect(names, old_names)
[18:01:59.009]                 added <- setdiff(names, old_names)
[18:01:59.009]                 removed <- setdiff(old_names, names)
[18:01:59.009]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:59.009]                   envs[common]]
[18:01:59.009]                 NAMES <- toupper(changed)
[18:01:59.009]                 args <- list()
[18:01:59.009]                 for (kk in seq_along(NAMES)) {
[18:01:59.009]                   name <- changed[[kk]]
[18:01:59.009]                   NAME <- NAMES[[kk]]
[18:01:59.009]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.009]                     next
[18:01:59.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.009]                 }
[18:01:59.009]                 NAMES <- toupper(added)
[18:01:59.009]                 for (kk in seq_along(NAMES)) {
[18:01:59.009]                   name <- added[[kk]]
[18:01:59.009]                   NAME <- NAMES[[kk]]
[18:01:59.009]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.009]                     next
[18:01:59.009]                   args[[name]] <- ""
[18:01:59.009]                 }
[18:01:59.009]                 NAMES <- toupper(removed)
[18:01:59.009]                 for (kk in seq_along(NAMES)) {
[18:01:59.009]                   name <- removed[[kk]]
[18:01:59.009]                   NAME <- NAMES[[kk]]
[18:01:59.009]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.009]                     next
[18:01:59.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.009]                 }
[18:01:59.009]                 if (length(args) > 0) 
[18:01:59.009]                   base::do.call(base::Sys.setenv, args = args)
[18:01:59.009]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:59.009]             }
[18:01:59.009]             else {
[18:01:59.009]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:59.009]             }
[18:01:59.009]             {
[18:01:59.009]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:59.009]                   0L) {
[18:01:59.009]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:59.009]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:59.009]                   base::options(opts)
[18:01:59.009]                 }
[18:01:59.009]                 {
[18:01:59.009]                   {
[18:01:59.009]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:59.009]                     NULL
[18:01:59.009]                   }
[18:01:59.009]                   options(future.plan = NULL)
[18:01:59.009]                   if (is.na(NA_character_)) 
[18:01:59.009]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.009]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:59.009]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:59.009]                     .init = FALSE)
[18:01:59.009]                 }
[18:01:59.009]             }
[18:01:59.009]         }
[18:01:59.009]     })
[18:01:59.009]     if (TRUE) {
[18:01:59.009]         base::sink(type = "output", split = FALSE)
[18:01:59.009]         if (TRUE) {
[18:01:59.009]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:59.009]         }
[18:01:59.009]         else {
[18:01:59.009]             ...future.result["stdout"] <- base::list(NULL)
[18:01:59.009]         }
[18:01:59.009]         base::close(...future.stdout)
[18:01:59.009]         ...future.stdout <- NULL
[18:01:59.009]     }
[18:01:59.009]     ...future.result$conditions <- ...future.conditions
[18:01:59.009]     ...future.result$finished <- base::Sys.time()
[18:01:59.009]     ...future.result
[18:01:59.009] }
[18:01:59.016] assign_globals() ...
[18:01:59.016] List of 11
[18:01:59.016]  $ ...future.FUN            :function (x, ...)  
[18:01:59.016]  $ x_FUN                    :function (x)  
[18:01:59.016]  $ times                    : int 4
[18:01:59.016]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:59.016]  $ stop_if_not              :function (...)  
[18:01:59.016]  $ dim                      : int [1:2] 2 2
[18:01:59.016]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:59.016]  $ future.call.arguments    : list()
[18:01:59.016]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.016]  $ ...future.elements_ii    :List of 5
[18:01:59.016]   ..$ : int 6
[18:01:59.016]   ..$ : int 7
[18:01:59.016]   ..$ : int 8
[18:01:59.016]   ..$ : int 9
[18:01:59.016]   ..$ : int 10
[18:01:59.016]  $ ...future.seeds_ii       : NULL
[18:01:59.016]  $ ...future.globals.maxSize: NULL
[18:01:59.016]  - attr(*, "where")=List of 11
[18:01:59.016]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:59.016]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:59.016]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:59.016]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:59.016]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:59.016]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:59.016]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:59.016]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:59.016]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:59.016]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:59.016]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:59.016]  - attr(*, "resolved")= logi FALSE
[18:01:59.016]  - attr(*, "total_size")= num 105552
[18:01:59.016]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.016]  - attr(*, "already-done")= logi TRUE
[18:01:59.050] - copied ‘...future.FUN’ to environment
[18:01:59.050] - reassign environment for ‘x_FUN’
[18:01:59.050] - copied ‘x_FUN’ to environment
[18:01:59.050] - copied ‘times’ to environment
[18:01:59.051] - copied ‘stopf’ to environment
[18:01:59.051] - copied ‘stop_if_not’ to environment
[18:01:59.051] - copied ‘dim’ to environment
[18:01:59.052] - copied ‘valid_types’ to environment
[18:01:59.052] - copied ‘future.call.arguments’ to environment
[18:01:59.052] - copied ‘...future.elements_ii’ to environment
[18:01:59.052] - copied ‘...future.seeds_ii’ to environment
[18:01:59.053] - copied ‘...future.globals.maxSize’ to environment
[18:01:59.053] assign_globals() ... done
[18:01:59.053] requestCore(): workers = 2
[18:01:59.057] MulticoreFuture started
[18:01:59.058] - Launch lazy future ... done
[18:01:59.059] run() for ‘MulticoreFuture’ ... done
[18:01:59.060] Created future:
[18:01:59.060] plan(): Setting new future strategy stack:
[18:01:59.061] List of future strategies:
[18:01:59.061] 1. sequential:
[18:01:59.061]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:59.061]    - tweaked: FALSE
[18:01:59.061]    - call: NULL
[18:01:59.064] plan(): nbrOfWorkers() = 1
[18:01:59.070] plan(): Setting new future strategy stack:
[18:01:59.070] List of future strategies:
[18:01:59.070] 1. multicore:
[18:01:59.070]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:59.070]    - tweaked: FALSE
[18:01:59.070]    - call: plan(strategy)
[18:01:59.080] plan(): nbrOfWorkers() = 2
[18:01:59.063] MulticoreFuture:
[18:01:59.063] Label: ‘future_vapply-2’
[18:01:59.063] Expression:
[18:01:59.063] {
[18:01:59.063]     do.call(function(...) {
[18:01:59.063]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.063]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.063]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.063]             on.exit(options(oopts), add = TRUE)
[18:01:59.063]         }
[18:01:59.063]         {
[18:01:59.063]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.063]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.063]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.063]             })
[18:01:59.063]         }
[18:01:59.063]     }, args = future.call.arguments)
[18:01:59.063] }
[18:01:59.063] Lazy evaluation: FALSE
[18:01:59.063] Asynchronous evaluation: TRUE
[18:01:59.063] Local evaluation: TRUE
[18:01:59.063] Environment: R_GlobalEnv
[18:01:59.063] Capture standard output: TRUE
[18:01:59.063] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:59.063] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:59.063] Packages: 1 packages (‘future.apply’)
[18:01:59.063] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:59.063] Resolved: TRUE
[18:01:59.063] Value: <not collected>
[18:01:59.063] Conditions captured: <none>
[18:01:59.063] Early signaling: FALSE
[18:01:59.063] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:59.063] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:59.082] Chunk #2 of 2 ... DONE
[18:01:59.083] Launching 2 futures (chunks) ... DONE
[18:01:59.083] Resolving 2 futures (chunks) ...
[18:01:59.083] resolve() on list ...
[18:01:59.084]  recursive: 0
[18:01:59.084]  length: 2
[18:01:59.084] 
[18:01:59.085] Future #1
[18:01:59.085] result() for MulticoreFuture ...
[18:01:59.090] result() for MulticoreFuture ...
[18:01:59.090] result() for MulticoreFuture ... done
[18:01:59.090] result() for MulticoreFuture ... done
[18:01:59.091] result() for MulticoreFuture ...
[18:01:59.091] result() for MulticoreFuture ... done
[18:01:59.091] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:59.092] - nx: 2
[18:01:59.092] - relay: TRUE
[18:01:59.094] - stdout: TRUE
[18:01:59.095] - signal: TRUE
[18:01:59.095] - resignal: FALSE
[18:01:59.095] - force: TRUE
[18:01:59.096] - relayed: [n=2] FALSE, FALSE
[18:01:59.096] - queued futures: [n=2] FALSE, FALSE
[18:01:59.096]  - until=1
[18:01:59.097]  - relaying element #1
[18:01:59.097] result() for MulticoreFuture ...
[18:01:59.097] result() for MulticoreFuture ... done
[18:01:59.098] result() for MulticoreFuture ...
[18:01:59.098] result() for MulticoreFuture ... done
[18:01:59.098] result() for MulticoreFuture ...
[18:01:59.099] result() for MulticoreFuture ... done
[18:01:59.099] result() for MulticoreFuture ...
[18:01:59.099] result() for MulticoreFuture ... done
[18:01:59.100] - relayed: [n=2] TRUE, FALSE
[18:01:59.100] - queued futures: [n=2] TRUE, FALSE
[18:01:59.100] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:59.101]  length: 1 (resolved future 1)
[18:01:59.101] Future #2
[18:01:59.102] result() for MulticoreFuture ...
[18:01:59.103] result() for MulticoreFuture ...
[18:01:59.103] result() for MulticoreFuture ... done
[18:01:59.104] result() for MulticoreFuture ... done
[18:01:59.104] result() for MulticoreFuture ...
[18:01:59.104] result() for MulticoreFuture ... done
[18:01:59.105] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:59.105] - nx: 2
[18:01:59.105] - relay: TRUE
[18:01:59.105] - stdout: TRUE
[18:01:59.106] - signal: TRUE
[18:01:59.106] - resignal: FALSE
[18:01:59.106] - force: TRUE
[18:01:59.106] - relayed: [n=2] TRUE, FALSE
[18:01:59.107] - queued futures: [n=2] TRUE, FALSE
[18:01:59.107]  - until=2
[18:01:59.107]  - relaying element #2
[18:01:59.107] result() for MulticoreFuture ...
[18:01:59.107] result() for MulticoreFuture ... done
[18:01:59.108] result() for MulticoreFuture ...
[18:01:59.108] result() for MulticoreFuture ... done
[18:01:59.108] result() for MulticoreFuture ...
[18:01:59.109] result() for MulticoreFuture ... done
[18:01:59.109] result() for MulticoreFuture ...
[18:01:59.109] result() for MulticoreFuture ... done
[18:01:59.109] - relayed: [n=2] TRUE, TRUE
[18:01:59.109] - queued futures: [n=2] TRUE, TRUE
[18:01:59.110] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:59.110]  length: 0 (resolved future 2)
[18:01:59.110] Relaying remaining futures
[18:01:59.110] signalConditionsASAP(NULL, pos=0) ...
[18:01:59.111] - nx: 2
[18:01:59.111] - relay: TRUE
[18:01:59.111] - stdout: TRUE
[18:01:59.111] - signal: TRUE
[18:01:59.111] - resignal: FALSE
[18:01:59.112] - force: TRUE
[18:01:59.112] - relayed: [n=2] TRUE, TRUE
[18:01:59.112] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:59.112] - relayed: [n=2] TRUE, TRUE
[18:01:59.113] - queued futures: [n=2] TRUE, TRUE
[18:01:59.113] signalConditionsASAP(NULL, pos=0) ... done
[18:01:59.113] resolve() on list ... DONE
[18:01:59.113] result() for MulticoreFuture ...
[18:01:59.114] result() for MulticoreFuture ... done
[18:01:59.114] result() for MulticoreFuture ...
[18:01:59.114] result() for MulticoreFuture ... done
[18:01:59.114] result() for MulticoreFuture ...
[18:01:59.114] result() for MulticoreFuture ... done
[18:01:59.115] result() for MulticoreFuture ...
[18:01:59.115] result() for MulticoreFuture ... done
[18:01:59.115]  - Number of value chunks collected: 2
[18:01:59.115] Resolving 2 futures (chunks) ... DONE
[18:01:59.116] Reducing values from 2 chunks ...
[18:01:59.116]  - Number of values collected after concatenation: 10
[18:01:59.116]  - Number of values expected: 10
[18:01:59.116] Reducing values from 2 chunks ... DONE
[18:01:59.117] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[18:01:59.122] future_lapply() ...
[18:01:59.136] Number of chunks: 2
[18:01:59.137] getGlobalsAndPackagesXApply() ...
[18:01:59.137]  - future.globals: TRUE
[18:01:59.137] getGlobalsAndPackages() ...
[18:01:59.137] Searching for globals...
[18:01:59.146] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[18:01:59.146] Searching for globals ... DONE
[18:01:59.146] Resolving globals: FALSE
[18:01:59.148] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[18:01:59.149] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:01:59.149] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:59.150] - packages: [2] ‘stats’, ‘future.apply’
[18:01:59.150] getGlobalsAndPackages() ... DONE
[18:01:59.150]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:59.150]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[18:01:59.151] Finding globals ... DONE
[18:01:59.151]  - use_args: TRUE
[18:01:59.151]  - Getting '...' globals ...
[18:01:59.152] resolve() on list ...
[18:01:59.152]  recursive: 0
[18:01:59.152]  length: 1
[18:01:59.152]  elements: ‘...’
[18:01:59.153]  length: 0 (resolved future 1)
[18:01:59.153] resolve() on list ... DONE
[18:01:59.153]    - '...' content: [n=0] 
[18:01:59.153] List of 1
[18:01:59.153]  $ ...: list()
[18:01:59.153]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.153]  - attr(*, "where")=List of 1
[18:01:59.153]   ..$ ...:<environment: 0x6183c0c13770> 
[18:01:59.153]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.153]  - attr(*, "resolved")= logi TRUE
[18:01:59.153]  - attr(*, "total_size")= num NA
[18:01:59.158]  - Getting '...' globals ... DONE
[18:01:59.159] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:59.159] List of 8
[18:01:59.159]  $ ...future.FUN:function (x, ...)  
[18:01:59.159]  $ x_FUN        :function (x, ...)  
[18:01:59.159]  $ times        : int 5
[18:01:59.159]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:59.159]  $ stop_if_not  :function (...)  
[18:01:59.159]  $ dim          : NULL
[18:01:59.159]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:59.159]  $ ...          : list()
[18:01:59.159]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.159]  - attr(*, "where")=List of 8
[18:01:59.159]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:59.159]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:59.159]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:59.159]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:59.159]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:59.159]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:59.159]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:59.159]   ..$ ...          :<environment: 0x6183c0c13770> 
[18:01:59.159]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.159]  - attr(*, "resolved")= logi FALSE
[18:01:59.159]  - attr(*, "total_size")= num 95528
[18:01:59.170] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[18:01:59.170] getGlobalsAndPackagesXApply() ... DONE
[18:01:59.170] Number of futures (= number of chunks): 2
[18:01:59.171] Launching 2 futures (chunks) ...
[18:01:59.171] Chunk #1 of 2 ...
[18:01:59.171]  - Finding globals in 'X' for chunk #1 ...
[18:01:59.171] getGlobalsAndPackages() ...
[18:01:59.172] Searching for globals...
[18:01:59.172] 
[18:01:59.172] Searching for globals ... DONE
[18:01:59.172] - globals: [0] <none>
[18:01:59.173] getGlobalsAndPackages() ... DONE
[18:01:59.175]    + additional globals found: [n=0] 
[18:01:59.176]    + additional namespaces needed: [n=0] 
[18:01:59.176]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:59.176]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:59.176]  - seeds: <none>
[18:01:59.177]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.177] getGlobalsAndPackages() ...
[18:01:59.177] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.177] Resolving globals: FALSE
[18:01:59.178] Tweak future expression to call with '...' arguments ...
[18:01:59.178] {
[18:01:59.178]     do.call(function(...) {
[18:01:59.178]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.178]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.178]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.178]             on.exit(options(oopts), add = TRUE)
[18:01:59.178]         }
[18:01:59.178]         {
[18:01:59.178]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.178]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.178]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.178]             })
[18:01:59.178]         }
[18:01:59.178]     }, args = future.call.arguments)
[18:01:59.178] }
[18:01:59.178] Tweak future expression to call with '...' arguments ... DONE
[18:01:59.180] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.180] - packages: [2] ‘stats’, ‘future.apply’
[18:01:59.180] getGlobalsAndPackages() ... DONE
[18:01:59.181] run() for ‘Future’ ...
[18:01:59.181] - state: ‘created’
[18:01:59.181] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:59.188] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:59.188] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:59.188]   - Field: ‘label’
[18:01:59.188]   - Field: ‘local’
[18:01:59.189]   - Field: ‘owner’
[18:01:59.189]   - Field: ‘envir’
[18:01:59.189]   - Field: ‘workers’
[18:01:59.189]   - Field: ‘packages’
[18:01:59.189]   - Field: ‘gc’
[18:01:59.190]   - Field: ‘job’
[18:01:59.190]   - Field: ‘conditions’
[18:01:59.190]   - Field: ‘expr’
[18:01:59.190]   - Field: ‘uuid’
[18:01:59.191]   - Field: ‘seed’
[18:01:59.191]   - Field: ‘version’
[18:01:59.191]   - Field: ‘result’
[18:01:59.191]   - Field: ‘asynchronous’
[18:01:59.191]   - Field: ‘calls’
[18:01:59.191]   - Field: ‘globals’
[18:01:59.192]   - Field: ‘stdout’
[18:01:59.192]   - Field: ‘earlySignal’
[18:01:59.192]   - Field: ‘lazy’
[18:01:59.192]   - Field: ‘state’
[18:01:59.193] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:59.193] - Launch lazy future ...
[18:01:59.193] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[18:01:59.194] Packages needed by future strategies (n = 0): <none>
[18:01:59.195] {
[18:01:59.195]     {
[18:01:59.195]         {
[18:01:59.195]             ...future.startTime <- base::Sys.time()
[18:01:59.195]             {
[18:01:59.195]                 {
[18:01:59.195]                   {
[18:01:59.195]                     {
[18:01:59.195]                       {
[18:01:59.195]                         base::local({
[18:01:59.195]                           has_future <- base::requireNamespace("future", 
[18:01:59.195]                             quietly = TRUE)
[18:01:59.195]                           if (has_future) {
[18:01:59.195]                             ns <- base::getNamespace("future")
[18:01:59.195]                             version <- ns[[".package"]][["version"]]
[18:01:59.195]                             if (is.null(version)) 
[18:01:59.195]                               version <- utils::packageVersion("future")
[18:01:59.195]                           }
[18:01:59.195]                           else {
[18:01:59.195]                             version <- NULL
[18:01:59.195]                           }
[18:01:59.195]                           if (!has_future || version < "1.8.0") {
[18:01:59.195]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:59.195]                               "", base::R.version$version.string), 
[18:01:59.195]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:59.195]                                 base::R.version$platform, 8 * 
[18:01:59.195]                                   base::.Machine$sizeof.pointer), 
[18:01:59.195]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:59.195]                                 "release", "version")], collapse = " "), 
[18:01:59.195]                               hostname = base::Sys.info()[["nodename"]])
[18:01:59.195]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:59.195]                               info)
[18:01:59.195]                             info <- base::paste(info, collapse = "; ")
[18:01:59.195]                             if (!has_future) {
[18:01:59.195]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:59.195]                                 info)
[18:01:59.195]                             }
[18:01:59.195]                             else {
[18:01:59.195]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:59.195]                                 info, version)
[18:01:59.195]                             }
[18:01:59.195]                             base::stop(msg)
[18:01:59.195]                           }
[18:01:59.195]                         })
[18:01:59.195]                       }
[18:01:59.195]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:59.195]                       base::options(mc.cores = 1L)
[18:01:59.195]                     }
[18:01:59.195]                     base::local({
[18:01:59.195]                       for (pkg in c("stats", "future.apply")) {
[18:01:59.195]                         base::loadNamespace(pkg)
[18:01:59.195]                         base::library(pkg, character.only = TRUE)
[18:01:59.195]                       }
[18:01:59.195]                     })
[18:01:59.195]                   }
[18:01:59.195]                   ...future.strategy.old <- future::plan("list")
[18:01:59.195]                   options(future.plan = NULL)
[18:01:59.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:59.195]                 }
[18:01:59.195]                 ...future.workdir <- getwd()
[18:01:59.195]             }
[18:01:59.195]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:59.195]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:59.195]         }
[18:01:59.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:59.195]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:59.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:59.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:59.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:59.195]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:59.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:59.195]             base::names(...future.oldOptions))
[18:01:59.195]     }
[18:01:59.195]     if (FALSE) {
[18:01:59.195]     }
[18:01:59.195]     else {
[18:01:59.195]         if (TRUE) {
[18:01:59.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:59.195]                 open = "w")
[18:01:59.195]         }
[18:01:59.195]         else {
[18:01:59.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:59.195]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:59.195]         }
[18:01:59.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:59.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:59.195]             base::sink(type = "output", split = FALSE)
[18:01:59.195]             base::close(...future.stdout)
[18:01:59.195]         }, add = TRUE)
[18:01:59.195]     }
[18:01:59.195]     ...future.frame <- base::sys.nframe()
[18:01:59.195]     ...future.conditions <- base::list()
[18:01:59.195]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:59.195]     if (FALSE) {
[18:01:59.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:59.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:59.195]     }
[18:01:59.195]     ...future.result <- base::tryCatch({
[18:01:59.195]         base::withCallingHandlers({
[18:01:59.195]             ...future.value <- base::withVisible(base::local({
[18:01:59.195]                 withCallingHandlers({
[18:01:59.195]                   {
[18:01:59.195]                     do.call(function(...) {
[18:01:59.195]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.195]                       if (!identical(...future.globals.maxSize.org, 
[18:01:59.195]                         ...future.globals.maxSize)) {
[18:01:59.195]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.195]                         on.exit(options(oopts), add = TRUE)
[18:01:59.195]                       }
[18:01:59.195]                       {
[18:01:59.195]                         lapply(seq_along(...future.elements_ii), 
[18:01:59.195]                           FUN = function(jj) {
[18:01:59.195]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.195]                             ...future.FUN(...future.X_jj, ...)
[18:01:59.195]                           })
[18:01:59.195]                       }
[18:01:59.195]                     }, args = future.call.arguments)
[18:01:59.195]                   }
[18:01:59.195]                 }, immediateCondition = function(cond) {
[18:01:59.195]                   save_rds <- function (object, pathname, ...) 
[18:01:59.195]                   {
[18:01:59.195]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:59.195]                     if (file_test("-f", pathname_tmp)) {
[18:01:59.195]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.195]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:59.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.195]                         fi_tmp[["mtime"]])
[18:01:59.195]                     }
[18:01:59.195]                     tryCatch({
[18:01:59.195]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:59.195]                     }, error = function(ex) {
[18:01:59.195]                       msg <- conditionMessage(ex)
[18:01:59.195]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.195]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:59.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.195]                         fi_tmp[["mtime"]], msg)
[18:01:59.195]                       ex$message <- msg
[18:01:59.195]                       stop(ex)
[18:01:59.195]                     })
[18:01:59.195]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:59.195]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:59.195]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:59.195]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.195]                       fi <- file.info(pathname)
[18:01:59.195]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:59.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.195]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:59.195]                         fi[["size"]], fi[["mtime"]])
[18:01:59.195]                       stop(msg)
[18:01:59.195]                     }
[18:01:59.195]                     invisible(pathname)
[18:01:59.195]                   }
[18:01:59.195]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:59.195]                     rootPath = tempdir()) 
[18:01:59.195]                   {
[18:01:59.195]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:59.195]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:59.195]                       tmpdir = path, fileext = ".rds")
[18:01:59.195]                     save_rds(obj, file)
[18:01:59.195]                   }
[18:01:59.195]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:59.195]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.195]                   {
[18:01:59.195]                     inherits <- base::inherits
[18:01:59.195]                     invokeRestart <- base::invokeRestart
[18:01:59.195]                     is.null <- base::is.null
[18:01:59.195]                     muffled <- FALSE
[18:01:59.195]                     if (inherits(cond, "message")) {
[18:01:59.195]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:59.195]                       if (muffled) 
[18:01:59.195]                         invokeRestart("muffleMessage")
[18:01:59.195]                     }
[18:01:59.195]                     else if (inherits(cond, "warning")) {
[18:01:59.195]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:59.195]                       if (muffled) 
[18:01:59.195]                         invokeRestart("muffleWarning")
[18:01:59.195]                     }
[18:01:59.195]                     else if (inherits(cond, "condition")) {
[18:01:59.195]                       if (!is.null(pattern)) {
[18:01:59.195]                         computeRestarts <- base::computeRestarts
[18:01:59.195]                         grepl <- base::grepl
[18:01:59.195]                         restarts <- computeRestarts(cond)
[18:01:59.195]                         for (restart in restarts) {
[18:01:59.195]                           name <- restart$name
[18:01:59.195]                           if (is.null(name)) 
[18:01:59.195]                             next
[18:01:59.195]                           if (!grepl(pattern, name)) 
[18:01:59.195]                             next
[18:01:59.195]                           invokeRestart(restart)
[18:01:59.195]                           muffled <- TRUE
[18:01:59.195]                           break
[18:01:59.195]                         }
[18:01:59.195]                       }
[18:01:59.195]                     }
[18:01:59.195]                     invisible(muffled)
[18:01:59.195]                   }
[18:01:59.195]                   muffleCondition(cond)
[18:01:59.195]                 })
[18:01:59.195]             }))
[18:01:59.195]             future::FutureResult(value = ...future.value$value, 
[18:01:59.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.195]                   ...future.rng), globalenv = if (FALSE) 
[18:01:59.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:59.195]                     ...future.globalenv.names))
[18:01:59.195]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:59.195]         }, condition = base::local({
[18:01:59.195]             c <- base::c
[18:01:59.195]             inherits <- base::inherits
[18:01:59.195]             invokeRestart <- base::invokeRestart
[18:01:59.195]             length <- base::length
[18:01:59.195]             list <- base::list
[18:01:59.195]             seq.int <- base::seq.int
[18:01:59.195]             signalCondition <- base::signalCondition
[18:01:59.195]             sys.calls <- base::sys.calls
[18:01:59.195]             `[[` <- base::`[[`
[18:01:59.195]             `+` <- base::`+`
[18:01:59.195]             `<<-` <- base::`<<-`
[18:01:59.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:59.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:59.195]                   3L)]
[18:01:59.195]             }
[18:01:59.195]             function(cond) {
[18:01:59.195]                 is_error <- inherits(cond, "error")
[18:01:59.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:59.195]                   NULL)
[18:01:59.195]                 if (is_error) {
[18:01:59.195]                   sessionInformation <- function() {
[18:01:59.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:59.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:59.195]                       search = base::search(), system = base::Sys.info())
[18:01:59.195]                   }
[18:01:59.195]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:59.195]                     cond$call), session = sessionInformation(), 
[18:01:59.195]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:59.195]                   signalCondition(cond)
[18:01:59.195]                 }
[18:01:59.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:59.195]                 "immediateCondition"))) {
[18:01:59.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:59.195]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:59.195]                   if (TRUE && !signal) {
[18:01:59.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.195]                     {
[18:01:59.195]                       inherits <- base::inherits
[18:01:59.195]                       invokeRestart <- base::invokeRestart
[18:01:59.195]                       is.null <- base::is.null
[18:01:59.195]                       muffled <- FALSE
[18:01:59.195]                       if (inherits(cond, "message")) {
[18:01:59.195]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.195]                         if (muffled) 
[18:01:59.195]                           invokeRestart("muffleMessage")
[18:01:59.195]                       }
[18:01:59.195]                       else if (inherits(cond, "warning")) {
[18:01:59.195]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.195]                         if (muffled) 
[18:01:59.195]                           invokeRestart("muffleWarning")
[18:01:59.195]                       }
[18:01:59.195]                       else if (inherits(cond, "condition")) {
[18:01:59.195]                         if (!is.null(pattern)) {
[18:01:59.195]                           computeRestarts <- base::computeRestarts
[18:01:59.195]                           grepl <- base::grepl
[18:01:59.195]                           restarts <- computeRestarts(cond)
[18:01:59.195]                           for (restart in restarts) {
[18:01:59.195]                             name <- restart$name
[18:01:59.195]                             if (is.null(name)) 
[18:01:59.195]                               next
[18:01:59.195]                             if (!grepl(pattern, name)) 
[18:01:59.195]                               next
[18:01:59.195]                             invokeRestart(restart)
[18:01:59.195]                             muffled <- TRUE
[18:01:59.195]                             break
[18:01:59.195]                           }
[18:01:59.195]                         }
[18:01:59.195]                       }
[18:01:59.195]                       invisible(muffled)
[18:01:59.195]                     }
[18:01:59.195]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.195]                   }
[18:01:59.195]                 }
[18:01:59.195]                 else {
[18:01:59.195]                   if (TRUE) {
[18:01:59.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.195]                     {
[18:01:59.195]                       inherits <- base::inherits
[18:01:59.195]                       invokeRestart <- base::invokeRestart
[18:01:59.195]                       is.null <- base::is.null
[18:01:59.195]                       muffled <- FALSE
[18:01:59.195]                       if (inherits(cond, "message")) {
[18:01:59.195]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.195]                         if (muffled) 
[18:01:59.195]                           invokeRestart("muffleMessage")
[18:01:59.195]                       }
[18:01:59.195]                       else if (inherits(cond, "warning")) {
[18:01:59.195]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.195]                         if (muffled) 
[18:01:59.195]                           invokeRestart("muffleWarning")
[18:01:59.195]                       }
[18:01:59.195]                       else if (inherits(cond, "condition")) {
[18:01:59.195]                         if (!is.null(pattern)) {
[18:01:59.195]                           computeRestarts <- base::computeRestarts
[18:01:59.195]                           grepl <- base::grepl
[18:01:59.195]                           restarts <- computeRestarts(cond)
[18:01:59.195]                           for (restart in restarts) {
[18:01:59.195]                             name <- restart$name
[18:01:59.195]                             if (is.null(name)) 
[18:01:59.195]                               next
[18:01:59.195]                             if (!grepl(pattern, name)) 
[18:01:59.195]                               next
[18:01:59.195]                             invokeRestart(restart)
[18:01:59.195]                             muffled <- TRUE
[18:01:59.195]                             break
[18:01:59.195]                           }
[18:01:59.195]                         }
[18:01:59.195]                       }
[18:01:59.195]                       invisible(muffled)
[18:01:59.195]                     }
[18:01:59.195]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.195]                   }
[18:01:59.195]                 }
[18:01:59.195]             }
[18:01:59.195]         }))
[18:01:59.195]     }, error = function(ex) {
[18:01:59.195]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:59.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.195]                 ...future.rng), started = ...future.startTime, 
[18:01:59.195]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:59.195]             version = "1.8"), class = "FutureResult")
[18:01:59.195]     }, finally = {
[18:01:59.195]         if (!identical(...future.workdir, getwd())) 
[18:01:59.195]             setwd(...future.workdir)
[18:01:59.195]         {
[18:01:59.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:59.195]                 ...future.oldOptions$nwarnings <- NULL
[18:01:59.195]             }
[18:01:59.195]             base::options(...future.oldOptions)
[18:01:59.195]             if (.Platform$OS.type == "windows") {
[18:01:59.195]                 old_names <- names(...future.oldEnvVars)
[18:01:59.195]                 envs <- base::Sys.getenv()
[18:01:59.195]                 names <- names(envs)
[18:01:59.195]                 common <- intersect(names, old_names)
[18:01:59.195]                 added <- setdiff(names, old_names)
[18:01:59.195]                 removed <- setdiff(old_names, names)
[18:01:59.195]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:59.195]                   envs[common]]
[18:01:59.195]                 NAMES <- toupper(changed)
[18:01:59.195]                 args <- list()
[18:01:59.195]                 for (kk in seq_along(NAMES)) {
[18:01:59.195]                   name <- changed[[kk]]
[18:01:59.195]                   NAME <- NAMES[[kk]]
[18:01:59.195]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.195]                     next
[18:01:59.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.195]                 }
[18:01:59.195]                 NAMES <- toupper(added)
[18:01:59.195]                 for (kk in seq_along(NAMES)) {
[18:01:59.195]                   name <- added[[kk]]
[18:01:59.195]                   NAME <- NAMES[[kk]]
[18:01:59.195]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.195]                     next
[18:01:59.195]                   args[[name]] <- ""
[18:01:59.195]                 }
[18:01:59.195]                 NAMES <- toupper(removed)
[18:01:59.195]                 for (kk in seq_along(NAMES)) {
[18:01:59.195]                   name <- removed[[kk]]
[18:01:59.195]                   NAME <- NAMES[[kk]]
[18:01:59.195]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.195]                     next
[18:01:59.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.195]                 }
[18:01:59.195]                 if (length(args) > 0) 
[18:01:59.195]                   base::do.call(base::Sys.setenv, args = args)
[18:01:59.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:59.195]             }
[18:01:59.195]             else {
[18:01:59.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:59.195]             }
[18:01:59.195]             {
[18:01:59.195]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:59.195]                   0L) {
[18:01:59.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:59.195]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:59.195]                   base::options(opts)
[18:01:59.195]                 }
[18:01:59.195]                 {
[18:01:59.195]                   {
[18:01:59.195]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:59.195]                     NULL
[18:01:59.195]                   }
[18:01:59.195]                   options(future.plan = NULL)
[18:01:59.195]                   if (is.na(NA_character_)) 
[18:01:59.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:59.195]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:59.195]                     .init = FALSE)
[18:01:59.195]                 }
[18:01:59.195]             }
[18:01:59.195]         }
[18:01:59.195]     })
[18:01:59.195]     if (TRUE) {
[18:01:59.195]         base::sink(type = "output", split = FALSE)
[18:01:59.195]         if (TRUE) {
[18:01:59.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:59.195]         }
[18:01:59.195]         else {
[18:01:59.195]             ...future.result["stdout"] <- base::list(NULL)
[18:01:59.195]         }
[18:01:59.195]         base::close(...future.stdout)
[18:01:59.195]         ...future.stdout <- NULL
[18:01:59.195]     }
[18:01:59.195]     ...future.result$conditions <- ...future.conditions
[18:01:59.195]     ...future.result$finished <- base::Sys.time()
[18:01:59.195]     ...future.result
[18:01:59.195] }
[18:01:59.200] assign_globals() ...
[18:01:59.200] List of 11
[18:01:59.200]  $ ...future.FUN            :function (x, ...)  
[18:01:59.200]  $ x_FUN                    :function (x, ...)  
[18:01:59.200]  $ times                    : int 5
[18:01:59.200]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:59.200]  $ stop_if_not              :function (...)  
[18:01:59.200]  $ dim                      : NULL
[18:01:59.200]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:59.200]  $ future.call.arguments    : list()
[18:01:59.200]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.200]  $ ...future.elements_ii    :List of 1
[18:01:59.200]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[18:01:59.200]  $ ...future.seeds_ii       : NULL
[18:01:59.200]  $ ...future.globals.maxSize: NULL
[18:01:59.200]  - attr(*, "where")=List of 11
[18:01:59.200]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:59.200]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:59.200]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:59.200]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:59.200]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:59.200]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:59.200]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:59.200]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:59.200]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:59.200]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:59.200]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:59.200]  - attr(*, "resolved")= logi FALSE
[18:01:59.200]  - attr(*, "total_size")= num 95528
[18:01:59.200]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.200]  - attr(*, "already-done")= logi TRUE
[18:01:59.215] - copied ‘...future.FUN’ to environment
[18:01:59.215] - copied ‘x_FUN’ to environment
[18:01:59.216] - copied ‘times’ to environment
[18:01:59.216] - copied ‘stopf’ to environment
[18:01:59.216] - copied ‘stop_if_not’ to environment
[18:01:59.216] - copied ‘dim’ to environment
[18:01:59.217] - copied ‘valid_types’ to environment
[18:01:59.217] - copied ‘future.call.arguments’ to environment
[18:01:59.217] - copied ‘...future.elements_ii’ to environment
[18:01:59.217] - copied ‘...future.seeds_ii’ to environment
[18:01:59.217] - copied ‘...future.globals.maxSize’ to environment
[18:01:59.218] assign_globals() ... done
[18:01:59.218] requestCore(): workers = 2
[18:01:59.222] MulticoreFuture started
[18:01:59.223] - Launch lazy future ... done
[18:01:59.223] run() for ‘MulticoreFuture’ ... done
[18:01:59.223] Created future:
[18:01:59.225] plan(): Setting new future strategy stack:
[18:01:59.225] List of future strategies:
[18:01:59.225] 1. sequential:
[18:01:59.225]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:59.225]    - tweaked: FALSE
[18:01:59.225]    - call: NULL
[18:01:59.227] plan(): nbrOfWorkers() = 1
[18:01:59.233] plan(): Setting new future strategy stack:
[18:01:59.233] List of future strategies:
[18:01:59.233] 1. multicore:
[18:01:59.233]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:59.233]    - tweaked: FALSE
[18:01:59.233]    - call: plan(strategy)
[18:01:59.224] MulticoreFuture:
[18:01:59.224] Label: ‘future_vapply-1’
[18:01:59.224] Expression:
[18:01:59.224] {
[18:01:59.224]     do.call(function(...) {
[18:01:59.224]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.224]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.224]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.224]             on.exit(options(oopts), add = TRUE)
[18:01:59.224]         }
[18:01:59.224]         {
[18:01:59.224]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.224]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.224]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.224]             })
[18:01:59.224]         }
[18:01:59.224]     }, args = future.call.arguments)
[18:01:59.224] }
[18:01:59.224] Lazy evaluation: FALSE
[18:01:59.224] Asynchronous evaluation: TRUE
[18:01:59.224] Local evaluation: TRUE
[18:01:59.224] Environment: R_GlobalEnv
[18:01:59.224] Capture standard output: TRUE
[18:01:59.224] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:59.224] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:59.224] Packages: 2 packages (‘stats’, ‘future.apply’)
[18:01:59.224] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:59.224] Resolved: FALSE
[18:01:59.224] Value: <not collected>
[18:01:59.224] Conditions captured: <none>
[18:01:59.224] Early signaling: FALSE
[18:01:59.224] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:59.224] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:59.239] Chunk #1 of 2 ... DONE
[18:01:59.240] Chunk #2 of 2 ...
[18:01:59.240]  - Finding globals in 'X' for chunk #2 ...
[18:01:59.241] getGlobalsAndPackages() ...
[18:01:59.241] Searching for globals...
[18:01:59.242] 
[18:01:59.242] Searching for globals ... DONE
[18:01:59.242] - globals: [0] <none>
[18:01:59.243] getGlobalsAndPackages() ... DONE
[18:01:59.243]    + additional globals found: [n=0] 
[18:01:59.243]    + additional namespaces needed: [n=0] 
[18:01:59.243]  - Finding globals in 'X' for chunk #2 ... DONE
[18:01:59.244]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:59.244]  - seeds: <none>
[18:01:59.249]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.250] getGlobalsAndPackages() ...
[18:01:59.250] plan(): nbrOfWorkers() = 2
[18:01:59.250] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.251] Resolving globals: FALSE
[18:01:59.252] Tweak future expression to call with '...' arguments ...
[18:01:59.253] {
[18:01:59.253]     do.call(function(...) {
[18:01:59.253]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.253]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.253]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.253]             on.exit(options(oopts), add = TRUE)
[18:01:59.253]         }
[18:01:59.253]         {
[18:01:59.253]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.253]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.253]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.253]             })
[18:01:59.253]         }
[18:01:59.253]     }, args = future.call.arguments)
[18:01:59.253] }
[18:01:59.254] Tweak future expression to call with '...' arguments ... DONE
[18:01:59.257] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.258] - packages: [2] ‘stats’, ‘future.apply’
[18:01:59.259] getGlobalsAndPackages() ... DONE
[18:01:59.260] run() for ‘Future’ ...
[18:01:59.261] - state: ‘created’
[18:01:59.261] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:59.271] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:59.272] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:59.272]   - Field: ‘label’
[18:01:59.273]   - Field: ‘local’
[18:01:59.273]   - Field: ‘owner’
[18:01:59.274]   - Field: ‘envir’
[18:01:59.274]   - Field: ‘workers’
[18:01:59.275]   - Field: ‘packages’
[18:01:59.275]   - Field: ‘gc’
[18:01:59.275]   - Field: ‘job’
[18:01:59.276]   - Field: ‘conditions’
[18:01:59.276]   - Field: ‘expr’
[18:01:59.276]   - Field: ‘uuid’
[18:01:59.277]   - Field: ‘seed’
[18:01:59.277]   - Field: ‘version’
[18:01:59.277]   - Field: ‘result’
[18:01:59.278]   - Field: ‘asynchronous’
[18:01:59.278]   - Field: ‘calls’
[18:01:59.278]   - Field: ‘globals’
[18:01:59.279]   - Field: ‘stdout’
[18:01:59.279]   - Field: ‘earlySignal’
[18:01:59.279]   - Field: ‘lazy’
[18:01:59.279]   - Field: ‘state’
[18:01:59.280] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:59.280] - Launch lazy future ...
[18:01:59.281] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[18:01:59.282] Packages needed by future strategies (n = 0): <none>
[18:01:59.284] {
[18:01:59.284]     {
[18:01:59.284]         {
[18:01:59.284]             ...future.startTime <- base::Sys.time()
[18:01:59.284]             {
[18:01:59.284]                 {
[18:01:59.284]                   {
[18:01:59.284]                     {
[18:01:59.284]                       {
[18:01:59.284]                         base::local({
[18:01:59.284]                           has_future <- base::requireNamespace("future", 
[18:01:59.284]                             quietly = TRUE)
[18:01:59.284]                           if (has_future) {
[18:01:59.284]                             ns <- base::getNamespace("future")
[18:01:59.284]                             version <- ns[[".package"]][["version"]]
[18:01:59.284]                             if (is.null(version)) 
[18:01:59.284]                               version <- utils::packageVersion("future")
[18:01:59.284]                           }
[18:01:59.284]                           else {
[18:01:59.284]                             version <- NULL
[18:01:59.284]                           }
[18:01:59.284]                           if (!has_future || version < "1.8.0") {
[18:01:59.284]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:59.284]                               "", base::R.version$version.string), 
[18:01:59.284]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:59.284]                                 base::R.version$platform, 8 * 
[18:01:59.284]                                   base::.Machine$sizeof.pointer), 
[18:01:59.284]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:59.284]                                 "release", "version")], collapse = " "), 
[18:01:59.284]                               hostname = base::Sys.info()[["nodename"]])
[18:01:59.284]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:59.284]                               info)
[18:01:59.284]                             info <- base::paste(info, collapse = "; ")
[18:01:59.284]                             if (!has_future) {
[18:01:59.284]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:59.284]                                 info)
[18:01:59.284]                             }
[18:01:59.284]                             else {
[18:01:59.284]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:59.284]                                 info, version)
[18:01:59.284]                             }
[18:01:59.284]                             base::stop(msg)
[18:01:59.284]                           }
[18:01:59.284]                         })
[18:01:59.284]                       }
[18:01:59.284]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:59.284]                       base::options(mc.cores = 1L)
[18:01:59.284]                     }
[18:01:59.284]                     base::local({
[18:01:59.284]                       for (pkg in c("stats", "future.apply")) {
[18:01:59.284]                         base::loadNamespace(pkg)
[18:01:59.284]                         base::library(pkg, character.only = TRUE)
[18:01:59.284]                       }
[18:01:59.284]                     })
[18:01:59.284]                   }
[18:01:59.284]                   ...future.strategy.old <- future::plan("list")
[18:01:59.284]                   options(future.plan = NULL)
[18:01:59.284]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.284]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:59.284]                 }
[18:01:59.284]                 ...future.workdir <- getwd()
[18:01:59.284]             }
[18:01:59.284]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:59.284]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:59.284]         }
[18:01:59.284]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:59.284]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:59.284]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:59.284]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:59.284]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:59.284]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:59.284]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:59.284]             base::names(...future.oldOptions))
[18:01:59.284]     }
[18:01:59.284]     if (FALSE) {
[18:01:59.284]     }
[18:01:59.284]     else {
[18:01:59.284]         if (TRUE) {
[18:01:59.284]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:59.284]                 open = "w")
[18:01:59.284]         }
[18:01:59.284]         else {
[18:01:59.284]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:59.284]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:59.284]         }
[18:01:59.284]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:59.284]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:59.284]             base::sink(type = "output", split = FALSE)
[18:01:59.284]             base::close(...future.stdout)
[18:01:59.284]         }, add = TRUE)
[18:01:59.284]     }
[18:01:59.284]     ...future.frame <- base::sys.nframe()
[18:01:59.284]     ...future.conditions <- base::list()
[18:01:59.284]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:59.284]     if (FALSE) {
[18:01:59.284]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:59.284]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:59.284]     }
[18:01:59.284]     ...future.result <- base::tryCatch({
[18:01:59.284]         base::withCallingHandlers({
[18:01:59.284]             ...future.value <- base::withVisible(base::local({
[18:01:59.284]                 withCallingHandlers({
[18:01:59.284]                   {
[18:01:59.284]                     do.call(function(...) {
[18:01:59.284]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.284]                       if (!identical(...future.globals.maxSize.org, 
[18:01:59.284]                         ...future.globals.maxSize)) {
[18:01:59.284]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.284]                         on.exit(options(oopts), add = TRUE)
[18:01:59.284]                       }
[18:01:59.284]                       {
[18:01:59.284]                         lapply(seq_along(...future.elements_ii), 
[18:01:59.284]                           FUN = function(jj) {
[18:01:59.284]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.284]                             ...future.FUN(...future.X_jj, ...)
[18:01:59.284]                           })
[18:01:59.284]                       }
[18:01:59.284]                     }, args = future.call.arguments)
[18:01:59.284]                   }
[18:01:59.284]                 }, immediateCondition = function(cond) {
[18:01:59.284]                   save_rds <- function (object, pathname, ...) 
[18:01:59.284]                   {
[18:01:59.284]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:59.284]                     if (file_test("-f", pathname_tmp)) {
[18:01:59.284]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.284]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:59.284]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.284]                         fi_tmp[["mtime"]])
[18:01:59.284]                     }
[18:01:59.284]                     tryCatch({
[18:01:59.284]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:59.284]                     }, error = function(ex) {
[18:01:59.284]                       msg <- conditionMessage(ex)
[18:01:59.284]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.284]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:59.284]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.284]                         fi_tmp[["mtime"]], msg)
[18:01:59.284]                       ex$message <- msg
[18:01:59.284]                       stop(ex)
[18:01:59.284]                     })
[18:01:59.284]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:59.284]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:59.284]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:59.284]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.284]                       fi <- file.info(pathname)
[18:01:59.284]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:59.284]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.284]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:59.284]                         fi[["size"]], fi[["mtime"]])
[18:01:59.284]                       stop(msg)
[18:01:59.284]                     }
[18:01:59.284]                     invisible(pathname)
[18:01:59.284]                   }
[18:01:59.284]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:59.284]                     rootPath = tempdir()) 
[18:01:59.284]                   {
[18:01:59.284]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:59.284]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:59.284]                       tmpdir = path, fileext = ".rds")
[18:01:59.284]                     save_rds(obj, file)
[18:01:59.284]                   }
[18:01:59.284]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:59.284]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.284]                   {
[18:01:59.284]                     inherits <- base::inherits
[18:01:59.284]                     invokeRestart <- base::invokeRestart
[18:01:59.284]                     is.null <- base::is.null
[18:01:59.284]                     muffled <- FALSE
[18:01:59.284]                     if (inherits(cond, "message")) {
[18:01:59.284]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:59.284]                       if (muffled) 
[18:01:59.284]                         invokeRestart("muffleMessage")
[18:01:59.284]                     }
[18:01:59.284]                     else if (inherits(cond, "warning")) {
[18:01:59.284]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:59.284]                       if (muffled) 
[18:01:59.284]                         invokeRestart("muffleWarning")
[18:01:59.284]                     }
[18:01:59.284]                     else if (inherits(cond, "condition")) {
[18:01:59.284]                       if (!is.null(pattern)) {
[18:01:59.284]                         computeRestarts <- base::computeRestarts
[18:01:59.284]                         grepl <- base::grepl
[18:01:59.284]                         restarts <- computeRestarts(cond)
[18:01:59.284]                         for (restart in restarts) {
[18:01:59.284]                           name <- restart$name
[18:01:59.284]                           if (is.null(name)) 
[18:01:59.284]                             next
[18:01:59.284]                           if (!grepl(pattern, name)) 
[18:01:59.284]                             next
[18:01:59.284]                           invokeRestart(restart)
[18:01:59.284]                           muffled <- TRUE
[18:01:59.284]                           break
[18:01:59.284]                         }
[18:01:59.284]                       }
[18:01:59.284]                     }
[18:01:59.284]                     invisible(muffled)
[18:01:59.284]                   }
[18:01:59.284]                   muffleCondition(cond)
[18:01:59.284]                 })
[18:01:59.284]             }))
[18:01:59.284]             future::FutureResult(value = ...future.value$value, 
[18:01:59.284]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.284]                   ...future.rng), globalenv = if (FALSE) 
[18:01:59.284]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:59.284]                     ...future.globalenv.names))
[18:01:59.284]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:59.284]         }, condition = base::local({
[18:01:59.284]             c <- base::c
[18:01:59.284]             inherits <- base::inherits
[18:01:59.284]             invokeRestart <- base::invokeRestart
[18:01:59.284]             length <- base::length
[18:01:59.284]             list <- base::list
[18:01:59.284]             seq.int <- base::seq.int
[18:01:59.284]             signalCondition <- base::signalCondition
[18:01:59.284]             sys.calls <- base::sys.calls
[18:01:59.284]             `[[` <- base::`[[`
[18:01:59.284]             `+` <- base::`+`
[18:01:59.284]             `<<-` <- base::`<<-`
[18:01:59.284]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:59.284]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:59.284]                   3L)]
[18:01:59.284]             }
[18:01:59.284]             function(cond) {
[18:01:59.284]                 is_error <- inherits(cond, "error")
[18:01:59.284]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:59.284]                   NULL)
[18:01:59.284]                 if (is_error) {
[18:01:59.284]                   sessionInformation <- function() {
[18:01:59.284]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:59.284]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:59.284]                       search = base::search(), system = base::Sys.info())
[18:01:59.284]                   }
[18:01:59.284]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.284]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:59.284]                     cond$call), session = sessionInformation(), 
[18:01:59.284]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:59.284]                   signalCondition(cond)
[18:01:59.284]                 }
[18:01:59.284]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:59.284]                 "immediateCondition"))) {
[18:01:59.284]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:59.284]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.284]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:59.284]                   if (TRUE && !signal) {
[18:01:59.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.284]                     {
[18:01:59.284]                       inherits <- base::inherits
[18:01:59.284]                       invokeRestart <- base::invokeRestart
[18:01:59.284]                       is.null <- base::is.null
[18:01:59.284]                       muffled <- FALSE
[18:01:59.284]                       if (inherits(cond, "message")) {
[18:01:59.284]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.284]                         if (muffled) 
[18:01:59.284]                           invokeRestart("muffleMessage")
[18:01:59.284]                       }
[18:01:59.284]                       else if (inherits(cond, "warning")) {
[18:01:59.284]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.284]                         if (muffled) 
[18:01:59.284]                           invokeRestart("muffleWarning")
[18:01:59.284]                       }
[18:01:59.284]                       else if (inherits(cond, "condition")) {
[18:01:59.284]                         if (!is.null(pattern)) {
[18:01:59.284]                           computeRestarts <- base::computeRestarts
[18:01:59.284]                           grepl <- base::grepl
[18:01:59.284]                           restarts <- computeRestarts(cond)
[18:01:59.284]                           for (restart in restarts) {
[18:01:59.284]                             name <- restart$name
[18:01:59.284]                             if (is.null(name)) 
[18:01:59.284]                               next
[18:01:59.284]                             if (!grepl(pattern, name)) 
[18:01:59.284]                               next
[18:01:59.284]                             invokeRestart(restart)
[18:01:59.284]                             muffled <- TRUE
[18:01:59.284]                             break
[18:01:59.284]                           }
[18:01:59.284]                         }
[18:01:59.284]                       }
[18:01:59.284]                       invisible(muffled)
[18:01:59.284]                     }
[18:01:59.284]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.284]                   }
[18:01:59.284]                 }
[18:01:59.284]                 else {
[18:01:59.284]                   if (TRUE) {
[18:01:59.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.284]                     {
[18:01:59.284]                       inherits <- base::inherits
[18:01:59.284]                       invokeRestart <- base::invokeRestart
[18:01:59.284]                       is.null <- base::is.null
[18:01:59.284]                       muffled <- FALSE
[18:01:59.284]                       if (inherits(cond, "message")) {
[18:01:59.284]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.284]                         if (muffled) 
[18:01:59.284]                           invokeRestart("muffleMessage")
[18:01:59.284]                       }
[18:01:59.284]                       else if (inherits(cond, "warning")) {
[18:01:59.284]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.284]                         if (muffled) 
[18:01:59.284]                           invokeRestart("muffleWarning")
[18:01:59.284]                       }
[18:01:59.284]                       else if (inherits(cond, "condition")) {
[18:01:59.284]                         if (!is.null(pattern)) {
[18:01:59.284]                           computeRestarts <- base::computeRestarts
[18:01:59.284]                           grepl <- base::grepl
[18:01:59.284]                           restarts <- computeRestarts(cond)
[18:01:59.284]                           for (restart in restarts) {
[18:01:59.284]                             name <- restart$name
[18:01:59.284]                             if (is.null(name)) 
[18:01:59.284]                               next
[18:01:59.284]                             if (!grepl(pattern, name)) 
[18:01:59.284]                               next
[18:01:59.284]                             invokeRestart(restart)
[18:01:59.284]                             muffled <- TRUE
[18:01:59.284]                             break
[18:01:59.284]                           }
[18:01:59.284]                         }
[18:01:59.284]                       }
[18:01:59.284]                       invisible(muffled)
[18:01:59.284]                     }
[18:01:59.284]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.284]                   }
[18:01:59.284]                 }
[18:01:59.284]             }
[18:01:59.284]         }))
[18:01:59.284]     }, error = function(ex) {
[18:01:59.284]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:59.284]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.284]                 ...future.rng), started = ...future.startTime, 
[18:01:59.284]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:59.284]             version = "1.8"), class = "FutureResult")
[18:01:59.284]     }, finally = {
[18:01:59.284]         if (!identical(...future.workdir, getwd())) 
[18:01:59.284]             setwd(...future.workdir)
[18:01:59.284]         {
[18:01:59.284]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:59.284]                 ...future.oldOptions$nwarnings <- NULL
[18:01:59.284]             }
[18:01:59.284]             base::options(...future.oldOptions)
[18:01:59.284]             if (.Platform$OS.type == "windows") {
[18:01:59.284]                 old_names <- names(...future.oldEnvVars)
[18:01:59.284]                 envs <- base::Sys.getenv()
[18:01:59.284]                 names <- names(envs)
[18:01:59.284]                 common <- intersect(names, old_names)
[18:01:59.284]                 added <- setdiff(names, old_names)
[18:01:59.284]                 removed <- setdiff(old_names, names)
[18:01:59.284]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:59.284]                   envs[common]]
[18:01:59.284]                 NAMES <- toupper(changed)
[18:01:59.284]                 args <- list()
[18:01:59.284]                 for (kk in seq_along(NAMES)) {
[18:01:59.284]                   name <- changed[[kk]]
[18:01:59.284]                   NAME <- NAMES[[kk]]
[18:01:59.284]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.284]                     next
[18:01:59.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.284]                 }
[18:01:59.284]                 NAMES <- toupper(added)
[18:01:59.284]                 for (kk in seq_along(NAMES)) {
[18:01:59.284]                   name <- added[[kk]]
[18:01:59.284]                   NAME <- NAMES[[kk]]
[18:01:59.284]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.284]                     next
[18:01:59.284]                   args[[name]] <- ""
[18:01:59.284]                 }
[18:01:59.284]                 NAMES <- toupper(removed)
[18:01:59.284]                 for (kk in seq_along(NAMES)) {
[18:01:59.284]                   name <- removed[[kk]]
[18:01:59.284]                   NAME <- NAMES[[kk]]
[18:01:59.284]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.284]                     next
[18:01:59.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.284]                 }
[18:01:59.284]                 if (length(args) > 0) 
[18:01:59.284]                   base::do.call(base::Sys.setenv, args = args)
[18:01:59.284]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:59.284]             }
[18:01:59.284]             else {
[18:01:59.284]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:59.284]             }
[18:01:59.284]             {
[18:01:59.284]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:59.284]                   0L) {
[18:01:59.284]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:59.284]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:59.284]                   base::options(opts)
[18:01:59.284]                 }
[18:01:59.284]                 {
[18:01:59.284]                   {
[18:01:59.284]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:59.284]                     NULL
[18:01:59.284]                   }
[18:01:59.284]                   options(future.plan = NULL)
[18:01:59.284]                   if (is.na(NA_character_)) 
[18:01:59.284]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.284]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:59.284]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:59.284]                     .init = FALSE)
[18:01:59.284]                 }
[18:01:59.284]             }
[18:01:59.284]         }
[18:01:59.284]     })
[18:01:59.284]     if (TRUE) {
[18:01:59.284]         base::sink(type = "output", split = FALSE)
[18:01:59.284]         if (TRUE) {
[18:01:59.284]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:59.284]         }
[18:01:59.284]         else {
[18:01:59.284]             ...future.result["stdout"] <- base::list(NULL)
[18:01:59.284]         }
[18:01:59.284]         base::close(...future.stdout)
[18:01:59.284]         ...future.stdout <- NULL
[18:01:59.284]     }
[18:01:59.284]     ...future.result$conditions <- ...future.conditions
[18:01:59.284]     ...future.result$finished <- base::Sys.time()
[18:01:59.284]     ...future.result
[18:01:59.284] }
[18:01:59.289] assign_globals() ...
[18:01:59.289] List of 11
[18:01:59.289]  $ ...future.FUN            :function (x, ...)  
[18:01:59.289]  $ x_FUN                    :function (x, ...)  
[18:01:59.289]  $ times                    : int 5
[18:01:59.289]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:59.289]  $ stop_if_not              :function (...)  
[18:01:59.289]  $ dim                      : NULL
[18:01:59.289]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:59.289]  $ future.call.arguments    : list()
[18:01:59.289]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.289]  $ ...future.elements_ii    :List of 2
[18:01:59.289]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[18:01:59.289]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[18:01:59.289]  $ ...future.seeds_ii       : NULL
[18:01:59.289]  $ ...future.globals.maxSize: NULL
[18:01:59.289]  - attr(*, "where")=List of 11
[18:01:59.289]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:59.289]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:59.289]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:59.289]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:59.289]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:59.289]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:59.289]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:59.289]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:59.289]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:59.289]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:59.289]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:59.289]  - attr(*, "resolved")= logi FALSE
[18:01:59.289]  - attr(*, "total_size")= num 95528
[18:01:59.289]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.289]  - attr(*, "already-done")= logi TRUE
[18:01:59.310] - copied ‘...future.FUN’ to environment
[18:01:59.311] - copied ‘x_FUN’ to environment
[18:01:59.311] - copied ‘times’ to environment
[18:01:59.311] - copied ‘stopf’ to environment
[18:01:59.311] - copied ‘stop_if_not’ to environment
[18:01:59.312] - copied ‘dim’ to environment
[18:01:59.312] - copied ‘valid_types’ to environment
[18:01:59.312] - copied ‘future.call.arguments’ to environment
[18:01:59.312] - copied ‘...future.elements_ii’ to environment
[18:01:59.313] - copied ‘...future.seeds_ii’ to environment
[18:01:59.313] - copied ‘...future.globals.maxSize’ to environment
[18:01:59.313] assign_globals() ... done
[18:01:59.313] requestCore(): workers = 2
[18:01:59.317] MulticoreFuture started
[18:01:59.318] - Launch lazy future ... done
[18:01:59.318] run() for ‘MulticoreFuture’ ... done
[18:01:59.319] Created future:
[18:01:59.320] plan(): Setting new future strategy stack:
[18:01:59.320] List of future strategies:
[18:01:59.320] 1. sequential:
[18:01:59.320]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:59.320]    - tweaked: FALSE
[18:01:59.320]    - call: NULL
[18:01:59.322] plan(): nbrOfWorkers() = 1
[18:01:59.328] plan(): Setting new future strategy stack:
[18:01:59.328] List of future strategies:
[18:01:59.328] 1. multicore:
[18:01:59.328]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:59.328]    - tweaked: FALSE
[18:01:59.328]    - call: plan(strategy)
[18:01:59.319] MulticoreFuture:
[18:01:59.319] Label: ‘future_vapply-2’
[18:01:59.319] Expression:
[18:01:59.319] {
[18:01:59.319]     do.call(function(...) {
[18:01:59.319]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.319]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.319]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.319]             on.exit(options(oopts), add = TRUE)
[18:01:59.319]         }
[18:01:59.319]         {
[18:01:59.319]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.319]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.319]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.319]             })
[18:01:59.319]         }
[18:01:59.319]     }, args = future.call.arguments)
[18:01:59.319] }
[18:01:59.319] Lazy evaluation: FALSE
[18:01:59.319] Asynchronous evaluation: TRUE
[18:01:59.319] Local evaluation: TRUE
[18:01:59.319] Environment: R_GlobalEnv
[18:01:59.319] Capture standard output: TRUE
[18:01:59.319] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:59.319] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:59.319] Packages: 2 packages (‘stats’, ‘future.apply’)
[18:01:59.319] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:59.319] Resolved: FALSE
[18:01:59.319] Value: <not collected>
[18:01:59.319] Conditions captured: <none>
[18:01:59.319] Early signaling: FALSE
[18:01:59.319] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:59.319] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:59.335] Chunk #2 of 2 ... DONE
[18:01:59.335] Launching 2 futures (chunks) ... DONE
[18:01:59.335] Resolving 2 futures (chunks) ...
[18:01:59.336] resolve() on list ...
[18:01:59.336]  recursive: 0
[18:01:59.336]  length: 2
[18:01:59.337] 
[18:01:59.337] Future #1
[18:01:59.338] result() for MulticoreFuture ...
[18:01:59.340] result() for MulticoreFuture ...
[18:01:59.340] result() for MulticoreFuture ... done
[18:01:59.340] result() for MulticoreFuture ... done
[18:01:59.341] result() for MulticoreFuture ...
[18:01:59.346] result() for MulticoreFuture ... done
[18:01:59.347] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:59.349] - nx: 2
[18:01:59.350] - relay: TRUE
[18:01:59.351] - stdout: TRUE
[18:01:59.351] - signal: TRUE
[18:01:59.352] - resignal: FALSE
[18:01:59.353] - force: TRUE
[18:01:59.354] - relayed: [n=2] FALSE, FALSE
[18:01:59.354] plan(): nbrOfWorkers() = 2
[18:01:59.354] - queued futures: [n=2] FALSE, FALSE
[18:01:59.355]  - until=1
[18:01:59.355]  - relaying element #1
[18:01:59.356] result() for MulticoreFuture ...
[18:01:59.357] result() for MulticoreFuture ... done
[18:01:59.357] result() for MulticoreFuture ...
[18:01:59.358] result() for MulticoreFuture ... done
[18:01:59.358] result() for MulticoreFuture ...
[18:01:59.359] result() for MulticoreFuture ... done
[18:01:59.359] result() for MulticoreFuture ...
[18:01:59.360] result() for MulticoreFuture ... done
[18:01:59.361] - relayed: [n=2] TRUE, FALSE
[18:01:59.361] - queued futures: [n=2] TRUE, FALSE
[18:01:59.362] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:59.362]  length: 1 (resolved future 1)
[18:01:59.363] Future #2
[18:01:59.364] result() for MulticoreFuture ...
[18:01:59.365] result() for MulticoreFuture ...
[18:01:59.366] result() for MulticoreFuture ... done
[18:01:59.366] result() for MulticoreFuture ... done
[18:01:59.367] result() for MulticoreFuture ...
[18:01:59.367] result() for MulticoreFuture ... done
[18:01:59.368] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:59.368] - nx: 2
[18:01:59.369] - relay: TRUE
[18:01:59.369] - stdout: TRUE
[18:01:59.369] - signal: TRUE
[18:01:59.369] - resignal: FALSE
[18:01:59.370] - force: TRUE
[18:01:59.370] - relayed: [n=2] TRUE, FALSE
[18:01:59.371] - queued futures: [n=2] TRUE, FALSE
[18:01:59.372]  - until=2
[18:01:59.372]  - relaying element #2
[18:01:59.372] result() for MulticoreFuture ...
[18:01:59.372] result() for MulticoreFuture ... done
[18:01:59.373] result() for MulticoreFuture ...
[18:01:59.374] result() for MulticoreFuture ... done
[18:01:59.374] result() for MulticoreFuture ...
[18:01:59.374] result() for MulticoreFuture ... done
[18:01:59.375] result() for MulticoreFuture ...
[18:01:59.375] result() for MulticoreFuture ... done
[18:01:59.375] - relayed: [n=2] TRUE, TRUE
[18:01:59.375] - queued futures: [n=2] TRUE, TRUE
[18:01:59.376] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:59.376]  length: 0 (resolved future 2)
[18:01:59.376] Relaying remaining futures
[18:01:59.376] signalConditionsASAP(NULL, pos=0) ...
[18:01:59.377] - nx: 2
[18:01:59.377] - relay: TRUE
[18:01:59.377] - stdout: TRUE
[18:01:59.377] - signal: TRUE
[18:01:59.377] - resignal: FALSE
[18:01:59.378] - force: TRUE
[18:01:59.378] - relayed: [n=2] TRUE, TRUE
[18:01:59.378] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:59.379] - relayed: [n=2] TRUE, TRUE
[18:01:59.379] - queued futures: [n=2] TRUE, TRUE
[18:01:59.379] signalConditionsASAP(NULL, pos=0) ... done
[18:01:59.379] resolve() on list ... DONE
[18:01:59.380] result() for MulticoreFuture ...
[18:01:59.380] result() for MulticoreFuture ... done
[18:01:59.380] result() for MulticoreFuture ...
[18:01:59.380] result() for MulticoreFuture ... done
[18:01:59.381] result() for MulticoreFuture ...
[18:01:59.381] result() for MulticoreFuture ... done
[18:01:59.381] result() for MulticoreFuture ...
[18:01:59.381] result() for MulticoreFuture ... done
[18:01:59.382]  - Number of value chunks collected: 2
[18:01:59.382] Resolving 2 futures (chunks) ... DONE
[18:01:59.382] Reducing values from 2 chunks ...
[18:01:59.382]  - Number of values collected after concatenation: 3
[18:01:59.382]  - Number of values expected: 3
[18:01:59.383] Reducing values from 2 chunks ... DONE
[18:01:59.383] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[18:01:59.387] future_lapply() ...
[18:01:59.402] Number of chunks: 2
[18:01:59.402] getGlobalsAndPackagesXApply() ...
[18:01:59.403]  - future.globals: TRUE
[18:01:59.403] getGlobalsAndPackages() ...
[18:01:59.403] Searching for globals...
[18:01:59.416] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[18:01:59.417] Searching for globals ... DONE
[18:01:59.417] Resolving globals: FALSE
[18:01:59.419] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[18:01:59.419] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[18:01:59.420] - globals: [1] ‘FUN’
[18:01:59.420] - packages: [1] ‘stats’
[18:01:59.420] getGlobalsAndPackages() ... DONE
[18:01:59.421]  - globals found/used: [n=1] ‘FUN’
[18:01:59.421]  - needed namespaces: [n=1] ‘stats’
[18:01:59.421] Finding globals ... DONE
[18:01:59.421]  - use_args: TRUE
[18:01:59.421]  - Getting '...' globals ...
[18:01:59.422] resolve() on list ...
[18:01:59.422]  recursive: 0
[18:01:59.422]  length: 1
[18:01:59.423]  elements: ‘...’
[18:01:59.423]  length: 0 (resolved future 1)
[18:01:59.423] resolve() on list ... DONE
[18:01:59.423]    - '...' content: [n=0] 
[18:01:59.424] List of 1
[18:01:59.424]  $ ...: list()
[18:01:59.424]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.424]  - attr(*, "where")=List of 1
[18:01:59.424]   ..$ ...:<environment: 0x6183bece9180> 
[18:01:59.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.424]  - attr(*, "resolved")= logi TRUE
[18:01:59.424]  - attr(*, "total_size")= num NA
[18:01:59.430]  - Getting '...' globals ... DONE
[18:01:59.431] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:01:59.431] List of 2
[18:01:59.431]  $ ...future.FUN:function (x, na.rm = TRUE)  
[18:01:59.431]  $ ...          : list()
[18:01:59.431]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.431]  - attr(*, "where")=List of 2
[18:01:59.431]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:59.431]   ..$ ...          :<environment: 0x6183bece9180> 
[18:01:59.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.431]  - attr(*, "resolved")= logi FALSE
[18:01:59.431]  - attr(*, "total_size")= num 46960
[18:01:59.437] Packages to be attached in all futures: [n=1] ‘stats’
[18:01:59.437] getGlobalsAndPackagesXApply() ... DONE
[18:01:59.438] Number of futures (= number of chunks): 2
[18:01:59.438] Launching 2 futures (chunks) ...
[18:01:59.438] Chunk #1 of 2 ...
[18:01:59.438]  - Finding globals in 'X' for chunk #1 ...
[18:01:59.439] getGlobalsAndPackages() ...
[18:01:59.439] Searching for globals...
[18:01:59.439] 
[18:01:59.440] Searching for globals ... DONE
[18:01:59.440] - globals: [0] <none>
[18:01:59.440] getGlobalsAndPackages() ... DONE
[18:01:59.440]    + additional globals found: [n=0] 
[18:01:59.441]    + additional namespaces needed: [n=0] 
[18:01:59.441]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:59.441]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:59.441]  - seeds: <none>
[18:01:59.441]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.442] getGlobalsAndPackages() ...
[18:01:59.442] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.442] Resolving globals: FALSE
[18:01:59.442] Tweak future expression to call with '...' arguments ...
[18:01:59.443] {
[18:01:59.443]     do.call(function(...) {
[18:01:59.443]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.443]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.443]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.443]             on.exit(options(oopts), add = TRUE)
[18:01:59.443]         }
[18:01:59.443]         {
[18:01:59.443]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.443]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.443]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.443]             })
[18:01:59.443]         }
[18:01:59.443]     }, args = future.call.arguments)
[18:01:59.443] }
[18:01:59.443] Tweak future expression to call with '...' arguments ... DONE
[18:01:59.444] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.444] - packages: [1] ‘stats’
[18:01:59.445] getGlobalsAndPackages() ... DONE
[18:01:59.445] run() for ‘Future’ ...
[18:01:59.445] - state: ‘created’
[18:01:59.446] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:59.452] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:59.452] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:59.453]   - Field: ‘label’
[18:01:59.453]   - Field: ‘local’
[18:01:59.453]   - Field: ‘owner’
[18:01:59.453]   - Field: ‘envir’
[18:01:59.453]   - Field: ‘workers’
[18:01:59.454]   - Field: ‘packages’
[18:01:59.454]   - Field: ‘gc’
[18:01:59.454]   - Field: ‘job’
[18:01:59.454]   - Field: ‘conditions’
[18:01:59.454]   - Field: ‘expr’
[18:01:59.455]   - Field: ‘uuid’
[18:01:59.455]   - Field: ‘seed’
[18:01:59.455]   - Field: ‘version’
[18:01:59.455]   - Field: ‘result’
[18:01:59.455]   - Field: ‘asynchronous’
[18:01:59.456]   - Field: ‘calls’
[18:01:59.456]   - Field: ‘globals’
[18:01:59.456]   - Field: ‘stdout’
[18:01:59.456]   - Field: ‘earlySignal’
[18:01:59.456]   - Field: ‘lazy’
[18:01:59.457]   - Field: ‘state’
[18:01:59.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:59.457] - Launch lazy future ...
[18:01:59.458] Packages needed by the future expression (n = 1): ‘stats’
[18:01:59.458] Packages needed by future strategies (n = 0): <none>
[18:01:59.459] {
[18:01:59.459]     {
[18:01:59.459]         {
[18:01:59.459]             ...future.startTime <- base::Sys.time()
[18:01:59.459]             {
[18:01:59.459]                 {
[18:01:59.459]                   {
[18:01:59.459]                     {
[18:01:59.459]                       {
[18:01:59.459]                         base::local({
[18:01:59.459]                           has_future <- base::requireNamespace("future", 
[18:01:59.459]                             quietly = TRUE)
[18:01:59.459]                           if (has_future) {
[18:01:59.459]                             ns <- base::getNamespace("future")
[18:01:59.459]                             version <- ns[[".package"]][["version"]]
[18:01:59.459]                             if (is.null(version)) 
[18:01:59.459]                               version <- utils::packageVersion("future")
[18:01:59.459]                           }
[18:01:59.459]                           else {
[18:01:59.459]                             version <- NULL
[18:01:59.459]                           }
[18:01:59.459]                           if (!has_future || version < "1.8.0") {
[18:01:59.459]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:59.459]                               "", base::R.version$version.string), 
[18:01:59.459]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:59.459]                                 base::R.version$platform, 8 * 
[18:01:59.459]                                   base::.Machine$sizeof.pointer), 
[18:01:59.459]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:59.459]                                 "release", "version")], collapse = " "), 
[18:01:59.459]                               hostname = base::Sys.info()[["nodename"]])
[18:01:59.459]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:59.459]                               info)
[18:01:59.459]                             info <- base::paste(info, collapse = "; ")
[18:01:59.459]                             if (!has_future) {
[18:01:59.459]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:59.459]                                 info)
[18:01:59.459]                             }
[18:01:59.459]                             else {
[18:01:59.459]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:59.459]                                 info, version)
[18:01:59.459]                             }
[18:01:59.459]                             base::stop(msg)
[18:01:59.459]                           }
[18:01:59.459]                         })
[18:01:59.459]                       }
[18:01:59.459]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:59.459]                       base::options(mc.cores = 1L)
[18:01:59.459]                     }
[18:01:59.459]                     base::local({
[18:01:59.459]                       for (pkg in "stats") {
[18:01:59.459]                         base::loadNamespace(pkg)
[18:01:59.459]                         base::library(pkg, character.only = TRUE)
[18:01:59.459]                       }
[18:01:59.459]                     })
[18:01:59.459]                   }
[18:01:59.459]                   ...future.strategy.old <- future::plan("list")
[18:01:59.459]                   options(future.plan = NULL)
[18:01:59.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:59.459]                 }
[18:01:59.459]                 ...future.workdir <- getwd()
[18:01:59.459]             }
[18:01:59.459]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:59.459]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:59.459]         }
[18:01:59.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:59.459]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:59.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:59.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:59.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:59.459]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:59.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:59.459]             base::names(...future.oldOptions))
[18:01:59.459]     }
[18:01:59.459]     if (FALSE) {
[18:01:59.459]     }
[18:01:59.459]     else {
[18:01:59.459]         if (TRUE) {
[18:01:59.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:59.459]                 open = "w")
[18:01:59.459]         }
[18:01:59.459]         else {
[18:01:59.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:59.459]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:59.459]         }
[18:01:59.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:59.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:59.459]             base::sink(type = "output", split = FALSE)
[18:01:59.459]             base::close(...future.stdout)
[18:01:59.459]         }, add = TRUE)
[18:01:59.459]     }
[18:01:59.459]     ...future.frame <- base::sys.nframe()
[18:01:59.459]     ...future.conditions <- base::list()
[18:01:59.459]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:59.459]     if (FALSE) {
[18:01:59.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:59.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:59.459]     }
[18:01:59.459]     ...future.result <- base::tryCatch({
[18:01:59.459]         base::withCallingHandlers({
[18:01:59.459]             ...future.value <- base::withVisible(base::local({
[18:01:59.459]                 withCallingHandlers({
[18:01:59.459]                   {
[18:01:59.459]                     do.call(function(...) {
[18:01:59.459]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.459]                       if (!identical(...future.globals.maxSize.org, 
[18:01:59.459]                         ...future.globals.maxSize)) {
[18:01:59.459]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.459]                         on.exit(options(oopts), add = TRUE)
[18:01:59.459]                       }
[18:01:59.459]                       {
[18:01:59.459]                         lapply(seq_along(...future.elements_ii), 
[18:01:59.459]                           FUN = function(jj) {
[18:01:59.459]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.459]                             ...future.FUN(...future.X_jj, ...)
[18:01:59.459]                           })
[18:01:59.459]                       }
[18:01:59.459]                     }, args = future.call.arguments)
[18:01:59.459]                   }
[18:01:59.459]                 }, immediateCondition = function(cond) {
[18:01:59.459]                   save_rds <- function (object, pathname, ...) 
[18:01:59.459]                   {
[18:01:59.459]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:59.459]                     if (file_test("-f", pathname_tmp)) {
[18:01:59.459]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.459]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:59.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.459]                         fi_tmp[["mtime"]])
[18:01:59.459]                     }
[18:01:59.459]                     tryCatch({
[18:01:59.459]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:59.459]                     }, error = function(ex) {
[18:01:59.459]                       msg <- conditionMessage(ex)
[18:01:59.459]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.459]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:59.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.459]                         fi_tmp[["mtime"]], msg)
[18:01:59.459]                       ex$message <- msg
[18:01:59.459]                       stop(ex)
[18:01:59.459]                     })
[18:01:59.459]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:59.459]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:59.459]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:59.459]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.459]                       fi <- file.info(pathname)
[18:01:59.459]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:59.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.459]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:59.459]                         fi[["size"]], fi[["mtime"]])
[18:01:59.459]                       stop(msg)
[18:01:59.459]                     }
[18:01:59.459]                     invisible(pathname)
[18:01:59.459]                   }
[18:01:59.459]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:59.459]                     rootPath = tempdir()) 
[18:01:59.459]                   {
[18:01:59.459]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:59.459]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:59.459]                       tmpdir = path, fileext = ".rds")
[18:01:59.459]                     save_rds(obj, file)
[18:01:59.459]                   }
[18:01:59.459]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:59.459]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.459]                   {
[18:01:59.459]                     inherits <- base::inherits
[18:01:59.459]                     invokeRestart <- base::invokeRestart
[18:01:59.459]                     is.null <- base::is.null
[18:01:59.459]                     muffled <- FALSE
[18:01:59.459]                     if (inherits(cond, "message")) {
[18:01:59.459]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:59.459]                       if (muffled) 
[18:01:59.459]                         invokeRestart("muffleMessage")
[18:01:59.459]                     }
[18:01:59.459]                     else if (inherits(cond, "warning")) {
[18:01:59.459]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:59.459]                       if (muffled) 
[18:01:59.459]                         invokeRestart("muffleWarning")
[18:01:59.459]                     }
[18:01:59.459]                     else if (inherits(cond, "condition")) {
[18:01:59.459]                       if (!is.null(pattern)) {
[18:01:59.459]                         computeRestarts <- base::computeRestarts
[18:01:59.459]                         grepl <- base::grepl
[18:01:59.459]                         restarts <- computeRestarts(cond)
[18:01:59.459]                         for (restart in restarts) {
[18:01:59.459]                           name <- restart$name
[18:01:59.459]                           if (is.null(name)) 
[18:01:59.459]                             next
[18:01:59.459]                           if (!grepl(pattern, name)) 
[18:01:59.459]                             next
[18:01:59.459]                           invokeRestart(restart)
[18:01:59.459]                           muffled <- TRUE
[18:01:59.459]                           break
[18:01:59.459]                         }
[18:01:59.459]                       }
[18:01:59.459]                     }
[18:01:59.459]                     invisible(muffled)
[18:01:59.459]                   }
[18:01:59.459]                   muffleCondition(cond)
[18:01:59.459]                 })
[18:01:59.459]             }))
[18:01:59.459]             future::FutureResult(value = ...future.value$value, 
[18:01:59.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.459]                   ...future.rng), globalenv = if (FALSE) 
[18:01:59.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:59.459]                     ...future.globalenv.names))
[18:01:59.459]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:59.459]         }, condition = base::local({
[18:01:59.459]             c <- base::c
[18:01:59.459]             inherits <- base::inherits
[18:01:59.459]             invokeRestart <- base::invokeRestart
[18:01:59.459]             length <- base::length
[18:01:59.459]             list <- base::list
[18:01:59.459]             seq.int <- base::seq.int
[18:01:59.459]             signalCondition <- base::signalCondition
[18:01:59.459]             sys.calls <- base::sys.calls
[18:01:59.459]             `[[` <- base::`[[`
[18:01:59.459]             `+` <- base::`+`
[18:01:59.459]             `<<-` <- base::`<<-`
[18:01:59.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:59.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:59.459]                   3L)]
[18:01:59.459]             }
[18:01:59.459]             function(cond) {
[18:01:59.459]                 is_error <- inherits(cond, "error")
[18:01:59.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:59.459]                   NULL)
[18:01:59.459]                 if (is_error) {
[18:01:59.459]                   sessionInformation <- function() {
[18:01:59.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:59.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:59.459]                       search = base::search(), system = base::Sys.info())
[18:01:59.459]                   }
[18:01:59.459]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:59.459]                     cond$call), session = sessionInformation(), 
[18:01:59.459]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:59.459]                   signalCondition(cond)
[18:01:59.459]                 }
[18:01:59.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:59.459]                 "immediateCondition"))) {
[18:01:59.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:59.459]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:59.459]                   if (TRUE && !signal) {
[18:01:59.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.459]                     {
[18:01:59.459]                       inherits <- base::inherits
[18:01:59.459]                       invokeRestart <- base::invokeRestart
[18:01:59.459]                       is.null <- base::is.null
[18:01:59.459]                       muffled <- FALSE
[18:01:59.459]                       if (inherits(cond, "message")) {
[18:01:59.459]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.459]                         if (muffled) 
[18:01:59.459]                           invokeRestart("muffleMessage")
[18:01:59.459]                       }
[18:01:59.459]                       else if (inherits(cond, "warning")) {
[18:01:59.459]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.459]                         if (muffled) 
[18:01:59.459]                           invokeRestart("muffleWarning")
[18:01:59.459]                       }
[18:01:59.459]                       else if (inherits(cond, "condition")) {
[18:01:59.459]                         if (!is.null(pattern)) {
[18:01:59.459]                           computeRestarts <- base::computeRestarts
[18:01:59.459]                           grepl <- base::grepl
[18:01:59.459]                           restarts <- computeRestarts(cond)
[18:01:59.459]                           for (restart in restarts) {
[18:01:59.459]                             name <- restart$name
[18:01:59.459]                             if (is.null(name)) 
[18:01:59.459]                               next
[18:01:59.459]                             if (!grepl(pattern, name)) 
[18:01:59.459]                               next
[18:01:59.459]                             invokeRestart(restart)
[18:01:59.459]                             muffled <- TRUE
[18:01:59.459]                             break
[18:01:59.459]                           }
[18:01:59.459]                         }
[18:01:59.459]                       }
[18:01:59.459]                       invisible(muffled)
[18:01:59.459]                     }
[18:01:59.459]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.459]                   }
[18:01:59.459]                 }
[18:01:59.459]                 else {
[18:01:59.459]                   if (TRUE) {
[18:01:59.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.459]                     {
[18:01:59.459]                       inherits <- base::inherits
[18:01:59.459]                       invokeRestart <- base::invokeRestart
[18:01:59.459]                       is.null <- base::is.null
[18:01:59.459]                       muffled <- FALSE
[18:01:59.459]                       if (inherits(cond, "message")) {
[18:01:59.459]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.459]                         if (muffled) 
[18:01:59.459]                           invokeRestart("muffleMessage")
[18:01:59.459]                       }
[18:01:59.459]                       else if (inherits(cond, "warning")) {
[18:01:59.459]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.459]                         if (muffled) 
[18:01:59.459]                           invokeRestart("muffleWarning")
[18:01:59.459]                       }
[18:01:59.459]                       else if (inherits(cond, "condition")) {
[18:01:59.459]                         if (!is.null(pattern)) {
[18:01:59.459]                           computeRestarts <- base::computeRestarts
[18:01:59.459]                           grepl <- base::grepl
[18:01:59.459]                           restarts <- computeRestarts(cond)
[18:01:59.459]                           for (restart in restarts) {
[18:01:59.459]                             name <- restart$name
[18:01:59.459]                             if (is.null(name)) 
[18:01:59.459]                               next
[18:01:59.459]                             if (!grepl(pattern, name)) 
[18:01:59.459]                               next
[18:01:59.459]                             invokeRestart(restart)
[18:01:59.459]                             muffled <- TRUE
[18:01:59.459]                             break
[18:01:59.459]                           }
[18:01:59.459]                         }
[18:01:59.459]                       }
[18:01:59.459]                       invisible(muffled)
[18:01:59.459]                     }
[18:01:59.459]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.459]                   }
[18:01:59.459]                 }
[18:01:59.459]             }
[18:01:59.459]         }))
[18:01:59.459]     }, error = function(ex) {
[18:01:59.459]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:59.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.459]                 ...future.rng), started = ...future.startTime, 
[18:01:59.459]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:59.459]             version = "1.8"), class = "FutureResult")
[18:01:59.459]     }, finally = {
[18:01:59.459]         if (!identical(...future.workdir, getwd())) 
[18:01:59.459]             setwd(...future.workdir)
[18:01:59.459]         {
[18:01:59.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:59.459]                 ...future.oldOptions$nwarnings <- NULL
[18:01:59.459]             }
[18:01:59.459]             base::options(...future.oldOptions)
[18:01:59.459]             if (.Platform$OS.type == "windows") {
[18:01:59.459]                 old_names <- names(...future.oldEnvVars)
[18:01:59.459]                 envs <- base::Sys.getenv()
[18:01:59.459]                 names <- names(envs)
[18:01:59.459]                 common <- intersect(names, old_names)
[18:01:59.459]                 added <- setdiff(names, old_names)
[18:01:59.459]                 removed <- setdiff(old_names, names)
[18:01:59.459]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:59.459]                   envs[common]]
[18:01:59.459]                 NAMES <- toupper(changed)
[18:01:59.459]                 args <- list()
[18:01:59.459]                 for (kk in seq_along(NAMES)) {
[18:01:59.459]                   name <- changed[[kk]]
[18:01:59.459]                   NAME <- NAMES[[kk]]
[18:01:59.459]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.459]                     next
[18:01:59.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.459]                 }
[18:01:59.459]                 NAMES <- toupper(added)
[18:01:59.459]                 for (kk in seq_along(NAMES)) {
[18:01:59.459]                   name <- added[[kk]]
[18:01:59.459]                   NAME <- NAMES[[kk]]
[18:01:59.459]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.459]                     next
[18:01:59.459]                   args[[name]] <- ""
[18:01:59.459]                 }
[18:01:59.459]                 NAMES <- toupper(removed)
[18:01:59.459]                 for (kk in seq_along(NAMES)) {
[18:01:59.459]                   name <- removed[[kk]]
[18:01:59.459]                   NAME <- NAMES[[kk]]
[18:01:59.459]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.459]                     next
[18:01:59.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.459]                 }
[18:01:59.459]                 if (length(args) > 0) 
[18:01:59.459]                   base::do.call(base::Sys.setenv, args = args)
[18:01:59.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:59.459]             }
[18:01:59.459]             else {
[18:01:59.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:59.459]             }
[18:01:59.459]             {
[18:01:59.459]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:59.459]                   0L) {
[18:01:59.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:59.459]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:59.459]                   base::options(opts)
[18:01:59.459]                 }
[18:01:59.459]                 {
[18:01:59.459]                   {
[18:01:59.459]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:59.459]                     NULL
[18:01:59.459]                   }
[18:01:59.459]                   options(future.plan = NULL)
[18:01:59.459]                   if (is.na(NA_character_)) 
[18:01:59.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:59.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:59.459]                     .init = FALSE)
[18:01:59.459]                 }
[18:01:59.459]             }
[18:01:59.459]         }
[18:01:59.459]     })
[18:01:59.459]     if (TRUE) {
[18:01:59.459]         base::sink(type = "output", split = FALSE)
[18:01:59.459]         if (TRUE) {
[18:01:59.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:59.459]         }
[18:01:59.459]         else {
[18:01:59.459]             ...future.result["stdout"] <- base::list(NULL)
[18:01:59.459]         }
[18:01:59.459]         base::close(...future.stdout)
[18:01:59.459]         ...future.stdout <- NULL
[18:01:59.459]     }
[18:01:59.459]     ...future.result$conditions <- ...future.conditions
[18:01:59.459]     ...future.result$finished <- base::Sys.time()
[18:01:59.459]     ...future.result
[18:01:59.459] }
[18:01:59.466] assign_globals() ...
[18:01:59.466] List of 5
[18:01:59.466]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[18:01:59.466]  $ future.call.arguments    : list()
[18:01:59.466]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.466]  $ ...future.elements_ii    :List of 4
[18:01:59.466]   ..$ : int [1:3] 1 2 3
[18:01:59.466]   ..$ : int [1:4] 1 2 3 4
[18:01:59.466]   ..$ : int [1:5] 1 2 3 4 5
[18:01:59.466]   ..$ : int [1:6] 1 2 3 4 5 6
[18:01:59.466]  $ ...future.seeds_ii       : NULL
[18:01:59.466]  $ ...future.globals.maxSize: NULL
[18:01:59.466]  - attr(*, "where")=List of 5
[18:01:59.466]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:59.466]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:59.466]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:59.466]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:59.466]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:59.466]  - attr(*, "resolved")= logi FALSE
[18:01:59.466]  - attr(*, "total_size")= num 46960
[18:01:59.466]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.466]  - attr(*, "already-done")= logi TRUE
[18:01:59.478] - copied ‘...future.FUN’ to environment
[18:01:59.478] - copied ‘future.call.arguments’ to environment
[18:01:59.479] - copied ‘...future.elements_ii’ to environment
[18:01:59.479] - copied ‘...future.seeds_ii’ to environment
[18:01:59.479] - copied ‘...future.globals.maxSize’ to environment
[18:01:59.479] assign_globals() ... done
[18:01:59.480] requestCore(): workers = 2
[18:01:59.484] MulticoreFuture started
[18:01:59.484] - Launch lazy future ... done
[18:01:59.485] run() for ‘MulticoreFuture’ ... done
[18:01:59.486] Created future:
[18:01:59.487] plan(): Setting new future strategy stack:
[18:01:59.488] List of future strategies:
[18:01:59.488] 1. sequential:
[18:01:59.488]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:59.488]    - tweaked: FALSE
[18:01:59.488]    - call: NULL
[18:01:59.490] plan(): nbrOfWorkers() = 1
[18:01:59.495] plan(): Setting new future strategy stack:
[18:01:59.496] List of future strategies:
[18:01:59.496] 1. multicore:
[18:01:59.496]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:59.496]    - tweaked: FALSE
[18:01:59.496]    - call: plan(strategy)
[18:01:59.486] MulticoreFuture:
[18:01:59.486] Label: ‘future_sapply-1’
[18:01:59.486] Expression:
[18:01:59.486] {
[18:01:59.486]     do.call(function(...) {
[18:01:59.486]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.486]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.486]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.486]             on.exit(options(oopts), add = TRUE)
[18:01:59.486]         }
[18:01:59.486]         {
[18:01:59.486]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.486]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.486]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.486]             })
[18:01:59.486]         }
[18:01:59.486]     }, args = future.call.arguments)
[18:01:59.486] }
[18:01:59.486] Lazy evaluation: FALSE
[18:01:59.486] Asynchronous evaluation: TRUE
[18:01:59.486] Local evaluation: TRUE
[18:01:59.486] Environment: R_GlobalEnv
[18:01:59.486] Capture standard output: TRUE
[18:01:59.486] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:59.486] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:59.486] Packages: 1 packages (‘stats’)
[18:01:59.486] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:59.486] Resolved: FALSE
[18:01:59.486] Value: <not collected>
[18:01:59.486] Conditions captured: <none>
[18:01:59.486] Early signaling: FALSE
[18:01:59.486] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:59.486] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:59.502] Chunk #1 of 2 ... DONE
[18:01:59.502] Chunk #2 of 2 ...
[18:01:59.503]  - Finding globals in 'X' for chunk #2 ...
[18:01:59.503] getGlobalsAndPackages() ...
[18:01:59.503] Searching for globals...
[18:01:59.504] 
[18:01:59.505] Searching for globals ... DONE
[18:01:59.505] plan(): nbrOfWorkers() = 2
[18:01:59.505] - globals: [0] <none>
[18:01:59.506] getGlobalsAndPackages() ... DONE
[18:01:59.506]    + additional globals found: [n=0] 
[18:01:59.506]    + additional namespaces needed: [n=0] 
[18:01:59.506]  - Finding globals in 'X' for chunk #2 ... DONE
[18:01:59.507]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:59.507]  - seeds: <none>
[18:01:59.507]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.508] getGlobalsAndPackages() ...
[18:01:59.508] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.508] Resolving globals: FALSE
[18:01:59.509] Tweak future expression to call with '...' arguments ...
[18:01:59.509] {
[18:01:59.509]     do.call(function(...) {
[18:01:59.509]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.509]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.509]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.509]             on.exit(options(oopts), add = TRUE)
[18:01:59.509]         }
[18:01:59.509]         {
[18:01:59.509]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.509]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.509]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.509]             })
[18:01:59.509]         }
[18:01:59.509]     }, args = future.call.arguments)
[18:01:59.509] }
[18:01:59.510] Tweak future expression to call with '...' arguments ... DONE
[18:01:59.511] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.512] - packages: [1] ‘stats’
[18:01:59.512] getGlobalsAndPackages() ... DONE
[18:01:59.514] run() for ‘Future’ ...
[18:01:59.514] - state: ‘created’
[18:01:59.514] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:59.523] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:59.523] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:59.524]   - Field: ‘label’
[18:01:59.524]   - Field: ‘local’
[18:01:59.525]   - Field: ‘owner’
[18:01:59.525]   - Field: ‘envir’
[18:01:59.525]   - Field: ‘workers’
[18:01:59.526]   - Field: ‘packages’
[18:01:59.526]   - Field: ‘gc’
[18:01:59.526]   - Field: ‘job’
[18:01:59.526]   - Field: ‘conditions’
[18:01:59.527]   - Field: ‘expr’
[18:01:59.527]   - Field: ‘uuid’
[18:01:59.528]   - Field: ‘seed’
[18:01:59.528]   - Field: ‘version’
[18:01:59.528]   - Field: ‘result’
[18:01:59.528]   - Field: ‘asynchronous’
[18:01:59.529]   - Field: ‘calls’
[18:01:59.529]   - Field: ‘globals’
[18:01:59.529]   - Field: ‘stdout’
[18:01:59.530]   - Field: ‘earlySignal’
[18:01:59.530]   - Field: ‘lazy’
[18:01:59.530]   - Field: ‘state’
[18:01:59.530] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:59.531] - Launch lazy future ...
[18:01:59.532] Packages needed by the future expression (n = 1): ‘stats’
[18:01:59.532] Packages needed by future strategies (n = 0): <none>
[18:01:59.534] {
[18:01:59.534]     {
[18:01:59.534]         {
[18:01:59.534]             ...future.startTime <- base::Sys.time()
[18:01:59.534]             {
[18:01:59.534]                 {
[18:01:59.534]                   {
[18:01:59.534]                     {
[18:01:59.534]                       {
[18:01:59.534]                         base::local({
[18:01:59.534]                           has_future <- base::requireNamespace("future", 
[18:01:59.534]                             quietly = TRUE)
[18:01:59.534]                           if (has_future) {
[18:01:59.534]                             ns <- base::getNamespace("future")
[18:01:59.534]                             version <- ns[[".package"]][["version"]]
[18:01:59.534]                             if (is.null(version)) 
[18:01:59.534]                               version <- utils::packageVersion("future")
[18:01:59.534]                           }
[18:01:59.534]                           else {
[18:01:59.534]                             version <- NULL
[18:01:59.534]                           }
[18:01:59.534]                           if (!has_future || version < "1.8.0") {
[18:01:59.534]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:59.534]                               "", base::R.version$version.string), 
[18:01:59.534]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:59.534]                                 base::R.version$platform, 8 * 
[18:01:59.534]                                   base::.Machine$sizeof.pointer), 
[18:01:59.534]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:59.534]                                 "release", "version")], collapse = " "), 
[18:01:59.534]                               hostname = base::Sys.info()[["nodename"]])
[18:01:59.534]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:59.534]                               info)
[18:01:59.534]                             info <- base::paste(info, collapse = "; ")
[18:01:59.534]                             if (!has_future) {
[18:01:59.534]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:59.534]                                 info)
[18:01:59.534]                             }
[18:01:59.534]                             else {
[18:01:59.534]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:59.534]                                 info, version)
[18:01:59.534]                             }
[18:01:59.534]                             base::stop(msg)
[18:01:59.534]                           }
[18:01:59.534]                         })
[18:01:59.534]                       }
[18:01:59.534]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:59.534]                       base::options(mc.cores = 1L)
[18:01:59.534]                     }
[18:01:59.534]                     base::local({
[18:01:59.534]                       for (pkg in "stats") {
[18:01:59.534]                         base::loadNamespace(pkg)
[18:01:59.534]                         base::library(pkg, character.only = TRUE)
[18:01:59.534]                       }
[18:01:59.534]                     })
[18:01:59.534]                   }
[18:01:59.534]                   ...future.strategy.old <- future::plan("list")
[18:01:59.534]                   options(future.plan = NULL)
[18:01:59.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:59.534]                 }
[18:01:59.534]                 ...future.workdir <- getwd()
[18:01:59.534]             }
[18:01:59.534]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:59.534]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:59.534]         }
[18:01:59.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:59.534]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:59.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:59.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:59.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:59.534]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:59.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:59.534]             base::names(...future.oldOptions))
[18:01:59.534]     }
[18:01:59.534]     if (FALSE) {
[18:01:59.534]     }
[18:01:59.534]     else {
[18:01:59.534]         if (TRUE) {
[18:01:59.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:59.534]                 open = "w")
[18:01:59.534]         }
[18:01:59.534]         else {
[18:01:59.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:59.534]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:59.534]         }
[18:01:59.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:59.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:59.534]             base::sink(type = "output", split = FALSE)
[18:01:59.534]             base::close(...future.stdout)
[18:01:59.534]         }, add = TRUE)
[18:01:59.534]     }
[18:01:59.534]     ...future.frame <- base::sys.nframe()
[18:01:59.534]     ...future.conditions <- base::list()
[18:01:59.534]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:59.534]     if (FALSE) {
[18:01:59.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:59.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:59.534]     }
[18:01:59.534]     ...future.result <- base::tryCatch({
[18:01:59.534]         base::withCallingHandlers({
[18:01:59.534]             ...future.value <- base::withVisible(base::local({
[18:01:59.534]                 withCallingHandlers({
[18:01:59.534]                   {
[18:01:59.534]                     do.call(function(...) {
[18:01:59.534]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.534]                       if (!identical(...future.globals.maxSize.org, 
[18:01:59.534]                         ...future.globals.maxSize)) {
[18:01:59.534]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.534]                         on.exit(options(oopts), add = TRUE)
[18:01:59.534]                       }
[18:01:59.534]                       {
[18:01:59.534]                         lapply(seq_along(...future.elements_ii), 
[18:01:59.534]                           FUN = function(jj) {
[18:01:59.534]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.534]                             ...future.FUN(...future.X_jj, ...)
[18:01:59.534]                           })
[18:01:59.534]                       }
[18:01:59.534]                     }, args = future.call.arguments)
[18:01:59.534]                   }
[18:01:59.534]                 }, immediateCondition = function(cond) {
[18:01:59.534]                   save_rds <- function (object, pathname, ...) 
[18:01:59.534]                   {
[18:01:59.534]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:59.534]                     if (file_test("-f", pathname_tmp)) {
[18:01:59.534]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.534]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:59.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.534]                         fi_tmp[["mtime"]])
[18:01:59.534]                     }
[18:01:59.534]                     tryCatch({
[18:01:59.534]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:59.534]                     }, error = function(ex) {
[18:01:59.534]                       msg <- conditionMessage(ex)
[18:01:59.534]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.534]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:59.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.534]                         fi_tmp[["mtime"]], msg)
[18:01:59.534]                       ex$message <- msg
[18:01:59.534]                       stop(ex)
[18:01:59.534]                     })
[18:01:59.534]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:59.534]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:59.534]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:59.534]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.534]                       fi <- file.info(pathname)
[18:01:59.534]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:59.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.534]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:59.534]                         fi[["size"]], fi[["mtime"]])
[18:01:59.534]                       stop(msg)
[18:01:59.534]                     }
[18:01:59.534]                     invisible(pathname)
[18:01:59.534]                   }
[18:01:59.534]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:59.534]                     rootPath = tempdir()) 
[18:01:59.534]                   {
[18:01:59.534]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:59.534]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:59.534]                       tmpdir = path, fileext = ".rds")
[18:01:59.534]                     save_rds(obj, file)
[18:01:59.534]                   }
[18:01:59.534]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:59.534]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.534]                   {
[18:01:59.534]                     inherits <- base::inherits
[18:01:59.534]                     invokeRestart <- base::invokeRestart
[18:01:59.534]                     is.null <- base::is.null
[18:01:59.534]                     muffled <- FALSE
[18:01:59.534]                     if (inherits(cond, "message")) {
[18:01:59.534]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:59.534]                       if (muffled) 
[18:01:59.534]                         invokeRestart("muffleMessage")
[18:01:59.534]                     }
[18:01:59.534]                     else if (inherits(cond, "warning")) {
[18:01:59.534]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:59.534]                       if (muffled) 
[18:01:59.534]                         invokeRestart("muffleWarning")
[18:01:59.534]                     }
[18:01:59.534]                     else if (inherits(cond, "condition")) {
[18:01:59.534]                       if (!is.null(pattern)) {
[18:01:59.534]                         computeRestarts <- base::computeRestarts
[18:01:59.534]                         grepl <- base::grepl
[18:01:59.534]                         restarts <- computeRestarts(cond)
[18:01:59.534]                         for (restart in restarts) {
[18:01:59.534]                           name <- restart$name
[18:01:59.534]                           if (is.null(name)) 
[18:01:59.534]                             next
[18:01:59.534]                           if (!grepl(pattern, name)) 
[18:01:59.534]                             next
[18:01:59.534]                           invokeRestart(restart)
[18:01:59.534]                           muffled <- TRUE
[18:01:59.534]                           break
[18:01:59.534]                         }
[18:01:59.534]                       }
[18:01:59.534]                     }
[18:01:59.534]                     invisible(muffled)
[18:01:59.534]                   }
[18:01:59.534]                   muffleCondition(cond)
[18:01:59.534]                 })
[18:01:59.534]             }))
[18:01:59.534]             future::FutureResult(value = ...future.value$value, 
[18:01:59.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.534]                   ...future.rng), globalenv = if (FALSE) 
[18:01:59.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:59.534]                     ...future.globalenv.names))
[18:01:59.534]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:59.534]         }, condition = base::local({
[18:01:59.534]             c <- base::c
[18:01:59.534]             inherits <- base::inherits
[18:01:59.534]             invokeRestart <- base::invokeRestart
[18:01:59.534]             length <- base::length
[18:01:59.534]             list <- base::list
[18:01:59.534]             seq.int <- base::seq.int
[18:01:59.534]             signalCondition <- base::signalCondition
[18:01:59.534]             sys.calls <- base::sys.calls
[18:01:59.534]             `[[` <- base::`[[`
[18:01:59.534]             `+` <- base::`+`
[18:01:59.534]             `<<-` <- base::`<<-`
[18:01:59.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:59.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:59.534]                   3L)]
[18:01:59.534]             }
[18:01:59.534]             function(cond) {
[18:01:59.534]                 is_error <- inherits(cond, "error")
[18:01:59.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:59.534]                   NULL)
[18:01:59.534]                 if (is_error) {
[18:01:59.534]                   sessionInformation <- function() {
[18:01:59.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:59.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:59.534]                       search = base::search(), system = base::Sys.info())
[18:01:59.534]                   }
[18:01:59.534]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:59.534]                     cond$call), session = sessionInformation(), 
[18:01:59.534]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:59.534]                   signalCondition(cond)
[18:01:59.534]                 }
[18:01:59.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:59.534]                 "immediateCondition"))) {
[18:01:59.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:59.534]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:59.534]                   if (TRUE && !signal) {
[18:01:59.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.534]                     {
[18:01:59.534]                       inherits <- base::inherits
[18:01:59.534]                       invokeRestart <- base::invokeRestart
[18:01:59.534]                       is.null <- base::is.null
[18:01:59.534]                       muffled <- FALSE
[18:01:59.534]                       if (inherits(cond, "message")) {
[18:01:59.534]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.534]                         if (muffled) 
[18:01:59.534]                           invokeRestart("muffleMessage")
[18:01:59.534]                       }
[18:01:59.534]                       else if (inherits(cond, "warning")) {
[18:01:59.534]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.534]                         if (muffled) 
[18:01:59.534]                           invokeRestart("muffleWarning")
[18:01:59.534]                       }
[18:01:59.534]                       else if (inherits(cond, "condition")) {
[18:01:59.534]                         if (!is.null(pattern)) {
[18:01:59.534]                           computeRestarts <- base::computeRestarts
[18:01:59.534]                           grepl <- base::grepl
[18:01:59.534]                           restarts <- computeRestarts(cond)
[18:01:59.534]                           for (restart in restarts) {
[18:01:59.534]                             name <- restart$name
[18:01:59.534]                             if (is.null(name)) 
[18:01:59.534]                               next
[18:01:59.534]                             if (!grepl(pattern, name)) 
[18:01:59.534]                               next
[18:01:59.534]                             invokeRestart(restart)
[18:01:59.534]                             muffled <- TRUE
[18:01:59.534]                             break
[18:01:59.534]                           }
[18:01:59.534]                         }
[18:01:59.534]                       }
[18:01:59.534]                       invisible(muffled)
[18:01:59.534]                     }
[18:01:59.534]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.534]                   }
[18:01:59.534]                 }
[18:01:59.534]                 else {
[18:01:59.534]                   if (TRUE) {
[18:01:59.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.534]                     {
[18:01:59.534]                       inherits <- base::inherits
[18:01:59.534]                       invokeRestart <- base::invokeRestart
[18:01:59.534]                       is.null <- base::is.null
[18:01:59.534]                       muffled <- FALSE
[18:01:59.534]                       if (inherits(cond, "message")) {
[18:01:59.534]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.534]                         if (muffled) 
[18:01:59.534]                           invokeRestart("muffleMessage")
[18:01:59.534]                       }
[18:01:59.534]                       else if (inherits(cond, "warning")) {
[18:01:59.534]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.534]                         if (muffled) 
[18:01:59.534]                           invokeRestart("muffleWarning")
[18:01:59.534]                       }
[18:01:59.534]                       else if (inherits(cond, "condition")) {
[18:01:59.534]                         if (!is.null(pattern)) {
[18:01:59.534]                           computeRestarts <- base::computeRestarts
[18:01:59.534]                           grepl <- base::grepl
[18:01:59.534]                           restarts <- computeRestarts(cond)
[18:01:59.534]                           for (restart in restarts) {
[18:01:59.534]                             name <- restart$name
[18:01:59.534]                             if (is.null(name)) 
[18:01:59.534]                               next
[18:01:59.534]                             if (!grepl(pattern, name)) 
[18:01:59.534]                               next
[18:01:59.534]                             invokeRestart(restart)
[18:01:59.534]                             muffled <- TRUE
[18:01:59.534]                             break
[18:01:59.534]                           }
[18:01:59.534]                         }
[18:01:59.534]                       }
[18:01:59.534]                       invisible(muffled)
[18:01:59.534]                     }
[18:01:59.534]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.534]                   }
[18:01:59.534]                 }
[18:01:59.534]             }
[18:01:59.534]         }))
[18:01:59.534]     }, error = function(ex) {
[18:01:59.534]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:59.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.534]                 ...future.rng), started = ...future.startTime, 
[18:01:59.534]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:59.534]             version = "1.8"), class = "FutureResult")
[18:01:59.534]     }, finally = {
[18:01:59.534]         if (!identical(...future.workdir, getwd())) 
[18:01:59.534]             setwd(...future.workdir)
[18:01:59.534]         {
[18:01:59.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:59.534]                 ...future.oldOptions$nwarnings <- NULL
[18:01:59.534]             }
[18:01:59.534]             base::options(...future.oldOptions)
[18:01:59.534]             if (.Platform$OS.type == "windows") {
[18:01:59.534]                 old_names <- names(...future.oldEnvVars)
[18:01:59.534]                 envs <- base::Sys.getenv()
[18:01:59.534]                 names <- names(envs)
[18:01:59.534]                 common <- intersect(names, old_names)
[18:01:59.534]                 added <- setdiff(names, old_names)
[18:01:59.534]                 removed <- setdiff(old_names, names)
[18:01:59.534]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:59.534]                   envs[common]]
[18:01:59.534]                 NAMES <- toupper(changed)
[18:01:59.534]                 args <- list()
[18:01:59.534]                 for (kk in seq_along(NAMES)) {
[18:01:59.534]                   name <- changed[[kk]]
[18:01:59.534]                   NAME <- NAMES[[kk]]
[18:01:59.534]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.534]                     next
[18:01:59.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.534]                 }
[18:01:59.534]                 NAMES <- toupper(added)
[18:01:59.534]                 for (kk in seq_along(NAMES)) {
[18:01:59.534]                   name <- added[[kk]]
[18:01:59.534]                   NAME <- NAMES[[kk]]
[18:01:59.534]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.534]                     next
[18:01:59.534]                   args[[name]] <- ""
[18:01:59.534]                 }
[18:01:59.534]                 NAMES <- toupper(removed)
[18:01:59.534]                 for (kk in seq_along(NAMES)) {
[18:01:59.534]                   name <- removed[[kk]]
[18:01:59.534]                   NAME <- NAMES[[kk]]
[18:01:59.534]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.534]                     next
[18:01:59.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.534]                 }
[18:01:59.534]                 if (length(args) > 0) 
[18:01:59.534]                   base::do.call(base::Sys.setenv, args = args)
[18:01:59.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:59.534]             }
[18:01:59.534]             else {
[18:01:59.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:59.534]             }
[18:01:59.534]             {
[18:01:59.534]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:59.534]                   0L) {
[18:01:59.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:59.534]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:59.534]                   base::options(opts)
[18:01:59.534]                 }
[18:01:59.534]                 {
[18:01:59.534]                   {
[18:01:59.534]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:59.534]                     NULL
[18:01:59.534]                   }
[18:01:59.534]                   options(future.plan = NULL)
[18:01:59.534]                   if (is.na(NA_character_)) 
[18:01:59.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:59.534]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:59.534]                     .init = FALSE)
[18:01:59.534]                 }
[18:01:59.534]             }
[18:01:59.534]         }
[18:01:59.534]     })
[18:01:59.534]     if (TRUE) {
[18:01:59.534]         base::sink(type = "output", split = FALSE)
[18:01:59.534]         if (TRUE) {
[18:01:59.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:59.534]         }
[18:01:59.534]         else {
[18:01:59.534]             ...future.result["stdout"] <- base::list(NULL)
[18:01:59.534]         }
[18:01:59.534]         base::close(...future.stdout)
[18:01:59.534]         ...future.stdout <- NULL
[18:01:59.534]     }
[18:01:59.534]     ...future.result$conditions <- ...future.conditions
[18:01:59.534]     ...future.result$finished <- base::Sys.time()
[18:01:59.534]     ...future.result
[18:01:59.534] }
[18:01:59.540] assign_globals() ...
[18:01:59.541] List of 5
[18:01:59.541]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[18:01:59.541]  $ future.call.arguments    : list()
[18:01:59.541]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.541]  $ ...future.elements_ii    :List of 3
[18:01:59.541]   ..$ : int [1:7] 1 2 3 4 5 6 7
[18:01:59.541]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[18:01:59.541]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[18:01:59.541]  $ ...future.seeds_ii       : NULL
[18:01:59.541]  $ ...future.globals.maxSize: NULL
[18:01:59.541]  - attr(*, "where")=List of 5
[18:01:59.541]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:59.541]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:59.541]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:59.541]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:59.541]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:59.541]  - attr(*, "resolved")= logi FALSE
[18:01:59.541]  - attr(*, "total_size")= num 46960
[18:01:59.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.541]  - attr(*, "already-done")= logi TRUE
[18:01:59.566] - copied ‘...future.FUN’ to environment
[18:01:59.567] - copied ‘future.call.arguments’ to environment
[18:01:59.567] - copied ‘...future.elements_ii’ to environment
[18:01:59.567] - copied ‘...future.seeds_ii’ to environment
[18:01:59.568] - copied ‘...future.globals.maxSize’ to environment
[18:01:59.568] assign_globals() ... done
[18:01:59.569] requestCore(): workers = 2
[18:01:59.573] MulticoreFuture started
[18:01:59.574] - Launch lazy future ... done
[18:01:59.575] run() for ‘MulticoreFuture’ ... done
[18:01:59.576] Created future:
[18:01:59.577] plan(): Setting new future strategy stack:
[18:01:59.578] List of future strategies:
[18:01:59.578] 1. sequential:
[18:01:59.578]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:59.578]    - tweaked: FALSE
[18:01:59.578]    - call: NULL
[18:01:59.581] plan(): nbrOfWorkers() = 1
[18:01:59.586] plan(): Setting new future strategy stack:
[18:01:59.587] List of future strategies:
[18:01:59.587] 1. multicore:
[18:01:59.587]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:59.587]    - tweaked: FALSE
[18:01:59.587]    - call: plan(strategy)
[18:01:59.577] MulticoreFuture:
[18:01:59.577] Label: ‘future_sapply-2’
[18:01:59.577] Expression:
[18:01:59.577] {
[18:01:59.577]     do.call(function(...) {
[18:01:59.577]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.577]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.577]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.577]             on.exit(options(oopts), add = TRUE)
[18:01:59.577]         }
[18:01:59.577]         {
[18:01:59.577]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.577]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.577]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.577]             })
[18:01:59.577]         }
[18:01:59.577]     }, args = future.call.arguments)
[18:01:59.577] }
[18:01:59.577] Lazy evaluation: FALSE
[18:01:59.577] Asynchronous evaluation: TRUE
[18:01:59.577] Local evaluation: TRUE
[18:01:59.577] Environment: R_GlobalEnv
[18:01:59.577] Capture standard output: TRUE
[18:01:59.577] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:59.577] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:59.577] Packages: 1 packages (‘stats’)
[18:01:59.577] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:59.577] Resolved: FALSE
[18:01:59.577] Value: <not collected>
[18:01:59.577] Conditions captured: <none>
[18:01:59.577] Early signaling: FALSE
[18:01:59.577] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:59.577] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:59.594] Chunk #2 of 2 ... DONE
[18:01:59.595] Launching 2 futures (chunks) ... DONE
[18:01:59.595] Resolving 2 futures (chunks) ...
[18:01:59.596] resolve() on list ...
[18:01:59.596]  recursive: 0
[18:01:59.596]  length: 2
[18:01:59.597] 
[18:01:59.598] Future #1
[18:01:59.598] result() for MulticoreFuture ...
[18:01:59.600] result() for MulticoreFuture ...
[18:01:59.599] plan(): nbrOfWorkers() = 2
[18:01:59.601] result() for MulticoreFuture ... done
[18:01:59.603] result() for MulticoreFuture ... done
[18:01:59.604] result() for MulticoreFuture ...
[18:01:59.605] result() for MulticoreFuture ... done
[18:01:59.606] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:59.606] - nx: 2
[18:01:59.606] - relay: TRUE
[18:01:59.607] - stdout: TRUE
[18:01:59.608] - signal: TRUE
[18:01:59.608] - resignal: FALSE
[18:01:59.609] - force: TRUE
[18:01:59.609] - relayed: [n=2] FALSE, FALSE
[18:01:59.609] - queued futures: [n=2] FALSE, FALSE
[18:01:59.610]  - until=1
[18:01:59.610]  - relaying element #1
[18:01:59.610] result() for MulticoreFuture ...
[18:01:59.611] result() for MulticoreFuture ... done
[18:01:59.611] result() for MulticoreFuture ...
[18:01:59.611] result() for MulticoreFuture ... done
[18:01:59.612] result() for MulticoreFuture ...
[18:01:59.612] result() for MulticoreFuture ... done
[18:01:59.612] result() for MulticoreFuture ...
[18:01:59.613] result() for MulticoreFuture ... done
[18:01:59.613] - relayed: [n=2] TRUE, FALSE
[18:01:59.613] - queued futures: [n=2] TRUE, FALSE
[18:01:59.614] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:59.614]  length: 1 (resolved future 1)
[18:01:59.615] Future #2
[18:01:59.615] result() for MulticoreFuture ...
[18:01:59.617] result() for MulticoreFuture ...
[18:01:59.617] result() for MulticoreFuture ... done
[18:01:59.617] result() for MulticoreFuture ... done
[18:01:59.618] result() for MulticoreFuture ...
[18:01:59.618] result() for MulticoreFuture ... done
[18:01:59.618] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:59.618] - nx: 2
[18:01:59.619] - relay: TRUE
[18:01:59.619] - stdout: TRUE
[18:01:59.619] - signal: TRUE
[18:01:59.619] - resignal: FALSE
[18:01:59.619] - force: TRUE
[18:01:59.620] - relayed: [n=2] TRUE, FALSE
[18:01:59.620] - queued futures: [n=2] TRUE, FALSE
[18:01:59.620]  - until=2
[18:01:59.620]  - relaying element #2
[18:01:59.621] result() for MulticoreFuture ...
[18:01:59.621] result() for MulticoreFuture ... done
[18:01:59.621] result() for MulticoreFuture ...
[18:01:59.621] result() for MulticoreFuture ... done
[18:01:59.623] result() for MulticoreFuture ...
[18:01:59.623] result() for MulticoreFuture ... done
[18:01:59.624] result() for MulticoreFuture ...
[18:01:59.624] result() for MulticoreFuture ... done
[18:01:59.624] - relayed: [n=2] TRUE, TRUE
[18:01:59.624] - queued futures: [n=2] TRUE, TRUE
[18:01:59.625] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:59.625]  length: 0 (resolved future 2)
[18:01:59.625] Relaying remaining futures
[18:01:59.625] signalConditionsASAP(NULL, pos=0) ...
[18:01:59.626] - nx: 2
[18:01:59.626] - relay: TRUE
[18:01:59.626] - stdout: TRUE
[18:01:59.626] - signal: TRUE
[18:01:59.627] - resignal: FALSE
[18:01:59.627] - force: TRUE
[18:01:59.627] - relayed: [n=2] TRUE, TRUE
[18:01:59.627] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:59.628] - relayed: [n=2] TRUE, TRUE
[18:01:59.628] - queued futures: [n=2] TRUE, TRUE
[18:01:59.628] signalConditionsASAP(NULL, pos=0) ... done
[18:01:59.628] resolve() on list ... DONE
[18:01:59.629] result() for MulticoreFuture ...
[18:01:59.629] result() for MulticoreFuture ... done
[18:01:59.629] result() for MulticoreFuture ...
[18:01:59.629] result() for MulticoreFuture ... done
[18:01:59.630] result() for MulticoreFuture ...
[18:01:59.630] result() for MulticoreFuture ... done
[18:01:59.630] result() for MulticoreFuture ...
[18:01:59.630] result() for MulticoreFuture ... done
[18:01:59.631]  - Number of value chunks collected: 2
[18:01:59.631] Resolving 2 futures (chunks) ... DONE
[18:01:59.631] Reducing values from 2 chunks ...
[18:01:59.631]  - Number of values collected after concatenation: 7
[18:01:59.632]  - Number of values expected: 7
[18:01:59.632] Reducing values from 2 chunks ... DONE
[18:01:59.632] future_lapply() ... DONE
[18:01:59.634] future_lapply() ...
[18:01:59.645] Number of chunks: 2
[18:01:59.645] getGlobalsAndPackagesXApply() ...
[18:01:59.645]  - future.globals: TRUE
[18:01:59.645] getGlobalsAndPackages() ...
[18:01:59.646] Searching for globals...
[18:01:59.666] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[18:01:59.666] Searching for globals ... DONE
[18:01:59.666] Resolving globals: FALSE
[18:01:59.669] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[18:01:59.670] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[18:01:59.670] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:59.670] - packages: [2] ‘stats’, ‘future.apply’
[18:01:59.670] getGlobalsAndPackages() ... DONE
[18:01:59.671]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:01:59.671]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[18:01:59.671] Finding globals ... DONE
[18:01:59.671]  - use_args: TRUE
[18:01:59.672]  - Getting '...' globals ...
[18:01:59.672] resolve() on list ...
[18:01:59.672]  recursive: 0
[18:01:59.673]  length: 1
[18:01:59.673]  elements: ‘...’
[18:01:59.673]  length: 0 (resolved future 1)
[18:01:59.673] resolve() on list ... DONE
[18:01:59.673]    - '...' content: [n=0] 
[18:01:59.674] List of 1
[18:01:59.674]  $ ...: list()
[18:01:59.674]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.674]  - attr(*, "where")=List of 1
[18:01:59.674]   ..$ ...:<environment: 0x6183c099ca30> 
[18:01:59.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.674]  - attr(*, "resolved")= logi TRUE
[18:01:59.674]  - attr(*, "total_size")= num NA
[18:01:59.679]  - Getting '...' globals ... DONE
[18:01:59.679] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:01:59.679] List of 8
[18:01:59.679]  $ ...future.FUN:function (x, ...)  
[18:01:59.679]  $ x_FUN        :function (x, na.rm = TRUE)  
[18:01:59.679]  $ times        : int 5
[18:01:59.679]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:59.679]  $ stop_if_not  :function (...)  
[18:01:59.679]  $ dim          : NULL
[18:01:59.679]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:01:59.679]  $ ...          : list()
[18:01:59.679]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.679]  - attr(*, "where")=List of 8
[18:01:59.679]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:59.679]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:01:59.679]   ..$ times        :<environment: R_EmptyEnv> 
[18:01:59.679]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:01:59.679]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:01:59.679]   ..$ dim          :<environment: R_EmptyEnv> 
[18:01:59.679]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:01:59.679]   ..$ ...          :<environment: 0x6183c099ca30> 
[18:01:59.679]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.679]  - attr(*, "resolved")= logi FALSE
[18:01:59.679]  - attr(*, "total_size")= num 141240
[18:01:59.694] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[18:01:59.694] getGlobalsAndPackagesXApply() ... DONE
[18:01:59.694] Number of futures (= number of chunks): 2
[18:01:59.695] Launching 2 futures (chunks) ...
[18:01:59.695] Chunk #1 of 2 ...
[18:01:59.695]  - Finding globals in 'X' for chunk #1 ...
[18:01:59.695] getGlobalsAndPackages() ...
[18:01:59.696] Searching for globals...
[18:01:59.696] 
[18:01:59.696] Searching for globals ... DONE
[18:01:59.696] - globals: [0] <none>
[18:01:59.697] getGlobalsAndPackages() ... DONE
[18:01:59.697]    + additional globals found: [n=0] 
[18:01:59.697]    + additional namespaces needed: [n=0] 
[18:01:59.697]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:59.697]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:59.698]  - seeds: <none>
[18:01:59.698]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.698] getGlobalsAndPackages() ...
[18:01:59.698] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.699] Resolving globals: FALSE
[18:01:59.699] Tweak future expression to call with '...' arguments ...
[18:01:59.699] {
[18:01:59.699]     do.call(function(...) {
[18:01:59.699]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.699]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.699]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.699]             on.exit(options(oopts), add = TRUE)
[18:01:59.699]         }
[18:01:59.699]         {
[18:01:59.699]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.699]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.699]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.699]             })
[18:01:59.699]         }
[18:01:59.699]     }, args = future.call.arguments)
[18:01:59.699] }
[18:01:59.700] Tweak future expression to call with '...' arguments ... DONE
[18:01:59.701] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.701] - packages: [2] ‘stats’, ‘future.apply’
[18:01:59.701] getGlobalsAndPackages() ... DONE
[18:01:59.702] run() for ‘Future’ ...
[18:01:59.702] - state: ‘created’
[18:01:59.702] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:59.709] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:59.709] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:59.709]   - Field: ‘label’
[18:01:59.710]   - Field: ‘local’
[18:01:59.710]   - Field: ‘owner’
[18:01:59.710]   - Field: ‘envir’
[18:01:59.710]   - Field: ‘workers’
[18:01:59.710]   - Field: ‘packages’
[18:01:59.711]   - Field: ‘gc’
[18:01:59.711]   - Field: ‘job’
[18:01:59.711]   - Field: ‘conditions’
[18:01:59.711]   - Field: ‘expr’
[18:01:59.712]   - Field: ‘uuid’
[18:01:59.712]   - Field: ‘seed’
[18:01:59.712]   - Field: ‘version’
[18:01:59.712]   - Field: ‘result’
[18:01:59.712]   - Field: ‘asynchronous’
[18:01:59.713]   - Field: ‘calls’
[18:01:59.713]   - Field: ‘globals’
[18:01:59.713]   - Field: ‘stdout’
[18:01:59.713]   - Field: ‘earlySignal’
[18:01:59.713]   - Field: ‘lazy’
[18:01:59.714]   - Field: ‘state’
[18:01:59.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:59.714] - Launch lazy future ...
[18:01:59.715] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[18:01:59.715] Packages needed by future strategies (n = 0): <none>
[18:01:59.716] {
[18:01:59.716]     {
[18:01:59.716]         {
[18:01:59.716]             ...future.startTime <- base::Sys.time()
[18:01:59.716]             {
[18:01:59.716]                 {
[18:01:59.716]                   {
[18:01:59.716]                     {
[18:01:59.716]                       {
[18:01:59.716]                         base::local({
[18:01:59.716]                           has_future <- base::requireNamespace("future", 
[18:01:59.716]                             quietly = TRUE)
[18:01:59.716]                           if (has_future) {
[18:01:59.716]                             ns <- base::getNamespace("future")
[18:01:59.716]                             version <- ns[[".package"]][["version"]]
[18:01:59.716]                             if (is.null(version)) 
[18:01:59.716]                               version <- utils::packageVersion("future")
[18:01:59.716]                           }
[18:01:59.716]                           else {
[18:01:59.716]                             version <- NULL
[18:01:59.716]                           }
[18:01:59.716]                           if (!has_future || version < "1.8.0") {
[18:01:59.716]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:59.716]                               "", base::R.version$version.string), 
[18:01:59.716]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:59.716]                                 base::R.version$platform, 8 * 
[18:01:59.716]                                   base::.Machine$sizeof.pointer), 
[18:01:59.716]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:59.716]                                 "release", "version")], collapse = " "), 
[18:01:59.716]                               hostname = base::Sys.info()[["nodename"]])
[18:01:59.716]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:59.716]                               info)
[18:01:59.716]                             info <- base::paste(info, collapse = "; ")
[18:01:59.716]                             if (!has_future) {
[18:01:59.716]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:59.716]                                 info)
[18:01:59.716]                             }
[18:01:59.716]                             else {
[18:01:59.716]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:59.716]                                 info, version)
[18:01:59.716]                             }
[18:01:59.716]                             base::stop(msg)
[18:01:59.716]                           }
[18:01:59.716]                         })
[18:01:59.716]                       }
[18:01:59.716]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:59.716]                       base::options(mc.cores = 1L)
[18:01:59.716]                     }
[18:01:59.716]                     base::local({
[18:01:59.716]                       for (pkg in c("stats", "future.apply")) {
[18:01:59.716]                         base::loadNamespace(pkg)
[18:01:59.716]                         base::library(pkg, character.only = TRUE)
[18:01:59.716]                       }
[18:01:59.716]                     })
[18:01:59.716]                   }
[18:01:59.716]                   ...future.strategy.old <- future::plan("list")
[18:01:59.716]                   options(future.plan = NULL)
[18:01:59.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:59.716]                 }
[18:01:59.716]                 ...future.workdir <- getwd()
[18:01:59.716]             }
[18:01:59.716]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:59.716]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:59.716]         }
[18:01:59.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:59.716]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:59.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:59.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:59.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:59.716]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:59.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:59.716]             base::names(...future.oldOptions))
[18:01:59.716]     }
[18:01:59.716]     if (FALSE) {
[18:01:59.716]     }
[18:01:59.716]     else {
[18:01:59.716]         if (TRUE) {
[18:01:59.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:59.716]                 open = "w")
[18:01:59.716]         }
[18:01:59.716]         else {
[18:01:59.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:59.716]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:59.716]         }
[18:01:59.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:59.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:59.716]             base::sink(type = "output", split = FALSE)
[18:01:59.716]             base::close(...future.stdout)
[18:01:59.716]         }, add = TRUE)
[18:01:59.716]     }
[18:01:59.716]     ...future.frame <- base::sys.nframe()
[18:01:59.716]     ...future.conditions <- base::list()
[18:01:59.716]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:59.716]     if (FALSE) {
[18:01:59.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:59.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:59.716]     }
[18:01:59.716]     ...future.result <- base::tryCatch({
[18:01:59.716]         base::withCallingHandlers({
[18:01:59.716]             ...future.value <- base::withVisible(base::local({
[18:01:59.716]                 withCallingHandlers({
[18:01:59.716]                   {
[18:01:59.716]                     do.call(function(...) {
[18:01:59.716]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.716]                       if (!identical(...future.globals.maxSize.org, 
[18:01:59.716]                         ...future.globals.maxSize)) {
[18:01:59.716]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.716]                         on.exit(options(oopts), add = TRUE)
[18:01:59.716]                       }
[18:01:59.716]                       {
[18:01:59.716]                         lapply(seq_along(...future.elements_ii), 
[18:01:59.716]                           FUN = function(jj) {
[18:01:59.716]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.716]                             ...future.FUN(...future.X_jj, ...)
[18:01:59.716]                           })
[18:01:59.716]                       }
[18:01:59.716]                     }, args = future.call.arguments)
[18:01:59.716]                   }
[18:01:59.716]                 }, immediateCondition = function(cond) {
[18:01:59.716]                   save_rds <- function (object, pathname, ...) 
[18:01:59.716]                   {
[18:01:59.716]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:59.716]                     if (file_test("-f", pathname_tmp)) {
[18:01:59.716]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.716]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:59.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.716]                         fi_tmp[["mtime"]])
[18:01:59.716]                     }
[18:01:59.716]                     tryCatch({
[18:01:59.716]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:59.716]                     }, error = function(ex) {
[18:01:59.716]                       msg <- conditionMessage(ex)
[18:01:59.716]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.716]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:59.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.716]                         fi_tmp[["mtime"]], msg)
[18:01:59.716]                       ex$message <- msg
[18:01:59.716]                       stop(ex)
[18:01:59.716]                     })
[18:01:59.716]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:59.716]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:59.716]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:59.716]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.716]                       fi <- file.info(pathname)
[18:01:59.716]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:59.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.716]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:59.716]                         fi[["size"]], fi[["mtime"]])
[18:01:59.716]                       stop(msg)
[18:01:59.716]                     }
[18:01:59.716]                     invisible(pathname)
[18:01:59.716]                   }
[18:01:59.716]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:59.716]                     rootPath = tempdir()) 
[18:01:59.716]                   {
[18:01:59.716]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:59.716]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:59.716]                       tmpdir = path, fileext = ".rds")
[18:01:59.716]                     save_rds(obj, file)
[18:01:59.716]                   }
[18:01:59.716]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:59.716]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.716]                   {
[18:01:59.716]                     inherits <- base::inherits
[18:01:59.716]                     invokeRestart <- base::invokeRestart
[18:01:59.716]                     is.null <- base::is.null
[18:01:59.716]                     muffled <- FALSE
[18:01:59.716]                     if (inherits(cond, "message")) {
[18:01:59.716]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:59.716]                       if (muffled) 
[18:01:59.716]                         invokeRestart("muffleMessage")
[18:01:59.716]                     }
[18:01:59.716]                     else if (inherits(cond, "warning")) {
[18:01:59.716]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:59.716]                       if (muffled) 
[18:01:59.716]                         invokeRestart("muffleWarning")
[18:01:59.716]                     }
[18:01:59.716]                     else if (inherits(cond, "condition")) {
[18:01:59.716]                       if (!is.null(pattern)) {
[18:01:59.716]                         computeRestarts <- base::computeRestarts
[18:01:59.716]                         grepl <- base::grepl
[18:01:59.716]                         restarts <- computeRestarts(cond)
[18:01:59.716]                         for (restart in restarts) {
[18:01:59.716]                           name <- restart$name
[18:01:59.716]                           if (is.null(name)) 
[18:01:59.716]                             next
[18:01:59.716]                           if (!grepl(pattern, name)) 
[18:01:59.716]                             next
[18:01:59.716]                           invokeRestart(restart)
[18:01:59.716]                           muffled <- TRUE
[18:01:59.716]                           break
[18:01:59.716]                         }
[18:01:59.716]                       }
[18:01:59.716]                     }
[18:01:59.716]                     invisible(muffled)
[18:01:59.716]                   }
[18:01:59.716]                   muffleCondition(cond)
[18:01:59.716]                 })
[18:01:59.716]             }))
[18:01:59.716]             future::FutureResult(value = ...future.value$value, 
[18:01:59.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.716]                   ...future.rng), globalenv = if (FALSE) 
[18:01:59.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:59.716]                     ...future.globalenv.names))
[18:01:59.716]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:59.716]         }, condition = base::local({
[18:01:59.716]             c <- base::c
[18:01:59.716]             inherits <- base::inherits
[18:01:59.716]             invokeRestart <- base::invokeRestart
[18:01:59.716]             length <- base::length
[18:01:59.716]             list <- base::list
[18:01:59.716]             seq.int <- base::seq.int
[18:01:59.716]             signalCondition <- base::signalCondition
[18:01:59.716]             sys.calls <- base::sys.calls
[18:01:59.716]             `[[` <- base::`[[`
[18:01:59.716]             `+` <- base::`+`
[18:01:59.716]             `<<-` <- base::`<<-`
[18:01:59.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:59.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:59.716]                   3L)]
[18:01:59.716]             }
[18:01:59.716]             function(cond) {
[18:01:59.716]                 is_error <- inherits(cond, "error")
[18:01:59.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:59.716]                   NULL)
[18:01:59.716]                 if (is_error) {
[18:01:59.716]                   sessionInformation <- function() {
[18:01:59.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:59.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:59.716]                       search = base::search(), system = base::Sys.info())
[18:01:59.716]                   }
[18:01:59.716]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:59.716]                     cond$call), session = sessionInformation(), 
[18:01:59.716]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:59.716]                   signalCondition(cond)
[18:01:59.716]                 }
[18:01:59.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:59.716]                 "immediateCondition"))) {
[18:01:59.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:59.716]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:59.716]                   if (TRUE && !signal) {
[18:01:59.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.716]                     {
[18:01:59.716]                       inherits <- base::inherits
[18:01:59.716]                       invokeRestart <- base::invokeRestart
[18:01:59.716]                       is.null <- base::is.null
[18:01:59.716]                       muffled <- FALSE
[18:01:59.716]                       if (inherits(cond, "message")) {
[18:01:59.716]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.716]                         if (muffled) 
[18:01:59.716]                           invokeRestart("muffleMessage")
[18:01:59.716]                       }
[18:01:59.716]                       else if (inherits(cond, "warning")) {
[18:01:59.716]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.716]                         if (muffled) 
[18:01:59.716]                           invokeRestart("muffleWarning")
[18:01:59.716]                       }
[18:01:59.716]                       else if (inherits(cond, "condition")) {
[18:01:59.716]                         if (!is.null(pattern)) {
[18:01:59.716]                           computeRestarts <- base::computeRestarts
[18:01:59.716]                           grepl <- base::grepl
[18:01:59.716]                           restarts <- computeRestarts(cond)
[18:01:59.716]                           for (restart in restarts) {
[18:01:59.716]                             name <- restart$name
[18:01:59.716]                             if (is.null(name)) 
[18:01:59.716]                               next
[18:01:59.716]                             if (!grepl(pattern, name)) 
[18:01:59.716]                               next
[18:01:59.716]                             invokeRestart(restart)
[18:01:59.716]                             muffled <- TRUE
[18:01:59.716]                             break
[18:01:59.716]                           }
[18:01:59.716]                         }
[18:01:59.716]                       }
[18:01:59.716]                       invisible(muffled)
[18:01:59.716]                     }
[18:01:59.716]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.716]                   }
[18:01:59.716]                 }
[18:01:59.716]                 else {
[18:01:59.716]                   if (TRUE) {
[18:01:59.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.716]                     {
[18:01:59.716]                       inherits <- base::inherits
[18:01:59.716]                       invokeRestart <- base::invokeRestart
[18:01:59.716]                       is.null <- base::is.null
[18:01:59.716]                       muffled <- FALSE
[18:01:59.716]                       if (inherits(cond, "message")) {
[18:01:59.716]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.716]                         if (muffled) 
[18:01:59.716]                           invokeRestart("muffleMessage")
[18:01:59.716]                       }
[18:01:59.716]                       else if (inherits(cond, "warning")) {
[18:01:59.716]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.716]                         if (muffled) 
[18:01:59.716]                           invokeRestart("muffleWarning")
[18:01:59.716]                       }
[18:01:59.716]                       else if (inherits(cond, "condition")) {
[18:01:59.716]                         if (!is.null(pattern)) {
[18:01:59.716]                           computeRestarts <- base::computeRestarts
[18:01:59.716]                           grepl <- base::grepl
[18:01:59.716]                           restarts <- computeRestarts(cond)
[18:01:59.716]                           for (restart in restarts) {
[18:01:59.716]                             name <- restart$name
[18:01:59.716]                             if (is.null(name)) 
[18:01:59.716]                               next
[18:01:59.716]                             if (!grepl(pattern, name)) 
[18:01:59.716]                               next
[18:01:59.716]                             invokeRestart(restart)
[18:01:59.716]                             muffled <- TRUE
[18:01:59.716]                             break
[18:01:59.716]                           }
[18:01:59.716]                         }
[18:01:59.716]                       }
[18:01:59.716]                       invisible(muffled)
[18:01:59.716]                     }
[18:01:59.716]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.716]                   }
[18:01:59.716]                 }
[18:01:59.716]             }
[18:01:59.716]         }))
[18:01:59.716]     }, error = function(ex) {
[18:01:59.716]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:59.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.716]                 ...future.rng), started = ...future.startTime, 
[18:01:59.716]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:59.716]             version = "1.8"), class = "FutureResult")
[18:01:59.716]     }, finally = {
[18:01:59.716]         if (!identical(...future.workdir, getwd())) 
[18:01:59.716]             setwd(...future.workdir)
[18:01:59.716]         {
[18:01:59.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:59.716]                 ...future.oldOptions$nwarnings <- NULL
[18:01:59.716]             }
[18:01:59.716]             base::options(...future.oldOptions)
[18:01:59.716]             if (.Platform$OS.type == "windows") {
[18:01:59.716]                 old_names <- names(...future.oldEnvVars)
[18:01:59.716]                 envs <- base::Sys.getenv()
[18:01:59.716]                 names <- names(envs)
[18:01:59.716]                 common <- intersect(names, old_names)
[18:01:59.716]                 added <- setdiff(names, old_names)
[18:01:59.716]                 removed <- setdiff(old_names, names)
[18:01:59.716]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:59.716]                   envs[common]]
[18:01:59.716]                 NAMES <- toupper(changed)
[18:01:59.716]                 args <- list()
[18:01:59.716]                 for (kk in seq_along(NAMES)) {
[18:01:59.716]                   name <- changed[[kk]]
[18:01:59.716]                   NAME <- NAMES[[kk]]
[18:01:59.716]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.716]                     next
[18:01:59.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.716]                 }
[18:01:59.716]                 NAMES <- toupper(added)
[18:01:59.716]                 for (kk in seq_along(NAMES)) {
[18:01:59.716]                   name <- added[[kk]]
[18:01:59.716]                   NAME <- NAMES[[kk]]
[18:01:59.716]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.716]                     next
[18:01:59.716]                   args[[name]] <- ""
[18:01:59.716]                 }
[18:01:59.716]                 NAMES <- toupper(removed)
[18:01:59.716]                 for (kk in seq_along(NAMES)) {
[18:01:59.716]                   name <- removed[[kk]]
[18:01:59.716]                   NAME <- NAMES[[kk]]
[18:01:59.716]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.716]                     next
[18:01:59.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.716]                 }
[18:01:59.716]                 if (length(args) > 0) 
[18:01:59.716]                   base::do.call(base::Sys.setenv, args = args)
[18:01:59.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:59.716]             }
[18:01:59.716]             else {
[18:01:59.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:59.716]             }
[18:01:59.716]             {
[18:01:59.716]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:59.716]                   0L) {
[18:01:59.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:59.716]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:59.716]                   base::options(opts)
[18:01:59.716]                 }
[18:01:59.716]                 {
[18:01:59.716]                   {
[18:01:59.716]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:59.716]                     NULL
[18:01:59.716]                   }
[18:01:59.716]                   options(future.plan = NULL)
[18:01:59.716]                   if (is.na(NA_character_)) 
[18:01:59.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:59.716]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:59.716]                     .init = FALSE)
[18:01:59.716]                 }
[18:01:59.716]             }
[18:01:59.716]         }
[18:01:59.716]     })
[18:01:59.716]     if (TRUE) {
[18:01:59.716]         base::sink(type = "output", split = FALSE)
[18:01:59.716]         if (TRUE) {
[18:01:59.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:59.716]         }
[18:01:59.716]         else {
[18:01:59.716]             ...future.result["stdout"] <- base::list(NULL)
[18:01:59.716]         }
[18:01:59.716]         base::close(...future.stdout)
[18:01:59.716]         ...future.stdout <- NULL
[18:01:59.716]     }
[18:01:59.716]     ...future.result$conditions <- ...future.conditions
[18:01:59.716]     ...future.result$finished <- base::Sys.time()
[18:01:59.716]     ...future.result
[18:01:59.716] }
[18:01:59.721] assign_globals() ...
[18:01:59.721] List of 11
[18:01:59.721]  $ ...future.FUN            :function (x, ...)  
[18:01:59.721]  $ x_FUN                    :function (x, na.rm = TRUE)  
[18:01:59.721]  $ times                    : int 5
[18:01:59.721]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:59.721]  $ stop_if_not              :function (...)  
[18:01:59.721]  $ dim                      : NULL
[18:01:59.721]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:59.721]  $ future.call.arguments    : list()
[18:01:59.721]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.721]  $ ...future.elements_ii    :List of 4
[18:01:59.721]   ..$ : int [1:3] 1 2 3
[18:01:59.721]   ..$ : int [1:4] 1 2 3 4
[18:01:59.721]   ..$ : int [1:5] 1 2 3 4 5
[18:01:59.721]   ..$ : int [1:6] 1 2 3 4 5 6
[18:01:59.721]  $ ...future.seeds_ii       : NULL
[18:01:59.721]  $ ...future.globals.maxSize: NULL
[18:01:59.721]  - attr(*, "where")=List of 11
[18:01:59.721]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:59.721]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:59.721]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:59.721]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:59.721]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:59.721]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:59.721]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:59.721]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:59.721]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:59.721]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:59.721]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:59.721]  - attr(*, "resolved")= logi FALSE
[18:01:59.721]  - attr(*, "total_size")= num 141240
[18:01:59.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.721]  - attr(*, "already-done")= logi TRUE
[18:01:59.741] - copied ‘...future.FUN’ to environment
[18:01:59.742] - copied ‘x_FUN’ to environment
[18:01:59.742] - copied ‘times’ to environment
[18:01:59.742] - copied ‘stopf’ to environment
[18:01:59.742] - copied ‘stop_if_not’ to environment
[18:01:59.743] - copied ‘dim’ to environment
[18:01:59.743] - copied ‘valid_types’ to environment
[18:01:59.743] - copied ‘future.call.arguments’ to environment
[18:01:59.743] - copied ‘...future.elements_ii’ to environment
[18:01:59.744] - copied ‘...future.seeds_ii’ to environment
[18:01:59.744] - copied ‘...future.globals.maxSize’ to environment
[18:01:59.744] assign_globals() ... done
[18:01:59.744] requestCore(): workers = 2
[18:01:59.748] MulticoreFuture started
[18:01:59.749] - Launch lazy future ... done
[18:01:59.750] run() for ‘MulticoreFuture’ ... done
[18:01:59.751] Created future:
[18:01:59.753] plan(): Setting new future strategy stack:
[18:01:59.754] List of future strategies:
[18:01:59.754] 1. sequential:
[18:01:59.754]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:59.754]    - tweaked: FALSE
[18:01:59.754]    - call: NULL
[18:01:59.757] plan(): nbrOfWorkers() = 1
[18:01:59.763] plan(): Setting new future strategy stack:
[18:01:59.764] List of future strategies:
[18:01:59.764] 1. multicore:
[18:01:59.764]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:59.764]    - tweaked: FALSE
[18:01:59.764]    - call: plan(strategy)
[18:01:59.752] MulticoreFuture:
[18:01:59.752] Label: ‘future_vapply-1’
[18:01:59.752] Expression:
[18:01:59.752] {
[18:01:59.752]     do.call(function(...) {
[18:01:59.752]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.752]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.752]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.752]             on.exit(options(oopts), add = TRUE)
[18:01:59.752]         }
[18:01:59.752]         {
[18:01:59.752]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.752]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.752]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.752]             })
[18:01:59.752]         }
[18:01:59.752]     }, args = future.call.arguments)
[18:01:59.752] }
[18:01:59.752] Lazy evaluation: FALSE
[18:01:59.752] Asynchronous evaluation: TRUE
[18:01:59.752] Local evaluation: TRUE
[18:01:59.752] Environment: R_GlobalEnv
[18:01:59.752] Capture standard output: TRUE
[18:01:59.752] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:59.752] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:59.752] Packages: 2 packages (‘stats’, ‘future.apply’)
[18:01:59.752] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:59.752] Resolved: FALSE
[18:01:59.752] Value: <not collected>
[18:01:59.752] Conditions captured: <none>
[18:01:59.752] Early signaling: FALSE
[18:01:59.752] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:59.752] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:59.771] Chunk #1 of 2 ... DONE
[18:01:59.772] Chunk #2 of 2 ...
[18:01:59.773]  - Finding globals in 'X' for chunk #2 ...
[18:01:59.773] getGlobalsAndPackages() ...
[18:01:59.773] Searching for globals...
[18:01:59.774] plan(): nbrOfWorkers() = 2
[18:01:59.775] 
[18:01:59.775] Searching for globals ... DONE
[18:01:59.775] - globals: [0] <none>
[18:01:59.775] getGlobalsAndPackages() ... DONE
[18:01:59.776]    + additional globals found: [n=0] 
[18:01:59.776]    + additional namespaces needed: [n=0] 
[18:01:59.776]  - Finding globals in 'X' for chunk #2 ... DONE
[18:01:59.776]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:59.777]  - seeds: <none>
[18:01:59.777]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.777] getGlobalsAndPackages() ...
[18:01:59.778] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.778] Resolving globals: FALSE
[18:01:59.779] Tweak future expression to call with '...' arguments ...
[18:01:59.779] {
[18:01:59.779]     do.call(function(...) {
[18:01:59.779]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.779]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.779]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.779]             on.exit(options(oopts), add = TRUE)
[18:01:59.779]         }
[18:01:59.779]         {
[18:01:59.779]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.779]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.779]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.779]             })
[18:01:59.779]         }
[18:01:59.779]     }, args = future.call.arguments)
[18:01:59.779] }
[18:01:59.780] Tweak future expression to call with '...' arguments ... DONE
[18:01:59.782] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.782] - packages: [2] ‘stats’, ‘future.apply’
[18:01:59.782] getGlobalsAndPackages() ... DONE
[18:01:59.783] run() for ‘Future’ ...
[18:01:59.784] - state: ‘created’
[18:01:59.784] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:59.793] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:59.793] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:59.793]   - Field: ‘label’
[18:01:59.794]   - Field: ‘local’
[18:01:59.794]   - Field: ‘owner’
[18:01:59.794]   - Field: ‘envir’
[18:01:59.794]   - Field: ‘workers’
[18:01:59.795]   - Field: ‘packages’
[18:01:59.795]   - Field: ‘gc’
[18:01:59.795]   - Field: ‘job’
[18:01:59.795]   - Field: ‘conditions’
[18:01:59.796]   - Field: ‘expr’
[18:01:59.796]   - Field: ‘uuid’
[18:01:59.796]   - Field: ‘seed’
[18:01:59.797]   - Field: ‘version’
[18:01:59.797]   - Field: ‘result’
[18:01:59.797]   - Field: ‘asynchronous’
[18:01:59.797]   - Field: ‘calls’
[18:01:59.798]   - Field: ‘globals’
[18:01:59.798]   - Field: ‘stdout’
[18:01:59.798]   - Field: ‘earlySignal’
[18:01:59.798]   - Field: ‘lazy’
[18:01:59.799]   - Field: ‘state’
[18:01:59.799] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:59.799] - Launch lazy future ...
[18:01:59.800] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[18:01:59.801] Packages needed by future strategies (n = 0): <none>
[18:01:59.802] {
[18:01:59.802]     {
[18:01:59.802]         {
[18:01:59.802]             ...future.startTime <- base::Sys.time()
[18:01:59.802]             {
[18:01:59.802]                 {
[18:01:59.802]                   {
[18:01:59.802]                     {
[18:01:59.802]                       {
[18:01:59.802]                         base::local({
[18:01:59.802]                           has_future <- base::requireNamespace("future", 
[18:01:59.802]                             quietly = TRUE)
[18:01:59.802]                           if (has_future) {
[18:01:59.802]                             ns <- base::getNamespace("future")
[18:01:59.802]                             version <- ns[[".package"]][["version"]]
[18:01:59.802]                             if (is.null(version)) 
[18:01:59.802]                               version <- utils::packageVersion("future")
[18:01:59.802]                           }
[18:01:59.802]                           else {
[18:01:59.802]                             version <- NULL
[18:01:59.802]                           }
[18:01:59.802]                           if (!has_future || version < "1.8.0") {
[18:01:59.802]                             info <- base::c(r_version = base::gsub("R version ", 
[18:01:59.802]                               "", base::R.version$version.string), 
[18:01:59.802]                               platform = base::sprintf("%s (%s-bit)", 
[18:01:59.802]                                 base::R.version$platform, 8 * 
[18:01:59.802]                                   base::.Machine$sizeof.pointer), 
[18:01:59.802]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:59.802]                                 "release", "version")], collapse = " "), 
[18:01:59.802]                               hostname = base::Sys.info()[["nodename"]])
[18:01:59.802]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:01:59.802]                               info)
[18:01:59.802]                             info <- base::paste(info, collapse = "; ")
[18:01:59.802]                             if (!has_future) {
[18:01:59.802]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:59.802]                                 info)
[18:01:59.802]                             }
[18:01:59.802]                             else {
[18:01:59.802]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:59.802]                                 info, version)
[18:01:59.802]                             }
[18:01:59.802]                             base::stop(msg)
[18:01:59.802]                           }
[18:01:59.802]                         })
[18:01:59.802]                       }
[18:01:59.802]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:59.802]                       base::options(mc.cores = 1L)
[18:01:59.802]                     }
[18:01:59.802]                     base::local({
[18:01:59.802]                       for (pkg in c("stats", "future.apply")) {
[18:01:59.802]                         base::loadNamespace(pkg)
[18:01:59.802]                         base::library(pkg, character.only = TRUE)
[18:01:59.802]                       }
[18:01:59.802]                     })
[18:01:59.802]                   }
[18:01:59.802]                   ...future.strategy.old <- future::plan("list")
[18:01:59.802]                   options(future.plan = NULL)
[18:01:59.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:59.802]                 }
[18:01:59.802]                 ...future.workdir <- getwd()
[18:01:59.802]             }
[18:01:59.802]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:59.802]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:59.802]         }
[18:01:59.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:59.802]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:59.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:59.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:59.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:59.802]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:59.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:59.802]             base::names(...future.oldOptions))
[18:01:59.802]     }
[18:01:59.802]     if (FALSE) {
[18:01:59.802]     }
[18:01:59.802]     else {
[18:01:59.802]         if (TRUE) {
[18:01:59.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:59.802]                 open = "w")
[18:01:59.802]         }
[18:01:59.802]         else {
[18:01:59.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:59.802]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:59.802]         }
[18:01:59.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:59.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:59.802]             base::sink(type = "output", split = FALSE)
[18:01:59.802]             base::close(...future.stdout)
[18:01:59.802]         }, add = TRUE)
[18:01:59.802]     }
[18:01:59.802]     ...future.frame <- base::sys.nframe()
[18:01:59.802]     ...future.conditions <- base::list()
[18:01:59.802]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:59.802]     if (FALSE) {
[18:01:59.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:59.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:59.802]     }
[18:01:59.802]     ...future.result <- base::tryCatch({
[18:01:59.802]         base::withCallingHandlers({
[18:01:59.802]             ...future.value <- base::withVisible(base::local({
[18:01:59.802]                 withCallingHandlers({
[18:01:59.802]                   {
[18:01:59.802]                     do.call(function(...) {
[18:01:59.802]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.802]                       if (!identical(...future.globals.maxSize.org, 
[18:01:59.802]                         ...future.globals.maxSize)) {
[18:01:59.802]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.802]                         on.exit(options(oopts), add = TRUE)
[18:01:59.802]                       }
[18:01:59.802]                       {
[18:01:59.802]                         lapply(seq_along(...future.elements_ii), 
[18:01:59.802]                           FUN = function(jj) {
[18:01:59.802]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.802]                             ...future.FUN(...future.X_jj, ...)
[18:01:59.802]                           })
[18:01:59.802]                       }
[18:01:59.802]                     }, args = future.call.arguments)
[18:01:59.802]                   }
[18:01:59.802]                 }, immediateCondition = function(cond) {
[18:01:59.802]                   save_rds <- function (object, pathname, ...) 
[18:01:59.802]                   {
[18:01:59.802]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:59.802]                     if (file_test("-f", pathname_tmp)) {
[18:01:59.802]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.802]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:59.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.802]                         fi_tmp[["mtime"]])
[18:01:59.802]                     }
[18:01:59.802]                     tryCatch({
[18:01:59.802]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:59.802]                     }, error = function(ex) {
[18:01:59.802]                       msg <- conditionMessage(ex)
[18:01:59.802]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.802]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:59.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.802]                         fi_tmp[["mtime"]], msg)
[18:01:59.802]                       ex$message <- msg
[18:01:59.802]                       stop(ex)
[18:01:59.802]                     })
[18:01:59.802]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:59.802]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:59.802]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:59.802]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.802]                       fi <- file.info(pathname)
[18:01:59.802]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:59.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.802]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:59.802]                         fi[["size"]], fi[["mtime"]])
[18:01:59.802]                       stop(msg)
[18:01:59.802]                     }
[18:01:59.802]                     invisible(pathname)
[18:01:59.802]                   }
[18:01:59.802]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:59.802]                     rootPath = tempdir()) 
[18:01:59.802]                   {
[18:01:59.802]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:59.802]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:59.802]                       tmpdir = path, fileext = ".rds")
[18:01:59.802]                     save_rds(obj, file)
[18:01:59.802]                   }
[18:01:59.802]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:59.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.802]                   {
[18:01:59.802]                     inherits <- base::inherits
[18:01:59.802]                     invokeRestart <- base::invokeRestart
[18:01:59.802]                     is.null <- base::is.null
[18:01:59.802]                     muffled <- FALSE
[18:01:59.802]                     if (inherits(cond, "message")) {
[18:01:59.802]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:59.802]                       if (muffled) 
[18:01:59.802]                         invokeRestart("muffleMessage")
[18:01:59.802]                     }
[18:01:59.802]                     else if (inherits(cond, "warning")) {
[18:01:59.802]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:59.802]                       if (muffled) 
[18:01:59.802]                         invokeRestart("muffleWarning")
[18:01:59.802]                     }
[18:01:59.802]                     else if (inherits(cond, "condition")) {
[18:01:59.802]                       if (!is.null(pattern)) {
[18:01:59.802]                         computeRestarts <- base::computeRestarts
[18:01:59.802]                         grepl <- base::grepl
[18:01:59.802]                         restarts <- computeRestarts(cond)
[18:01:59.802]                         for (restart in restarts) {
[18:01:59.802]                           name <- restart$name
[18:01:59.802]                           if (is.null(name)) 
[18:01:59.802]                             next
[18:01:59.802]                           if (!grepl(pattern, name)) 
[18:01:59.802]                             next
[18:01:59.802]                           invokeRestart(restart)
[18:01:59.802]                           muffled <- TRUE
[18:01:59.802]                           break
[18:01:59.802]                         }
[18:01:59.802]                       }
[18:01:59.802]                     }
[18:01:59.802]                     invisible(muffled)
[18:01:59.802]                   }
[18:01:59.802]                   muffleCondition(cond)
[18:01:59.802]                 })
[18:01:59.802]             }))
[18:01:59.802]             future::FutureResult(value = ...future.value$value, 
[18:01:59.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.802]                   ...future.rng), globalenv = if (FALSE) 
[18:01:59.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:59.802]                     ...future.globalenv.names))
[18:01:59.802]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:59.802]         }, condition = base::local({
[18:01:59.802]             c <- base::c
[18:01:59.802]             inherits <- base::inherits
[18:01:59.802]             invokeRestart <- base::invokeRestart
[18:01:59.802]             length <- base::length
[18:01:59.802]             list <- base::list
[18:01:59.802]             seq.int <- base::seq.int
[18:01:59.802]             signalCondition <- base::signalCondition
[18:01:59.802]             sys.calls <- base::sys.calls
[18:01:59.802]             `[[` <- base::`[[`
[18:01:59.802]             `+` <- base::`+`
[18:01:59.802]             `<<-` <- base::`<<-`
[18:01:59.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:59.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:59.802]                   3L)]
[18:01:59.802]             }
[18:01:59.802]             function(cond) {
[18:01:59.802]                 is_error <- inherits(cond, "error")
[18:01:59.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:59.802]                   NULL)
[18:01:59.802]                 if (is_error) {
[18:01:59.802]                   sessionInformation <- function() {
[18:01:59.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:59.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:59.802]                       search = base::search(), system = base::Sys.info())
[18:01:59.802]                   }
[18:01:59.802]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:59.802]                     cond$call), session = sessionInformation(), 
[18:01:59.802]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:59.802]                   signalCondition(cond)
[18:01:59.802]                 }
[18:01:59.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:59.802]                 "immediateCondition"))) {
[18:01:59.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:59.802]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:59.802]                   if (TRUE && !signal) {
[18:01:59.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.802]                     {
[18:01:59.802]                       inherits <- base::inherits
[18:01:59.802]                       invokeRestart <- base::invokeRestart
[18:01:59.802]                       is.null <- base::is.null
[18:01:59.802]                       muffled <- FALSE
[18:01:59.802]                       if (inherits(cond, "message")) {
[18:01:59.802]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.802]                         if (muffled) 
[18:01:59.802]                           invokeRestart("muffleMessage")
[18:01:59.802]                       }
[18:01:59.802]                       else if (inherits(cond, "warning")) {
[18:01:59.802]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.802]                         if (muffled) 
[18:01:59.802]                           invokeRestart("muffleWarning")
[18:01:59.802]                       }
[18:01:59.802]                       else if (inherits(cond, "condition")) {
[18:01:59.802]                         if (!is.null(pattern)) {
[18:01:59.802]                           computeRestarts <- base::computeRestarts
[18:01:59.802]                           grepl <- base::grepl
[18:01:59.802]                           restarts <- computeRestarts(cond)
[18:01:59.802]                           for (restart in restarts) {
[18:01:59.802]                             name <- restart$name
[18:01:59.802]                             if (is.null(name)) 
[18:01:59.802]                               next
[18:01:59.802]                             if (!grepl(pattern, name)) 
[18:01:59.802]                               next
[18:01:59.802]                             invokeRestart(restart)
[18:01:59.802]                             muffled <- TRUE
[18:01:59.802]                             break
[18:01:59.802]                           }
[18:01:59.802]                         }
[18:01:59.802]                       }
[18:01:59.802]                       invisible(muffled)
[18:01:59.802]                     }
[18:01:59.802]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.802]                   }
[18:01:59.802]                 }
[18:01:59.802]                 else {
[18:01:59.802]                   if (TRUE) {
[18:01:59.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.802]                     {
[18:01:59.802]                       inherits <- base::inherits
[18:01:59.802]                       invokeRestart <- base::invokeRestart
[18:01:59.802]                       is.null <- base::is.null
[18:01:59.802]                       muffled <- FALSE
[18:01:59.802]                       if (inherits(cond, "message")) {
[18:01:59.802]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.802]                         if (muffled) 
[18:01:59.802]                           invokeRestart("muffleMessage")
[18:01:59.802]                       }
[18:01:59.802]                       else if (inherits(cond, "warning")) {
[18:01:59.802]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.802]                         if (muffled) 
[18:01:59.802]                           invokeRestart("muffleWarning")
[18:01:59.802]                       }
[18:01:59.802]                       else if (inherits(cond, "condition")) {
[18:01:59.802]                         if (!is.null(pattern)) {
[18:01:59.802]                           computeRestarts <- base::computeRestarts
[18:01:59.802]                           grepl <- base::grepl
[18:01:59.802]                           restarts <- computeRestarts(cond)
[18:01:59.802]                           for (restart in restarts) {
[18:01:59.802]                             name <- restart$name
[18:01:59.802]                             if (is.null(name)) 
[18:01:59.802]                               next
[18:01:59.802]                             if (!grepl(pattern, name)) 
[18:01:59.802]                               next
[18:01:59.802]                             invokeRestart(restart)
[18:01:59.802]                             muffled <- TRUE
[18:01:59.802]                             break
[18:01:59.802]                           }
[18:01:59.802]                         }
[18:01:59.802]                       }
[18:01:59.802]                       invisible(muffled)
[18:01:59.802]                     }
[18:01:59.802]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.802]                   }
[18:01:59.802]                 }
[18:01:59.802]             }
[18:01:59.802]         }))
[18:01:59.802]     }, error = function(ex) {
[18:01:59.802]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:59.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.802]                 ...future.rng), started = ...future.startTime, 
[18:01:59.802]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:59.802]             version = "1.8"), class = "FutureResult")
[18:01:59.802]     }, finally = {
[18:01:59.802]         if (!identical(...future.workdir, getwd())) 
[18:01:59.802]             setwd(...future.workdir)
[18:01:59.802]         {
[18:01:59.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:59.802]                 ...future.oldOptions$nwarnings <- NULL
[18:01:59.802]             }
[18:01:59.802]             base::options(...future.oldOptions)
[18:01:59.802]             if (.Platform$OS.type == "windows") {
[18:01:59.802]                 old_names <- names(...future.oldEnvVars)
[18:01:59.802]                 envs <- base::Sys.getenv()
[18:01:59.802]                 names <- names(envs)
[18:01:59.802]                 common <- intersect(names, old_names)
[18:01:59.802]                 added <- setdiff(names, old_names)
[18:01:59.802]                 removed <- setdiff(old_names, names)
[18:01:59.802]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:59.802]                   envs[common]]
[18:01:59.802]                 NAMES <- toupper(changed)
[18:01:59.802]                 args <- list()
[18:01:59.802]                 for (kk in seq_along(NAMES)) {
[18:01:59.802]                   name <- changed[[kk]]
[18:01:59.802]                   NAME <- NAMES[[kk]]
[18:01:59.802]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.802]                     next
[18:01:59.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.802]                 }
[18:01:59.802]                 NAMES <- toupper(added)
[18:01:59.802]                 for (kk in seq_along(NAMES)) {
[18:01:59.802]                   name <- added[[kk]]
[18:01:59.802]                   NAME <- NAMES[[kk]]
[18:01:59.802]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.802]                     next
[18:01:59.802]                   args[[name]] <- ""
[18:01:59.802]                 }
[18:01:59.802]                 NAMES <- toupper(removed)
[18:01:59.802]                 for (kk in seq_along(NAMES)) {
[18:01:59.802]                   name <- removed[[kk]]
[18:01:59.802]                   NAME <- NAMES[[kk]]
[18:01:59.802]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.802]                     next
[18:01:59.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.802]                 }
[18:01:59.802]                 if (length(args) > 0) 
[18:01:59.802]                   base::do.call(base::Sys.setenv, args = args)
[18:01:59.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:59.802]             }
[18:01:59.802]             else {
[18:01:59.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:59.802]             }
[18:01:59.802]             {
[18:01:59.802]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:59.802]                   0L) {
[18:01:59.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:59.802]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:59.802]                   base::options(opts)
[18:01:59.802]                 }
[18:01:59.802]                 {
[18:01:59.802]                   {
[18:01:59.802]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:59.802]                     NULL
[18:01:59.802]                   }
[18:01:59.802]                   options(future.plan = NULL)
[18:01:59.802]                   if (is.na(NA_character_)) 
[18:01:59.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:59.802]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:59.802]                     .init = FALSE)
[18:01:59.802]                 }
[18:01:59.802]             }
[18:01:59.802]         }
[18:01:59.802]     })
[18:01:59.802]     if (TRUE) {
[18:01:59.802]         base::sink(type = "output", split = FALSE)
[18:01:59.802]         if (TRUE) {
[18:01:59.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:59.802]         }
[18:01:59.802]         else {
[18:01:59.802]             ...future.result["stdout"] <- base::list(NULL)
[18:01:59.802]         }
[18:01:59.802]         base::close(...future.stdout)
[18:01:59.802]         ...future.stdout <- NULL
[18:01:59.802]     }
[18:01:59.802]     ...future.result$conditions <- ...future.conditions
[18:01:59.802]     ...future.result$finished <- base::Sys.time()
[18:01:59.802]     ...future.result
[18:01:59.802] }
[18:01:59.809] assign_globals() ...
[18:01:59.809] List of 11
[18:01:59.809]  $ ...future.FUN            :function (x, ...)  
[18:01:59.809]  $ x_FUN                    :function (x, na.rm = TRUE)  
[18:01:59.809]  $ times                    : int 5
[18:01:59.809]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:01:59.809]  $ stop_if_not              :function (...)  
[18:01:59.809]  $ dim                      : NULL
[18:01:59.809]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:01:59.809]  $ future.call.arguments    : list()
[18:01:59.809]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.809]  $ ...future.elements_ii    :List of 3
[18:01:59.809]   ..$ : int [1:7] 1 2 3 4 5 6 7
[18:01:59.809]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[18:01:59.809]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[18:01:59.809]  $ ...future.seeds_ii       : NULL
[18:01:59.809]  $ ...future.globals.maxSize: NULL
[18:01:59.809]  - attr(*, "where")=List of 11
[18:01:59.809]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:59.809]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:01:59.809]   ..$ times                    :<environment: R_EmptyEnv> 
[18:01:59.809]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:01:59.809]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:01:59.809]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:01:59.809]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:01:59.809]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:59.809]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:59.809]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:59.809]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:59.809]  - attr(*, "resolved")= logi FALSE
[18:01:59.809]  - attr(*, "total_size")= num 141240
[18:01:59.809]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.809]  - attr(*, "already-done")= logi TRUE
[18:01:59.839] - copied ‘...future.FUN’ to environment
[18:01:59.840] - copied ‘x_FUN’ to environment
[18:01:59.840] - copied ‘times’ to environment
[18:01:59.840] - copied ‘stopf’ to environment
[18:01:59.841] - copied ‘stop_if_not’ to environment
[18:01:59.841] - copied ‘dim’ to environment
[18:01:59.841] - copied ‘valid_types’ to environment
[18:01:59.841] - copied ‘future.call.arguments’ to environment
[18:01:59.842] - copied ‘...future.elements_ii’ to environment
[18:01:59.842] - copied ‘...future.seeds_ii’ to environment
[18:01:59.842] - copied ‘...future.globals.maxSize’ to environment
[18:01:59.842] assign_globals() ... done
[18:01:59.843] requestCore(): workers = 2
[18:01:59.847] MulticoreFuture started
[18:01:59.848] - Launch lazy future ... done
[18:01:59.849] run() for ‘MulticoreFuture’ ... done
[18:01:59.850] Created future:
[18:01:59.856] plan(): Setting new future strategy stack:
[18:01:59.857] List of future strategies:
[18:01:59.857] 1. sequential:
[18:01:59.857]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:59.857]    - tweaked: FALSE
[18:01:59.857]    - call: NULL
[18:01:59.860] plan(): nbrOfWorkers() = 1
[18:01:59.865] plan(): Setting new future strategy stack:
[18:01:59.866] List of future strategies:
[18:01:59.866] 1. multicore:
[18:01:59.866]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:01:59.866]    - tweaked: FALSE
[18:01:59.866]    - call: plan(strategy)
[18:01:59.852] MulticoreFuture:
[18:01:59.852] Label: ‘future_vapply-2’
[18:01:59.852] Expression:
[18:01:59.852] {
[18:01:59.852]     do.call(function(...) {
[18:01:59.852]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.852]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.852]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.852]             on.exit(options(oopts), add = TRUE)
[18:01:59.852]         }
[18:01:59.852]         {
[18:01:59.852]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.852]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.852]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.852]             })
[18:01:59.852]         }
[18:01:59.852]     }, args = future.call.arguments)
[18:01:59.852] }
[18:01:59.852] Lazy evaluation: FALSE
[18:01:59.852] Asynchronous evaluation: TRUE
[18:01:59.852] Local evaluation: TRUE
[18:01:59.852] Environment: R_GlobalEnv
[18:01:59.852] Capture standard output: TRUE
[18:01:59.852] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:59.852] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:01:59.852] Packages: 2 packages (‘stats’, ‘future.apply’)
[18:01:59.852] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:59.852] Resolved: FALSE
[18:01:59.852] Value: <not collected>
[18:01:59.852] Conditions captured: <none>
[18:01:59.852] Early signaling: FALSE
[18:01:59.852] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:59.852] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:59.870] Chunk #2 of 2 ... DONE
[18:01:59.870] Launching 2 futures (chunks) ... DONE
[18:01:59.871] Resolving 2 futures (chunks) ...
[18:01:59.873] resolve() on list ...
[18:01:59.873]  recursive: 0
[18:01:59.874]  length: 2
[18:01:59.874] 
[18:01:59.875] Future #1
[18:01:59.875] result() for MulticoreFuture ...
[18:01:59.880] result() for MulticoreFuture ...
[18:01:59.880] result() for MulticoreFuture ... done
[18:01:59.881] result() for MulticoreFuture ... done
[18:01:59.881] result() for MulticoreFuture ...
[18:01:59.882] result() for MulticoreFuture ... done
[18:01:59.883] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:01:59.883] - nx: 2
[18:01:59.884] - relay: TRUE
[18:01:59.884] - stdout: TRUE
[18:01:59.884] - signal: TRUE
[18:01:59.885] plan(): nbrOfWorkers() = 2
[18:01:59.885] - resignal: FALSE
[18:01:59.886] - force: TRUE
[18:01:59.886] - relayed: [n=2] FALSE, FALSE
[18:01:59.887] - queued futures: [n=2] FALSE, FALSE
[18:01:59.887]  - until=1
[18:01:59.887]  - relaying element #1
[18:01:59.888] result() for MulticoreFuture ...
[18:01:59.888] result() for MulticoreFuture ... done
[18:01:59.888] result() for MulticoreFuture ...
[18:01:59.889] result() for MulticoreFuture ... done
[18:01:59.889] result() for MulticoreFuture ...
[18:01:59.889] result() for MulticoreFuture ... done
[18:01:59.890] result() for MulticoreFuture ...
[18:01:59.890] result() for MulticoreFuture ... done
[18:01:59.890] - relayed: [n=2] TRUE, FALSE
[18:01:59.891] - queued futures: [n=2] TRUE, FALSE
[18:01:59.891] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:01:59.891]  length: 1 (resolved future 1)
[18:01:59.892] Future #2
[18:01:59.892] result() for MulticoreFuture ...
[18:01:59.895] result() for MulticoreFuture ...
[18:01:59.896] result() for MulticoreFuture ... done
[18:01:59.896] result() for MulticoreFuture ... done
[18:01:59.896] result() for MulticoreFuture ...
[18:01:59.896] result() for MulticoreFuture ... done
[18:01:59.897] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:01:59.897] - nx: 2
[18:01:59.897] - relay: TRUE
[18:01:59.897] - stdout: TRUE
[18:01:59.898] - signal: TRUE
[18:01:59.898] - resignal: FALSE
[18:01:59.898] - force: TRUE
[18:01:59.898] - relayed: [n=2] TRUE, FALSE
[18:01:59.898] - queued futures: [n=2] TRUE, FALSE
[18:01:59.899]  - until=2
[18:01:59.899]  - relaying element #2
[18:01:59.899] result() for MulticoreFuture ...
[18:01:59.899] result() for MulticoreFuture ... done
[18:01:59.900] result() for MulticoreFuture ...
[18:01:59.900] result() for MulticoreFuture ... done
[18:01:59.900] result() for MulticoreFuture ...
[18:01:59.900] result() for MulticoreFuture ... done
[18:01:59.901] result() for MulticoreFuture ...
[18:01:59.901] result() for MulticoreFuture ... done
[18:01:59.901] - relayed: [n=2] TRUE, TRUE
[18:01:59.901] - queued futures: [n=2] TRUE, TRUE
[18:01:59.902] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:01:59.902]  length: 0 (resolved future 2)
[18:01:59.902] Relaying remaining futures
[18:01:59.902] signalConditionsASAP(NULL, pos=0) ...
[18:01:59.902] - nx: 2
[18:01:59.903] - relay: TRUE
[18:01:59.903] - stdout: TRUE
[18:01:59.903] - signal: TRUE
[18:01:59.903] - resignal: FALSE
[18:01:59.903] - force: TRUE
[18:01:59.904] - relayed: [n=2] TRUE, TRUE
[18:01:59.904] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:01:59.904] - relayed: [n=2] TRUE, TRUE
[18:01:59.904] - queued futures: [n=2] TRUE, TRUE
[18:01:59.905] signalConditionsASAP(NULL, pos=0) ... done
[18:01:59.905] resolve() on list ... DONE
[18:01:59.905] result() for MulticoreFuture ...
[18:01:59.905] result() for MulticoreFuture ... done
[18:01:59.906] result() for MulticoreFuture ...
[18:01:59.906] result() for MulticoreFuture ... done
[18:01:59.906] result() for MulticoreFuture ...
[18:01:59.906] result() for MulticoreFuture ... done
[18:01:59.907] result() for MulticoreFuture ...
[18:01:59.907] result() for MulticoreFuture ... done
[18:01:59.907]  - Number of value chunks collected: 2
[18:01:59.907] Resolving 2 futures (chunks) ... DONE
[18:01:59.907] Reducing values from 2 chunks ...
[18:01:59.908]  - Number of values collected after concatenation: 7
[18:01:59.908]  - Number of values expected: 7
[18:01:59.908] Reducing values from 2 chunks ... DONE
[18:01:59.908] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[18:01:59.912] future_lapply() ...
[18:01:59.920] Number of chunks: 2
[18:01:59.920] getGlobalsAndPackagesXApply() ...
[18:01:59.920]  - future.globals: TRUE
[18:01:59.921] getGlobalsAndPackages() ...
[18:01:59.921] Searching for globals...
[18:01:59.927] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[18:01:59.927] Searching for globals ... DONE
[18:01:59.928] Resolving globals: FALSE
[18:01:59.929] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[18:01:59.929] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[18:01:59.930] - globals: [1] ‘FUN’
[18:01:59.930] 
[18:01:59.930] getGlobalsAndPackages() ... DONE
[18:01:59.930]  - globals found/used: [n=1] ‘FUN’
[18:01:59.931]  - needed namespaces: [n=0] 
[18:01:59.931] Finding globals ... DONE
[18:01:59.931]  - use_args: TRUE
[18:01:59.931]  - Getting '...' globals ...
[18:01:59.932] resolve() on list ...
[18:01:59.932]  recursive: 0
[18:01:59.933]  length: 1
[18:01:59.933]  elements: ‘...’
[18:01:59.933]  length: 0 (resolved future 1)
[18:01:59.933] resolve() on list ... DONE
[18:01:59.934]    - '...' content: [n=1] ‘y’
[18:01:59.934] List of 1
[18:01:59.934]  $ ...:List of 1
[18:01:59.934]   ..$ y: num [1:5] 2 4 6 8 10
[18:01:59.934]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.934]  - attr(*, "where")=List of 1
[18:01:59.934]   ..$ ...:<environment: 0x6183c0ae9ea8> 
[18:01:59.934]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.934]  - attr(*, "resolved")= logi TRUE
[18:01:59.934]  - attr(*, "total_size")= num NA
[18:01:59.940]  - Getting '...' globals ... DONE
[18:01:59.940] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:01:59.941] List of 2
[18:01:59.941]  $ ...future.FUN:function (x, y)  
[18:01:59.941]  $ ...          :List of 1
[18:01:59.941]   ..$ y: num [1:5] 2 4 6 8 10
[18:01:59.941]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.941]  - attr(*, "where")=List of 2
[18:01:59.941]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:01:59.941]   ..$ ...          :<environment: 0x6183c0ae9ea8> 
[18:01:59.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.941]  - attr(*, "resolved")= logi FALSE
[18:01:59.941]  - attr(*, "total_size")= num 4264
[18:01:59.947] Packages to be attached in all futures: [n=0] 
[18:01:59.947] getGlobalsAndPackagesXApply() ... DONE
[18:01:59.947] Number of futures (= number of chunks): 2
[18:01:59.948] Launching 2 futures (chunks) ...
[18:01:59.948] Chunk #1 of 2 ...
[18:01:59.948]  - Finding globals in 'X' for chunk #1 ...
[18:01:59.948] getGlobalsAndPackages() ...
[18:01:59.949] Searching for globals...
[18:01:59.949] 
[18:01:59.949] Searching for globals ... DONE
[18:01:59.949] - globals: [0] <none>
[18:01:59.950] getGlobalsAndPackages() ... DONE
[18:01:59.950]    + additional globals found: [n=0] 
[18:01:59.950]    + additional namespaces needed: [n=0] 
[18:01:59.951]  - Finding globals in 'X' for chunk #1 ... DONE
[18:01:59.951]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:01:59.951]  - seeds: <none>
[18:01:59.951]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.952] getGlobalsAndPackages() ...
[18:01:59.952] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.952] Resolving globals: FALSE
[18:01:59.952] Tweak future expression to call with '...' arguments ...
[18:01:59.952] {
[18:01:59.952]     do.call(function(...) {
[18:01:59.952]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.952]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.952]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.952]             on.exit(options(oopts), add = TRUE)
[18:01:59.952]         }
[18:01:59.952]         {
[18:01:59.952]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.952]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.952]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.952]             })
[18:01:59.952]         }
[18:01:59.952]     }, args = future.call.arguments)
[18:01:59.952] }
[18:01:59.953] Tweak future expression to call with '...' arguments ... DONE
[18:01:59.954] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:01:59.954] 
[18:01:59.955] getGlobalsAndPackages() ... DONE
[18:01:59.955] run() for ‘Future’ ...
[18:01:59.955] - state: ‘created’
[18:01:59.956] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:01:59.962] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:01:59.963] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:01:59.963]   - Field: ‘label’
[18:01:59.963]   - Field: ‘local’
[18:01:59.963]   - Field: ‘owner’
[18:01:59.964]   - Field: ‘envir’
[18:01:59.964]   - Field: ‘workers’
[18:01:59.964]   - Field: ‘packages’
[18:01:59.964]   - Field: ‘gc’
[18:01:59.964]   - Field: ‘job’
[18:01:59.965]   - Field: ‘conditions’
[18:01:59.965]   - Field: ‘expr’
[18:01:59.965]   - Field: ‘uuid’
[18:01:59.965]   - Field: ‘seed’
[18:01:59.965]   - Field: ‘version’
[18:01:59.966]   - Field: ‘result’
[18:01:59.966]   - Field: ‘asynchronous’
[18:01:59.966]   - Field: ‘calls’
[18:01:59.966]   - Field: ‘globals’
[18:01:59.966]   - Field: ‘stdout’
[18:01:59.967]   - Field: ‘earlySignal’
[18:01:59.967]   - Field: ‘lazy’
[18:01:59.967]   - Field: ‘state’
[18:01:59.967] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:01:59.967] - Launch lazy future ...
[18:01:59.968] Packages needed by the future expression (n = 0): <none>
[18:01:59.968] Packages needed by future strategies (n = 0): <none>
[18:01:59.969] {
[18:01:59.969]     {
[18:01:59.969]         {
[18:01:59.969]             ...future.startTime <- base::Sys.time()
[18:01:59.969]             {
[18:01:59.969]                 {
[18:01:59.969]                   {
[18:01:59.969]                     {
[18:01:59.969]                       base::local({
[18:01:59.969]                         has_future <- base::requireNamespace("future", 
[18:01:59.969]                           quietly = TRUE)
[18:01:59.969]                         if (has_future) {
[18:01:59.969]                           ns <- base::getNamespace("future")
[18:01:59.969]                           version <- ns[[".package"]][["version"]]
[18:01:59.969]                           if (is.null(version)) 
[18:01:59.969]                             version <- utils::packageVersion("future")
[18:01:59.969]                         }
[18:01:59.969]                         else {
[18:01:59.969]                           version <- NULL
[18:01:59.969]                         }
[18:01:59.969]                         if (!has_future || version < "1.8.0") {
[18:01:59.969]                           info <- base::c(r_version = base::gsub("R version ", 
[18:01:59.969]                             "", base::R.version$version.string), 
[18:01:59.969]                             platform = base::sprintf("%s (%s-bit)", 
[18:01:59.969]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:01:59.969]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:01:59.969]                               "release", "version")], collapse = " "), 
[18:01:59.969]                             hostname = base::Sys.info()[["nodename"]])
[18:01:59.969]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:01:59.969]                             info)
[18:01:59.969]                           info <- base::paste(info, collapse = "; ")
[18:01:59.969]                           if (!has_future) {
[18:01:59.969]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:01:59.969]                               info)
[18:01:59.969]                           }
[18:01:59.969]                           else {
[18:01:59.969]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:01:59.969]                               info, version)
[18:01:59.969]                           }
[18:01:59.969]                           base::stop(msg)
[18:01:59.969]                         }
[18:01:59.969]                       })
[18:01:59.969]                     }
[18:01:59.969]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:01:59.969]                     base::options(mc.cores = 1L)
[18:01:59.969]                   }
[18:01:59.969]                   ...future.strategy.old <- future::plan("list")
[18:01:59.969]                   options(future.plan = NULL)
[18:01:59.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:01:59.969]                 }
[18:01:59.969]                 ...future.workdir <- getwd()
[18:01:59.969]             }
[18:01:59.969]             ...future.oldOptions <- base::as.list(base::.Options)
[18:01:59.969]             ...future.oldEnvVars <- base::Sys.getenv()
[18:01:59.969]         }
[18:01:59.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:01:59.969]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:01:59.969]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:01:59.969]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:01:59.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:01:59.969]             future.stdout.windows.reencode = NULL, width = 80L)
[18:01:59.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:01:59.969]             base::names(...future.oldOptions))
[18:01:59.969]     }
[18:01:59.969]     if (FALSE) {
[18:01:59.969]     }
[18:01:59.969]     else {
[18:01:59.969]         if (TRUE) {
[18:01:59.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:01:59.969]                 open = "w")
[18:01:59.969]         }
[18:01:59.969]         else {
[18:01:59.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:01:59.969]                 windows = "NUL", "/dev/null"), open = "w")
[18:01:59.969]         }
[18:01:59.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:01:59.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:01:59.969]             base::sink(type = "output", split = FALSE)
[18:01:59.969]             base::close(...future.stdout)
[18:01:59.969]         }, add = TRUE)
[18:01:59.969]     }
[18:01:59.969]     ...future.frame <- base::sys.nframe()
[18:01:59.969]     ...future.conditions <- base::list()
[18:01:59.969]     ...future.rng <- base::globalenv()$.Random.seed
[18:01:59.969]     if (FALSE) {
[18:01:59.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:01:59.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:01:59.969]     }
[18:01:59.969]     ...future.result <- base::tryCatch({
[18:01:59.969]         base::withCallingHandlers({
[18:01:59.969]             ...future.value <- base::withVisible(base::local({
[18:01:59.969]                 withCallingHandlers({
[18:01:59.969]                   {
[18:01:59.969]                     do.call(function(...) {
[18:01:59.969]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.969]                       if (!identical(...future.globals.maxSize.org, 
[18:01:59.969]                         ...future.globals.maxSize)) {
[18:01:59.969]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.969]                         on.exit(options(oopts), add = TRUE)
[18:01:59.969]                       }
[18:01:59.969]                       {
[18:01:59.969]                         lapply(seq_along(...future.elements_ii), 
[18:01:59.969]                           FUN = function(jj) {
[18:01:59.969]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.969]                             ...future.FUN(...future.X_jj, ...)
[18:01:59.969]                           })
[18:01:59.969]                       }
[18:01:59.969]                     }, args = future.call.arguments)
[18:01:59.969]                   }
[18:01:59.969]                 }, immediateCondition = function(cond) {
[18:01:59.969]                   save_rds <- function (object, pathname, ...) 
[18:01:59.969]                   {
[18:01:59.969]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:01:59.969]                     if (file_test("-f", pathname_tmp)) {
[18:01:59.969]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.969]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:01:59.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.969]                         fi_tmp[["mtime"]])
[18:01:59.969]                     }
[18:01:59.969]                     tryCatch({
[18:01:59.969]                       saveRDS(object, file = pathname_tmp, ...)
[18:01:59.969]                     }, error = function(ex) {
[18:01:59.969]                       msg <- conditionMessage(ex)
[18:01:59.969]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.969]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:01:59.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.969]                         fi_tmp[["mtime"]], msg)
[18:01:59.969]                       ex$message <- msg
[18:01:59.969]                       stop(ex)
[18:01:59.969]                     })
[18:01:59.969]                     stopifnot(file_test("-f", pathname_tmp))
[18:01:59.969]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:01:59.969]                     if (!res || file_test("-f", pathname_tmp)) {
[18:01:59.969]                       fi_tmp <- file.info(pathname_tmp)
[18:01:59.969]                       fi <- file.info(pathname)
[18:01:59.969]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:01:59.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:01:59.969]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:01:59.969]                         fi[["size"]], fi[["mtime"]])
[18:01:59.969]                       stop(msg)
[18:01:59.969]                     }
[18:01:59.969]                     invisible(pathname)
[18:01:59.969]                   }
[18:01:59.969]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:01:59.969]                     rootPath = tempdir()) 
[18:01:59.969]                   {
[18:01:59.969]                     obj <- list(time = Sys.time(), condition = cond)
[18:01:59.969]                     file <- tempfile(pattern = class(cond)[1], 
[18:01:59.969]                       tmpdir = path, fileext = ".rds")
[18:01:59.969]                     save_rds(obj, file)
[18:01:59.969]                   }
[18:01:59.969]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:01:59.969]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.969]                   {
[18:01:59.969]                     inherits <- base::inherits
[18:01:59.969]                     invokeRestart <- base::invokeRestart
[18:01:59.969]                     is.null <- base::is.null
[18:01:59.969]                     muffled <- FALSE
[18:01:59.969]                     if (inherits(cond, "message")) {
[18:01:59.969]                       muffled <- grepl(pattern, "muffleMessage")
[18:01:59.969]                       if (muffled) 
[18:01:59.969]                         invokeRestart("muffleMessage")
[18:01:59.969]                     }
[18:01:59.969]                     else if (inherits(cond, "warning")) {
[18:01:59.969]                       muffled <- grepl(pattern, "muffleWarning")
[18:01:59.969]                       if (muffled) 
[18:01:59.969]                         invokeRestart("muffleWarning")
[18:01:59.969]                     }
[18:01:59.969]                     else if (inherits(cond, "condition")) {
[18:01:59.969]                       if (!is.null(pattern)) {
[18:01:59.969]                         computeRestarts <- base::computeRestarts
[18:01:59.969]                         grepl <- base::grepl
[18:01:59.969]                         restarts <- computeRestarts(cond)
[18:01:59.969]                         for (restart in restarts) {
[18:01:59.969]                           name <- restart$name
[18:01:59.969]                           if (is.null(name)) 
[18:01:59.969]                             next
[18:01:59.969]                           if (!grepl(pattern, name)) 
[18:01:59.969]                             next
[18:01:59.969]                           invokeRestart(restart)
[18:01:59.969]                           muffled <- TRUE
[18:01:59.969]                           break
[18:01:59.969]                         }
[18:01:59.969]                       }
[18:01:59.969]                     }
[18:01:59.969]                     invisible(muffled)
[18:01:59.969]                   }
[18:01:59.969]                   muffleCondition(cond)
[18:01:59.969]                 })
[18:01:59.969]             }))
[18:01:59.969]             future::FutureResult(value = ...future.value$value, 
[18:01:59.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.969]                   ...future.rng), globalenv = if (FALSE) 
[18:01:59.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:01:59.969]                     ...future.globalenv.names))
[18:01:59.969]                 else NULL, started = ...future.startTime, version = "1.8")
[18:01:59.969]         }, condition = base::local({
[18:01:59.969]             c <- base::c
[18:01:59.969]             inherits <- base::inherits
[18:01:59.969]             invokeRestart <- base::invokeRestart
[18:01:59.969]             length <- base::length
[18:01:59.969]             list <- base::list
[18:01:59.969]             seq.int <- base::seq.int
[18:01:59.969]             signalCondition <- base::signalCondition
[18:01:59.969]             sys.calls <- base::sys.calls
[18:01:59.969]             `[[` <- base::`[[`
[18:01:59.969]             `+` <- base::`+`
[18:01:59.969]             `<<-` <- base::`<<-`
[18:01:59.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:01:59.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:01:59.969]                   3L)]
[18:01:59.969]             }
[18:01:59.969]             function(cond) {
[18:01:59.969]                 is_error <- inherits(cond, "error")
[18:01:59.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:01:59.969]                   NULL)
[18:01:59.969]                 if (is_error) {
[18:01:59.969]                   sessionInformation <- function() {
[18:01:59.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:01:59.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:01:59.969]                       search = base::search(), system = base::Sys.info())
[18:01:59.969]                   }
[18:01:59.969]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:01:59.969]                     cond$call), session = sessionInformation(), 
[18:01:59.969]                     timestamp = base::Sys.time(), signaled = 0L)
[18:01:59.969]                   signalCondition(cond)
[18:01:59.969]                 }
[18:01:59.969]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:01:59.969]                 "immediateCondition"))) {
[18:01:59.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:01:59.969]                   ...future.conditions[[length(...future.conditions) + 
[18:01:59.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:01:59.969]                   if (TRUE && !signal) {
[18:01:59.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.969]                     {
[18:01:59.969]                       inherits <- base::inherits
[18:01:59.969]                       invokeRestart <- base::invokeRestart
[18:01:59.969]                       is.null <- base::is.null
[18:01:59.969]                       muffled <- FALSE
[18:01:59.969]                       if (inherits(cond, "message")) {
[18:01:59.969]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.969]                         if (muffled) 
[18:01:59.969]                           invokeRestart("muffleMessage")
[18:01:59.969]                       }
[18:01:59.969]                       else if (inherits(cond, "warning")) {
[18:01:59.969]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.969]                         if (muffled) 
[18:01:59.969]                           invokeRestart("muffleWarning")
[18:01:59.969]                       }
[18:01:59.969]                       else if (inherits(cond, "condition")) {
[18:01:59.969]                         if (!is.null(pattern)) {
[18:01:59.969]                           computeRestarts <- base::computeRestarts
[18:01:59.969]                           grepl <- base::grepl
[18:01:59.969]                           restarts <- computeRestarts(cond)
[18:01:59.969]                           for (restart in restarts) {
[18:01:59.969]                             name <- restart$name
[18:01:59.969]                             if (is.null(name)) 
[18:01:59.969]                               next
[18:01:59.969]                             if (!grepl(pattern, name)) 
[18:01:59.969]                               next
[18:01:59.969]                             invokeRestart(restart)
[18:01:59.969]                             muffled <- TRUE
[18:01:59.969]                             break
[18:01:59.969]                           }
[18:01:59.969]                         }
[18:01:59.969]                       }
[18:01:59.969]                       invisible(muffled)
[18:01:59.969]                     }
[18:01:59.969]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.969]                   }
[18:01:59.969]                 }
[18:01:59.969]                 else {
[18:01:59.969]                   if (TRUE) {
[18:01:59.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:01:59.969]                     {
[18:01:59.969]                       inherits <- base::inherits
[18:01:59.969]                       invokeRestart <- base::invokeRestart
[18:01:59.969]                       is.null <- base::is.null
[18:01:59.969]                       muffled <- FALSE
[18:01:59.969]                       if (inherits(cond, "message")) {
[18:01:59.969]                         muffled <- grepl(pattern, "muffleMessage")
[18:01:59.969]                         if (muffled) 
[18:01:59.969]                           invokeRestart("muffleMessage")
[18:01:59.969]                       }
[18:01:59.969]                       else if (inherits(cond, "warning")) {
[18:01:59.969]                         muffled <- grepl(pattern, "muffleWarning")
[18:01:59.969]                         if (muffled) 
[18:01:59.969]                           invokeRestart("muffleWarning")
[18:01:59.969]                       }
[18:01:59.969]                       else if (inherits(cond, "condition")) {
[18:01:59.969]                         if (!is.null(pattern)) {
[18:01:59.969]                           computeRestarts <- base::computeRestarts
[18:01:59.969]                           grepl <- base::grepl
[18:01:59.969]                           restarts <- computeRestarts(cond)
[18:01:59.969]                           for (restart in restarts) {
[18:01:59.969]                             name <- restart$name
[18:01:59.969]                             if (is.null(name)) 
[18:01:59.969]                               next
[18:01:59.969]                             if (!grepl(pattern, name)) 
[18:01:59.969]                               next
[18:01:59.969]                             invokeRestart(restart)
[18:01:59.969]                             muffled <- TRUE
[18:01:59.969]                             break
[18:01:59.969]                           }
[18:01:59.969]                         }
[18:01:59.969]                       }
[18:01:59.969]                       invisible(muffled)
[18:01:59.969]                     }
[18:01:59.969]                     muffleCondition(cond, pattern = "^muffle")
[18:01:59.969]                   }
[18:01:59.969]                 }
[18:01:59.969]             }
[18:01:59.969]         }))
[18:01:59.969]     }, error = function(ex) {
[18:01:59.969]         base::structure(base::list(value = NULL, visible = NULL, 
[18:01:59.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:01:59.969]                 ...future.rng), started = ...future.startTime, 
[18:01:59.969]             finished = Sys.time(), session_uuid = NA_character_, 
[18:01:59.969]             version = "1.8"), class = "FutureResult")
[18:01:59.969]     }, finally = {
[18:01:59.969]         if (!identical(...future.workdir, getwd())) 
[18:01:59.969]             setwd(...future.workdir)
[18:01:59.969]         {
[18:01:59.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:01:59.969]                 ...future.oldOptions$nwarnings <- NULL
[18:01:59.969]             }
[18:01:59.969]             base::options(...future.oldOptions)
[18:01:59.969]             if (.Platform$OS.type == "windows") {
[18:01:59.969]                 old_names <- names(...future.oldEnvVars)
[18:01:59.969]                 envs <- base::Sys.getenv()
[18:01:59.969]                 names <- names(envs)
[18:01:59.969]                 common <- intersect(names, old_names)
[18:01:59.969]                 added <- setdiff(names, old_names)
[18:01:59.969]                 removed <- setdiff(old_names, names)
[18:01:59.969]                 changed <- common[...future.oldEnvVars[common] != 
[18:01:59.969]                   envs[common]]
[18:01:59.969]                 NAMES <- toupper(changed)
[18:01:59.969]                 args <- list()
[18:01:59.969]                 for (kk in seq_along(NAMES)) {
[18:01:59.969]                   name <- changed[[kk]]
[18:01:59.969]                   NAME <- NAMES[[kk]]
[18:01:59.969]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.969]                     next
[18:01:59.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.969]                 }
[18:01:59.969]                 NAMES <- toupper(added)
[18:01:59.969]                 for (kk in seq_along(NAMES)) {
[18:01:59.969]                   name <- added[[kk]]
[18:01:59.969]                   NAME <- NAMES[[kk]]
[18:01:59.969]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.969]                     next
[18:01:59.969]                   args[[name]] <- ""
[18:01:59.969]                 }
[18:01:59.969]                 NAMES <- toupper(removed)
[18:01:59.969]                 for (kk in seq_along(NAMES)) {
[18:01:59.969]                   name <- removed[[kk]]
[18:01:59.969]                   NAME <- NAMES[[kk]]
[18:01:59.969]                   if (name != NAME && is.element(NAME, old_names)) 
[18:01:59.969]                     next
[18:01:59.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:01:59.969]                 }
[18:01:59.969]                 if (length(args) > 0) 
[18:01:59.969]                   base::do.call(base::Sys.setenv, args = args)
[18:01:59.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:01:59.969]             }
[18:01:59.969]             else {
[18:01:59.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:01:59.969]             }
[18:01:59.969]             {
[18:01:59.969]                 if (base::length(...future.futureOptionsAdded) > 
[18:01:59.969]                   0L) {
[18:01:59.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:01:59.969]                   base::names(opts) <- ...future.futureOptionsAdded
[18:01:59.969]                   base::options(opts)
[18:01:59.969]                 }
[18:01:59.969]                 {
[18:01:59.969]                   {
[18:01:59.969]                     base::options(mc.cores = ...future.mc.cores.old)
[18:01:59.969]                     NULL
[18:01:59.969]                   }
[18:01:59.969]                   options(future.plan = NULL)
[18:01:59.969]                   if (is.na(NA_character_)) 
[18:01:59.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:01:59.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:01:59.969]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:01:59.969]                     .init = FALSE)
[18:01:59.969]                 }
[18:01:59.969]             }
[18:01:59.969]         }
[18:01:59.969]     })
[18:01:59.969]     if (TRUE) {
[18:01:59.969]         base::sink(type = "output", split = FALSE)
[18:01:59.969]         if (TRUE) {
[18:01:59.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:01:59.969]         }
[18:01:59.969]         else {
[18:01:59.969]             ...future.result["stdout"] <- base::list(NULL)
[18:01:59.969]         }
[18:01:59.969]         base::close(...future.stdout)
[18:01:59.969]         ...future.stdout <- NULL
[18:01:59.969]     }
[18:01:59.969]     ...future.result$conditions <- ...future.conditions
[18:01:59.969]     ...future.result$finished <- base::Sys.time()
[18:01:59.969]     ...future.result
[18:01:59.969] }
[18:01:59.977] assign_globals() ...
[18:01:59.977] List of 5
[18:01:59.977]  $ ...future.FUN            :function (x, y)  
[18:01:59.977]  $ future.call.arguments    :List of 1
[18:01:59.977]   ..$ y: num [1:5] 2 4 6 8 10
[18:01:59.977]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:01:59.977]  $ ...future.elements_ii    :List of 2
[18:01:59.977]   ..$ A: num 50
[18:01:59.977]   ..$ B: num 60
[18:01:59.977]  $ ...future.seeds_ii       : NULL
[18:01:59.977]  $ ...future.globals.maxSize: NULL
[18:01:59.977]  - attr(*, "where")=List of 5
[18:01:59.977]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:01:59.977]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:01:59.977]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:01:59.977]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:01:59.977]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:01:59.977]  - attr(*, "resolved")= logi FALSE
[18:01:59.977]  - attr(*, "total_size")= num 4264
[18:01:59.977]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:01:59.977]  - attr(*, "already-done")= logi TRUE
[18:01:59.989] - reassign environment for ‘...future.FUN’
[18:01:59.989] - copied ‘...future.FUN’ to environment
[18:01:59.989] - copied ‘future.call.arguments’ to environment
[18:01:59.989] - copied ‘...future.elements_ii’ to environment
[18:01:59.990] - copied ‘...future.seeds_ii’ to environment
[18:01:59.990] - copied ‘...future.globals.maxSize’ to environment
[18:01:59.990] assign_globals() ... done
[18:01:59.990] requestCore(): workers = 2
[18:01:59.994] MulticoreFuture started
[18:01:59.995] - Launch lazy future ... done
[18:01:59.995] run() for ‘MulticoreFuture’ ... done
[18:01:59.996] Created future:
[18:01:59.996] plan(): Setting new future strategy stack:
[18:01:59.996] List of future strategies:
[18:01:59.996] 1. sequential:
[18:01:59.996]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:01:59.996]    - tweaked: FALSE
[18:01:59.996]    - call: NULL
[18:01:59.998] plan(): nbrOfWorkers() = 1
[18:02:00.003] plan(): Setting new future strategy stack:
[18:02:00.003] List of future strategies:
[18:02:00.003] 1. multicore:
[18:02:00.003]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:00.003]    - tweaked: FALSE
[18:02:00.003]    - call: plan(strategy)
[18:02:00.013] plan(): nbrOfWorkers() = 2
[18:01:59.996] MulticoreFuture:
[18:01:59.996] Label: ‘future_sapply-1’
[18:01:59.996] Expression:
[18:01:59.996] {
[18:01:59.996]     do.call(function(...) {
[18:01:59.996]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:01:59.996]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:01:59.996]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:01:59.996]             on.exit(options(oopts), add = TRUE)
[18:01:59.996]         }
[18:01:59.996]         {
[18:01:59.996]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:01:59.996]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:01:59.996]                 ...future.FUN(...future.X_jj, ...)
[18:01:59.996]             })
[18:01:59.996]         }
[18:01:59.996]     }, args = future.call.arguments)
[18:01:59.996] }
[18:01:59.996] Lazy evaluation: FALSE
[18:01:59.996] Asynchronous evaluation: TRUE
[18:01:59.996] Local evaluation: TRUE
[18:01:59.996] Environment: R_GlobalEnv
[18:01:59.996] Capture standard output: TRUE
[18:01:59.996] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:01:59.996] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:01:59.996] Packages: <none>
[18:01:59.996] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:01:59.996] Resolved: TRUE
[18:01:59.996] Value: <not collected>
[18:01:59.996] Conditions captured: <none>
[18:01:59.996] Early signaling: FALSE
[18:01:59.996] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:01:59.996] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.015] Chunk #1 of 2 ... DONE
[18:02:00.015] Chunk #2 of 2 ...
[18:02:00.016]  - Finding globals in 'X' for chunk #2 ...
[18:02:00.016] getGlobalsAndPackages() ...
[18:02:00.016] Searching for globals...
[18:02:00.017] 
[18:02:00.017] Searching for globals ... DONE
[18:02:00.018] - globals: [0] <none>
[18:02:00.018] getGlobalsAndPackages() ... DONE
[18:02:00.018]    + additional globals found: [n=0] 
[18:02:00.019]    + additional namespaces needed: [n=0] 
[18:02:00.019]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:00.019]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:00.019]  - seeds: <none>
[18:02:00.020]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.020] getGlobalsAndPackages() ...
[18:02:00.020] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.021] Resolving globals: FALSE
[18:02:00.021] Tweak future expression to call with '...' arguments ...
[18:02:00.022] {
[18:02:00.022]     do.call(function(...) {
[18:02:00.022]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.022]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.022]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.022]             on.exit(options(oopts), add = TRUE)
[18:02:00.022]         }
[18:02:00.022]         {
[18:02:00.022]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.022]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.022]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.022]             })
[18:02:00.022]         }
[18:02:00.022]     }, args = future.call.arguments)
[18:02:00.022] }
[18:02:00.022] Tweak future expression to call with '...' arguments ... DONE
[18:02:00.024] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.024] 
[18:02:00.024] getGlobalsAndPackages() ... DONE
[18:02:00.025] run() for ‘Future’ ...
[18:02:00.026] - state: ‘created’
[18:02:00.026] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:00.034] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.035] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:00.035]   - Field: ‘label’
[18:02:00.036]   - Field: ‘local’
[18:02:00.036]   - Field: ‘owner’
[18:02:00.036]   - Field: ‘envir’
[18:02:00.037]   - Field: ‘workers’
[18:02:00.037]   - Field: ‘packages’
[18:02:00.037]   - Field: ‘gc’
[18:02:00.038]   - Field: ‘job’
[18:02:00.038]   - Field: ‘conditions’
[18:02:00.038]   - Field: ‘expr’
[18:02:00.039]   - Field: ‘uuid’
[18:02:00.039]   - Field: ‘seed’
[18:02:00.039]   - Field: ‘version’
[18:02:00.039]   - Field: ‘result’
[18:02:00.040]   - Field: ‘asynchronous’
[18:02:00.040]   - Field: ‘calls’
[18:02:00.040]   - Field: ‘globals’
[18:02:00.041]   - Field: ‘stdout’
[18:02:00.041]   - Field: ‘earlySignal’
[18:02:00.041]   - Field: ‘lazy’
[18:02:00.042]   - Field: ‘state’
[18:02:00.042] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:00.042] - Launch lazy future ...
[18:02:00.043] Packages needed by the future expression (n = 0): <none>
[18:02:00.044] Packages needed by future strategies (n = 0): <none>
[18:02:00.045] {
[18:02:00.045]     {
[18:02:00.045]         {
[18:02:00.045]             ...future.startTime <- base::Sys.time()
[18:02:00.045]             {
[18:02:00.045]                 {
[18:02:00.045]                   {
[18:02:00.045]                     {
[18:02:00.045]                       base::local({
[18:02:00.045]                         has_future <- base::requireNamespace("future", 
[18:02:00.045]                           quietly = TRUE)
[18:02:00.045]                         if (has_future) {
[18:02:00.045]                           ns <- base::getNamespace("future")
[18:02:00.045]                           version <- ns[[".package"]][["version"]]
[18:02:00.045]                           if (is.null(version)) 
[18:02:00.045]                             version <- utils::packageVersion("future")
[18:02:00.045]                         }
[18:02:00.045]                         else {
[18:02:00.045]                           version <- NULL
[18:02:00.045]                         }
[18:02:00.045]                         if (!has_future || version < "1.8.0") {
[18:02:00.045]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:00.045]                             "", base::R.version$version.string), 
[18:02:00.045]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:00.045]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:00.045]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:00.045]                               "release", "version")], collapse = " "), 
[18:02:00.045]                             hostname = base::Sys.info()[["nodename"]])
[18:02:00.045]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:00.045]                             info)
[18:02:00.045]                           info <- base::paste(info, collapse = "; ")
[18:02:00.045]                           if (!has_future) {
[18:02:00.045]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:00.045]                               info)
[18:02:00.045]                           }
[18:02:00.045]                           else {
[18:02:00.045]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:00.045]                               info, version)
[18:02:00.045]                           }
[18:02:00.045]                           base::stop(msg)
[18:02:00.045]                         }
[18:02:00.045]                       })
[18:02:00.045]                     }
[18:02:00.045]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:00.045]                     base::options(mc.cores = 1L)
[18:02:00.045]                   }
[18:02:00.045]                   ...future.strategy.old <- future::plan("list")
[18:02:00.045]                   options(future.plan = NULL)
[18:02:00.045]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:00.045]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:00.045]                 }
[18:02:00.045]                 ...future.workdir <- getwd()
[18:02:00.045]             }
[18:02:00.045]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:00.045]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:00.045]         }
[18:02:00.045]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:00.045]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:00.045]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:00.045]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:00.045]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:00.045]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:00.045]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:00.045]             base::names(...future.oldOptions))
[18:02:00.045]     }
[18:02:00.045]     if (FALSE) {
[18:02:00.045]     }
[18:02:00.045]     else {
[18:02:00.045]         if (TRUE) {
[18:02:00.045]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:00.045]                 open = "w")
[18:02:00.045]         }
[18:02:00.045]         else {
[18:02:00.045]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:00.045]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:00.045]         }
[18:02:00.045]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:00.045]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:00.045]             base::sink(type = "output", split = FALSE)
[18:02:00.045]             base::close(...future.stdout)
[18:02:00.045]         }, add = TRUE)
[18:02:00.045]     }
[18:02:00.045]     ...future.frame <- base::sys.nframe()
[18:02:00.045]     ...future.conditions <- base::list()
[18:02:00.045]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:00.045]     if (FALSE) {
[18:02:00.045]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:00.045]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:00.045]     }
[18:02:00.045]     ...future.result <- base::tryCatch({
[18:02:00.045]         base::withCallingHandlers({
[18:02:00.045]             ...future.value <- base::withVisible(base::local({
[18:02:00.045]                 withCallingHandlers({
[18:02:00.045]                   {
[18:02:00.045]                     do.call(function(...) {
[18:02:00.045]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.045]                       if (!identical(...future.globals.maxSize.org, 
[18:02:00.045]                         ...future.globals.maxSize)) {
[18:02:00.045]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.045]                         on.exit(options(oopts), add = TRUE)
[18:02:00.045]                       }
[18:02:00.045]                       {
[18:02:00.045]                         lapply(seq_along(...future.elements_ii), 
[18:02:00.045]                           FUN = function(jj) {
[18:02:00.045]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.045]                             ...future.FUN(...future.X_jj, ...)
[18:02:00.045]                           })
[18:02:00.045]                       }
[18:02:00.045]                     }, args = future.call.arguments)
[18:02:00.045]                   }
[18:02:00.045]                 }, immediateCondition = function(cond) {
[18:02:00.045]                   save_rds <- function (object, pathname, ...) 
[18:02:00.045]                   {
[18:02:00.045]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:00.045]                     if (file_test("-f", pathname_tmp)) {
[18:02:00.045]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.045]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:00.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.045]                         fi_tmp[["mtime"]])
[18:02:00.045]                     }
[18:02:00.045]                     tryCatch({
[18:02:00.045]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:00.045]                     }, error = function(ex) {
[18:02:00.045]                       msg <- conditionMessage(ex)
[18:02:00.045]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.045]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:00.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.045]                         fi_tmp[["mtime"]], msg)
[18:02:00.045]                       ex$message <- msg
[18:02:00.045]                       stop(ex)
[18:02:00.045]                     })
[18:02:00.045]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:00.045]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:00.045]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:00.045]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.045]                       fi <- file.info(pathname)
[18:02:00.045]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:00.045]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.045]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:00.045]                         fi[["size"]], fi[["mtime"]])
[18:02:00.045]                       stop(msg)
[18:02:00.045]                     }
[18:02:00.045]                     invisible(pathname)
[18:02:00.045]                   }
[18:02:00.045]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:00.045]                     rootPath = tempdir()) 
[18:02:00.045]                   {
[18:02:00.045]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:00.045]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:00.045]                       tmpdir = path, fileext = ".rds")
[18:02:00.045]                     save_rds(obj, file)
[18:02:00.045]                   }
[18:02:00.045]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:02:00.045]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.045]                   {
[18:02:00.045]                     inherits <- base::inherits
[18:02:00.045]                     invokeRestart <- base::invokeRestart
[18:02:00.045]                     is.null <- base::is.null
[18:02:00.045]                     muffled <- FALSE
[18:02:00.045]                     if (inherits(cond, "message")) {
[18:02:00.045]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:00.045]                       if (muffled) 
[18:02:00.045]                         invokeRestart("muffleMessage")
[18:02:00.045]                     }
[18:02:00.045]                     else if (inherits(cond, "warning")) {
[18:02:00.045]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:00.045]                       if (muffled) 
[18:02:00.045]                         invokeRestart("muffleWarning")
[18:02:00.045]                     }
[18:02:00.045]                     else if (inherits(cond, "condition")) {
[18:02:00.045]                       if (!is.null(pattern)) {
[18:02:00.045]                         computeRestarts <- base::computeRestarts
[18:02:00.045]                         grepl <- base::grepl
[18:02:00.045]                         restarts <- computeRestarts(cond)
[18:02:00.045]                         for (restart in restarts) {
[18:02:00.045]                           name <- restart$name
[18:02:00.045]                           if (is.null(name)) 
[18:02:00.045]                             next
[18:02:00.045]                           if (!grepl(pattern, name)) 
[18:02:00.045]                             next
[18:02:00.045]                           invokeRestart(restart)
[18:02:00.045]                           muffled <- TRUE
[18:02:00.045]                           break
[18:02:00.045]                         }
[18:02:00.045]                       }
[18:02:00.045]                     }
[18:02:00.045]                     invisible(muffled)
[18:02:00.045]                   }
[18:02:00.045]                   muffleCondition(cond)
[18:02:00.045]                 })
[18:02:00.045]             }))
[18:02:00.045]             future::FutureResult(value = ...future.value$value, 
[18:02:00.045]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:00.045]                   ...future.rng), globalenv = if (FALSE) 
[18:02:00.045]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:00.045]                     ...future.globalenv.names))
[18:02:00.045]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:00.045]         }, condition = base::local({
[18:02:00.045]             c <- base::c
[18:02:00.045]             inherits <- base::inherits
[18:02:00.045]             invokeRestart <- base::invokeRestart
[18:02:00.045]             length <- base::length
[18:02:00.045]             list <- base::list
[18:02:00.045]             seq.int <- base::seq.int
[18:02:00.045]             signalCondition <- base::signalCondition
[18:02:00.045]             sys.calls <- base::sys.calls
[18:02:00.045]             `[[` <- base::`[[`
[18:02:00.045]             `+` <- base::`+`
[18:02:00.045]             `<<-` <- base::`<<-`
[18:02:00.045]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:00.045]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:00.045]                   3L)]
[18:02:00.045]             }
[18:02:00.045]             function(cond) {
[18:02:00.045]                 is_error <- inherits(cond, "error")
[18:02:00.045]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:00.045]                   NULL)
[18:02:00.045]                 if (is_error) {
[18:02:00.045]                   sessionInformation <- function() {
[18:02:00.045]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:00.045]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:00.045]                       search = base::search(), system = base::Sys.info())
[18:02:00.045]                   }
[18:02:00.045]                   ...future.conditions[[length(...future.conditions) + 
[18:02:00.045]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:00.045]                     cond$call), session = sessionInformation(), 
[18:02:00.045]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:00.045]                   signalCondition(cond)
[18:02:00.045]                 }
[18:02:00.045]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:00.045]                 "immediateCondition"))) {
[18:02:00.045]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:00.045]                   ...future.conditions[[length(...future.conditions) + 
[18:02:00.045]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:00.045]                   if (TRUE && !signal) {
[18:02:00.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.045]                     {
[18:02:00.045]                       inherits <- base::inherits
[18:02:00.045]                       invokeRestart <- base::invokeRestart
[18:02:00.045]                       is.null <- base::is.null
[18:02:00.045]                       muffled <- FALSE
[18:02:00.045]                       if (inherits(cond, "message")) {
[18:02:00.045]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:00.045]                         if (muffled) 
[18:02:00.045]                           invokeRestart("muffleMessage")
[18:02:00.045]                       }
[18:02:00.045]                       else if (inherits(cond, "warning")) {
[18:02:00.045]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:00.045]                         if (muffled) 
[18:02:00.045]                           invokeRestart("muffleWarning")
[18:02:00.045]                       }
[18:02:00.045]                       else if (inherits(cond, "condition")) {
[18:02:00.045]                         if (!is.null(pattern)) {
[18:02:00.045]                           computeRestarts <- base::computeRestarts
[18:02:00.045]                           grepl <- base::grepl
[18:02:00.045]                           restarts <- computeRestarts(cond)
[18:02:00.045]                           for (restart in restarts) {
[18:02:00.045]                             name <- restart$name
[18:02:00.045]                             if (is.null(name)) 
[18:02:00.045]                               next
[18:02:00.045]                             if (!grepl(pattern, name)) 
[18:02:00.045]                               next
[18:02:00.045]                             invokeRestart(restart)
[18:02:00.045]                             muffled <- TRUE
[18:02:00.045]                             break
[18:02:00.045]                           }
[18:02:00.045]                         }
[18:02:00.045]                       }
[18:02:00.045]                       invisible(muffled)
[18:02:00.045]                     }
[18:02:00.045]                     muffleCondition(cond, pattern = "^muffle")
[18:02:00.045]                   }
[18:02:00.045]                 }
[18:02:00.045]                 else {
[18:02:00.045]                   if (TRUE) {
[18:02:00.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.045]                     {
[18:02:00.045]                       inherits <- base::inherits
[18:02:00.045]                       invokeRestart <- base::invokeRestart
[18:02:00.045]                       is.null <- base::is.null
[18:02:00.045]                       muffled <- FALSE
[18:02:00.045]                       if (inherits(cond, "message")) {
[18:02:00.045]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:00.045]                         if (muffled) 
[18:02:00.045]                           invokeRestart("muffleMessage")
[18:02:00.045]                       }
[18:02:00.045]                       else if (inherits(cond, "warning")) {
[18:02:00.045]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:00.045]                         if (muffled) 
[18:02:00.045]                           invokeRestart("muffleWarning")
[18:02:00.045]                       }
[18:02:00.045]                       else if (inherits(cond, "condition")) {
[18:02:00.045]                         if (!is.null(pattern)) {
[18:02:00.045]                           computeRestarts <- base::computeRestarts
[18:02:00.045]                           grepl <- base::grepl
[18:02:00.045]                           restarts <- computeRestarts(cond)
[18:02:00.045]                           for (restart in restarts) {
[18:02:00.045]                             name <- restart$name
[18:02:00.045]                             if (is.null(name)) 
[18:02:00.045]                               next
[18:02:00.045]                             if (!grepl(pattern, name)) 
[18:02:00.045]                               next
[18:02:00.045]                             invokeRestart(restart)
[18:02:00.045]                             muffled <- TRUE
[18:02:00.045]                             break
[18:02:00.045]                           }
[18:02:00.045]                         }
[18:02:00.045]                       }
[18:02:00.045]                       invisible(muffled)
[18:02:00.045]                     }
[18:02:00.045]                     muffleCondition(cond, pattern = "^muffle")
[18:02:00.045]                   }
[18:02:00.045]                 }
[18:02:00.045]             }
[18:02:00.045]         }))
[18:02:00.045]     }, error = function(ex) {
[18:02:00.045]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:00.045]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:00.045]                 ...future.rng), started = ...future.startTime, 
[18:02:00.045]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:00.045]             version = "1.8"), class = "FutureResult")
[18:02:00.045]     }, finally = {
[18:02:00.045]         if (!identical(...future.workdir, getwd())) 
[18:02:00.045]             setwd(...future.workdir)
[18:02:00.045]         {
[18:02:00.045]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:00.045]                 ...future.oldOptions$nwarnings <- NULL
[18:02:00.045]             }
[18:02:00.045]             base::options(...future.oldOptions)
[18:02:00.045]             if (.Platform$OS.type == "windows") {
[18:02:00.045]                 old_names <- names(...future.oldEnvVars)
[18:02:00.045]                 envs <- base::Sys.getenv()
[18:02:00.045]                 names <- names(envs)
[18:02:00.045]                 common <- intersect(names, old_names)
[18:02:00.045]                 added <- setdiff(names, old_names)
[18:02:00.045]                 removed <- setdiff(old_names, names)
[18:02:00.045]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:00.045]                   envs[common]]
[18:02:00.045]                 NAMES <- toupper(changed)
[18:02:00.045]                 args <- list()
[18:02:00.045]                 for (kk in seq_along(NAMES)) {
[18:02:00.045]                   name <- changed[[kk]]
[18:02:00.045]                   NAME <- NAMES[[kk]]
[18:02:00.045]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.045]                     next
[18:02:00.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:00.045]                 }
[18:02:00.045]                 NAMES <- toupper(added)
[18:02:00.045]                 for (kk in seq_along(NAMES)) {
[18:02:00.045]                   name <- added[[kk]]
[18:02:00.045]                   NAME <- NAMES[[kk]]
[18:02:00.045]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.045]                     next
[18:02:00.045]                   args[[name]] <- ""
[18:02:00.045]                 }
[18:02:00.045]                 NAMES <- toupper(removed)
[18:02:00.045]                 for (kk in seq_along(NAMES)) {
[18:02:00.045]                   name <- removed[[kk]]
[18:02:00.045]                   NAME <- NAMES[[kk]]
[18:02:00.045]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.045]                     next
[18:02:00.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:00.045]                 }
[18:02:00.045]                 if (length(args) > 0) 
[18:02:00.045]                   base::do.call(base::Sys.setenv, args = args)
[18:02:00.045]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:00.045]             }
[18:02:00.045]             else {
[18:02:00.045]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:00.045]             }
[18:02:00.045]             {
[18:02:00.045]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:00.045]                   0L) {
[18:02:00.045]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:00.045]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:00.045]                   base::options(opts)
[18:02:00.045]                 }
[18:02:00.045]                 {
[18:02:00.045]                   {
[18:02:00.045]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:00.045]                     NULL
[18:02:00.045]                   }
[18:02:00.045]                   options(future.plan = NULL)
[18:02:00.045]                   if (is.na(NA_character_)) 
[18:02:00.045]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:00.045]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:00.045]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:00.045]                     .init = FALSE)
[18:02:00.045]                 }
[18:02:00.045]             }
[18:02:00.045]         }
[18:02:00.045]     })
[18:02:00.045]     if (TRUE) {
[18:02:00.045]         base::sink(type = "output", split = FALSE)
[18:02:00.045]         if (TRUE) {
[18:02:00.045]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:00.045]         }
[18:02:00.045]         else {
[18:02:00.045]             ...future.result["stdout"] <- base::list(NULL)
[18:02:00.045]         }
[18:02:00.045]         base::close(...future.stdout)
[18:02:00.045]         ...future.stdout <- NULL
[18:02:00.045]     }
[18:02:00.045]     ...future.result$conditions <- ...future.conditions
[18:02:00.045]     ...future.result$finished <- base::Sys.time()
[18:02:00.045]     ...future.result
[18:02:00.045] }
[18:02:00.051] assign_globals() ...
[18:02:00.052] List of 5
[18:02:00.052]  $ ...future.FUN            :function (x, y)  
[18:02:00.052]  $ future.call.arguments    :List of 1
[18:02:00.052]   ..$ y: num [1:5] 2 4 6 8 10
[18:02:00.052]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.052]  $ ...future.elements_ii    :List of 2
[18:02:00.052]   ..$ C: num 70
[18:02:00.052]   ..$ D: num 80
[18:02:00.052]  $ ...future.seeds_ii       : NULL
[18:02:00.052]  $ ...future.globals.maxSize: NULL
[18:02:00.052]  - attr(*, "where")=List of 5
[18:02:00.052]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:00.052]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:00.052]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:00.052]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:00.052]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:00.052]  - attr(*, "resolved")= logi FALSE
[18:02:00.052]  - attr(*, "total_size")= num 4264
[18:02:00.052]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.052]  - attr(*, "already-done")= logi TRUE
[18:02:00.078] - reassign environment for ‘...future.FUN’
[18:02:00.078] - copied ‘...future.FUN’ to environment
[18:02:00.079] - copied ‘future.call.arguments’ to environment
[18:02:00.079] - copied ‘...future.elements_ii’ to environment
[18:02:00.079] - copied ‘...future.seeds_ii’ to environment
[18:02:00.080] - copied ‘...future.globals.maxSize’ to environment
[18:02:00.080] assign_globals() ... done
[18:02:00.080] requestCore(): workers = 2
[18:02:00.084] MulticoreFuture started
[18:02:00.086] - Launch lazy future ... done
[18:02:00.086] run() for ‘MulticoreFuture’ ... done
[18:02:00.087] Created future:
[18:02:00.089] plan(): Setting new future strategy stack:
[18:02:00.091] List of future strategies:
[18:02:00.091] 1. sequential:
[18:02:00.091]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:00.091]    - tweaked: FALSE
[18:02:00.091]    - call: NULL
[18:02:00.095] plan(): nbrOfWorkers() = 1
[18:02:00.099] plan(): Setting new future strategy stack:
[18:02:00.100] List of future strategies:
[18:02:00.100] 1. multicore:
[18:02:00.100]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:00.100]    - tweaked: FALSE
[18:02:00.100]    - call: plan(strategy)
[18:02:00.088] MulticoreFuture:
[18:02:00.088] Label: ‘future_sapply-2’
[18:02:00.088] Expression:
[18:02:00.088] {
[18:02:00.088]     do.call(function(...) {
[18:02:00.088]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.088]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.088]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.088]             on.exit(options(oopts), add = TRUE)
[18:02:00.088]         }
[18:02:00.088]         {
[18:02:00.088]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.088]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.088]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.088]             })
[18:02:00.088]         }
[18:02:00.088]     }, args = future.call.arguments)
[18:02:00.088] }
[18:02:00.088] Lazy evaluation: FALSE
[18:02:00.088] Asynchronous evaluation: TRUE
[18:02:00.088] Local evaluation: TRUE
[18:02:00.088] Environment: R_GlobalEnv
[18:02:00.088] Capture standard output: TRUE
[18:02:00.088] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:00.088] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:00.088] Packages: <none>
[18:02:00.088] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:00.088] Resolved: FALSE
[18:02:00.088] Value: <not collected>
[18:02:00.088] Conditions captured: <none>
[18:02:00.088] Early signaling: FALSE
[18:02:00.088] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:00.088] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.105] Chunk #2 of 2 ... DONE
[18:02:00.106] Launching 2 futures (chunks) ... DONE
[18:02:00.106] Resolving 2 futures (chunks) ...
[18:02:00.109] resolve() on list ...
[18:02:00.109]  recursive: 0
[18:02:00.110]  length: 2
[18:02:00.110] 
[18:02:00.113] Future #1
[18:02:00.113] result() for MulticoreFuture ...
[18:02:00.117] plan(): nbrOfWorkers() = 2
[18:02:00.118] result() for MulticoreFuture ...
[18:02:00.118] result() for MulticoreFuture ... done
[18:02:00.119] result() for MulticoreFuture ... done
[18:02:00.119] result() for MulticoreFuture ...
[18:02:00.120] result() for MulticoreFuture ... done
[18:02:00.120] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:02:00.121] - nx: 2
[18:02:00.121] - relay: TRUE
[18:02:00.121] - stdout: TRUE
[18:02:00.122] - signal: TRUE
[18:02:00.122] - resignal: FALSE
[18:02:00.122] - force: TRUE
[18:02:00.123] - relayed: [n=2] FALSE, FALSE
[18:02:00.123] - queued futures: [n=2] FALSE, FALSE
[18:02:00.123]  - until=1
[18:02:00.124]  - relaying element #1
[18:02:00.124] result() for MulticoreFuture ...
[18:02:00.124] result() for MulticoreFuture ... done
[18:02:00.125] result() for MulticoreFuture ...
[18:02:00.125] result() for MulticoreFuture ... done
[18:02:00.125] result() for MulticoreFuture ...
[18:02:00.126] result() for MulticoreFuture ... done
[18:02:00.126] result() for MulticoreFuture ...
[18:02:00.126] result() for MulticoreFuture ... done
[18:02:00.127] - relayed: [n=2] TRUE, FALSE
[18:02:00.127] - queued futures: [n=2] TRUE, FALSE
[18:02:00.127] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:02:00.128]  length: 1 (resolved future 1)
[18:02:00.128] Future #2
[18:02:00.129] result() for MulticoreFuture ...
[18:02:00.130] result() for MulticoreFuture ...
[18:02:00.131] result() for MulticoreFuture ... done
[18:02:00.133] result() for MulticoreFuture ... done
[18:02:00.133] result() for MulticoreFuture ...
[18:02:00.134] result() for MulticoreFuture ... done
[18:02:00.134] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:02:00.134] - nx: 2
[18:02:00.135] - relay: TRUE
[18:02:00.137] - stdout: TRUE
[18:02:00.137] - signal: TRUE
[18:02:00.137] - resignal: FALSE
[18:02:00.137] - force: TRUE
[18:02:00.138] - relayed: [n=2] TRUE, FALSE
[18:02:00.138] - queued futures: [n=2] TRUE, FALSE
[18:02:00.138]  - until=2
[18:02:00.138]  - relaying element #2
[18:02:00.139] result() for MulticoreFuture ...
[18:02:00.139] result() for MulticoreFuture ... done
[18:02:00.139] result() for MulticoreFuture ...
[18:02:00.139] result() for MulticoreFuture ... done
[18:02:00.140] result() for MulticoreFuture ...
[18:02:00.140] result() for MulticoreFuture ... done
[18:02:00.140] result() for MulticoreFuture ...
[18:02:00.141] result() for MulticoreFuture ... done
[18:02:00.141] - relayed: [n=2] TRUE, TRUE
[18:02:00.141] - queued futures: [n=2] TRUE, TRUE
[18:02:00.141] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:02:00.142]  length: 0 (resolved future 2)
[18:02:00.142] Relaying remaining futures
[18:02:00.142] signalConditionsASAP(NULL, pos=0) ...
[18:02:00.142] - nx: 2
[18:02:00.143] - relay: TRUE
[18:02:00.143] - stdout: TRUE
[18:02:00.143] - signal: TRUE
[18:02:00.143] - resignal: FALSE
[18:02:00.143] - force: TRUE
[18:02:00.144] - relayed: [n=2] TRUE, TRUE
[18:02:00.144] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:00.144] - relayed: [n=2] TRUE, TRUE
[18:02:00.144] - queued futures: [n=2] TRUE, TRUE
[18:02:00.145] signalConditionsASAP(NULL, pos=0) ... done
[18:02:00.145] resolve() on list ... DONE
[18:02:00.145] result() for MulticoreFuture ...
[18:02:00.145] result() for MulticoreFuture ... done
[18:02:00.146] result() for MulticoreFuture ...
[18:02:00.146] result() for MulticoreFuture ... done
[18:02:00.146] result() for MulticoreFuture ...
[18:02:00.146] result() for MulticoreFuture ... done
[18:02:00.147] result() for MulticoreFuture ...
[18:02:00.147] result() for MulticoreFuture ... done
[18:02:00.147]  - Number of value chunks collected: 2
[18:02:00.147] Resolving 2 futures (chunks) ... DONE
[18:02:00.148] Reducing values from 2 chunks ...
[18:02:00.148]  - Number of values collected after concatenation: 4
[18:02:00.148]  - Number of values expected: 4
[18:02:00.148] Reducing values from 2 chunks ... DONE
[18:02:00.149] future_lapply() ... DONE
[18:02:00.150] future_lapply() ...
[18:02:00.165] Number of chunks: 2
[18:02:00.165] getGlobalsAndPackagesXApply() ...
[18:02:00.166]  - future.globals: TRUE
[18:02:00.166] getGlobalsAndPackages() ...
[18:02:00.166] Searching for globals...
[18:02:00.175] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[18:02:00.175] Searching for globals ... DONE
[18:02:00.176] Resolving globals: FALSE
[18:02:00.177] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[18:02:00.178] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:00.179] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:00.179] - packages: [1] ‘future.apply’
[18:02:00.179] getGlobalsAndPackages() ... DONE
[18:02:00.179]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:00.180]  - needed namespaces: [n=1] ‘future.apply’
[18:02:00.180] Finding globals ... DONE
[18:02:00.180]  - use_args: TRUE
[18:02:00.180]  - Getting '...' globals ...
[18:02:00.181] resolve() on list ...
[18:02:00.181]  recursive: 0
[18:02:00.181]  length: 1
[18:02:00.181]  elements: ‘...’
[18:02:00.182]  length: 0 (resolved future 1)
[18:02:00.182] resolve() on list ... DONE
[18:02:00.182]    - '...' content: [n=1] ‘y’
[18:02:00.182] List of 1
[18:02:00.182]  $ ...:List of 1
[18:02:00.182]   ..$ y: num [1:5] 2 4 6 8 10
[18:02:00.182]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.182]  - attr(*, "where")=List of 1
[18:02:00.182]   ..$ ...:<environment: 0x6183c0b1a6c0> 
[18:02:00.182]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.182]  - attr(*, "resolved")= logi TRUE
[18:02:00.182]  - attr(*, "total_size")= num NA
[18:02:00.188]  - Getting '...' globals ... DONE
[18:02:00.189] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:00.189] List of 8
[18:02:00.189]  $ ...future.FUN:function (x, ...)  
[18:02:00.189]  $ x_FUN        :function (x, y)  
[18:02:00.189]  $ times        : int 15
[18:02:00.189]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:00.189]  $ stop_if_not  :function (...)  
[18:02:00.189]  $ dim          : int [1:2] 3 5
[18:02:00.189]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:02:00.189]  $ ...          :List of 1
[18:02:00.189]   ..$ y: num [1:5] 2 4 6 8 10
[18:02:00.189]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.189]  - attr(*, "where")=List of 8
[18:02:00.189]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:00.189]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:00.189]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:00.189]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:00.189]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:00.189]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:00.189]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:00.189]   ..$ ...          :<environment: 0x6183c0b1a6c0> 
[18:02:00.189]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.189]  - attr(*, "resolved")= logi FALSE
[18:02:00.189]  - attr(*, "total_size")= num 98600
[18:02:00.206] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:00.206] getGlobalsAndPackagesXApply() ... DONE
[18:02:00.206] Number of futures (= number of chunks): 2
[18:02:00.207] Launching 2 futures (chunks) ...
[18:02:00.207] Chunk #1 of 2 ...
[18:02:00.207]  - Finding globals in 'X' for chunk #1 ...
[18:02:00.207] getGlobalsAndPackages() ...
[18:02:00.208] Searching for globals...
[18:02:00.208] 
[18:02:00.209] Searching for globals ... DONE
[18:02:00.209] - globals: [0] <none>
[18:02:00.209] getGlobalsAndPackages() ... DONE
[18:02:00.209]    + additional globals found: [n=0] 
[18:02:00.209]    + additional namespaces needed: [n=0] 
[18:02:00.210]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:00.210]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:00.210]  - seeds: <none>
[18:02:00.210]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.211] getGlobalsAndPackages() ...
[18:02:00.211] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.211] Resolving globals: FALSE
[18:02:00.211] Tweak future expression to call with '...' arguments ...
[18:02:00.212] {
[18:02:00.212]     do.call(function(...) {
[18:02:00.212]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.212]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.212]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.212]             on.exit(options(oopts), add = TRUE)
[18:02:00.212]         }
[18:02:00.212]         {
[18:02:00.212]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.212]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.212]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.212]             })
[18:02:00.212]         }
[18:02:00.212]     }, args = future.call.arguments)
[18:02:00.212] }
[18:02:00.212] Tweak future expression to call with '...' arguments ... DONE
[18:02:00.214] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.214] - packages: [1] ‘future.apply’
[18:02:00.215] getGlobalsAndPackages() ... DONE
[18:02:00.215] run() for ‘Future’ ...
[18:02:00.216] - state: ‘created’
[18:02:00.216] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:00.223] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.223] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:00.224]   - Field: ‘label’
[18:02:00.224]   - Field: ‘local’
[18:02:00.224]   - Field: ‘owner’
[18:02:00.224]   - Field: ‘envir’
[18:02:00.225]   - Field: ‘workers’
[18:02:00.225]   - Field: ‘packages’
[18:02:00.225]   - Field: ‘gc’
[18:02:00.225]   - Field: ‘job’
[18:02:00.225]   - Field: ‘conditions’
[18:02:00.226]   - Field: ‘expr’
[18:02:00.226]   - Field: ‘uuid’
[18:02:00.226]   - Field: ‘seed’
[18:02:00.226]   - Field: ‘version’
[18:02:00.227]   - Field: ‘result’
[18:02:00.227]   - Field: ‘asynchronous’
[18:02:00.227]   - Field: ‘calls’
[18:02:00.227]   - Field: ‘globals’
[18:02:00.227]   - Field: ‘stdout’
[18:02:00.228]   - Field: ‘earlySignal’
[18:02:00.228]   - Field: ‘lazy’
[18:02:00.228]   - Field: ‘state’
[18:02:00.228] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:00.228] - Launch lazy future ...
[18:02:00.229] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:00.229] Packages needed by future strategies (n = 0): <none>
[18:02:00.230] {
[18:02:00.230]     {
[18:02:00.230]         {
[18:02:00.230]             ...future.startTime <- base::Sys.time()
[18:02:00.230]             {
[18:02:00.230]                 {
[18:02:00.230]                   {
[18:02:00.230]                     {
[18:02:00.230]                       {
[18:02:00.230]                         base::local({
[18:02:00.230]                           has_future <- base::requireNamespace("future", 
[18:02:00.230]                             quietly = TRUE)
[18:02:00.230]                           if (has_future) {
[18:02:00.230]                             ns <- base::getNamespace("future")
[18:02:00.230]                             version <- ns[[".package"]][["version"]]
[18:02:00.230]                             if (is.null(version)) 
[18:02:00.230]                               version <- utils::packageVersion("future")
[18:02:00.230]                           }
[18:02:00.230]                           else {
[18:02:00.230]                             version <- NULL
[18:02:00.230]                           }
[18:02:00.230]                           if (!has_future || version < "1.8.0") {
[18:02:00.230]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:00.230]                               "", base::R.version$version.string), 
[18:02:00.230]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:00.230]                                 base::R.version$platform, 8 * 
[18:02:00.230]                                   base::.Machine$sizeof.pointer), 
[18:02:00.230]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:00.230]                                 "release", "version")], collapse = " "), 
[18:02:00.230]                               hostname = base::Sys.info()[["nodename"]])
[18:02:00.230]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:00.230]                               info)
[18:02:00.230]                             info <- base::paste(info, collapse = "; ")
[18:02:00.230]                             if (!has_future) {
[18:02:00.230]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:00.230]                                 info)
[18:02:00.230]                             }
[18:02:00.230]                             else {
[18:02:00.230]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:00.230]                                 info, version)
[18:02:00.230]                             }
[18:02:00.230]                             base::stop(msg)
[18:02:00.230]                           }
[18:02:00.230]                         })
[18:02:00.230]                       }
[18:02:00.230]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:00.230]                       base::options(mc.cores = 1L)
[18:02:00.230]                     }
[18:02:00.230]                     base::local({
[18:02:00.230]                       for (pkg in "future.apply") {
[18:02:00.230]                         base::loadNamespace(pkg)
[18:02:00.230]                         base::library(pkg, character.only = TRUE)
[18:02:00.230]                       }
[18:02:00.230]                     })
[18:02:00.230]                   }
[18:02:00.230]                   ...future.strategy.old <- future::plan("list")
[18:02:00.230]                   options(future.plan = NULL)
[18:02:00.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:00.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:00.230]                 }
[18:02:00.230]                 ...future.workdir <- getwd()
[18:02:00.230]             }
[18:02:00.230]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:00.230]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:00.230]         }
[18:02:00.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:00.230]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:00.230]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:00.230]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:00.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:00.230]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:00.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:00.230]             base::names(...future.oldOptions))
[18:02:00.230]     }
[18:02:00.230]     if (FALSE) {
[18:02:00.230]     }
[18:02:00.230]     else {
[18:02:00.230]         if (TRUE) {
[18:02:00.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:00.230]                 open = "w")
[18:02:00.230]         }
[18:02:00.230]         else {
[18:02:00.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:00.230]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:00.230]         }
[18:02:00.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:00.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:00.230]             base::sink(type = "output", split = FALSE)
[18:02:00.230]             base::close(...future.stdout)
[18:02:00.230]         }, add = TRUE)
[18:02:00.230]     }
[18:02:00.230]     ...future.frame <- base::sys.nframe()
[18:02:00.230]     ...future.conditions <- base::list()
[18:02:00.230]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:00.230]     if (FALSE) {
[18:02:00.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:00.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:00.230]     }
[18:02:00.230]     ...future.result <- base::tryCatch({
[18:02:00.230]         base::withCallingHandlers({
[18:02:00.230]             ...future.value <- base::withVisible(base::local({
[18:02:00.230]                 withCallingHandlers({
[18:02:00.230]                   {
[18:02:00.230]                     do.call(function(...) {
[18:02:00.230]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.230]                       if (!identical(...future.globals.maxSize.org, 
[18:02:00.230]                         ...future.globals.maxSize)) {
[18:02:00.230]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.230]                         on.exit(options(oopts), add = TRUE)
[18:02:00.230]                       }
[18:02:00.230]                       {
[18:02:00.230]                         lapply(seq_along(...future.elements_ii), 
[18:02:00.230]                           FUN = function(jj) {
[18:02:00.230]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.230]                             ...future.FUN(...future.X_jj, ...)
[18:02:00.230]                           })
[18:02:00.230]                       }
[18:02:00.230]                     }, args = future.call.arguments)
[18:02:00.230]                   }
[18:02:00.230]                 }, immediateCondition = function(cond) {
[18:02:00.230]                   save_rds <- function (object, pathname, ...) 
[18:02:00.230]                   {
[18:02:00.230]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:00.230]                     if (file_test("-f", pathname_tmp)) {
[18:02:00.230]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.230]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:00.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.230]                         fi_tmp[["mtime"]])
[18:02:00.230]                     }
[18:02:00.230]                     tryCatch({
[18:02:00.230]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:00.230]                     }, error = function(ex) {
[18:02:00.230]                       msg <- conditionMessage(ex)
[18:02:00.230]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.230]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:00.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.230]                         fi_tmp[["mtime"]], msg)
[18:02:00.230]                       ex$message <- msg
[18:02:00.230]                       stop(ex)
[18:02:00.230]                     })
[18:02:00.230]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:00.230]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:00.230]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:00.230]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.230]                       fi <- file.info(pathname)
[18:02:00.230]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:00.230]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.230]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:00.230]                         fi[["size"]], fi[["mtime"]])
[18:02:00.230]                       stop(msg)
[18:02:00.230]                     }
[18:02:00.230]                     invisible(pathname)
[18:02:00.230]                   }
[18:02:00.230]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:00.230]                     rootPath = tempdir()) 
[18:02:00.230]                   {
[18:02:00.230]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:00.230]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:00.230]                       tmpdir = path, fileext = ".rds")
[18:02:00.230]                     save_rds(obj, file)
[18:02:00.230]                   }
[18:02:00.230]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:02:00.230]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.230]                   {
[18:02:00.230]                     inherits <- base::inherits
[18:02:00.230]                     invokeRestart <- base::invokeRestart
[18:02:00.230]                     is.null <- base::is.null
[18:02:00.230]                     muffled <- FALSE
[18:02:00.230]                     if (inherits(cond, "message")) {
[18:02:00.230]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:00.230]                       if (muffled) 
[18:02:00.230]                         invokeRestart("muffleMessage")
[18:02:00.230]                     }
[18:02:00.230]                     else if (inherits(cond, "warning")) {
[18:02:00.230]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:00.230]                       if (muffled) 
[18:02:00.230]                         invokeRestart("muffleWarning")
[18:02:00.230]                     }
[18:02:00.230]                     else if (inherits(cond, "condition")) {
[18:02:00.230]                       if (!is.null(pattern)) {
[18:02:00.230]                         computeRestarts <- base::computeRestarts
[18:02:00.230]                         grepl <- base::grepl
[18:02:00.230]                         restarts <- computeRestarts(cond)
[18:02:00.230]                         for (restart in restarts) {
[18:02:00.230]                           name <- restart$name
[18:02:00.230]                           if (is.null(name)) 
[18:02:00.230]                             next
[18:02:00.230]                           if (!grepl(pattern, name)) 
[18:02:00.230]                             next
[18:02:00.230]                           invokeRestart(restart)
[18:02:00.230]                           muffled <- TRUE
[18:02:00.230]                           break
[18:02:00.230]                         }
[18:02:00.230]                       }
[18:02:00.230]                     }
[18:02:00.230]                     invisible(muffled)
[18:02:00.230]                   }
[18:02:00.230]                   muffleCondition(cond)
[18:02:00.230]                 })
[18:02:00.230]             }))
[18:02:00.230]             future::FutureResult(value = ...future.value$value, 
[18:02:00.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:00.230]                   ...future.rng), globalenv = if (FALSE) 
[18:02:00.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:00.230]                     ...future.globalenv.names))
[18:02:00.230]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:00.230]         }, condition = base::local({
[18:02:00.230]             c <- base::c
[18:02:00.230]             inherits <- base::inherits
[18:02:00.230]             invokeRestart <- base::invokeRestart
[18:02:00.230]             length <- base::length
[18:02:00.230]             list <- base::list
[18:02:00.230]             seq.int <- base::seq.int
[18:02:00.230]             signalCondition <- base::signalCondition
[18:02:00.230]             sys.calls <- base::sys.calls
[18:02:00.230]             `[[` <- base::`[[`
[18:02:00.230]             `+` <- base::`+`
[18:02:00.230]             `<<-` <- base::`<<-`
[18:02:00.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:00.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:00.230]                   3L)]
[18:02:00.230]             }
[18:02:00.230]             function(cond) {
[18:02:00.230]                 is_error <- inherits(cond, "error")
[18:02:00.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:00.230]                   NULL)
[18:02:00.230]                 if (is_error) {
[18:02:00.230]                   sessionInformation <- function() {
[18:02:00.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:00.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:00.230]                       search = base::search(), system = base::Sys.info())
[18:02:00.230]                   }
[18:02:00.230]                   ...future.conditions[[length(...future.conditions) + 
[18:02:00.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:00.230]                     cond$call), session = sessionInformation(), 
[18:02:00.230]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:00.230]                   signalCondition(cond)
[18:02:00.230]                 }
[18:02:00.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:00.230]                 "immediateCondition"))) {
[18:02:00.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:00.230]                   ...future.conditions[[length(...future.conditions) + 
[18:02:00.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:00.230]                   if (TRUE && !signal) {
[18:02:00.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.230]                     {
[18:02:00.230]                       inherits <- base::inherits
[18:02:00.230]                       invokeRestart <- base::invokeRestart
[18:02:00.230]                       is.null <- base::is.null
[18:02:00.230]                       muffled <- FALSE
[18:02:00.230]                       if (inherits(cond, "message")) {
[18:02:00.230]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:00.230]                         if (muffled) 
[18:02:00.230]                           invokeRestart("muffleMessage")
[18:02:00.230]                       }
[18:02:00.230]                       else if (inherits(cond, "warning")) {
[18:02:00.230]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:00.230]                         if (muffled) 
[18:02:00.230]                           invokeRestart("muffleWarning")
[18:02:00.230]                       }
[18:02:00.230]                       else if (inherits(cond, "condition")) {
[18:02:00.230]                         if (!is.null(pattern)) {
[18:02:00.230]                           computeRestarts <- base::computeRestarts
[18:02:00.230]                           grepl <- base::grepl
[18:02:00.230]                           restarts <- computeRestarts(cond)
[18:02:00.230]                           for (restart in restarts) {
[18:02:00.230]                             name <- restart$name
[18:02:00.230]                             if (is.null(name)) 
[18:02:00.230]                               next
[18:02:00.230]                             if (!grepl(pattern, name)) 
[18:02:00.230]                               next
[18:02:00.230]                             invokeRestart(restart)
[18:02:00.230]                             muffled <- TRUE
[18:02:00.230]                             break
[18:02:00.230]                           }
[18:02:00.230]                         }
[18:02:00.230]                       }
[18:02:00.230]                       invisible(muffled)
[18:02:00.230]                     }
[18:02:00.230]                     muffleCondition(cond, pattern = "^muffle")
[18:02:00.230]                   }
[18:02:00.230]                 }
[18:02:00.230]                 else {
[18:02:00.230]                   if (TRUE) {
[18:02:00.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.230]                     {
[18:02:00.230]                       inherits <- base::inherits
[18:02:00.230]                       invokeRestart <- base::invokeRestart
[18:02:00.230]                       is.null <- base::is.null
[18:02:00.230]                       muffled <- FALSE
[18:02:00.230]                       if (inherits(cond, "message")) {
[18:02:00.230]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:00.230]                         if (muffled) 
[18:02:00.230]                           invokeRestart("muffleMessage")
[18:02:00.230]                       }
[18:02:00.230]                       else if (inherits(cond, "warning")) {
[18:02:00.230]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:00.230]                         if (muffled) 
[18:02:00.230]                           invokeRestart("muffleWarning")
[18:02:00.230]                       }
[18:02:00.230]                       else if (inherits(cond, "condition")) {
[18:02:00.230]                         if (!is.null(pattern)) {
[18:02:00.230]                           computeRestarts <- base::computeRestarts
[18:02:00.230]                           grepl <- base::grepl
[18:02:00.230]                           restarts <- computeRestarts(cond)
[18:02:00.230]                           for (restart in restarts) {
[18:02:00.230]                             name <- restart$name
[18:02:00.230]                             if (is.null(name)) 
[18:02:00.230]                               next
[18:02:00.230]                             if (!grepl(pattern, name)) 
[18:02:00.230]                               next
[18:02:00.230]                             invokeRestart(restart)
[18:02:00.230]                             muffled <- TRUE
[18:02:00.230]                             break
[18:02:00.230]                           }
[18:02:00.230]                         }
[18:02:00.230]                       }
[18:02:00.230]                       invisible(muffled)
[18:02:00.230]                     }
[18:02:00.230]                     muffleCondition(cond, pattern = "^muffle")
[18:02:00.230]                   }
[18:02:00.230]                 }
[18:02:00.230]             }
[18:02:00.230]         }))
[18:02:00.230]     }, error = function(ex) {
[18:02:00.230]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:00.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:00.230]                 ...future.rng), started = ...future.startTime, 
[18:02:00.230]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:00.230]             version = "1.8"), class = "FutureResult")
[18:02:00.230]     }, finally = {
[18:02:00.230]         if (!identical(...future.workdir, getwd())) 
[18:02:00.230]             setwd(...future.workdir)
[18:02:00.230]         {
[18:02:00.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:00.230]                 ...future.oldOptions$nwarnings <- NULL
[18:02:00.230]             }
[18:02:00.230]             base::options(...future.oldOptions)
[18:02:00.230]             if (.Platform$OS.type == "windows") {
[18:02:00.230]                 old_names <- names(...future.oldEnvVars)
[18:02:00.230]                 envs <- base::Sys.getenv()
[18:02:00.230]                 names <- names(envs)
[18:02:00.230]                 common <- intersect(names, old_names)
[18:02:00.230]                 added <- setdiff(names, old_names)
[18:02:00.230]                 removed <- setdiff(old_names, names)
[18:02:00.230]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:00.230]                   envs[common]]
[18:02:00.230]                 NAMES <- toupper(changed)
[18:02:00.230]                 args <- list()
[18:02:00.230]                 for (kk in seq_along(NAMES)) {
[18:02:00.230]                   name <- changed[[kk]]
[18:02:00.230]                   NAME <- NAMES[[kk]]
[18:02:00.230]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.230]                     next
[18:02:00.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:00.230]                 }
[18:02:00.230]                 NAMES <- toupper(added)
[18:02:00.230]                 for (kk in seq_along(NAMES)) {
[18:02:00.230]                   name <- added[[kk]]
[18:02:00.230]                   NAME <- NAMES[[kk]]
[18:02:00.230]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.230]                     next
[18:02:00.230]                   args[[name]] <- ""
[18:02:00.230]                 }
[18:02:00.230]                 NAMES <- toupper(removed)
[18:02:00.230]                 for (kk in seq_along(NAMES)) {
[18:02:00.230]                   name <- removed[[kk]]
[18:02:00.230]                   NAME <- NAMES[[kk]]
[18:02:00.230]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.230]                     next
[18:02:00.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:00.230]                 }
[18:02:00.230]                 if (length(args) > 0) 
[18:02:00.230]                   base::do.call(base::Sys.setenv, args = args)
[18:02:00.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:00.230]             }
[18:02:00.230]             else {
[18:02:00.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:00.230]             }
[18:02:00.230]             {
[18:02:00.230]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:00.230]                   0L) {
[18:02:00.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:00.230]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:00.230]                   base::options(opts)
[18:02:00.230]                 }
[18:02:00.230]                 {
[18:02:00.230]                   {
[18:02:00.230]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:00.230]                     NULL
[18:02:00.230]                   }
[18:02:00.230]                   options(future.plan = NULL)
[18:02:00.230]                   if (is.na(NA_character_)) 
[18:02:00.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:00.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:00.230]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:00.230]                     .init = FALSE)
[18:02:00.230]                 }
[18:02:00.230]             }
[18:02:00.230]         }
[18:02:00.230]     })
[18:02:00.230]     if (TRUE) {
[18:02:00.230]         base::sink(type = "output", split = FALSE)
[18:02:00.230]         if (TRUE) {
[18:02:00.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:00.230]         }
[18:02:00.230]         else {
[18:02:00.230]             ...future.result["stdout"] <- base::list(NULL)
[18:02:00.230]         }
[18:02:00.230]         base::close(...future.stdout)
[18:02:00.230]         ...future.stdout <- NULL
[18:02:00.230]     }
[18:02:00.230]     ...future.result$conditions <- ...future.conditions
[18:02:00.230]     ...future.result$finished <- base::Sys.time()
[18:02:00.230]     ...future.result
[18:02:00.230] }
[18:02:00.235] assign_globals() ...
[18:02:00.235] List of 11
[18:02:00.235]  $ ...future.FUN            :function (x, ...)  
[18:02:00.235]  $ x_FUN                    :function (x, y)  
[18:02:00.235]  $ times                    : int 15
[18:02:00.235]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:00.235]  $ stop_if_not              :function (...)  
[18:02:00.235]  $ dim                      : int [1:2] 3 5
[18:02:00.235]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:02:00.235]  $ future.call.arguments    :List of 1
[18:02:00.235]   ..$ y: num [1:5] 2 4 6 8 10
[18:02:00.235]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.235]  $ ...future.elements_ii    :List of 2
[18:02:00.235]   ..$ A: num 50
[18:02:00.235]   ..$ B: num 60
[18:02:00.235]  $ ...future.seeds_ii       : NULL
[18:02:00.235]  $ ...future.globals.maxSize: NULL
[18:02:00.235]  - attr(*, "where")=List of 11
[18:02:00.235]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:00.235]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:02:00.235]   ..$ times                    :<environment: R_EmptyEnv> 
[18:02:00.235]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:02:00.235]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:02:00.235]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:02:00.235]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:02:00.235]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:00.235]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:00.235]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:00.235]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:00.235]  - attr(*, "resolved")= logi FALSE
[18:02:00.235]  - attr(*, "total_size")= num 98600
[18:02:00.235]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.235]  - attr(*, "already-done")= logi TRUE
[18:02:00.255] - copied ‘...future.FUN’ to environment
[18:02:00.256] - reassign environment for ‘x_FUN’
[18:02:00.256] - copied ‘x_FUN’ to environment
[18:02:00.256] - copied ‘times’ to environment
[18:02:00.256] - copied ‘stopf’ to environment
[18:02:00.257] - copied ‘stop_if_not’ to environment
[18:02:00.257] - copied ‘dim’ to environment
[18:02:00.257] - copied ‘valid_types’ to environment
[18:02:00.257] - copied ‘future.call.arguments’ to environment
[18:02:00.257] - copied ‘...future.elements_ii’ to environment
[18:02:00.258] - copied ‘...future.seeds_ii’ to environment
[18:02:00.258] - copied ‘...future.globals.maxSize’ to environment
[18:02:00.258] assign_globals() ... done
[18:02:00.258] requestCore(): workers = 2
[18:02:00.262] MulticoreFuture started
[18:02:00.264] - Launch lazy future ... done
[18:02:00.265] run() for ‘MulticoreFuture’ ... done
[18:02:00.266] Created future:
[18:02:00.266] plan(): Setting new future strategy stack:
[18:02:00.267] List of future strategies:
[18:02:00.267] 1. sequential:
[18:02:00.267]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:00.267]    - tweaked: FALSE
[18:02:00.267]    - call: NULL
[18:02:00.271] plan(): nbrOfWorkers() = 1
[18:02:00.276] plan(): Setting new future strategy stack:
[18:02:00.277] List of future strategies:
[18:02:00.277] 1. multicore:
[18:02:00.277]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:00.277]    - tweaked: FALSE
[18:02:00.277]    - call: plan(strategy)
[18:02:00.267] MulticoreFuture:
[18:02:00.267] Label: ‘future_vapply-1’
[18:02:00.267] Expression:
[18:02:00.267] {
[18:02:00.267]     do.call(function(...) {
[18:02:00.267]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.267]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.267]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.267]             on.exit(options(oopts), add = TRUE)
[18:02:00.267]         }
[18:02:00.267]         {
[18:02:00.267]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.267]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.267]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.267]             })
[18:02:00.267]         }
[18:02:00.267]     }, args = future.call.arguments)
[18:02:00.267] }
[18:02:00.267] Lazy evaluation: FALSE
[18:02:00.267] Asynchronous evaluation: TRUE
[18:02:00.267] Local evaluation: TRUE
[18:02:00.267] Environment: R_GlobalEnv
[18:02:00.267] Capture standard output: TRUE
[18:02:00.267] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:00.267] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:00.267] Packages: 1 packages (‘future.apply’)
[18:02:00.267] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:00.267] Resolved: FALSE
[18:02:00.267] Value: <not collected>
[18:02:00.267] Conditions captured: <none>
[18:02:00.267] Early signaling: FALSE
[18:02:00.267] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:00.267] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.285] Chunk #1 of 2 ... DONE
[18:02:00.286] Chunk #2 of 2 ...
[18:02:00.286]  - Finding globals in 'X' for chunk #2 ...
[18:02:00.287] getGlobalsAndPackages() ...
[18:02:00.287] Searching for globals...
[18:02:00.287] plan(): nbrOfWorkers() = 2
[18:02:00.288] 
[18:02:00.288] Searching for globals ... DONE
[18:02:00.289] - globals: [0] <none>
[18:02:00.289] getGlobalsAndPackages() ... DONE
[18:02:00.289]    + additional globals found: [n=0] 
[18:02:00.289]    + additional namespaces needed: [n=0] 
[18:02:00.290]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:00.290]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:00.290]  - seeds: <none>
[18:02:00.291]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.291] getGlobalsAndPackages() ...
[18:02:00.291] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.292] Resolving globals: FALSE
[18:02:00.292] Tweak future expression to call with '...' arguments ...
[18:02:00.292] {
[18:02:00.292]     do.call(function(...) {
[18:02:00.292]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.292]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.292]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.292]             on.exit(options(oopts), add = TRUE)
[18:02:00.292]         }
[18:02:00.292]         {
[18:02:00.292]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.292]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.292]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.292]             })
[18:02:00.292]         }
[18:02:00.292]     }, args = future.call.arguments)
[18:02:00.292] }
[18:02:00.293] Tweak future expression to call with '...' arguments ... DONE
[18:02:00.295] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.296] - packages: [1] ‘future.apply’
[18:02:00.296] getGlobalsAndPackages() ... DONE
[18:02:00.297] run() for ‘Future’ ...
[18:02:00.297] - state: ‘created’
[18:02:00.298] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:00.306] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.306] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:00.306]   - Field: ‘label’
[18:02:00.307]   - Field: ‘local’
[18:02:00.307]   - Field: ‘owner’
[18:02:00.307]   - Field: ‘envir’
[18:02:00.307]   - Field: ‘workers’
[18:02:00.308]   - Field: ‘packages’
[18:02:00.308]   - Field: ‘gc’
[18:02:00.308]   - Field: ‘job’
[18:02:00.309]   - Field: ‘conditions’
[18:02:00.309]   - Field: ‘expr’
[18:02:00.309]   - Field: ‘uuid’
[18:02:00.310]   - Field: ‘seed’
[18:02:00.310]   - Field: ‘version’
[18:02:00.310]   - Field: ‘result’
[18:02:00.310]   - Field: ‘asynchronous’
[18:02:00.311]   - Field: ‘calls’
[18:02:00.311]   - Field: ‘globals’
[18:02:00.311]   - Field: ‘stdout’
[18:02:00.312]   - Field: ‘earlySignal’
[18:02:00.312]   - Field: ‘lazy’
[18:02:00.312]   - Field: ‘state’
[18:02:00.312] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:00.313] - Launch lazy future ...
[18:02:00.314] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:00.314] Packages needed by future strategies (n = 0): <none>
[18:02:00.316] {
[18:02:00.316]     {
[18:02:00.316]         {
[18:02:00.316]             ...future.startTime <- base::Sys.time()
[18:02:00.316]             {
[18:02:00.316]                 {
[18:02:00.316]                   {
[18:02:00.316]                     {
[18:02:00.316]                       {
[18:02:00.316]                         base::local({
[18:02:00.316]                           has_future <- base::requireNamespace("future", 
[18:02:00.316]                             quietly = TRUE)
[18:02:00.316]                           if (has_future) {
[18:02:00.316]                             ns <- base::getNamespace("future")
[18:02:00.316]                             version <- ns[[".package"]][["version"]]
[18:02:00.316]                             if (is.null(version)) 
[18:02:00.316]                               version <- utils::packageVersion("future")
[18:02:00.316]                           }
[18:02:00.316]                           else {
[18:02:00.316]                             version <- NULL
[18:02:00.316]                           }
[18:02:00.316]                           if (!has_future || version < "1.8.0") {
[18:02:00.316]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:00.316]                               "", base::R.version$version.string), 
[18:02:00.316]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:00.316]                                 base::R.version$platform, 8 * 
[18:02:00.316]                                   base::.Machine$sizeof.pointer), 
[18:02:00.316]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:00.316]                                 "release", "version")], collapse = " "), 
[18:02:00.316]                               hostname = base::Sys.info()[["nodename"]])
[18:02:00.316]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:00.316]                               info)
[18:02:00.316]                             info <- base::paste(info, collapse = "; ")
[18:02:00.316]                             if (!has_future) {
[18:02:00.316]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:00.316]                                 info)
[18:02:00.316]                             }
[18:02:00.316]                             else {
[18:02:00.316]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:00.316]                                 info, version)
[18:02:00.316]                             }
[18:02:00.316]                             base::stop(msg)
[18:02:00.316]                           }
[18:02:00.316]                         })
[18:02:00.316]                       }
[18:02:00.316]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:00.316]                       base::options(mc.cores = 1L)
[18:02:00.316]                     }
[18:02:00.316]                     base::local({
[18:02:00.316]                       for (pkg in "future.apply") {
[18:02:00.316]                         base::loadNamespace(pkg)
[18:02:00.316]                         base::library(pkg, character.only = TRUE)
[18:02:00.316]                       }
[18:02:00.316]                     })
[18:02:00.316]                   }
[18:02:00.316]                   ...future.strategy.old <- future::plan("list")
[18:02:00.316]                   options(future.plan = NULL)
[18:02:00.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:00.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:00.316]                 }
[18:02:00.316]                 ...future.workdir <- getwd()
[18:02:00.316]             }
[18:02:00.316]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:00.316]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:00.316]         }
[18:02:00.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:00.316]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:00.316]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:00.316]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:00.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:00.316]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:00.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:00.316]             base::names(...future.oldOptions))
[18:02:00.316]     }
[18:02:00.316]     if (FALSE) {
[18:02:00.316]     }
[18:02:00.316]     else {
[18:02:00.316]         if (TRUE) {
[18:02:00.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:00.316]                 open = "w")
[18:02:00.316]         }
[18:02:00.316]         else {
[18:02:00.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:00.316]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:00.316]         }
[18:02:00.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:00.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:00.316]             base::sink(type = "output", split = FALSE)
[18:02:00.316]             base::close(...future.stdout)
[18:02:00.316]         }, add = TRUE)
[18:02:00.316]     }
[18:02:00.316]     ...future.frame <- base::sys.nframe()
[18:02:00.316]     ...future.conditions <- base::list()
[18:02:00.316]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:00.316]     if (FALSE) {
[18:02:00.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:00.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:00.316]     }
[18:02:00.316]     ...future.result <- base::tryCatch({
[18:02:00.316]         base::withCallingHandlers({
[18:02:00.316]             ...future.value <- base::withVisible(base::local({
[18:02:00.316]                 withCallingHandlers({
[18:02:00.316]                   {
[18:02:00.316]                     do.call(function(...) {
[18:02:00.316]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.316]                       if (!identical(...future.globals.maxSize.org, 
[18:02:00.316]                         ...future.globals.maxSize)) {
[18:02:00.316]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.316]                         on.exit(options(oopts), add = TRUE)
[18:02:00.316]                       }
[18:02:00.316]                       {
[18:02:00.316]                         lapply(seq_along(...future.elements_ii), 
[18:02:00.316]                           FUN = function(jj) {
[18:02:00.316]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.316]                             ...future.FUN(...future.X_jj, ...)
[18:02:00.316]                           })
[18:02:00.316]                       }
[18:02:00.316]                     }, args = future.call.arguments)
[18:02:00.316]                   }
[18:02:00.316]                 }, immediateCondition = function(cond) {
[18:02:00.316]                   save_rds <- function (object, pathname, ...) 
[18:02:00.316]                   {
[18:02:00.316]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:00.316]                     if (file_test("-f", pathname_tmp)) {
[18:02:00.316]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.316]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:00.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.316]                         fi_tmp[["mtime"]])
[18:02:00.316]                     }
[18:02:00.316]                     tryCatch({
[18:02:00.316]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:00.316]                     }, error = function(ex) {
[18:02:00.316]                       msg <- conditionMessage(ex)
[18:02:00.316]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.316]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:00.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.316]                         fi_tmp[["mtime"]], msg)
[18:02:00.316]                       ex$message <- msg
[18:02:00.316]                       stop(ex)
[18:02:00.316]                     })
[18:02:00.316]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:00.316]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:00.316]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:00.316]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.316]                       fi <- file.info(pathname)
[18:02:00.316]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:00.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.316]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:00.316]                         fi[["size"]], fi[["mtime"]])
[18:02:00.316]                       stop(msg)
[18:02:00.316]                     }
[18:02:00.316]                     invisible(pathname)
[18:02:00.316]                   }
[18:02:00.316]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:00.316]                     rootPath = tempdir()) 
[18:02:00.316]                   {
[18:02:00.316]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:00.316]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:00.316]                       tmpdir = path, fileext = ".rds")
[18:02:00.316]                     save_rds(obj, file)
[18:02:00.316]                   }
[18:02:00.316]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:02:00.316]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.316]                   {
[18:02:00.316]                     inherits <- base::inherits
[18:02:00.316]                     invokeRestart <- base::invokeRestart
[18:02:00.316]                     is.null <- base::is.null
[18:02:00.316]                     muffled <- FALSE
[18:02:00.316]                     if (inherits(cond, "message")) {
[18:02:00.316]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:00.316]                       if (muffled) 
[18:02:00.316]                         invokeRestart("muffleMessage")
[18:02:00.316]                     }
[18:02:00.316]                     else if (inherits(cond, "warning")) {
[18:02:00.316]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:00.316]                       if (muffled) 
[18:02:00.316]                         invokeRestart("muffleWarning")
[18:02:00.316]                     }
[18:02:00.316]                     else if (inherits(cond, "condition")) {
[18:02:00.316]                       if (!is.null(pattern)) {
[18:02:00.316]                         computeRestarts <- base::computeRestarts
[18:02:00.316]                         grepl <- base::grepl
[18:02:00.316]                         restarts <- computeRestarts(cond)
[18:02:00.316]                         for (restart in restarts) {
[18:02:00.316]                           name <- restart$name
[18:02:00.316]                           if (is.null(name)) 
[18:02:00.316]                             next
[18:02:00.316]                           if (!grepl(pattern, name)) 
[18:02:00.316]                             next
[18:02:00.316]                           invokeRestart(restart)
[18:02:00.316]                           muffled <- TRUE
[18:02:00.316]                           break
[18:02:00.316]                         }
[18:02:00.316]                       }
[18:02:00.316]                     }
[18:02:00.316]                     invisible(muffled)
[18:02:00.316]                   }
[18:02:00.316]                   muffleCondition(cond)
[18:02:00.316]                 })
[18:02:00.316]             }))
[18:02:00.316]             future::FutureResult(value = ...future.value$value, 
[18:02:00.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:00.316]                   ...future.rng), globalenv = if (FALSE) 
[18:02:00.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:00.316]                     ...future.globalenv.names))
[18:02:00.316]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:00.316]         }, condition = base::local({
[18:02:00.316]             c <- base::c
[18:02:00.316]             inherits <- base::inherits
[18:02:00.316]             invokeRestart <- base::invokeRestart
[18:02:00.316]             length <- base::length
[18:02:00.316]             list <- base::list
[18:02:00.316]             seq.int <- base::seq.int
[18:02:00.316]             signalCondition <- base::signalCondition
[18:02:00.316]             sys.calls <- base::sys.calls
[18:02:00.316]             `[[` <- base::`[[`
[18:02:00.316]             `+` <- base::`+`
[18:02:00.316]             `<<-` <- base::`<<-`
[18:02:00.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:00.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:00.316]                   3L)]
[18:02:00.316]             }
[18:02:00.316]             function(cond) {
[18:02:00.316]                 is_error <- inherits(cond, "error")
[18:02:00.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:00.316]                   NULL)
[18:02:00.316]                 if (is_error) {
[18:02:00.316]                   sessionInformation <- function() {
[18:02:00.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:00.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:00.316]                       search = base::search(), system = base::Sys.info())
[18:02:00.316]                   }
[18:02:00.316]                   ...future.conditions[[length(...future.conditions) + 
[18:02:00.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:00.316]                     cond$call), session = sessionInformation(), 
[18:02:00.316]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:00.316]                   signalCondition(cond)
[18:02:00.316]                 }
[18:02:00.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:00.316]                 "immediateCondition"))) {
[18:02:00.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:00.316]                   ...future.conditions[[length(...future.conditions) + 
[18:02:00.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:00.316]                   if (TRUE && !signal) {
[18:02:00.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.316]                     {
[18:02:00.316]                       inherits <- base::inherits
[18:02:00.316]                       invokeRestart <- base::invokeRestart
[18:02:00.316]                       is.null <- base::is.null
[18:02:00.316]                       muffled <- FALSE
[18:02:00.316]                       if (inherits(cond, "message")) {
[18:02:00.316]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:00.316]                         if (muffled) 
[18:02:00.316]                           invokeRestart("muffleMessage")
[18:02:00.316]                       }
[18:02:00.316]                       else if (inherits(cond, "warning")) {
[18:02:00.316]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:00.316]                         if (muffled) 
[18:02:00.316]                           invokeRestart("muffleWarning")
[18:02:00.316]                       }
[18:02:00.316]                       else if (inherits(cond, "condition")) {
[18:02:00.316]                         if (!is.null(pattern)) {
[18:02:00.316]                           computeRestarts <- base::computeRestarts
[18:02:00.316]                           grepl <- base::grepl
[18:02:00.316]                           restarts <- computeRestarts(cond)
[18:02:00.316]                           for (restart in restarts) {
[18:02:00.316]                             name <- restart$name
[18:02:00.316]                             if (is.null(name)) 
[18:02:00.316]                               next
[18:02:00.316]                             if (!grepl(pattern, name)) 
[18:02:00.316]                               next
[18:02:00.316]                             invokeRestart(restart)
[18:02:00.316]                             muffled <- TRUE
[18:02:00.316]                             break
[18:02:00.316]                           }
[18:02:00.316]                         }
[18:02:00.316]                       }
[18:02:00.316]                       invisible(muffled)
[18:02:00.316]                     }
[18:02:00.316]                     muffleCondition(cond, pattern = "^muffle")
[18:02:00.316]                   }
[18:02:00.316]                 }
[18:02:00.316]                 else {
[18:02:00.316]                   if (TRUE) {
[18:02:00.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.316]                     {
[18:02:00.316]                       inherits <- base::inherits
[18:02:00.316]                       invokeRestart <- base::invokeRestart
[18:02:00.316]                       is.null <- base::is.null
[18:02:00.316]                       muffled <- FALSE
[18:02:00.316]                       if (inherits(cond, "message")) {
[18:02:00.316]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:00.316]                         if (muffled) 
[18:02:00.316]                           invokeRestart("muffleMessage")
[18:02:00.316]                       }
[18:02:00.316]                       else if (inherits(cond, "warning")) {
[18:02:00.316]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:00.316]                         if (muffled) 
[18:02:00.316]                           invokeRestart("muffleWarning")
[18:02:00.316]                       }
[18:02:00.316]                       else if (inherits(cond, "condition")) {
[18:02:00.316]                         if (!is.null(pattern)) {
[18:02:00.316]                           computeRestarts <- base::computeRestarts
[18:02:00.316]                           grepl <- base::grepl
[18:02:00.316]                           restarts <- computeRestarts(cond)
[18:02:00.316]                           for (restart in restarts) {
[18:02:00.316]                             name <- restart$name
[18:02:00.316]                             if (is.null(name)) 
[18:02:00.316]                               next
[18:02:00.316]                             if (!grepl(pattern, name)) 
[18:02:00.316]                               next
[18:02:00.316]                             invokeRestart(restart)
[18:02:00.316]                             muffled <- TRUE
[18:02:00.316]                             break
[18:02:00.316]                           }
[18:02:00.316]                         }
[18:02:00.316]                       }
[18:02:00.316]                       invisible(muffled)
[18:02:00.316]                     }
[18:02:00.316]                     muffleCondition(cond, pattern = "^muffle")
[18:02:00.316]                   }
[18:02:00.316]                 }
[18:02:00.316]             }
[18:02:00.316]         }))
[18:02:00.316]     }, error = function(ex) {
[18:02:00.316]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:00.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:00.316]                 ...future.rng), started = ...future.startTime, 
[18:02:00.316]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:00.316]             version = "1.8"), class = "FutureResult")
[18:02:00.316]     }, finally = {
[18:02:00.316]         if (!identical(...future.workdir, getwd())) 
[18:02:00.316]             setwd(...future.workdir)
[18:02:00.316]         {
[18:02:00.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:00.316]                 ...future.oldOptions$nwarnings <- NULL
[18:02:00.316]             }
[18:02:00.316]             base::options(...future.oldOptions)
[18:02:00.316]             if (.Platform$OS.type == "windows") {
[18:02:00.316]                 old_names <- names(...future.oldEnvVars)
[18:02:00.316]                 envs <- base::Sys.getenv()
[18:02:00.316]                 names <- names(envs)
[18:02:00.316]                 common <- intersect(names, old_names)
[18:02:00.316]                 added <- setdiff(names, old_names)
[18:02:00.316]                 removed <- setdiff(old_names, names)
[18:02:00.316]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:00.316]                   envs[common]]
[18:02:00.316]                 NAMES <- toupper(changed)
[18:02:00.316]                 args <- list()
[18:02:00.316]                 for (kk in seq_along(NAMES)) {
[18:02:00.316]                   name <- changed[[kk]]
[18:02:00.316]                   NAME <- NAMES[[kk]]
[18:02:00.316]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.316]                     next
[18:02:00.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:00.316]                 }
[18:02:00.316]                 NAMES <- toupper(added)
[18:02:00.316]                 for (kk in seq_along(NAMES)) {
[18:02:00.316]                   name <- added[[kk]]
[18:02:00.316]                   NAME <- NAMES[[kk]]
[18:02:00.316]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.316]                     next
[18:02:00.316]                   args[[name]] <- ""
[18:02:00.316]                 }
[18:02:00.316]                 NAMES <- toupper(removed)
[18:02:00.316]                 for (kk in seq_along(NAMES)) {
[18:02:00.316]                   name <- removed[[kk]]
[18:02:00.316]                   NAME <- NAMES[[kk]]
[18:02:00.316]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.316]                     next
[18:02:00.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:00.316]                 }
[18:02:00.316]                 if (length(args) > 0) 
[18:02:00.316]                   base::do.call(base::Sys.setenv, args = args)
[18:02:00.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:00.316]             }
[18:02:00.316]             else {
[18:02:00.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:00.316]             }
[18:02:00.316]             {
[18:02:00.316]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:00.316]                   0L) {
[18:02:00.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:00.316]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:00.316]                   base::options(opts)
[18:02:00.316]                 }
[18:02:00.316]                 {
[18:02:00.316]                   {
[18:02:00.316]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:00.316]                     NULL
[18:02:00.316]                   }
[18:02:00.316]                   options(future.plan = NULL)
[18:02:00.316]                   if (is.na(NA_character_)) 
[18:02:00.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:00.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:00.316]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:00.316]                     .init = FALSE)
[18:02:00.316]                 }
[18:02:00.316]             }
[18:02:00.316]         }
[18:02:00.316]     })
[18:02:00.316]     if (TRUE) {
[18:02:00.316]         base::sink(type = "output", split = FALSE)
[18:02:00.316]         if (TRUE) {
[18:02:00.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:00.316]         }
[18:02:00.316]         else {
[18:02:00.316]             ...future.result["stdout"] <- base::list(NULL)
[18:02:00.316]         }
[18:02:00.316]         base::close(...future.stdout)
[18:02:00.316]         ...future.stdout <- NULL
[18:02:00.316]     }
[18:02:00.316]     ...future.result$conditions <- ...future.conditions
[18:02:00.316]     ...future.result$finished <- base::Sys.time()
[18:02:00.316]     ...future.result
[18:02:00.316] }
[18:02:00.322] assign_globals() ...
[18:02:00.322] List of 11
[18:02:00.322]  $ ...future.FUN            :function (x, ...)  
[18:02:00.322]  $ x_FUN                    :function (x, y)  
[18:02:00.322]  $ times                    : int 15
[18:02:00.322]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:00.322]  $ stop_if_not              :function (...)  
[18:02:00.322]  $ dim                      : int [1:2] 3 5
[18:02:00.322]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:02:00.322]  $ future.call.arguments    :List of 1
[18:02:00.322]   ..$ y: num [1:5] 2 4 6 8 10
[18:02:00.322]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.322]  $ ...future.elements_ii    :List of 2
[18:02:00.322]   ..$ C: num 70
[18:02:00.322]   ..$ D: num 80
[18:02:00.322]  $ ...future.seeds_ii       : NULL
[18:02:00.322]  $ ...future.globals.maxSize: NULL
[18:02:00.322]  - attr(*, "where")=List of 11
[18:02:00.322]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:00.322]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:02:00.322]   ..$ times                    :<environment: R_EmptyEnv> 
[18:02:00.322]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:02:00.322]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:02:00.322]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:02:00.322]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:02:00.322]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:00.322]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:00.322]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:00.322]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:00.322]  - attr(*, "resolved")= logi FALSE
[18:02:00.322]  - attr(*, "total_size")= num 98600
[18:02:00.322]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.322]  - attr(*, "already-done")= logi TRUE
[18:02:00.353] - copied ‘...future.FUN’ to environment
[18:02:00.354] - reassign environment for ‘x_FUN’
[18:02:00.354] - copied ‘x_FUN’ to environment
[18:02:00.354] - copied ‘times’ to environment
[18:02:00.355] - copied ‘stopf’ to environment
[18:02:00.355] - copied ‘stop_if_not’ to environment
[18:02:00.355] - copied ‘dim’ to environment
[18:02:00.355] - copied ‘valid_types’ to environment
[18:02:00.356] - copied ‘future.call.arguments’ to environment
[18:02:00.356] - copied ‘...future.elements_ii’ to environment
[18:02:00.356] - copied ‘...future.seeds_ii’ to environment
[18:02:00.356] - copied ‘...future.globals.maxSize’ to environment
[18:02:00.357] assign_globals() ... done
[18:02:00.357] requestCore(): workers = 2
[18:02:00.361] MulticoreFuture started
[18:02:00.362] - Launch lazy future ... done
[18:02:00.363] run() for ‘MulticoreFuture’ ... done
[18:02:00.365] Created future:
[18:02:00.365] plan(): Setting new future strategy stack:
[18:02:00.368] List of future strategies:
[18:02:00.368] 1. sequential:
[18:02:00.368]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:00.368]    - tweaked: FALSE
[18:02:00.368]    - call: NULL
[18:02:00.374] plan(): nbrOfWorkers() = 1
[18:02:00.379] plan(): Setting new future strategy stack:
[18:02:00.380] List of future strategies:
[18:02:00.380] 1. multicore:
[18:02:00.380]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:00.380]    - tweaked: FALSE
[18:02:00.380]    - call: plan(strategy)
[18:02:00.365] MulticoreFuture:
[18:02:00.365] Label: ‘future_vapply-2’
[18:02:00.365] Expression:
[18:02:00.365] {
[18:02:00.365]     do.call(function(...) {
[18:02:00.365]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.365]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.365]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.365]             on.exit(options(oopts), add = TRUE)
[18:02:00.365]         }
[18:02:00.365]         {
[18:02:00.365]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.365]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.365]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.365]             })
[18:02:00.365]         }
[18:02:00.365]     }, args = future.call.arguments)
[18:02:00.365] }
[18:02:00.365] Lazy evaluation: FALSE
[18:02:00.365] Asynchronous evaluation: TRUE
[18:02:00.365] Local evaluation: TRUE
[18:02:00.365] Environment: R_GlobalEnv
[18:02:00.365] Capture standard output: TRUE
[18:02:00.365] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:00.365] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:00.365] Packages: 1 packages (‘future.apply’)
[18:02:00.365] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:00.365] Resolved: FALSE
[18:02:00.365] Value: <not collected>
[18:02:00.365] Conditions captured: <none>
[18:02:00.365] Early signaling: FALSE
[18:02:00.365] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:00.365] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.385] Chunk #2 of 2 ... DONE
[18:02:00.385] Launching 2 futures (chunks) ... DONE
[18:02:00.385] Resolving 2 futures (chunks) ...
[18:02:00.386] resolve() on list ...
[18:02:00.386]  recursive: 0
[18:02:00.387]  length: 2
[18:02:00.387] 
[18:02:00.388] Future #1
[18:02:00.388] result() for MulticoreFuture ...
[18:02:00.390] result() for MulticoreFuture ...
[18:02:00.390] result() for MulticoreFuture ... done
[18:02:00.390] result() for MulticoreFuture ... done
[18:02:00.391] result() for MulticoreFuture ...
[18:02:00.391] result() for MulticoreFuture ... done
[18:02:00.391] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:02:00.392] - nx: 2
[18:02:00.392] plan(): nbrOfWorkers() = 2
[18:02:00.392] - relay: TRUE
[18:02:00.392] - stdout: TRUE
[18:02:00.393] - signal: TRUE
[18:02:00.393] - resignal: FALSE
[18:02:00.393] - force: TRUE
[18:02:00.394] - relayed: [n=2] FALSE, FALSE
[18:02:00.394] - queued futures: [n=2] FALSE, FALSE
[18:02:00.394]  - until=1
[18:02:00.395]  - relaying element #1
[18:02:00.395] result() for MulticoreFuture ...
[18:02:00.395] result() for MulticoreFuture ... done
[18:02:00.396] result() for MulticoreFuture ...
[18:02:00.396] result() for MulticoreFuture ... done
[18:02:00.396] result() for MulticoreFuture ...
[18:02:00.397] result() for MulticoreFuture ... done
[18:02:00.397] result() for MulticoreFuture ...
[18:02:00.397] result() for MulticoreFuture ... done
[18:02:00.398] - relayed: [n=2] TRUE, FALSE
[18:02:00.398] - queued futures: [n=2] TRUE, FALSE
[18:02:00.398] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:02:00.398]  length: 1 (resolved future 1)
[18:02:00.399] Future #2
[18:02:00.399] result() for MulticoreFuture ...
[18:02:00.401] result() for MulticoreFuture ...
[18:02:00.401] result() for MulticoreFuture ... done
[18:02:00.401] result() for MulticoreFuture ... done
[18:02:00.402] result() for MulticoreFuture ...
[18:02:00.402] result() for MulticoreFuture ... done
[18:02:00.402] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:02:00.403] - nx: 2
[18:02:00.403] - relay: TRUE
[18:02:00.403] - stdout: TRUE
[18:02:00.403] - signal: TRUE
[18:02:00.403] - resignal: FALSE
[18:02:00.404] - force: TRUE
[18:02:00.404] - relayed: [n=2] TRUE, FALSE
[18:02:00.404] - queued futures: [n=2] TRUE, FALSE
[18:02:00.404]  - until=2
[18:02:00.405]  - relaying element #2
[18:02:00.405] result() for MulticoreFuture ...
[18:02:00.405] result() for MulticoreFuture ... done
[18:02:00.405] result() for MulticoreFuture ...
[18:02:00.406] result() for MulticoreFuture ... done
[18:02:00.406] result() for MulticoreFuture ...
[18:02:00.406] result() for MulticoreFuture ... done
[18:02:00.406] result() for MulticoreFuture ...
[18:02:00.407] result() for MulticoreFuture ... done
[18:02:00.407] - relayed: [n=2] TRUE, TRUE
[18:02:00.407] - queued futures: [n=2] TRUE, TRUE
[18:02:00.407] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:02:00.407]  length: 0 (resolved future 2)
[18:02:00.408] Relaying remaining futures
[18:02:00.408] signalConditionsASAP(NULL, pos=0) ...
[18:02:00.408] - nx: 2
[18:02:00.408] - relay: TRUE
[18:02:00.409] - stdout: TRUE
[18:02:00.409] - signal: TRUE
[18:02:00.409] - resignal: FALSE
[18:02:00.409] - force: TRUE
[18:02:00.409] - relayed: [n=2] TRUE, TRUE
[18:02:00.410] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:00.410] - relayed: [n=2] TRUE, TRUE
[18:02:00.410] - queued futures: [n=2] TRUE, TRUE
[18:02:00.410] signalConditionsASAP(NULL, pos=0) ... done
[18:02:00.411] resolve() on list ... DONE
[18:02:00.411] result() for MulticoreFuture ...
[18:02:00.411] result() for MulticoreFuture ... done
[18:02:00.411] result() for MulticoreFuture ...
[18:02:00.411] result() for MulticoreFuture ... done
[18:02:00.412] result() for MulticoreFuture ...
[18:02:00.412] result() for MulticoreFuture ... done
[18:02:00.412] result() for MulticoreFuture ...
[18:02:00.412] result() for MulticoreFuture ... done
[18:02:00.413]  - Number of value chunks collected: 2
[18:02:00.413] Resolving 2 futures (chunks) ... DONE
[18:02:00.413] Reducing values from 2 chunks ...
[18:02:00.413]  - Number of values collected after concatenation: 4
[18:02:00.414]  - Number of values expected: 4
[18:02:00.414] Reducing values from 2 chunks ... DONE
[18:02:00.414] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[18:02:00.418] future_lapply() ...
[18:02:00.433] Number of chunks: 2
[18:02:00.433] getGlobalsAndPackagesXApply() ...
[18:02:00.434]  - future.globals: TRUE
[18:02:00.434] getGlobalsAndPackages() ...
[18:02:00.434] Searching for globals...
[18:02:00.442] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:02:00.442] Searching for globals ... DONE
[18:02:00.442] Resolving globals: FALSE
[18:02:00.444] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[18:02:00.445] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:00.445] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:00.445] - packages: [1] ‘future.apply’
[18:02:00.446] getGlobalsAndPackages() ... DONE
[18:02:00.446]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:00.446]  - needed namespaces: [n=1] ‘future.apply’
[18:02:00.446] Finding globals ... DONE
[18:02:00.447]  - use_args: TRUE
[18:02:00.447]  - Getting '...' globals ...
[18:02:00.447] resolve() on list ...
[18:02:00.448]  recursive: 0
[18:02:00.448]  length: 1
[18:02:00.448]  elements: ‘...’
[18:02:00.448]  length: 0 (resolved future 1)
[18:02:00.448] resolve() on list ... DONE
[18:02:00.449]    - '...' content: [n=0] 
[18:02:00.449] List of 1
[18:02:00.449]  $ ...: list()
[18:02:00.449]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.449]  - attr(*, "where")=List of 1
[18:02:00.449]   ..$ ...:<environment: 0x6183c0b4ed10> 
[18:02:00.449]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.449]  - attr(*, "resolved")= logi TRUE
[18:02:00.449]  - attr(*, "total_size")= num NA
[18:02:00.454]  - Getting '...' globals ... DONE
[18:02:00.454] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:00.455] List of 8
[18:02:00.455]  $ ...future.FUN:function (x, ...)  
[18:02:00.455]  $ x_FUN        :function (x)  
[18:02:00.455]  $ times        : int 1
[18:02:00.455]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:00.455]  $ stop_if_not  :function (...)  
[18:02:00.455]  $ dim          : NULL
[18:02:00.455]  $ valid_types  : chr "logical"
[18:02:00.455]  $ ...          : list()
[18:02:00.455]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.455]  - attr(*, "where")=List of 8
[18:02:00.455]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:00.455]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:00.455]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:00.455]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:00.455]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:00.455]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:00.455]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:00.455]   ..$ ...          :<environment: 0x6183c0b4ed10> 
[18:02:00.455]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.455]  - attr(*, "resolved")= logi FALSE
[18:02:00.455]  - attr(*, "total_size")= num 94200
[18:02:00.466] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:00.466] getGlobalsAndPackagesXApply() ... DONE
[18:02:00.466] Number of futures (= number of chunks): 2
[18:02:00.466] Launching 2 futures (chunks) ...
[18:02:00.467] Chunk #1 of 2 ...
[18:02:00.467]  - Finding globals in 'X' for chunk #1 ...
[18:02:00.467] getGlobalsAndPackages() ...
[18:02:00.467] Searching for globals...
[18:02:00.468] 
[18:02:00.468] Searching for globals ... DONE
[18:02:00.468] - globals: [0] <none>
[18:02:00.468] getGlobalsAndPackages() ... DONE
[18:02:00.469]    + additional globals found: [n=0] 
[18:02:00.472]    + additional namespaces needed: [n=0] 
[18:02:00.472]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:00.472]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:00.472]  - seeds: <none>
[18:02:00.473]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.473] getGlobalsAndPackages() ...
[18:02:00.473] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.473] Resolving globals: FALSE
[18:02:00.474] Tweak future expression to call with '...' arguments ...
[18:02:00.474] {
[18:02:00.474]     do.call(function(...) {
[18:02:00.474]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.474]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.474]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.474]             on.exit(options(oopts), add = TRUE)
[18:02:00.474]         }
[18:02:00.474]         {
[18:02:00.474]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.474]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.474]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.474]             })
[18:02:00.474]         }
[18:02:00.474]     }, args = future.call.arguments)
[18:02:00.474] }
[18:02:00.474] Tweak future expression to call with '...' arguments ... DONE
[18:02:00.476] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.476] - packages: [1] ‘future.apply’
[18:02:00.476] getGlobalsAndPackages() ... DONE
[18:02:00.477] run() for ‘Future’ ...
[18:02:00.477] - state: ‘created’
[18:02:00.477] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:00.484] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.484] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:00.484]   - Field: ‘label’
[18:02:00.485]   - Field: ‘local’
[18:02:00.485]   - Field: ‘owner’
[18:02:00.485]   - Field: ‘envir’
[18:02:00.485]   - Field: ‘workers’
[18:02:00.486]   - Field: ‘packages’
[18:02:00.486]   - Field: ‘gc’
[18:02:00.486]   - Field: ‘job’
[18:02:00.486]   - Field: ‘conditions’
[18:02:00.487]   - Field: ‘expr’
[18:02:00.487]   - Field: ‘uuid’
[18:02:00.487]   - Field: ‘seed’
[18:02:00.487]   - Field: ‘version’
[18:02:00.488]   - Field: ‘result’
[18:02:00.488]   - Field: ‘asynchronous’
[18:02:00.488]   - Field: ‘calls’
[18:02:00.488]   - Field: ‘globals’
[18:02:00.488]   - Field: ‘stdout’
[18:02:00.489]   - Field: ‘earlySignal’
[18:02:00.489]   - Field: ‘lazy’
[18:02:00.489]   - Field: ‘state’
[18:02:00.489] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:00.490] - Launch lazy future ...
[18:02:00.490] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:00.491] Packages needed by future strategies (n = 0): <none>
[18:02:00.492] {
[18:02:00.492]     {
[18:02:00.492]         {
[18:02:00.492]             ...future.startTime <- base::Sys.time()
[18:02:00.492]             {
[18:02:00.492]                 {
[18:02:00.492]                   {
[18:02:00.492]                     {
[18:02:00.492]                       {
[18:02:00.492]                         base::local({
[18:02:00.492]                           has_future <- base::requireNamespace("future", 
[18:02:00.492]                             quietly = TRUE)
[18:02:00.492]                           if (has_future) {
[18:02:00.492]                             ns <- base::getNamespace("future")
[18:02:00.492]                             version <- ns[[".package"]][["version"]]
[18:02:00.492]                             if (is.null(version)) 
[18:02:00.492]                               version <- utils::packageVersion("future")
[18:02:00.492]                           }
[18:02:00.492]                           else {
[18:02:00.492]                             version <- NULL
[18:02:00.492]                           }
[18:02:00.492]                           if (!has_future || version < "1.8.0") {
[18:02:00.492]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:00.492]                               "", base::R.version$version.string), 
[18:02:00.492]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:00.492]                                 base::R.version$platform, 8 * 
[18:02:00.492]                                   base::.Machine$sizeof.pointer), 
[18:02:00.492]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:00.492]                                 "release", "version")], collapse = " "), 
[18:02:00.492]                               hostname = base::Sys.info()[["nodename"]])
[18:02:00.492]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:00.492]                               info)
[18:02:00.492]                             info <- base::paste(info, collapse = "; ")
[18:02:00.492]                             if (!has_future) {
[18:02:00.492]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:00.492]                                 info)
[18:02:00.492]                             }
[18:02:00.492]                             else {
[18:02:00.492]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:00.492]                                 info, version)
[18:02:00.492]                             }
[18:02:00.492]                             base::stop(msg)
[18:02:00.492]                           }
[18:02:00.492]                         })
[18:02:00.492]                       }
[18:02:00.492]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:00.492]                       base::options(mc.cores = 1L)
[18:02:00.492]                     }
[18:02:00.492]                     base::local({
[18:02:00.492]                       for (pkg in "future.apply") {
[18:02:00.492]                         base::loadNamespace(pkg)
[18:02:00.492]                         base::library(pkg, character.only = TRUE)
[18:02:00.492]                       }
[18:02:00.492]                     })
[18:02:00.492]                   }
[18:02:00.492]                   ...future.strategy.old <- future::plan("list")
[18:02:00.492]                   options(future.plan = NULL)
[18:02:00.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:00.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:00.492]                 }
[18:02:00.492]                 ...future.workdir <- getwd()
[18:02:00.492]             }
[18:02:00.492]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:00.492]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:00.492]         }
[18:02:00.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:00.492]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:00.492]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:00.492]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:00.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:00.492]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:00.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:00.492]             base::names(...future.oldOptions))
[18:02:00.492]     }
[18:02:00.492]     if (FALSE) {
[18:02:00.492]     }
[18:02:00.492]     else {
[18:02:00.492]         if (TRUE) {
[18:02:00.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:00.492]                 open = "w")
[18:02:00.492]         }
[18:02:00.492]         else {
[18:02:00.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:00.492]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:00.492]         }
[18:02:00.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:00.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:00.492]             base::sink(type = "output", split = FALSE)
[18:02:00.492]             base::close(...future.stdout)
[18:02:00.492]         }, add = TRUE)
[18:02:00.492]     }
[18:02:00.492]     ...future.frame <- base::sys.nframe()
[18:02:00.492]     ...future.conditions <- base::list()
[18:02:00.492]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:00.492]     if (FALSE) {
[18:02:00.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:00.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:00.492]     }
[18:02:00.492]     ...future.result <- base::tryCatch({
[18:02:00.492]         base::withCallingHandlers({
[18:02:00.492]             ...future.value <- base::withVisible(base::local({
[18:02:00.492]                 withCallingHandlers({
[18:02:00.492]                   {
[18:02:00.492]                     do.call(function(...) {
[18:02:00.492]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.492]                       if (!identical(...future.globals.maxSize.org, 
[18:02:00.492]                         ...future.globals.maxSize)) {
[18:02:00.492]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.492]                         on.exit(options(oopts), add = TRUE)
[18:02:00.492]                       }
[18:02:00.492]                       {
[18:02:00.492]                         lapply(seq_along(...future.elements_ii), 
[18:02:00.492]                           FUN = function(jj) {
[18:02:00.492]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.492]                             ...future.FUN(...future.X_jj, ...)
[18:02:00.492]                           })
[18:02:00.492]                       }
[18:02:00.492]                     }, args = future.call.arguments)
[18:02:00.492]                   }
[18:02:00.492]                 }, immediateCondition = function(cond) {
[18:02:00.492]                   save_rds <- function (object, pathname, ...) 
[18:02:00.492]                   {
[18:02:00.492]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:00.492]                     if (file_test("-f", pathname_tmp)) {
[18:02:00.492]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.492]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:00.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.492]                         fi_tmp[["mtime"]])
[18:02:00.492]                     }
[18:02:00.492]                     tryCatch({
[18:02:00.492]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:00.492]                     }, error = function(ex) {
[18:02:00.492]                       msg <- conditionMessage(ex)
[18:02:00.492]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.492]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:00.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.492]                         fi_tmp[["mtime"]], msg)
[18:02:00.492]                       ex$message <- msg
[18:02:00.492]                       stop(ex)
[18:02:00.492]                     })
[18:02:00.492]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:00.492]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:00.492]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:00.492]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.492]                       fi <- file.info(pathname)
[18:02:00.492]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:00.492]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.492]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:00.492]                         fi[["size"]], fi[["mtime"]])
[18:02:00.492]                       stop(msg)
[18:02:00.492]                     }
[18:02:00.492]                     invisible(pathname)
[18:02:00.492]                   }
[18:02:00.492]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:00.492]                     rootPath = tempdir()) 
[18:02:00.492]                   {
[18:02:00.492]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:00.492]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:00.492]                       tmpdir = path, fileext = ".rds")
[18:02:00.492]                     save_rds(obj, file)
[18:02:00.492]                   }
[18:02:00.492]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:02:00.492]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.492]                   {
[18:02:00.492]                     inherits <- base::inherits
[18:02:00.492]                     invokeRestart <- base::invokeRestart
[18:02:00.492]                     is.null <- base::is.null
[18:02:00.492]                     muffled <- FALSE
[18:02:00.492]                     if (inherits(cond, "message")) {
[18:02:00.492]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:00.492]                       if (muffled) 
[18:02:00.492]                         invokeRestart("muffleMessage")
[18:02:00.492]                     }
[18:02:00.492]                     else if (inherits(cond, "warning")) {
[18:02:00.492]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:00.492]                       if (muffled) 
[18:02:00.492]                         invokeRestart("muffleWarning")
[18:02:00.492]                     }
[18:02:00.492]                     else if (inherits(cond, "condition")) {
[18:02:00.492]                       if (!is.null(pattern)) {
[18:02:00.492]                         computeRestarts <- base::computeRestarts
[18:02:00.492]                         grepl <- base::grepl
[18:02:00.492]                         restarts <- computeRestarts(cond)
[18:02:00.492]                         for (restart in restarts) {
[18:02:00.492]                           name <- restart$name
[18:02:00.492]                           if (is.null(name)) 
[18:02:00.492]                             next
[18:02:00.492]                           if (!grepl(pattern, name)) 
[18:02:00.492]                             next
[18:02:00.492]                           invokeRestart(restart)
[18:02:00.492]                           muffled <- TRUE
[18:02:00.492]                           break
[18:02:00.492]                         }
[18:02:00.492]                       }
[18:02:00.492]                     }
[18:02:00.492]                     invisible(muffled)
[18:02:00.492]                   }
[18:02:00.492]                   muffleCondition(cond)
[18:02:00.492]                 })
[18:02:00.492]             }))
[18:02:00.492]             future::FutureResult(value = ...future.value$value, 
[18:02:00.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:00.492]                   ...future.rng), globalenv = if (FALSE) 
[18:02:00.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:00.492]                     ...future.globalenv.names))
[18:02:00.492]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:00.492]         }, condition = base::local({
[18:02:00.492]             c <- base::c
[18:02:00.492]             inherits <- base::inherits
[18:02:00.492]             invokeRestart <- base::invokeRestart
[18:02:00.492]             length <- base::length
[18:02:00.492]             list <- base::list
[18:02:00.492]             seq.int <- base::seq.int
[18:02:00.492]             signalCondition <- base::signalCondition
[18:02:00.492]             sys.calls <- base::sys.calls
[18:02:00.492]             `[[` <- base::`[[`
[18:02:00.492]             `+` <- base::`+`
[18:02:00.492]             `<<-` <- base::`<<-`
[18:02:00.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:00.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:00.492]                   3L)]
[18:02:00.492]             }
[18:02:00.492]             function(cond) {
[18:02:00.492]                 is_error <- inherits(cond, "error")
[18:02:00.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:00.492]                   NULL)
[18:02:00.492]                 if (is_error) {
[18:02:00.492]                   sessionInformation <- function() {
[18:02:00.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:00.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:00.492]                       search = base::search(), system = base::Sys.info())
[18:02:00.492]                   }
[18:02:00.492]                   ...future.conditions[[length(...future.conditions) + 
[18:02:00.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:00.492]                     cond$call), session = sessionInformation(), 
[18:02:00.492]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:00.492]                   signalCondition(cond)
[18:02:00.492]                 }
[18:02:00.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:00.492]                 "immediateCondition"))) {
[18:02:00.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:00.492]                   ...future.conditions[[length(...future.conditions) + 
[18:02:00.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:00.492]                   if (TRUE && !signal) {
[18:02:00.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.492]                     {
[18:02:00.492]                       inherits <- base::inherits
[18:02:00.492]                       invokeRestart <- base::invokeRestart
[18:02:00.492]                       is.null <- base::is.null
[18:02:00.492]                       muffled <- FALSE
[18:02:00.492]                       if (inherits(cond, "message")) {
[18:02:00.492]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:00.492]                         if (muffled) 
[18:02:00.492]                           invokeRestart("muffleMessage")
[18:02:00.492]                       }
[18:02:00.492]                       else if (inherits(cond, "warning")) {
[18:02:00.492]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:00.492]                         if (muffled) 
[18:02:00.492]                           invokeRestart("muffleWarning")
[18:02:00.492]                       }
[18:02:00.492]                       else if (inherits(cond, "condition")) {
[18:02:00.492]                         if (!is.null(pattern)) {
[18:02:00.492]                           computeRestarts <- base::computeRestarts
[18:02:00.492]                           grepl <- base::grepl
[18:02:00.492]                           restarts <- computeRestarts(cond)
[18:02:00.492]                           for (restart in restarts) {
[18:02:00.492]                             name <- restart$name
[18:02:00.492]                             if (is.null(name)) 
[18:02:00.492]                               next
[18:02:00.492]                             if (!grepl(pattern, name)) 
[18:02:00.492]                               next
[18:02:00.492]                             invokeRestart(restart)
[18:02:00.492]                             muffled <- TRUE
[18:02:00.492]                             break
[18:02:00.492]                           }
[18:02:00.492]                         }
[18:02:00.492]                       }
[18:02:00.492]                       invisible(muffled)
[18:02:00.492]                     }
[18:02:00.492]                     muffleCondition(cond, pattern = "^muffle")
[18:02:00.492]                   }
[18:02:00.492]                 }
[18:02:00.492]                 else {
[18:02:00.492]                   if (TRUE) {
[18:02:00.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.492]                     {
[18:02:00.492]                       inherits <- base::inherits
[18:02:00.492]                       invokeRestart <- base::invokeRestart
[18:02:00.492]                       is.null <- base::is.null
[18:02:00.492]                       muffled <- FALSE
[18:02:00.492]                       if (inherits(cond, "message")) {
[18:02:00.492]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:00.492]                         if (muffled) 
[18:02:00.492]                           invokeRestart("muffleMessage")
[18:02:00.492]                       }
[18:02:00.492]                       else if (inherits(cond, "warning")) {
[18:02:00.492]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:00.492]                         if (muffled) 
[18:02:00.492]                           invokeRestart("muffleWarning")
[18:02:00.492]                       }
[18:02:00.492]                       else if (inherits(cond, "condition")) {
[18:02:00.492]                         if (!is.null(pattern)) {
[18:02:00.492]                           computeRestarts <- base::computeRestarts
[18:02:00.492]                           grepl <- base::grepl
[18:02:00.492]                           restarts <- computeRestarts(cond)
[18:02:00.492]                           for (restart in restarts) {
[18:02:00.492]                             name <- restart$name
[18:02:00.492]                             if (is.null(name)) 
[18:02:00.492]                               next
[18:02:00.492]                             if (!grepl(pattern, name)) 
[18:02:00.492]                               next
[18:02:00.492]                             invokeRestart(restart)
[18:02:00.492]                             muffled <- TRUE
[18:02:00.492]                             break
[18:02:00.492]                           }
[18:02:00.492]                         }
[18:02:00.492]                       }
[18:02:00.492]                       invisible(muffled)
[18:02:00.492]                     }
[18:02:00.492]                     muffleCondition(cond, pattern = "^muffle")
[18:02:00.492]                   }
[18:02:00.492]                 }
[18:02:00.492]             }
[18:02:00.492]         }))
[18:02:00.492]     }, error = function(ex) {
[18:02:00.492]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:00.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:00.492]                 ...future.rng), started = ...future.startTime, 
[18:02:00.492]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:00.492]             version = "1.8"), class = "FutureResult")
[18:02:00.492]     }, finally = {
[18:02:00.492]         if (!identical(...future.workdir, getwd())) 
[18:02:00.492]             setwd(...future.workdir)
[18:02:00.492]         {
[18:02:00.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:00.492]                 ...future.oldOptions$nwarnings <- NULL
[18:02:00.492]             }
[18:02:00.492]             base::options(...future.oldOptions)
[18:02:00.492]             if (.Platform$OS.type == "windows") {
[18:02:00.492]                 old_names <- names(...future.oldEnvVars)
[18:02:00.492]                 envs <- base::Sys.getenv()
[18:02:00.492]                 names <- names(envs)
[18:02:00.492]                 common <- intersect(names, old_names)
[18:02:00.492]                 added <- setdiff(names, old_names)
[18:02:00.492]                 removed <- setdiff(old_names, names)
[18:02:00.492]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:00.492]                   envs[common]]
[18:02:00.492]                 NAMES <- toupper(changed)
[18:02:00.492]                 args <- list()
[18:02:00.492]                 for (kk in seq_along(NAMES)) {
[18:02:00.492]                   name <- changed[[kk]]
[18:02:00.492]                   NAME <- NAMES[[kk]]
[18:02:00.492]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.492]                     next
[18:02:00.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:00.492]                 }
[18:02:00.492]                 NAMES <- toupper(added)
[18:02:00.492]                 for (kk in seq_along(NAMES)) {
[18:02:00.492]                   name <- added[[kk]]
[18:02:00.492]                   NAME <- NAMES[[kk]]
[18:02:00.492]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.492]                     next
[18:02:00.492]                   args[[name]] <- ""
[18:02:00.492]                 }
[18:02:00.492]                 NAMES <- toupper(removed)
[18:02:00.492]                 for (kk in seq_along(NAMES)) {
[18:02:00.492]                   name <- removed[[kk]]
[18:02:00.492]                   NAME <- NAMES[[kk]]
[18:02:00.492]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.492]                     next
[18:02:00.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:00.492]                 }
[18:02:00.492]                 if (length(args) > 0) 
[18:02:00.492]                   base::do.call(base::Sys.setenv, args = args)
[18:02:00.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:00.492]             }
[18:02:00.492]             else {
[18:02:00.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:00.492]             }
[18:02:00.492]             {
[18:02:00.492]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:00.492]                   0L) {
[18:02:00.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:00.492]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:00.492]                   base::options(opts)
[18:02:00.492]                 }
[18:02:00.492]                 {
[18:02:00.492]                   {
[18:02:00.492]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:00.492]                     NULL
[18:02:00.492]                   }
[18:02:00.492]                   options(future.plan = NULL)
[18:02:00.492]                   if (is.na(NA_character_)) 
[18:02:00.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:00.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:00.492]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:00.492]                     .init = FALSE)
[18:02:00.492]                 }
[18:02:00.492]             }
[18:02:00.492]         }
[18:02:00.492]     })
[18:02:00.492]     if (TRUE) {
[18:02:00.492]         base::sink(type = "output", split = FALSE)
[18:02:00.492]         if (TRUE) {
[18:02:00.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:00.492]         }
[18:02:00.492]         else {
[18:02:00.492]             ...future.result["stdout"] <- base::list(NULL)
[18:02:00.492]         }
[18:02:00.492]         base::close(...future.stdout)
[18:02:00.492]         ...future.stdout <- NULL
[18:02:00.492]     }
[18:02:00.492]     ...future.result$conditions <- ...future.conditions
[18:02:00.492]     ...future.result$finished <- base::Sys.time()
[18:02:00.492]     ...future.result
[18:02:00.492] }
[18:02:00.497] assign_globals() ...
[18:02:00.497] List of 11
[18:02:00.497]  $ ...future.FUN            :function (x, ...)  
[18:02:00.497]  $ x_FUN                    :function (x)  
[18:02:00.497]  $ times                    : int 1
[18:02:00.497]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:00.497]  $ stop_if_not              :function (...)  
[18:02:00.497]  $ dim                      : NULL
[18:02:00.497]  $ valid_types              : chr "logical"
[18:02:00.497]  $ future.call.arguments    : list()
[18:02:00.497]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.497]  $ ...future.elements_ii    :List of 6
[18:02:00.497]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[18:02:00.497]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[18:02:00.497]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[18:02:00.497]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[18:02:00.497]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[18:02:00.497]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[18:02:00.497]  $ ...future.seeds_ii       : NULL
[18:02:00.497]  $ ...future.globals.maxSize: NULL
[18:02:00.497]  - attr(*, "where")=List of 11
[18:02:00.497]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:00.497]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:02:00.497]   ..$ times                    :<environment: R_EmptyEnv> 
[18:02:00.497]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:02:00.497]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:02:00.497]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:02:00.497]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:02:00.497]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:00.497]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:00.497]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:00.497]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:00.497]  - attr(*, "resolved")= logi FALSE
[18:02:00.497]  - attr(*, "total_size")= num 94200
[18:02:00.497]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.497]  - attr(*, "already-done")= logi TRUE
[18:02:00.517] - copied ‘...future.FUN’ to environment
[18:02:00.517] - copied ‘x_FUN’ to environment
[18:02:00.517] - copied ‘times’ to environment
[18:02:00.518] - copied ‘stopf’ to environment
[18:02:00.518] - copied ‘stop_if_not’ to environment
[18:02:00.518] - copied ‘dim’ to environment
[18:02:00.518] - copied ‘valid_types’ to environment
[18:02:00.518] - copied ‘future.call.arguments’ to environment
[18:02:00.519] - copied ‘...future.elements_ii’ to environment
[18:02:00.519] - copied ‘...future.seeds_ii’ to environment
[18:02:00.519] - copied ‘...future.globals.maxSize’ to environment
[18:02:00.519] assign_globals() ... done
[18:02:00.519] requestCore(): workers = 2
[18:02:00.523] MulticoreFuture started
[18:02:00.524] - Launch lazy future ... done
[18:02:00.524] run() for ‘MulticoreFuture’ ... done
[18:02:00.525] Created future:
[18:02:00.525] plan(): Setting new future strategy stack:
[18:02:00.526] List of future strategies:
[18:02:00.526] 1. sequential:
[18:02:00.526]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:00.526]    - tweaked: FALSE
[18:02:00.526]    - call: NULL
[18:02:00.534] plan(): nbrOfWorkers() = 1
[18:02:00.539] plan(): Setting new future strategy stack:
[18:02:00.540] List of future strategies:
[18:02:00.540] 1. multicore:
[18:02:00.540]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:00.540]    - tweaked: FALSE
[18:02:00.540]    - call: plan(strategy)
[18:02:00.525] MulticoreFuture:
[18:02:00.525] Label: ‘future_vapply-1’
[18:02:00.525] Expression:
[18:02:00.525] {
[18:02:00.525]     do.call(function(...) {
[18:02:00.525]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.525]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.525]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.525]             on.exit(options(oopts), add = TRUE)
[18:02:00.525]         }
[18:02:00.525]         {
[18:02:00.525]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.525]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.525]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.525]             })
[18:02:00.525]         }
[18:02:00.525]     }, args = future.call.arguments)
[18:02:00.525] }
[18:02:00.525] Lazy evaluation: FALSE
[18:02:00.525] Asynchronous evaluation: TRUE
[18:02:00.525] Local evaluation: TRUE
[18:02:00.525] Environment: R_GlobalEnv
[18:02:00.525] Capture standard output: TRUE
[18:02:00.525] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:00.525] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:00.525] Packages: 1 packages (‘future.apply’)
[18:02:00.525] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:00.525] Resolved: FALSE
[18:02:00.525] Value: <not collected>
[18:02:00.525] Conditions captured: <none>
[18:02:00.525] Early signaling: FALSE
[18:02:00.525] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:00.525] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.549] Chunk #1 of 2 ... DONE
[18:02:00.550] Chunk #2 of 2 ...
[18:02:00.550]  - Finding globals in 'X' for chunk #2 ...
[18:02:00.551] getGlobalsAndPackages() ...
[18:02:00.551] Searching for globals...
[18:02:00.552] plan(): nbrOfWorkers() = 2
[18:02:00.552] 
[18:02:00.553] Searching for globals ... DONE
[18:02:00.553] - globals: [0] <none>
[18:02:00.553] getGlobalsAndPackages() ... DONE
[18:02:00.554]    + additional globals found: [n=0] 
[18:02:00.554]    + additional namespaces needed: [n=0] 
[18:02:00.555]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:00.555]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:00.555]  - seeds: <none>
[18:02:00.555]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.556] getGlobalsAndPackages() ...
[18:02:00.557] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.557] Resolving globals: FALSE
[18:02:00.558] Tweak future expression to call with '...' arguments ...
[18:02:00.559] {
[18:02:00.559]     do.call(function(...) {
[18:02:00.559]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.559]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.559]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.559]             on.exit(options(oopts), add = TRUE)
[18:02:00.559]         }
[18:02:00.559]         {
[18:02:00.559]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.559]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.559]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.559]             })
[18:02:00.559]         }
[18:02:00.559]     }, args = future.call.arguments)
[18:02:00.559] }
[18:02:00.560] Tweak future expression to call with '...' arguments ... DONE
[18:02:00.562] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.562] - packages: [1] ‘future.apply’
[18:02:00.563] getGlobalsAndPackages() ... DONE
[18:02:00.564] run() for ‘Future’ ...
[18:02:00.564] - state: ‘created’
[18:02:00.565] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:00.574] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.575] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:00.575]   - Field: ‘label’
[18:02:00.576]   - Field: ‘local’
[18:02:00.576]   - Field: ‘owner’
[18:02:00.576]   - Field: ‘envir’
[18:02:00.577]   - Field: ‘workers’
[18:02:00.577]   - Field: ‘packages’
[18:02:00.577]   - Field: ‘gc’
[18:02:00.578]   - Field: ‘job’
[18:02:00.578]   - Field: ‘conditions’
[18:02:00.578]   - Field: ‘expr’
[18:02:00.578]   - Field: ‘uuid’
[18:02:00.579]   - Field: ‘seed’
[18:02:00.579]   - Field: ‘version’
[18:02:00.579]   - Field: ‘result’
[18:02:00.580]   - Field: ‘asynchronous’
[18:02:00.580]   - Field: ‘calls’
[18:02:00.580]   - Field: ‘globals’
[18:02:00.580]   - Field: ‘stdout’
[18:02:00.581]   - Field: ‘earlySignal’
[18:02:00.581]   - Field: ‘lazy’
[18:02:00.581]   - Field: ‘state’
[18:02:00.582] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:00.582] - Launch lazy future ...
[18:02:00.583] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:00.583] Packages needed by future strategies (n = 0): <none>
[18:02:00.585] {
[18:02:00.585]     {
[18:02:00.585]         {
[18:02:00.585]             ...future.startTime <- base::Sys.time()
[18:02:00.585]             {
[18:02:00.585]                 {
[18:02:00.585]                   {
[18:02:00.585]                     {
[18:02:00.585]                       {
[18:02:00.585]                         base::local({
[18:02:00.585]                           has_future <- base::requireNamespace("future", 
[18:02:00.585]                             quietly = TRUE)
[18:02:00.585]                           if (has_future) {
[18:02:00.585]                             ns <- base::getNamespace("future")
[18:02:00.585]                             version <- ns[[".package"]][["version"]]
[18:02:00.585]                             if (is.null(version)) 
[18:02:00.585]                               version <- utils::packageVersion("future")
[18:02:00.585]                           }
[18:02:00.585]                           else {
[18:02:00.585]                             version <- NULL
[18:02:00.585]                           }
[18:02:00.585]                           if (!has_future || version < "1.8.0") {
[18:02:00.585]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:00.585]                               "", base::R.version$version.string), 
[18:02:00.585]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:00.585]                                 base::R.version$platform, 8 * 
[18:02:00.585]                                   base::.Machine$sizeof.pointer), 
[18:02:00.585]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:00.585]                                 "release", "version")], collapse = " "), 
[18:02:00.585]                               hostname = base::Sys.info()[["nodename"]])
[18:02:00.585]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:00.585]                               info)
[18:02:00.585]                             info <- base::paste(info, collapse = "; ")
[18:02:00.585]                             if (!has_future) {
[18:02:00.585]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:00.585]                                 info)
[18:02:00.585]                             }
[18:02:00.585]                             else {
[18:02:00.585]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:00.585]                                 info, version)
[18:02:00.585]                             }
[18:02:00.585]                             base::stop(msg)
[18:02:00.585]                           }
[18:02:00.585]                         })
[18:02:00.585]                       }
[18:02:00.585]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:00.585]                       base::options(mc.cores = 1L)
[18:02:00.585]                     }
[18:02:00.585]                     base::local({
[18:02:00.585]                       for (pkg in "future.apply") {
[18:02:00.585]                         base::loadNamespace(pkg)
[18:02:00.585]                         base::library(pkg, character.only = TRUE)
[18:02:00.585]                       }
[18:02:00.585]                     })
[18:02:00.585]                   }
[18:02:00.585]                   ...future.strategy.old <- future::plan("list")
[18:02:00.585]                   options(future.plan = NULL)
[18:02:00.585]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:00.585]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:00.585]                 }
[18:02:00.585]                 ...future.workdir <- getwd()
[18:02:00.585]             }
[18:02:00.585]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:00.585]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:00.585]         }
[18:02:00.585]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:00.585]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:00.585]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:00.585]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:00.585]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:00.585]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:00.585]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:00.585]             base::names(...future.oldOptions))
[18:02:00.585]     }
[18:02:00.585]     if (FALSE) {
[18:02:00.585]     }
[18:02:00.585]     else {
[18:02:00.585]         if (TRUE) {
[18:02:00.585]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:00.585]                 open = "w")
[18:02:00.585]         }
[18:02:00.585]         else {
[18:02:00.585]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:00.585]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:00.585]         }
[18:02:00.585]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:00.585]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:00.585]             base::sink(type = "output", split = FALSE)
[18:02:00.585]             base::close(...future.stdout)
[18:02:00.585]         }, add = TRUE)
[18:02:00.585]     }
[18:02:00.585]     ...future.frame <- base::sys.nframe()
[18:02:00.585]     ...future.conditions <- base::list()
[18:02:00.585]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:00.585]     if (FALSE) {
[18:02:00.585]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:00.585]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:00.585]     }
[18:02:00.585]     ...future.result <- base::tryCatch({
[18:02:00.585]         base::withCallingHandlers({
[18:02:00.585]             ...future.value <- base::withVisible(base::local({
[18:02:00.585]                 withCallingHandlers({
[18:02:00.585]                   {
[18:02:00.585]                     do.call(function(...) {
[18:02:00.585]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.585]                       if (!identical(...future.globals.maxSize.org, 
[18:02:00.585]                         ...future.globals.maxSize)) {
[18:02:00.585]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.585]                         on.exit(options(oopts), add = TRUE)
[18:02:00.585]                       }
[18:02:00.585]                       {
[18:02:00.585]                         lapply(seq_along(...future.elements_ii), 
[18:02:00.585]                           FUN = function(jj) {
[18:02:00.585]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.585]                             ...future.FUN(...future.X_jj, ...)
[18:02:00.585]                           })
[18:02:00.585]                       }
[18:02:00.585]                     }, args = future.call.arguments)
[18:02:00.585]                   }
[18:02:00.585]                 }, immediateCondition = function(cond) {
[18:02:00.585]                   save_rds <- function (object, pathname, ...) 
[18:02:00.585]                   {
[18:02:00.585]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:00.585]                     if (file_test("-f", pathname_tmp)) {
[18:02:00.585]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.585]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:00.585]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.585]                         fi_tmp[["mtime"]])
[18:02:00.585]                     }
[18:02:00.585]                     tryCatch({
[18:02:00.585]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:00.585]                     }, error = function(ex) {
[18:02:00.585]                       msg <- conditionMessage(ex)
[18:02:00.585]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.585]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:00.585]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.585]                         fi_tmp[["mtime"]], msg)
[18:02:00.585]                       ex$message <- msg
[18:02:00.585]                       stop(ex)
[18:02:00.585]                     })
[18:02:00.585]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:00.585]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:00.585]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:00.585]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.585]                       fi <- file.info(pathname)
[18:02:00.585]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:00.585]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.585]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:00.585]                         fi[["size"]], fi[["mtime"]])
[18:02:00.585]                       stop(msg)
[18:02:00.585]                     }
[18:02:00.585]                     invisible(pathname)
[18:02:00.585]                   }
[18:02:00.585]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:00.585]                     rootPath = tempdir()) 
[18:02:00.585]                   {
[18:02:00.585]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:00.585]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:00.585]                       tmpdir = path, fileext = ".rds")
[18:02:00.585]                     save_rds(obj, file)
[18:02:00.585]                   }
[18:02:00.585]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:02:00.585]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.585]                   {
[18:02:00.585]                     inherits <- base::inherits
[18:02:00.585]                     invokeRestart <- base::invokeRestart
[18:02:00.585]                     is.null <- base::is.null
[18:02:00.585]                     muffled <- FALSE
[18:02:00.585]                     if (inherits(cond, "message")) {
[18:02:00.585]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:00.585]                       if (muffled) 
[18:02:00.585]                         invokeRestart("muffleMessage")
[18:02:00.585]                     }
[18:02:00.585]                     else if (inherits(cond, "warning")) {
[18:02:00.585]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:00.585]                       if (muffled) 
[18:02:00.585]                         invokeRestart("muffleWarning")
[18:02:00.585]                     }
[18:02:00.585]                     else if (inherits(cond, "condition")) {
[18:02:00.585]                       if (!is.null(pattern)) {
[18:02:00.585]                         computeRestarts <- base::computeRestarts
[18:02:00.585]                         grepl <- base::grepl
[18:02:00.585]                         restarts <- computeRestarts(cond)
[18:02:00.585]                         for (restart in restarts) {
[18:02:00.585]                           name <- restart$name
[18:02:00.585]                           if (is.null(name)) 
[18:02:00.585]                             next
[18:02:00.585]                           if (!grepl(pattern, name)) 
[18:02:00.585]                             next
[18:02:00.585]                           invokeRestart(restart)
[18:02:00.585]                           muffled <- TRUE
[18:02:00.585]                           break
[18:02:00.585]                         }
[18:02:00.585]                       }
[18:02:00.585]                     }
[18:02:00.585]                     invisible(muffled)
[18:02:00.585]                   }
[18:02:00.585]                   muffleCondition(cond)
[18:02:00.585]                 })
[18:02:00.585]             }))
[18:02:00.585]             future::FutureResult(value = ...future.value$value, 
[18:02:00.585]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:00.585]                   ...future.rng), globalenv = if (FALSE) 
[18:02:00.585]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:00.585]                     ...future.globalenv.names))
[18:02:00.585]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:00.585]         }, condition = base::local({
[18:02:00.585]             c <- base::c
[18:02:00.585]             inherits <- base::inherits
[18:02:00.585]             invokeRestart <- base::invokeRestart
[18:02:00.585]             length <- base::length
[18:02:00.585]             list <- base::list
[18:02:00.585]             seq.int <- base::seq.int
[18:02:00.585]             signalCondition <- base::signalCondition
[18:02:00.585]             sys.calls <- base::sys.calls
[18:02:00.585]             `[[` <- base::`[[`
[18:02:00.585]             `+` <- base::`+`
[18:02:00.585]             `<<-` <- base::`<<-`
[18:02:00.585]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:00.585]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:00.585]                   3L)]
[18:02:00.585]             }
[18:02:00.585]             function(cond) {
[18:02:00.585]                 is_error <- inherits(cond, "error")
[18:02:00.585]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:00.585]                   NULL)
[18:02:00.585]                 if (is_error) {
[18:02:00.585]                   sessionInformation <- function() {
[18:02:00.585]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:00.585]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:00.585]                       search = base::search(), system = base::Sys.info())
[18:02:00.585]                   }
[18:02:00.585]                   ...future.conditions[[length(...future.conditions) + 
[18:02:00.585]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:00.585]                     cond$call), session = sessionInformation(), 
[18:02:00.585]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:00.585]                   signalCondition(cond)
[18:02:00.585]                 }
[18:02:00.585]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:00.585]                 "immediateCondition"))) {
[18:02:00.585]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:00.585]                   ...future.conditions[[length(...future.conditions) + 
[18:02:00.585]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:00.585]                   if (TRUE && !signal) {
[18:02:00.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.585]                     {
[18:02:00.585]                       inherits <- base::inherits
[18:02:00.585]                       invokeRestart <- base::invokeRestart
[18:02:00.585]                       is.null <- base::is.null
[18:02:00.585]                       muffled <- FALSE
[18:02:00.585]                       if (inherits(cond, "message")) {
[18:02:00.585]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:00.585]                         if (muffled) 
[18:02:00.585]                           invokeRestart("muffleMessage")
[18:02:00.585]                       }
[18:02:00.585]                       else if (inherits(cond, "warning")) {
[18:02:00.585]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:00.585]                         if (muffled) 
[18:02:00.585]                           invokeRestart("muffleWarning")
[18:02:00.585]                       }
[18:02:00.585]                       else if (inherits(cond, "condition")) {
[18:02:00.585]                         if (!is.null(pattern)) {
[18:02:00.585]                           computeRestarts <- base::computeRestarts
[18:02:00.585]                           grepl <- base::grepl
[18:02:00.585]                           restarts <- computeRestarts(cond)
[18:02:00.585]                           for (restart in restarts) {
[18:02:00.585]                             name <- restart$name
[18:02:00.585]                             if (is.null(name)) 
[18:02:00.585]                               next
[18:02:00.585]                             if (!grepl(pattern, name)) 
[18:02:00.585]                               next
[18:02:00.585]                             invokeRestart(restart)
[18:02:00.585]                             muffled <- TRUE
[18:02:00.585]                             break
[18:02:00.585]                           }
[18:02:00.585]                         }
[18:02:00.585]                       }
[18:02:00.585]                       invisible(muffled)
[18:02:00.585]                     }
[18:02:00.585]                     muffleCondition(cond, pattern = "^muffle")
[18:02:00.585]                   }
[18:02:00.585]                 }
[18:02:00.585]                 else {
[18:02:00.585]                   if (TRUE) {
[18:02:00.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.585]                     {
[18:02:00.585]                       inherits <- base::inherits
[18:02:00.585]                       invokeRestart <- base::invokeRestart
[18:02:00.585]                       is.null <- base::is.null
[18:02:00.585]                       muffled <- FALSE
[18:02:00.585]                       if (inherits(cond, "message")) {
[18:02:00.585]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:00.585]                         if (muffled) 
[18:02:00.585]                           invokeRestart("muffleMessage")
[18:02:00.585]                       }
[18:02:00.585]                       else if (inherits(cond, "warning")) {
[18:02:00.585]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:00.585]                         if (muffled) 
[18:02:00.585]                           invokeRestart("muffleWarning")
[18:02:00.585]                       }
[18:02:00.585]                       else if (inherits(cond, "condition")) {
[18:02:00.585]                         if (!is.null(pattern)) {
[18:02:00.585]                           computeRestarts <- base::computeRestarts
[18:02:00.585]                           grepl <- base::grepl
[18:02:00.585]                           restarts <- computeRestarts(cond)
[18:02:00.585]                           for (restart in restarts) {
[18:02:00.585]                             name <- restart$name
[18:02:00.585]                             if (is.null(name)) 
[18:02:00.585]                               next
[18:02:00.585]                             if (!grepl(pattern, name)) 
[18:02:00.585]                               next
[18:02:00.585]                             invokeRestart(restart)
[18:02:00.585]                             muffled <- TRUE
[18:02:00.585]                             break
[18:02:00.585]                           }
[18:02:00.585]                         }
[18:02:00.585]                       }
[18:02:00.585]                       invisible(muffled)
[18:02:00.585]                     }
[18:02:00.585]                     muffleCondition(cond, pattern = "^muffle")
[18:02:00.585]                   }
[18:02:00.585]                 }
[18:02:00.585]             }
[18:02:00.585]         }))
[18:02:00.585]     }, error = function(ex) {
[18:02:00.585]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:00.585]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:00.585]                 ...future.rng), started = ...future.startTime, 
[18:02:00.585]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:00.585]             version = "1.8"), class = "FutureResult")
[18:02:00.585]     }, finally = {
[18:02:00.585]         if (!identical(...future.workdir, getwd())) 
[18:02:00.585]             setwd(...future.workdir)
[18:02:00.585]         {
[18:02:00.585]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:00.585]                 ...future.oldOptions$nwarnings <- NULL
[18:02:00.585]             }
[18:02:00.585]             base::options(...future.oldOptions)
[18:02:00.585]             if (.Platform$OS.type == "windows") {
[18:02:00.585]                 old_names <- names(...future.oldEnvVars)
[18:02:00.585]                 envs <- base::Sys.getenv()
[18:02:00.585]                 names <- names(envs)
[18:02:00.585]                 common <- intersect(names, old_names)
[18:02:00.585]                 added <- setdiff(names, old_names)
[18:02:00.585]                 removed <- setdiff(old_names, names)
[18:02:00.585]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:00.585]                   envs[common]]
[18:02:00.585]                 NAMES <- toupper(changed)
[18:02:00.585]                 args <- list()
[18:02:00.585]                 for (kk in seq_along(NAMES)) {
[18:02:00.585]                   name <- changed[[kk]]
[18:02:00.585]                   NAME <- NAMES[[kk]]
[18:02:00.585]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.585]                     next
[18:02:00.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:00.585]                 }
[18:02:00.585]                 NAMES <- toupper(added)
[18:02:00.585]                 for (kk in seq_along(NAMES)) {
[18:02:00.585]                   name <- added[[kk]]
[18:02:00.585]                   NAME <- NAMES[[kk]]
[18:02:00.585]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.585]                     next
[18:02:00.585]                   args[[name]] <- ""
[18:02:00.585]                 }
[18:02:00.585]                 NAMES <- toupper(removed)
[18:02:00.585]                 for (kk in seq_along(NAMES)) {
[18:02:00.585]                   name <- removed[[kk]]
[18:02:00.585]                   NAME <- NAMES[[kk]]
[18:02:00.585]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.585]                     next
[18:02:00.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:00.585]                 }
[18:02:00.585]                 if (length(args) > 0) 
[18:02:00.585]                   base::do.call(base::Sys.setenv, args = args)
[18:02:00.585]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:00.585]             }
[18:02:00.585]             else {
[18:02:00.585]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:00.585]             }
[18:02:00.585]             {
[18:02:00.585]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:00.585]                   0L) {
[18:02:00.585]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:00.585]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:00.585]                   base::options(opts)
[18:02:00.585]                 }
[18:02:00.585]                 {
[18:02:00.585]                   {
[18:02:00.585]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:00.585]                     NULL
[18:02:00.585]                   }
[18:02:00.585]                   options(future.plan = NULL)
[18:02:00.585]                   if (is.na(NA_character_)) 
[18:02:00.585]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:00.585]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:00.585]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:00.585]                     .init = FALSE)
[18:02:00.585]                 }
[18:02:00.585]             }
[18:02:00.585]         }
[18:02:00.585]     })
[18:02:00.585]     if (TRUE) {
[18:02:00.585]         base::sink(type = "output", split = FALSE)
[18:02:00.585]         if (TRUE) {
[18:02:00.585]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:00.585]         }
[18:02:00.585]         else {
[18:02:00.585]             ...future.result["stdout"] <- base::list(NULL)
[18:02:00.585]         }
[18:02:00.585]         base::close(...future.stdout)
[18:02:00.585]         ...future.stdout <- NULL
[18:02:00.585]     }
[18:02:00.585]     ...future.result$conditions <- ...future.conditions
[18:02:00.585]     ...future.result$finished <- base::Sys.time()
[18:02:00.585]     ...future.result
[18:02:00.585] }
[18:02:00.591] assign_globals() ...
[18:02:00.591] List of 11
[18:02:00.591]  $ ...future.FUN            :function (x, ...)  
[18:02:00.591]  $ x_FUN                    :function (x)  
[18:02:00.591]  $ times                    : int 1
[18:02:00.591]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:00.591]  $ stop_if_not              :function (...)  
[18:02:00.591]  $ dim                      : NULL
[18:02:00.591]  $ valid_types              : chr "logical"
[18:02:00.591]  $ future.call.arguments    : list()
[18:02:00.591]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.591]  $ ...future.elements_ii    :List of 5
[18:02:00.591]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[18:02:00.591]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[18:02:00.591]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[18:02:00.591]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[18:02:00.591]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[18:02:00.591]  $ ...future.seeds_ii       : NULL
[18:02:00.591]  $ ...future.globals.maxSize: NULL
[18:02:00.591]  - attr(*, "where")=List of 11
[18:02:00.591]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:00.591]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:02:00.591]   ..$ times                    :<environment: R_EmptyEnv> 
[18:02:00.591]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:02:00.591]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:02:00.591]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:02:00.591]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:02:00.591]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:00.591]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:00.591]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:00.591]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:00.591]  - attr(*, "resolved")= logi FALSE
[18:02:00.591]  - attr(*, "total_size")= num 94200
[18:02:00.591]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.591]  - attr(*, "already-done")= logi TRUE
[18:02:00.612] - copied ‘...future.FUN’ to environment
[18:02:00.612] - copied ‘x_FUN’ to environment
[18:02:00.612] - copied ‘times’ to environment
[18:02:00.612] - copied ‘stopf’ to environment
[18:02:00.613] - copied ‘stop_if_not’ to environment
[18:02:00.616] - copied ‘dim’ to environment
[18:02:00.616] - copied ‘valid_types’ to environment
[18:02:00.616] - copied ‘future.call.arguments’ to environment
[18:02:00.617] - copied ‘...future.elements_ii’ to environment
[18:02:00.617] - copied ‘...future.seeds_ii’ to environment
[18:02:00.617] - copied ‘...future.globals.maxSize’ to environment
[18:02:00.617] assign_globals() ... done
[18:02:00.618] requestCore(): workers = 2
[18:02:00.622] MulticoreFuture started
[18:02:00.623] - Launch lazy future ... done
[18:02:00.624] run() for ‘MulticoreFuture’ ... done
[18:02:00.625] Created future:
[18:02:00.625] plan(): Setting new future strategy stack:
[18:02:00.626] List of future strategies:
[18:02:00.626] 1. sequential:
[18:02:00.626]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:00.626]    - tweaked: FALSE
[18:02:00.626]    - call: NULL
[18:02:00.630] plan(): nbrOfWorkers() = 1
[18:02:00.635] plan(): Setting new future strategy stack:
[18:02:00.636] List of future strategies:
[18:02:00.636] 1. multicore:
[18:02:00.636]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:00.636]    - tweaked: FALSE
[18:02:00.636]    - call: plan(strategy)
[18:02:00.626] MulticoreFuture:
[18:02:00.626] Label: ‘future_vapply-2’
[18:02:00.626] Expression:
[18:02:00.626] {
[18:02:00.626]     do.call(function(...) {
[18:02:00.626]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.626]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.626]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.626]             on.exit(options(oopts), add = TRUE)
[18:02:00.626]         }
[18:02:00.626]         {
[18:02:00.626]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.626]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.626]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.626]             })
[18:02:00.626]         }
[18:02:00.626]     }, args = future.call.arguments)
[18:02:00.626] }
[18:02:00.626] Lazy evaluation: FALSE
[18:02:00.626] Asynchronous evaluation: TRUE
[18:02:00.626] Local evaluation: TRUE
[18:02:00.626] Environment: R_GlobalEnv
[18:02:00.626] Capture standard output: TRUE
[18:02:00.626] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:00.626] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:00.626] Packages: 1 packages (‘future.apply’)
[18:02:00.626] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:00.626] Resolved: FALSE
[18:02:00.626] Value: <not collected>
[18:02:00.626] Conditions captured: <none>
[18:02:00.626] Early signaling: FALSE
[18:02:00.626] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:00.626] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.645] Chunk #2 of 2 ... DONE
[18:02:00.645] Launching 2 futures (chunks) ... DONE
[18:02:00.645] Resolving 2 futures (chunks) ...
[18:02:00.646] resolve() on list ...
[18:02:00.646]  recursive: 0
[18:02:00.647]  length: 2
[18:02:00.647] 
[18:02:00.648] Future #1
[18:02:00.648] plan(): nbrOfWorkers() = 2
[18:02:00.648] result() for MulticoreFuture ...
[18:02:00.650] result() for MulticoreFuture ...
[18:02:00.651] result() for MulticoreFuture ... done
[18:02:00.651] result() for MulticoreFuture ... done
[18:02:00.651] result() for MulticoreFuture ...
[18:02:00.652] result() for MulticoreFuture ... done
[18:02:00.653] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:02:00.653] - nx: 2
[18:02:00.653] - relay: TRUE
[18:02:00.654] - stdout: TRUE
[18:02:00.654] - signal: TRUE
[18:02:00.655] - resignal: FALSE
[18:02:00.655] - force: TRUE
[18:02:00.656] - relayed: [n=2] FALSE, FALSE
[18:02:00.656] - queued futures: [n=2] FALSE, FALSE
[18:02:00.656]  - until=1
[18:02:00.657]  - relaying element #1
[18:02:00.657] result() for MulticoreFuture ...
[18:02:00.658] result() for MulticoreFuture ... done
[18:02:00.658] result() for MulticoreFuture ...
[18:02:00.658] result() for MulticoreFuture ... done
[18:02:00.659] result() for MulticoreFuture ...
[18:02:00.659] result() for MulticoreFuture ... done
[18:02:00.660] result() for MulticoreFuture ...
[18:02:00.660] result() for MulticoreFuture ... done
[18:02:00.660] - relayed: [n=2] TRUE, FALSE
[18:02:00.661] - queued futures: [n=2] TRUE, FALSE
[18:02:00.661] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:02:00.661]  length: 1 (resolved future 1)
[18:02:00.662] Future #2
[18:02:00.662] result() for MulticoreFuture ...
[18:02:00.664] result() for MulticoreFuture ...
[18:02:00.664] result() for MulticoreFuture ... done
[18:02:00.664] result() for MulticoreFuture ... done
[18:02:00.665] result() for MulticoreFuture ...
[18:02:00.665] result() for MulticoreFuture ... done
[18:02:00.665] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:02:00.666] - nx: 2
[18:02:00.666] - relay: TRUE
[18:02:00.666] - stdout: TRUE
[18:02:00.666] - signal: TRUE
[18:02:00.666] - resignal: FALSE
[18:02:00.667] - force: TRUE
[18:02:00.667] - relayed: [n=2] TRUE, FALSE
[18:02:00.667] - queued futures: [n=2] TRUE, FALSE
[18:02:00.668]  - until=2
[18:02:00.668]  - relaying element #2
[18:02:00.668] result() for MulticoreFuture ...
[18:02:00.668] result() for MulticoreFuture ... done
[18:02:00.668] result() for MulticoreFuture ...
[18:02:00.669] result() for MulticoreFuture ... done
[18:02:00.669] result() for MulticoreFuture ...
[18:02:00.669] result() for MulticoreFuture ... done
[18:02:00.669] result() for MulticoreFuture ...
[18:02:00.670] result() for MulticoreFuture ... done
[18:02:00.670] - relayed: [n=2] TRUE, TRUE
[18:02:00.670] - queued futures: [n=2] TRUE, TRUE
[18:02:00.670] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:02:00.670]  length: 0 (resolved future 2)
[18:02:00.671] Relaying remaining futures
[18:02:00.671] signalConditionsASAP(NULL, pos=0) ...
[18:02:00.671] - nx: 2
[18:02:00.671] - relay: TRUE
[18:02:00.671] - stdout: TRUE
[18:02:00.672] - signal: TRUE
[18:02:00.672] - resignal: FALSE
[18:02:00.672] - force: TRUE
[18:02:00.672] - relayed: [n=2] TRUE, TRUE
[18:02:00.672] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:00.673] - relayed: [n=2] TRUE, TRUE
[18:02:00.673] - queued futures: [n=2] TRUE, TRUE
[18:02:00.673] signalConditionsASAP(NULL, pos=0) ... done
[18:02:00.673] resolve() on list ... DONE
[18:02:00.674] result() for MulticoreFuture ...
[18:02:00.674] result() for MulticoreFuture ... done
[18:02:00.674] result() for MulticoreFuture ...
[18:02:00.674] result() for MulticoreFuture ... done
[18:02:00.674] result() for MulticoreFuture ...
[18:02:00.675] result() for MulticoreFuture ... done
[18:02:00.675] result() for MulticoreFuture ...
[18:02:00.675] result() for MulticoreFuture ... done
[18:02:00.675]  - Number of value chunks collected: 2
[18:02:00.675] Resolving 2 futures (chunks) ... DONE
[18:02:00.676] Reducing values from 2 chunks ...
[18:02:00.676]  - Number of values collected after concatenation: 11
[18:02:00.676]  - Number of values expected: 11
[18:02:00.676] Reducing values from 2 chunks ... DONE
[18:02:00.676] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[18:02:00.679] future_lapply() ...
[18:02:00.689] Number of chunks: 2
[18:02:00.690] getGlobalsAndPackagesXApply() ...
[18:02:00.690]  - future.globals: TRUE
[18:02:00.690] getGlobalsAndPackages() ...
[18:02:00.690] Searching for globals...
[18:02:00.701] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:02:00.701] Searching for globals ... DONE
[18:02:00.701] Resolving globals: FALSE
[18:02:00.703] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[18:02:00.704] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:00.705] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:00.705] - packages: [1] ‘future.apply’
[18:02:00.705] getGlobalsAndPackages() ... DONE
[18:02:00.705]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:00.705]  - needed namespaces: [n=1] ‘future.apply’
[18:02:00.706] Finding globals ... DONE
[18:02:00.706]  - use_args: TRUE
[18:02:00.706]  - Getting '...' globals ...
[18:02:00.707] resolve() on list ...
[18:02:00.707]  recursive: 0
[18:02:00.707]  length: 1
[18:02:00.707]  elements: ‘...’
[18:02:00.708]  length: 0 (resolved future 1)
[18:02:00.708] resolve() on list ... DONE
[18:02:00.708]    - '...' content: [n=0] 
[18:02:00.708] List of 1
[18:02:00.708]  $ ...: list()
[18:02:00.708]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.708]  - attr(*, "where")=List of 1
[18:02:00.708]   ..$ ...:<environment: 0x6183c0279848> 
[18:02:00.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.708]  - attr(*, "resolved")= logi TRUE
[18:02:00.708]  - attr(*, "total_size")= num NA
[18:02:00.714]  - Getting '...' globals ... DONE
[18:02:00.715] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:00.715] List of 8
[18:02:00.715]  $ ...future.FUN:function (x, ...)  
[18:02:00.715]  $ x_FUN        :function (x)  
[18:02:00.715]  $ times        : int 1
[18:02:00.715]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:00.715]  $ stop_if_not  :function (...)  
[18:02:00.715]  $ dim          : NULL
[18:02:00.715]  $ valid_types  : chr [1:2] "logical" "integer"
[18:02:00.715]  $ ...          : list()
[18:02:00.715]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.715]  - attr(*, "where")=List of 8
[18:02:00.715]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:00.715]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:00.715]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:00.715]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:00.715]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:00.715]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:00.715]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:00.715]   ..$ ...          :<environment: 0x6183c0279848> 
[18:02:00.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.715]  - attr(*, "resolved")= logi FALSE
[18:02:00.715]  - attr(*, "total_size")= num 94264
[18:02:00.727] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:00.727] getGlobalsAndPackagesXApply() ... DONE
[18:02:00.728] Number of futures (= number of chunks): 2
[18:02:00.728] Launching 2 futures (chunks) ...
[18:02:00.728] Chunk #1 of 2 ...
[18:02:00.728]  - Finding globals in 'X' for chunk #1 ...
[18:02:00.729] getGlobalsAndPackages() ...
[18:02:00.729] Searching for globals...
[18:02:00.729] 
[18:02:00.730] Searching for globals ... DONE
[18:02:00.730] - globals: [0] <none>
[18:02:00.730] getGlobalsAndPackages() ... DONE
[18:02:00.730]    + additional globals found: [n=0] 
[18:02:00.730]    + additional namespaces needed: [n=0] 
[18:02:00.731]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:00.731]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:00.731]  - seeds: <none>
[18:02:00.731]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.731] getGlobalsAndPackages() ...
[18:02:00.732] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.732] Resolving globals: FALSE
[18:02:00.732] Tweak future expression to call with '...' arguments ...
[18:02:00.732] {
[18:02:00.732]     do.call(function(...) {
[18:02:00.732]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.732]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.732]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.732]             on.exit(options(oopts), add = TRUE)
[18:02:00.732]         }
[18:02:00.732]         {
[18:02:00.732]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.732]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.732]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.732]             })
[18:02:00.732]         }
[18:02:00.732]     }, args = future.call.arguments)
[18:02:00.732] }
[18:02:00.733] Tweak future expression to call with '...' arguments ... DONE
[18:02:00.734] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.735] - packages: [1] ‘future.apply’
[18:02:00.735] getGlobalsAndPackages() ... DONE
[18:02:00.736] run() for ‘Future’ ...
[18:02:00.736] - state: ‘created’
[18:02:00.736] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:00.743] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.743] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:00.744]   - Field: ‘label’
[18:02:00.744]   - Field: ‘local’
[18:02:00.744]   - Field: ‘owner’
[18:02:00.744]   - Field: ‘envir’
[18:02:00.744]   - Field: ‘workers’
[18:02:00.745]   - Field: ‘packages’
[18:02:00.745]   - Field: ‘gc’
[18:02:00.745]   - Field: ‘job’
[18:02:00.748]   - Field: ‘conditions’
[18:02:00.749]   - Field: ‘expr’
[18:02:00.749]   - Field: ‘uuid’
[18:02:00.749]   - Field: ‘seed’
[18:02:00.749]   - Field: ‘version’
[18:02:00.749]   - Field: ‘result’
[18:02:00.750]   - Field: ‘asynchronous’
[18:02:00.750]   - Field: ‘calls’
[18:02:00.750]   - Field: ‘globals’
[18:02:00.750]   - Field: ‘stdout’
[18:02:00.751]   - Field: ‘earlySignal’
[18:02:00.751]   - Field: ‘lazy’
[18:02:00.751]   - Field: ‘state’
[18:02:00.751] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:00.751] - Launch lazy future ...
[18:02:00.752] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:00.752] Packages needed by future strategies (n = 0): <none>
[18:02:00.753] {
[18:02:00.753]     {
[18:02:00.753]         {
[18:02:00.753]             ...future.startTime <- base::Sys.time()
[18:02:00.753]             {
[18:02:00.753]                 {
[18:02:00.753]                   {
[18:02:00.753]                     {
[18:02:00.753]                       {
[18:02:00.753]                         base::local({
[18:02:00.753]                           has_future <- base::requireNamespace("future", 
[18:02:00.753]                             quietly = TRUE)
[18:02:00.753]                           if (has_future) {
[18:02:00.753]                             ns <- base::getNamespace("future")
[18:02:00.753]                             version <- ns[[".package"]][["version"]]
[18:02:00.753]                             if (is.null(version)) 
[18:02:00.753]                               version <- utils::packageVersion("future")
[18:02:00.753]                           }
[18:02:00.753]                           else {
[18:02:00.753]                             version <- NULL
[18:02:00.753]                           }
[18:02:00.753]                           if (!has_future || version < "1.8.0") {
[18:02:00.753]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:00.753]                               "", base::R.version$version.string), 
[18:02:00.753]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:00.753]                                 base::R.version$platform, 8 * 
[18:02:00.753]                                   base::.Machine$sizeof.pointer), 
[18:02:00.753]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:00.753]                                 "release", "version")], collapse = " "), 
[18:02:00.753]                               hostname = base::Sys.info()[["nodename"]])
[18:02:00.753]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:00.753]                               info)
[18:02:00.753]                             info <- base::paste(info, collapse = "; ")
[18:02:00.753]                             if (!has_future) {
[18:02:00.753]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:00.753]                                 info)
[18:02:00.753]                             }
[18:02:00.753]                             else {
[18:02:00.753]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:00.753]                                 info, version)
[18:02:00.753]                             }
[18:02:00.753]                             base::stop(msg)
[18:02:00.753]                           }
[18:02:00.753]                         })
[18:02:00.753]                       }
[18:02:00.753]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:00.753]                       base::options(mc.cores = 1L)
[18:02:00.753]                     }
[18:02:00.753]                     base::local({
[18:02:00.753]                       for (pkg in "future.apply") {
[18:02:00.753]                         base::loadNamespace(pkg)
[18:02:00.753]                         base::library(pkg, character.only = TRUE)
[18:02:00.753]                       }
[18:02:00.753]                     })
[18:02:00.753]                   }
[18:02:00.753]                   ...future.strategy.old <- future::plan("list")
[18:02:00.753]                   options(future.plan = NULL)
[18:02:00.753]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:00.753]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:00.753]                 }
[18:02:00.753]                 ...future.workdir <- getwd()
[18:02:00.753]             }
[18:02:00.753]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:00.753]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:00.753]         }
[18:02:00.753]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:00.753]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:00.753]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:00.753]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:00.753]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:00.753]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:00.753]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:00.753]             base::names(...future.oldOptions))
[18:02:00.753]     }
[18:02:00.753]     if (FALSE) {
[18:02:00.753]     }
[18:02:00.753]     else {
[18:02:00.753]         if (TRUE) {
[18:02:00.753]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:00.753]                 open = "w")
[18:02:00.753]         }
[18:02:00.753]         else {
[18:02:00.753]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:00.753]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:00.753]         }
[18:02:00.753]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:00.753]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:00.753]             base::sink(type = "output", split = FALSE)
[18:02:00.753]             base::close(...future.stdout)
[18:02:00.753]         }, add = TRUE)
[18:02:00.753]     }
[18:02:00.753]     ...future.frame <- base::sys.nframe()
[18:02:00.753]     ...future.conditions <- base::list()
[18:02:00.753]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:00.753]     if (FALSE) {
[18:02:00.753]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:00.753]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:00.753]     }
[18:02:00.753]     ...future.result <- base::tryCatch({
[18:02:00.753]         base::withCallingHandlers({
[18:02:00.753]             ...future.value <- base::withVisible(base::local({
[18:02:00.753]                 withCallingHandlers({
[18:02:00.753]                   {
[18:02:00.753]                     do.call(function(...) {
[18:02:00.753]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.753]                       if (!identical(...future.globals.maxSize.org, 
[18:02:00.753]                         ...future.globals.maxSize)) {
[18:02:00.753]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.753]                         on.exit(options(oopts), add = TRUE)
[18:02:00.753]                       }
[18:02:00.753]                       {
[18:02:00.753]                         lapply(seq_along(...future.elements_ii), 
[18:02:00.753]                           FUN = function(jj) {
[18:02:00.753]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.753]                             ...future.FUN(...future.X_jj, ...)
[18:02:00.753]                           })
[18:02:00.753]                       }
[18:02:00.753]                     }, args = future.call.arguments)
[18:02:00.753]                   }
[18:02:00.753]                 }, immediateCondition = function(cond) {
[18:02:00.753]                   save_rds <- function (object, pathname, ...) 
[18:02:00.753]                   {
[18:02:00.753]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:00.753]                     if (file_test("-f", pathname_tmp)) {
[18:02:00.753]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.753]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:00.753]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.753]                         fi_tmp[["mtime"]])
[18:02:00.753]                     }
[18:02:00.753]                     tryCatch({
[18:02:00.753]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:00.753]                     }, error = function(ex) {
[18:02:00.753]                       msg <- conditionMessage(ex)
[18:02:00.753]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.753]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:00.753]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.753]                         fi_tmp[["mtime"]], msg)
[18:02:00.753]                       ex$message <- msg
[18:02:00.753]                       stop(ex)
[18:02:00.753]                     })
[18:02:00.753]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:00.753]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:00.753]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:00.753]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.753]                       fi <- file.info(pathname)
[18:02:00.753]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:00.753]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.753]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:00.753]                         fi[["size"]], fi[["mtime"]])
[18:02:00.753]                       stop(msg)
[18:02:00.753]                     }
[18:02:00.753]                     invisible(pathname)
[18:02:00.753]                   }
[18:02:00.753]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:00.753]                     rootPath = tempdir()) 
[18:02:00.753]                   {
[18:02:00.753]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:00.753]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:00.753]                       tmpdir = path, fileext = ".rds")
[18:02:00.753]                     save_rds(obj, file)
[18:02:00.753]                   }
[18:02:00.753]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:02:00.753]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.753]                   {
[18:02:00.753]                     inherits <- base::inherits
[18:02:00.753]                     invokeRestart <- base::invokeRestart
[18:02:00.753]                     is.null <- base::is.null
[18:02:00.753]                     muffled <- FALSE
[18:02:00.753]                     if (inherits(cond, "message")) {
[18:02:00.753]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:00.753]                       if (muffled) 
[18:02:00.753]                         invokeRestart("muffleMessage")
[18:02:00.753]                     }
[18:02:00.753]                     else if (inherits(cond, "warning")) {
[18:02:00.753]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:00.753]                       if (muffled) 
[18:02:00.753]                         invokeRestart("muffleWarning")
[18:02:00.753]                     }
[18:02:00.753]                     else if (inherits(cond, "condition")) {
[18:02:00.753]                       if (!is.null(pattern)) {
[18:02:00.753]                         computeRestarts <- base::computeRestarts
[18:02:00.753]                         grepl <- base::grepl
[18:02:00.753]                         restarts <- computeRestarts(cond)
[18:02:00.753]                         for (restart in restarts) {
[18:02:00.753]                           name <- restart$name
[18:02:00.753]                           if (is.null(name)) 
[18:02:00.753]                             next
[18:02:00.753]                           if (!grepl(pattern, name)) 
[18:02:00.753]                             next
[18:02:00.753]                           invokeRestart(restart)
[18:02:00.753]                           muffled <- TRUE
[18:02:00.753]                           break
[18:02:00.753]                         }
[18:02:00.753]                       }
[18:02:00.753]                     }
[18:02:00.753]                     invisible(muffled)
[18:02:00.753]                   }
[18:02:00.753]                   muffleCondition(cond)
[18:02:00.753]                 })
[18:02:00.753]             }))
[18:02:00.753]             future::FutureResult(value = ...future.value$value, 
[18:02:00.753]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:00.753]                   ...future.rng), globalenv = if (FALSE) 
[18:02:00.753]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:00.753]                     ...future.globalenv.names))
[18:02:00.753]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:00.753]         }, condition = base::local({
[18:02:00.753]             c <- base::c
[18:02:00.753]             inherits <- base::inherits
[18:02:00.753]             invokeRestart <- base::invokeRestart
[18:02:00.753]             length <- base::length
[18:02:00.753]             list <- base::list
[18:02:00.753]             seq.int <- base::seq.int
[18:02:00.753]             signalCondition <- base::signalCondition
[18:02:00.753]             sys.calls <- base::sys.calls
[18:02:00.753]             `[[` <- base::`[[`
[18:02:00.753]             `+` <- base::`+`
[18:02:00.753]             `<<-` <- base::`<<-`
[18:02:00.753]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:00.753]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:00.753]                   3L)]
[18:02:00.753]             }
[18:02:00.753]             function(cond) {
[18:02:00.753]                 is_error <- inherits(cond, "error")
[18:02:00.753]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:00.753]                   NULL)
[18:02:00.753]                 if (is_error) {
[18:02:00.753]                   sessionInformation <- function() {
[18:02:00.753]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:00.753]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:00.753]                       search = base::search(), system = base::Sys.info())
[18:02:00.753]                   }
[18:02:00.753]                   ...future.conditions[[length(...future.conditions) + 
[18:02:00.753]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:00.753]                     cond$call), session = sessionInformation(), 
[18:02:00.753]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:00.753]                   signalCondition(cond)
[18:02:00.753]                 }
[18:02:00.753]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:00.753]                 "immediateCondition"))) {
[18:02:00.753]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:00.753]                   ...future.conditions[[length(...future.conditions) + 
[18:02:00.753]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:00.753]                   if (TRUE && !signal) {
[18:02:00.753]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.753]                     {
[18:02:00.753]                       inherits <- base::inherits
[18:02:00.753]                       invokeRestart <- base::invokeRestart
[18:02:00.753]                       is.null <- base::is.null
[18:02:00.753]                       muffled <- FALSE
[18:02:00.753]                       if (inherits(cond, "message")) {
[18:02:00.753]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:00.753]                         if (muffled) 
[18:02:00.753]                           invokeRestart("muffleMessage")
[18:02:00.753]                       }
[18:02:00.753]                       else if (inherits(cond, "warning")) {
[18:02:00.753]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:00.753]                         if (muffled) 
[18:02:00.753]                           invokeRestart("muffleWarning")
[18:02:00.753]                       }
[18:02:00.753]                       else if (inherits(cond, "condition")) {
[18:02:00.753]                         if (!is.null(pattern)) {
[18:02:00.753]                           computeRestarts <- base::computeRestarts
[18:02:00.753]                           grepl <- base::grepl
[18:02:00.753]                           restarts <- computeRestarts(cond)
[18:02:00.753]                           for (restart in restarts) {
[18:02:00.753]                             name <- restart$name
[18:02:00.753]                             if (is.null(name)) 
[18:02:00.753]                               next
[18:02:00.753]                             if (!grepl(pattern, name)) 
[18:02:00.753]                               next
[18:02:00.753]                             invokeRestart(restart)
[18:02:00.753]                             muffled <- TRUE
[18:02:00.753]                             break
[18:02:00.753]                           }
[18:02:00.753]                         }
[18:02:00.753]                       }
[18:02:00.753]                       invisible(muffled)
[18:02:00.753]                     }
[18:02:00.753]                     muffleCondition(cond, pattern = "^muffle")
[18:02:00.753]                   }
[18:02:00.753]                 }
[18:02:00.753]                 else {
[18:02:00.753]                   if (TRUE) {
[18:02:00.753]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.753]                     {
[18:02:00.753]                       inherits <- base::inherits
[18:02:00.753]                       invokeRestart <- base::invokeRestart
[18:02:00.753]                       is.null <- base::is.null
[18:02:00.753]                       muffled <- FALSE
[18:02:00.753]                       if (inherits(cond, "message")) {
[18:02:00.753]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:00.753]                         if (muffled) 
[18:02:00.753]                           invokeRestart("muffleMessage")
[18:02:00.753]                       }
[18:02:00.753]                       else if (inherits(cond, "warning")) {
[18:02:00.753]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:00.753]                         if (muffled) 
[18:02:00.753]                           invokeRestart("muffleWarning")
[18:02:00.753]                       }
[18:02:00.753]                       else if (inherits(cond, "condition")) {
[18:02:00.753]                         if (!is.null(pattern)) {
[18:02:00.753]                           computeRestarts <- base::computeRestarts
[18:02:00.753]                           grepl <- base::grepl
[18:02:00.753]                           restarts <- computeRestarts(cond)
[18:02:00.753]                           for (restart in restarts) {
[18:02:00.753]                             name <- restart$name
[18:02:00.753]                             if (is.null(name)) 
[18:02:00.753]                               next
[18:02:00.753]                             if (!grepl(pattern, name)) 
[18:02:00.753]                               next
[18:02:00.753]                             invokeRestart(restart)
[18:02:00.753]                             muffled <- TRUE
[18:02:00.753]                             break
[18:02:00.753]                           }
[18:02:00.753]                         }
[18:02:00.753]                       }
[18:02:00.753]                       invisible(muffled)
[18:02:00.753]                     }
[18:02:00.753]                     muffleCondition(cond, pattern = "^muffle")
[18:02:00.753]                   }
[18:02:00.753]                 }
[18:02:00.753]             }
[18:02:00.753]         }))
[18:02:00.753]     }, error = function(ex) {
[18:02:00.753]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:00.753]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:00.753]                 ...future.rng), started = ...future.startTime, 
[18:02:00.753]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:00.753]             version = "1.8"), class = "FutureResult")
[18:02:00.753]     }, finally = {
[18:02:00.753]         if (!identical(...future.workdir, getwd())) 
[18:02:00.753]             setwd(...future.workdir)
[18:02:00.753]         {
[18:02:00.753]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:00.753]                 ...future.oldOptions$nwarnings <- NULL
[18:02:00.753]             }
[18:02:00.753]             base::options(...future.oldOptions)
[18:02:00.753]             if (.Platform$OS.type == "windows") {
[18:02:00.753]                 old_names <- names(...future.oldEnvVars)
[18:02:00.753]                 envs <- base::Sys.getenv()
[18:02:00.753]                 names <- names(envs)
[18:02:00.753]                 common <- intersect(names, old_names)
[18:02:00.753]                 added <- setdiff(names, old_names)
[18:02:00.753]                 removed <- setdiff(old_names, names)
[18:02:00.753]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:00.753]                   envs[common]]
[18:02:00.753]                 NAMES <- toupper(changed)
[18:02:00.753]                 args <- list()
[18:02:00.753]                 for (kk in seq_along(NAMES)) {
[18:02:00.753]                   name <- changed[[kk]]
[18:02:00.753]                   NAME <- NAMES[[kk]]
[18:02:00.753]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.753]                     next
[18:02:00.753]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:00.753]                 }
[18:02:00.753]                 NAMES <- toupper(added)
[18:02:00.753]                 for (kk in seq_along(NAMES)) {
[18:02:00.753]                   name <- added[[kk]]
[18:02:00.753]                   NAME <- NAMES[[kk]]
[18:02:00.753]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.753]                     next
[18:02:00.753]                   args[[name]] <- ""
[18:02:00.753]                 }
[18:02:00.753]                 NAMES <- toupper(removed)
[18:02:00.753]                 for (kk in seq_along(NAMES)) {
[18:02:00.753]                   name <- removed[[kk]]
[18:02:00.753]                   NAME <- NAMES[[kk]]
[18:02:00.753]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.753]                     next
[18:02:00.753]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:00.753]                 }
[18:02:00.753]                 if (length(args) > 0) 
[18:02:00.753]                   base::do.call(base::Sys.setenv, args = args)
[18:02:00.753]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:00.753]             }
[18:02:00.753]             else {
[18:02:00.753]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:00.753]             }
[18:02:00.753]             {
[18:02:00.753]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:00.753]                   0L) {
[18:02:00.753]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:00.753]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:00.753]                   base::options(opts)
[18:02:00.753]                 }
[18:02:00.753]                 {
[18:02:00.753]                   {
[18:02:00.753]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:00.753]                     NULL
[18:02:00.753]                   }
[18:02:00.753]                   options(future.plan = NULL)
[18:02:00.753]                   if (is.na(NA_character_)) 
[18:02:00.753]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:00.753]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:00.753]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:00.753]                     .init = FALSE)
[18:02:00.753]                 }
[18:02:00.753]             }
[18:02:00.753]         }
[18:02:00.753]     })
[18:02:00.753]     if (TRUE) {
[18:02:00.753]         base::sink(type = "output", split = FALSE)
[18:02:00.753]         if (TRUE) {
[18:02:00.753]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:00.753]         }
[18:02:00.753]         else {
[18:02:00.753]             ...future.result["stdout"] <- base::list(NULL)
[18:02:00.753]         }
[18:02:00.753]         base::close(...future.stdout)
[18:02:00.753]         ...future.stdout <- NULL
[18:02:00.753]     }
[18:02:00.753]     ...future.result$conditions <- ...future.conditions
[18:02:00.753]     ...future.result$finished <- base::Sys.time()
[18:02:00.753]     ...future.result
[18:02:00.753] }
[18:02:00.758] assign_globals() ...
[18:02:00.758] List of 11
[18:02:00.758]  $ ...future.FUN            :function (x, ...)  
[18:02:00.758]  $ x_FUN                    :function (x)  
[18:02:00.758]  $ times                    : int 1
[18:02:00.758]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:00.758]  $ stop_if_not              :function (...)  
[18:02:00.758]  $ dim                      : NULL
[18:02:00.758]  $ valid_types              : chr [1:2] "logical" "integer"
[18:02:00.758]  $ future.call.arguments    : list()
[18:02:00.758]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.758]  $ ...future.elements_ii    :List of 1
[18:02:00.758]   ..$ a: num 1
[18:02:00.758]  $ ...future.seeds_ii       : NULL
[18:02:00.758]  $ ...future.globals.maxSize: NULL
[18:02:00.758]  - attr(*, "where")=List of 11
[18:02:00.758]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:00.758]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:02:00.758]   ..$ times                    :<environment: R_EmptyEnv> 
[18:02:00.758]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:02:00.758]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:02:00.758]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:02:00.758]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:02:00.758]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:00.758]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:00.758]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:00.758]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:00.758]  - attr(*, "resolved")= logi FALSE
[18:02:00.758]  - attr(*, "total_size")= num 94264
[18:02:00.758]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.758]  - attr(*, "already-done")= logi TRUE
[18:02:00.774] - copied ‘...future.FUN’ to environment
[18:02:00.774] - copied ‘x_FUN’ to environment
[18:02:00.775] - copied ‘times’ to environment
[18:02:00.775] - copied ‘stopf’ to environment
[18:02:00.775] - copied ‘stop_if_not’ to environment
[18:02:00.775] - copied ‘dim’ to environment
[18:02:00.775] - copied ‘valid_types’ to environment
[18:02:00.776] - copied ‘future.call.arguments’ to environment
[18:02:00.776] - copied ‘...future.elements_ii’ to environment
[18:02:00.776] - copied ‘...future.seeds_ii’ to environment
[18:02:00.776] - copied ‘...future.globals.maxSize’ to environment
[18:02:00.776] assign_globals() ... done
[18:02:00.777] requestCore(): workers = 2
[18:02:00.780] MulticoreFuture started
[18:02:00.781] - Launch lazy future ... done
[18:02:00.781] run() for ‘MulticoreFuture’ ... done
[18:02:00.782] Created future:
[18:02:00.783] plan(): Setting new future strategy stack:
[18:02:00.783] List of future strategies:
[18:02:00.783] 1. sequential:
[18:02:00.783]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:00.783]    - tweaked: FALSE
[18:02:00.783]    - call: NULL
[18:02:00.785] plan(): nbrOfWorkers() = 1
[18:02:00.790] plan(): Setting new future strategy stack:
[18:02:00.790] List of future strategies:
[18:02:00.790] 1. multicore:
[18:02:00.790]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:00.790]    - tweaked: FALSE
[18:02:00.790]    - call: plan(strategy)
[18:02:00.782] MulticoreFuture:
[18:02:00.782] Label: ‘future_vapply-1’
[18:02:00.782] Expression:
[18:02:00.782] {
[18:02:00.782]     do.call(function(...) {
[18:02:00.782]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.782]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.782]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.782]             on.exit(options(oopts), add = TRUE)
[18:02:00.782]         }
[18:02:00.782]         {
[18:02:00.782]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.782]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.782]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.782]             })
[18:02:00.782]         }
[18:02:00.782]     }, args = future.call.arguments)
[18:02:00.782] }
[18:02:00.782] Lazy evaluation: FALSE
[18:02:00.782] Asynchronous evaluation: TRUE
[18:02:00.782] Local evaluation: TRUE
[18:02:00.782] Environment: R_GlobalEnv
[18:02:00.782] Capture standard output: TRUE
[18:02:00.782] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:00.782] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:00.782] Packages: 1 packages (‘future.apply’)
[18:02:00.782] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:00.782] Resolved: FALSE
[18:02:00.782] Value: <not collected>
[18:02:00.782] Conditions captured: <none>
[18:02:00.782] Early signaling: FALSE
[18:02:00.782] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:00.782] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.798] Chunk #1 of 2 ... DONE
[18:02:00.799] Chunk #2 of 2 ...
[18:02:00.799]  - Finding globals in 'X' for chunk #2 ...
[18:02:00.800] getGlobalsAndPackages() ...
[18:02:00.800] Searching for globals...
[18:02:00.800] plan(): nbrOfWorkers() = 2
[18:02:00.801] 
[18:02:00.801] Searching for globals ... DONE
[18:02:00.801] - globals: [0] <none>
[18:02:00.802] getGlobalsAndPackages() ... DONE
[18:02:00.802]    + additional globals found: [n=0] 
[18:02:00.802]    + additional namespaces needed: [n=0] 
[18:02:00.802]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:00.803]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:00.803]  - seeds: <none>
[18:02:00.803]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.804] getGlobalsAndPackages() ...
[18:02:00.804] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.804] Resolving globals: FALSE
[18:02:00.805] Tweak future expression to call with '...' arguments ...
[18:02:00.805] {
[18:02:00.805]     do.call(function(...) {
[18:02:00.805]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.805]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.805]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.805]             on.exit(options(oopts), add = TRUE)
[18:02:00.805]         }
[18:02:00.805]         {
[18:02:00.805]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.805]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.805]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.805]             })
[18:02:00.805]         }
[18:02:00.805]     }, args = future.call.arguments)
[18:02:00.805] }
[18:02:00.806] Tweak future expression to call with '...' arguments ... DONE
[18:02:00.808] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.808] - packages: [1] ‘future.apply’
[18:02:00.809] getGlobalsAndPackages() ... DONE
[18:02:00.810] run() for ‘Future’ ...
[18:02:00.810] - state: ‘created’
[18:02:00.811] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:00.819] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.819] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:00.820]   - Field: ‘label’
[18:02:00.820]   - Field: ‘local’
[18:02:00.820]   - Field: ‘owner’
[18:02:00.826]   - Field: ‘envir’
[18:02:00.826]   - Field: ‘workers’
[18:02:00.827]   - Field: ‘packages’
[18:02:00.827]   - Field: ‘gc’
[18:02:00.828]   - Field: ‘job’
[18:02:00.829]   - Field: ‘conditions’
[18:02:00.829]   - Field: ‘expr’
[18:02:00.830]   - Field: ‘uuid’
[18:02:00.830]   - Field: ‘seed’
[18:02:00.831]   - Field: ‘version’
[18:02:00.831]   - Field: ‘result’
[18:02:00.832]   - Field: ‘asynchronous’
[18:02:00.832]   - Field: ‘calls’
[18:02:00.833]   - Field: ‘globals’
[18:02:00.833]   - Field: ‘stdout’
[18:02:00.834]   - Field: ‘earlySignal’
[18:02:00.834]   - Field: ‘lazy’
[18:02:00.834]   - Field: ‘state’
[18:02:00.835] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:00.835] - Launch lazy future ...
[18:02:00.837] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:00.837] Packages needed by future strategies (n = 0): <none>
[18:02:00.840] {
[18:02:00.840]     {
[18:02:00.840]         {
[18:02:00.840]             ...future.startTime <- base::Sys.time()
[18:02:00.840]             {
[18:02:00.840]                 {
[18:02:00.840]                   {
[18:02:00.840]                     {
[18:02:00.840]                       {
[18:02:00.840]                         base::local({
[18:02:00.840]                           has_future <- base::requireNamespace("future", 
[18:02:00.840]                             quietly = TRUE)
[18:02:00.840]                           if (has_future) {
[18:02:00.840]                             ns <- base::getNamespace("future")
[18:02:00.840]                             version <- ns[[".package"]][["version"]]
[18:02:00.840]                             if (is.null(version)) 
[18:02:00.840]                               version <- utils::packageVersion("future")
[18:02:00.840]                           }
[18:02:00.840]                           else {
[18:02:00.840]                             version <- NULL
[18:02:00.840]                           }
[18:02:00.840]                           if (!has_future || version < "1.8.0") {
[18:02:00.840]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:00.840]                               "", base::R.version$version.string), 
[18:02:00.840]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:00.840]                                 base::R.version$platform, 8 * 
[18:02:00.840]                                   base::.Machine$sizeof.pointer), 
[18:02:00.840]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:00.840]                                 "release", "version")], collapse = " "), 
[18:02:00.840]                               hostname = base::Sys.info()[["nodename"]])
[18:02:00.840]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:00.840]                               info)
[18:02:00.840]                             info <- base::paste(info, collapse = "; ")
[18:02:00.840]                             if (!has_future) {
[18:02:00.840]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:00.840]                                 info)
[18:02:00.840]                             }
[18:02:00.840]                             else {
[18:02:00.840]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:00.840]                                 info, version)
[18:02:00.840]                             }
[18:02:00.840]                             base::stop(msg)
[18:02:00.840]                           }
[18:02:00.840]                         })
[18:02:00.840]                       }
[18:02:00.840]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:00.840]                       base::options(mc.cores = 1L)
[18:02:00.840]                     }
[18:02:00.840]                     base::local({
[18:02:00.840]                       for (pkg in "future.apply") {
[18:02:00.840]                         base::loadNamespace(pkg)
[18:02:00.840]                         base::library(pkg, character.only = TRUE)
[18:02:00.840]                       }
[18:02:00.840]                     })
[18:02:00.840]                   }
[18:02:00.840]                   ...future.strategy.old <- future::plan("list")
[18:02:00.840]                   options(future.plan = NULL)
[18:02:00.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:00.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:00.840]                 }
[18:02:00.840]                 ...future.workdir <- getwd()
[18:02:00.840]             }
[18:02:00.840]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:00.840]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:00.840]         }
[18:02:00.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:00.840]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:00.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:00.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:00.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:00.840]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:00.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:00.840]             base::names(...future.oldOptions))
[18:02:00.840]     }
[18:02:00.840]     if (FALSE) {
[18:02:00.840]     }
[18:02:00.840]     else {
[18:02:00.840]         if (TRUE) {
[18:02:00.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:00.840]                 open = "w")
[18:02:00.840]         }
[18:02:00.840]         else {
[18:02:00.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:00.840]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:00.840]         }
[18:02:00.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:00.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:00.840]             base::sink(type = "output", split = FALSE)
[18:02:00.840]             base::close(...future.stdout)
[18:02:00.840]         }, add = TRUE)
[18:02:00.840]     }
[18:02:00.840]     ...future.frame <- base::sys.nframe()
[18:02:00.840]     ...future.conditions <- base::list()
[18:02:00.840]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:00.840]     if (FALSE) {
[18:02:00.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:00.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:00.840]     }
[18:02:00.840]     ...future.result <- base::tryCatch({
[18:02:00.840]         base::withCallingHandlers({
[18:02:00.840]             ...future.value <- base::withVisible(base::local({
[18:02:00.840]                 withCallingHandlers({
[18:02:00.840]                   {
[18:02:00.840]                     do.call(function(...) {
[18:02:00.840]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.840]                       if (!identical(...future.globals.maxSize.org, 
[18:02:00.840]                         ...future.globals.maxSize)) {
[18:02:00.840]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.840]                         on.exit(options(oopts), add = TRUE)
[18:02:00.840]                       }
[18:02:00.840]                       {
[18:02:00.840]                         lapply(seq_along(...future.elements_ii), 
[18:02:00.840]                           FUN = function(jj) {
[18:02:00.840]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.840]                             ...future.FUN(...future.X_jj, ...)
[18:02:00.840]                           })
[18:02:00.840]                       }
[18:02:00.840]                     }, args = future.call.arguments)
[18:02:00.840]                   }
[18:02:00.840]                 }, immediateCondition = function(cond) {
[18:02:00.840]                   save_rds <- function (object, pathname, ...) 
[18:02:00.840]                   {
[18:02:00.840]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:00.840]                     if (file_test("-f", pathname_tmp)) {
[18:02:00.840]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.840]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:00.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.840]                         fi_tmp[["mtime"]])
[18:02:00.840]                     }
[18:02:00.840]                     tryCatch({
[18:02:00.840]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:00.840]                     }, error = function(ex) {
[18:02:00.840]                       msg <- conditionMessage(ex)
[18:02:00.840]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.840]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:00.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.840]                         fi_tmp[["mtime"]], msg)
[18:02:00.840]                       ex$message <- msg
[18:02:00.840]                       stop(ex)
[18:02:00.840]                     })
[18:02:00.840]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:00.840]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:00.840]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:00.840]                       fi_tmp <- file.info(pathname_tmp)
[18:02:00.840]                       fi <- file.info(pathname)
[18:02:00.840]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:00.840]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:00.840]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:00.840]                         fi[["size"]], fi[["mtime"]])
[18:02:00.840]                       stop(msg)
[18:02:00.840]                     }
[18:02:00.840]                     invisible(pathname)
[18:02:00.840]                   }
[18:02:00.840]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:00.840]                     rootPath = tempdir()) 
[18:02:00.840]                   {
[18:02:00.840]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:00.840]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:00.840]                       tmpdir = path, fileext = ".rds")
[18:02:00.840]                     save_rds(obj, file)
[18:02:00.840]                   }
[18:02:00.840]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:02:00.840]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.840]                   {
[18:02:00.840]                     inherits <- base::inherits
[18:02:00.840]                     invokeRestart <- base::invokeRestart
[18:02:00.840]                     is.null <- base::is.null
[18:02:00.840]                     muffled <- FALSE
[18:02:00.840]                     if (inherits(cond, "message")) {
[18:02:00.840]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:00.840]                       if (muffled) 
[18:02:00.840]                         invokeRestart("muffleMessage")
[18:02:00.840]                     }
[18:02:00.840]                     else if (inherits(cond, "warning")) {
[18:02:00.840]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:00.840]                       if (muffled) 
[18:02:00.840]                         invokeRestart("muffleWarning")
[18:02:00.840]                     }
[18:02:00.840]                     else if (inherits(cond, "condition")) {
[18:02:00.840]                       if (!is.null(pattern)) {
[18:02:00.840]                         computeRestarts <- base::computeRestarts
[18:02:00.840]                         grepl <- base::grepl
[18:02:00.840]                         restarts <- computeRestarts(cond)
[18:02:00.840]                         for (restart in restarts) {
[18:02:00.840]                           name <- restart$name
[18:02:00.840]                           if (is.null(name)) 
[18:02:00.840]                             next
[18:02:00.840]                           if (!grepl(pattern, name)) 
[18:02:00.840]                             next
[18:02:00.840]                           invokeRestart(restart)
[18:02:00.840]                           muffled <- TRUE
[18:02:00.840]                           break
[18:02:00.840]                         }
[18:02:00.840]                       }
[18:02:00.840]                     }
[18:02:00.840]                     invisible(muffled)
[18:02:00.840]                   }
[18:02:00.840]                   muffleCondition(cond)
[18:02:00.840]                 })
[18:02:00.840]             }))
[18:02:00.840]             future::FutureResult(value = ...future.value$value, 
[18:02:00.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:00.840]                   ...future.rng), globalenv = if (FALSE) 
[18:02:00.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:00.840]                     ...future.globalenv.names))
[18:02:00.840]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:00.840]         }, condition = base::local({
[18:02:00.840]             c <- base::c
[18:02:00.840]             inherits <- base::inherits
[18:02:00.840]             invokeRestart <- base::invokeRestart
[18:02:00.840]             length <- base::length
[18:02:00.840]             list <- base::list
[18:02:00.840]             seq.int <- base::seq.int
[18:02:00.840]             signalCondition <- base::signalCondition
[18:02:00.840]             sys.calls <- base::sys.calls
[18:02:00.840]             `[[` <- base::`[[`
[18:02:00.840]             `+` <- base::`+`
[18:02:00.840]             `<<-` <- base::`<<-`
[18:02:00.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:00.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:00.840]                   3L)]
[18:02:00.840]             }
[18:02:00.840]             function(cond) {
[18:02:00.840]                 is_error <- inherits(cond, "error")
[18:02:00.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:00.840]                   NULL)
[18:02:00.840]                 if (is_error) {
[18:02:00.840]                   sessionInformation <- function() {
[18:02:00.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:00.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:00.840]                       search = base::search(), system = base::Sys.info())
[18:02:00.840]                   }
[18:02:00.840]                   ...future.conditions[[length(...future.conditions) + 
[18:02:00.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:00.840]                     cond$call), session = sessionInformation(), 
[18:02:00.840]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:00.840]                   signalCondition(cond)
[18:02:00.840]                 }
[18:02:00.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:00.840]                 "immediateCondition"))) {
[18:02:00.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:00.840]                   ...future.conditions[[length(...future.conditions) + 
[18:02:00.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:00.840]                   if (TRUE && !signal) {
[18:02:00.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.840]                     {
[18:02:00.840]                       inherits <- base::inherits
[18:02:00.840]                       invokeRestart <- base::invokeRestart
[18:02:00.840]                       is.null <- base::is.null
[18:02:00.840]                       muffled <- FALSE
[18:02:00.840]                       if (inherits(cond, "message")) {
[18:02:00.840]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:00.840]                         if (muffled) 
[18:02:00.840]                           invokeRestart("muffleMessage")
[18:02:00.840]                       }
[18:02:00.840]                       else if (inherits(cond, "warning")) {
[18:02:00.840]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:00.840]                         if (muffled) 
[18:02:00.840]                           invokeRestart("muffleWarning")
[18:02:00.840]                       }
[18:02:00.840]                       else if (inherits(cond, "condition")) {
[18:02:00.840]                         if (!is.null(pattern)) {
[18:02:00.840]                           computeRestarts <- base::computeRestarts
[18:02:00.840]                           grepl <- base::grepl
[18:02:00.840]                           restarts <- computeRestarts(cond)
[18:02:00.840]                           for (restart in restarts) {
[18:02:00.840]                             name <- restart$name
[18:02:00.840]                             if (is.null(name)) 
[18:02:00.840]                               next
[18:02:00.840]                             if (!grepl(pattern, name)) 
[18:02:00.840]                               next
[18:02:00.840]                             invokeRestart(restart)
[18:02:00.840]                             muffled <- TRUE
[18:02:00.840]                             break
[18:02:00.840]                           }
[18:02:00.840]                         }
[18:02:00.840]                       }
[18:02:00.840]                       invisible(muffled)
[18:02:00.840]                     }
[18:02:00.840]                     muffleCondition(cond, pattern = "^muffle")
[18:02:00.840]                   }
[18:02:00.840]                 }
[18:02:00.840]                 else {
[18:02:00.840]                   if (TRUE) {
[18:02:00.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:00.840]                     {
[18:02:00.840]                       inherits <- base::inherits
[18:02:00.840]                       invokeRestart <- base::invokeRestart
[18:02:00.840]                       is.null <- base::is.null
[18:02:00.840]                       muffled <- FALSE
[18:02:00.840]                       if (inherits(cond, "message")) {
[18:02:00.840]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:00.840]                         if (muffled) 
[18:02:00.840]                           invokeRestart("muffleMessage")
[18:02:00.840]                       }
[18:02:00.840]                       else if (inherits(cond, "warning")) {
[18:02:00.840]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:00.840]                         if (muffled) 
[18:02:00.840]                           invokeRestart("muffleWarning")
[18:02:00.840]                       }
[18:02:00.840]                       else if (inherits(cond, "condition")) {
[18:02:00.840]                         if (!is.null(pattern)) {
[18:02:00.840]                           computeRestarts <- base::computeRestarts
[18:02:00.840]                           grepl <- base::grepl
[18:02:00.840]                           restarts <- computeRestarts(cond)
[18:02:00.840]                           for (restart in restarts) {
[18:02:00.840]                             name <- restart$name
[18:02:00.840]                             if (is.null(name)) 
[18:02:00.840]                               next
[18:02:00.840]                             if (!grepl(pattern, name)) 
[18:02:00.840]                               next
[18:02:00.840]                             invokeRestart(restart)
[18:02:00.840]                             muffled <- TRUE
[18:02:00.840]                             break
[18:02:00.840]                           }
[18:02:00.840]                         }
[18:02:00.840]                       }
[18:02:00.840]                       invisible(muffled)
[18:02:00.840]                     }
[18:02:00.840]                     muffleCondition(cond, pattern = "^muffle")
[18:02:00.840]                   }
[18:02:00.840]                 }
[18:02:00.840]             }
[18:02:00.840]         }))
[18:02:00.840]     }, error = function(ex) {
[18:02:00.840]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:00.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:00.840]                 ...future.rng), started = ...future.startTime, 
[18:02:00.840]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:00.840]             version = "1.8"), class = "FutureResult")
[18:02:00.840]     }, finally = {
[18:02:00.840]         if (!identical(...future.workdir, getwd())) 
[18:02:00.840]             setwd(...future.workdir)
[18:02:00.840]         {
[18:02:00.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:00.840]                 ...future.oldOptions$nwarnings <- NULL
[18:02:00.840]             }
[18:02:00.840]             base::options(...future.oldOptions)
[18:02:00.840]             if (.Platform$OS.type == "windows") {
[18:02:00.840]                 old_names <- names(...future.oldEnvVars)
[18:02:00.840]                 envs <- base::Sys.getenv()
[18:02:00.840]                 names <- names(envs)
[18:02:00.840]                 common <- intersect(names, old_names)
[18:02:00.840]                 added <- setdiff(names, old_names)
[18:02:00.840]                 removed <- setdiff(old_names, names)
[18:02:00.840]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:00.840]                   envs[common]]
[18:02:00.840]                 NAMES <- toupper(changed)
[18:02:00.840]                 args <- list()
[18:02:00.840]                 for (kk in seq_along(NAMES)) {
[18:02:00.840]                   name <- changed[[kk]]
[18:02:00.840]                   NAME <- NAMES[[kk]]
[18:02:00.840]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.840]                     next
[18:02:00.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:00.840]                 }
[18:02:00.840]                 NAMES <- toupper(added)
[18:02:00.840]                 for (kk in seq_along(NAMES)) {
[18:02:00.840]                   name <- added[[kk]]
[18:02:00.840]                   NAME <- NAMES[[kk]]
[18:02:00.840]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.840]                     next
[18:02:00.840]                   args[[name]] <- ""
[18:02:00.840]                 }
[18:02:00.840]                 NAMES <- toupper(removed)
[18:02:00.840]                 for (kk in seq_along(NAMES)) {
[18:02:00.840]                   name <- removed[[kk]]
[18:02:00.840]                   NAME <- NAMES[[kk]]
[18:02:00.840]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:00.840]                     next
[18:02:00.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:00.840]                 }
[18:02:00.840]                 if (length(args) > 0) 
[18:02:00.840]                   base::do.call(base::Sys.setenv, args = args)
[18:02:00.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:00.840]             }
[18:02:00.840]             else {
[18:02:00.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:00.840]             }
[18:02:00.840]             {
[18:02:00.840]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:00.840]                   0L) {
[18:02:00.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:00.840]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:00.840]                   base::options(opts)
[18:02:00.840]                 }
[18:02:00.840]                 {
[18:02:00.840]                   {
[18:02:00.840]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:00.840]                     NULL
[18:02:00.840]                   }
[18:02:00.840]                   options(future.plan = NULL)
[18:02:00.840]                   if (is.na(NA_character_)) 
[18:02:00.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:00.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:00.840]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:00.840]                     .init = FALSE)
[18:02:00.840]                 }
[18:02:00.840]             }
[18:02:00.840]         }
[18:02:00.840]     })
[18:02:00.840]     if (TRUE) {
[18:02:00.840]         base::sink(type = "output", split = FALSE)
[18:02:00.840]         if (TRUE) {
[18:02:00.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:00.840]         }
[18:02:00.840]         else {
[18:02:00.840]             ...future.result["stdout"] <- base::list(NULL)
[18:02:00.840]         }
[18:02:00.840]         base::close(...future.stdout)
[18:02:00.840]         ...future.stdout <- NULL
[18:02:00.840]     }
[18:02:00.840]     ...future.result$conditions <- ...future.conditions
[18:02:00.840]     ...future.result$finished <- base::Sys.time()
[18:02:00.840]     ...future.result
[18:02:00.840] }
[18:02:00.845] assign_globals() ...
[18:02:00.846] List of 11
[18:02:00.846]  $ ...future.FUN            :function (x, ...)  
[18:02:00.846]  $ x_FUN                    :function (x)  
[18:02:00.846]  $ times                    : int 1
[18:02:00.846]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:00.846]  $ stop_if_not              :function (...)  
[18:02:00.846]  $ dim                      : NULL
[18:02:00.846]  $ valid_types              : chr [1:2] "logical" "integer"
[18:02:00.846]  $ future.call.arguments    : list()
[18:02:00.846]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.846]  $ ...future.elements_ii    :List of 2
[18:02:00.846]   ..$ b: num 2
[18:02:00.846]   ..$ c: num 3
[18:02:00.846]  $ ...future.seeds_ii       : NULL
[18:02:00.846]  $ ...future.globals.maxSize: NULL
[18:02:00.846]  - attr(*, "where")=List of 11
[18:02:00.846]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:00.846]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:02:00.846]   ..$ times                    :<environment: R_EmptyEnv> 
[18:02:00.846]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:02:00.846]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:02:00.846]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:02:00.846]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:02:00.846]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:00.846]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:00.846]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:00.846]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:00.846]  - attr(*, "resolved")= logi FALSE
[18:02:00.846]  - attr(*, "total_size")= num 94264
[18:02:00.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.846]  - attr(*, "already-done")= logi TRUE
[18:02:00.869] - copied ‘...future.FUN’ to environment
[18:02:00.869] - copied ‘x_FUN’ to environment
[18:02:00.870] - copied ‘times’ to environment
[18:02:00.870] - copied ‘stopf’ to environment
[18:02:00.870] - copied ‘stop_if_not’ to environment
[18:02:00.870] - copied ‘dim’ to environment
[18:02:00.871] - copied ‘valid_types’ to environment
[18:02:00.871] - copied ‘future.call.arguments’ to environment
[18:02:00.871] - copied ‘...future.elements_ii’ to environment
[18:02:00.871] - copied ‘...future.seeds_ii’ to environment
[18:02:00.871] - copied ‘...future.globals.maxSize’ to environment
[18:02:00.872] assign_globals() ... done
[18:02:00.872] requestCore(): workers = 2
[18:02:00.876] MulticoreFuture started
[18:02:00.876] - Launch lazy future ... done
[18:02:00.877] run() for ‘MulticoreFuture’ ... done
[18:02:00.877] Created future:
[18:02:00.878] plan(): Setting new future strategy stack:
[18:02:00.879] List of future strategies:
[18:02:00.879] 1. sequential:
[18:02:00.879]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:00.879]    - tweaked: FALSE
[18:02:00.879]    - call: NULL
[18:02:00.881] plan(): nbrOfWorkers() = 1
[18:02:00.885] plan(): Setting new future strategy stack:
[18:02:00.886] List of future strategies:
[18:02:00.886] 1. multicore:
[18:02:00.886]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:00.886]    - tweaked: FALSE
[18:02:00.886]    - call: plan(strategy)
[18:02:00.878] MulticoreFuture:
[18:02:00.878] Label: ‘future_vapply-2’
[18:02:00.878] Expression:
[18:02:00.878] {
[18:02:00.878]     do.call(function(...) {
[18:02:00.878]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.878]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.878]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.878]             on.exit(options(oopts), add = TRUE)
[18:02:00.878]         }
[18:02:00.878]         {
[18:02:00.878]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.878]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.878]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.878]             })
[18:02:00.878]         }
[18:02:00.878]     }, args = future.call.arguments)
[18:02:00.878] }
[18:02:00.878] Lazy evaluation: FALSE
[18:02:00.878] Asynchronous evaluation: TRUE
[18:02:00.878] Local evaluation: TRUE
[18:02:00.878] Environment: R_GlobalEnv
[18:02:00.878] Capture standard output: TRUE
[18:02:00.878] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:00.878] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:00.878] Packages: 1 packages (‘future.apply’)
[18:02:00.878] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:00.878] Resolved: FALSE
[18:02:00.878] Value: <not collected>
[18:02:00.878] Conditions captured: <none>
[18:02:00.878] Early signaling: FALSE
[18:02:00.878] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:00.878] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:00.894] Chunk #2 of 2 ... DONE
[18:02:00.894] Launching 2 futures (chunks) ... DONE
[18:02:00.895] Resolving 2 futures (chunks) ...
[18:02:00.895] resolve() on list ...
[18:02:00.895] plan(): nbrOfWorkers() = 2
[18:02:00.895]  recursive: 0
[18:02:00.896]  length: 2
[18:02:00.896] 
[18:02:00.897] Future #1
[18:02:00.897] result() for MulticoreFuture ...
[18:02:00.899] result() for MulticoreFuture ...
[18:02:00.899] result() for MulticoreFuture ... done
[18:02:00.899] result() for MulticoreFuture ... done
[18:02:00.899] result() for MulticoreFuture ...
[18:02:00.900] result() for MulticoreFuture ... done
[18:02:00.900] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:02:00.900] - nx: 2
[18:02:00.901] - relay: TRUE
[18:02:00.901] - stdout: TRUE
[18:02:00.901] - signal: TRUE
[18:02:00.902] - resignal: FALSE
[18:02:00.902] - force: TRUE
[18:02:00.902] - relayed: [n=2] FALSE, FALSE
[18:02:00.903] - queued futures: [n=2] FALSE, FALSE
[18:02:00.903]  - until=1
[18:02:00.903]  - relaying element #1
[18:02:00.904] result() for MulticoreFuture ...
[18:02:00.904] result() for MulticoreFuture ... done
[18:02:00.904] result() for MulticoreFuture ...
[18:02:00.905] result() for MulticoreFuture ... done
[18:02:00.905] result() for MulticoreFuture ...
[18:02:00.905] result() for MulticoreFuture ... done
[18:02:00.906] result() for MulticoreFuture ...
[18:02:00.906] result() for MulticoreFuture ... done
[18:02:00.906] - relayed: [n=2] TRUE, FALSE
[18:02:00.906] - queued futures: [n=2] TRUE, FALSE
[18:02:00.907] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:02:00.907]  length: 1 (resolved future 1)
[18:02:00.908] Future #2
[18:02:00.913] result() for MulticoreFuture ...
[18:02:00.916] result() for MulticoreFuture ...
[18:02:00.916] result() for MulticoreFuture ... done
[18:02:00.917] result() for MulticoreFuture ... done
[18:02:00.918] result() for MulticoreFuture ...
[18:02:00.918] result() for MulticoreFuture ... done
[18:02:00.918] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:02:00.919] - nx: 2
[18:02:00.919] - relay: TRUE
[18:02:00.919] - stdout: TRUE
[18:02:00.920] - signal: TRUE
[18:02:00.920] - resignal: FALSE
[18:02:00.920] - force: TRUE
[18:02:00.920] - relayed: [n=2] TRUE, FALSE
[18:02:00.921] - queued futures: [n=2] TRUE, FALSE
[18:02:00.921]  - until=2
[18:02:00.921]  - relaying element #2
[18:02:00.922] result() for MulticoreFuture ...
[18:02:00.922] result() for MulticoreFuture ... done
[18:02:00.922] result() for MulticoreFuture ...
[18:02:00.922] result() for MulticoreFuture ... done
[18:02:00.923] result() for MulticoreFuture ...
[18:02:00.923] result() for MulticoreFuture ... done
[18:02:00.923] result() for MulticoreFuture ...
[18:02:00.924] result() for MulticoreFuture ... done
[18:02:00.924] - relayed: [n=2] TRUE, TRUE
[18:02:00.924] - queued futures: [n=2] TRUE, TRUE
[18:02:00.924] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[18:02:00.925]  length: 0 (resolved future 2)
[18:02:00.925] Relaying remaining futures
[18:02:00.925] signalConditionsASAP(NULL, pos=0) ...
[18:02:00.926] - nx: 2
[18:02:00.926] - relay: TRUE
[18:02:00.926] - stdout: TRUE
[18:02:00.926] - signal: TRUE
[18:02:00.926] - resignal: FALSE
[18:02:00.927] - force: TRUE
[18:02:00.927] - relayed: [n=2] TRUE, TRUE
[18:02:00.927] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:00.928] - relayed: [n=2] TRUE, TRUE
[18:02:00.928] - queued futures: [n=2] TRUE, TRUE
[18:02:00.928] signalConditionsASAP(NULL, pos=0) ... done
[18:02:00.928] resolve() on list ... DONE
[18:02:00.929] result() for MulticoreFuture ...
[18:02:00.929] result() for MulticoreFuture ... done
[18:02:00.929] result() for MulticoreFuture ...
[18:02:00.929] result() for MulticoreFuture ... done
[18:02:00.930] result() for MulticoreFuture ...
[18:02:00.930] result() for MulticoreFuture ... done
[18:02:00.930] result() for MulticoreFuture ...
[18:02:00.930] result() for MulticoreFuture ... done
[18:02:00.931]  - Number of value chunks collected: 2
[18:02:00.931] Resolving 2 futures (chunks) ... DONE
[18:02:00.931] Reducing values from 2 chunks ...
[18:02:00.931]  - Number of values collected after concatenation: 3
[18:02:00.932]  - Number of values expected: 3
[18:02:00.932] Reducing values from 2 chunks ... DONE
[18:02:00.932] future_lapply() ... DONE
- exceptions ...
[18:02:00.933] future_lapply() ...
[18:02:00.943] Number of chunks: 2
[18:02:00.944] getGlobalsAndPackagesXApply() ...
[18:02:00.944]  - future.globals: TRUE
[18:02:00.944] getGlobalsAndPackages() ...
[18:02:00.944] Searching for globals...
[18:02:00.952] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:02:00.952] Searching for globals ... DONE
[18:02:00.953] Resolving globals: FALSE
[18:02:00.955] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[18:02:00.956] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:00.956] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:00.956] - packages: [1] ‘future.apply’
[18:02:00.956] getGlobalsAndPackages() ... DONE
[18:02:00.957]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:00.957]  - needed namespaces: [n=1] ‘future.apply’
[18:02:00.957] Finding globals ... DONE
[18:02:00.957]  - use_args: TRUE
[18:02:00.958]  - Getting '...' globals ...
[18:02:00.958] resolve() on list ...
[18:02:00.959]  recursive: 0
[18:02:00.959]  length: 1
[18:02:00.959]  elements: ‘...’
[18:02:00.959]  length: 0 (resolved future 1)
[18:02:00.959] resolve() on list ... DONE
[18:02:00.960]    - '...' content: [n=0] 
[18:02:00.960] List of 1
[18:02:00.960]  $ ...: list()
[18:02:00.960]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.960]  - attr(*, "where")=List of 1
[18:02:00.960]   ..$ ...:<environment: 0x6183c0f16060> 
[18:02:00.960]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.960]  - attr(*, "resolved")= logi TRUE
[18:02:00.960]  - attr(*, "total_size")= num NA
[18:02:00.969]  - Getting '...' globals ... DONE
[18:02:00.970] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:00.970] List of 8
[18:02:00.970]  $ ...future.FUN:function (x, ...)  
[18:02:00.970]  $ x_FUN        :function (x)  
[18:02:00.970]  $ times        : int 2
[18:02:00.970]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:00.970]  $ stop_if_not  :function (...)  
[18:02:00.970]  $ dim          : NULL
[18:02:00.970]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:02:00.970]  $ ...          : list()
[18:02:00.970]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:00.970]  - attr(*, "where")=List of 8
[18:02:00.970]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:00.970]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:00.970]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:00.970]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:00.970]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:00.970]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:00.970]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:00.970]   ..$ ...          :<environment: 0x6183c0f16060> 
[18:02:00.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:00.970]  - attr(*, "resolved")= logi FALSE
[18:02:00.970]  - attr(*, "total_size")= num 95128
[18:02:00.983] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:00.984] getGlobalsAndPackagesXApply() ... DONE
[18:02:00.984] Number of futures (= number of chunks): 2
[18:02:00.984] Launching 2 futures (chunks) ...
[18:02:00.985] Chunk #1 of 2 ...
[18:02:00.985]  - Finding globals in 'X' for chunk #1 ...
[18:02:00.985] getGlobalsAndPackages() ...
[18:02:00.986] Searching for globals...
[18:02:00.986] 
[18:02:00.986] Searching for globals ... DONE
[18:02:00.987] - globals: [0] <none>
[18:02:00.987] getGlobalsAndPackages() ... DONE
[18:02:00.987]    + additional globals found: [n=0] 
[18:02:00.988]    + additional namespaces needed: [n=0] 
[18:02:00.988]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:00.988]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:00.988]  - seeds: <none>
[18:02:00.988]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.989] getGlobalsAndPackages() ...
[18:02:00.989] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.989] Resolving globals: FALSE
[18:02:00.989] Tweak future expression to call with '...' arguments ...
[18:02:00.990] {
[18:02:00.990]     do.call(function(...) {
[18:02:00.990]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:00.990]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:00.990]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:00.990]             on.exit(options(oopts), add = TRUE)
[18:02:00.990]         }
[18:02:00.990]         {
[18:02:00.990]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:00.990]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:00.990]                 ...future.FUN(...future.X_jj, ...)
[18:02:00.990]             })
[18:02:00.990]         }
[18:02:00.990]     }, args = future.call.arguments)
[18:02:00.990] }
[18:02:00.990] Tweak future expression to call with '...' arguments ... DONE
[18:02:00.991] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:00.992] - packages: [1] ‘future.apply’
[18:02:00.992] getGlobalsAndPackages() ... DONE
[18:02:00.993] run() for ‘Future’ ...
[18:02:00.993] - state: ‘created’
[18:02:00.993] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:01.000] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:01.000] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:01.000]   - Field: ‘label’
[18:02:01.001]   - Field: ‘local’
[18:02:01.001]   - Field: ‘owner’
[18:02:01.001]   - Field: ‘envir’
[18:02:01.001]   - Field: ‘workers’
[18:02:01.001]   - Field: ‘packages’
[18:02:01.002]   - Field: ‘gc’
[18:02:01.002]   - Field: ‘job’
[18:02:01.003]   - Field: ‘conditions’
[18:02:01.003]   - Field: ‘expr’
[18:02:01.003]   - Field: ‘uuid’
[18:02:01.003]   - Field: ‘seed’
[18:02:01.003]   - Field: ‘version’
[18:02:01.004]   - Field: ‘result’
[18:02:01.004]   - Field: ‘asynchronous’
[18:02:01.004]   - Field: ‘calls’
[18:02:01.004]   - Field: ‘globals’
[18:02:01.005]   - Field: ‘stdout’
[18:02:01.005]   - Field: ‘earlySignal’
[18:02:01.005]   - Field: ‘lazy’
[18:02:01.005]   - Field: ‘state’
[18:02:01.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:01.006] - Launch lazy future ...
[18:02:01.006] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:01.006] Packages needed by future strategies (n = 0): <none>
[18:02:01.008] {
[18:02:01.008]     {
[18:02:01.008]         {
[18:02:01.008]             ...future.startTime <- base::Sys.time()
[18:02:01.008]             {
[18:02:01.008]                 {
[18:02:01.008]                   {
[18:02:01.008]                     {
[18:02:01.008]                       {
[18:02:01.008]                         base::local({
[18:02:01.008]                           has_future <- base::requireNamespace("future", 
[18:02:01.008]                             quietly = TRUE)
[18:02:01.008]                           if (has_future) {
[18:02:01.008]                             ns <- base::getNamespace("future")
[18:02:01.008]                             version <- ns[[".package"]][["version"]]
[18:02:01.008]                             if (is.null(version)) 
[18:02:01.008]                               version <- utils::packageVersion("future")
[18:02:01.008]                           }
[18:02:01.008]                           else {
[18:02:01.008]                             version <- NULL
[18:02:01.008]                           }
[18:02:01.008]                           if (!has_future || version < "1.8.0") {
[18:02:01.008]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:01.008]                               "", base::R.version$version.string), 
[18:02:01.008]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:01.008]                                 base::R.version$platform, 8 * 
[18:02:01.008]                                   base::.Machine$sizeof.pointer), 
[18:02:01.008]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:01.008]                                 "release", "version")], collapse = " "), 
[18:02:01.008]                               hostname = base::Sys.info()[["nodename"]])
[18:02:01.008]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:01.008]                               info)
[18:02:01.008]                             info <- base::paste(info, collapse = "; ")
[18:02:01.008]                             if (!has_future) {
[18:02:01.008]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:01.008]                                 info)
[18:02:01.008]                             }
[18:02:01.008]                             else {
[18:02:01.008]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:01.008]                                 info, version)
[18:02:01.008]                             }
[18:02:01.008]                             base::stop(msg)
[18:02:01.008]                           }
[18:02:01.008]                         })
[18:02:01.008]                       }
[18:02:01.008]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:01.008]                       base::options(mc.cores = 1L)
[18:02:01.008]                     }
[18:02:01.008]                     base::local({
[18:02:01.008]                       for (pkg in "future.apply") {
[18:02:01.008]                         base::loadNamespace(pkg)
[18:02:01.008]                         base::library(pkg, character.only = TRUE)
[18:02:01.008]                       }
[18:02:01.008]                     })
[18:02:01.008]                   }
[18:02:01.008]                   ...future.strategy.old <- future::plan("list")
[18:02:01.008]                   options(future.plan = NULL)
[18:02:01.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:01.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:01.008]                 }
[18:02:01.008]                 ...future.workdir <- getwd()
[18:02:01.008]             }
[18:02:01.008]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:01.008]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:01.008]         }
[18:02:01.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:01.008]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:01.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:01.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:01.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:01.008]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:01.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:01.008]             base::names(...future.oldOptions))
[18:02:01.008]     }
[18:02:01.008]     if (FALSE) {
[18:02:01.008]     }
[18:02:01.008]     else {
[18:02:01.008]         if (TRUE) {
[18:02:01.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:01.008]                 open = "w")
[18:02:01.008]         }
[18:02:01.008]         else {
[18:02:01.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:01.008]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:01.008]         }
[18:02:01.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:01.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:01.008]             base::sink(type = "output", split = FALSE)
[18:02:01.008]             base::close(...future.stdout)
[18:02:01.008]         }, add = TRUE)
[18:02:01.008]     }
[18:02:01.008]     ...future.frame <- base::sys.nframe()
[18:02:01.008]     ...future.conditions <- base::list()
[18:02:01.008]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:01.008]     if (FALSE) {
[18:02:01.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:01.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:01.008]     }
[18:02:01.008]     ...future.result <- base::tryCatch({
[18:02:01.008]         base::withCallingHandlers({
[18:02:01.008]             ...future.value <- base::withVisible(base::local({
[18:02:01.008]                 withCallingHandlers({
[18:02:01.008]                   {
[18:02:01.008]                     do.call(function(...) {
[18:02:01.008]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:01.008]                       if (!identical(...future.globals.maxSize.org, 
[18:02:01.008]                         ...future.globals.maxSize)) {
[18:02:01.008]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:01.008]                         on.exit(options(oopts), add = TRUE)
[18:02:01.008]                       }
[18:02:01.008]                       {
[18:02:01.008]                         lapply(seq_along(...future.elements_ii), 
[18:02:01.008]                           FUN = function(jj) {
[18:02:01.008]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:01.008]                             ...future.FUN(...future.X_jj, ...)
[18:02:01.008]                           })
[18:02:01.008]                       }
[18:02:01.008]                     }, args = future.call.arguments)
[18:02:01.008]                   }
[18:02:01.008]                 }, immediateCondition = function(cond) {
[18:02:01.008]                   save_rds <- function (object, pathname, ...) 
[18:02:01.008]                   {
[18:02:01.008]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:01.008]                     if (file_test("-f", pathname_tmp)) {
[18:02:01.008]                       fi_tmp <- file.info(pathname_tmp)
[18:02:01.008]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:01.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:01.008]                         fi_tmp[["mtime"]])
[18:02:01.008]                     }
[18:02:01.008]                     tryCatch({
[18:02:01.008]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:01.008]                     }, error = function(ex) {
[18:02:01.008]                       msg <- conditionMessage(ex)
[18:02:01.008]                       fi_tmp <- file.info(pathname_tmp)
[18:02:01.008]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:01.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:01.008]                         fi_tmp[["mtime"]], msg)
[18:02:01.008]                       ex$message <- msg
[18:02:01.008]                       stop(ex)
[18:02:01.008]                     })
[18:02:01.008]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:01.008]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:01.008]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:01.008]                       fi_tmp <- file.info(pathname_tmp)
[18:02:01.008]                       fi <- file.info(pathname)
[18:02:01.008]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:01.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:01.008]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:01.008]                         fi[["size"]], fi[["mtime"]])
[18:02:01.008]                       stop(msg)
[18:02:01.008]                     }
[18:02:01.008]                     invisible(pathname)
[18:02:01.008]                   }
[18:02:01.008]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:01.008]                     rootPath = tempdir()) 
[18:02:01.008]                   {
[18:02:01.008]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:01.008]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:01.008]                       tmpdir = path, fileext = ".rds")
[18:02:01.008]                     save_rds(obj, file)
[18:02:01.008]                   }
[18:02:01.008]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:02:01.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:01.008]                   {
[18:02:01.008]                     inherits <- base::inherits
[18:02:01.008]                     invokeRestart <- base::invokeRestart
[18:02:01.008]                     is.null <- base::is.null
[18:02:01.008]                     muffled <- FALSE
[18:02:01.008]                     if (inherits(cond, "message")) {
[18:02:01.008]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:01.008]                       if (muffled) 
[18:02:01.008]                         invokeRestart("muffleMessage")
[18:02:01.008]                     }
[18:02:01.008]                     else if (inherits(cond, "warning")) {
[18:02:01.008]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:01.008]                       if (muffled) 
[18:02:01.008]                         invokeRestart("muffleWarning")
[18:02:01.008]                     }
[18:02:01.008]                     else if (inherits(cond, "condition")) {
[18:02:01.008]                       if (!is.null(pattern)) {
[18:02:01.008]                         computeRestarts <- base::computeRestarts
[18:02:01.008]                         grepl <- base::grepl
[18:02:01.008]                         restarts <- computeRestarts(cond)
[18:02:01.008]                         for (restart in restarts) {
[18:02:01.008]                           name <- restart$name
[18:02:01.008]                           if (is.null(name)) 
[18:02:01.008]                             next
[18:02:01.008]                           if (!grepl(pattern, name)) 
[18:02:01.008]                             next
[18:02:01.008]                           invokeRestart(restart)
[18:02:01.008]                           muffled <- TRUE
[18:02:01.008]                           break
[18:02:01.008]                         }
[18:02:01.008]                       }
[18:02:01.008]                     }
[18:02:01.008]                     invisible(muffled)
[18:02:01.008]                   }
[18:02:01.008]                   muffleCondition(cond)
[18:02:01.008]                 })
[18:02:01.008]             }))
[18:02:01.008]             future::FutureResult(value = ...future.value$value, 
[18:02:01.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:01.008]                   ...future.rng), globalenv = if (FALSE) 
[18:02:01.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:01.008]                     ...future.globalenv.names))
[18:02:01.008]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:01.008]         }, condition = base::local({
[18:02:01.008]             c <- base::c
[18:02:01.008]             inherits <- base::inherits
[18:02:01.008]             invokeRestart <- base::invokeRestart
[18:02:01.008]             length <- base::length
[18:02:01.008]             list <- base::list
[18:02:01.008]             seq.int <- base::seq.int
[18:02:01.008]             signalCondition <- base::signalCondition
[18:02:01.008]             sys.calls <- base::sys.calls
[18:02:01.008]             `[[` <- base::`[[`
[18:02:01.008]             `+` <- base::`+`
[18:02:01.008]             `<<-` <- base::`<<-`
[18:02:01.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:01.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:01.008]                   3L)]
[18:02:01.008]             }
[18:02:01.008]             function(cond) {
[18:02:01.008]                 is_error <- inherits(cond, "error")
[18:02:01.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:01.008]                   NULL)
[18:02:01.008]                 if (is_error) {
[18:02:01.008]                   sessionInformation <- function() {
[18:02:01.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:01.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:01.008]                       search = base::search(), system = base::Sys.info())
[18:02:01.008]                   }
[18:02:01.008]                   ...future.conditions[[length(...future.conditions) + 
[18:02:01.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:01.008]                     cond$call), session = sessionInformation(), 
[18:02:01.008]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:01.008]                   signalCondition(cond)
[18:02:01.008]                 }
[18:02:01.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:01.008]                 "immediateCondition"))) {
[18:02:01.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:01.008]                   ...future.conditions[[length(...future.conditions) + 
[18:02:01.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:01.008]                   if (TRUE && !signal) {
[18:02:01.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:01.008]                     {
[18:02:01.008]                       inherits <- base::inherits
[18:02:01.008]                       invokeRestart <- base::invokeRestart
[18:02:01.008]                       is.null <- base::is.null
[18:02:01.008]                       muffled <- FALSE
[18:02:01.008]                       if (inherits(cond, "message")) {
[18:02:01.008]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:01.008]                         if (muffled) 
[18:02:01.008]                           invokeRestart("muffleMessage")
[18:02:01.008]                       }
[18:02:01.008]                       else if (inherits(cond, "warning")) {
[18:02:01.008]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:01.008]                         if (muffled) 
[18:02:01.008]                           invokeRestart("muffleWarning")
[18:02:01.008]                       }
[18:02:01.008]                       else if (inherits(cond, "condition")) {
[18:02:01.008]                         if (!is.null(pattern)) {
[18:02:01.008]                           computeRestarts <- base::computeRestarts
[18:02:01.008]                           grepl <- base::grepl
[18:02:01.008]                           restarts <- computeRestarts(cond)
[18:02:01.008]                           for (restart in restarts) {
[18:02:01.008]                             name <- restart$name
[18:02:01.008]                             if (is.null(name)) 
[18:02:01.008]                               next
[18:02:01.008]                             if (!grepl(pattern, name)) 
[18:02:01.008]                               next
[18:02:01.008]                             invokeRestart(restart)
[18:02:01.008]                             muffled <- TRUE
[18:02:01.008]                             break
[18:02:01.008]                           }
[18:02:01.008]                         }
[18:02:01.008]                       }
[18:02:01.008]                       invisible(muffled)
[18:02:01.008]                     }
[18:02:01.008]                     muffleCondition(cond, pattern = "^muffle")
[18:02:01.008]                   }
[18:02:01.008]                 }
[18:02:01.008]                 else {
[18:02:01.008]                   if (TRUE) {
[18:02:01.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:01.008]                     {
[18:02:01.008]                       inherits <- base::inherits
[18:02:01.008]                       invokeRestart <- base::invokeRestart
[18:02:01.008]                       is.null <- base::is.null
[18:02:01.008]                       muffled <- FALSE
[18:02:01.008]                       if (inherits(cond, "message")) {
[18:02:01.008]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:01.008]                         if (muffled) 
[18:02:01.008]                           invokeRestart("muffleMessage")
[18:02:01.008]                       }
[18:02:01.008]                       else if (inherits(cond, "warning")) {
[18:02:01.008]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:01.008]                         if (muffled) 
[18:02:01.008]                           invokeRestart("muffleWarning")
[18:02:01.008]                       }
[18:02:01.008]                       else if (inherits(cond, "condition")) {
[18:02:01.008]                         if (!is.null(pattern)) {
[18:02:01.008]                           computeRestarts <- base::computeRestarts
[18:02:01.008]                           grepl <- base::grepl
[18:02:01.008]                           restarts <- computeRestarts(cond)
[18:02:01.008]                           for (restart in restarts) {
[18:02:01.008]                             name <- restart$name
[18:02:01.008]                             if (is.null(name)) 
[18:02:01.008]                               next
[18:02:01.008]                             if (!grepl(pattern, name)) 
[18:02:01.008]                               next
[18:02:01.008]                             invokeRestart(restart)
[18:02:01.008]                             muffled <- TRUE
[18:02:01.008]                             break
[18:02:01.008]                           }
[18:02:01.008]                         }
[18:02:01.008]                       }
[18:02:01.008]                       invisible(muffled)
[18:02:01.008]                     }
[18:02:01.008]                     muffleCondition(cond, pattern = "^muffle")
[18:02:01.008]                   }
[18:02:01.008]                 }
[18:02:01.008]             }
[18:02:01.008]         }))
[18:02:01.008]     }, error = function(ex) {
[18:02:01.008]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:01.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:01.008]                 ...future.rng), started = ...future.startTime, 
[18:02:01.008]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:01.008]             version = "1.8"), class = "FutureResult")
[18:02:01.008]     }, finally = {
[18:02:01.008]         if (!identical(...future.workdir, getwd())) 
[18:02:01.008]             setwd(...future.workdir)
[18:02:01.008]         {
[18:02:01.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:01.008]                 ...future.oldOptions$nwarnings <- NULL
[18:02:01.008]             }
[18:02:01.008]             base::options(...future.oldOptions)
[18:02:01.008]             if (.Platform$OS.type == "windows") {
[18:02:01.008]                 old_names <- names(...future.oldEnvVars)
[18:02:01.008]                 envs <- base::Sys.getenv()
[18:02:01.008]                 names <- names(envs)
[18:02:01.008]                 common <- intersect(names, old_names)
[18:02:01.008]                 added <- setdiff(names, old_names)
[18:02:01.008]                 removed <- setdiff(old_names, names)
[18:02:01.008]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:01.008]                   envs[common]]
[18:02:01.008]                 NAMES <- toupper(changed)
[18:02:01.008]                 args <- list()
[18:02:01.008]                 for (kk in seq_along(NAMES)) {
[18:02:01.008]                   name <- changed[[kk]]
[18:02:01.008]                   NAME <- NAMES[[kk]]
[18:02:01.008]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:01.008]                     next
[18:02:01.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:01.008]                 }
[18:02:01.008]                 NAMES <- toupper(added)
[18:02:01.008]                 for (kk in seq_along(NAMES)) {
[18:02:01.008]                   name <- added[[kk]]
[18:02:01.008]                   NAME <- NAMES[[kk]]
[18:02:01.008]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:01.008]                     next
[18:02:01.008]                   args[[name]] <- ""
[18:02:01.008]                 }
[18:02:01.008]                 NAMES <- toupper(removed)
[18:02:01.008]                 for (kk in seq_along(NAMES)) {
[18:02:01.008]                   name <- removed[[kk]]
[18:02:01.008]                   NAME <- NAMES[[kk]]
[18:02:01.008]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:01.008]                     next
[18:02:01.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:01.008]                 }
[18:02:01.008]                 if (length(args) > 0) 
[18:02:01.008]                   base::do.call(base::Sys.setenv, args = args)
[18:02:01.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:01.008]             }
[18:02:01.008]             else {
[18:02:01.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:01.008]             }
[18:02:01.008]             {
[18:02:01.008]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:01.008]                   0L) {
[18:02:01.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:01.008]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:01.008]                   base::options(opts)
[18:02:01.008]                 }
[18:02:01.008]                 {
[18:02:01.008]                   {
[18:02:01.008]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:01.008]                     NULL
[18:02:01.008]                   }
[18:02:01.008]                   options(future.plan = NULL)
[18:02:01.008]                   if (is.na(NA_character_)) 
[18:02:01.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:01.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:01.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:01.008]                     .init = FALSE)
[18:02:01.008]                 }
[18:02:01.008]             }
[18:02:01.008]         }
[18:02:01.008]     })
[18:02:01.008]     if (TRUE) {
[18:02:01.008]         base::sink(type = "output", split = FALSE)
[18:02:01.008]         if (TRUE) {
[18:02:01.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:01.008]         }
[18:02:01.008]         else {
[18:02:01.008]             ...future.result["stdout"] <- base::list(NULL)
[18:02:01.008]         }
[18:02:01.008]         base::close(...future.stdout)
[18:02:01.008]         ...future.stdout <- NULL
[18:02:01.008]     }
[18:02:01.008]     ...future.result$conditions <- ...future.conditions
[18:02:01.008]     ...future.result$finished <- base::Sys.time()
[18:02:01.008]     ...future.result
[18:02:01.008] }
[18:02:01.013] assign_globals() ...
[18:02:01.013] List of 11
[18:02:01.013]  $ ...future.FUN            :function (x, ...)  
[18:02:01.013]  $ x_FUN                    :function (x)  
[18:02:01.013]  $ times                    : int 2
[18:02:01.013]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:01.013]  $ stop_if_not              :function (...)  
[18:02:01.013]  $ dim                      : NULL
[18:02:01.013]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:02:01.013]  $ future.call.arguments    : list()
[18:02:01.013]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:01.013]  $ ...future.elements_ii    :List of 1
[18:02:01.013]   ..$ : int 1
[18:02:01.013]  $ ...future.seeds_ii       : NULL
[18:02:01.013]  $ ...future.globals.maxSize: NULL
[18:02:01.013]  - attr(*, "where")=List of 11
[18:02:01.013]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:01.013]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:02:01.013]   ..$ times                    :<environment: R_EmptyEnv> 
[18:02:01.013]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:02:01.013]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:02:01.013]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:02:01.013]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:02:01.013]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:01.013]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:01.013]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:01.013]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:01.013]  - attr(*, "resolved")= logi FALSE
[18:02:01.013]  - attr(*, "total_size")= num 95128
[18:02:01.013]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:01.013]  - attr(*, "already-done")= logi TRUE
[18:02:01.034] - copied ‘...future.FUN’ to environment
[18:02:01.034] - copied ‘x_FUN’ to environment
[18:02:01.035] - copied ‘times’ to environment
[18:02:01.035] - copied ‘stopf’ to environment
[18:02:01.035] - copied ‘stop_if_not’ to environment
[18:02:01.035] - copied ‘dim’ to environment
[18:02:01.035] - copied ‘valid_types’ to environment
[18:02:01.036] - copied ‘future.call.arguments’ to environment
[18:02:01.036] - copied ‘...future.elements_ii’ to environment
[18:02:01.036] - copied ‘...future.seeds_ii’ to environment
[18:02:01.036] - copied ‘...future.globals.maxSize’ to environment
[18:02:01.036] assign_globals() ... done
[18:02:01.037] requestCore(): workers = 2
[18:02:01.040] MulticoreFuture started
[18:02:01.041] - Launch lazy future ... done
[18:02:01.042] run() for ‘MulticoreFuture’ ... done
[18:02:01.043] Created future:
[18:02:01.043] plan(): Setting new future strategy stack:
[18:02:01.044] List of future strategies:
[18:02:01.044] 1. sequential:
[18:02:01.044]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:01.044]    - tweaked: FALSE
[18:02:01.044]    - call: NULL
[18:02:01.046] plan(): nbrOfWorkers() = 1
[18:02:01.053] plan(): Setting new future strategy stack:
[18:02:01.053] List of future strategies:
[18:02:01.053] 1. multicore:
[18:02:01.053]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:01.053]    - tweaked: FALSE
[18:02:01.053]    - call: plan(strategy)
[18:02:01.043] MulticoreFuture:
[18:02:01.043] Label: ‘future_vapply-1’
[18:02:01.043] Expression:
[18:02:01.043] {
[18:02:01.043]     do.call(function(...) {
[18:02:01.043]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:01.043]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:01.043]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:01.043]             on.exit(options(oopts), add = TRUE)
[18:02:01.043]         }
[18:02:01.043]         {
[18:02:01.043]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:01.043]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:01.043]                 ...future.FUN(...future.X_jj, ...)
[18:02:01.043]             })
[18:02:01.043]         }
[18:02:01.043]     }, args = future.call.arguments)
[18:02:01.043] }
[18:02:01.043] Lazy evaluation: FALSE
[18:02:01.043] Asynchronous evaluation: TRUE
[18:02:01.043] Local evaluation: TRUE
[18:02:01.043] Environment: R_GlobalEnv
[18:02:01.043] Capture standard output: TRUE
[18:02:01.043] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:01.043] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:01.043] Packages: 1 packages (‘future.apply’)
[18:02:01.043] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:01.043] Resolved: FALSE
[18:02:01.043] Value: <not collected>
[18:02:01.043] Conditions captured: <none>
[18:02:01.043] Early signaling: FALSE
[18:02:01.043] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:01.043] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:01.062] Chunk #1 of 2 ... DONE
[18:02:01.064] Chunk #2 of 2 ...
[18:02:01.065]  - Finding globals in 'X' for chunk #2 ...
[18:02:01.066] getGlobalsAndPackages() ...
[18:02:01.066] Searching for globals...
[18:02:01.069] plan(): nbrOfWorkers() = 2
[18:02:01.068] 
[18:02:01.071] Searching for globals ... DONE
[18:02:01.071] - globals: [0] <none>
[18:02:01.072] getGlobalsAndPackages() ... DONE
[18:02:01.072]    + additional globals found: [n=0] 
[18:02:01.072]    + additional namespaces needed: [n=0] 
[18:02:01.073]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:01.073]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:01.073]  - seeds: <none>
[18:02:01.073]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:01.076] getGlobalsAndPackages() ...
[18:02:01.076] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:01.077] Resolving globals: FALSE
[18:02:01.077] Tweak future expression to call with '...' arguments ...
[18:02:01.077] {
[18:02:01.077]     do.call(function(...) {
[18:02:01.077]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:01.077]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:01.077]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:01.077]             on.exit(options(oopts), add = TRUE)
[18:02:01.077]         }
[18:02:01.077]         {
[18:02:01.077]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:01.077]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:01.077]                 ...future.FUN(...future.X_jj, ...)
[18:02:01.077]             })
[18:02:01.077]         }
[18:02:01.077]     }, args = future.call.arguments)
[18:02:01.077] }
[18:02:01.080] Tweak future expression to call with '...' arguments ... DONE
[18:02:01.083] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:01.083] - packages: [1] ‘future.apply’
[18:02:01.083] getGlobalsAndPackages() ... DONE
[18:02:01.084] run() for ‘Future’ ...
[18:02:01.085] - state: ‘created’
[18:02:01.085] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:01.093] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:01.093] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:01.094]   - Field: ‘label’
[18:02:01.094]   - Field: ‘local’
[18:02:01.095]   - Field: ‘owner’
[18:02:01.095]   - Field: ‘envir’
[18:02:01.095]   - Field: ‘workers’
[18:02:01.095]   - Field: ‘packages’
[18:02:01.096]   - Field: ‘gc’
[18:02:01.096]   - Field: ‘job’
[18:02:01.096]   - Field: ‘conditions’
[18:02:01.097]   - Field: ‘expr’
[18:02:01.097]   - Field: ‘uuid’
[18:02:01.097]   - Field: ‘seed’
[18:02:01.098]   - Field: ‘version’
[18:02:01.098]   - Field: ‘result’
[18:02:01.098]   - Field: ‘asynchronous’
[18:02:01.099]   - Field: ‘calls’
[18:02:01.099]   - Field: ‘globals’
[18:02:01.099]   - Field: ‘stdout’
[18:02:01.100]   - Field: ‘earlySignal’
[18:02:01.100]   - Field: ‘lazy’
[18:02:01.100]   - Field: ‘state’
[18:02:01.101] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:01.101] - Launch lazy future ...
[18:02:01.102] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:01.102] Packages needed by future strategies (n = 0): <none>
[18:02:01.104] {
[18:02:01.104]     {
[18:02:01.104]         {
[18:02:01.104]             ...future.startTime <- base::Sys.time()
[18:02:01.104]             {
[18:02:01.104]                 {
[18:02:01.104]                   {
[18:02:01.104]                     {
[18:02:01.104]                       {
[18:02:01.104]                         base::local({
[18:02:01.104]                           has_future <- base::requireNamespace("future", 
[18:02:01.104]                             quietly = TRUE)
[18:02:01.104]                           if (has_future) {
[18:02:01.104]                             ns <- base::getNamespace("future")
[18:02:01.104]                             version <- ns[[".package"]][["version"]]
[18:02:01.104]                             if (is.null(version)) 
[18:02:01.104]                               version <- utils::packageVersion("future")
[18:02:01.104]                           }
[18:02:01.104]                           else {
[18:02:01.104]                             version <- NULL
[18:02:01.104]                           }
[18:02:01.104]                           if (!has_future || version < "1.8.0") {
[18:02:01.104]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:01.104]                               "", base::R.version$version.string), 
[18:02:01.104]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:01.104]                                 base::R.version$platform, 8 * 
[18:02:01.104]                                   base::.Machine$sizeof.pointer), 
[18:02:01.104]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:01.104]                                 "release", "version")], collapse = " "), 
[18:02:01.104]                               hostname = base::Sys.info()[["nodename"]])
[18:02:01.104]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:01.104]                               info)
[18:02:01.104]                             info <- base::paste(info, collapse = "; ")
[18:02:01.104]                             if (!has_future) {
[18:02:01.104]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:01.104]                                 info)
[18:02:01.104]                             }
[18:02:01.104]                             else {
[18:02:01.104]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:01.104]                                 info, version)
[18:02:01.104]                             }
[18:02:01.104]                             base::stop(msg)
[18:02:01.104]                           }
[18:02:01.104]                         })
[18:02:01.104]                       }
[18:02:01.104]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:01.104]                       base::options(mc.cores = 1L)
[18:02:01.104]                     }
[18:02:01.104]                     base::local({
[18:02:01.104]                       for (pkg in "future.apply") {
[18:02:01.104]                         base::loadNamespace(pkg)
[18:02:01.104]                         base::library(pkg, character.only = TRUE)
[18:02:01.104]                       }
[18:02:01.104]                     })
[18:02:01.104]                   }
[18:02:01.104]                   ...future.strategy.old <- future::plan("list")
[18:02:01.104]                   options(future.plan = NULL)
[18:02:01.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:01.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:01.104]                 }
[18:02:01.104]                 ...future.workdir <- getwd()
[18:02:01.104]             }
[18:02:01.104]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:01.104]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:01.104]         }
[18:02:01.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:01.104]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:01.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:01.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:01.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:01.104]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:01.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:01.104]             base::names(...future.oldOptions))
[18:02:01.104]     }
[18:02:01.104]     if (FALSE) {
[18:02:01.104]     }
[18:02:01.104]     else {
[18:02:01.104]         if (TRUE) {
[18:02:01.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:01.104]                 open = "w")
[18:02:01.104]         }
[18:02:01.104]         else {
[18:02:01.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:01.104]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:01.104]         }
[18:02:01.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:01.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:01.104]             base::sink(type = "output", split = FALSE)
[18:02:01.104]             base::close(...future.stdout)
[18:02:01.104]         }, add = TRUE)
[18:02:01.104]     }
[18:02:01.104]     ...future.frame <- base::sys.nframe()
[18:02:01.104]     ...future.conditions <- base::list()
[18:02:01.104]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:01.104]     if (FALSE) {
[18:02:01.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:01.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:01.104]     }
[18:02:01.104]     ...future.result <- base::tryCatch({
[18:02:01.104]         base::withCallingHandlers({
[18:02:01.104]             ...future.value <- base::withVisible(base::local({
[18:02:01.104]                 withCallingHandlers({
[18:02:01.104]                   {
[18:02:01.104]                     do.call(function(...) {
[18:02:01.104]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:01.104]                       if (!identical(...future.globals.maxSize.org, 
[18:02:01.104]                         ...future.globals.maxSize)) {
[18:02:01.104]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:01.104]                         on.exit(options(oopts), add = TRUE)
[18:02:01.104]                       }
[18:02:01.104]                       {
[18:02:01.104]                         lapply(seq_along(...future.elements_ii), 
[18:02:01.104]                           FUN = function(jj) {
[18:02:01.104]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:01.104]                             ...future.FUN(...future.X_jj, ...)
[18:02:01.104]                           })
[18:02:01.104]                       }
[18:02:01.104]                     }, args = future.call.arguments)
[18:02:01.104]                   }
[18:02:01.104]                 }, immediateCondition = function(cond) {
[18:02:01.104]                   save_rds <- function (object, pathname, ...) 
[18:02:01.104]                   {
[18:02:01.104]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:01.104]                     if (file_test("-f", pathname_tmp)) {
[18:02:01.104]                       fi_tmp <- file.info(pathname_tmp)
[18:02:01.104]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:01.104]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:01.104]                         fi_tmp[["mtime"]])
[18:02:01.104]                     }
[18:02:01.104]                     tryCatch({
[18:02:01.104]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:01.104]                     }, error = function(ex) {
[18:02:01.104]                       msg <- conditionMessage(ex)
[18:02:01.104]                       fi_tmp <- file.info(pathname_tmp)
[18:02:01.104]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:01.104]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:01.104]                         fi_tmp[["mtime"]], msg)
[18:02:01.104]                       ex$message <- msg
[18:02:01.104]                       stop(ex)
[18:02:01.104]                     })
[18:02:01.104]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:01.104]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:01.104]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:01.104]                       fi_tmp <- file.info(pathname_tmp)
[18:02:01.104]                       fi <- file.info(pathname)
[18:02:01.104]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:01.104]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:01.104]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:01.104]                         fi[["size"]], fi[["mtime"]])
[18:02:01.104]                       stop(msg)
[18:02:01.104]                     }
[18:02:01.104]                     invisible(pathname)
[18:02:01.104]                   }
[18:02:01.104]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:01.104]                     rootPath = tempdir()) 
[18:02:01.104]                   {
[18:02:01.104]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:01.104]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:01.104]                       tmpdir = path, fileext = ".rds")
[18:02:01.104]                     save_rds(obj, file)
[18:02:01.104]                   }
[18:02:01.104]                   saveImmediateCondition(cond, path = "/tmp/RtmpINx3OL/.future/immediateConditions")
[18:02:01.104]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:01.104]                   {
[18:02:01.104]                     inherits <- base::inherits
[18:02:01.104]                     invokeRestart <- base::invokeRestart
[18:02:01.104]                     is.null <- base::is.null
[18:02:01.104]                     muffled <- FALSE
[18:02:01.104]                     if (inherits(cond, "message")) {
[18:02:01.104]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:01.104]                       if (muffled) 
[18:02:01.104]                         invokeRestart("muffleMessage")
[18:02:01.104]                     }
[18:02:01.104]                     else if (inherits(cond, "warning")) {
[18:02:01.104]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:01.104]                       if (muffled) 
[18:02:01.104]                         invokeRestart("muffleWarning")
[18:02:01.104]                     }
[18:02:01.104]                     else if (inherits(cond, "condition")) {
[18:02:01.104]                       if (!is.null(pattern)) {
[18:02:01.104]                         computeRestarts <- base::computeRestarts
[18:02:01.104]                         grepl <- base::grepl
[18:02:01.104]                         restarts <- computeRestarts(cond)
[18:02:01.104]                         for (restart in restarts) {
[18:02:01.104]                           name <- restart$name
[18:02:01.104]                           if (is.null(name)) 
[18:02:01.104]                             next
[18:02:01.104]                           if (!grepl(pattern, name)) 
[18:02:01.104]                             next
[18:02:01.104]                           invokeRestart(restart)
[18:02:01.104]                           muffled <- TRUE
[18:02:01.104]                           break
[18:02:01.104]                         }
[18:02:01.104]                       }
[18:02:01.104]                     }
[18:02:01.104]                     invisible(muffled)
[18:02:01.104]                   }
[18:02:01.104]                   muffleCondition(cond)
[18:02:01.104]                 })
[18:02:01.104]             }))
[18:02:01.104]             future::FutureResult(value = ...future.value$value, 
[18:02:01.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:01.104]                   ...future.rng), globalenv = if (FALSE) 
[18:02:01.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:01.104]                     ...future.globalenv.names))
[18:02:01.104]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:01.104]         }, condition = base::local({
[18:02:01.104]             c <- base::c
[18:02:01.104]             inherits <- base::inherits
[18:02:01.104]             invokeRestart <- base::invokeRestart
[18:02:01.104]             length <- base::length
[18:02:01.104]             list <- base::list
[18:02:01.104]             seq.int <- base::seq.int
[18:02:01.104]             signalCondition <- base::signalCondition
[18:02:01.104]             sys.calls <- base::sys.calls
[18:02:01.104]             `[[` <- base::`[[`
[18:02:01.104]             `+` <- base::`+`
[18:02:01.104]             `<<-` <- base::`<<-`
[18:02:01.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:01.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:01.104]                   3L)]
[18:02:01.104]             }
[18:02:01.104]             function(cond) {
[18:02:01.104]                 is_error <- inherits(cond, "error")
[18:02:01.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:01.104]                   NULL)
[18:02:01.104]                 if (is_error) {
[18:02:01.104]                   sessionInformation <- function() {
[18:02:01.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:01.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:01.104]                       search = base::search(), system = base::Sys.info())
[18:02:01.104]                   }
[18:02:01.104]                   ...future.conditions[[length(...future.conditions) + 
[18:02:01.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:01.104]                     cond$call), session = sessionInformation(), 
[18:02:01.104]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:01.104]                   signalCondition(cond)
[18:02:01.104]                 }
[18:02:01.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:01.104]                 "immediateCondition"))) {
[18:02:01.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:01.104]                   ...future.conditions[[length(...future.conditions) + 
[18:02:01.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:01.104]                   if (TRUE && !signal) {
[18:02:01.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:01.104]                     {
[18:02:01.104]                       inherits <- base::inherits
[18:02:01.104]                       invokeRestart <- base::invokeRestart
[18:02:01.104]                       is.null <- base::is.null
[18:02:01.104]                       muffled <- FALSE
[18:02:01.104]                       if (inherits(cond, "message")) {
[18:02:01.104]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:01.104]                         if (muffled) 
[18:02:01.104]                           invokeRestart("muffleMessage")
[18:02:01.104]                       }
[18:02:01.104]                       else if (inherits(cond, "warning")) {
[18:02:01.104]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:01.104]                         if (muffled) 
[18:02:01.104]                           invokeRestart("muffleWarning")
[18:02:01.104]                       }
[18:02:01.104]                       else if (inherits(cond, "condition")) {
[18:02:01.104]                         if (!is.null(pattern)) {
[18:02:01.104]                           computeRestarts <- base::computeRestarts
[18:02:01.104]                           grepl <- base::grepl
[18:02:01.104]                           restarts <- computeRestarts(cond)
[18:02:01.104]                           for (restart in restarts) {
[18:02:01.104]                             name <- restart$name
[18:02:01.104]                             if (is.null(name)) 
[18:02:01.104]                               next
[18:02:01.104]                             if (!grepl(pattern, name)) 
[18:02:01.104]                               next
[18:02:01.104]                             invokeRestart(restart)
[18:02:01.104]                             muffled <- TRUE
[18:02:01.104]                             break
[18:02:01.104]                           }
[18:02:01.104]                         }
[18:02:01.104]                       }
[18:02:01.104]                       invisible(muffled)
[18:02:01.104]                     }
[18:02:01.104]                     muffleCondition(cond, pattern = "^muffle")
[18:02:01.104]                   }
[18:02:01.104]                 }
[18:02:01.104]                 else {
[18:02:01.104]                   if (TRUE) {
[18:02:01.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:01.104]                     {
[18:02:01.104]                       inherits <- base::inherits
[18:02:01.104]                       invokeRestart <- base::invokeRestart
[18:02:01.104]                       is.null <- base::is.null
[18:02:01.104]                       muffled <- FALSE
[18:02:01.104]                       if (inherits(cond, "message")) {
[18:02:01.104]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:01.104]                         if (muffled) 
[18:02:01.104]                           invokeRestart("muffleMessage")
[18:02:01.104]                       }
[18:02:01.104]                       else if (inherits(cond, "warning")) {
[18:02:01.104]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:01.104]                         if (muffled) 
[18:02:01.104]                           invokeRestart("muffleWarning")
[18:02:01.104]                       }
[18:02:01.104]                       else if (inherits(cond, "condition")) {
[18:02:01.104]                         if (!is.null(pattern)) {
[18:02:01.104]                           computeRestarts <- base::computeRestarts
[18:02:01.104]                           grepl <- base::grepl
[18:02:01.104]                           restarts <- computeRestarts(cond)
[18:02:01.104]                           for (restart in restarts) {
[18:02:01.104]                             name <- restart$name
[18:02:01.104]                             if (is.null(name)) 
[18:02:01.104]                               next
[18:02:01.104]                             if (!grepl(pattern, name)) 
[18:02:01.104]                               next
[18:02:01.104]                             invokeRestart(restart)
[18:02:01.104]                             muffled <- TRUE
[18:02:01.104]                             break
[18:02:01.104]                           }
[18:02:01.104]                         }
[18:02:01.104]                       }
[18:02:01.104]                       invisible(muffled)
[18:02:01.104]                     }
[18:02:01.104]                     muffleCondition(cond, pattern = "^muffle")
[18:02:01.104]                   }
[18:02:01.104]                 }
[18:02:01.104]             }
[18:02:01.104]         }))
[18:02:01.104]     }, error = function(ex) {
[18:02:01.104]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:01.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:01.104]                 ...future.rng), started = ...future.startTime, 
[18:02:01.104]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:01.104]             version = "1.8"), class = "FutureResult")
[18:02:01.104]     }, finally = {
[18:02:01.104]         if (!identical(...future.workdir, getwd())) 
[18:02:01.104]             setwd(...future.workdir)
[18:02:01.104]         {
[18:02:01.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:01.104]                 ...future.oldOptions$nwarnings <- NULL
[18:02:01.104]             }
[18:02:01.104]             base::options(...future.oldOptions)
[18:02:01.104]             if (.Platform$OS.type == "windows") {
[18:02:01.104]                 old_names <- names(...future.oldEnvVars)
[18:02:01.104]                 envs <- base::Sys.getenv()
[18:02:01.104]                 names <- names(envs)
[18:02:01.104]                 common <- intersect(names, old_names)
[18:02:01.104]                 added <- setdiff(names, old_names)
[18:02:01.104]                 removed <- setdiff(old_names, names)
[18:02:01.104]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:01.104]                   envs[common]]
[18:02:01.104]                 NAMES <- toupper(changed)
[18:02:01.104]                 args <- list()
[18:02:01.104]                 for (kk in seq_along(NAMES)) {
[18:02:01.104]                   name <- changed[[kk]]
[18:02:01.104]                   NAME <- NAMES[[kk]]
[18:02:01.104]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:01.104]                     next
[18:02:01.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:01.104]                 }
[18:02:01.104]                 NAMES <- toupper(added)
[18:02:01.104]                 for (kk in seq_along(NAMES)) {
[18:02:01.104]                   name <- added[[kk]]
[18:02:01.104]                   NAME <- NAMES[[kk]]
[18:02:01.104]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:01.104]                     next
[18:02:01.104]                   args[[name]] <- ""
[18:02:01.104]                 }
[18:02:01.104]                 NAMES <- toupper(removed)
[18:02:01.104]                 for (kk in seq_along(NAMES)) {
[18:02:01.104]                   name <- removed[[kk]]
[18:02:01.104]                   NAME <- NAMES[[kk]]
[18:02:01.104]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:01.104]                     next
[18:02:01.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:01.104]                 }
[18:02:01.104]                 if (length(args) > 0) 
[18:02:01.104]                   base::do.call(base::Sys.setenv, args = args)
[18:02:01.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:01.104]             }
[18:02:01.104]             else {
[18:02:01.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:01.104]             }
[18:02:01.104]             {
[18:02:01.104]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:01.104]                   0L) {
[18:02:01.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:01.104]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:01.104]                   base::options(opts)
[18:02:01.104]                 }
[18:02:01.104]                 {
[18:02:01.104]                   {
[18:02:01.104]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:01.104]                     NULL
[18:02:01.104]                   }
[18:02:01.104]                   options(future.plan = NULL)
[18:02:01.104]                   if (is.na(NA_character_)) 
[18:02:01.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:01.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:01.104]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:01.104]                     .init = FALSE)
[18:02:01.104]                 }
[18:02:01.104]             }
[18:02:01.104]         }
[18:02:01.104]     })
[18:02:01.104]     if (TRUE) {
[18:02:01.104]         base::sink(type = "output", split = FALSE)
[18:02:01.104]         if (TRUE) {
[18:02:01.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:01.104]         }
[18:02:01.104]         else {
[18:02:01.104]             ...future.result["stdout"] <- base::list(NULL)
[18:02:01.104]         }
[18:02:01.104]         base::close(...future.stdout)
[18:02:01.104]         ...future.stdout <- NULL
[18:02:01.104]     }
[18:02:01.104]     ...future.result$conditions <- ...future.conditions
[18:02:01.104]     ...future.result$finished <- base::Sys.time()
[18:02:01.104]     ...future.result
[18:02:01.104] }
[18:02:01.111] assign_globals() ...
[18:02:01.111] List of 11
[18:02:01.111]  $ ...future.FUN            :function (x, ...)  
[18:02:01.111]  $ x_FUN                    :function (x)  
[18:02:01.111]  $ times                    : int 2
[18:02:01.111]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:01.111]  $ stop_if_not              :function (...)  
[18:02:01.111]  $ dim                      : NULL
[18:02:01.111]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[18:02:01.111]  $ future.call.arguments    : list()
[18:02:01.111]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:01.111]  $ ...future.elements_ii    :List of 2
[18:02:01.111]   ..$ : int 2
[18:02:01.111]   ..$ : int 3
[18:02:01.111]  $ ...future.seeds_ii       : NULL
[18:02:01.111]  $ ...future.globals.maxSize: NULL
[18:02:01.111]  - attr(*, "where")=List of 11
[18:02:01.111]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:01.111]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[18:02:01.111]   ..$ times                    :<environment: R_EmptyEnv> 
[18:02:01.111]   ..$ stopf                    :<environment: R_EmptyEnv> 
[18:02:01.111]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[18:02:01.111]   ..$ dim                      :<environment: R_EmptyEnv> 
[18:02:01.111]   ..$ valid_types              :<environment: R_EmptyEnv> 
[18:02:01.111]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:01.111]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:01.111]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:01.111]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:01.111]  - attr(*, "resolved")= logi FALSE
[18:02:01.111]  - attr(*, "total_size")= num 95128
[18:02:01.111]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:01.111]  - attr(*, "already-done")= logi TRUE
[18:02:01.142] - copied ‘...future.FUN’ to environment
[18:02:01.142] - copied ‘x_FUN’ to environment
[18:02:01.143] - copied ‘times’ to environment
[18:02:01.143] - copied ‘stopf’ to environment
[18:02:01.143] - copied ‘stop_if_not’ to environment
[18:02:01.144] - copied ‘dim’ to environment
[18:02:01.144] - copied ‘valid_types’ to environment
[18:02:01.144] - copied ‘future.call.arguments’ to environment
[18:02:01.144] - copied ‘...future.elements_ii’ to environment
[18:02:01.144] - copied ‘...future.seeds_ii’ to environment
[18:02:01.145] - copied ‘...future.globals.maxSize’ to environment
[18:02:01.145] assign_globals() ... done
[18:02:01.145] requestCore(): workers = 2
[18:02:01.149] MulticoreFuture started
[18:02:01.150] - Launch lazy future ... done
[18:02:01.150] run() for ‘MulticoreFuture’ ... done
[18:02:01.151] Created future:
[18:02:01.152] plan(): Setting new future strategy stack:
[18:02:01.152] List of future strategies:
[18:02:01.152] 1. sequential:
[18:02:01.152]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:01.152]    - tweaked: FALSE
[18:02:01.152]    - call: NULL
[18:02:01.154] plan(): nbrOfWorkers() = 1
[18:02:01.159] plan(): Setting new future strategy stack:
[18:02:01.159] List of future strategies:
[18:02:01.159] 1. multicore:
[18:02:01.159]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:01.159]    - tweaked: FALSE
[18:02:01.159]    - call: plan(strategy)
[18:02:01.151] MulticoreFuture:
[18:02:01.151] Label: ‘future_vapply-2’
[18:02:01.151] Expression:
[18:02:01.151] {
[18:02:01.151]     do.call(function(...) {
[18:02:01.151]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:01.151]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:01.151]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:01.151]             on.exit(options(oopts), add = TRUE)
[18:02:01.151]         }
[18:02:01.151]         {
[18:02:01.151]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:01.151]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:01.151]                 ...future.FUN(...future.X_jj, ...)
[18:02:01.151]             })
[18:02:01.151]         }
[18:02:01.151]     }, args = future.call.arguments)
[18:02:01.151] }
[18:02:01.151] Lazy evaluation: FALSE
[18:02:01.151] Asynchronous evaluation: TRUE
[18:02:01.151] Local evaluation: TRUE
[18:02:01.151] Environment: R_GlobalEnv
[18:02:01.151] Capture standard output: TRUE
[18:02:01.151] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:01.151] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:01.151] Packages: 1 packages (‘future.apply’)
[18:02:01.151] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:01.151] Resolved: FALSE
[18:02:01.151] Value: <not collected>
[18:02:01.151] Conditions captured: <none>
[18:02:01.151] Early signaling: FALSE
[18:02:01.151] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:01.151] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:01.168] Chunk #2 of 2 ... DONE
[18:02:01.168] Launching 2 futures (chunks) ... DONE
[18:02:01.168] Resolving 2 futures (chunks) ...
[18:02:01.169] resolve() on list ...
[18:02:01.169]  recursive: 0
[18:02:01.169] plan(): nbrOfWorkers() = 2
[18:02:01.169]  length: 2
[18:02:01.169] 
[18:02:01.170] Future #1
[18:02:01.171] result() for MulticoreFuture ...
[18:02:01.183] result() for MulticoreFuture ...
[18:02:01.183] result() for MulticoreFuture ... done
[18:02:01.184] signalConditions() ...
[18:02:01.184]  - include = ‘immediateCondition’
[18:02:01.184]  - exclude = 
[18:02:01.185]  - resignal = FALSE
[18:02:01.185]  - Number of conditions: 1
[18:02:01.185] signalConditions() ... done
[18:02:01.186] result() for MulticoreFuture ... done
[18:02:01.186] result() for MulticoreFuture ...
[18:02:01.186] result() for MulticoreFuture ... done
[18:02:01.187] signalConditions() ...
[18:02:01.187]  - include = ‘immediateCondition’
[18:02:01.187]  - exclude = 
[18:02:01.188]  - resignal = FALSE
[18:02:01.188]  - Number of conditions: 1
[18:02:01.188] signalConditions() ... done
[18:02:01.189] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:02:01.189] - nx: 2
[18:02:01.189] - relay: TRUE
[18:02:01.190] - stdout: TRUE
[18:02:01.190] - signal: TRUE
[18:02:01.190] - resignal: FALSE
[18:02:01.190] - force: TRUE
[18:02:01.191] - relayed: [n=2] FALSE, FALSE
[18:02:01.191] - queued futures: [n=2] FALSE, FALSE
[18:02:01.191]  - until=1
[18:02:01.192]  - relaying element #1
[18:02:01.197] result() for MulticoreFuture ...
[18:02:01.198] result() for MulticoreFuture ... done
[18:02:01.198] result() for MulticoreFuture ...
[18:02:01.198] result() for MulticoreFuture ... done
[18:02:01.199] signalConditions() ...
[18:02:01.200]  - include = ‘immediateCondition’
[18:02:01.200]  - exclude = 
[18:02:01.200]  - resignal = FALSE
[18:02:01.201]  - Number of conditions: 1
[18:02:01.201] signalConditions() ... done
[18:02:01.202] result() for MulticoreFuture ...
[18:02:01.202] result() for MulticoreFuture ... done
[18:02:01.203] signalConditions() ...
[18:02:01.203]  - include = ‘immediateCondition’
[18:02:01.203]  - exclude = 
[18:02:01.204]  - resignal = FALSE
[18:02:01.204]  - Number of conditions: 1
[18:02:01.205] signalConditions() ... done
[18:02:01.205] result() for MulticoreFuture ...
[18:02:01.205] result() for MulticoreFuture ... done
[18:02:01.206] signalConditions() ...
[18:02:01.206]  - include = ‘condition’
[18:02:01.207]  - exclude = ‘immediateCondition’
[18:02:01.207]  - resignal = TRUE
[18:02:01.207]  - Number of conditions: 1
[18:02:01.208]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:02:01.208] signalConditions() ... done
[18:02:01.209] - relayed: [n=2] FALSE, FALSE
[18:02:01.209] - queued futures: [n=2] TRUE, FALSE
[18:02:01.210] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:02:01.210] plan(): Setting new future strategy stack:
[18:02:01.211] List of future strategies:
[18:02:01.211] 1. sequential:
[18:02:01.211]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:01.211]    - tweaked: FALSE
[18:02:01.211]    - call: plan(sequential)
[18:02:01.212] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[18:02:01.214] plan(): Setting new future strategy stack:
[18:02:01.214] List of future strategies:
[18:02:01.214] 1. multisession:
[18:02:01.214]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:02:01.214]    - tweaked: FALSE
[18:02:01.214]    - call: plan(strategy)
[18:02:01.216] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:02:01.216] multisession:
[18:02:01.216] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:02:01.216] - tweaked: FALSE
[18:02:01.216] - call: plan(strategy)
[18:02:01.229] getGlobalsAndPackages() ...
[18:02:01.229] Not searching for globals
[18:02:01.230] - globals: [0] <none>
[18:02:01.230] getGlobalsAndPackages() ... DONE
[18:02:01.231] [local output] makeClusterPSOCK() ...
[18:02:01.313] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:02:01.315] [local output] Base port: 11145
[18:02:01.315] [local output] Getting setup options for 2 cluster nodes ...
[18:02:01.316] [local output]  - Node 1 of 2 ...
[18:02:01.316] [local output] localMachine=TRUE => revtunnel=FALSE

[18:02:01.318] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpINx3OL/worker.rank=1.parallelly.parent=316666.4d4fa6a016a77.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpINx3OL/worker.rank=1.parallelly.parent=316666.4d4fa6a016a77.pid")'’
[18:02:01.598] - Possible to infer worker's PID: TRUE
[18:02:01.599] [local output] Rscript port: 11145

[18:02:01.599] [local output]  - Node 2 of 2 ...
[18:02:01.600] [local output] localMachine=TRUE => revtunnel=FALSE

[18:02:01.601] [local output] Rscript port: 11145

[18:02:01.602] [local output] Getting setup options for 2 cluster nodes ... done
[18:02:01.602] [local output]  - Parallel setup requested for some PSOCK nodes
[18:02:01.603] [local output] Setting up PSOCK nodes in parallel
[18:02:01.604] List of 36
[18:02:01.604]  $ worker          : chr "localhost"
[18:02:01.604]   ..- attr(*, "localhost")= logi TRUE
[18:02:01.604]  $ master          : chr "localhost"
[18:02:01.604]  $ port            : int 11145
[18:02:01.604]  $ connectTimeout  : num 120
[18:02:01.604]  $ timeout         : num 2592000
[18:02:01.604]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:02:01.604]  $ homogeneous     : logi TRUE
[18:02:01.604]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:02:01.604]  $ rscript_envs    : NULL
[18:02:01.604]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:02:01.604]  $ rscript_startup : NULL
[18:02:01.604]  $ rscript_sh      : chr "sh"
[18:02:01.604]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:02:01.604]  $ methods         : logi TRUE
[18:02:01.604]  $ socketOptions   : chr "no-delay"
[18:02:01.604]  $ useXDR          : logi FALSE
[18:02:01.604]  $ outfile         : chr "/dev/null"
[18:02:01.604]  $ renice          : int NA
[18:02:01.604]  $ rshcmd          : NULL
[18:02:01.604]  $ user            : chr(0) 
[18:02:01.604]  $ revtunnel       : logi FALSE
[18:02:01.604]  $ rshlogfile      : NULL
[18:02:01.604]  $ rshopts         : chr(0) 
[18:02:01.604]  $ rank            : int 1
[18:02:01.604]  $ manual          : logi FALSE
[18:02:01.604]  $ dryrun          : logi FALSE
[18:02:01.604]  $ quiet           : logi FALSE
[18:02:01.604]  $ setup_strategy  : chr "parallel"
[18:02:01.604]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:02:01.604]  $ pidfile         : chr "/tmp/RtmpINx3OL/worker.rank=1.parallelly.parent=316666.4d4fa6a016a77.pid"
[18:02:01.604]  $ rshcmd_label    : NULL
[18:02:01.604]  $ rsh_call        : NULL
[18:02:01.604]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:02:01.604]  $ localMachine    : logi TRUE
[18:02:01.604]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:02:01.604]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:02:01.604]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:02:01.604]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:02:01.604]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:02:01.604]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:02:01.604]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:02:01.604]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:02:01.604]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:02:01.604]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:02:01.604]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:02:01.604]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:02:01.604]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:02:01.604]  $ arguments       :List of 28
[18:02:01.604]   ..$ worker          : chr "localhost"
[18:02:01.604]   ..$ master          : NULL
[18:02:01.604]   ..$ port            : int 11145
[18:02:01.604]   ..$ connectTimeout  : num 120
[18:02:01.604]   ..$ timeout         : num 2592000
[18:02:01.604]   ..$ rscript         : NULL
[18:02:01.604]   ..$ homogeneous     : NULL
[18:02:01.604]   ..$ rscript_args    : NULL
[18:02:01.604]   ..$ rscript_envs    : NULL
[18:02:01.604]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:02:01.604]   ..$ rscript_startup : NULL
[18:02:01.604]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:02:01.604]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:02:01.604]   ..$ methods         : logi TRUE
[18:02:01.604]   ..$ socketOptions   : chr "no-delay"
[18:02:01.604]   ..$ useXDR          : logi FALSE
[18:02:01.604]   ..$ outfile         : chr "/dev/null"
[18:02:01.604]   ..$ renice          : int NA
[18:02:01.604]   ..$ rshcmd          : NULL
[18:02:01.604]   ..$ user            : NULL
[18:02:01.604]   ..$ revtunnel       : logi NA
[18:02:01.604]   ..$ rshlogfile      : NULL
[18:02:01.604]   ..$ rshopts         : NULL
[18:02:01.604]   ..$ rank            : int 1
[18:02:01.604]   ..$ manual          : logi FALSE
[18:02:01.604]   ..$ dryrun          : logi FALSE
[18:02:01.604]   ..$ quiet           : logi FALSE
[18:02:01.604]   ..$ setup_strategy  : chr "parallel"
[18:02:01.604]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:02:01.640] [local output] System call to launch all workers:
[18:02:01.640] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpINx3OL/worker.rank=1.parallelly.parent=316666.4d4fa6a016a77.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11145 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:02:01.640] [local output] Starting PSOCK main server
[18:02:01.649] [local output] Workers launched
[18:02:01.649] [local output] Waiting for workers to connect back
[18:02:01.650]  - [local output] 0 workers out of 2 ready
[18:02:02.005]  - [local output] 0 workers out of 2 ready
[18:02:02.005]  - [local output] 1 workers out of 2 ready
[18:02:02.014]  - [local output] 1 workers out of 2 ready
[18:02:02.015]  - [local output] 2 workers out of 2 ready
[18:02:02.015] [local output] Launching of workers completed
[18:02:02.015] [local output] Collecting session information from workers
[18:02:02.017] [local output]  - Worker #1 of 2
[18:02:02.018] [local output]  - Worker #2 of 2
[18:02:02.019] [local output] makeClusterPSOCK() ... done
[18:02:02.039] Packages needed by the future expression (n = 0): <none>
[18:02:02.039] Packages needed by future strategies (n = 0): <none>
[18:02:02.040] {
[18:02:02.040]     {
[18:02:02.040]         {
[18:02:02.040]             ...future.startTime <- base::Sys.time()
[18:02:02.040]             {
[18:02:02.040]                 {
[18:02:02.040]                   {
[18:02:02.040]                     {
[18:02:02.040]                       base::local({
[18:02:02.040]                         has_future <- base::requireNamespace("future", 
[18:02:02.040]                           quietly = TRUE)
[18:02:02.040]                         if (has_future) {
[18:02:02.040]                           ns <- base::getNamespace("future")
[18:02:02.040]                           version <- ns[[".package"]][["version"]]
[18:02:02.040]                           if (is.null(version)) 
[18:02:02.040]                             version <- utils::packageVersion("future")
[18:02:02.040]                         }
[18:02:02.040]                         else {
[18:02:02.040]                           version <- NULL
[18:02:02.040]                         }
[18:02:02.040]                         if (!has_future || version < "1.8.0") {
[18:02:02.040]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:02.040]                             "", base::R.version$version.string), 
[18:02:02.040]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:02.040]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:02.040]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:02.040]                               "release", "version")], collapse = " "), 
[18:02:02.040]                             hostname = base::Sys.info()[["nodename"]])
[18:02:02.040]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:02.040]                             info)
[18:02:02.040]                           info <- base::paste(info, collapse = "; ")
[18:02:02.040]                           if (!has_future) {
[18:02:02.040]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:02.040]                               info)
[18:02:02.040]                           }
[18:02:02.040]                           else {
[18:02:02.040]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:02.040]                               info, version)
[18:02:02.040]                           }
[18:02:02.040]                           base::stop(msg)
[18:02:02.040]                         }
[18:02:02.040]                       })
[18:02:02.040]                     }
[18:02:02.040]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:02.040]                     base::options(mc.cores = 1L)
[18:02:02.040]                   }
[18:02:02.040]                   ...future.strategy.old <- future::plan("list")
[18:02:02.040]                   options(future.plan = NULL)
[18:02:02.040]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:02.040]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:02.040]                 }
[18:02:02.040]                 ...future.workdir <- getwd()
[18:02:02.040]             }
[18:02:02.040]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:02.040]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:02.040]         }
[18:02:02.040]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:02.040]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:02.040]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:02.040]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:02.040]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:02.040]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:02.040]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:02.040]             base::names(...future.oldOptions))
[18:02:02.040]     }
[18:02:02.040]     if (FALSE) {
[18:02:02.040]     }
[18:02:02.040]     else {
[18:02:02.040]         if (TRUE) {
[18:02:02.040]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:02.040]                 open = "w")
[18:02:02.040]         }
[18:02:02.040]         else {
[18:02:02.040]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:02.040]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:02.040]         }
[18:02:02.040]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:02.040]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:02.040]             base::sink(type = "output", split = FALSE)
[18:02:02.040]             base::close(...future.stdout)
[18:02:02.040]         }, add = TRUE)
[18:02:02.040]     }
[18:02:02.040]     ...future.frame <- base::sys.nframe()
[18:02:02.040]     ...future.conditions <- base::list()
[18:02:02.040]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:02.040]     if (FALSE) {
[18:02:02.040]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:02.040]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:02.040]     }
[18:02:02.040]     ...future.result <- base::tryCatch({
[18:02:02.040]         base::withCallingHandlers({
[18:02:02.040]             ...future.value <- base::withVisible(base::local({
[18:02:02.040]                 ...future.makeSendCondition <- base::local({
[18:02:02.040]                   sendCondition <- NULL
[18:02:02.040]                   function(frame = 1L) {
[18:02:02.040]                     if (is.function(sendCondition)) 
[18:02:02.040]                       return(sendCondition)
[18:02:02.040]                     ns <- getNamespace("parallel")
[18:02:02.040]                     if (exists("sendData", mode = "function", 
[18:02:02.040]                       envir = ns)) {
[18:02:02.040]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:02.040]                         envir = ns)
[18:02:02.040]                       envir <- sys.frame(frame)
[18:02:02.040]                       master <- NULL
[18:02:02.040]                       while (!identical(envir, .GlobalEnv) && 
[18:02:02.040]                         !identical(envir, emptyenv())) {
[18:02:02.040]                         if (exists("master", mode = "list", envir = envir, 
[18:02:02.040]                           inherits = FALSE)) {
[18:02:02.040]                           master <- get("master", mode = "list", 
[18:02:02.040]                             envir = envir, inherits = FALSE)
[18:02:02.040]                           if (inherits(master, c("SOCKnode", 
[18:02:02.040]                             "SOCK0node"))) {
[18:02:02.040]                             sendCondition <<- function(cond) {
[18:02:02.040]                               data <- list(type = "VALUE", value = cond, 
[18:02:02.040]                                 success = TRUE)
[18:02:02.040]                               parallel_sendData(master, data)
[18:02:02.040]                             }
[18:02:02.040]                             return(sendCondition)
[18:02:02.040]                           }
[18:02:02.040]                         }
[18:02:02.040]                         frame <- frame + 1L
[18:02:02.040]                         envir <- sys.frame(frame)
[18:02:02.040]                       }
[18:02:02.040]                     }
[18:02:02.040]                     sendCondition <<- function(cond) NULL
[18:02:02.040]                   }
[18:02:02.040]                 })
[18:02:02.040]                 withCallingHandlers({
[18:02:02.040]                   NA
[18:02:02.040]                 }, immediateCondition = function(cond) {
[18:02:02.040]                   sendCondition <- ...future.makeSendCondition()
[18:02:02.040]                   sendCondition(cond)
[18:02:02.040]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:02.040]                   {
[18:02:02.040]                     inherits <- base::inherits
[18:02:02.040]                     invokeRestart <- base::invokeRestart
[18:02:02.040]                     is.null <- base::is.null
[18:02:02.040]                     muffled <- FALSE
[18:02:02.040]                     if (inherits(cond, "message")) {
[18:02:02.040]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:02.040]                       if (muffled) 
[18:02:02.040]                         invokeRestart("muffleMessage")
[18:02:02.040]                     }
[18:02:02.040]                     else if (inherits(cond, "warning")) {
[18:02:02.040]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:02.040]                       if (muffled) 
[18:02:02.040]                         invokeRestart("muffleWarning")
[18:02:02.040]                     }
[18:02:02.040]                     else if (inherits(cond, "condition")) {
[18:02:02.040]                       if (!is.null(pattern)) {
[18:02:02.040]                         computeRestarts <- base::computeRestarts
[18:02:02.040]                         grepl <- base::grepl
[18:02:02.040]                         restarts <- computeRestarts(cond)
[18:02:02.040]                         for (restart in restarts) {
[18:02:02.040]                           name <- restart$name
[18:02:02.040]                           if (is.null(name)) 
[18:02:02.040]                             next
[18:02:02.040]                           if (!grepl(pattern, name)) 
[18:02:02.040]                             next
[18:02:02.040]                           invokeRestart(restart)
[18:02:02.040]                           muffled <- TRUE
[18:02:02.040]                           break
[18:02:02.040]                         }
[18:02:02.040]                       }
[18:02:02.040]                     }
[18:02:02.040]                     invisible(muffled)
[18:02:02.040]                   }
[18:02:02.040]                   muffleCondition(cond)
[18:02:02.040]                 })
[18:02:02.040]             }))
[18:02:02.040]             future::FutureResult(value = ...future.value$value, 
[18:02:02.040]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:02.040]                   ...future.rng), globalenv = if (FALSE) 
[18:02:02.040]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:02.040]                     ...future.globalenv.names))
[18:02:02.040]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:02.040]         }, condition = base::local({
[18:02:02.040]             c <- base::c
[18:02:02.040]             inherits <- base::inherits
[18:02:02.040]             invokeRestart <- base::invokeRestart
[18:02:02.040]             length <- base::length
[18:02:02.040]             list <- base::list
[18:02:02.040]             seq.int <- base::seq.int
[18:02:02.040]             signalCondition <- base::signalCondition
[18:02:02.040]             sys.calls <- base::sys.calls
[18:02:02.040]             `[[` <- base::`[[`
[18:02:02.040]             `+` <- base::`+`
[18:02:02.040]             `<<-` <- base::`<<-`
[18:02:02.040]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:02.040]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:02.040]                   3L)]
[18:02:02.040]             }
[18:02:02.040]             function(cond) {
[18:02:02.040]                 is_error <- inherits(cond, "error")
[18:02:02.040]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:02.040]                   NULL)
[18:02:02.040]                 if (is_error) {
[18:02:02.040]                   sessionInformation <- function() {
[18:02:02.040]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:02.040]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:02.040]                       search = base::search(), system = base::Sys.info())
[18:02:02.040]                   }
[18:02:02.040]                   ...future.conditions[[length(...future.conditions) + 
[18:02:02.040]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:02.040]                     cond$call), session = sessionInformation(), 
[18:02:02.040]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:02.040]                   signalCondition(cond)
[18:02:02.040]                 }
[18:02:02.040]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:02.040]                 "immediateCondition"))) {
[18:02:02.040]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:02.040]                   ...future.conditions[[length(...future.conditions) + 
[18:02:02.040]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:02.040]                   if (TRUE && !signal) {
[18:02:02.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:02.040]                     {
[18:02:02.040]                       inherits <- base::inherits
[18:02:02.040]                       invokeRestart <- base::invokeRestart
[18:02:02.040]                       is.null <- base::is.null
[18:02:02.040]                       muffled <- FALSE
[18:02:02.040]                       if (inherits(cond, "message")) {
[18:02:02.040]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:02.040]                         if (muffled) 
[18:02:02.040]                           invokeRestart("muffleMessage")
[18:02:02.040]                       }
[18:02:02.040]                       else if (inherits(cond, "warning")) {
[18:02:02.040]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:02.040]                         if (muffled) 
[18:02:02.040]                           invokeRestart("muffleWarning")
[18:02:02.040]                       }
[18:02:02.040]                       else if (inherits(cond, "condition")) {
[18:02:02.040]                         if (!is.null(pattern)) {
[18:02:02.040]                           computeRestarts <- base::computeRestarts
[18:02:02.040]                           grepl <- base::grepl
[18:02:02.040]                           restarts <- computeRestarts(cond)
[18:02:02.040]                           for (restart in restarts) {
[18:02:02.040]                             name <- restart$name
[18:02:02.040]                             if (is.null(name)) 
[18:02:02.040]                               next
[18:02:02.040]                             if (!grepl(pattern, name)) 
[18:02:02.040]                               next
[18:02:02.040]                             invokeRestart(restart)
[18:02:02.040]                             muffled <- TRUE
[18:02:02.040]                             break
[18:02:02.040]                           }
[18:02:02.040]                         }
[18:02:02.040]                       }
[18:02:02.040]                       invisible(muffled)
[18:02:02.040]                     }
[18:02:02.040]                     muffleCondition(cond, pattern = "^muffle")
[18:02:02.040]                   }
[18:02:02.040]                 }
[18:02:02.040]                 else {
[18:02:02.040]                   if (TRUE) {
[18:02:02.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:02.040]                     {
[18:02:02.040]                       inherits <- base::inherits
[18:02:02.040]                       invokeRestart <- base::invokeRestart
[18:02:02.040]                       is.null <- base::is.null
[18:02:02.040]                       muffled <- FALSE
[18:02:02.040]                       if (inherits(cond, "message")) {
[18:02:02.040]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:02.040]                         if (muffled) 
[18:02:02.040]                           invokeRestart("muffleMessage")
[18:02:02.040]                       }
[18:02:02.040]                       else if (inherits(cond, "warning")) {
[18:02:02.040]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:02.040]                         if (muffled) 
[18:02:02.040]                           invokeRestart("muffleWarning")
[18:02:02.040]                       }
[18:02:02.040]                       else if (inherits(cond, "condition")) {
[18:02:02.040]                         if (!is.null(pattern)) {
[18:02:02.040]                           computeRestarts <- base::computeRestarts
[18:02:02.040]                           grepl <- base::grepl
[18:02:02.040]                           restarts <- computeRestarts(cond)
[18:02:02.040]                           for (restart in restarts) {
[18:02:02.040]                             name <- restart$name
[18:02:02.040]                             if (is.null(name)) 
[18:02:02.040]                               next
[18:02:02.040]                             if (!grepl(pattern, name)) 
[18:02:02.040]                               next
[18:02:02.040]                             invokeRestart(restart)
[18:02:02.040]                             muffled <- TRUE
[18:02:02.040]                             break
[18:02:02.040]                           }
[18:02:02.040]                         }
[18:02:02.040]                       }
[18:02:02.040]                       invisible(muffled)
[18:02:02.040]                     }
[18:02:02.040]                     muffleCondition(cond, pattern = "^muffle")
[18:02:02.040]                   }
[18:02:02.040]                 }
[18:02:02.040]             }
[18:02:02.040]         }))
[18:02:02.040]     }, error = function(ex) {
[18:02:02.040]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:02.040]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:02.040]                 ...future.rng), started = ...future.startTime, 
[18:02:02.040]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:02.040]             version = "1.8"), class = "FutureResult")
[18:02:02.040]     }, finally = {
[18:02:02.040]         if (!identical(...future.workdir, getwd())) 
[18:02:02.040]             setwd(...future.workdir)
[18:02:02.040]         {
[18:02:02.040]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:02.040]                 ...future.oldOptions$nwarnings <- NULL
[18:02:02.040]             }
[18:02:02.040]             base::options(...future.oldOptions)
[18:02:02.040]             if (.Platform$OS.type == "windows") {
[18:02:02.040]                 old_names <- names(...future.oldEnvVars)
[18:02:02.040]                 envs <- base::Sys.getenv()
[18:02:02.040]                 names <- names(envs)
[18:02:02.040]                 common <- intersect(names, old_names)
[18:02:02.040]                 added <- setdiff(names, old_names)
[18:02:02.040]                 removed <- setdiff(old_names, names)
[18:02:02.040]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:02.040]                   envs[common]]
[18:02:02.040]                 NAMES <- toupper(changed)
[18:02:02.040]                 args <- list()
[18:02:02.040]                 for (kk in seq_along(NAMES)) {
[18:02:02.040]                   name <- changed[[kk]]
[18:02:02.040]                   NAME <- NAMES[[kk]]
[18:02:02.040]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:02.040]                     next
[18:02:02.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:02.040]                 }
[18:02:02.040]                 NAMES <- toupper(added)
[18:02:02.040]                 for (kk in seq_along(NAMES)) {
[18:02:02.040]                   name <- added[[kk]]
[18:02:02.040]                   NAME <- NAMES[[kk]]
[18:02:02.040]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:02.040]                     next
[18:02:02.040]                   args[[name]] <- ""
[18:02:02.040]                 }
[18:02:02.040]                 NAMES <- toupper(removed)
[18:02:02.040]                 for (kk in seq_along(NAMES)) {
[18:02:02.040]                   name <- removed[[kk]]
[18:02:02.040]                   NAME <- NAMES[[kk]]
[18:02:02.040]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:02.040]                     next
[18:02:02.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:02.040]                 }
[18:02:02.040]                 if (length(args) > 0) 
[18:02:02.040]                   base::do.call(base::Sys.setenv, args = args)
[18:02:02.040]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:02.040]             }
[18:02:02.040]             else {
[18:02:02.040]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:02.040]             }
[18:02:02.040]             {
[18:02:02.040]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:02.040]                   0L) {
[18:02:02.040]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:02.040]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:02.040]                   base::options(opts)
[18:02:02.040]                 }
[18:02:02.040]                 {
[18:02:02.040]                   {
[18:02:02.040]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:02.040]                     NULL
[18:02:02.040]                   }
[18:02:02.040]                   options(future.plan = NULL)
[18:02:02.040]                   if (is.na(NA_character_)) 
[18:02:02.040]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:02.040]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:02.040]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:02.040]                     .init = FALSE)
[18:02:02.040]                 }
[18:02:02.040]             }
[18:02:02.040]         }
[18:02:02.040]     })
[18:02:02.040]     if (TRUE) {
[18:02:02.040]         base::sink(type = "output", split = FALSE)
[18:02:02.040]         if (TRUE) {
[18:02:02.040]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:02.040]         }
[18:02:02.040]         else {
[18:02:02.040]             ...future.result["stdout"] <- base::list(NULL)
[18:02:02.040]         }
[18:02:02.040]         base::close(...future.stdout)
[18:02:02.040]         ...future.stdout <- NULL
[18:02:02.040]     }
[18:02:02.040]     ...future.result$conditions <- ...future.conditions
[18:02:02.040]     ...future.result$finished <- base::Sys.time()
[18:02:02.040]     ...future.result
[18:02:02.040] }
[18:02:02.145] MultisessionFuture started
[18:02:02.145] result() for ClusterFuture ...
[18:02:02.146] receiveMessageFromWorker() for ClusterFuture ...
[18:02:02.146] - Validating connection of MultisessionFuture
[18:02:02.209] - received message: FutureResult
[18:02:02.209] - Received FutureResult
[18:02:02.209] - Erased future from FutureRegistry
[18:02:02.210] result() for ClusterFuture ...
[18:02:02.210] - result already collected: FutureResult
[18:02:02.210] result() for ClusterFuture ... done
[18:02:02.211] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:02.211] result() for ClusterFuture ... done
[18:02:02.211] result() for ClusterFuture ...
[18:02:02.212] - result already collected: FutureResult
[18:02:02.212] result() for ClusterFuture ... done
[18:02:02.212] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:02:02.219] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[18:02:02.225] future_lapply() ...
[18:02:02.235] Number of chunks: 2
[18:02:02.235] getGlobalsAndPackagesXApply() ...
[18:02:02.236]  - future.globals: TRUE
[18:02:02.236] getGlobalsAndPackages() ...
[18:02:02.236] Searching for globals...
[18:02:02.244] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:02:02.244] Searching for globals ... DONE
[18:02:02.244] Resolving globals: FALSE
[18:02:02.246] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[18:02:02.247] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:02.248] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:02.248] - packages: [1] ‘future.apply’
[18:02:02.248] getGlobalsAndPackages() ... DONE
[18:02:02.248]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:02.249]  - needed namespaces: [n=1] ‘future.apply’
[18:02:02.249] Finding globals ... DONE
[18:02:02.249]  - use_args: TRUE
[18:02:02.249]  - Getting '...' globals ...
[18:02:02.250] resolve() on list ...
[18:02:02.250]  recursive: 0
[18:02:02.251]  length: 1
[18:02:02.251]  elements: ‘...’
[18:02:02.251]  length: 0 (resolved future 1)
[18:02:02.251] resolve() on list ... DONE
[18:02:02.252]    - '...' content: [n=0] 
[18:02:02.252] List of 1
[18:02:02.252]  $ ...: list()
[18:02:02.252]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:02.252]  - attr(*, "where")=List of 1
[18:02:02.252]   ..$ ...:<environment: 0x6183c23762e8> 
[18:02:02.252]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:02.252]  - attr(*, "resolved")= logi TRUE
[18:02:02.252]  - attr(*, "total_size")= num NA
[18:02:02.258]  - Getting '...' globals ... DONE
[18:02:02.258] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:02.259] List of 8
[18:02:02.259]  $ ...future.FUN:function (x, ...)  
[18:02:02.259]  $ x_FUN        :function (x)  
[18:02:02.259]  $ times        : int 1
[18:02:02.259]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:02.259]  $ stop_if_not  :function (...)  
[18:02:02.259]  $ dim          : NULL
[18:02:02.259]  $ valid_types  : chr "character"
[18:02:02.259]  $ ...          : list()
[18:02:02.259]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:02.259]  - attr(*, "where")=List of 8
[18:02:02.259]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:02.259]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:02.259]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:02.259]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:02.259]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:02.259]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:02.259]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:02.259]   ..$ ...          :<environment: 0x6183c23762e8> 
[18:02:02.259]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:02.259]  - attr(*, "resolved")= logi FALSE
[18:02:02.259]  - attr(*, "total_size")= num 94208
[18:02:02.272] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:02.272] getGlobalsAndPackagesXApply() ... DONE
[18:02:02.272] Number of futures (= number of chunks): 2
[18:02:02.273] Launching 2 futures (chunks) ...
[18:02:02.273] Chunk #1 of 2 ...
[18:02:02.273]  - Finding globals in 'X' for chunk #1 ...
[18:02:02.273] getGlobalsAndPackages() ...
[18:02:02.274] Searching for globals...
[18:02:02.274] 
[18:02:02.274] Searching for globals ... DONE
[18:02:02.275] - globals: [0] <none>
[18:02:02.275] getGlobalsAndPackages() ... DONE
[18:02:02.275]    + additional globals found: [n=0] 
[18:02:02.275]    + additional namespaces needed: [n=0] 
[18:02:02.276]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:02.276]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:02.276]  - seeds: <none>
[18:02:02.276]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:02.276] getGlobalsAndPackages() ...
[18:02:02.277] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:02.277] Resolving globals: FALSE
[18:02:02.277] Tweak future expression to call with '...' arguments ...
[18:02:02.277] {
[18:02:02.277]     do.call(function(...) {
[18:02:02.277]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:02.277]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:02.277]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:02.277]             on.exit(options(oopts), add = TRUE)
[18:02:02.277]         }
[18:02:02.277]         {
[18:02:02.277]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:02.277]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:02.277]                 ...future.FUN(...future.X_jj, ...)
[18:02:02.277]             })
[18:02:02.277]         }
[18:02:02.277]     }, args = future.call.arguments)
[18:02:02.277] }
[18:02:02.278] Tweak future expression to call with '...' arguments ... DONE
[18:02:02.279] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:02.280] - packages: [1] ‘future.apply’
[18:02:02.280] getGlobalsAndPackages() ... DONE
[18:02:02.281] run() for ‘Future’ ...
[18:02:02.281] - state: ‘created’
[18:02:02.281] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:02.307] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:02.307] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:02.307]   - Field: ‘node’
[18:02:02.308]   - Field: ‘label’
[18:02:02.308]   - Field: ‘local’
[18:02:02.308]   - Field: ‘owner’
[18:02:02.308]   - Field: ‘envir’
[18:02:02.308]   - Field: ‘workers’
[18:02:02.309]   - Field: ‘packages’
[18:02:02.309]   - Field: ‘gc’
[18:02:02.309]   - Field: ‘conditions’
[18:02:02.309]   - Field: ‘persistent’
[18:02:02.310]   - Field: ‘expr’
[18:02:02.310]   - Field: ‘uuid’
[18:02:02.310]   - Field: ‘seed’
[18:02:02.310]   - Field: ‘version’
[18:02:02.311]   - Field: ‘result’
[18:02:02.311]   - Field: ‘asynchronous’
[18:02:02.311]   - Field: ‘calls’
[18:02:02.311]   - Field: ‘globals’
[18:02:02.312]   - Field: ‘stdout’
[18:02:02.312]   - Field: ‘earlySignal’
[18:02:02.312]   - Field: ‘lazy’
[18:02:02.312]   - Field: ‘state’
[18:02:02.312] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:02.313] - Launch lazy future ...
[18:02:02.313] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:02.314] Packages needed by future strategies (n = 0): <none>
[18:02:02.315] {
[18:02:02.315]     {
[18:02:02.315]         {
[18:02:02.315]             ...future.startTime <- base::Sys.time()
[18:02:02.315]             {
[18:02:02.315]                 {
[18:02:02.315]                   {
[18:02:02.315]                     {
[18:02:02.315]                       {
[18:02:02.315]                         base::local({
[18:02:02.315]                           has_future <- base::requireNamespace("future", 
[18:02:02.315]                             quietly = TRUE)
[18:02:02.315]                           if (has_future) {
[18:02:02.315]                             ns <- base::getNamespace("future")
[18:02:02.315]                             version <- ns[[".package"]][["version"]]
[18:02:02.315]                             if (is.null(version)) 
[18:02:02.315]                               version <- utils::packageVersion("future")
[18:02:02.315]                           }
[18:02:02.315]                           else {
[18:02:02.315]                             version <- NULL
[18:02:02.315]                           }
[18:02:02.315]                           if (!has_future || version < "1.8.0") {
[18:02:02.315]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:02.315]                               "", base::R.version$version.string), 
[18:02:02.315]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:02.315]                                 base::R.version$platform, 8 * 
[18:02:02.315]                                   base::.Machine$sizeof.pointer), 
[18:02:02.315]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:02.315]                                 "release", "version")], collapse = " "), 
[18:02:02.315]                               hostname = base::Sys.info()[["nodename"]])
[18:02:02.315]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:02.315]                               info)
[18:02:02.315]                             info <- base::paste(info, collapse = "; ")
[18:02:02.315]                             if (!has_future) {
[18:02:02.315]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:02.315]                                 info)
[18:02:02.315]                             }
[18:02:02.315]                             else {
[18:02:02.315]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:02.315]                                 info, version)
[18:02:02.315]                             }
[18:02:02.315]                             base::stop(msg)
[18:02:02.315]                           }
[18:02:02.315]                         })
[18:02:02.315]                       }
[18:02:02.315]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:02.315]                       base::options(mc.cores = 1L)
[18:02:02.315]                     }
[18:02:02.315]                     base::local({
[18:02:02.315]                       for (pkg in "future.apply") {
[18:02:02.315]                         base::loadNamespace(pkg)
[18:02:02.315]                         base::library(pkg, character.only = TRUE)
[18:02:02.315]                       }
[18:02:02.315]                     })
[18:02:02.315]                   }
[18:02:02.315]                   ...future.strategy.old <- future::plan("list")
[18:02:02.315]                   options(future.plan = NULL)
[18:02:02.315]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:02.315]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:02.315]                 }
[18:02:02.315]                 ...future.workdir <- getwd()
[18:02:02.315]             }
[18:02:02.315]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:02.315]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:02.315]         }
[18:02:02.315]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:02.315]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:02.315]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:02.315]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:02.315]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:02.315]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:02.315]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:02.315]             base::names(...future.oldOptions))
[18:02:02.315]     }
[18:02:02.315]     if (FALSE) {
[18:02:02.315]     }
[18:02:02.315]     else {
[18:02:02.315]         if (TRUE) {
[18:02:02.315]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:02.315]                 open = "w")
[18:02:02.315]         }
[18:02:02.315]         else {
[18:02:02.315]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:02.315]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:02.315]         }
[18:02:02.315]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:02.315]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:02.315]             base::sink(type = "output", split = FALSE)
[18:02:02.315]             base::close(...future.stdout)
[18:02:02.315]         }, add = TRUE)
[18:02:02.315]     }
[18:02:02.315]     ...future.frame <- base::sys.nframe()
[18:02:02.315]     ...future.conditions <- base::list()
[18:02:02.315]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:02.315]     if (FALSE) {
[18:02:02.315]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:02.315]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:02.315]     }
[18:02:02.315]     ...future.result <- base::tryCatch({
[18:02:02.315]         base::withCallingHandlers({
[18:02:02.315]             ...future.value <- base::withVisible(base::local({
[18:02:02.315]                 ...future.makeSendCondition <- base::local({
[18:02:02.315]                   sendCondition <- NULL
[18:02:02.315]                   function(frame = 1L) {
[18:02:02.315]                     if (is.function(sendCondition)) 
[18:02:02.315]                       return(sendCondition)
[18:02:02.315]                     ns <- getNamespace("parallel")
[18:02:02.315]                     if (exists("sendData", mode = "function", 
[18:02:02.315]                       envir = ns)) {
[18:02:02.315]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:02.315]                         envir = ns)
[18:02:02.315]                       envir <- sys.frame(frame)
[18:02:02.315]                       master <- NULL
[18:02:02.315]                       while (!identical(envir, .GlobalEnv) && 
[18:02:02.315]                         !identical(envir, emptyenv())) {
[18:02:02.315]                         if (exists("master", mode = "list", envir = envir, 
[18:02:02.315]                           inherits = FALSE)) {
[18:02:02.315]                           master <- get("master", mode = "list", 
[18:02:02.315]                             envir = envir, inherits = FALSE)
[18:02:02.315]                           if (inherits(master, c("SOCKnode", 
[18:02:02.315]                             "SOCK0node"))) {
[18:02:02.315]                             sendCondition <<- function(cond) {
[18:02:02.315]                               data <- list(type = "VALUE", value = cond, 
[18:02:02.315]                                 success = TRUE)
[18:02:02.315]                               parallel_sendData(master, data)
[18:02:02.315]                             }
[18:02:02.315]                             return(sendCondition)
[18:02:02.315]                           }
[18:02:02.315]                         }
[18:02:02.315]                         frame <- frame + 1L
[18:02:02.315]                         envir <- sys.frame(frame)
[18:02:02.315]                       }
[18:02:02.315]                     }
[18:02:02.315]                     sendCondition <<- function(cond) NULL
[18:02:02.315]                   }
[18:02:02.315]                 })
[18:02:02.315]                 withCallingHandlers({
[18:02:02.315]                   {
[18:02:02.315]                     do.call(function(...) {
[18:02:02.315]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:02.315]                       if (!identical(...future.globals.maxSize.org, 
[18:02:02.315]                         ...future.globals.maxSize)) {
[18:02:02.315]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:02.315]                         on.exit(options(oopts), add = TRUE)
[18:02:02.315]                       }
[18:02:02.315]                       {
[18:02:02.315]                         lapply(seq_along(...future.elements_ii), 
[18:02:02.315]                           FUN = function(jj) {
[18:02:02.315]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:02.315]                             ...future.FUN(...future.X_jj, ...)
[18:02:02.315]                           })
[18:02:02.315]                       }
[18:02:02.315]                     }, args = future.call.arguments)
[18:02:02.315]                   }
[18:02:02.315]                 }, immediateCondition = function(cond) {
[18:02:02.315]                   sendCondition <- ...future.makeSendCondition()
[18:02:02.315]                   sendCondition(cond)
[18:02:02.315]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:02.315]                   {
[18:02:02.315]                     inherits <- base::inherits
[18:02:02.315]                     invokeRestart <- base::invokeRestart
[18:02:02.315]                     is.null <- base::is.null
[18:02:02.315]                     muffled <- FALSE
[18:02:02.315]                     if (inherits(cond, "message")) {
[18:02:02.315]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:02.315]                       if (muffled) 
[18:02:02.315]                         invokeRestart("muffleMessage")
[18:02:02.315]                     }
[18:02:02.315]                     else if (inherits(cond, "warning")) {
[18:02:02.315]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:02.315]                       if (muffled) 
[18:02:02.315]                         invokeRestart("muffleWarning")
[18:02:02.315]                     }
[18:02:02.315]                     else if (inherits(cond, "condition")) {
[18:02:02.315]                       if (!is.null(pattern)) {
[18:02:02.315]                         computeRestarts <- base::computeRestarts
[18:02:02.315]                         grepl <- base::grepl
[18:02:02.315]                         restarts <- computeRestarts(cond)
[18:02:02.315]                         for (restart in restarts) {
[18:02:02.315]                           name <- restart$name
[18:02:02.315]                           if (is.null(name)) 
[18:02:02.315]                             next
[18:02:02.315]                           if (!grepl(pattern, name)) 
[18:02:02.315]                             next
[18:02:02.315]                           invokeRestart(restart)
[18:02:02.315]                           muffled <- TRUE
[18:02:02.315]                           break
[18:02:02.315]                         }
[18:02:02.315]                       }
[18:02:02.315]                     }
[18:02:02.315]                     invisible(muffled)
[18:02:02.315]                   }
[18:02:02.315]                   muffleCondition(cond)
[18:02:02.315]                 })
[18:02:02.315]             }))
[18:02:02.315]             future::FutureResult(value = ...future.value$value, 
[18:02:02.315]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:02.315]                   ...future.rng), globalenv = if (FALSE) 
[18:02:02.315]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:02.315]                     ...future.globalenv.names))
[18:02:02.315]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:02.315]         }, condition = base::local({
[18:02:02.315]             c <- base::c
[18:02:02.315]             inherits <- base::inherits
[18:02:02.315]             invokeRestart <- base::invokeRestart
[18:02:02.315]             length <- base::length
[18:02:02.315]             list <- base::list
[18:02:02.315]             seq.int <- base::seq.int
[18:02:02.315]             signalCondition <- base::signalCondition
[18:02:02.315]             sys.calls <- base::sys.calls
[18:02:02.315]             `[[` <- base::`[[`
[18:02:02.315]             `+` <- base::`+`
[18:02:02.315]             `<<-` <- base::`<<-`
[18:02:02.315]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:02.315]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:02.315]                   3L)]
[18:02:02.315]             }
[18:02:02.315]             function(cond) {
[18:02:02.315]                 is_error <- inherits(cond, "error")
[18:02:02.315]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:02.315]                   NULL)
[18:02:02.315]                 if (is_error) {
[18:02:02.315]                   sessionInformation <- function() {
[18:02:02.315]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:02.315]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:02.315]                       search = base::search(), system = base::Sys.info())
[18:02:02.315]                   }
[18:02:02.315]                   ...future.conditions[[length(...future.conditions) + 
[18:02:02.315]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:02.315]                     cond$call), session = sessionInformation(), 
[18:02:02.315]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:02.315]                   signalCondition(cond)
[18:02:02.315]                 }
[18:02:02.315]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:02.315]                 "immediateCondition"))) {
[18:02:02.315]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:02.315]                   ...future.conditions[[length(...future.conditions) + 
[18:02:02.315]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:02.315]                   if (TRUE && !signal) {
[18:02:02.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:02.315]                     {
[18:02:02.315]                       inherits <- base::inherits
[18:02:02.315]                       invokeRestart <- base::invokeRestart
[18:02:02.315]                       is.null <- base::is.null
[18:02:02.315]                       muffled <- FALSE
[18:02:02.315]                       if (inherits(cond, "message")) {
[18:02:02.315]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:02.315]                         if (muffled) 
[18:02:02.315]                           invokeRestart("muffleMessage")
[18:02:02.315]                       }
[18:02:02.315]                       else if (inherits(cond, "warning")) {
[18:02:02.315]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:02.315]                         if (muffled) 
[18:02:02.315]                           invokeRestart("muffleWarning")
[18:02:02.315]                       }
[18:02:02.315]                       else if (inherits(cond, "condition")) {
[18:02:02.315]                         if (!is.null(pattern)) {
[18:02:02.315]                           computeRestarts <- base::computeRestarts
[18:02:02.315]                           grepl <- base::grepl
[18:02:02.315]                           restarts <- computeRestarts(cond)
[18:02:02.315]                           for (restart in restarts) {
[18:02:02.315]                             name <- restart$name
[18:02:02.315]                             if (is.null(name)) 
[18:02:02.315]                               next
[18:02:02.315]                             if (!grepl(pattern, name)) 
[18:02:02.315]                               next
[18:02:02.315]                             invokeRestart(restart)
[18:02:02.315]                             muffled <- TRUE
[18:02:02.315]                             break
[18:02:02.315]                           }
[18:02:02.315]                         }
[18:02:02.315]                       }
[18:02:02.315]                       invisible(muffled)
[18:02:02.315]                     }
[18:02:02.315]                     muffleCondition(cond, pattern = "^muffle")
[18:02:02.315]                   }
[18:02:02.315]                 }
[18:02:02.315]                 else {
[18:02:02.315]                   if (TRUE) {
[18:02:02.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:02.315]                     {
[18:02:02.315]                       inherits <- base::inherits
[18:02:02.315]                       invokeRestart <- base::invokeRestart
[18:02:02.315]                       is.null <- base::is.null
[18:02:02.315]                       muffled <- FALSE
[18:02:02.315]                       if (inherits(cond, "message")) {
[18:02:02.315]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:02.315]                         if (muffled) 
[18:02:02.315]                           invokeRestart("muffleMessage")
[18:02:02.315]                       }
[18:02:02.315]                       else if (inherits(cond, "warning")) {
[18:02:02.315]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:02.315]                         if (muffled) 
[18:02:02.315]                           invokeRestart("muffleWarning")
[18:02:02.315]                       }
[18:02:02.315]                       else if (inherits(cond, "condition")) {
[18:02:02.315]                         if (!is.null(pattern)) {
[18:02:02.315]                           computeRestarts <- base::computeRestarts
[18:02:02.315]                           grepl <- base::grepl
[18:02:02.315]                           restarts <- computeRestarts(cond)
[18:02:02.315]                           for (restart in restarts) {
[18:02:02.315]                             name <- restart$name
[18:02:02.315]                             if (is.null(name)) 
[18:02:02.315]                               next
[18:02:02.315]                             if (!grepl(pattern, name)) 
[18:02:02.315]                               next
[18:02:02.315]                             invokeRestart(restart)
[18:02:02.315]                             muffled <- TRUE
[18:02:02.315]                             break
[18:02:02.315]                           }
[18:02:02.315]                         }
[18:02:02.315]                       }
[18:02:02.315]                       invisible(muffled)
[18:02:02.315]                     }
[18:02:02.315]                     muffleCondition(cond, pattern = "^muffle")
[18:02:02.315]                   }
[18:02:02.315]                 }
[18:02:02.315]             }
[18:02:02.315]         }))
[18:02:02.315]     }, error = function(ex) {
[18:02:02.315]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:02.315]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:02.315]                 ...future.rng), started = ...future.startTime, 
[18:02:02.315]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:02.315]             version = "1.8"), class = "FutureResult")
[18:02:02.315]     }, finally = {
[18:02:02.315]         if (!identical(...future.workdir, getwd())) 
[18:02:02.315]             setwd(...future.workdir)
[18:02:02.315]         {
[18:02:02.315]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:02.315]                 ...future.oldOptions$nwarnings <- NULL
[18:02:02.315]             }
[18:02:02.315]             base::options(...future.oldOptions)
[18:02:02.315]             if (.Platform$OS.type == "windows") {
[18:02:02.315]                 old_names <- names(...future.oldEnvVars)
[18:02:02.315]                 envs <- base::Sys.getenv()
[18:02:02.315]                 names <- names(envs)
[18:02:02.315]                 common <- intersect(names, old_names)
[18:02:02.315]                 added <- setdiff(names, old_names)
[18:02:02.315]                 removed <- setdiff(old_names, names)
[18:02:02.315]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:02.315]                   envs[common]]
[18:02:02.315]                 NAMES <- toupper(changed)
[18:02:02.315]                 args <- list()
[18:02:02.315]                 for (kk in seq_along(NAMES)) {
[18:02:02.315]                   name <- changed[[kk]]
[18:02:02.315]                   NAME <- NAMES[[kk]]
[18:02:02.315]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:02.315]                     next
[18:02:02.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:02.315]                 }
[18:02:02.315]                 NAMES <- toupper(added)
[18:02:02.315]                 for (kk in seq_along(NAMES)) {
[18:02:02.315]                   name <- added[[kk]]
[18:02:02.315]                   NAME <- NAMES[[kk]]
[18:02:02.315]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:02.315]                     next
[18:02:02.315]                   args[[name]] <- ""
[18:02:02.315]                 }
[18:02:02.315]                 NAMES <- toupper(removed)
[18:02:02.315]                 for (kk in seq_along(NAMES)) {
[18:02:02.315]                   name <- removed[[kk]]
[18:02:02.315]                   NAME <- NAMES[[kk]]
[18:02:02.315]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:02.315]                     next
[18:02:02.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:02.315]                 }
[18:02:02.315]                 if (length(args) > 0) 
[18:02:02.315]                   base::do.call(base::Sys.setenv, args = args)
[18:02:02.315]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:02.315]             }
[18:02:02.315]             else {
[18:02:02.315]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:02.315]             }
[18:02:02.315]             {
[18:02:02.315]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:02.315]                   0L) {
[18:02:02.315]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:02.315]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:02.315]                   base::options(opts)
[18:02:02.315]                 }
[18:02:02.315]                 {
[18:02:02.315]                   {
[18:02:02.315]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:02.315]                     NULL
[18:02:02.315]                   }
[18:02:02.315]                   options(future.plan = NULL)
[18:02:02.315]                   if (is.na(NA_character_)) 
[18:02:02.315]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:02.315]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:02.315]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:02.315]                     .init = FALSE)
[18:02:02.315]                 }
[18:02:02.315]             }
[18:02:02.315]         }
[18:02:02.315]     })
[18:02:02.315]     if (TRUE) {
[18:02:02.315]         base::sink(type = "output", split = FALSE)
[18:02:02.315]         if (TRUE) {
[18:02:02.315]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:02.315]         }
[18:02:02.315]         else {
[18:02:02.315]             ...future.result["stdout"] <- base::list(NULL)
[18:02:02.315]         }
[18:02:02.315]         base::close(...future.stdout)
[18:02:02.315]         ...future.stdout <- NULL
[18:02:02.315]     }
[18:02:02.315]     ...future.result$conditions <- ...future.conditions
[18:02:02.315]     ...future.result$finished <- base::Sys.time()
[18:02:02.315]     ...future.result
[18:02:02.315] }
[18:02:02.320] Exporting 11 global objects (92.00 KiB) to cluster node #1 ...
[18:02:02.321] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[18:02:02.362] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[18:02:02.363] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[18:02:02.364] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[18:02:02.364] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[18:02:02.365] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[18:02:02.365] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[18:02:02.407] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[18:02:02.408] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[18:02:02.449] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[18:02:02.450] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[18:02:02.451] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[18:02:02.452] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ...
[18:02:02.453] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ... DONE
[18:02:02.454] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:02.455] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:02.455] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[18:02:02.457] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[18:02:02.457] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:02.458] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:02.459] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:02.460] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:02.461] Exporting 11 global objects (92.00 KiB) to cluster node #1 ... DONE
[18:02:02.462] MultisessionFuture started
[18:02:02.463] - Launch lazy future ... done
[18:02:02.463] run() for ‘MultisessionFuture’ ... done
[18:02:02.463] Created future:
[18:02:02.464] MultisessionFuture:
[18:02:02.464] Label: ‘future_vapply-1’
[18:02:02.464] Expression:
[18:02:02.464] {
[18:02:02.464]     do.call(function(...) {
[18:02:02.464]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:02.464]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:02.464]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:02.464]             on.exit(options(oopts), add = TRUE)
[18:02:02.464]         }
[18:02:02.464]         {
[18:02:02.464]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:02.464]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:02.464]                 ...future.FUN(...future.X_jj, ...)
[18:02:02.464]             })
[18:02:02.464]         }
[18:02:02.464]     }, args = future.call.arguments)
[18:02:02.464] }
[18:02:02.464] Lazy evaluation: FALSE
[18:02:02.464] Asynchronous evaluation: TRUE
[18:02:02.464] Local evaluation: TRUE
[18:02:02.464] Environment: R_GlobalEnv
[18:02:02.464] Capture standard output: TRUE
[18:02:02.464] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:02.464] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:02.464] Packages: 1 packages (‘future.apply’)
[18:02:02.464] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:02.464] Resolved: FALSE
[18:02:02.464] Value: <not collected>
[18:02:02.464] Conditions captured: <none>
[18:02:02.464] Early signaling: FALSE
[18:02:02.464] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:02.464] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:02.481] Chunk #1 of 2 ... DONE
[18:02:02.481] Chunk #2 of 2 ...
[18:02:02.482]  - Finding globals in 'X' for chunk #2 ...
[18:02:02.482] getGlobalsAndPackages() ...
[18:02:02.482] Searching for globals...
[18:02:02.483] 
[18:02:02.484] Searching for globals ... DONE
[18:02:02.484] - globals: [0] <none>
[18:02:02.485] getGlobalsAndPackages() ... DONE
[18:02:02.485]    + additional globals found: [n=0] 
[18:02:02.485]    + additional namespaces needed: [n=0] 
[18:02:02.486]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:02.486]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:02.487]  - seeds: <none>
[18:02:02.487]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:02.487] getGlobalsAndPackages() ...
[18:02:02.488] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:02.488] Resolving globals: FALSE
[18:02:02.489] Tweak future expression to call with '...' arguments ...
[18:02:02.489] {
[18:02:02.489]     do.call(function(...) {
[18:02:02.489]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:02.489]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:02.489]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:02.489]             on.exit(options(oopts), add = TRUE)
[18:02:02.489]         }
[18:02:02.489]         {
[18:02:02.489]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:02.489]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:02.489]                 ...future.FUN(...future.X_jj, ...)
[18:02:02.489]             })
[18:02:02.489]         }
[18:02:02.489]     }, args = future.call.arguments)
[18:02:02.489] }
[18:02:02.490] Tweak future expression to call with '...' arguments ... DONE
[18:02:02.494] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:02.494] - packages: [1] ‘future.apply’
[18:02:02.495] getGlobalsAndPackages() ... DONE
[18:02:02.496] run() for ‘Future’ ...
[18:02:02.496] - state: ‘created’
[18:02:02.497] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:02.527] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:02.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:02.528]   - Field: ‘node’
[18:02:02.528]   - Field: ‘label’
[18:02:02.529]   - Field: ‘local’
[18:02:02.529]   - Field: ‘owner’
[18:02:02.529]   - Field: ‘envir’
[18:02:02.529]   - Field: ‘workers’
[18:02:02.530]   - Field: ‘packages’
[18:02:02.530]   - Field: ‘gc’
[18:02:02.530]   - Field: ‘conditions’
[18:02:02.530]   - Field: ‘persistent’
[18:02:02.531]   - Field: ‘expr’
[18:02:02.531]   - Field: ‘uuid’
[18:02:02.531]   - Field: ‘seed’
[18:02:02.532]   - Field: ‘version’
[18:02:02.532]   - Field: ‘result’
[18:02:02.532]   - Field: ‘asynchronous’
[18:02:02.532]   - Field: ‘calls’
[18:02:02.533]   - Field: ‘globals’
[18:02:02.533]   - Field: ‘stdout’
[18:02:02.533]   - Field: ‘earlySignal’
[18:02:02.534]   - Field: ‘lazy’
[18:02:02.534]   - Field: ‘state’
[18:02:02.534] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:02.534] - Launch lazy future ...
[18:02:02.535] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:02.535] Packages needed by future strategies (n = 0): <none>
[18:02:02.537] {
[18:02:02.537]     {
[18:02:02.537]         {
[18:02:02.537]             ...future.startTime <- base::Sys.time()
[18:02:02.537]             {
[18:02:02.537]                 {
[18:02:02.537]                   {
[18:02:02.537]                     {
[18:02:02.537]                       {
[18:02:02.537]                         base::local({
[18:02:02.537]                           has_future <- base::requireNamespace("future", 
[18:02:02.537]                             quietly = TRUE)
[18:02:02.537]                           if (has_future) {
[18:02:02.537]                             ns <- base::getNamespace("future")
[18:02:02.537]                             version <- ns[[".package"]][["version"]]
[18:02:02.537]                             if (is.null(version)) 
[18:02:02.537]                               version <- utils::packageVersion("future")
[18:02:02.537]                           }
[18:02:02.537]                           else {
[18:02:02.537]                             version <- NULL
[18:02:02.537]                           }
[18:02:02.537]                           if (!has_future || version < "1.8.0") {
[18:02:02.537]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:02.537]                               "", base::R.version$version.string), 
[18:02:02.537]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:02.537]                                 base::R.version$platform, 8 * 
[18:02:02.537]                                   base::.Machine$sizeof.pointer), 
[18:02:02.537]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:02.537]                                 "release", "version")], collapse = " "), 
[18:02:02.537]                               hostname = base::Sys.info()[["nodename"]])
[18:02:02.537]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:02.537]                               info)
[18:02:02.537]                             info <- base::paste(info, collapse = "; ")
[18:02:02.537]                             if (!has_future) {
[18:02:02.537]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:02.537]                                 info)
[18:02:02.537]                             }
[18:02:02.537]                             else {
[18:02:02.537]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:02.537]                                 info, version)
[18:02:02.537]                             }
[18:02:02.537]                             base::stop(msg)
[18:02:02.537]                           }
[18:02:02.537]                         })
[18:02:02.537]                       }
[18:02:02.537]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:02.537]                       base::options(mc.cores = 1L)
[18:02:02.537]                     }
[18:02:02.537]                     base::local({
[18:02:02.537]                       for (pkg in "future.apply") {
[18:02:02.537]                         base::loadNamespace(pkg)
[18:02:02.537]                         base::library(pkg, character.only = TRUE)
[18:02:02.537]                       }
[18:02:02.537]                     })
[18:02:02.537]                   }
[18:02:02.537]                   ...future.strategy.old <- future::plan("list")
[18:02:02.537]                   options(future.plan = NULL)
[18:02:02.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:02.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:02.537]                 }
[18:02:02.537]                 ...future.workdir <- getwd()
[18:02:02.537]             }
[18:02:02.537]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:02.537]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:02.537]         }
[18:02:02.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:02.537]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:02.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:02.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:02.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:02.537]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:02.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:02.537]             base::names(...future.oldOptions))
[18:02:02.537]     }
[18:02:02.537]     if (FALSE) {
[18:02:02.537]     }
[18:02:02.537]     else {
[18:02:02.537]         if (TRUE) {
[18:02:02.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:02.537]                 open = "w")
[18:02:02.537]         }
[18:02:02.537]         else {
[18:02:02.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:02.537]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:02.537]         }
[18:02:02.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:02.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:02.537]             base::sink(type = "output", split = FALSE)
[18:02:02.537]             base::close(...future.stdout)
[18:02:02.537]         }, add = TRUE)
[18:02:02.537]     }
[18:02:02.537]     ...future.frame <- base::sys.nframe()
[18:02:02.537]     ...future.conditions <- base::list()
[18:02:02.537]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:02.537]     if (FALSE) {
[18:02:02.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:02.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:02.537]     }
[18:02:02.537]     ...future.result <- base::tryCatch({
[18:02:02.537]         base::withCallingHandlers({
[18:02:02.537]             ...future.value <- base::withVisible(base::local({
[18:02:02.537]                 ...future.makeSendCondition <- base::local({
[18:02:02.537]                   sendCondition <- NULL
[18:02:02.537]                   function(frame = 1L) {
[18:02:02.537]                     if (is.function(sendCondition)) 
[18:02:02.537]                       return(sendCondition)
[18:02:02.537]                     ns <- getNamespace("parallel")
[18:02:02.537]                     if (exists("sendData", mode = "function", 
[18:02:02.537]                       envir = ns)) {
[18:02:02.537]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:02.537]                         envir = ns)
[18:02:02.537]                       envir <- sys.frame(frame)
[18:02:02.537]                       master <- NULL
[18:02:02.537]                       while (!identical(envir, .GlobalEnv) && 
[18:02:02.537]                         !identical(envir, emptyenv())) {
[18:02:02.537]                         if (exists("master", mode = "list", envir = envir, 
[18:02:02.537]                           inherits = FALSE)) {
[18:02:02.537]                           master <- get("master", mode = "list", 
[18:02:02.537]                             envir = envir, inherits = FALSE)
[18:02:02.537]                           if (inherits(master, c("SOCKnode", 
[18:02:02.537]                             "SOCK0node"))) {
[18:02:02.537]                             sendCondition <<- function(cond) {
[18:02:02.537]                               data <- list(type = "VALUE", value = cond, 
[18:02:02.537]                                 success = TRUE)
[18:02:02.537]                               parallel_sendData(master, data)
[18:02:02.537]                             }
[18:02:02.537]                             return(sendCondition)
[18:02:02.537]                           }
[18:02:02.537]                         }
[18:02:02.537]                         frame <- frame + 1L
[18:02:02.537]                         envir <- sys.frame(frame)
[18:02:02.537]                       }
[18:02:02.537]                     }
[18:02:02.537]                     sendCondition <<- function(cond) NULL
[18:02:02.537]                   }
[18:02:02.537]                 })
[18:02:02.537]                 withCallingHandlers({
[18:02:02.537]                   {
[18:02:02.537]                     do.call(function(...) {
[18:02:02.537]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:02.537]                       if (!identical(...future.globals.maxSize.org, 
[18:02:02.537]                         ...future.globals.maxSize)) {
[18:02:02.537]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:02.537]                         on.exit(options(oopts), add = TRUE)
[18:02:02.537]                       }
[18:02:02.537]                       {
[18:02:02.537]                         lapply(seq_along(...future.elements_ii), 
[18:02:02.537]                           FUN = function(jj) {
[18:02:02.537]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:02.537]                             ...future.FUN(...future.X_jj, ...)
[18:02:02.537]                           })
[18:02:02.537]                       }
[18:02:02.537]                     }, args = future.call.arguments)
[18:02:02.537]                   }
[18:02:02.537]                 }, immediateCondition = function(cond) {
[18:02:02.537]                   sendCondition <- ...future.makeSendCondition()
[18:02:02.537]                   sendCondition(cond)
[18:02:02.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:02.537]                   {
[18:02:02.537]                     inherits <- base::inherits
[18:02:02.537]                     invokeRestart <- base::invokeRestart
[18:02:02.537]                     is.null <- base::is.null
[18:02:02.537]                     muffled <- FALSE
[18:02:02.537]                     if (inherits(cond, "message")) {
[18:02:02.537]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:02.537]                       if (muffled) 
[18:02:02.537]                         invokeRestart("muffleMessage")
[18:02:02.537]                     }
[18:02:02.537]                     else if (inherits(cond, "warning")) {
[18:02:02.537]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:02.537]                       if (muffled) 
[18:02:02.537]                         invokeRestart("muffleWarning")
[18:02:02.537]                     }
[18:02:02.537]                     else if (inherits(cond, "condition")) {
[18:02:02.537]                       if (!is.null(pattern)) {
[18:02:02.537]                         computeRestarts <- base::computeRestarts
[18:02:02.537]                         grepl <- base::grepl
[18:02:02.537]                         restarts <- computeRestarts(cond)
[18:02:02.537]                         for (restart in restarts) {
[18:02:02.537]                           name <- restart$name
[18:02:02.537]                           if (is.null(name)) 
[18:02:02.537]                             next
[18:02:02.537]                           if (!grepl(pattern, name)) 
[18:02:02.537]                             next
[18:02:02.537]                           invokeRestart(restart)
[18:02:02.537]                           muffled <- TRUE
[18:02:02.537]                           break
[18:02:02.537]                         }
[18:02:02.537]                       }
[18:02:02.537]                     }
[18:02:02.537]                     invisible(muffled)
[18:02:02.537]                   }
[18:02:02.537]                   muffleCondition(cond)
[18:02:02.537]                 })
[18:02:02.537]             }))
[18:02:02.537]             future::FutureResult(value = ...future.value$value, 
[18:02:02.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:02.537]                   ...future.rng), globalenv = if (FALSE) 
[18:02:02.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:02.537]                     ...future.globalenv.names))
[18:02:02.537]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:02.537]         }, condition = base::local({
[18:02:02.537]             c <- base::c
[18:02:02.537]             inherits <- base::inherits
[18:02:02.537]             invokeRestart <- base::invokeRestart
[18:02:02.537]             length <- base::length
[18:02:02.537]             list <- base::list
[18:02:02.537]             seq.int <- base::seq.int
[18:02:02.537]             signalCondition <- base::signalCondition
[18:02:02.537]             sys.calls <- base::sys.calls
[18:02:02.537]             `[[` <- base::`[[`
[18:02:02.537]             `+` <- base::`+`
[18:02:02.537]             `<<-` <- base::`<<-`
[18:02:02.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:02.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:02.537]                   3L)]
[18:02:02.537]             }
[18:02:02.537]             function(cond) {
[18:02:02.537]                 is_error <- inherits(cond, "error")
[18:02:02.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:02.537]                   NULL)
[18:02:02.537]                 if (is_error) {
[18:02:02.537]                   sessionInformation <- function() {
[18:02:02.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:02.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:02.537]                       search = base::search(), system = base::Sys.info())
[18:02:02.537]                   }
[18:02:02.537]                   ...future.conditions[[length(...future.conditions) + 
[18:02:02.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:02.537]                     cond$call), session = sessionInformation(), 
[18:02:02.537]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:02.537]                   signalCondition(cond)
[18:02:02.537]                 }
[18:02:02.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:02.537]                 "immediateCondition"))) {
[18:02:02.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:02.537]                   ...future.conditions[[length(...future.conditions) + 
[18:02:02.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:02.537]                   if (TRUE && !signal) {
[18:02:02.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:02.537]                     {
[18:02:02.537]                       inherits <- base::inherits
[18:02:02.537]                       invokeRestart <- base::invokeRestart
[18:02:02.537]                       is.null <- base::is.null
[18:02:02.537]                       muffled <- FALSE
[18:02:02.537]                       if (inherits(cond, "message")) {
[18:02:02.537]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:02.537]                         if (muffled) 
[18:02:02.537]                           invokeRestart("muffleMessage")
[18:02:02.537]                       }
[18:02:02.537]                       else if (inherits(cond, "warning")) {
[18:02:02.537]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:02.537]                         if (muffled) 
[18:02:02.537]                           invokeRestart("muffleWarning")
[18:02:02.537]                       }
[18:02:02.537]                       else if (inherits(cond, "condition")) {
[18:02:02.537]                         if (!is.null(pattern)) {
[18:02:02.537]                           computeRestarts <- base::computeRestarts
[18:02:02.537]                           grepl <- base::grepl
[18:02:02.537]                           restarts <- computeRestarts(cond)
[18:02:02.537]                           for (restart in restarts) {
[18:02:02.537]                             name <- restart$name
[18:02:02.537]                             if (is.null(name)) 
[18:02:02.537]                               next
[18:02:02.537]                             if (!grepl(pattern, name)) 
[18:02:02.537]                               next
[18:02:02.537]                             invokeRestart(restart)
[18:02:02.537]                             muffled <- TRUE
[18:02:02.537]                             break
[18:02:02.537]                           }
[18:02:02.537]                         }
[18:02:02.537]                       }
[18:02:02.537]                       invisible(muffled)
[18:02:02.537]                     }
[18:02:02.537]                     muffleCondition(cond, pattern = "^muffle")
[18:02:02.537]                   }
[18:02:02.537]                 }
[18:02:02.537]                 else {
[18:02:02.537]                   if (TRUE) {
[18:02:02.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:02.537]                     {
[18:02:02.537]                       inherits <- base::inherits
[18:02:02.537]                       invokeRestart <- base::invokeRestart
[18:02:02.537]                       is.null <- base::is.null
[18:02:02.537]                       muffled <- FALSE
[18:02:02.537]                       if (inherits(cond, "message")) {
[18:02:02.537]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:02.537]                         if (muffled) 
[18:02:02.537]                           invokeRestart("muffleMessage")
[18:02:02.537]                       }
[18:02:02.537]                       else if (inherits(cond, "warning")) {
[18:02:02.537]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:02.537]                         if (muffled) 
[18:02:02.537]                           invokeRestart("muffleWarning")
[18:02:02.537]                       }
[18:02:02.537]                       else if (inherits(cond, "condition")) {
[18:02:02.537]                         if (!is.null(pattern)) {
[18:02:02.537]                           computeRestarts <- base::computeRestarts
[18:02:02.537]                           grepl <- base::grepl
[18:02:02.537]                           restarts <- computeRestarts(cond)
[18:02:02.537]                           for (restart in restarts) {
[18:02:02.537]                             name <- restart$name
[18:02:02.537]                             if (is.null(name)) 
[18:02:02.537]                               next
[18:02:02.537]                             if (!grepl(pattern, name)) 
[18:02:02.537]                               next
[18:02:02.537]                             invokeRestart(restart)
[18:02:02.537]                             muffled <- TRUE
[18:02:02.537]                             break
[18:02:02.537]                           }
[18:02:02.537]                         }
[18:02:02.537]                       }
[18:02:02.537]                       invisible(muffled)
[18:02:02.537]                     }
[18:02:02.537]                     muffleCondition(cond, pattern = "^muffle")
[18:02:02.537]                   }
[18:02:02.537]                 }
[18:02:02.537]             }
[18:02:02.537]         }))
[18:02:02.537]     }, error = function(ex) {
[18:02:02.537]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:02.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:02.537]                 ...future.rng), started = ...future.startTime, 
[18:02:02.537]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:02.537]             version = "1.8"), class = "FutureResult")
[18:02:02.537]     }, finally = {
[18:02:02.537]         if (!identical(...future.workdir, getwd())) 
[18:02:02.537]             setwd(...future.workdir)
[18:02:02.537]         {
[18:02:02.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:02.537]                 ...future.oldOptions$nwarnings <- NULL
[18:02:02.537]             }
[18:02:02.537]             base::options(...future.oldOptions)
[18:02:02.537]             if (.Platform$OS.type == "windows") {
[18:02:02.537]                 old_names <- names(...future.oldEnvVars)
[18:02:02.537]                 envs <- base::Sys.getenv()
[18:02:02.537]                 names <- names(envs)
[18:02:02.537]                 common <- intersect(names, old_names)
[18:02:02.537]                 added <- setdiff(names, old_names)
[18:02:02.537]                 removed <- setdiff(old_names, names)
[18:02:02.537]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:02.537]                   envs[common]]
[18:02:02.537]                 NAMES <- toupper(changed)
[18:02:02.537]                 args <- list()
[18:02:02.537]                 for (kk in seq_along(NAMES)) {
[18:02:02.537]                   name <- changed[[kk]]
[18:02:02.537]                   NAME <- NAMES[[kk]]
[18:02:02.537]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:02.537]                     next
[18:02:02.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:02.537]                 }
[18:02:02.537]                 NAMES <- toupper(added)
[18:02:02.537]                 for (kk in seq_along(NAMES)) {
[18:02:02.537]                   name <- added[[kk]]
[18:02:02.537]                   NAME <- NAMES[[kk]]
[18:02:02.537]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:02.537]                     next
[18:02:02.537]                   args[[name]] <- ""
[18:02:02.537]                 }
[18:02:02.537]                 NAMES <- toupper(removed)
[18:02:02.537]                 for (kk in seq_along(NAMES)) {
[18:02:02.537]                   name <- removed[[kk]]
[18:02:02.537]                   NAME <- NAMES[[kk]]
[18:02:02.537]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:02.537]                     next
[18:02:02.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:02.537]                 }
[18:02:02.537]                 if (length(args) > 0) 
[18:02:02.537]                   base::do.call(base::Sys.setenv, args = args)
[18:02:02.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:02.537]             }
[18:02:02.537]             else {
[18:02:02.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:02.537]             }
[18:02:02.537]             {
[18:02:02.537]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:02.537]                   0L) {
[18:02:02.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:02.537]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:02.537]                   base::options(opts)
[18:02:02.537]                 }
[18:02:02.537]                 {
[18:02:02.537]                   {
[18:02:02.537]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:02.537]                     NULL
[18:02:02.537]                   }
[18:02:02.537]                   options(future.plan = NULL)
[18:02:02.537]                   if (is.na(NA_character_)) 
[18:02:02.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:02.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:02.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:02.537]                     .init = FALSE)
[18:02:02.537]                 }
[18:02:02.537]             }
[18:02:02.537]         }
[18:02:02.537]     })
[18:02:02.537]     if (TRUE) {
[18:02:02.537]         base::sink(type = "output", split = FALSE)
[18:02:02.537]         if (TRUE) {
[18:02:02.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:02.537]         }
[18:02:02.537]         else {
[18:02:02.537]             ...future.result["stdout"] <- base::list(NULL)
[18:02:02.537]         }
[18:02:02.537]         base::close(...future.stdout)
[18:02:02.537]         ...future.stdout <- NULL
[18:02:02.537]     }
[18:02:02.537]     ...future.result$conditions <- ...future.conditions
[18:02:02.537]     ...future.result$finished <- base::Sys.time()
[18:02:02.537]     ...future.result
[18:02:02.537] }
[18:02:02.640] Exporting 11 global objects (92.00 KiB) to cluster node #2 ...
[18:02:02.640] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[18:02:02.649] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[18:02:02.649] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[18:02:02.650] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[18:02:02.651] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[18:02:02.652] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[18:02:02.653] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[18:02:02.694] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[18:02:02.695] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[18:02:02.736] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[18:02:02.737] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[18:02:02.738] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[18:02:02.739] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ...
[18:02:02.740] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ... DONE
[18:02:02.741] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:02.742] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:02.743] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ...
[18:02:02.744] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ... DONE
[18:02:02.744] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:02.746] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:02.746] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:02.747] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:02.748] Exporting 11 global objects (92.00 KiB) to cluster node #2 ... DONE
[18:02:02.750] MultisessionFuture started
[18:02:02.750] - Launch lazy future ... done
[18:02:02.751] run() for ‘MultisessionFuture’ ... done
[18:02:02.755] Created future:
[18:02:02.755] MultisessionFuture:
[18:02:02.755] Label: ‘future_vapply-2’
[18:02:02.755] Expression:
[18:02:02.755] {
[18:02:02.755]     do.call(function(...) {
[18:02:02.755]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:02.755]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:02.755]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:02.755]             on.exit(options(oopts), add = TRUE)
[18:02:02.755]         }
[18:02:02.755]         {
[18:02:02.755]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:02.755]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:02.755]                 ...future.FUN(...future.X_jj, ...)
[18:02:02.755]             })
[18:02:02.755]         }
[18:02:02.755]     }, args = future.call.arguments)
[18:02:02.755] }
[18:02:02.755] Lazy evaluation: FALSE
[18:02:02.755] Asynchronous evaluation: TRUE
[18:02:02.755] Local evaluation: TRUE
[18:02:02.755] Environment: R_GlobalEnv
[18:02:02.755] Capture standard output: TRUE
[18:02:02.755] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:02.755] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:02.755] Packages: 1 packages (‘future.apply’)
[18:02:02.755] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:02.755] Resolved: FALSE
[18:02:02.755] Value: <not collected>
[18:02:02.755] Conditions captured: <none>
[18:02:02.755] Early signaling: FALSE
[18:02:02.755] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:02.755] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:02.770] Chunk #2 of 2 ... DONE
[18:02:02.771] Launching 2 futures (chunks) ... DONE
[18:02:02.771] Resolving 2 futures (chunks) ...
[18:02:02.771] resolve() on list ...
[18:02:02.772]  recursive: 0
[18:02:02.772]  length: 2
[18:02:02.772] 
[18:02:02.774] receiveMessageFromWorker() for ClusterFuture ...
[18:02:02.774] - Validating connection of MultisessionFuture
[18:02:02.775] - received message: FutureResult
[18:02:02.775] - Received FutureResult
[18:02:02.775] - Erased future from FutureRegistry
[18:02:02.776] result() for ClusterFuture ...
[18:02:02.776] - result already collected: FutureResult
[18:02:02.776] result() for ClusterFuture ... done
[18:02:02.777] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:02.777] Future #1
[18:02:02.777] result() for ClusterFuture ...
[18:02:02.778] - result already collected: FutureResult
[18:02:02.778] result() for ClusterFuture ... done
[18:02:02.778] result() for ClusterFuture ...
[18:02:02.778] - result already collected: FutureResult
[18:02:02.779] result() for ClusterFuture ... done
[18:02:02.779] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:02.779] - nx: 2
[18:02:02.780] - relay: TRUE
[18:02:02.780] - stdout: TRUE
[18:02:02.780] - signal: TRUE
[18:02:02.780] - resignal: FALSE
[18:02:02.781] - force: TRUE
[18:02:02.781] - relayed: [n=2] FALSE, FALSE
[18:02:02.781] - queued futures: [n=2] FALSE, FALSE
[18:02:02.782]  - until=1
[18:02:02.782]  - relaying element #1
[18:02:02.782] result() for ClusterFuture ...
[18:02:02.783] - result already collected: FutureResult
[18:02:02.783] result() for ClusterFuture ... done
[18:02:02.783] result() for ClusterFuture ...
[18:02:02.783] - result already collected: FutureResult
[18:02:02.784] result() for ClusterFuture ... done
[18:02:02.784] result() for ClusterFuture ...
[18:02:02.785] - result already collected: FutureResult
[18:02:02.785] result() for ClusterFuture ... done
[18:02:02.785] result() for ClusterFuture ...
[18:02:02.785] - result already collected: FutureResult
[18:02:02.786] result() for ClusterFuture ... done
[18:02:02.786] - relayed: [n=2] TRUE, FALSE
[18:02:02.786] - queued futures: [n=2] TRUE, FALSE
[18:02:02.787] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:02.787]  length: 1 (resolved future 1)
[18:02:02.897] receiveMessageFromWorker() for ClusterFuture ...
[18:02:02.898] - Validating connection of MultisessionFuture
[18:02:02.898] - received message: FutureResult
[18:02:02.898] - Received FutureResult
[18:02:02.899] - Erased future from FutureRegistry
[18:02:02.899] result() for ClusterFuture ...
[18:02:02.899] - result already collected: FutureResult
[18:02:02.899] result() for ClusterFuture ... done
[18:02:02.899] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:02.900] Future #2
[18:02:02.900] result() for ClusterFuture ...
[18:02:02.900] - result already collected: FutureResult
[18:02:02.900] result() for ClusterFuture ... done
[18:02:02.900] result() for ClusterFuture ...
[18:02:02.901] - result already collected: FutureResult
[18:02:02.901] result() for ClusterFuture ... done
[18:02:02.901] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:02.901] - nx: 2
[18:02:02.901] - relay: TRUE
[18:02:02.902] - stdout: TRUE
[18:02:02.902] - signal: TRUE
[18:02:02.902] - resignal: FALSE
[18:02:02.902] - force: TRUE
[18:02:02.902] - relayed: [n=2] TRUE, FALSE
[18:02:02.902] - queued futures: [n=2] TRUE, FALSE
[18:02:02.903]  - until=2
[18:02:02.903]  - relaying element #2
[18:02:02.903] result() for ClusterFuture ...
[18:02:02.903] - result already collected: FutureResult
[18:02:02.903] result() for ClusterFuture ... done
[18:02:02.904] result() for ClusterFuture ...
[18:02:02.904] - result already collected: FutureResult
[18:02:02.904] result() for ClusterFuture ... done
[18:02:02.904] result() for ClusterFuture ...
[18:02:02.904] - result already collected: FutureResult
[18:02:02.905] result() for ClusterFuture ... done
[18:02:02.905] result() for ClusterFuture ...
[18:02:02.905] - result already collected: FutureResult
[18:02:02.905] result() for ClusterFuture ... done
[18:02:02.905] - relayed: [n=2] TRUE, TRUE
[18:02:02.906] - queued futures: [n=2] TRUE, TRUE
[18:02:02.906] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:02.906]  length: 0 (resolved future 2)
[18:02:02.906] Relaying remaining futures
[18:02:02.906] signalConditionsASAP(NULL, pos=0) ...
[18:02:02.907] - nx: 2
[18:02:02.907] - relay: TRUE
[18:02:02.907] - stdout: TRUE
[18:02:02.907] - signal: TRUE
[18:02:02.907] - resignal: FALSE
[18:02:02.907] - force: TRUE
[18:02:02.908] - relayed: [n=2] TRUE, TRUE
[18:02:02.908] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:02.908] - relayed: [n=2] TRUE, TRUE
[18:02:02.908] - queued futures: [n=2] TRUE, TRUE
[18:02:02.908] signalConditionsASAP(NULL, pos=0) ... done
[18:02:02.909] resolve() on list ... DONE
[18:02:02.909] result() for ClusterFuture ...
[18:02:02.909] - result already collected: FutureResult
[18:02:02.909] result() for ClusterFuture ... done
[18:02:02.909] result() for ClusterFuture ...
[18:02:02.910] - result already collected: FutureResult
[18:02:02.910] result() for ClusterFuture ... done
[18:02:02.910] result() for ClusterFuture ...
[18:02:02.910] - result already collected: FutureResult
[18:02:02.910] result() for ClusterFuture ... done
[18:02:02.911] result() for ClusterFuture ...
[18:02:02.911] - result already collected: FutureResult
[18:02:02.911] result() for ClusterFuture ... done
[18:02:02.911]  - Number of value chunks collected: 2
[18:02:02.911] Resolving 2 futures (chunks) ... DONE
[18:02:02.912] Reducing values from 2 chunks ...
[18:02:02.912]  - Number of values collected after concatenation: 2
[18:02:02.912]  - Number of values expected: 2
[18:02:02.912] Reducing values from 2 chunks ... DONE
[18:02:02.912] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[18:02:02.914] future_lapply() ...
[18:02:02.923] Number of chunks: 2
[18:02:02.923] getGlobalsAndPackagesXApply() ...
[18:02:02.923]  - future.globals: TRUE
[18:02:02.924] getGlobalsAndPackages() ...
[18:02:02.924] Searching for globals...
[18:02:02.931] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[18:02:02.931] Searching for globals ... DONE
[18:02:02.932] Resolving globals: FALSE
[18:02:02.933] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[18:02:02.934] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:02.934] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:02.935] - packages: [1] ‘future.apply’
[18:02:02.935] getGlobalsAndPackages() ... DONE
[18:02:02.935]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:02.935]  - needed namespaces: [n=1] ‘future.apply’
[18:02:02.935] Finding globals ... DONE
[18:02:02.936]  - use_args: TRUE
[18:02:02.936]  - Getting '...' globals ...
[18:02:02.936] resolve() on list ...
[18:02:02.937]  recursive: 0
[18:02:02.937]  length: 1
[18:02:02.937]  elements: ‘...’
[18:02:02.937]  length: 0 (resolved future 1)
[18:02:02.937] resolve() on list ... DONE
[18:02:02.938]    - '...' content: [n=0] 
[18:02:02.938] List of 1
[18:02:02.938]  $ ...: list()
[18:02:02.938]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:02.938]  - attr(*, "where")=List of 1
[18:02:02.938]   ..$ ...:<environment: 0x6183bf6312e0> 
[18:02:02.938]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:02.938]  - attr(*, "resolved")= logi TRUE
[18:02:02.938]  - attr(*, "total_size")= num NA
[18:02:02.943]  - Getting '...' globals ... DONE
[18:02:02.943] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:02.943] List of 8
[18:02:02.943]  $ ...future.FUN:function (x, ...)  
[18:02:02.943]  $ x_FUN        :function (x)  
[18:02:02.943]  $ times        : int 0
[18:02:02.943]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:02.943]  $ stop_if_not  :function (...)  
[18:02:02.943]  $ dim          : NULL
[18:02:02.943]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:02:02.943]  $ ...          : list()
[18:02:02.943]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:02.943]  - attr(*, "where")=List of 8
[18:02:02.943]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:02.943]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:02.943]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:02.943]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:02.943]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:02.943]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:02.943]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:02.943]   ..$ ...          :<environment: 0x6183bf6312e0> 
[18:02:02.943]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:02.943]  - attr(*, "resolved")= logi FALSE
[18:02:02.943]  - attr(*, "total_size")= num 95472
[18:02:02.955] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:02.955] getGlobalsAndPackagesXApply() ... DONE
[18:02:02.956] Number of futures (= number of chunks): 2
[18:02:02.956] Launching 2 futures (chunks) ...
[18:02:02.956] Chunk #1 of 2 ...
[18:02:02.956]  - Finding globals in 'X' for chunk #1 ...
[18:02:02.956] getGlobalsAndPackages() ...
[18:02:02.957] Searching for globals...
[18:02:02.957] 
[18:02:02.957] Searching for globals ... DONE
[18:02:02.957] - globals: [0] <none>
[18:02:02.958] getGlobalsAndPackages() ... DONE
[18:02:02.958]    + additional globals found: [n=0] 
[18:02:02.958]    + additional namespaces needed: [n=0] 
[18:02:02.958]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:02.958]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:02.959]  - seeds: <none>
[18:02:02.959]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:02.959] getGlobalsAndPackages() ...
[18:02:02.959] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:02.959] Resolving globals: FALSE
[18:02:02.960] Tweak future expression to call with '...' arguments ...
[18:02:02.960] {
[18:02:02.960]     do.call(function(...) {
[18:02:02.960]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:02.960]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:02.960]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:02.960]             on.exit(options(oopts), add = TRUE)
[18:02:02.960]         }
[18:02:02.960]         {
[18:02:02.960]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:02.960]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:02.960]                 ...future.FUN(...future.X_jj, ...)
[18:02:02.960]             })
[18:02:02.960]         }
[18:02:02.960]     }, args = future.call.arguments)
[18:02:02.960] }
[18:02:02.960] Tweak future expression to call with '...' arguments ... DONE
[18:02:02.961] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:02.962] - packages: [1] ‘future.apply’
[18:02:02.962] getGlobalsAndPackages() ... DONE
[18:02:02.962] run() for ‘Future’ ...
[18:02:02.963] - state: ‘created’
[18:02:02.963] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:02.987] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:02.987] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:02.987]   - Field: ‘node’
[18:02:02.988]   - Field: ‘label’
[18:02:02.988]   - Field: ‘local’
[18:02:02.988]   - Field: ‘owner’
[18:02:02.988]   - Field: ‘envir’
[18:02:02.989]   - Field: ‘workers’
[18:02:02.989]   - Field: ‘packages’
[18:02:02.989]   - Field: ‘gc’
[18:02:02.989]   - Field: ‘conditions’
[18:02:02.989]   - Field: ‘persistent’
[18:02:02.990]   - Field: ‘expr’
[18:02:02.990]   - Field: ‘uuid’
[18:02:02.990]   - Field: ‘seed’
[18:02:02.990]   - Field: ‘version’
[18:02:02.990]   - Field: ‘result’
[18:02:02.990]   - Field: ‘asynchronous’
[18:02:02.991]   - Field: ‘calls’
[18:02:02.991]   - Field: ‘globals’
[18:02:02.991]   - Field: ‘stdout’
[18:02:02.991]   - Field: ‘earlySignal’
[18:02:02.991]   - Field: ‘lazy’
[18:02:02.992]   - Field: ‘state’
[18:02:02.992] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:02.992] - Launch lazy future ...
[18:02:02.993] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:02.993] Packages needed by future strategies (n = 0): <none>
[18:02:02.994] {
[18:02:02.994]     {
[18:02:02.994]         {
[18:02:02.994]             ...future.startTime <- base::Sys.time()
[18:02:02.994]             {
[18:02:02.994]                 {
[18:02:02.994]                   {
[18:02:02.994]                     {
[18:02:02.994]                       {
[18:02:02.994]                         base::local({
[18:02:02.994]                           has_future <- base::requireNamespace("future", 
[18:02:02.994]                             quietly = TRUE)
[18:02:02.994]                           if (has_future) {
[18:02:02.994]                             ns <- base::getNamespace("future")
[18:02:02.994]                             version <- ns[[".package"]][["version"]]
[18:02:02.994]                             if (is.null(version)) 
[18:02:02.994]                               version <- utils::packageVersion("future")
[18:02:02.994]                           }
[18:02:02.994]                           else {
[18:02:02.994]                             version <- NULL
[18:02:02.994]                           }
[18:02:02.994]                           if (!has_future || version < "1.8.0") {
[18:02:02.994]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:02.994]                               "", base::R.version$version.string), 
[18:02:02.994]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:02.994]                                 base::R.version$platform, 8 * 
[18:02:02.994]                                   base::.Machine$sizeof.pointer), 
[18:02:02.994]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:02.994]                                 "release", "version")], collapse = " "), 
[18:02:02.994]                               hostname = base::Sys.info()[["nodename"]])
[18:02:02.994]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:02.994]                               info)
[18:02:02.994]                             info <- base::paste(info, collapse = "; ")
[18:02:02.994]                             if (!has_future) {
[18:02:02.994]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:02.994]                                 info)
[18:02:02.994]                             }
[18:02:02.994]                             else {
[18:02:02.994]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:02.994]                                 info, version)
[18:02:02.994]                             }
[18:02:02.994]                             base::stop(msg)
[18:02:02.994]                           }
[18:02:02.994]                         })
[18:02:02.994]                       }
[18:02:02.994]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:02.994]                       base::options(mc.cores = 1L)
[18:02:02.994]                     }
[18:02:02.994]                     base::local({
[18:02:02.994]                       for (pkg in "future.apply") {
[18:02:02.994]                         base::loadNamespace(pkg)
[18:02:02.994]                         base::library(pkg, character.only = TRUE)
[18:02:02.994]                       }
[18:02:02.994]                     })
[18:02:02.994]                   }
[18:02:02.994]                   ...future.strategy.old <- future::plan("list")
[18:02:02.994]                   options(future.plan = NULL)
[18:02:02.994]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:02.994]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:02.994]                 }
[18:02:02.994]                 ...future.workdir <- getwd()
[18:02:02.994]             }
[18:02:02.994]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:02.994]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:02.994]         }
[18:02:02.994]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:02.994]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:02.994]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:02.994]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:02.994]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:02.994]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:02.994]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:02.994]             base::names(...future.oldOptions))
[18:02:02.994]     }
[18:02:02.994]     if (FALSE) {
[18:02:02.994]     }
[18:02:02.994]     else {
[18:02:02.994]         if (TRUE) {
[18:02:02.994]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:02.994]                 open = "w")
[18:02:02.994]         }
[18:02:02.994]         else {
[18:02:02.994]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:02.994]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:02.994]         }
[18:02:02.994]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:02.994]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:02.994]             base::sink(type = "output", split = FALSE)
[18:02:02.994]             base::close(...future.stdout)
[18:02:02.994]         }, add = TRUE)
[18:02:02.994]     }
[18:02:02.994]     ...future.frame <- base::sys.nframe()
[18:02:02.994]     ...future.conditions <- base::list()
[18:02:02.994]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:02.994]     if (FALSE) {
[18:02:02.994]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:02.994]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:02.994]     }
[18:02:02.994]     ...future.result <- base::tryCatch({
[18:02:02.994]         base::withCallingHandlers({
[18:02:02.994]             ...future.value <- base::withVisible(base::local({
[18:02:02.994]                 ...future.makeSendCondition <- base::local({
[18:02:02.994]                   sendCondition <- NULL
[18:02:02.994]                   function(frame = 1L) {
[18:02:02.994]                     if (is.function(sendCondition)) 
[18:02:02.994]                       return(sendCondition)
[18:02:02.994]                     ns <- getNamespace("parallel")
[18:02:02.994]                     if (exists("sendData", mode = "function", 
[18:02:02.994]                       envir = ns)) {
[18:02:02.994]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:02.994]                         envir = ns)
[18:02:02.994]                       envir <- sys.frame(frame)
[18:02:02.994]                       master <- NULL
[18:02:02.994]                       while (!identical(envir, .GlobalEnv) && 
[18:02:02.994]                         !identical(envir, emptyenv())) {
[18:02:02.994]                         if (exists("master", mode = "list", envir = envir, 
[18:02:02.994]                           inherits = FALSE)) {
[18:02:02.994]                           master <- get("master", mode = "list", 
[18:02:02.994]                             envir = envir, inherits = FALSE)
[18:02:02.994]                           if (inherits(master, c("SOCKnode", 
[18:02:02.994]                             "SOCK0node"))) {
[18:02:02.994]                             sendCondition <<- function(cond) {
[18:02:02.994]                               data <- list(type = "VALUE", value = cond, 
[18:02:02.994]                                 success = TRUE)
[18:02:02.994]                               parallel_sendData(master, data)
[18:02:02.994]                             }
[18:02:02.994]                             return(sendCondition)
[18:02:02.994]                           }
[18:02:02.994]                         }
[18:02:02.994]                         frame <- frame + 1L
[18:02:02.994]                         envir <- sys.frame(frame)
[18:02:02.994]                       }
[18:02:02.994]                     }
[18:02:02.994]                     sendCondition <<- function(cond) NULL
[18:02:02.994]                   }
[18:02:02.994]                 })
[18:02:02.994]                 withCallingHandlers({
[18:02:02.994]                   {
[18:02:02.994]                     do.call(function(...) {
[18:02:02.994]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:02.994]                       if (!identical(...future.globals.maxSize.org, 
[18:02:02.994]                         ...future.globals.maxSize)) {
[18:02:02.994]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:02.994]                         on.exit(options(oopts), add = TRUE)
[18:02:02.994]                       }
[18:02:02.994]                       {
[18:02:02.994]                         lapply(seq_along(...future.elements_ii), 
[18:02:02.994]                           FUN = function(jj) {
[18:02:02.994]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:02.994]                             ...future.FUN(...future.X_jj, ...)
[18:02:02.994]                           })
[18:02:02.994]                       }
[18:02:02.994]                     }, args = future.call.arguments)
[18:02:02.994]                   }
[18:02:02.994]                 }, immediateCondition = function(cond) {
[18:02:02.994]                   sendCondition <- ...future.makeSendCondition()
[18:02:02.994]                   sendCondition(cond)
[18:02:02.994]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:02.994]                   {
[18:02:02.994]                     inherits <- base::inherits
[18:02:02.994]                     invokeRestart <- base::invokeRestart
[18:02:02.994]                     is.null <- base::is.null
[18:02:02.994]                     muffled <- FALSE
[18:02:02.994]                     if (inherits(cond, "message")) {
[18:02:02.994]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:02.994]                       if (muffled) 
[18:02:02.994]                         invokeRestart("muffleMessage")
[18:02:02.994]                     }
[18:02:02.994]                     else if (inherits(cond, "warning")) {
[18:02:02.994]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:02.994]                       if (muffled) 
[18:02:02.994]                         invokeRestart("muffleWarning")
[18:02:02.994]                     }
[18:02:02.994]                     else if (inherits(cond, "condition")) {
[18:02:02.994]                       if (!is.null(pattern)) {
[18:02:02.994]                         computeRestarts <- base::computeRestarts
[18:02:02.994]                         grepl <- base::grepl
[18:02:02.994]                         restarts <- computeRestarts(cond)
[18:02:02.994]                         for (restart in restarts) {
[18:02:02.994]                           name <- restart$name
[18:02:02.994]                           if (is.null(name)) 
[18:02:02.994]                             next
[18:02:02.994]                           if (!grepl(pattern, name)) 
[18:02:02.994]                             next
[18:02:02.994]                           invokeRestart(restart)
[18:02:02.994]                           muffled <- TRUE
[18:02:02.994]                           break
[18:02:02.994]                         }
[18:02:02.994]                       }
[18:02:02.994]                     }
[18:02:02.994]                     invisible(muffled)
[18:02:02.994]                   }
[18:02:02.994]                   muffleCondition(cond)
[18:02:02.994]                 })
[18:02:02.994]             }))
[18:02:02.994]             future::FutureResult(value = ...future.value$value, 
[18:02:02.994]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:02.994]                   ...future.rng), globalenv = if (FALSE) 
[18:02:02.994]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:02.994]                     ...future.globalenv.names))
[18:02:02.994]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:02.994]         }, condition = base::local({
[18:02:02.994]             c <- base::c
[18:02:02.994]             inherits <- base::inherits
[18:02:02.994]             invokeRestart <- base::invokeRestart
[18:02:02.994]             length <- base::length
[18:02:02.994]             list <- base::list
[18:02:02.994]             seq.int <- base::seq.int
[18:02:02.994]             signalCondition <- base::signalCondition
[18:02:02.994]             sys.calls <- base::sys.calls
[18:02:02.994]             `[[` <- base::`[[`
[18:02:02.994]             `+` <- base::`+`
[18:02:02.994]             `<<-` <- base::`<<-`
[18:02:02.994]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:02.994]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:02.994]                   3L)]
[18:02:02.994]             }
[18:02:02.994]             function(cond) {
[18:02:02.994]                 is_error <- inherits(cond, "error")
[18:02:02.994]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:02.994]                   NULL)
[18:02:02.994]                 if (is_error) {
[18:02:02.994]                   sessionInformation <- function() {
[18:02:02.994]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:02.994]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:02.994]                       search = base::search(), system = base::Sys.info())
[18:02:02.994]                   }
[18:02:02.994]                   ...future.conditions[[length(...future.conditions) + 
[18:02:02.994]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:02.994]                     cond$call), session = sessionInformation(), 
[18:02:02.994]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:02.994]                   signalCondition(cond)
[18:02:02.994]                 }
[18:02:02.994]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:02.994]                 "immediateCondition"))) {
[18:02:02.994]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:02.994]                   ...future.conditions[[length(...future.conditions) + 
[18:02:02.994]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:02.994]                   if (TRUE && !signal) {
[18:02:02.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:02.994]                     {
[18:02:02.994]                       inherits <- base::inherits
[18:02:02.994]                       invokeRestart <- base::invokeRestart
[18:02:02.994]                       is.null <- base::is.null
[18:02:02.994]                       muffled <- FALSE
[18:02:02.994]                       if (inherits(cond, "message")) {
[18:02:02.994]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:02.994]                         if (muffled) 
[18:02:02.994]                           invokeRestart("muffleMessage")
[18:02:02.994]                       }
[18:02:02.994]                       else if (inherits(cond, "warning")) {
[18:02:02.994]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:02.994]                         if (muffled) 
[18:02:02.994]                           invokeRestart("muffleWarning")
[18:02:02.994]                       }
[18:02:02.994]                       else if (inherits(cond, "condition")) {
[18:02:02.994]                         if (!is.null(pattern)) {
[18:02:02.994]                           computeRestarts <- base::computeRestarts
[18:02:02.994]                           grepl <- base::grepl
[18:02:02.994]                           restarts <- computeRestarts(cond)
[18:02:02.994]                           for (restart in restarts) {
[18:02:02.994]                             name <- restart$name
[18:02:02.994]                             if (is.null(name)) 
[18:02:02.994]                               next
[18:02:02.994]                             if (!grepl(pattern, name)) 
[18:02:02.994]                               next
[18:02:02.994]                             invokeRestart(restart)
[18:02:02.994]                             muffled <- TRUE
[18:02:02.994]                             break
[18:02:02.994]                           }
[18:02:02.994]                         }
[18:02:02.994]                       }
[18:02:02.994]                       invisible(muffled)
[18:02:02.994]                     }
[18:02:02.994]                     muffleCondition(cond, pattern = "^muffle")
[18:02:02.994]                   }
[18:02:02.994]                 }
[18:02:02.994]                 else {
[18:02:02.994]                   if (TRUE) {
[18:02:02.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:02.994]                     {
[18:02:02.994]                       inherits <- base::inherits
[18:02:02.994]                       invokeRestart <- base::invokeRestart
[18:02:02.994]                       is.null <- base::is.null
[18:02:02.994]                       muffled <- FALSE
[18:02:02.994]                       if (inherits(cond, "message")) {
[18:02:02.994]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:02.994]                         if (muffled) 
[18:02:02.994]                           invokeRestart("muffleMessage")
[18:02:02.994]                       }
[18:02:02.994]                       else if (inherits(cond, "warning")) {
[18:02:02.994]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:02.994]                         if (muffled) 
[18:02:02.994]                           invokeRestart("muffleWarning")
[18:02:02.994]                       }
[18:02:02.994]                       else if (inherits(cond, "condition")) {
[18:02:02.994]                         if (!is.null(pattern)) {
[18:02:02.994]                           computeRestarts <- base::computeRestarts
[18:02:02.994]                           grepl <- base::grepl
[18:02:02.994]                           restarts <- computeRestarts(cond)
[18:02:02.994]                           for (restart in restarts) {
[18:02:02.994]                             name <- restart$name
[18:02:02.994]                             if (is.null(name)) 
[18:02:02.994]                               next
[18:02:02.994]                             if (!grepl(pattern, name)) 
[18:02:02.994]                               next
[18:02:02.994]                             invokeRestart(restart)
[18:02:02.994]                             muffled <- TRUE
[18:02:02.994]                             break
[18:02:02.994]                           }
[18:02:02.994]                         }
[18:02:02.994]                       }
[18:02:02.994]                       invisible(muffled)
[18:02:02.994]                     }
[18:02:02.994]                     muffleCondition(cond, pattern = "^muffle")
[18:02:02.994]                   }
[18:02:02.994]                 }
[18:02:02.994]             }
[18:02:02.994]         }))
[18:02:02.994]     }, error = function(ex) {
[18:02:02.994]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:02.994]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:02.994]                 ...future.rng), started = ...future.startTime, 
[18:02:02.994]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:02.994]             version = "1.8"), class = "FutureResult")
[18:02:02.994]     }, finally = {
[18:02:02.994]         if (!identical(...future.workdir, getwd())) 
[18:02:02.994]             setwd(...future.workdir)
[18:02:02.994]         {
[18:02:02.994]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:02.994]                 ...future.oldOptions$nwarnings <- NULL
[18:02:02.994]             }
[18:02:02.994]             base::options(...future.oldOptions)
[18:02:02.994]             if (.Platform$OS.type == "windows") {
[18:02:02.994]                 old_names <- names(...future.oldEnvVars)
[18:02:02.994]                 envs <- base::Sys.getenv()
[18:02:02.994]                 names <- names(envs)
[18:02:02.994]                 common <- intersect(names, old_names)
[18:02:02.994]                 added <- setdiff(names, old_names)
[18:02:02.994]                 removed <- setdiff(old_names, names)
[18:02:02.994]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:02.994]                   envs[common]]
[18:02:02.994]                 NAMES <- toupper(changed)
[18:02:02.994]                 args <- list()
[18:02:02.994]                 for (kk in seq_along(NAMES)) {
[18:02:02.994]                   name <- changed[[kk]]
[18:02:02.994]                   NAME <- NAMES[[kk]]
[18:02:02.994]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:02.994]                     next
[18:02:02.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:02.994]                 }
[18:02:02.994]                 NAMES <- toupper(added)
[18:02:02.994]                 for (kk in seq_along(NAMES)) {
[18:02:02.994]                   name <- added[[kk]]
[18:02:02.994]                   NAME <- NAMES[[kk]]
[18:02:02.994]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:02.994]                     next
[18:02:02.994]                   args[[name]] <- ""
[18:02:02.994]                 }
[18:02:02.994]                 NAMES <- toupper(removed)
[18:02:02.994]                 for (kk in seq_along(NAMES)) {
[18:02:02.994]                   name <- removed[[kk]]
[18:02:02.994]                   NAME <- NAMES[[kk]]
[18:02:02.994]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:02.994]                     next
[18:02:02.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:02.994]                 }
[18:02:02.994]                 if (length(args) > 0) 
[18:02:02.994]                   base::do.call(base::Sys.setenv, args = args)
[18:02:02.994]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:02.994]             }
[18:02:02.994]             else {
[18:02:02.994]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:02.994]             }
[18:02:02.994]             {
[18:02:02.994]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:02.994]                   0L) {
[18:02:02.994]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:02.994]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:02.994]                   base::options(opts)
[18:02:02.994]                 }
[18:02:02.994]                 {
[18:02:02.994]                   {
[18:02:02.994]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:02.994]                     NULL
[18:02:02.994]                   }
[18:02:02.994]                   options(future.plan = NULL)
[18:02:02.994]                   if (is.na(NA_character_)) 
[18:02:02.994]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:02.994]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:02.994]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:02.994]                     .init = FALSE)
[18:02:02.994]                 }
[18:02:02.994]             }
[18:02:02.994]         }
[18:02:02.994]     })
[18:02:02.994]     if (TRUE) {
[18:02:02.994]         base::sink(type = "output", split = FALSE)
[18:02:02.994]         if (TRUE) {
[18:02:02.994]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:02.994]         }
[18:02:02.994]         else {
[18:02:02.994]             ...future.result["stdout"] <- base::list(NULL)
[18:02:02.994]         }
[18:02:02.994]         base::close(...future.stdout)
[18:02:02.994]         ...future.stdout <- NULL
[18:02:02.994]     }
[18:02:02.994]     ...future.result$conditions <- ...future.conditions
[18:02:02.994]     ...future.result$finished <- base::Sys.time()
[18:02:02.994]     ...future.result
[18:02:02.994] }
[18:02:02.999] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[18:02:03.000] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[18:02:03.041] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[18:02:03.042] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[18:02:03.043] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[18:02:03.043] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[18:02:03.044] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[18:02:03.044] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[18:02:03.086] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[18:02:03.087] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[18:02:03.129] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[18:02:03.129] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[18:02:03.130] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[18:02:03.131] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[18:02:03.132] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[18:02:03.133] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:03.134] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:03.134] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[18:02:03.136] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[18:02:03.136] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:03.137] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:03.138] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:03.139] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:03.139] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[18:02:03.141] MultisessionFuture started
[18:02:03.141] - Launch lazy future ... done
[18:02:03.141] run() for ‘MultisessionFuture’ ... done
[18:02:03.142] Created future:
[18:02:03.142] MultisessionFuture:
[18:02:03.142] Label: ‘future_vapply-1’
[18:02:03.142] Expression:
[18:02:03.142] {
[18:02:03.142]     do.call(function(...) {
[18:02:03.142]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:03.142]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:03.142]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:03.142]             on.exit(options(oopts), add = TRUE)
[18:02:03.142]         }
[18:02:03.142]         {
[18:02:03.142]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:03.142]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:03.142]                 ...future.FUN(...future.X_jj, ...)
[18:02:03.142]             })
[18:02:03.142]         }
[18:02:03.142]     }, args = future.call.arguments)
[18:02:03.142] }
[18:02:03.142] Lazy evaluation: FALSE
[18:02:03.142] Asynchronous evaluation: TRUE
[18:02:03.142] Local evaluation: TRUE
[18:02:03.142] Environment: R_GlobalEnv
[18:02:03.142] Capture standard output: TRUE
[18:02:03.142] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:03.142] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:03.142] Packages: 1 packages (‘future.apply’)
[18:02:03.142] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:03.142] Resolved: FALSE
[18:02:03.142] Value: <not collected>
[18:02:03.142] Conditions captured: <none>
[18:02:03.142] Early signaling: FALSE
[18:02:03.142] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:03.142] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:03.157] Chunk #1 of 2 ... DONE
[18:02:03.157] Chunk #2 of 2 ...
[18:02:03.158]  - Finding globals in 'X' for chunk #2 ...
[18:02:03.158] getGlobalsAndPackages() ...
[18:02:03.158] Searching for globals...
[18:02:03.159] 
[18:02:03.160] Searching for globals ... DONE
[18:02:03.160] - globals: [0] <none>
[18:02:03.160] getGlobalsAndPackages() ... DONE
[18:02:03.160]    + additional globals found: [n=0] 
[18:02:03.161]    + additional namespaces needed: [n=0] 
[18:02:03.161]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:03.161]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:03.162]  - seeds: <none>
[18:02:03.162]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:03.162] getGlobalsAndPackages() ...
[18:02:03.163] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:03.163] Resolving globals: FALSE
[18:02:03.164] Tweak future expression to call with '...' arguments ...
[18:02:03.164] {
[18:02:03.164]     do.call(function(...) {
[18:02:03.164]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:03.164]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:03.164]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:03.164]             on.exit(options(oopts), add = TRUE)
[18:02:03.164]         }
[18:02:03.164]         {
[18:02:03.164]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:03.164]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:03.164]                 ...future.FUN(...future.X_jj, ...)
[18:02:03.164]             })
[18:02:03.164]         }
[18:02:03.164]     }, args = future.call.arguments)
[18:02:03.164] }
[18:02:03.165] Tweak future expression to call with '...' arguments ... DONE
[18:02:03.167] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:03.167] - packages: [1] ‘future.apply’
[18:02:03.167] getGlobalsAndPackages() ... DONE
[18:02:03.168] run() for ‘Future’ ...
[18:02:03.169] - state: ‘created’
[18:02:03.169] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:03.200] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:03.200] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:03.200]   - Field: ‘node’
[18:02:03.201]   - Field: ‘label’
[18:02:03.201]   - Field: ‘local’
[18:02:03.201]   - Field: ‘owner’
[18:02:03.201]   - Field: ‘envir’
[18:02:03.201]   - Field: ‘workers’
[18:02:03.202]   - Field: ‘packages’
[18:02:03.202]   - Field: ‘gc’
[18:02:03.202]   - Field: ‘conditions’
[18:02:03.202]   - Field: ‘persistent’
[18:02:03.202]   - Field: ‘expr’
[18:02:03.203]   - Field: ‘uuid’
[18:02:03.203]   - Field: ‘seed’
[18:02:03.203]   - Field: ‘version’
[18:02:03.203]   - Field: ‘result’
[18:02:03.203]   - Field: ‘asynchronous’
[18:02:03.204]   - Field: ‘calls’
[18:02:03.204]   - Field: ‘globals’
[18:02:03.204]   - Field: ‘stdout’
[18:02:03.204]   - Field: ‘earlySignal’
[18:02:03.204]   - Field: ‘lazy’
[18:02:03.205]   - Field: ‘state’
[18:02:03.205] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:03.205] - Launch lazy future ...
[18:02:03.205] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:03.206] Packages needed by future strategies (n = 0): <none>
[18:02:03.207] {
[18:02:03.207]     {
[18:02:03.207]         {
[18:02:03.207]             ...future.startTime <- base::Sys.time()
[18:02:03.207]             {
[18:02:03.207]                 {
[18:02:03.207]                   {
[18:02:03.207]                     {
[18:02:03.207]                       {
[18:02:03.207]                         base::local({
[18:02:03.207]                           has_future <- base::requireNamespace("future", 
[18:02:03.207]                             quietly = TRUE)
[18:02:03.207]                           if (has_future) {
[18:02:03.207]                             ns <- base::getNamespace("future")
[18:02:03.207]                             version <- ns[[".package"]][["version"]]
[18:02:03.207]                             if (is.null(version)) 
[18:02:03.207]                               version <- utils::packageVersion("future")
[18:02:03.207]                           }
[18:02:03.207]                           else {
[18:02:03.207]                             version <- NULL
[18:02:03.207]                           }
[18:02:03.207]                           if (!has_future || version < "1.8.0") {
[18:02:03.207]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:03.207]                               "", base::R.version$version.string), 
[18:02:03.207]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:03.207]                                 base::R.version$platform, 8 * 
[18:02:03.207]                                   base::.Machine$sizeof.pointer), 
[18:02:03.207]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:03.207]                                 "release", "version")], collapse = " "), 
[18:02:03.207]                               hostname = base::Sys.info()[["nodename"]])
[18:02:03.207]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:03.207]                               info)
[18:02:03.207]                             info <- base::paste(info, collapse = "; ")
[18:02:03.207]                             if (!has_future) {
[18:02:03.207]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:03.207]                                 info)
[18:02:03.207]                             }
[18:02:03.207]                             else {
[18:02:03.207]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:03.207]                                 info, version)
[18:02:03.207]                             }
[18:02:03.207]                             base::stop(msg)
[18:02:03.207]                           }
[18:02:03.207]                         })
[18:02:03.207]                       }
[18:02:03.207]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:03.207]                       base::options(mc.cores = 1L)
[18:02:03.207]                     }
[18:02:03.207]                     base::local({
[18:02:03.207]                       for (pkg in "future.apply") {
[18:02:03.207]                         base::loadNamespace(pkg)
[18:02:03.207]                         base::library(pkg, character.only = TRUE)
[18:02:03.207]                       }
[18:02:03.207]                     })
[18:02:03.207]                   }
[18:02:03.207]                   ...future.strategy.old <- future::plan("list")
[18:02:03.207]                   options(future.plan = NULL)
[18:02:03.207]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:03.207]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:03.207]                 }
[18:02:03.207]                 ...future.workdir <- getwd()
[18:02:03.207]             }
[18:02:03.207]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:03.207]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:03.207]         }
[18:02:03.207]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:03.207]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:03.207]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:03.207]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:03.207]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:03.207]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:03.207]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:03.207]             base::names(...future.oldOptions))
[18:02:03.207]     }
[18:02:03.207]     if (FALSE) {
[18:02:03.207]     }
[18:02:03.207]     else {
[18:02:03.207]         if (TRUE) {
[18:02:03.207]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:03.207]                 open = "w")
[18:02:03.207]         }
[18:02:03.207]         else {
[18:02:03.207]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:03.207]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:03.207]         }
[18:02:03.207]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:03.207]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:03.207]             base::sink(type = "output", split = FALSE)
[18:02:03.207]             base::close(...future.stdout)
[18:02:03.207]         }, add = TRUE)
[18:02:03.207]     }
[18:02:03.207]     ...future.frame <- base::sys.nframe()
[18:02:03.207]     ...future.conditions <- base::list()
[18:02:03.207]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:03.207]     if (FALSE) {
[18:02:03.207]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:03.207]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:03.207]     }
[18:02:03.207]     ...future.result <- base::tryCatch({
[18:02:03.207]         base::withCallingHandlers({
[18:02:03.207]             ...future.value <- base::withVisible(base::local({
[18:02:03.207]                 ...future.makeSendCondition <- base::local({
[18:02:03.207]                   sendCondition <- NULL
[18:02:03.207]                   function(frame = 1L) {
[18:02:03.207]                     if (is.function(sendCondition)) 
[18:02:03.207]                       return(sendCondition)
[18:02:03.207]                     ns <- getNamespace("parallel")
[18:02:03.207]                     if (exists("sendData", mode = "function", 
[18:02:03.207]                       envir = ns)) {
[18:02:03.207]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:03.207]                         envir = ns)
[18:02:03.207]                       envir <- sys.frame(frame)
[18:02:03.207]                       master <- NULL
[18:02:03.207]                       while (!identical(envir, .GlobalEnv) && 
[18:02:03.207]                         !identical(envir, emptyenv())) {
[18:02:03.207]                         if (exists("master", mode = "list", envir = envir, 
[18:02:03.207]                           inherits = FALSE)) {
[18:02:03.207]                           master <- get("master", mode = "list", 
[18:02:03.207]                             envir = envir, inherits = FALSE)
[18:02:03.207]                           if (inherits(master, c("SOCKnode", 
[18:02:03.207]                             "SOCK0node"))) {
[18:02:03.207]                             sendCondition <<- function(cond) {
[18:02:03.207]                               data <- list(type = "VALUE", value = cond, 
[18:02:03.207]                                 success = TRUE)
[18:02:03.207]                               parallel_sendData(master, data)
[18:02:03.207]                             }
[18:02:03.207]                             return(sendCondition)
[18:02:03.207]                           }
[18:02:03.207]                         }
[18:02:03.207]                         frame <- frame + 1L
[18:02:03.207]                         envir <- sys.frame(frame)
[18:02:03.207]                       }
[18:02:03.207]                     }
[18:02:03.207]                     sendCondition <<- function(cond) NULL
[18:02:03.207]                   }
[18:02:03.207]                 })
[18:02:03.207]                 withCallingHandlers({
[18:02:03.207]                   {
[18:02:03.207]                     do.call(function(...) {
[18:02:03.207]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:03.207]                       if (!identical(...future.globals.maxSize.org, 
[18:02:03.207]                         ...future.globals.maxSize)) {
[18:02:03.207]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:03.207]                         on.exit(options(oopts), add = TRUE)
[18:02:03.207]                       }
[18:02:03.207]                       {
[18:02:03.207]                         lapply(seq_along(...future.elements_ii), 
[18:02:03.207]                           FUN = function(jj) {
[18:02:03.207]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:03.207]                             ...future.FUN(...future.X_jj, ...)
[18:02:03.207]                           })
[18:02:03.207]                       }
[18:02:03.207]                     }, args = future.call.arguments)
[18:02:03.207]                   }
[18:02:03.207]                 }, immediateCondition = function(cond) {
[18:02:03.207]                   sendCondition <- ...future.makeSendCondition()
[18:02:03.207]                   sendCondition(cond)
[18:02:03.207]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:03.207]                   {
[18:02:03.207]                     inherits <- base::inherits
[18:02:03.207]                     invokeRestart <- base::invokeRestart
[18:02:03.207]                     is.null <- base::is.null
[18:02:03.207]                     muffled <- FALSE
[18:02:03.207]                     if (inherits(cond, "message")) {
[18:02:03.207]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:03.207]                       if (muffled) 
[18:02:03.207]                         invokeRestart("muffleMessage")
[18:02:03.207]                     }
[18:02:03.207]                     else if (inherits(cond, "warning")) {
[18:02:03.207]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:03.207]                       if (muffled) 
[18:02:03.207]                         invokeRestart("muffleWarning")
[18:02:03.207]                     }
[18:02:03.207]                     else if (inherits(cond, "condition")) {
[18:02:03.207]                       if (!is.null(pattern)) {
[18:02:03.207]                         computeRestarts <- base::computeRestarts
[18:02:03.207]                         grepl <- base::grepl
[18:02:03.207]                         restarts <- computeRestarts(cond)
[18:02:03.207]                         for (restart in restarts) {
[18:02:03.207]                           name <- restart$name
[18:02:03.207]                           if (is.null(name)) 
[18:02:03.207]                             next
[18:02:03.207]                           if (!grepl(pattern, name)) 
[18:02:03.207]                             next
[18:02:03.207]                           invokeRestart(restart)
[18:02:03.207]                           muffled <- TRUE
[18:02:03.207]                           break
[18:02:03.207]                         }
[18:02:03.207]                       }
[18:02:03.207]                     }
[18:02:03.207]                     invisible(muffled)
[18:02:03.207]                   }
[18:02:03.207]                   muffleCondition(cond)
[18:02:03.207]                 })
[18:02:03.207]             }))
[18:02:03.207]             future::FutureResult(value = ...future.value$value, 
[18:02:03.207]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:03.207]                   ...future.rng), globalenv = if (FALSE) 
[18:02:03.207]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:03.207]                     ...future.globalenv.names))
[18:02:03.207]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:03.207]         }, condition = base::local({
[18:02:03.207]             c <- base::c
[18:02:03.207]             inherits <- base::inherits
[18:02:03.207]             invokeRestart <- base::invokeRestart
[18:02:03.207]             length <- base::length
[18:02:03.207]             list <- base::list
[18:02:03.207]             seq.int <- base::seq.int
[18:02:03.207]             signalCondition <- base::signalCondition
[18:02:03.207]             sys.calls <- base::sys.calls
[18:02:03.207]             `[[` <- base::`[[`
[18:02:03.207]             `+` <- base::`+`
[18:02:03.207]             `<<-` <- base::`<<-`
[18:02:03.207]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:03.207]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:03.207]                   3L)]
[18:02:03.207]             }
[18:02:03.207]             function(cond) {
[18:02:03.207]                 is_error <- inherits(cond, "error")
[18:02:03.207]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:03.207]                   NULL)
[18:02:03.207]                 if (is_error) {
[18:02:03.207]                   sessionInformation <- function() {
[18:02:03.207]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:03.207]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:03.207]                       search = base::search(), system = base::Sys.info())
[18:02:03.207]                   }
[18:02:03.207]                   ...future.conditions[[length(...future.conditions) + 
[18:02:03.207]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:03.207]                     cond$call), session = sessionInformation(), 
[18:02:03.207]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:03.207]                   signalCondition(cond)
[18:02:03.207]                 }
[18:02:03.207]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:03.207]                 "immediateCondition"))) {
[18:02:03.207]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:03.207]                   ...future.conditions[[length(...future.conditions) + 
[18:02:03.207]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:03.207]                   if (TRUE && !signal) {
[18:02:03.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:03.207]                     {
[18:02:03.207]                       inherits <- base::inherits
[18:02:03.207]                       invokeRestart <- base::invokeRestart
[18:02:03.207]                       is.null <- base::is.null
[18:02:03.207]                       muffled <- FALSE
[18:02:03.207]                       if (inherits(cond, "message")) {
[18:02:03.207]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:03.207]                         if (muffled) 
[18:02:03.207]                           invokeRestart("muffleMessage")
[18:02:03.207]                       }
[18:02:03.207]                       else if (inherits(cond, "warning")) {
[18:02:03.207]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:03.207]                         if (muffled) 
[18:02:03.207]                           invokeRestart("muffleWarning")
[18:02:03.207]                       }
[18:02:03.207]                       else if (inherits(cond, "condition")) {
[18:02:03.207]                         if (!is.null(pattern)) {
[18:02:03.207]                           computeRestarts <- base::computeRestarts
[18:02:03.207]                           grepl <- base::grepl
[18:02:03.207]                           restarts <- computeRestarts(cond)
[18:02:03.207]                           for (restart in restarts) {
[18:02:03.207]                             name <- restart$name
[18:02:03.207]                             if (is.null(name)) 
[18:02:03.207]                               next
[18:02:03.207]                             if (!grepl(pattern, name)) 
[18:02:03.207]                               next
[18:02:03.207]                             invokeRestart(restart)
[18:02:03.207]                             muffled <- TRUE
[18:02:03.207]                             break
[18:02:03.207]                           }
[18:02:03.207]                         }
[18:02:03.207]                       }
[18:02:03.207]                       invisible(muffled)
[18:02:03.207]                     }
[18:02:03.207]                     muffleCondition(cond, pattern = "^muffle")
[18:02:03.207]                   }
[18:02:03.207]                 }
[18:02:03.207]                 else {
[18:02:03.207]                   if (TRUE) {
[18:02:03.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:03.207]                     {
[18:02:03.207]                       inherits <- base::inherits
[18:02:03.207]                       invokeRestart <- base::invokeRestart
[18:02:03.207]                       is.null <- base::is.null
[18:02:03.207]                       muffled <- FALSE
[18:02:03.207]                       if (inherits(cond, "message")) {
[18:02:03.207]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:03.207]                         if (muffled) 
[18:02:03.207]                           invokeRestart("muffleMessage")
[18:02:03.207]                       }
[18:02:03.207]                       else if (inherits(cond, "warning")) {
[18:02:03.207]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:03.207]                         if (muffled) 
[18:02:03.207]                           invokeRestart("muffleWarning")
[18:02:03.207]                       }
[18:02:03.207]                       else if (inherits(cond, "condition")) {
[18:02:03.207]                         if (!is.null(pattern)) {
[18:02:03.207]                           computeRestarts <- base::computeRestarts
[18:02:03.207]                           grepl <- base::grepl
[18:02:03.207]                           restarts <- computeRestarts(cond)
[18:02:03.207]                           for (restart in restarts) {
[18:02:03.207]                             name <- restart$name
[18:02:03.207]                             if (is.null(name)) 
[18:02:03.207]                               next
[18:02:03.207]                             if (!grepl(pattern, name)) 
[18:02:03.207]                               next
[18:02:03.207]                             invokeRestart(restart)
[18:02:03.207]                             muffled <- TRUE
[18:02:03.207]                             break
[18:02:03.207]                           }
[18:02:03.207]                         }
[18:02:03.207]                       }
[18:02:03.207]                       invisible(muffled)
[18:02:03.207]                     }
[18:02:03.207]                     muffleCondition(cond, pattern = "^muffle")
[18:02:03.207]                   }
[18:02:03.207]                 }
[18:02:03.207]             }
[18:02:03.207]         }))
[18:02:03.207]     }, error = function(ex) {
[18:02:03.207]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:03.207]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:03.207]                 ...future.rng), started = ...future.startTime, 
[18:02:03.207]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:03.207]             version = "1.8"), class = "FutureResult")
[18:02:03.207]     }, finally = {
[18:02:03.207]         if (!identical(...future.workdir, getwd())) 
[18:02:03.207]             setwd(...future.workdir)
[18:02:03.207]         {
[18:02:03.207]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:03.207]                 ...future.oldOptions$nwarnings <- NULL
[18:02:03.207]             }
[18:02:03.207]             base::options(...future.oldOptions)
[18:02:03.207]             if (.Platform$OS.type == "windows") {
[18:02:03.207]                 old_names <- names(...future.oldEnvVars)
[18:02:03.207]                 envs <- base::Sys.getenv()
[18:02:03.207]                 names <- names(envs)
[18:02:03.207]                 common <- intersect(names, old_names)
[18:02:03.207]                 added <- setdiff(names, old_names)
[18:02:03.207]                 removed <- setdiff(old_names, names)
[18:02:03.207]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:03.207]                   envs[common]]
[18:02:03.207]                 NAMES <- toupper(changed)
[18:02:03.207]                 args <- list()
[18:02:03.207]                 for (kk in seq_along(NAMES)) {
[18:02:03.207]                   name <- changed[[kk]]
[18:02:03.207]                   NAME <- NAMES[[kk]]
[18:02:03.207]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:03.207]                     next
[18:02:03.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:03.207]                 }
[18:02:03.207]                 NAMES <- toupper(added)
[18:02:03.207]                 for (kk in seq_along(NAMES)) {
[18:02:03.207]                   name <- added[[kk]]
[18:02:03.207]                   NAME <- NAMES[[kk]]
[18:02:03.207]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:03.207]                     next
[18:02:03.207]                   args[[name]] <- ""
[18:02:03.207]                 }
[18:02:03.207]                 NAMES <- toupper(removed)
[18:02:03.207]                 for (kk in seq_along(NAMES)) {
[18:02:03.207]                   name <- removed[[kk]]
[18:02:03.207]                   NAME <- NAMES[[kk]]
[18:02:03.207]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:03.207]                     next
[18:02:03.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:03.207]                 }
[18:02:03.207]                 if (length(args) > 0) 
[18:02:03.207]                   base::do.call(base::Sys.setenv, args = args)
[18:02:03.207]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:03.207]             }
[18:02:03.207]             else {
[18:02:03.207]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:03.207]             }
[18:02:03.207]             {
[18:02:03.207]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:03.207]                   0L) {
[18:02:03.207]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:03.207]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:03.207]                   base::options(opts)
[18:02:03.207]                 }
[18:02:03.207]                 {
[18:02:03.207]                   {
[18:02:03.207]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:03.207]                     NULL
[18:02:03.207]                   }
[18:02:03.207]                   options(future.plan = NULL)
[18:02:03.207]                   if (is.na(NA_character_)) 
[18:02:03.207]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:03.207]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:03.207]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:03.207]                     .init = FALSE)
[18:02:03.207]                 }
[18:02:03.207]             }
[18:02:03.207]         }
[18:02:03.207]     })
[18:02:03.207]     if (TRUE) {
[18:02:03.207]         base::sink(type = "output", split = FALSE)
[18:02:03.207]         if (TRUE) {
[18:02:03.207]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:03.207]         }
[18:02:03.207]         else {
[18:02:03.207]             ...future.result["stdout"] <- base::list(NULL)
[18:02:03.207]         }
[18:02:03.207]         base::close(...future.stdout)
[18:02:03.207]         ...future.stdout <- NULL
[18:02:03.207]     }
[18:02:03.207]     ...future.result$conditions <- ...future.conditions
[18:02:03.207]     ...future.result$finished <- base::Sys.time()
[18:02:03.207]     ...future.result
[18:02:03.207] }
[18:02:03.212] Exporting 11 global objects (93.23 KiB) to cluster node #2 ...
[18:02:03.212] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[18:02:03.253] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[18:02:03.254] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[18:02:03.255] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[18:02:03.255] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[18:02:03.256] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[18:02:03.257] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[18:02:03.298] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[18:02:03.299] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[18:02:03.340] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[18:02:03.341] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[18:02:03.342] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[18:02:03.342] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[18:02:03.343] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[18:02:03.344] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:03.344] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:03.345] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[18:02:03.346] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[18:02:03.346] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:03.347] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:03.347] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:03.348] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:03.348] Exporting 11 global objects (93.23 KiB) to cluster node #2 ... DONE
[18:02:03.349] MultisessionFuture started
[18:02:03.350] - Launch lazy future ... done
[18:02:03.350] run() for ‘MultisessionFuture’ ... done
[18:02:03.350] Created future:
[18:02:03.350] MultisessionFuture:
[18:02:03.350] Label: ‘future_vapply-2’
[18:02:03.350] Expression:
[18:02:03.350] {
[18:02:03.350]     do.call(function(...) {
[18:02:03.350]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:03.350]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:03.350]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:03.350]             on.exit(options(oopts), add = TRUE)
[18:02:03.350]         }
[18:02:03.350]         {
[18:02:03.350]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:03.350]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:03.350]                 ...future.FUN(...future.X_jj, ...)
[18:02:03.350]             })
[18:02:03.350]         }
[18:02:03.350]     }, args = future.call.arguments)
[18:02:03.350] }
[18:02:03.350] Lazy evaluation: FALSE
[18:02:03.350] Asynchronous evaluation: TRUE
[18:02:03.350] Local evaluation: TRUE
[18:02:03.350] Environment: R_GlobalEnv
[18:02:03.350] Capture standard output: TRUE
[18:02:03.350] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:03.350] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:03.350] Packages: 1 packages (‘future.apply’)
[18:02:03.350] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:03.350] Resolved: FALSE
[18:02:03.350] Value: <not collected>
[18:02:03.350] Conditions captured: <none>
[18:02:03.350] Early signaling: FALSE
[18:02:03.350] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:03.350] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:03.364] Chunk #2 of 2 ... DONE
[18:02:03.364] Launching 2 futures (chunks) ... DONE
[18:02:03.365] Resolving 2 futures (chunks) ...
[18:02:03.365] resolve() on list ...
[18:02:03.365]  recursive: 0
[18:02:03.366]  length: 2
[18:02:03.366] 
[18:02:03.371] receiveMessageFromWorker() for ClusterFuture ...
[18:02:03.371] - Validating connection of MultisessionFuture
[18:02:03.373] - received message: FutureResult
[18:02:03.373] - Received FutureResult
[18:02:03.373] - Erased future from FutureRegistry
[18:02:03.374] result() for ClusterFuture ...
[18:02:03.374] - result already collected: FutureResult
[18:02:03.374] result() for ClusterFuture ... done
[18:02:03.374] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:03.374] Future #1
[18:02:03.378] result() for ClusterFuture ...
[18:02:03.378] - result already collected: FutureResult
[18:02:03.378] result() for ClusterFuture ... done
[18:02:03.378] result() for ClusterFuture ...
[18:02:03.379] - result already collected: FutureResult
[18:02:03.380] result() for ClusterFuture ... done
[18:02:03.381] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:03.382] - nx: 2
[18:02:03.382] - relay: TRUE
[18:02:03.382] - stdout: TRUE
[18:02:03.382] - signal: TRUE
[18:02:03.383] - resignal: FALSE
[18:02:03.383] - force: TRUE
[18:02:03.383] - relayed: [n=2] FALSE, FALSE
[18:02:03.383] - queued futures: [n=2] FALSE, FALSE
[18:02:03.383]  - until=1
[18:02:03.384]  - relaying element #1
[18:02:03.384] result() for ClusterFuture ...
[18:02:03.384] - result already collected: FutureResult
[18:02:03.384] result() for ClusterFuture ... done
[18:02:03.385] result() for ClusterFuture ...
[18:02:03.385] - result already collected: FutureResult
[18:02:03.385] result() for ClusterFuture ... done
[18:02:03.385] result() for ClusterFuture ...
[18:02:03.385] - result already collected: FutureResult
[18:02:03.386] result() for ClusterFuture ... done
[18:02:03.386] result() for ClusterFuture ...
[18:02:03.386] - result already collected: FutureResult
[18:02:03.386] result() for ClusterFuture ... done
[18:02:03.386] - relayed: [n=2] TRUE, FALSE
[18:02:03.387] - queued futures: [n=2] TRUE, FALSE
[18:02:03.387] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:03.387]  length: 1 (resolved future 1)
[18:02:03.393] receiveMessageFromWorker() for ClusterFuture ...
[18:02:03.393] - Validating connection of MultisessionFuture
[18:02:03.394] - received message: FutureResult
[18:02:03.394] - Received FutureResult
[18:02:03.394] - Erased future from FutureRegistry
[18:02:03.395] result() for ClusterFuture ...
[18:02:03.395] - result already collected: FutureResult
[18:02:03.395] result() for ClusterFuture ... done
[18:02:03.395] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:03.395] Future #2
[18:02:03.395] result() for ClusterFuture ...
[18:02:03.396] - result already collected: FutureResult
[18:02:03.396] result() for ClusterFuture ... done
[18:02:03.396] result() for ClusterFuture ...
[18:02:03.396] - result already collected: FutureResult
[18:02:03.397] result() for ClusterFuture ... done
[18:02:03.397] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:03.397] - nx: 2
[18:02:03.397] - relay: TRUE
[18:02:03.397] - stdout: TRUE
[18:02:03.397] - signal: TRUE
[18:02:03.398] - resignal: FALSE
[18:02:03.398] - force: TRUE
[18:02:03.398] - relayed: [n=2] TRUE, FALSE
[18:02:03.398] - queued futures: [n=2] TRUE, FALSE
[18:02:03.398]  - until=2
[18:02:03.399]  - relaying element #2
[18:02:03.399] result() for ClusterFuture ...
[18:02:03.399] - result already collected: FutureResult
[18:02:03.399] result() for ClusterFuture ... done
[18:02:03.399] result() for ClusterFuture ...
[18:02:03.400] - result already collected: FutureResult
[18:02:03.400] result() for ClusterFuture ... done
[18:02:03.400] result() for ClusterFuture ...
[18:02:03.400] - result already collected: FutureResult
[18:02:03.400] result() for ClusterFuture ... done
[18:02:03.401] result() for ClusterFuture ...
[18:02:03.401] - result already collected: FutureResult
[18:02:03.401] result() for ClusterFuture ... done
[18:02:03.401] - relayed: [n=2] TRUE, TRUE
[18:02:03.401] - queued futures: [n=2] TRUE, TRUE
[18:02:03.402] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:03.402]  length: 0 (resolved future 2)
[18:02:03.402] Relaying remaining futures
[18:02:03.402] signalConditionsASAP(NULL, pos=0) ...
[18:02:03.402] - nx: 2
[18:02:03.403] - relay: TRUE
[18:02:03.403] - stdout: TRUE
[18:02:03.403] - signal: TRUE
[18:02:03.403] - resignal: FALSE
[18:02:03.403] - force: TRUE
[18:02:03.403] - relayed: [n=2] TRUE, TRUE
[18:02:03.404] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:03.404] - relayed: [n=2] TRUE, TRUE
[18:02:03.404] - queued futures: [n=2] TRUE, TRUE
[18:02:03.404] signalConditionsASAP(NULL, pos=0) ... done
[18:02:03.405] resolve() on list ... DONE
[18:02:03.405] result() for ClusterFuture ...
[18:02:03.405] - result already collected: FutureResult
[18:02:03.405] result() for ClusterFuture ... done
[18:02:03.405] result() for ClusterFuture ...
[18:02:03.406] - result already collected: FutureResult
[18:02:03.406] result() for ClusterFuture ... done
[18:02:03.406] result() for ClusterFuture ...
[18:02:03.406] - result already collected: FutureResult
[18:02:03.406] result() for ClusterFuture ... done
[18:02:03.407] result() for ClusterFuture ...
[18:02:03.407] - result already collected: FutureResult
[18:02:03.407] result() for ClusterFuture ... done
[18:02:03.407]  - Number of value chunks collected: 2
[18:02:03.407] Resolving 2 futures (chunks) ... DONE
[18:02:03.407] Reducing values from 2 chunks ...
[18:02:03.408]  - Number of values collected after concatenation: 10
[18:02:03.408]  - Number of values expected: 10
[18:02:03.408] Reducing values from 2 chunks ... DONE
[18:02:03.408] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[18:02:03.410] future_lapply() ...
[18:02:03.423] Number of chunks: 2
[18:02:03.423] getGlobalsAndPackagesXApply() ...
[18:02:03.423]  - future.globals: TRUE
[18:02:03.423] getGlobalsAndPackages() ...
[18:02:03.424] Searching for globals...
[18:02:03.431] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[18:02:03.432] Searching for globals ... DONE
[18:02:03.432] Resolving globals: FALSE
[18:02:03.434] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[18:02:03.435] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:03.435] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:03.436] - packages: [1] ‘future.apply’
[18:02:03.436] getGlobalsAndPackages() ... DONE
[18:02:03.436]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:03.437]  - needed namespaces: [n=1] ‘future.apply’
[18:02:03.438] Finding globals ... DONE
[18:02:03.438]  - use_args: TRUE
[18:02:03.438]  - Getting '...' globals ...
[18:02:03.439] resolve() on list ...
[18:02:03.439]  recursive: 0
[18:02:03.439]  length: 1
[18:02:03.439]  elements: ‘...’
[18:02:03.440]  length: 0 (resolved future 1)
[18:02:03.440] resolve() on list ... DONE
[18:02:03.440]    - '...' content: [n=0] 
[18:02:03.440] List of 1
[18:02:03.440]  $ ...: list()
[18:02:03.440]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:03.440]  - attr(*, "where")=List of 1
[18:02:03.440]   ..$ ...:<environment: 0x6183c39916e0> 
[18:02:03.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:03.440]  - attr(*, "resolved")= logi TRUE
[18:02:03.440]  - attr(*, "total_size")= num NA
[18:02:03.446]  - Getting '...' globals ... DONE
[18:02:03.446] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:03.446] List of 8
[18:02:03.446]  $ ...future.FUN:function (x, ...)  
[18:02:03.446]  $ x_FUN        :function (x)  
[18:02:03.446]  $ times        : int 0
[18:02:03.446]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:03.446]  $ stop_if_not  :function (...)  
[18:02:03.446]  $ dim          : NULL
[18:02:03.446]  $ valid_types  : chr [1:2] "logical" "integer"
[18:02:03.446]  $ ...          : list()
[18:02:03.446]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:03.446]  - attr(*, "where")=List of 8
[18:02:03.446]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:03.446]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:03.446]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:03.446]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:03.446]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:03.446]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:03.446]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:03.446]   ..$ ...          :<environment: 0x6183c39916e0> 
[18:02:03.446]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:03.446]  - attr(*, "resolved")= logi FALSE
[18:02:03.446]  - attr(*, "total_size")= num 95400
[18:02:03.458] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:03.459] getGlobalsAndPackagesXApply() ... DONE
[18:02:03.459] Number of futures (= number of chunks): 2
[18:02:03.459] Launching 2 futures (chunks) ...
[18:02:03.459] Chunk #1 of 2 ...
[18:02:03.460]  - Finding globals in 'X' for chunk #1 ...
[18:02:03.460] getGlobalsAndPackages() ...
[18:02:03.460] Searching for globals...
[18:02:03.461] 
[18:02:03.461] Searching for globals ... DONE
[18:02:03.461] - globals: [0] <none>
[18:02:03.461] getGlobalsAndPackages() ... DONE
[18:02:03.462]    + additional globals found: [n=0] 
[18:02:03.462]    + additional namespaces needed: [n=0] 
[18:02:03.462]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:03.462]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:03.462]  - seeds: <none>
[18:02:03.463]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:03.463] getGlobalsAndPackages() ...
[18:02:03.463] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:03.463] Resolving globals: FALSE
[18:02:03.464] Tweak future expression to call with '...' arguments ...
[18:02:03.464] {
[18:02:03.464]     do.call(function(...) {
[18:02:03.464]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:03.464]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:03.464]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:03.464]             on.exit(options(oopts), add = TRUE)
[18:02:03.464]         }
[18:02:03.464]         {
[18:02:03.464]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:03.464]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:03.464]                 ...future.FUN(...future.X_jj, ...)
[18:02:03.464]             })
[18:02:03.464]         }
[18:02:03.464]     }, args = future.call.arguments)
[18:02:03.464] }
[18:02:03.464] Tweak future expression to call with '...' arguments ... DONE
[18:02:03.466] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:03.466] - packages: [1] ‘future.apply’
[18:02:03.466] getGlobalsAndPackages() ... DONE
[18:02:03.467] run() for ‘Future’ ...
[18:02:03.467] - state: ‘created’
[18:02:03.467] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:03.493] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:03.494] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:03.494]   - Field: ‘node’
[18:02:03.494]   - Field: ‘label’
[18:02:03.494]   - Field: ‘local’
[18:02:03.495]   - Field: ‘owner’
[18:02:03.495]   - Field: ‘envir’
[18:02:03.495]   - Field: ‘workers’
[18:02:03.495]   - Field: ‘packages’
[18:02:03.495]   - Field: ‘gc’
[18:02:03.496]   - Field: ‘conditions’
[18:02:03.496]   - Field: ‘persistent’
[18:02:03.496]   - Field: ‘expr’
[18:02:03.496]   - Field: ‘uuid’
[18:02:03.496]   - Field: ‘seed’
[18:02:03.496]   - Field: ‘version’
[18:02:03.497]   - Field: ‘result’
[18:02:03.497]   - Field: ‘asynchronous’
[18:02:03.497]   - Field: ‘calls’
[18:02:03.497]   - Field: ‘globals’
[18:02:03.497]   - Field: ‘stdout’
[18:02:03.498]   - Field: ‘earlySignal’
[18:02:03.498]   - Field: ‘lazy’
[18:02:03.498]   - Field: ‘state’
[18:02:03.498] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:03.498] - Launch lazy future ...
[18:02:03.499] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:03.499] Packages needed by future strategies (n = 0): <none>
[18:02:03.500] {
[18:02:03.500]     {
[18:02:03.500]         {
[18:02:03.500]             ...future.startTime <- base::Sys.time()
[18:02:03.500]             {
[18:02:03.500]                 {
[18:02:03.500]                   {
[18:02:03.500]                     {
[18:02:03.500]                       {
[18:02:03.500]                         base::local({
[18:02:03.500]                           has_future <- base::requireNamespace("future", 
[18:02:03.500]                             quietly = TRUE)
[18:02:03.500]                           if (has_future) {
[18:02:03.500]                             ns <- base::getNamespace("future")
[18:02:03.500]                             version <- ns[[".package"]][["version"]]
[18:02:03.500]                             if (is.null(version)) 
[18:02:03.500]                               version <- utils::packageVersion("future")
[18:02:03.500]                           }
[18:02:03.500]                           else {
[18:02:03.500]                             version <- NULL
[18:02:03.500]                           }
[18:02:03.500]                           if (!has_future || version < "1.8.0") {
[18:02:03.500]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:03.500]                               "", base::R.version$version.string), 
[18:02:03.500]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:03.500]                                 base::R.version$platform, 8 * 
[18:02:03.500]                                   base::.Machine$sizeof.pointer), 
[18:02:03.500]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:03.500]                                 "release", "version")], collapse = " "), 
[18:02:03.500]                               hostname = base::Sys.info()[["nodename"]])
[18:02:03.500]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:03.500]                               info)
[18:02:03.500]                             info <- base::paste(info, collapse = "; ")
[18:02:03.500]                             if (!has_future) {
[18:02:03.500]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:03.500]                                 info)
[18:02:03.500]                             }
[18:02:03.500]                             else {
[18:02:03.500]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:03.500]                                 info, version)
[18:02:03.500]                             }
[18:02:03.500]                             base::stop(msg)
[18:02:03.500]                           }
[18:02:03.500]                         })
[18:02:03.500]                       }
[18:02:03.500]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:03.500]                       base::options(mc.cores = 1L)
[18:02:03.500]                     }
[18:02:03.500]                     base::local({
[18:02:03.500]                       for (pkg in "future.apply") {
[18:02:03.500]                         base::loadNamespace(pkg)
[18:02:03.500]                         base::library(pkg, character.only = TRUE)
[18:02:03.500]                       }
[18:02:03.500]                     })
[18:02:03.500]                   }
[18:02:03.500]                   ...future.strategy.old <- future::plan("list")
[18:02:03.500]                   options(future.plan = NULL)
[18:02:03.500]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:03.500]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:03.500]                 }
[18:02:03.500]                 ...future.workdir <- getwd()
[18:02:03.500]             }
[18:02:03.500]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:03.500]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:03.500]         }
[18:02:03.500]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:03.500]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:03.500]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:03.500]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:03.500]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:03.500]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:03.500]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:03.500]             base::names(...future.oldOptions))
[18:02:03.500]     }
[18:02:03.500]     if (FALSE) {
[18:02:03.500]     }
[18:02:03.500]     else {
[18:02:03.500]         if (TRUE) {
[18:02:03.500]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:03.500]                 open = "w")
[18:02:03.500]         }
[18:02:03.500]         else {
[18:02:03.500]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:03.500]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:03.500]         }
[18:02:03.500]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:03.500]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:03.500]             base::sink(type = "output", split = FALSE)
[18:02:03.500]             base::close(...future.stdout)
[18:02:03.500]         }, add = TRUE)
[18:02:03.500]     }
[18:02:03.500]     ...future.frame <- base::sys.nframe()
[18:02:03.500]     ...future.conditions <- base::list()
[18:02:03.500]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:03.500]     if (FALSE) {
[18:02:03.500]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:03.500]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:03.500]     }
[18:02:03.500]     ...future.result <- base::tryCatch({
[18:02:03.500]         base::withCallingHandlers({
[18:02:03.500]             ...future.value <- base::withVisible(base::local({
[18:02:03.500]                 ...future.makeSendCondition <- base::local({
[18:02:03.500]                   sendCondition <- NULL
[18:02:03.500]                   function(frame = 1L) {
[18:02:03.500]                     if (is.function(sendCondition)) 
[18:02:03.500]                       return(sendCondition)
[18:02:03.500]                     ns <- getNamespace("parallel")
[18:02:03.500]                     if (exists("sendData", mode = "function", 
[18:02:03.500]                       envir = ns)) {
[18:02:03.500]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:03.500]                         envir = ns)
[18:02:03.500]                       envir <- sys.frame(frame)
[18:02:03.500]                       master <- NULL
[18:02:03.500]                       while (!identical(envir, .GlobalEnv) && 
[18:02:03.500]                         !identical(envir, emptyenv())) {
[18:02:03.500]                         if (exists("master", mode = "list", envir = envir, 
[18:02:03.500]                           inherits = FALSE)) {
[18:02:03.500]                           master <- get("master", mode = "list", 
[18:02:03.500]                             envir = envir, inherits = FALSE)
[18:02:03.500]                           if (inherits(master, c("SOCKnode", 
[18:02:03.500]                             "SOCK0node"))) {
[18:02:03.500]                             sendCondition <<- function(cond) {
[18:02:03.500]                               data <- list(type = "VALUE", value = cond, 
[18:02:03.500]                                 success = TRUE)
[18:02:03.500]                               parallel_sendData(master, data)
[18:02:03.500]                             }
[18:02:03.500]                             return(sendCondition)
[18:02:03.500]                           }
[18:02:03.500]                         }
[18:02:03.500]                         frame <- frame + 1L
[18:02:03.500]                         envir <- sys.frame(frame)
[18:02:03.500]                       }
[18:02:03.500]                     }
[18:02:03.500]                     sendCondition <<- function(cond) NULL
[18:02:03.500]                   }
[18:02:03.500]                 })
[18:02:03.500]                 withCallingHandlers({
[18:02:03.500]                   {
[18:02:03.500]                     do.call(function(...) {
[18:02:03.500]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:03.500]                       if (!identical(...future.globals.maxSize.org, 
[18:02:03.500]                         ...future.globals.maxSize)) {
[18:02:03.500]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:03.500]                         on.exit(options(oopts), add = TRUE)
[18:02:03.500]                       }
[18:02:03.500]                       {
[18:02:03.500]                         lapply(seq_along(...future.elements_ii), 
[18:02:03.500]                           FUN = function(jj) {
[18:02:03.500]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:03.500]                             ...future.FUN(...future.X_jj, ...)
[18:02:03.500]                           })
[18:02:03.500]                       }
[18:02:03.500]                     }, args = future.call.arguments)
[18:02:03.500]                   }
[18:02:03.500]                 }, immediateCondition = function(cond) {
[18:02:03.500]                   sendCondition <- ...future.makeSendCondition()
[18:02:03.500]                   sendCondition(cond)
[18:02:03.500]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:03.500]                   {
[18:02:03.500]                     inherits <- base::inherits
[18:02:03.500]                     invokeRestart <- base::invokeRestart
[18:02:03.500]                     is.null <- base::is.null
[18:02:03.500]                     muffled <- FALSE
[18:02:03.500]                     if (inherits(cond, "message")) {
[18:02:03.500]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:03.500]                       if (muffled) 
[18:02:03.500]                         invokeRestart("muffleMessage")
[18:02:03.500]                     }
[18:02:03.500]                     else if (inherits(cond, "warning")) {
[18:02:03.500]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:03.500]                       if (muffled) 
[18:02:03.500]                         invokeRestart("muffleWarning")
[18:02:03.500]                     }
[18:02:03.500]                     else if (inherits(cond, "condition")) {
[18:02:03.500]                       if (!is.null(pattern)) {
[18:02:03.500]                         computeRestarts <- base::computeRestarts
[18:02:03.500]                         grepl <- base::grepl
[18:02:03.500]                         restarts <- computeRestarts(cond)
[18:02:03.500]                         for (restart in restarts) {
[18:02:03.500]                           name <- restart$name
[18:02:03.500]                           if (is.null(name)) 
[18:02:03.500]                             next
[18:02:03.500]                           if (!grepl(pattern, name)) 
[18:02:03.500]                             next
[18:02:03.500]                           invokeRestart(restart)
[18:02:03.500]                           muffled <- TRUE
[18:02:03.500]                           break
[18:02:03.500]                         }
[18:02:03.500]                       }
[18:02:03.500]                     }
[18:02:03.500]                     invisible(muffled)
[18:02:03.500]                   }
[18:02:03.500]                   muffleCondition(cond)
[18:02:03.500]                 })
[18:02:03.500]             }))
[18:02:03.500]             future::FutureResult(value = ...future.value$value, 
[18:02:03.500]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:03.500]                   ...future.rng), globalenv = if (FALSE) 
[18:02:03.500]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:03.500]                     ...future.globalenv.names))
[18:02:03.500]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:03.500]         }, condition = base::local({
[18:02:03.500]             c <- base::c
[18:02:03.500]             inherits <- base::inherits
[18:02:03.500]             invokeRestart <- base::invokeRestart
[18:02:03.500]             length <- base::length
[18:02:03.500]             list <- base::list
[18:02:03.500]             seq.int <- base::seq.int
[18:02:03.500]             signalCondition <- base::signalCondition
[18:02:03.500]             sys.calls <- base::sys.calls
[18:02:03.500]             `[[` <- base::`[[`
[18:02:03.500]             `+` <- base::`+`
[18:02:03.500]             `<<-` <- base::`<<-`
[18:02:03.500]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:03.500]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:03.500]                   3L)]
[18:02:03.500]             }
[18:02:03.500]             function(cond) {
[18:02:03.500]                 is_error <- inherits(cond, "error")
[18:02:03.500]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:03.500]                   NULL)
[18:02:03.500]                 if (is_error) {
[18:02:03.500]                   sessionInformation <- function() {
[18:02:03.500]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:03.500]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:03.500]                       search = base::search(), system = base::Sys.info())
[18:02:03.500]                   }
[18:02:03.500]                   ...future.conditions[[length(...future.conditions) + 
[18:02:03.500]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:03.500]                     cond$call), session = sessionInformation(), 
[18:02:03.500]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:03.500]                   signalCondition(cond)
[18:02:03.500]                 }
[18:02:03.500]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:03.500]                 "immediateCondition"))) {
[18:02:03.500]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:03.500]                   ...future.conditions[[length(...future.conditions) + 
[18:02:03.500]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:03.500]                   if (TRUE && !signal) {
[18:02:03.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:03.500]                     {
[18:02:03.500]                       inherits <- base::inherits
[18:02:03.500]                       invokeRestart <- base::invokeRestart
[18:02:03.500]                       is.null <- base::is.null
[18:02:03.500]                       muffled <- FALSE
[18:02:03.500]                       if (inherits(cond, "message")) {
[18:02:03.500]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:03.500]                         if (muffled) 
[18:02:03.500]                           invokeRestart("muffleMessage")
[18:02:03.500]                       }
[18:02:03.500]                       else if (inherits(cond, "warning")) {
[18:02:03.500]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:03.500]                         if (muffled) 
[18:02:03.500]                           invokeRestart("muffleWarning")
[18:02:03.500]                       }
[18:02:03.500]                       else if (inherits(cond, "condition")) {
[18:02:03.500]                         if (!is.null(pattern)) {
[18:02:03.500]                           computeRestarts <- base::computeRestarts
[18:02:03.500]                           grepl <- base::grepl
[18:02:03.500]                           restarts <- computeRestarts(cond)
[18:02:03.500]                           for (restart in restarts) {
[18:02:03.500]                             name <- restart$name
[18:02:03.500]                             if (is.null(name)) 
[18:02:03.500]                               next
[18:02:03.500]                             if (!grepl(pattern, name)) 
[18:02:03.500]                               next
[18:02:03.500]                             invokeRestart(restart)
[18:02:03.500]                             muffled <- TRUE
[18:02:03.500]                             break
[18:02:03.500]                           }
[18:02:03.500]                         }
[18:02:03.500]                       }
[18:02:03.500]                       invisible(muffled)
[18:02:03.500]                     }
[18:02:03.500]                     muffleCondition(cond, pattern = "^muffle")
[18:02:03.500]                   }
[18:02:03.500]                 }
[18:02:03.500]                 else {
[18:02:03.500]                   if (TRUE) {
[18:02:03.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:03.500]                     {
[18:02:03.500]                       inherits <- base::inherits
[18:02:03.500]                       invokeRestart <- base::invokeRestart
[18:02:03.500]                       is.null <- base::is.null
[18:02:03.500]                       muffled <- FALSE
[18:02:03.500]                       if (inherits(cond, "message")) {
[18:02:03.500]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:03.500]                         if (muffled) 
[18:02:03.500]                           invokeRestart("muffleMessage")
[18:02:03.500]                       }
[18:02:03.500]                       else if (inherits(cond, "warning")) {
[18:02:03.500]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:03.500]                         if (muffled) 
[18:02:03.500]                           invokeRestart("muffleWarning")
[18:02:03.500]                       }
[18:02:03.500]                       else if (inherits(cond, "condition")) {
[18:02:03.500]                         if (!is.null(pattern)) {
[18:02:03.500]                           computeRestarts <- base::computeRestarts
[18:02:03.500]                           grepl <- base::grepl
[18:02:03.500]                           restarts <- computeRestarts(cond)
[18:02:03.500]                           for (restart in restarts) {
[18:02:03.500]                             name <- restart$name
[18:02:03.500]                             if (is.null(name)) 
[18:02:03.500]                               next
[18:02:03.500]                             if (!grepl(pattern, name)) 
[18:02:03.500]                               next
[18:02:03.500]                             invokeRestart(restart)
[18:02:03.500]                             muffled <- TRUE
[18:02:03.500]                             break
[18:02:03.500]                           }
[18:02:03.500]                         }
[18:02:03.500]                       }
[18:02:03.500]                       invisible(muffled)
[18:02:03.500]                     }
[18:02:03.500]                     muffleCondition(cond, pattern = "^muffle")
[18:02:03.500]                   }
[18:02:03.500]                 }
[18:02:03.500]             }
[18:02:03.500]         }))
[18:02:03.500]     }, error = function(ex) {
[18:02:03.500]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:03.500]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:03.500]                 ...future.rng), started = ...future.startTime, 
[18:02:03.500]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:03.500]             version = "1.8"), class = "FutureResult")
[18:02:03.500]     }, finally = {
[18:02:03.500]         if (!identical(...future.workdir, getwd())) 
[18:02:03.500]             setwd(...future.workdir)
[18:02:03.500]         {
[18:02:03.500]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:03.500]                 ...future.oldOptions$nwarnings <- NULL
[18:02:03.500]             }
[18:02:03.500]             base::options(...future.oldOptions)
[18:02:03.500]             if (.Platform$OS.type == "windows") {
[18:02:03.500]                 old_names <- names(...future.oldEnvVars)
[18:02:03.500]                 envs <- base::Sys.getenv()
[18:02:03.500]                 names <- names(envs)
[18:02:03.500]                 common <- intersect(names, old_names)
[18:02:03.500]                 added <- setdiff(names, old_names)
[18:02:03.500]                 removed <- setdiff(old_names, names)
[18:02:03.500]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:03.500]                   envs[common]]
[18:02:03.500]                 NAMES <- toupper(changed)
[18:02:03.500]                 args <- list()
[18:02:03.500]                 for (kk in seq_along(NAMES)) {
[18:02:03.500]                   name <- changed[[kk]]
[18:02:03.500]                   NAME <- NAMES[[kk]]
[18:02:03.500]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:03.500]                     next
[18:02:03.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:03.500]                 }
[18:02:03.500]                 NAMES <- toupper(added)
[18:02:03.500]                 for (kk in seq_along(NAMES)) {
[18:02:03.500]                   name <- added[[kk]]
[18:02:03.500]                   NAME <- NAMES[[kk]]
[18:02:03.500]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:03.500]                     next
[18:02:03.500]                   args[[name]] <- ""
[18:02:03.500]                 }
[18:02:03.500]                 NAMES <- toupper(removed)
[18:02:03.500]                 for (kk in seq_along(NAMES)) {
[18:02:03.500]                   name <- removed[[kk]]
[18:02:03.500]                   NAME <- NAMES[[kk]]
[18:02:03.500]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:03.500]                     next
[18:02:03.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:03.500]                 }
[18:02:03.500]                 if (length(args) > 0) 
[18:02:03.500]                   base::do.call(base::Sys.setenv, args = args)
[18:02:03.500]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:03.500]             }
[18:02:03.500]             else {
[18:02:03.500]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:03.500]             }
[18:02:03.500]             {
[18:02:03.500]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:03.500]                   0L) {
[18:02:03.500]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:03.500]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:03.500]                   base::options(opts)
[18:02:03.500]                 }
[18:02:03.500]                 {
[18:02:03.500]                   {
[18:02:03.500]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:03.500]                     NULL
[18:02:03.500]                   }
[18:02:03.500]                   options(future.plan = NULL)
[18:02:03.500]                   if (is.na(NA_character_)) 
[18:02:03.500]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:03.500]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:03.500]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:03.500]                     .init = FALSE)
[18:02:03.500]                 }
[18:02:03.500]             }
[18:02:03.500]         }
[18:02:03.500]     })
[18:02:03.500]     if (TRUE) {
[18:02:03.500]         base::sink(type = "output", split = FALSE)
[18:02:03.500]         if (TRUE) {
[18:02:03.500]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:03.500]         }
[18:02:03.500]         else {
[18:02:03.500]             ...future.result["stdout"] <- base::list(NULL)
[18:02:03.500]         }
[18:02:03.500]         base::close(...future.stdout)
[18:02:03.500]         ...future.stdout <- NULL
[18:02:03.500]     }
[18:02:03.500]     ...future.result$conditions <- ...future.conditions
[18:02:03.500]     ...future.result$finished <- base::Sys.time()
[18:02:03.500]     ...future.result
[18:02:03.500] }
[18:02:03.506] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[18:02:03.506] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[18:02:03.547] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[18:02:03.548] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[18:02:03.549] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[18:02:03.549] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[18:02:03.550] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[18:02:03.551] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[18:02:03.592] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[18:02:03.593] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[18:02:03.634] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[18:02:03.635] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[18:02:03.636] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[18:02:03.636] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[18:02:03.637] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[18:02:03.638] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:03.639] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:03.640] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[18:02:03.641] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[18:02:03.641] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:03.642] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:03.643] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:03.644] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:03.644] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[18:02:03.646] MultisessionFuture started
[18:02:03.646] - Launch lazy future ... done
[18:02:03.647] run() for ‘MultisessionFuture’ ... done
[18:02:03.647] Created future:
[18:02:03.647] MultisessionFuture:
[18:02:03.647] Label: ‘future_vapply-1’
[18:02:03.647] Expression:
[18:02:03.647] {
[18:02:03.647]     do.call(function(...) {
[18:02:03.647]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:03.647]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:03.647]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:03.647]             on.exit(options(oopts), add = TRUE)
[18:02:03.647]         }
[18:02:03.647]         {
[18:02:03.647]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:03.647]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:03.647]                 ...future.FUN(...future.X_jj, ...)
[18:02:03.647]             })
[18:02:03.647]         }
[18:02:03.647]     }, args = future.call.arguments)
[18:02:03.647] }
[18:02:03.647] Lazy evaluation: FALSE
[18:02:03.647] Asynchronous evaluation: TRUE
[18:02:03.647] Local evaluation: TRUE
[18:02:03.647] Environment: R_GlobalEnv
[18:02:03.647] Capture standard output: TRUE
[18:02:03.647] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:03.647] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:03.647] Packages: 1 packages (‘future.apply’)
[18:02:03.647] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:03.647] Resolved: FALSE
[18:02:03.647] Value: <not collected>
[18:02:03.647] Conditions captured: <none>
[18:02:03.647] Early signaling: FALSE
[18:02:03.647] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:03.647] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:03.662] Chunk #1 of 2 ... DONE
[18:02:03.663] Chunk #2 of 2 ...
[18:02:03.663]  - Finding globals in 'X' for chunk #2 ...
[18:02:03.663] getGlobalsAndPackages() ...
[18:02:03.664] Searching for globals...
[18:02:03.665] 
[18:02:03.665] Searching for globals ... DONE
[18:02:03.665] - globals: [0] <none>
[18:02:03.665] getGlobalsAndPackages() ... DONE
[18:02:03.666]    + additional globals found: [n=0] 
[18:02:03.666]    + additional namespaces needed: [n=0] 
[18:02:03.666]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:03.667]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:03.667]  - seeds: <none>
[18:02:03.667]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:03.668] getGlobalsAndPackages() ...
[18:02:03.668] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:03.668] Resolving globals: FALSE
[18:02:03.669] Tweak future expression to call with '...' arguments ...
[18:02:03.669] {
[18:02:03.669]     do.call(function(...) {
[18:02:03.669]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:03.669]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:03.669]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:03.669]             on.exit(options(oopts), add = TRUE)
[18:02:03.669]         }
[18:02:03.669]         {
[18:02:03.669]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:03.669]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:03.669]                 ...future.FUN(...future.X_jj, ...)
[18:02:03.669]             })
[18:02:03.669]         }
[18:02:03.669]     }, args = future.call.arguments)
[18:02:03.669] }
[18:02:03.670] Tweak future expression to call with '...' arguments ... DONE
[18:02:03.672] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:03.672] - packages: [1] ‘future.apply’
[18:02:03.673] getGlobalsAndPackages() ... DONE
[18:02:03.673] run() for ‘Future’ ...
[18:02:03.674] - state: ‘created’
[18:02:03.674] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:03.711] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:03.712] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:03.712]   - Field: ‘node’
[18:02:03.712]   - Field: ‘label’
[18:02:03.713]   - Field: ‘local’
[18:02:03.713]   - Field: ‘owner’
[18:02:03.713]   - Field: ‘envir’
[18:02:03.713]   - Field: ‘workers’
[18:02:03.714]   - Field: ‘packages’
[18:02:03.714]   - Field: ‘gc’
[18:02:03.714]   - Field: ‘conditions’
[18:02:03.714]   - Field: ‘persistent’
[18:02:03.715]   - Field: ‘expr’
[18:02:03.715]   - Field: ‘uuid’
[18:02:03.715]   - Field: ‘seed’
[18:02:03.716]   - Field: ‘version’
[18:02:03.716]   - Field: ‘result’
[18:02:03.716]   - Field: ‘asynchronous’
[18:02:03.716]   - Field: ‘calls’
[18:02:03.717]   - Field: ‘globals’
[18:02:03.717]   - Field: ‘stdout’
[18:02:03.717]   - Field: ‘earlySignal’
[18:02:03.717]   - Field: ‘lazy’
[18:02:03.718]   - Field: ‘state’
[18:02:03.718] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:03.718] - Launch lazy future ...
[18:02:03.719] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:03.719] Packages needed by future strategies (n = 0): <none>
[18:02:03.720] {
[18:02:03.720]     {
[18:02:03.720]         {
[18:02:03.720]             ...future.startTime <- base::Sys.time()
[18:02:03.720]             {
[18:02:03.720]                 {
[18:02:03.720]                   {
[18:02:03.720]                     {
[18:02:03.720]                       {
[18:02:03.720]                         base::local({
[18:02:03.720]                           has_future <- base::requireNamespace("future", 
[18:02:03.720]                             quietly = TRUE)
[18:02:03.720]                           if (has_future) {
[18:02:03.720]                             ns <- base::getNamespace("future")
[18:02:03.720]                             version <- ns[[".package"]][["version"]]
[18:02:03.720]                             if (is.null(version)) 
[18:02:03.720]                               version <- utils::packageVersion("future")
[18:02:03.720]                           }
[18:02:03.720]                           else {
[18:02:03.720]                             version <- NULL
[18:02:03.720]                           }
[18:02:03.720]                           if (!has_future || version < "1.8.0") {
[18:02:03.720]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:03.720]                               "", base::R.version$version.string), 
[18:02:03.720]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:03.720]                                 base::R.version$platform, 8 * 
[18:02:03.720]                                   base::.Machine$sizeof.pointer), 
[18:02:03.720]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:03.720]                                 "release", "version")], collapse = " "), 
[18:02:03.720]                               hostname = base::Sys.info()[["nodename"]])
[18:02:03.720]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:03.720]                               info)
[18:02:03.720]                             info <- base::paste(info, collapse = "; ")
[18:02:03.720]                             if (!has_future) {
[18:02:03.720]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:03.720]                                 info)
[18:02:03.720]                             }
[18:02:03.720]                             else {
[18:02:03.720]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:03.720]                                 info, version)
[18:02:03.720]                             }
[18:02:03.720]                             base::stop(msg)
[18:02:03.720]                           }
[18:02:03.720]                         })
[18:02:03.720]                       }
[18:02:03.720]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:03.720]                       base::options(mc.cores = 1L)
[18:02:03.720]                     }
[18:02:03.720]                     base::local({
[18:02:03.720]                       for (pkg in "future.apply") {
[18:02:03.720]                         base::loadNamespace(pkg)
[18:02:03.720]                         base::library(pkg, character.only = TRUE)
[18:02:03.720]                       }
[18:02:03.720]                     })
[18:02:03.720]                   }
[18:02:03.720]                   ...future.strategy.old <- future::plan("list")
[18:02:03.720]                   options(future.plan = NULL)
[18:02:03.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:03.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:03.720]                 }
[18:02:03.720]                 ...future.workdir <- getwd()
[18:02:03.720]             }
[18:02:03.720]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:03.720]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:03.720]         }
[18:02:03.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:03.720]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:03.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:03.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:03.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:03.720]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:03.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:03.720]             base::names(...future.oldOptions))
[18:02:03.720]     }
[18:02:03.720]     if (FALSE) {
[18:02:03.720]     }
[18:02:03.720]     else {
[18:02:03.720]         if (TRUE) {
[18:02:03.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:03.720]                 open = "w")
[18:02:03.720]         }
[18:02:03.720]         else {
[18:02:03.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:03.720]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:03.720]         }
[18:02:03.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:03.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:03.720]             base::sink(type = "output", split = FALSE)
[18:02:03.720]             base::close(...future.stdout)
[18:02:03.720]         }, add = TRUE)
[18:02:03.720]     }
[18:02:03.720]     ...future.frame <- base::sys.nframe()
[18:02:03.720]     ...future.conditions <- base::list()
[18:02:03.720]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:03.720]     if (FALSE) {
[18:02:03.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:03.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:03.720]     }
[18:02:03.720]     ...future.result <- base::tryCatch({
[18:02:03.720]         base::withCallingHandlers({
[18:02:03.720]             ...future.value <- base::withVisible(base::local({
[18:02:03.720]                 ...future.makeSendCondition <- base::local({
[18:02:03.720]                   sendCondition <- NULL
[18:02:03.720]                   function(frame = 1L) {
[18:02:03.720]                     if (is.function(sendCondition)) 
[18:02:03.720]                       return(sendCondition)
[18:02:03.720]                     ns <- getNamespace("parallel")
[18:02:03.720]                     if (exists("sendData", mode = "function", 
[18:02:03.720]                       envir = ns)) {
[18:02:03.720]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:03.720]                         envir = ns)
[18:02:03.720]                       envir <- sys.frame(frame)
[18:02:03.720]                       master <- NULL
[18:02:03.720]                       while (!identical(envir, .GlobalEnv) && 
[18:02:03.720]                         !identical(envir, emptyenv())) {
[18:02:03.720]                         if (exists("master", mode = "list", envir = envir, 
[18:02:03.720]                           inherits = FALSE)) {
[18:02:03.720]                           master <- get("master", mode = "list", 
[18:02:03.720]                             envir = envir, inherits = FALSE)
[18:02:03.720]                           if (inherits(master, c("SOCKnode", 
[18:02:03.720]                             "SOCK0node"))) {
[18:02:03.720]                             sendCondition <<- function(cond) {
[18:02:03.720]                               data <- list(type = "VALUE", value = cond, 
[18:02:03.720]                                 success = TRUE)
[18:02:03.720]                               parallel_sendData(master, data)
[18:02:03.720]                             }
[18:02:03.720]                             return(sendCondition)
[18:02:03.720]                           }
[18:02:03.720]                         }
[18:02:03.720]                         frame <- frame + 1L
[18:02:03.720]                         envir <- sys.frame(frame)
[18:02:03.720]                       }
[18:02:03.720]                     }
[18:02:03.720]                     sendCondition <<- function(cond) NULL
[18:02:03.720]                   }
[18:02:03.720]                 })
[18:02:03.720]                 withCallingHandlers({
[18:02:03.720]                   {
[18:02:03.720]                     do.call(function(...) {
[18:02:03.720]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:03.720]                       if (!identical(...future.globals.maxSize.org, 
[18:02:03.720]                         ...future.globals.maxSize)) {
[18:02:03.720]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:03.720]                         on.exit(options(oopts), add = TRUE)
[18:02:03.720]                       }
[18:02:03.720]                       {
[18:02:03.720]                         lapply(seq_along(...future.elements_ii), 
[18:02:03.720]                           FUN = function(jj) {
[18:02:03.720]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:03.720]                             ...future.FUN(...future.X_jj, ...)
[18:02:03.720]                           })
[18:02:03.720]                       }
[18:02:03.720]                     }, args = future.call.arguments)
[18:02:03.720]                   }
[18:02:03.720]                 }, immediateCondition = function(cond) {
[18:02:03.720]                   sendCondition <- ...future.makeSendCondition()
[18:02:03.720]                   sendCondition(cond)
[18:02:03.720]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:03.720]                   {
[18:02:03.720]                     inherits <- base::inherits
[18:02:03.720]                     invokeRestart <- base::invokeRestart
[18:02:03.720]                     is.null <- base::is.null
[18:02:03.720]                     muffled <- FALSE
[18:02:03.720]                     if (inherits(cond, "message")) {
[18:02:03.720]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:03.720]                       if (muffled) 
[18:02:03.720]                         invokeRestart("muffleMessage")
[18:02:03.720]                     }
[18:02:03.720]                     else if (inherits(cond, "warning")) {
[18:02:03.720]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:03.720]                       if (muffled) 
[18:02:03.720]                         invokeRestart("muffleWarning")
[18:02:03.720]                     }
[18:02:03.720]                     else if (inherits(cond, "condition")) {
[18:02:03.720]                       if (!is.null(pattern)) {
[18:02:03.720]                         computeRestarts <- base::computeRestarts
[18:02:03.720]                         grepl <- base::grepl
[18:02:03.720]                         restarts <- computeRestarts(cond)
[18:02:03.720]                         for (restart in restarts) {
[18:02:03.720]                           name <- restart$name
[18:02:03.720]                           if (is.null(name)) 
[18:02:03.720]                             next
[18:02:03.720]                           if (!grepl(pattern, name)) 
[18:02:03.720]                             next
[18:02:03.720]                           invokeRestart(restart)
[18:02:03.720]                           muffled <- TRUE
[18:02:03.720]                           break
[18:02:03.720]                         }
[18:02:03.720]                       }
[18:02:03.720]                     }
[18:02:03.720]                     invisible(muffled)
[18:02:03.720]                   }
[18:02:03.720]                   muffleCondition(cond)
[18:02:03.720]                 })
[18:02:03.720]             }))
[18:02:03.720]             future::FutureResult(value = ...future.value$value, 
[18:02:03.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:03.720]                   ...future.rng), globalenv = if (FALSE) 
[18:02:03.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:03.720]                     ...future.globalenv.names))
[18:02:03.720]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:03.720]         }, condition = base::local({
[18:02:03.720]             c <- base::c
[18:02:03.720]             inherits <- base::inherits
[18:02:03.720]             invokeRestart <- base::invokeRestart
[18:02:03.720]             length <- base::length
[18:02:03.720]             list <- base::list
[18:02:03.720]             seq.int <- base::seq.int
[18:02:03.720]             signalCondition <- base::signalCondition
[18:02:03.720]             sys.calls <- base::sys.calls
[18:02:03.720]             `[[` <- base::`[[`
[18:02:03.720]             `+` <- base::`+`
[18:02:03.720]             `<<-` <- base::`<<-`
[18:02:03.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:03.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:03.720]                   3L)]
[18:02:03.720]             }
[18:02:03.720]             function(cond) {
[18:02:03.720]                 is_error <- inherits(cond, "error")
[18:02:03.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:03.720]                   NULL)
[18:02:03.720]                 if (is_error) {
[18:02:03.720]                   sessionInformation <- function() {
[18:02:03.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:03.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:03.720]                       search = base::search(), system = base::Sys.info())
[18:02:03.720]                   }
[18:02:03.720]                   ...future.conditions[[length(...future.conditions) + 
[18:02:03.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:03.720]                     cond$call), session = sessionInformation(), 
[18:02:03.720]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:03.720]                   signalCondition(cond)
[18:02:03.720]                 }
[18:02:03.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:03.720]                 "immediateCondition"))) {
[18:02:03.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:03.720]                   ...future.conditions[[length(...future.conditions) + 
[18:02:03.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:03.720]                   if (TRUE && !signal) {
[18:02:03.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:03.720]                     {
[18:02:03.720]                       inherits <- base::inherits
[18:02:03.720]                       invokeRestart <- base::invokeRestart
[18:02:03.720]                       is.null <- base::is.null
[18:02:03.720]                       muffled <- FALSE
[18:02:03.720]                       if (inherits(cond, "message")) {
[18:02:03.720]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:03.720]                         if (muffled) 
[18:02:03.720]                           invokeRestart("muffleMessage")
[18:02:03.720]                       }
[18:02:03.720]                       else if (inherits(cond, "warning")) {
[18:02:03.720]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:03.720]                         if (muffled) 
[18:02:03.720]                           invokeRestart("muffleWarning")
[18:02:03.720]                       }
[18:02:03.720]                       else if (inherits(cond, "condition")) {
[18:02:03.720]                         if (!is.null(pattern)) {
[18:02:03.720]                           computeRestarts <- base::computeRestarts
[18:02:03.720]                           grepl <- base::grepl
[18:02:03.720]                           restarts <- computeRestarts(cond)
[18:02:03.720]                           for (restart in restarts) {
[18:02:03.720]                             name <- restart$name
[18:02:03.720]                             if (is.null(name)) 
[18:02:03.720]                               next
[18:02:03.720]                             if (!grepl(pattern, name)) 
[18:02:03.720]                               next
[18:02:03.720]                             invokeRestart(restart)
[18:02:03.720]                             muffled <- TRUE
[18:02:03.720]                             break
[18:02:03.720]                           }
[18:02:03.720]                         }
[18:02:03.720]                       }
[18:02:03.720]                       invisible(muffled)
[18:02:03.720]                     }
[18:02:03.720]                     muffleCondition(cond, pattern = "^muffle")
[18:02:03.720]                   }
[18:02:03.720]                 }
[18:02:03.720]                 else {
[18:02:03.720]                   if (TRUE) {
[18:02:03.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:03.720]                     {
[18:02:03.720]                       inherits <- base::inherits
[18:02:03.720]                       invokeRestart <- base::invokeRestart
[18:02:03.720]                       is.null <- base::is.null
[18:02:03.720]                       muffled <- FALSE
[18:02:03.720]                       if (inherits(cond, "message")) {
[18:02:03.720]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:03.720]                         if (muffled) 
[18:02:03.720]                           invokeRestart("muffleMessage")
[18:02:03.720]                       }
[18:02:03.720]                       else if (inherits(cond, "warning")) {
[18:02:03.720]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:03.720]                         if (muffled) 
[18:02:03.720]                           invokeRestart("muffleWarning")
[18:02:03.720]                       }
[18:02:03.720]                       else if (inherits(cond, "condition")) {
[18:02:03.720]                         if (!is.null(pattern)) {
[18:02:03.720]                           computeRestarts <- base::computeRestarts
[18:02:03.720]                           grepl <- base::grepl
[18:02:03.720]                           restarts <- computeRestarts(cond)
[18:02:03.720]                           for (restart in restarts) {
[18:02:03.720]                             name <- restart$name
[18:02:03.720]                             if (is.null(name)) 
[18:02:03.720]                               next
[18:02:03.720]                             if (!grepl(pattern, name)) 
[18:02:03.720]                               next
[18:02:03.720]                             invokeRestart(restart)
[18:02:03.720]                             muffled <- TRUE
[18:02:03.720]                             break
[18:02:03.720]                           }
[18:02:03.720]                         }
[18:02:03.720]                       }
[18:02:03.720]                       invisible(muffled)
[18:02:03.720]                     }
[18:02:03.720]                     muffleCondition(cond, pattern = "^muffle")
[18:02:03.720]                   }
[18:02:03.720]                 }
[18:02:03.720]             }
[18:02:03.720]         }))
[18:02:03.720]     }, error = function(ex) {
[18:02:03.720]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:03.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:03.720]                 ...future.rng), started = ...future.startTime, 
[18:02:03.720]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:03.720]             version = "1.8"), class = "FutureResult")
[18:02:03.720]     }, finally = {
[18:02:03.720]         if (!identical(...future.workdir, getwd())) 
[18:02:03.720]             setwd(...future.workdir)
[18:02:03.720]         {
[18:02:03.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:03.720]                 ...future.oldOptions$nwarnings <- NULL
[18:02:03.720]             }
[18:02:03.720]             base::options(...future.oldOptions)
[18:02:03.720]             if (.Platform$OS.type == "windows") {
[18:02:03.720]                 old_names <- names(...future.oldEnvVars)
[18:02:03.720]                 envs <- base::Sys.getenv()
[18:02:03.720]                 names <- names(envs)
[18:02:03.720]                 common <- intersect(names, old_names)
[18:02:03.720]                 added <- setdiff(names, old_names)
[18:02:03.720]                 removed <- setdiff(old_names, names)
[18:02:03.720]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:03.720]                   envs[common]]
[18:02:03.720]                 NAMES <- toupper(changed)
[18:02:03.720]                 args <- list()
[18:02:03.720]                 for (kk in seq_along(NAMES)) {
[18:02:03.720]                   name <- changed[[kk]]
[18:02:03.720]                   NAME <- NAMES[[kk]]
[18:02:03.720]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:03.720]                     next
[18:02:03.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:03.720]                 }
[18:02:03.720]                 NAMES <- toupper(added)
[18:02:03.720]                 for (kk in seq_along(NAMES)) {
[18:02:03.720]                   name <- added[[kk]]
[18:02:03.720]                   NAME <- NAMES[[kk]]
[18:02:03.720]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:03.720]                     next
[18:02:03.720]                   args[[name]] <- ""
[18:02:03.720]                 }
[18:02:03.720]                 NAMES <- toupper(removed)
[18:02:03.720]                 for (kk in seq_along(NAMES)) {
[18:02:03.720]                   name <- removed[[kk]]
[18:02:03.720]                   NAME <- NAMES[[kk]]
[18:02:03.720]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:03.720]                     next
[18:02:03.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:03.720]                 }
[18:02:03.720]                 if (length(args) > 0) 
[18:02:03.720]                   base::do.call(base::Sys.setenv, args = args)
[18:02:03.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:03.720]             }
[18:02:03.720]             else {
[18:02:03.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:03.720]             }
[18:02:03.720]             {
[18:02:03.720]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:03.720]                   0L) {
[18:02:03.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:03.720]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:03.720]                   base::options(opts)
[18:02:03.720]                 }
[18:02:03.720]                 {
[18:02:03.720]                   {
[18:02:03.720]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:03.720]                     NULL
[18:02:03.720]                   }
[18:02:03.720]                   options(future.plan = NULL)
[18:02:03.720]                   if (is.na(NA_character_)) 
[18:02:03.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:03.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:03.720]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:03.720]                     .init = FALSE)
[18:02:03.720]                 }
[18:02:03.720]             }
[18:02:03.720]         }
[18:02:03.720]     })
[18:02:03.720]     if (TRUE) {
[18:02:03.720]         base::sink(type = "output", split = FALSE)
[18:02:03.720]         if (TRUE) {
[18:02:03.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:03.720]         }
[18:02:03.720]         else {
[18:02:03.720]             ...future.result["stdout"] <- base::list(NULL)
[18:02:03.720]         }
[18:02:03.720]         base::close(...future.stdout)
[18:02:03.720]         ...future.stdout <- NULL
[18:02:03.720]     }
[18:02:03.720]     ...future.result$conditions <- ...future.conditions
[18:02:03.720]     ...future.result$finished <- base::Sys.time()
[18:02:03.720]     ...future.result
[18:02:03.720] }
[18:02:03.727] Exporting 11 global objects (93.16 KiB) to cluster node #2 ...
[18:02:03.728] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[18:02:03.769] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[18:02:03.770] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[18:02:03.771] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[18:02:03.772] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[18:02:03.773] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[18:02:03.773] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[18:02:03.815] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[18:02:03.816] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[18:02:03.857] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[18:02:03.858] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[18:02:03.859] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[18:02:03.860] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[18:02:03.861] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[18:02:03.862] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:03.863] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:03.863] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[18:02:03.864] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[18:02:03.865] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:03.866] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:03.866] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:03.868] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:03.868] Exporting 11 global objects (93.16 KiB) to cluster node #2 ... DONE
[18:02:03.869] MultisessionFuture started
[18:02:03.870] - Launch lazy future ... done
[18:02:03.870] run() for ‘MultisessionFuture’ ... done
[18:02:03.871] Created future:
[18:02:03.871] MultisessionFuture:
[18:02:03.871] Label: ‘future_vapply-2’
[18:02:03.871] Expression:
[18:02:03.871] {
[18:02:03.871]     do.call(function(...) {
[18:02:03.871]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:03.871]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:03.871]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:03.871]             on.exit(options(oopts), add = TRUE)
[18:02:03.871]         }
[18:02:03.871]         {
[18:02:03.871]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:03.871]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:03.871]                 ...future.FUN(...future.X_jj, ...)
[18:02:03.871]             })
[18:02:03.871]         }
[18:02:03.871]     }, args = future.call.arguments)
[18:02:03.871] }
[18:02:03.871] Lazy evaluation: FALSE
[18:02:03.871] Asynchronous evaluation: TRUE
[18:02:03.871] Local evaluation: TRUE
[18:02:03.871] Environment: R_GlobalEnv
[18:02:03.871] Capture standard output: TRUE
[18:02:03.871] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:03.871] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:03.871] Packages: 1 packages (‘future.apply’)
[18:02:03.871] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:03.871] Resolved: FALSE
[18:02:03.871] Value: <not collected>
[18:02:03.871] Conditions captured: <none>
[18:02:03.871] Early signaling: FALSE
[18:02:03.871] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:03.871] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:03.886] Chunk #2 of 2 ... DONE
[18:02:03.886] Launching 2 futures (chunks) ... DONE
[18:02:03.886] Resolving 2 futures (chunks) ...
[18:02:03.887] resolve() on list ...
[18:02:03.887]  recursive: 0
[18:02:03.887]  length: 2
[18:02:03.888] 
[18:02:03.889] receiveMessageFromWorker() for ClusterFuture ...
[18:02:03.890] - Validating connection of MultisessionFuture
[18:02:03.890] - received message: FutureResult
[18:02:03.890] - Received FutureResult
[18:02:03.891] - Erased future from FutureRegistry
[18:02:03.891] result() for ClusterFuture ...
[18:02:03.891] - result already collected: FutureResult
[18:02:03.892] result() for ClusterFuture ... done
[18:02:03.892] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:03.892] Future #1
[18:02:03.893] result() for ClusterFuture ...
[18:02:03.893] - result already collected: FutureResult
[18:02:03.893] result() for ClusterFuture ... done
[18:02:03.894] result() for ClusterFuture ...
[18:02:03.894] - result already collected: FutureResult
[18:02:03.894] result() for ClusterFuture ... done
[18:02:03.895] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:03.895] - nx: 2
[18:02:03.895] - relay: TRUE
[18:02:03.895] - stdout: TRUE
[18:02:03.896] - signal: TRUE
[18:02:03.896] - resignal: FALSE
[18:02:03.896] - force: TRUE
[18:02:03.897] - relayed: [n=2] FALSE, FALSE
[18:02:03.897] - queued futures: [n=2] FALSE, FALSE
[18:02:03.897]  - until=1
[18:02:03.898]  - relaying element #1
[18:02:03.898] result() for ClusterFuture ...
[18:02:03.898] - result already collected: FutureResult
[18:02:03.898] result() for ClusterFuture ... done
[18:02:03.899] result() for ClusterFuture ...
[18:02:03.899] - result already collected: FutureResult
[18:02:03.899] result() for ClusterFuture ... done
[18:02:03.900] result() for ClusterFuture ...
[18:02:03.900] - result already collected: FutureResult
[18:02:03.900] result() for ClusterFuture ... done
[18:02:03.901] result() for ClusterFuture ...
[18:02:03.901] - result already collected: FutureResult
[18:02:03.901] result() for ClusterFuture ... done
[18:02:03.902] - relayed: [n=2] TRUE, FALSE
[18:02:03.902] - queued futures: [n=2] TRUE, FALSE
[18:02:03.902] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:03.903]  length: 1 (resolved future 1)
[18:02:03.914] receiveMessageFromWorker() for ClusterFuture ...
[18:02:03.914] - Validating connection of MultisessionFuture
[18:02:03.915] - received message: FutureResult
[18:02:03.915] - Received FutureResult
[18:02:03.916] - Erased future from FutureRegistry
[18:02:03.916] result() for ClusterFuture ...
[18:02:03.916] - result already collected: FutureResult
[18:02:03.917] result() for ClusterFuture ... done
[18:02:03.917] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:03.917] Future #2
[18:02:03.918] result() for ClusterFuture ...
[18:02:03.918] - result already collected: FutureResult
[18:02:03.918] result() for ClusterFuture ... done
[18:02:03.919] result() for ClusterFuture ...
[18:02:03.919] - result already collected: FutureResult
[18:02:03.919] result() for ClusterFuture ... done
[18:02:03.920] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:03.920] - nx: 2
[18:02:03.920] - relay: TRUE
[18:02:03.920] - stdout: TRUE
[18:02:03.921] - signal: TRUE
[18:02:03.921] - resignal: FALSE
[18:02:03.921] - force: TRUE
[18:02:03.922] - relayed: [n=2] TRUE, FALSE
[18:02:03.922] - queued futures: [n=2] TRUE, FALSE
[18:02:03.922]  - until=2
[18:02:03.923]  - relaying element #2
[18:02:03.923] result() for ClusterFuture ...
[18:02:03.923] - result already collected: FutureResult
[18:02:03.923] result() for ClusterFuture ... done
[18:02:03.924] result() for ClusterFuture ...
[18:02:03.924] - result already collected: FutureResult
[18:02:03.924] result() for ClusterFuture ... done
[18:02:03.925] result() for ClusterFuture ...
[18:02:03.925] - result already collected: FutureResult
[18:02:03.925] result() for ClusterFuture ... done
[18:02:03.926] result() for ClusterFuture ...
[18:02:03.926] - result already collected: FutureResult
[18:02:03.926] result() for ClusterFuture ... done
[18:02:03.927] - relayed: [n=2] TRUE, TRUE
[18:02:03.927] - queued futures: [n=2] TRUE, TRUE
[18:02:03.927] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:03.927]  length: 0 (resolved future 2)
[18:02:03.928] Relaying remaining futures
[18:02:03.928] signalConditionsASAP(NULL, pos=0) ...
[18:02:03.928] - nx: 2
[18:02:03.929] - relay: TRUE
[18:02:03.929] - stdout: TRUE
[18:02:03.929] - signal: TRUE
[18:02:03.929] - resignal: FALSE
[18:02:03.930] - force: TRUE
[18:02:03.930] - relayed: [n=2] TRUE, TRUE
[18:02:03.930] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:03.931] - relayed: [n=2] TRUE, TRUE
[18:02:03.931] - queued futures: [n=2] TRUE, TRUE
[18:02:03.931] signalConditionsASAP(NULL, pos=0) ... done
[18:02:03.932] resolve() on list ... DONE
[18:02:03.932] result() for ClusterFuture ...
[18:02:03.932] - result already collected: FutureResult
[18:02:03.933] result() for ClusterFuture ... done
[18:02:03.933] result() for ClusterFuture ...
[18:02:03.933] - result already collected: FutureResult
[18:02:03.934] result() for ClusterFuture ... done
[18:02:03.934] result() for ClusterFuture ...
[18:02:03.934] - result already collected: FutureResult
[18:02:03.935] result() for ClusterFuture ... done
[18:02:03.935] result() for ClusterFuture ...
[18:02:03.935] - result already collected: FutureResult
[18:02:03.935] result() for ClusterFuture ... done
[18:02:03.936]  - Number of value chunks collected: 2
[18:02:03.936] Resolving 2 futures (chunks) ... DONE
[18:02:03.936] Reducing values from 2 chunks ...
[18:02:03.937]  - Number of values collected after concatenation: 10
[18:02:03.937]  - Number of values expected: 10
[18:02:03.937] Reducing values from 2 chunks ... DONE
[18:02:03.938] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[18:02:03.940] future_lapply() ...
[18:02:03.953] Number of chunks: 2
[18:02:03.953] getGlobalsAndPackagesXApply() ...
[18:02:03.953]  - future.globals: TRUE
[18:02:03.953] getGlobalsAndPackages() ...
[18:02:03.954] Searching for globals...
[18:02:03.961] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:02:03.961] Searching for globals ... DONE
[18:02:03.961] Resolving globals: FALSE
[18:02:03.963] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[18:02:03.964] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:03.964] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:03.964] - packages: [1] ‘future.apply’
[18:02:03.965] getGlobalsAndPackages() ... DONE
[18:02:03.965]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:03.965]  - needed namespaces: [n=1] ‘future.apply’
[18:02:03.965] Finding globals ... DONE
[18:02:03.966]  - use_args: TRUE
[18:02:03.966]  - Getting '...' globals ...
[18:02:03.967] resolve() on list ...
[18:02:03.967]  recursive: 0
[18:02:03.967]  length: 1
[18:02:03.967]  elements: ‘...’
[18:02:03.967]  length: 0 (resolved future 1)
[18:02:03.968] resolve() on list ... DONE
[18:02:03.968]    - '...' content: [n=0] 
[18:02:03.968] List of 1
[18:02:03.968]  $ ...: list()
[18:02:03.968]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:03.968]  - attr(*, "where")=List of 1
[18:02:03.968]   ..$ ...:<environment: 0x6183c2e755c8> 
[18:02:03.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:03.968]  - attr(*, "resolved")= logi TRUE
[18:02:03.968]  - attr(*, "total_size")= num NA
[18:02:03.974]  - Getting '...' globals ... DONE
[18:02:03.974] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:03.974] List of 8
[18:02:03.974]  $ ...future.FUN:function (x, ...)  
[18:02:03.974]  $ x_FUN        :function (x)  
[18:02:03.974]  $ times        : int 1
[18:02:03.974]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:03.974]  $ stop_if_not  :function (...)  
[18:02:03.974]  $ dim          : NULL
[18:02:03.974]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:02:03.974]  $ ...          : list()
[18:02:03.974]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:03.974]  - attr(*, "where")=List of 8
[18:02:03.974]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:03.974]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:03.974]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:03.974]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:03.974]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:03.974]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:03.974]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:03.974]   ..$ ...          :<environment: 0x6183c2e755c8> 
[18:02:03.974]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:03.974]  - attr(*, "resolved")= logi FALSE
[18:02:03.974]  - attr(*, "total_size")= num 94336
[18:02:03.986] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:03.986] getGlobalsAndPackagesXApply() ... DONE
[18:02:03.987] Number of futures (= number of chunks): 2
[18:02:03.987] Launching 2 futures (chunks) ...
[18:02:03.987] Chunk #1 of 2 ...
[18:02:03.988]  - Finding globals in 'X' for chunk #1 ...
[18:02:03.988] getGlobalsAndPackages() ...
[18:02:03.988] Searching for globals...
[18:02:03.989] 
[18:02:03.989] Searching for globals ... DONE
[18:02:03.989] - globals: [0] <none>
[18:02:03.989] getGlobalsAndPackages() ... DONE
[18:02:03.989]    + additional globals found: [n=0] 
[18:02:03.990]    + additional namespaces needed: [n=0] 
[18:02:03.990]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:03.990]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:03.990]  - seeds: <none>
[18:02:03.990]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:03.991] getGlobalsAndPackages() ...
[18:02:03.991] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:03.994] Resolving globals: FALSE
[18:02:03.995] Tweak future expression to call with '...' arguments ...
[18:02:03.995] {
[18:02:03.995]     do.call(function(...) {
[18:02:03.995]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:03.995]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:03.995]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:03.995]             on.exit(options(oopts), add = TRUE)
[18:02:03.995]         }
[18:02:03.995]         {
[18:02:03.995]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:03.995]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:03.995]                 ...future.FUN(...future.X_jj, ...)
[18:02:03.995]             })
[18:02:03.995]         }
[18:02:03.995]     }, args = future.call.arguments)
[18:02:03.995] }
[18:02:03.996] Tweak future expression to call with '...' arguments ... DONE
[18:02:03.997] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:03.997] - packages: [1] ‘future.apply’
[18:02:03.998] getGlobalsAndPackages() ... DONE
[18:02:03.998] run() for ‘Future’ ...
[18:02:03.998] - state: ‘created’
[18:02:03.999] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:04.023] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:04.023] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:04.023]   - Field: ‘node’
[18:02:04.023]   - Field: ‘label’
[18:02:04.024]   - Field: ‘local’
[18:02:04.024]   - Field: ‘owner’
[18:02:04.024]   - Field: ‘envir’
[18:02:04.024]   - Field: ‘workers’
[18:02:04.024]   - Field: ‘packages’
[18:02:04.025]   - Field: ‘gc’
[18:02:04.025]   - Field: ‘conditions’
[18:02:04.025]   - Field: ‘persistent’
[18:02:04.025]   - Field: ‘expr’
[18:02:04.025]   - Field: ‘uuid’
[18:02:04.026]   - Field: ‘seed’
[18:02:04.026]   - Field: ‘version’
[18:02:04.026]   - Field: ‘result’
[18:02:04.026]   - Field: ‘asynchronous’
[18:02:04.026]   - Field: ‘calls’
[18:02:04.026]   - Field: ‘globals’
[18:02:04.027]   - Field: ‘stdout’
[18:02:04.027]   - Field: ‘earlySignal’
[18:02:04.027]   - Field: ‘lazy’
[18:02:04.027]   - Field: ‘state’
[18:02:04.027] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:04.028] - Launch lazy future ...
[18:02:04.028] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:04.029] Packages needed by future strategies (n = 0): <none>
[18:02:04.030] {
[18:02:04.030]     {
[18:02:04.030]         {
[18:02:04.030]             ...future.startTime <- base::Sys.time()
[18:02:04.030]             {
[18:02:04.030]                 {
[18:02:04.030]                   {
[18:02:04.030]                     {
[18:02:04.030]                       {
[18:02:04.030]                         base::local({
[18:02:04.030]                           has_future <- base::requireNamespace("future", 
[18:02:04.030]                             quietly = TRUE)
[18:02:04.030]                           if (has_future) {
[18:02:04.030]                             ns <- base::getNamespace("future")
[18:02:04.030]                             version <- ns[[".package"]][["version"]]
[18:02:04.030]                             if (is.null(version)) 
[18:02:04.030]                               version <- utils::packageVersion("future")
[18:02:04.030]                           }
[18:02:04.030]                           else {
[18:02:04.030]                             version <- NULL
[18:02:04.030]                           }
[18:02:04.030]                           if (!has_future || version < "1.8.0") {
[18:02:04.030]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:04.030]                               "", base::R.version$version.string), 
[18:02:04.030]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:04.030]                                 base::R.version$platform, 8 * 
[18:02:04.030]                                   base::.Machine$sizeof.pointer), 
[18:02:04.030]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:04.030]                                 "release", "version")], collapse = " "), 
[18:02:04.030]                               hostname = base::Sys.info()[["nodename"]])
[18:02:04.030]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:04.030]                               info)
[18:02:04.030]                             info <- base::paste(info, collapse = "; ")
[18:02:04.030]                             if (!has_future) {
[18:02:04.030]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:04.030]                                 info)
[18:02:04.030]                             }
[18:02:04.030]                             else {
[18:02:04.030]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:04.030]                                 info, version)
[18:02:04.030]                             }
[18:02:04.030]                             base::stop(msg)
[18:02:04.030]                           }
[18:02:04.030]                         })
[18:02:04.030]                       }
[18:02:04.030]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:04.030]                       base::options(mc.cores = 1L)
[18:02:04.030]                     }
[18:02:04.030]                     base::local({
[18:02:04.030]                       for (pkg in "future.apply") {
[18:02:04.030]                         base::loadNamespace(pkg)
[18:02:04.030]                         base::library(pkg, character.only = TRUE)
[18:02:04.030]                       }
[18:02:04.030]                     })
[18:02:04.030]                   }
[18:02:04.030]                   ...future.strategy.old <- future::plan("list")
[18:02:04.030]                   options(future.plan = NULL)
[18:02:04.030]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:04.030]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:04.030]                 }
[18:02:04.030]                 ...future.workdir <- getwd()
[18:02:04.030]             }
[18:02:04.030]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:04.030]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:04.030]         }
[18:02:04.030]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:04.030]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:04.030]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:04.030]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:04.030]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:04.030]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:04.030]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:04.030]             base::names(...future.oldOptions))
[18:02:04.030]     }
[18:02:04.030]     if (FALSE) {
[18:02:04.030]     }
[18:02:04.030]     else {
[18:02:04.030]         if (TRUE) {
[18:02:04.030]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:04.030]                 open = "w")
[18:02:04.030]         }
[18:02:04.030]         else {
[18:02:04.030]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:04.030]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:04.030]         }
[18:02:04.030]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:04.030]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:04.030]             base::sink(type = "output", split = FALSE)
[18:02:04.030]             base::close(...future.stdout)
[18:02:04.030]         }, add = TRUE)
[18:02:04.030]     }
[18:02:04.030]     ...future.frame <- base::sys.nframe()
[18:02:04.030]     ...future.conditions <- base::list()
[18:02:04.030]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:04.030]     if (FALSE) {
[18:02:04.030]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:04.030]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:04.030]     }
[18:02:04.030]     ...future.result <- base::tryCatch({
[18:02:04.030]         base::withCallingHandlers({
[18:02:04.030]             ...future.value <- base::withVisible(base::local({
[18:02:04.030]                 ...future.makeSendCondition <- base::local({
[18:02:04.030]                   sendCondition <- NULL
[18:02:04.030]                   function(frame = 1L) {
[18:02:04.030]                     if (is.function(sendCondition)) 
[18:02:04.030]                       return(sendCondition)
[18:02:04.030]                     ns <- getNamespace("parallel")
[18:02:04.030]                     if (exists("sendData", mode = "function", 
[18:02:04.030]                       envir = ns)) {
[18:02:04.030]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:04.030]                         envir = ns)
[18:02:04.030]                       envir <- sys.frame(frame)
[18:02:04.030]                       master <- NULL
[18:02:04.030]                       while (!identical(envir, .GlobalEnv) && 
[18:02:04.030]                         !identical(envir, emptyenv())) {
[18:02:04.030]                         if (exists("master", mode = "list", envir = envir, 
[18:02:04.030]                           inherits = FALSE)) {
[18:02:04.030]                           master <- get("master", mode = "list", 
[18:02:04.030]                             envir = envir, inherits = FALSE)
[18:02:04.030]                           if (inherits(master, c("SOCKnode", 
[18:02:04.030]                             "SOCK0node"))) {
[18:02:04.030]                             sendCondition <<- function(cond) {
[18:02:04.030]                               data <- list(type = "VALUE", value = cond, 
[18:02:04.030]                                 success = TRUE)
[18:02:04.030]                               parallel_sendData(master, data)
[18:02:04.030]                             }
[18:02:04.030]                             return(sendCondition)
[18:02:04.030]                           }
[18:02:04.030]                         }
[18:02:04.030]                         frame <- frame + 1L
[18:02:04.030]                         envir <- sys.frame(frame)
[18:02:04.030]                       }
[18:02:04.030]                     }
[18:02:04.030]                     sendCondition <<- function(cond) NULL
[18:02:04.030]                   }
[18:02:04.030]                 })
[18:02:04.030]                 withCallingHandlers({
[18:02:04.030]                   {
[18:02:04.030]                     do.call(function(...) {
[18:02:04.030]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:04.030]                       if (!identical(...future.globals.maxSize.org, 
[18:02:04.030]                         ...future.globals.maxSize)) {
[18:02:04.030]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:04.030]                         on.exit(options(oopts), add = TRUE)
[18:02:04.030]                       }
[18:02:04.030]                       {
[18:02:04.030]                         lapply(seq_along(...future.elements_ii), 
[18:02:04.030]                           FUN = function(jj) {
[18:02:04.030]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:04.030]                             ...future.FUN(...future.X_jj, ...)
[18:02:04.030]                           })
[18:02:04.030]                       }
[18:02:04.030]                     }, args = future.call.arguments)
[18:02:04.030]                   }
[18:02:04.030]                 }, immediateCondition = function(cond) {
[18:02:04.030]                   sendCondition <- ...future.makeSendCondition()
[18:02:04.030]                   sendCondition(cond)
[18:02:04.030]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:04.030]                   {
[18:02:04.030]                     inherits <- base::inherits
[18:02:04.030]                     invokeRestart <- base::invokeRestart
[18:02:04.030]                     is.null <- base::is.null
[18:02:04.030]                     muffled <- FALSE
[18:02:04.030]                     if (inherits(cond, "message")) {
[18:02:04.030]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:04.030]                       if (muffled) 
[18:02:04.030]                         invokeRestart("muffleMessage")
[18:02:04.030]                     }
[18:02:04.030]                     else if (inherits(cond, "warning")) {
[18:02:04.030]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:04.030]                       if (muffled) 
[18:02:04.030]                         invokeRestart("muffleWarning")
[18:02:04.030]                     }
[18:02:04.030]                     else if (inherits(cond, "condition")) {
[18:02:04.030]                       if (!is.null(pattern)) {
[18:02:04.030]                         computeRestarts <- base::computeRestarts
[18:02:04.030]                         grepl <- base::grepl
[18:02:04.030]                         restarts <- computeRestarts(cond)
[18:02:04.030]                         for (restart in restarts) {
[18:02:04.030]                           name <- restart$name
[18:02:04.030]                           if (is.null(name)) 
[18:02:04.030]                             next
[18:02:04.030]                           if (!grepl(pattern, name)) 
[18:02:04.030]                             next
[18:02:04.030]                           invokeRestart(restart)
[18:02:04.030]                           muffled <- TRUE
[18:02:04.030]                           break
[18:02:04.030]                         }
[18:02:04.030]                       }
[18:02:04.030]                     }
[18:02:04.030]                     invisible(muffled)
[18:02:04.030]                   }
[18:02:04.030]                   muffleCondition(cond)
[18:02:04.030]                 })
[18:02:04.030]             }))
[18:02:04.030]             future::FutureResult(value = ...future.value$value, 
[18:02:04.030]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:04.030]                   ...future.rng), globalenv = if (FALSE) 
[18:02:04.030]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:04.030]                     ...future.globalenv.names))
[18:02:04.030]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:04.030]         }, condition = base::local({
[18:02:04.030]             c <- base::c
[18:02:04.030]             inherits <- base::inherits
[18:02:04.030]             invokeRestart <- base::invokeRestart
[18:02:04.030]             length <- base::length
[18:02:04.030]             list <- base::list
[18:02:04.030]             seq.int <- base::seq.int
[18:02:04.030]             signalCondition <- base::signalCondition
[18:02:04.030]             sys.calls <- base::sys.calls
[18:02:04.030]             `[[` <- base::`[[`
[18:02:04.030]             `+` <- base::`+`
[18:02:04.030]             `<<-` <- base::`<<-`
[18:02:04.030]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:04.030]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:04.030]                   3L)]
[18:02:04.030]             }
[18:02:04.030]             function(cond) {
[18:02:04.030]                 is_error <- inherits(cond, "error")
[18:02:04.030]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:04.030]                   NULL)
[18:02:04.030]                 if (is_error) {
[18:02:04.030]                   sessionInformation <- function() {
[18:02:04.030]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:04.030]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:04.030]                       search = base::search(), system = base::Sys.info())
[18:02:04.030]                   }
[18:02:04.030]                   ...future.conditions[[length(...future.conditions) + 
[18:02:04.030]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:04.030]                     cond$call), session = sessionInformation(), 
[18:02:04.030]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:04.030]                   signalCondition(cond)
[18:02:04.030]                 }
[18:02:04.030]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:04.030]                 "immediateCondition"))) {
[18:02:04.030]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:04.030]                   ...future.conditions[[length(...future.conditions) + 
[18:02:04.030]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:04.030]                   if (TRUE && !signal) {
[18:02:04.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:04.030]                     {
[18:02:04.030]                       inherits <- base::inherits
[18:02:04.030]                       invokeRestart <- base::invokeRestart
[18:02:04.030]                       is.null <- base::is.null
[18:02:04.030]                       muffled <- FALSE
[18:02:04.030]                       if (inherits(cond, "message")) {
[18:02:04.030]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:04.030]                         if (muffled) 
[18:02:04.030]                           invokeRestart("muffleMessage")
[18:02:04.030]                       }
[18:02:04.030]                       else if (inherits(cond, "warning")) {
[18:02:04.030]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:04.030]                         if (muffled) 
[18:02:04.030]                           invokeRestart("muffleWarning")
[18:02:04.030]                       }
[18:02:04.030]                       else if (inherits(cond, "condition")) {
[18:02:04.030]                         if (!is.null(pattern)) {
[18:02:04.030]                           computeRestarts <- base::computeRestarts
[18:02:04.030]                           grepl <- base::grepl
[18:02:04.030]                           restarts <- computeRestarts(cond)
[18:02:04.030]                           for (restart in restarts) {
[18:02:04.030]                             name <- restart$name
[18:02:04.030]                             if (is.null(name)) 
[18:02:04.030]                               next
[18:02:04.030]                             if (!grepl(pattern, name)) 
[18:02:04.030]                               next
[18:02:04.030]                             invokeRestart(restart)
[18:02:04.030]                             muffled <- TRUE
[18:02:04.030]                             break
[18:02:04.030]                           }
[18:02:04.030]                         }
[18:02:04.030]                       }
[18:02:04.030]                       invisible(muffled)
[18:02:04.030]                     }
[18:02:04.030]                     muffleCondition(cond, pattern = "^muffle")
[18:02:04.030]                   }
[18:02:04.030]                 }
[18:02:04.030]                 else {
[18:02:04.030]                   if (TRUE) {
[18:02:04.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:04.030]                     {
[18:02:04.030]                       inherits <- base::inherits
[18:02:04.030]                       invokeRestart <- base::invokeRestart
[18:02:04.030]                       is.null <- base::is.null
[18:02:04.030]                       muffled <- FALSE
[18:02:04.030]                       if (inherits(cond, "message")) {
[18:02:04.030]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:04.030]                         if (muffled) 
[18:02:04.030]                           invokeRestart("muffleMessage")
[18:02:04.030]                       }
[18:02:04.030]                       else if (inherits(cond, "warning")) {
[18:02:04.030]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:04.030]                         if (muffled) 
[18:02:04.030]                           invokeRestart("muffleWarning")
[18:02:04.030]                       }
[18:02:04.030]                       else if (inherits(cond, "condition")) {
[18:02:04.030]                         if (!is.null(pattern)) {
[18:02:04.030]                           computeRestarts <- base::computeRestarts
[18:02:04.030]                           grepl <- base::grepl
[18:02:04.030]                           restarts <- computeRestarts(cond)
[18:02:04.030]                           for (restart in restarts) {
[18:02:04.030]                             name <- restart$name
[18:02:04.030]                             if (is.null(name)) 
[18:02:04.030]                               next
[18:02:04.030]                             if (!grepl(pattern, name)) 
[18:02:04.030]                               next
[18:02:04.030]                             invokeRestart(restart)
[18:02:04.030]                             muffled <- TRUE
[18:02:04.030]                             break
[18:02:04.030]                           }
[18:02:04.030]                         }
[18:02:04.030]                       }
[18:02:04.030]                       invisible(muffled)
[18:02:04.030]                     }
[18:02:04.030]                     muffleCondition(cond, pattern = "^muffle")
[18:02:04.030]                   }
[18:02:04.030]                 }
[18:02:04.030]             }
[18:02:04.030]         }))
[18:02:04.030]     }, error = function(ex) {
[18:02:04.030]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:04.030]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:04.030]                 ...future.rng), started = ...future.startTime, 
[18:02:04.030]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:04.030]             version = "1.8"), class = "FutureResult")
[18:02:04.030]     }, finally = {
[18:02:04.030]         if (!identical(...future.workdir, getwd())) 
[18:02:04.030]             setwd(...future.workdir)
[18:02:04.030]         {
[18:02:04.030]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:04.030]                 ...future.oldOptions$nwarnings <- NULL
[18:02:04.030]             }
[18:02:04.030]             base::options(...future.oldOptions)
[18:02:04.030]             if (.Platform$OS.type == "windows") {
[18:02:04.030]                 old_names <- names(...future.oldEnvVars)
[18:02:04.030]                 envs <- base::Sys.getenv()
[18:02:04.030]                 names <- names(envs)
[18:02:04.030]                 common <- intersect(names, old_names)
[18:02:04.030]                 added <- setdiff(names, old_names)
[18:02:04.030]                 removed <- setdiff(old_names, names)
[18:02:04.030]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:04.030]                   envs[common]]
[18:02:04.030]                 NAMES <- toupper(changed)
[18:02:04.030]                 args <- list()
[18:02:04.030]                 for (kk in seq_along(NAMES)) {
[18:02:04.030]                   name <- changed[[kk]]
[18:02:04.030]                   NAME <- NAMES[[kk]]
[18:02:04.030]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:04.030]                     next
[18:02:04.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:04.030]                 }
[18:02:04.030]                 NAMES <- toupper(added)
[18:02:04.030]                 for (kk in seq_along(NAMES)) {
[18:02:04.030]                   name <- added[[kk]]
[18:02:04.030]                   NAME <- NAMES[[kk]]
[18:02:04.030]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:04.030]                     next
[18:02:04.030]                   args[[name]] <- ""
[18:02:04.030]                 }
[18:02:04.030]                 NAMES <- toupper(removed)
[18:02:04.030]                 for (kk in seq_along(NAMES)) {
[18:02:04.030]                   name <- removed[[kk]]
[18:02:04.030]                   NAME <- NAMES[[kk]]
[18:02:04.030]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:04.030]                     next
[18:02:04.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:04.030]                 }
[18:02:04.030]                 if (length(args) > 0) 
[18:02:04.030]                   base::do.call(base::Sys.setenv, args = args)
[18:02:04.030]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:04.030]             }
[18:02:04.030]             else {
[18:02:04.030]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:04.030]             }
[18:02:04.030]             {
[18:02:04.030]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:04.030]                   0L) {
[18:02:04.030]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:04.030]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:04.030]                   base::options(opts)
[18:02:04.030]                 }
[18:02:04.030]                 {
[18:02:04.030]                   {
[18:02:04.030]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:04.030]                     NULL
[18:02:04.030]                   }
[18:02:04.030]                   options(future.plan = NULL)
[18:02:04.030]                   if (is.na(NA_character_)) 
[18:02:04.030]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:04.030]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:04.030]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:04.030]                     .init = FALSE)
[18:02:04.030]                 }
[18:02:04.030]             }
[18:02:04.030]         }
[18:02:04.030]     })
[18:02:04.030]     if (TRUE) {
[18:02:04.030]         base::sink(type = "output", split = FALSE)
[18:02:04.030]         if (TRUE) {
[18:02:04.030]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:04.030]         }
[18:02:04.030]         else {
[18:02:04.030]             ...future.result["stdout"] <- base::list(NULL)
[18:02:04.030]         }
[18:02:04.030]         base::close(...future.stdout)
[18:02:04.030]         ...future.stdout <- NULL
[18:02:04.030]     }
[18:02:04.030]     ...future.result$conditions <- ...future.conditions
[18:02:04.030]     ...future.result$finished <- base::Sys.time()
[18:02:04.030]     ...future.result
[18:02:04.030] }
[18:02:04.035] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[18:02:04.035] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[18:02:04.076] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[18:02:04.077] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[18:02:04.078] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[18:02:04.078] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[18:02:04.079] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[18:02:04.080] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[18:02:04.121] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[18:02:04.122] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[18:02:04.163] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[18:02:04.164] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[18:02:04.165] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[18:02:04.165] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[18:02:04.167] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[18:02:04.167] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:04.168] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:04.169] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[18:02:04.170] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[18:02:04.170] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:04.172] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:04.172] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:04.173] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:04.174] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[18:02:04.175] MultisessionFuture started
[18:02:04.175] - Launch lazy future ... done
[18:02:04.176] run() for ‘MultisessionFuture’ ... done
[18:02:04.176] Created future:
[18:02:04.176] MultisessionFuture:
[18:02:04.176] Label: ‘future_vapply-1’
[18:02:04.176] Expression:
[18:02:04.176] {
[18:02:04.176]     do.call(function(...) {
[18:02:04.176]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:04.176]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:04.176]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:04.176]             on.exit(options(oopts), add = TRUE)
[18:02:04.176]         }
[18:02:04.176]         {
[18:02:04.176]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:04.176]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:04.176]                 ...future.FUN(...future.X_jj, ...)
[18:02:04.176]             })
[18:02:04.176]         }
[18:02:04.176]     }, args = future.call.arguments)
[18:02:04.176] }
[18:02:04.176] Lazy evaluation: FALSE
[18:02:04.176] Asynchronous evaluation: TRUE
[18:02:04.176] Local evaluation: TRUE
[18:02:04.176] Environment: R_GlobalEnv
[18:02:04.176] Capture standard output: TRUE
[18:02:04.176] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:04.176] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:04.176] Packages: 1 packages (‘future.apply’)
[18:02:04.176] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:04.176] Resolved: FALSE
[18:02:04.176] Value: <not collected>
[18:02:04.176] Conditions captured: <none>
[18:02:04.176] Early signaling: FALSE
[18:02:04.176] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:04.176] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:04.191] Chunk #1 of 2 ... DONE
[18:02:04.192] Chunk #2 of 2 ...
[18:02:04.192]  - Finding globals in 'X' for chunk #2 ...
[18:02:04.192] getGlobalsAndPackages() ...
[18:02:04.193] Searching for globals...
[18:02:04.194] 
[18:02:04.194] Searching for globals ... DONE
[18:02:04.194] - globals: [0] <none>
[18:02:04.195] getGlobalsAndPackages() ... DONE
[18:02:04.195]    + additional globals found: [n=0] 
[18:02:04.195]    + additional namespaces needed: [n=0] 
[18:02:04.196]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:04.196]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:04.196]  - seeds: <none>
[18:02:04.196]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:04.197] getGlobalsAndPackages() ...
[18:02:04.197] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:04.198] Resolving globals: FALSE
[18:02:04.198] Tweak future expression to call with '...' arguments ...
[18:02:04.198] {
[18:02:04.198]     do.call(function(...) {
[18:02:04.198]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:04.198]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:04.198]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:04.198]             on.exit(options(oopts), add = TRUE)
[18:02:04.198]         }
[18:02:04.198]         {
[18:02:04.198]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:04.198]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:04.198]                 ...future.FUN(...future.X_jj, ...)
[18:02:04.198]             })
[18:02:04.198]         }
[18:02:04.198]     }, args = future.call.arguments)
[18:02:04.198] }
[18:02:04.199] Tweak future expression to call with '...' arguments ... DONE
[18:02:04.201] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:04.201] - packages: [1] ‘future.apply’
[18:02:04.202] getGlobalsAndPackages() ... DONE
[18:02:04.203] run() for ‘Future’ ...
[18:02:04.203] - state: ‘created’
[18:02:04.203] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:04.239] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:04.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:04.240]   - Field: ‘node’
[18:02:04.241]   - Field: ‘label’
[18:02:04.241]   - Field: ‘local’
[18:02:04.241]   - Field: ‘owner’
[18:02:04.241]   - Field: ‘envir’
[18:02:04.242]   - Field: ‘workers’
[18:02:04.242]   - Field: ‘packages’
[18:02:04.242]   - Field: ‘gc’
[18:02:04.243]   - Field: ‘conditions’
[18:02:04.243]   - Field: ‘persistent’
[18:02:04.243]   - Field: ‘expr’
[18:02:04.243]   - Field: ‘uuid’
[18:02:04.244]   - Field: ‘seed’
[18:02:04.244]   - Field: ‘version’
[18:02:04.244]   - Field: ‘result’
[18:02:04.244]   - Field: ‘asynchronous’
[18:02:04.245]   - Field: ‘calls’
[18:02:04.245]   - Field: ‘globals’
[18:02:04.245]   - Field: ‘stdout’
[18:02:04.245]   - Field: ‘earlySignal’
[18:02:04.246]   - Field: ‘lazy’
[18:02:04.246]   - Field: ‘state’
[18:02:04.246] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:04.247] - Launch lazy future ...
[18:02:04.248] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:04.248] Packages needed by future strategies (n = 0): <none>
[18:02:04.249] {
[18:02:04.249]     {
[18:02:04.249]         {
[18:02:04.249]             ...future.startTime <- base::Sys.time()
[18:02:04.249]             {
[18:02:04.249]                 {
[18:02:04.249]                   {
[18:02:04.249]                     {
[18:02:04.249]                       {
[18:02:04.249]                         base::local({
[18:02:04.249]                           has_future <- base::requireNamespace("future", 
[18:02:04.249]                             quietly = TRUE)
[18:02:04.249]                           if (has_future) {
[18:02:04.249]                             ns <- base::getNamespace("future")
[18:02:04.249]                             version <- ns[[".package"]][["version"]]
[18:02:04.249]                             if (is.null(version)) 
[18:02:04.249]                               version <- utils::packageVersion("future")
[18:02:04.249]                           }
[18:02:04.249]                           else {
[18:02:04.249]                             version <- NULL
[18:02:04.249]                           }
[18:02:04.249]                           if (!has_future || version < "1.8.0") {
[18:02:04.249]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:04.249]                               "", base::R.version$version.string), 
[18:02:04.249]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:04.249]                                 base::R.version$platform, 8 * 
[18:02:04.249]                                   base::.Machine$sizeof.pointer), 
[18:02:04.249]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:04.249]                                 "release", "version")], collapse = " "), 
[18:02:04.249]                               hostname = base::Sys.info()[["nodename"]])
[18:02:04.249]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:04.249]                               info)
[18:02:04.249]                             info <- base::paste(info, collapse = "; ")
[18:02:04.249]                             if (!has_future) {
[18:02:04.249]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:04.249]                                 info)
[18:02:04.249]                             }
[18:02:04.249]                             else {
[18:02:04.249]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:04.249]                                 info, version)
[18:02:04.249]                             }
[18:02:04.249]                             base::stop(msg)
[18:02:04.249]                           }
[18:02:04.249]                         })
[18:02:04.249]                       }
[18:02:04.249]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:04.249]                       base::options(mc.cores = 1L)
[18:02:04.249]                     }
[18:02:04.249]                     base::local({
[18:02:04.249]                       for (pkg in "future.apply") {
[18:02:04.249]                         base::loadNamespace(pkg)
[18:02:04.249]                         base::library(pkg, character.only = TRUE)
[18:02:04.249]                       }
[18:02:04.249]                     })
[18:02:04.249]                   }
[18:02:04.249]                   ...future.strategy.old <- future::plan("list")
[18:02:04.249]                   options(future.plan = NULL)
[18:02:04.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:04.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:04.249]                 }
[18:02:04.249]                 ...future.workdir <- getwd()
[18:02:04.249]             }
[18:02:04.249]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:04.249]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:04.249]         }
[18:02:04.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:04.249]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:04.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:04.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:04.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:04.249]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:04.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:04.249]             base::names(...future.oldOptions))
[18:02:04.249]     }
[18:02:04.249]     if (FALSE) {
[18:02:04.249]     }
[18:02:04.249]     else {
[18:02:04.249]         if (TRUE) {
[18:02:04.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:04.249]                 open = "w")
[18:02:04.249]         }
[18:02:04.249]         else {
[18:02:04.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:04.249]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:04.249]         }
[18:02:04.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:04.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:04.249]             base::sink(type = "output", split = FALSE)
[18:02:04.249]             base::close(...future.stdout)
[18:02:04.249]         }, add = TRUE)
[18:02:04.249]     }
[18:02:04.249]     ...future.frame <- base::sys.nframe()
[18:02:04.249]     ...future.conditions <- base::list()
[18:02:04.249]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:04.249]     if (FALSE) {
[18:02:04.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:04.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:04.249]     }
[18:02:04.249]     ...future.result <- base::tryCatch({
[18:02:04.249]         base::withCallingHandlers({
[18:02:04.249]             ...future.value <- base::withVisible(base::local({
[18:02:04.249]                 ...future.makeSendCondition <- base::local({
[18:02:04.249]                   sendCondition <- NULL
[18:02:04.249]                   function(frame = 1L) {
[18:02:04.249]                     if (is.function(sendCondition)) 
[18:02:04.249]                       return(sendCondition)
[18:02:04.249]                     ns <- getNamespace("parallel")
[18:02:04.249]                     if (exists("sendData", mode = "function", 
[18:02:04.249]                       envir = ns)) {
[18:02:04.249]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:04.249]                         envir = ns)
[18:02:04.249]                       envir <- sys.frame(frame)
[18:02:04.249]                       master <- NULL
[18:02:04.249]                       while (!identical(envir, .GlobalEnv) && 
[18:02:04.249]                         !identical(envir, emptyenv())) {
[18:02:04.249]                         if (exists("master", mode = "list", envir = envir, 
[18:02:04.249]                           inherits = FALSE)) {
[18:02:04.249]                           master <- get("master", mode = "list", 
[18:02:04.249]                             envir = envir, inherits = FALSE)
[18:02:04.249]                           if (inherits(master, c("SOCKnode", 
[18:02:04.249]                             "SOCK0node"))) {
[18:02:04.249]                             sendCondition <<- function(cond) {
[18:02:04.249]                               data <- list(type = "VALUE", value = cond, 
[18:02:04.249]                                 success = TRUE)
[18:02:04.249]                               parallel_sendData(master, data)
[18:02:04.249]                             }
[18:02:04.249]                             return(sendCondition)
[18:02:04.249]                           }
[18:02:04.249]                         }
[18:02:04.249]                         frame <- frame + 1L
[18:02:04.249]                         envir <- sys.frame(frame)
[18:02:04.249]                       }
[18:02:04.249]                     }
[18:02:04.249]                     sendCondition <<- function(cond) NULL
[18:02:04.249]                   }
[18:02:04.249]                 })
[18:02:04.249]                 withCallingHandlers({
[18:02:04.249]                   {
[18:02:04.249]                     do.call(function(...) {
[18:02:04.249]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:04.249]                       if (!identical(...future.globals.maxSize.org, 
[18:02:04.249]                         ...future.globals.maxSize)) {
[18:02:04.249]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:04.249]                         on.exit(options(oopts), add = TRUE)
[18:02:04.249]                       }
[18:02:04.249]                       {
[18:02:04.249]                         lapply(seq_along(...future.elements_ii), 
[18:02:04.249]                           FUN = function(jj) {
[18:02:04.249]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:04.249]                             ...future.FUN(...future.X_jj, ...)
[18:02:04.249]                           })
[18:02:04.249]                       }
[18:02:04.249]                     }, args = future.call.arguments)
[18:02:04.249]                   }
[18:02:04.249]                 }, immediateCondition = function(cond) {
[18:02:04.249]                   sendCondition <- ...future.makeSendCondition()
[18:02:04.249]                   sendCondition(cond)
[18:02:04.249]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:04.249]                   {
[18:02:04.249]                     inherits <- base::inherits
[18:02:04.249]                     invokeRestart <- base::invokeRestart
[18:02:04.249]                     is.null <- base::is.null
[18:02:04.249]                     muffled <- FALSE
[18:02:04.249]                     if (inherits(cond, "message")) {
[18:02:04.249]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:04.249]                       if (muffled) 
[18:02:04.249]                         invokeRestart("muffleMessage")
[18:02:04.249]                     }
[18:02:04.249]                     else if (inherits(cond, "warning")) {
[18:02:04.249]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:04.249]                       if (muffled) 
[18:02:04.249]                         invokeRestart("muffleWarning")
[18:02:04.249]                     }
[18:02:04.249]                     else if (inherits(cond, "condition")) {
[18:02:04.249]                       if (!is.null(pattern)) {
[18:02:04.249]                         computeRestarts <- base::computeRestarts
[18:02:04.249]                         grepl <- base::grepl
[18:02:04.249]                         restarts <- computeRestarts(cond)
[18:02:04.249]                         for (restart in restarts) {
[18:02:04.249]                           name <- restart$name
[18:02:04.249]                           if (is.null(name)) 
[18:02:04.249]                             next
[18:02:04.249]                           if (!grepl(pattern, name)) 
[18:02:04.249]                             next
[18:02:04.249]                           invokeRestart(restart)
[18:02:04.249]                           muffled <- TRUE
[18:02:04.249]                           break
[18:02:04.249]                         }
[18:02:04.249]                       }
[18:02:04.249]                     }
[18:02:04.249]                     invisible(muffled)
[18:02:04.249]                   }
[18:02:04.249]                   muffleCondition(cond)
[18:02:04.249]                 })
[18:02:04.249]             }))
[18:02:04.249]             future::FutureResult(value = ...future.value$value, 
[18:02:04.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:04.249]                   ...future.rng), globalenv = if (FALSE) 
[18:02:04.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:04.249]                     ...future.globalenv.names))
[18:02:04.249]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:04.249]         }, condition = base::local({
[18:02:04.249]             c <- base::c
[18:02:04.249]             inherits <- base::inherits
[18:02:04.249]             invokeRestart <- base::invokeRestart
[18:02:04.249]             length <- base::length
[18:02:04.249]             list <- base::list
[18:02:04.249]             seq.int <- base::seq.int
[18:02:04.249]             signalCondition <- base::signalCondition
[18:02:04.249]             sys.calls <- base::sys.calls
[18:02:04.249]             `[[` <- base::`[[`
[18:02:04.249]             `+` <- base::`+`
[18:02:04.249]             `<<-` <- base::`<<-`
[18:02:04.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:04.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:04.249]                   3L)]
[18:02:04.249]             }
[18:02:04.249]             function(cond) {
[18:02:04.249]                 is_error <- inherits(cond, "error")
[18:02:04.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:04.249]                   NULL)
[18:02:04.249]                 if (is_error) {
[18:02:04.249]                   sessionInformation <- function() {
[18:02:04.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:04.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:04.249]                       search = base::search(), system = base::Sys.info())
[18:02:04.249]                   }
[18:02:04.249]                   ...future.conditions[[length(...future.conditions) + 
[18:02:04.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:04.249]                     cond$call), session = sessionInformation(), 
[18:02:04.249]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:04.249]                   signalCondition(cond)
[18:02:04.249]                 }
[18:02:04.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:04.249]                 "immediateCondition"))) {
[18:02:04.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:04.249]                   ...future.conditions[[length(...future.conditions) + 
[18:02:04.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:04.249]                   if (TRUE && !signal) {
[18:02:04.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:04.249]                     {
[18:02:04.249]                       inherits <- base::inherits
[18:02:04.249]                       invokeRestart <- base::invokeRestart
[18:02:04.249]                       is.null <- base::is.null
[18:02:04.249]                       muffled <- FALSE
[18:02:04.249]                       if (inherits(cond, "message")) {
[18:02:04.249]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:04.249]                         if (muffled) 
[18:02:04.249]                           invokeRestart("muffleMessage")
[18:02:04.249]                       }
[18:02:04.249]                       else if (inherits(cond, "warning")) {
[18:02:04.249]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:04.249]                         if (muffled) 
[18:02:04.249]                           invokeRestart("muffleWarning")
[18:02:04.249]                       }
[18:02:04.249]                       else if (inherits(cond, "condition")) {
[18:02:04.249]                         if (!is.null(pattern)) {
[18:02:04.249]                           computeRestarts <- base::computeRestarts
[18:02:04.249]                           grepl <- base::grepl
[18:02:04.249]                           restarts <- computeRestarts(cond)
[18:02:04.249]                           for (restart in restarts) {
[18:02:04.249]                             name <- restart$name
[18:02:04.249]                             if (is.null(name)) 
[18:02:04.249]                               next
[18:02:04.249]                             if (!grepl(pattern, name)) 
[18:02:04.249]                               next
[18:02:04.249]                             invokeRestart(restart)
[18:02:04.249]                             muffled <- TRUE
[18:02:04.249]                             break
[18:02:04.249]                           }
[18:02:04.249]                         }
[18:02:04.249]                       }
[18:02:04.249]                       invisible(muffled)
[18:02:04.249]                     }
[18:02:04.249]                     muffleCondition(cond, pattern = "^muffle")
[18:02:04.249]                   }
[18:02:04.249]                 }
[18:02:04.249]                 else {
[18:02:04.249]                   if (TRUE) {
[18:02:04.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:04.249]                     {
[18:02:04.249]                       inherits <- base::inherits
[18:02:04.249]                       invokeRestart <- base::invokeRestart
[18:02:04.249]                       is.null <- base::is.null
[18:02:04.249]                       muffled <- FALSE
[18:02:04.249]                       if (inherits(cond, "message")) {
[18:02:04.249]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:04.249]                         if (muffled) 
[18:02:04.249]                           invokeRestart("muffleMessage")
[18:02:04.249]                       }
[18:02:04.249]                       else if (inherits(cond, "warning")) {
[18:02:04.249]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:04.249]                         if (muffled) 
[18:02:04.249]                           invokeRestart("muffleWarning")
[18:02:04.249]                       }
[18:02:04.249]                       else if (inherits(cond, "condition")) {
[18:02:04.249]                         if (!is.null(pattern)) {
[18:02:04.249]                           computeRestarts <- base::computeRestarts
[18:02:04.249]                           grepl <- base::grepl
[18:02:04.249]                           restarts <- computeRestarts(cond)
[18:02:04.249]                           for (restart in restarts) {
[18:02:04.249]                             name <- restart$name
[18:02:04.249]                             if (is.null(name)) 
[18:02:04.249]                               next
[18:02:04.249]                             if (!grepl(pattern, name)) 
[18:02:04.249]                               next
[18:02:04.249]                             invokeRestart(restart)
[18:02:04.249]                             muffled <- TRUE
[18:02:04.249]                             break
[18:02:04.249]                           }
[18:02:04.249]                         }
[18:02:04.249]                       }
[18:02:04.249]                       invisible(muffled)
[18:02:04.249]                     }
[18:02:04.249]                     muffleCondition(cond, pattern = "^muffle")
[18:02:04.249]                   }
[18:02:04.249]                 }
[18:02:04.249]             }
[18:02:04.249]         }))
[18:02:04.249]     }, error = function(ex) {
[18:02:04.249]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:04.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:04.249]                 ...future.rng), started = ...future.startTime, 
[18:02:04.249]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:04.249]             version = "1.8"), class = "FutureResult")
[18:02:04.249]     }, finally = {
[18:02:04.249]         if (!identical(...future.workdir, getwd())) 
[18:02:04.249]             setwd(...future.workdir)
[18:02:04.249]         {
[18:02:04.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:04.249]                 ...future.oldOptions$nwarnings <- NULL
[18:02:04.249]             }
[18:02:04.249]             base::options(...future.oldOptions)
[18:02:04.249]             if (.Platform$OS.type == "windows") {
[18:02:04.249]                 old_names <- names(...future.oldEnvVars)
[18:02:04.249]                 envs <- base::Sys.getenv()
[18:02:04.249]                 names <- names(envs)
[18:02:04.249]                 common <- intersect(names, old_names)
[18:02:04.249]                 added <- setdiff(names, old_names)
[18:02:04.249]                 removed <- setdiff(old_names, names)
[18:02:04.249]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:04.249]                   envs[common]]
[18:02:04.249]                 NAMES <- toupper(changed)
[18:02:04.249]                 args <- list()
[18:02:04.249]                 for (kk in seq_along(NAMES)) {
[18:02:04.249]                   name <- changed[[kk]]
[18:02:04.249]                   NAME <- NAMES[[kk]]
[18:02:04.249]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:04.249]                     next
[18:02:04.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:04.249]                 }
[18:02:04.249]                 NAMES <- toupper(added)
[18:02:04.249]                 for (kk in seq_along(NAMES)) {
[18:02:04.249]                   name <- added[[kk]]
[18:02:04.249]                   NAME <- NAMES[[kk]]
[18:02:04.249]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:04.249]                     next
[18:02:04.249]                   args[[name]] <- ""
[18:02:04.249]                 }
[18:02:04.249]                 NAMES <- toupper(removed)
[18:02:04.249]                 for (kk in seq_along(NAMES)) {
[18:02:04.249]                   name <- removed[[kk]]
[18:02:04.249]                   NAME <- NAMES[[kk]]
[18:02:04.249]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:04.249]                     next
[18:02:04.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:04.249]                 }
[18:02:04.249]                 if (length(args) > 0) 
[18:02:04.249]                   base::do.call(base::Sys.setenv, args = args)
[18:02:04.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:04.249]             }
[18:02:04.249]             else {
[18:02:04.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:04.249]             }
[18:02:04.249]             {
[18:02:04.249]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:04.249]                   0L) {
[18:02:04.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:04.249]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:04.249]                   base::options(opts)
[18:02:04.249]                 }
[18:02:04.249]                 {
[18:02:04.249]                   {
[18:02:04.249]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:04.249]                     NULL
[18:02:04.249]                   }
[18:02:04.249]                   options(future.plan = NULL)
[18:02:04.249]                   if (is.na(NA_character_)) 
[18:02:04.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:04.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:04.249]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:04.249]                     .init = FALSE)
[18:02:04.249]                 }
[18:02:04.249]             }
[18:02:04.249]         }
[18:02:04.249]     })
[18:02:04.249]     if (TRUE) {
[18:02:04.249]         base::sink(type = "output", split = FALSE)
[18:02:04.249]         if (TRUE) {
[18:02:04.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:04.249]         }
[18:02:04.249]         else {
[18:02:04.249]             ...future.result["stdout"] <- base::list(NULL)
[18:02:04.249]         }
[18:02:04.249]         base::close(...future.stdout)
[18:02:04.249]         ...future.stdout <- NULL
[18:02:04.249]     }
[18:02:04.249]     ...future.result$conditions <- ...future.conditions
[18:02:04.249]     ...future.result$finished <- base::Sys.time()
[18:02:04.249]     ...future.result
[18:02:04.249] }
[18:02:04.256] Exporting 11 global objects (92.12 KiB) to cluster node #2 ...
[18:02:04.256] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[18:02:04.297] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[18:02:04.298] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[18:02:04.299] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[18:02:04.299] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[18:02:04.300] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[18:02:04.301] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[18:02:04.342] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[18:02:04.343] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[18:02:04.384] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[18:02:04.385] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[18:02:04.386] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[18:02:04.387] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[18:02:04.388] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[18:02:04.389] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:04.390] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:04.390] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[18:02:04.391] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[18:02:04.392] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:04.393] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:04.393] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:04.394] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:04.395] Exporting 11 global objects (92.12 KiB) to cluster node #2 ... DONE
[18:02:04.396] MultisessionFuture started
[18:02:04.397] - Launch lazy future ... done
[18:02:04.397] run() for ‘MultisessionFuture’ ... done
[18:02:04.397] Created future:
[18:02:04.398] MultisessionFuture:
[18:02:04.398] Label: ‘future_vapply-2’
[18:02:04.398] Expression:
[18:02:04.398] {
[18:02:04.398]     do.call(function(...) {
[18:02:04.398]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:04.398]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:04.398]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:04.398]             on.exit(options(oopts), add = TRUE)
[18:02:04.398]         }
[18:02:04.398]         {
[18:02:04.398]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:04.398]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:04.398]                 ...future.FUN(...future.X_jj, ...)
[18:02:04.398]             })
[18:02:04.398]         }
[18:02:04.398]     }, args = future.call.arguments)
[18:02:04.398] }
[18:02:04.398] Lazy evaluation: FALSE
[18:02:04.398] Asynchronous evaluation: TRUE
[18:02:04.398] Local evaluation: TRUE
[18:02:04.398] Environment: R_GlobalEnv
[18:02:04.398] Capture standard output: TRUE
[18:02:04.398] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:04.398] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:04.398] Packages: 1 packages (‘future.apply’)
[18:02:04.398] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:04.398] Resolved: FALSE
[18:02:04.398] Value: <not collected>
[18:02:04.398] Conditions captured: <none>
[18:02:04.398] Early signaling: FALSE
[18:02:04.398] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:04.398] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:04.413] Chunk #2 of 2 ... DONE
[18:02:04.414] Launching 2 futures (chunks) ... DONE
[18:02:04.414] Resolving 2 futures (chunks) ...
[18:02:04.414] resolve() on list ...
[18:02:04.415]  recursive: 0
[18:02:04.415]  length: 2
[18:02:04.415] 
[18:02:04.417] receiveMessageFromWorker() for ClusterFuture ...
[18:02:04.417] - Validating connection of MultisessionFuture
[18:02:04.418] - received message: FutureResult
[18:02:04.418] - Received FutureResult
[18:02:04.418] - Erased future from FutureRegistry
[18:02:04.419] result() for ClusterFuture ...
[18:02:04.419] - result already collected: FutureResult
[18:02:04.419] result() for ClusterFuture ... done
[18:02:04.420] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:04.420] Future #1
[18:02:04.420] result() for ClusterFuture ...
[18:02:04.421] - result already collected: FutureResult
[18:02:04.421] result() for ClusterFuture ... done
[18:02:04.421] result() for ClusterFuture ...
[18:02:04.421] - result already collected: FutureResult
[18:02:04.422] result() for ClusterFuture ... done
[18:02:04.422] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:04.422] - nx: 2
[18:02:04.423] - relay: TRUE
[18:02:04.423] - stdout: TRUE
[18:02:04.423] - signal: TRUE
[18:02:04.424] - resignal: FALSE
[18:02:04.424] - force: TRUE
[18:02:04.424] - relayed: [n=2] FALSE, FALSE
[18:02:04.424] - queued futures: [n=2] FALSE, FALSE
[18:02:04.425]  - until=1
[18:02:04.425]  - relaying element #1
[18:02:04.425] result() for ClusterFuture ...
[18:02:04.426] - result already collected: FutureResult
[18:02:04.426] result() for ClusterFuture ... done
[18:02:04.426] result() for ClusterFuture ...
[18:02:04.427] - result already collected: FutureResult
[18:02:04.427] result() for ClusterFuture ... done
[18:02:04.427] result() for ClusterFuture ...
[18:02:04.428] - result already collected: FutureResult
[18:02:04.428] result() for ClusterFuture ... done
[18:02:04.428] result() for ClusterFuture ...
[18:02:04.428] - result already collected: FutureResult
[18:02:04.429] result() for ClusterFuture ... done
[18:02:04.429] - relayed: [n=2] TRUE, FALSE
[18:02:04.429] - queued futures: [n=2] TRUE, FALSE
[18:02:04.430] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:04.430]  length: 1 (resolved future 1)
[18:02:04.441] receiveMessageFromWorker() for ClusterFuture ...
[18:02:04.441] - Validating connection of MultisessionFuture
[18:02:04.442] - received message: FutureResult
[18:02:04.442] - Received FutureResult
[18:02:04.443] - Erased future from FutureRegistry
[18:02:04.443] result() for ClusterFuture ...
[18:02:04.443] - result already collected: FutureResult
[18:02:04.444] result() for ClusterFuture ... done
[18:02:04.444] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:04.444] Future #2
[18:02:04.445] result() for ClusterFuture ...
[18:02:04.445] - result already collected: FutureResult
[18:02:04.445] result() for ClusterFuture ... done
[18:02:04.446] result() for ClusterFuture ...
[18:02:04.446] - result already collected: FutureResult
[18:02:04.446] result() for ClusterFuture ... done
[18:02:04.447] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:04.447] - nx: 2
[18:02:04.447] - relay: TRUE
[18:02:04.447] - stdout: TRUE
[18:02:04.448] - signal: TRUE
[18:02:04.448] - resignal: FALSE
[18:02:04.448] - force: TRUE
[18:02:04.449] - relayed: [n=2] TRUE, FALSE
[18:02:04.449] - queued futures: [n=2] TRUE, FALSE
[18:02:04.449]  - until=2
[18:02:04.450]  - relaying element #2
[18:02:04.450] result() for ClusterFuture ...
[18:02:04.450] - result already collected: FutureResult
[18:02:04.450] result() for ClusterFuture ... done
[18:02:04.451] result() for ClusterFuture ...
[18:02:04.451] - result already collected: FutureResult
[18:02:04.451] result() for ClusterFuture ... done
[18:02:04.452] result() for ClusterFuture ...
[18:02:04.452] - result already collected: FutureResult
[18:02:04.452] result() for ClusterFuture ... done
[18:02:04.453] result() for ClusterFuture ...
[18:02:04.453] - result already collected: FutureResult
[18:02:04.453] result() for ClusterFuture ... done
[18:02:04.454] - relayed: [n=2] TRUE, TRUE
[18:02:04.454] - queued futures: [n=2] TRUE, TRUE
[18:02:04.454] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:04.455]  length: 0 (resolved future 2)
[18:02:04.455] Relaying remaining futures
[18:02:04.455] signalConditionsASAP(NULL, pos=0) ...
[18:02:04.455] - nx: 2
[18:02:04.456] - relay: TRUE
[18:02:04.456] - stdout: TRUE
[18:02:04.456] - signal: TRUE
[18:02:04.457] - resignal: FALSE
[18:02:04.457] - force: TRUE
[18:02:04.457] - relayed: [n=2] TRUE, TRUE
[18:02:04.457] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:04.458] - relayed: [n=2] TRUE, TRUE
[18:02:04.458] - queued futures: [n=2] TRUE, TRUE
[18:02:04.458] signalConditionsASAP(NULL, pos=0) ... done
[18:02:04.459] resolve() on list ... DONE
[18:02:04.459] result() for ClusterFuture ...
[18:02:04.459] - result already collected: FutureResult
[18:02:04.460] result() for ClusterFuture ... done
[18:02:04.460] result() for ClusterFuture ...
[18:02:04.460] - result already collected: FutureResult
[18:02:04.461] result() for ClusterFuture ... done
[18:02:04.461] result() for ClusterFuture ...
[18:02:04.461] - result already collected: FutureResult
[18:02:04.461] result() for ClusterFuture ... done
[18:02:04.462] result() for ClusterFuture ...
[18:02:04.462] - result already collected: FutureResult
[18:02:04.462] result() for ClusterFuture ... done
[18:02:04.463]  - Number of value chunks collected: 2
[18:02:04.463] Resolving 2 futures (chunks) ... DONE
[18:02:04.463] Reducing values from 2 chunks ...
[18:02:04.464]  - Number of values collected after concatenation: 10
[18:02:04.464]  - Number of values expected: 10
[18:02:04.464] Reducing values from 2 chunks ... DONE
[18:02:04.464] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[18:02:04.466] future_lapply() ...
[18:02:04.478] Number of chunks: 2
[18:02:04.478] getGlobalsAndPackagesXApply() ...
[18:02:04.478]  - future.globals: TRUE
[18:02:04.479] getGlobalsAndPackages() ...
[18:02:04.479] Searching for globals...
[18:02:04.487] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[18:02:04.487] Searching for globals ... DONE
[18:02:04.488] Resolving globals: FALSE
[18:02:04.490] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[18:02:04.490] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:04.491] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:04.491] - packages: [1] ‘future.apply’
[18:02:04.491] getGlobalsAndPackages() ... DONE
[18:02:04.491]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:04.492]  - needed namespaces: [n=1] ‘future.apply’
[18:02:04.492] Finding globals ... DONE
[18:02:04.492]  - use_args: TRUE
[18:02:04.492]  - Getting '...' globals ...
[18:02:04.493] resolve() on list ...
[18:02:04.493]  recursive: 0
[18:02:04.493]  length: 1
[18:02:04.494]  elements: ‘...’
[18:02:04.494]  length: 0 (resolved future 1)
[18:02:04.494] resolve() on list ... DONE
[18:02:04.494]    - '...' content: [n=0] 
[18:02:04.494] List of 1
[18:02:04.494]  $ ...: list()
[18:02:04.494]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:04.494]  - attr(*, "where")=List of 1
[18:02:04.494]   ..$ ...:<environment: 0x6183c25fa718> 
[18:02:04.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:04.494]  - attr(*, "resolved")= logi TRUE
[18:02:04.494]  - attr(*, "total_size")= num NA
[18:02:04.500]  - Getting '...' globals ... DONE
[18:02:04.500] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:04.500] List of 8
[18:02:04.500]  $ ...future.FUN:function (x, ...)  
[18:02:04.500]  $ x_FUN        :function (x)  
[18:02:04.500]  $ times        : int 2
[18:02:04.500]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:04.500]  $ stop_if_not  :function (...)  
[18:02:04.500]  $ dim          : NULL
[18:02:04.500]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:02:04.500]  $ ...          : list()
[18:02:04.500]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:04.500]  - attr(*, "where")=List of 8
[18:02:04.500]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:04.500]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:04.500]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:04.500]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:04.500]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:04.500]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:04.500]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:04.500]   ..$ ...          :<environment: 0x6183c25fa718> 
[18:02:04.500]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:04.500]  - attr(*, "resolved")= logi FALSE
[18:02:04.500]  - attr(*, "total_size")= num 96456
[18:02:04.512] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:04.512] getGlobalsAndPackagesXApply() ... DONE
[18:02:04.513] Number of futures (= number of chunks): 2
[18:02:04.513] Launching 2 futures (chunks) ...
[18:02:04.513] Chunk #1 of 2 ...
[18:02:04.513]  - Finding globals in 'X' for chunk #1 ...
[18:02:04.514] getGlobalsAndPackages() ...
[18:02:04.514] Searching for globals...
[18:02:04.514] 
[18:02:04.515] Searching for globals ... DONE
[18:02:04.515] - globals: [0] <none>
[18:02:04.515] getGlobalsAndPackages() ... DONE
[18:02:04.515]    + additional globals found: [n=0] 
[18:02:04.515]    + additional namespaces needed: [n=0] 
[18:02:04.516]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:04.516]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:04.516]  - seeds: <none>
[18:02:04.516]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:04.516] getGlobalsAndPackages() ...
[18:02:04.517] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:04.517] Resolving globals: FALSE
[18:02:04.517] Tweak future expression to call with '...' arguments ...
[18:02:04.517] {
[18:02:04.517]     do.call(function(...) {
[18:02:04.517]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:04.517]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:04.517]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:04.517]             on.exit(options(oopts), add = TRUE)
[18:02:04.517]         }
[18:02:04.517]         {
[18:02:04.517]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:04.517]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:04.517]                 ...future.FUN(...future.X_jj, ...)
[18:02:04.517]             })
[18:02:04.517]         }
[18:02:04.517]     }, args = future.call.arguments)
[18:02:04.517] }
[18:02:04.518] Tweak future expression to call with '...' arguments ... DONE
[18:02:04.519] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:04.520] - packages: [1] ‘future.apply’
[18:02:04.520] getGlobalsAndPackages() ... DONE
[18:02:04.520] run() for ‘Future’ ...
[18:02:04.521] - state: ‘created’
[18:02:04.521] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:04.546] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:04.546] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:04.547]   - Field: ‘node’
[18:02:04.547]   - Field: ‘label’
[18:02:04.547]   - Field: ‘local’
[18:02:04.547]   - Field: ‘owner’
[18:02:04.548]   - Field: ‘envir’
[18:02:04.548]   - Field: ‘workers’
[18:02:04.548]   - Field: ‘packages’
[18:02:04.548]   - Field: ‘gc’
[18:02:04.548]   - Field: ‘conditions’
[18:02:04.549]   - Field: ‘persistent’
[18:02:04.549]   - Field: ‘expr’
[18:02:04.549]   - Field: ‘uuid’
[18:02:04.549]   - Field: ‘seed’
[18:02:04.549]   - Field: ‘version’
[18:02:04.550]   - Field: ‘result’
[18:02:04.550]   - Field: ‘asynchronous’
[18:02:04.550]   - Field: ‘calls’
[18:02:04.550]   - Field: ‘globals’
[18:02:04.550]   - Field: ‘stdout’
[18:02:04.551]   - Field: ‘earlySignal’
[18:02:04.551]   - Field: ‘lazy’
[18:02:04.551]   - Field: ‘state’
[18:02:04.551] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:04.551] - Launch lazy future ...
[18:02:04.552] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:04.552] Packages needed by future strategies (n = 0): <none>
[18:02:04.553] {
[18:02:04.553]     {
[18:02:04.553]         {
[18:02:04.553]             ...future.startTime <- base::Sys.time()
[18:02:04.553]             {
[18:02:04.553]                 {
[18:02:04.553]                   {
[18:02:04.553]                     {
[18:02:04.553]                       {
[18:02:04.553]                         base::local({
[18:02:04.553]                           has_future <- base::requireNamespace("future", 
[18:02:04.553]                             quietly = TRUE)
[18:02:04.553]                           if (has_future) {
[18:02:04.553]                             ns <- base::getNamespace("future")
[18:02:04.553]                             version <- ns[[".package"]][["version"]]
[18:02:04.553]                             if (is.null(version)) 
[18:02:04.553]                               version <- utils::packageVersion("future")
[18:02:04.553]                           }
[18:02:04.553]                           else {
[18:02:04.553]                             version <- NULL
[18:02:04.553]                           }
[18:02:04.553]                           if (!has_future || version < "1.8.0") {
[18:02:04.553]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:04.553]                               "", base::R.version$version.string), 
[18:02:04.553]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:04.553]                                 base::R.version$platform, 8 * 
[18:02:04.553]                                   base::.Machine$sizeof.pointer), 
[18:02:04.553]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:04.553]                                 "release", "version")], collapse = " "), 
[18:02:04.553]                               hostname = base::Sys.info()[["nodename"]])
[18:02:04.553]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:04.553]                               info)
[18:02:04.553]                             info <- base::paste(info, collapse = "; ")
[18:02:04.553]                             if (!has_future) {
[18:02:04.553]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:04.553]                                 info)
[18:02:04.553]                             }
[18:02:04.553]                             else {
[18:02:04.553]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:04.553]                                 info, version)
[18:02:04.553]                             }
[18:02:04.553]                             base::stop(msg)
[18:02:04.553]                           }
[18:02:04.553]                         })
[18:02:04.553]                       }
[18:02:04.553]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:04.553]                       base::options(mc.cores = 1L)
[18:02:04.553]                     }
[18:02:04.553]                     base::local({
[18:02:04.553]                       for (pkg in "future.apply") {
[18:02:04.553]                         base::loadNamespace(pkg)
[18:02:04.553]                         base::library(pkg, character.only = TRUE)
[18:02:04.553]                       }
[18:02:04.553]                     })
[18:02:04.553]                   }
[18:02:04.553]                   ...future.strategy.old <- future::plan("list")
[18:02:04.553]                   options(future.plan = NULL)
[18:02:04.553]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:04.553]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:04.553]                 }
[18:02:04.553]                 ...future.workdir <- getwd()
[18:02:04.553]             }
[18:02:04.553]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:04.553]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:04.553]         }
[18:02:04.553]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:04.553]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:04.553]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:04.553]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:04.553]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:04.553]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:04.553]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:04.553]             base::names(...future.oldOptions))
[18:02:04.553]     }
[18:02:04.553]     if (FALSE) {
[18:02:04.553]     }
[18:02:04.553]     else {
[18:02:04.553]         if (TRUE) {
[18:02:04.553]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:04.553]                 open = "w")
[18:02:04.553]         }
[18:02:04.553]         else {
[18:02:04.553]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:04.553]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:04.553]         }
[18:02:04.553]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:04.553]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:04.553]             base::sink(type = "output", split = FALSE)
[18:02:04.553]             base::close(...future.stdout)
[18:02:04.553]         }, add = TRUE)
[18:02:04.553]     }
[18:02:04.553]     ...future.frame <- base::sys.nframe()
[18:02:04.553]     ...future.conditions <- base::list()
[18:02:04.553]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:04.553]     if (FALSE) {
[18:02:04.553]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:04.553]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:04.553]     }
[18:02:04.553]     ...future.result <- base::tryCatch({
[18:02:04.553]         base::withCallingHandlers({
[18:02:04.553]             ...future.value <- base::withVisible(base::local({
[18:02:04.553]                 ...future.makeSendCondition <- base::local({
[18:02:04.553]                   sendCondition <- NULL
[18:02:04.553]                   function(frame = 1L) {
[18:02:04.553]                     if (is.function(sendCondition)) 
[18:02:04.553]                       return(sendCondition)
[18:02:04.553]                     ns <- getNamespace("parallel")
[18:02:04.553]                     if (exists("sendData", mode = "function", 
[18:02:04.553]                       envir = ns)) {
[18:02:04.553]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:04.553]                         envir = ns)
[18:02:04.553]                       envir <- sys.frame(frame)
[18:02:04.553]                       master <- NULL
[18:02:04.553]                       while (!identical(envir, .GlobalEnv) && 
[18:02:04.553]                         !identical(envir, emptyenv())) {
[18:02:04.553]                         if (exists("master", mode = "list", envir = envir, 
[18:02:04.553]                           inherits = FALSE)) {
[18:02:04.553]                           master <- get("master", mode = "list", 
[18:02:04.553]                             envir = envir, inherits = FALSE)
[18:02:04.553]                           if (inherits(master, c("SOCKnode", 
[18:02:04.553]                             "SOCK0node"))) {
[18:02:04.553]                             sendCondition <<- function(cond) {
[18:02:04.553]                               data <- list(type = "VALUE", value = cond, 
[18:02:04.553]                                 success = TRUE)
[18:02:04.553]                               parallel_sendData(master, data)
[18:02:04.553]                             }
[18:02:04.553]                             return(sendCondition)
[18:02:04.553]                           }
[18:02:04.553]                         }
[18:02:04.553]                         frame <- frame + 1L
[18:02:04.553]                         envir <- sys.frame(frame)
[18:02:04.553]                       }
[18:02:04.553]                     }
[18:02:04.553]                     sendCondition <<- function(cond) NULL
[18:02:04.553]                   }
[18:02:04.553]                 })
[18:02:04.553]                 withCallingHandlers({
[18:02:04.553]                   {
[18:02:04.553]                     do.call(function(...) {
[18:02:04.553]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:04.553]                       if (!identical(...future.globals.maxSize.org, 
[18:02:04.553]                         ...future.globals.maxSize)) {
[18:02:04.553]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:04.553]                         on.exit(options(oopts), add = TRUE)
[18:02:04.553]                       }
[18:02:04.553]                       {
[18:02:04.553]                         lapply(seq_along(...future.elements_ii), 
[18:02:04.553]                           FUN = function(jj) {
[18:02:04.553]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:04.553]                             ...future.FUN(...future.X_jj, ...)
[18:02:04.553]                           })
[18:02:04.553]                       }
[18:02:04.553]                     }, args = future.call.arguments)
[18:02:04.553]                   }
[18:02:04.553]                 }, immediateCondition = function(cond) {
[18:02:04.553]                   sendCondition <- ...future.makeSendCondition()
[18:02:04.553]                   sendCondition(cond)
[18:02:04.553]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:04.553]                   {
[18:02:04.553]                     inherits <- base::inherits
[18:02:04.553]                     invokeRestart <- base::invokeRestart
[18:02:04.553]                     is.null <- base::is.null
[18:02:04.553]                     muffled <- FALSE
[18:02:04.553]                     if (inherits(cond, "message")) {
[18:02:04.553]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:04.553]                       if (muffled) 
[18:02:04.553]                         invokeRestart("muffleMessage")
[18:02:04.553]                     }
[18:02:04.553]                     else if (inherits(cond, "warning")) {
[18:02:04.553]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:04.553]                       if (muffled) 
[18:02:04.553]                         invokeRestart("muffleWarning")
[18:02:04.553]                     }
[18:02:04.553]                     else if (inherits(cond, "condition")) {
[18:02:04.553]                       if (!is.null(pattern)) {
[18:02:04.553]                         computeRestarts <- base::computeRestarts
[18:02:04.553]                         grepl <- base::grepl
[18:02:04.553]                         restarts <- computeRestarts(cond)
[18:02:04.553]                         for (restart in restarts) {
[18:02:04.553]                           name <- restart$name
[18:02:04.553]                           if (is.null(name)) 
[18:02:04.553]                             next
[18:02:04.553]                           if (!grepl(pattern, name)) 
[18:02:04.553]                             next
[18:02:04.553]                           invokeRestart(restart)
[18:02:04.553]                           muffled <- TRUE
[18:02:04.553]                           break
[18:02:04.553]                         }
[18:02:04.553]                       }
[18:02:04.553]                     }
[18:02:04.553]                     invisible(muffled)
[18:02:04.553]                   }
[18:02:04.553]                   muffleCondition(cond)
[18:02:04.553]                 })
[18:02:04.553]             }))
[18:02:04.553]             future::FutureResult(value = ...future.value$value, 
[18:02:04.553]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:04.553]                   ...future.rng), globalenv = if (FALSE) 
[18:02:04.553]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:04.553]                     ...future.globalenv.names))
[18:02:04.553]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:04.553]         }, condition = base::local({
[18:02:04.553]             c <- base::c
[18:02:04.553]             inherits <- base::inherits
[18:02:04.553]             invokeRestart <- base::invokeRestart
[18:02:04.553]             length <- base::length
[18:02:04.553]             list <- base::list
[18:02:04.553]             seq.int <- base::seq.int
[18:02:04.553]             signalCondition <- base::signalCondition
[18:02:04.553]             sys.calls <- base::sys.calls
[18:02:04.553]             `[[` <- base::`[[`
[18:02:04.553]             `+` <- base::`+`
[18:02:04.553]             `<<-` <- base::`<<-`
[18:02:04.553]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:04.553]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:04.553]                   3L)]
[18:02:04.553]             }
[18:02:04.553]             function(cond) {
[18:02:04.553]                 is_error <- inherits(cond, "error")
[18:02:04.553]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:04.553]                   NULL)
[18:02:04.553]                 if (is_error) {
[18:02:04.553]                   sessionInformation <- function() {
[18:02:04.553]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:04.553]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:04.553]                       search = base::search(), system = base::Sys.info())
[18:02:04.553]                   }
[18:02:04.553]                   ...future.conditions[[length(...future.conditions) + 
[18:02:04.553]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:04.553]                     cond$call), session = sessionInformation(), 
[18:02:04.553]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:04.553]                   signalCondition(cond)
[18:02:04.553]                 }
[18:02:04.553]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:04.553]                 "immediateCondition"))) {
[18:02:04.553]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:04.553]                   ...future.conditions[[length(...future.conditions) + 
[18:02:04.553]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:04.553]                   if (TRUE && !signal) {
[18:02:04.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:04.553]                     {
[18:02:04.553]                       inherits <- base::inherits
[18:02:04.553]                       invokeRestart <- base::invokeRestart
[18:02:04.553]                       is.null <- base::is.null
[18:02:04.553]                       muffled <- FALSE
[18:02:04.553]                       if (inherits(cond, "message")) {
[18:02:04.553]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:04.553]                         if (muffled) 
[18:02:04.553]                           invokeRestart("muffleMessage")
[18:02:04.553]                       }
[18:02:04.553]                       else if (inherits(cond, "warning")) {
[18:02:04.553]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:04.553]                         if (muffled) 
[18:02:04.553]                           invokeRestart("muffleWarning")
[18:02:04.553]                       }
[18:02:04.553]                       else if (inherits(cond, "condition")) {
[18:02:04.553]                         if (!is.null(pattern)) {
[18:02:04.553]                           computeRestarts <- base::computeRestarts
[18:02:04.553]                           grepl <- base::grepl
[18:02:04.553]                           restarts <- computeRestarts(cond)
[18:02:04.553]                           for (restart in restarts) {
[18:02:04.553]                             name <- restart$name
[18:02:04.553]                             if (is.null(name)) 
[18:02:04.553]                               next
[18:02:04.553]                             if (!grepl(pattern, name)) 
[18:02:04.553]                               next
[18:02:04.553]                             invokeRestart(restart)
[18:02:04.553]                             muffled <- TRUE
[18:02:04.553]                             break
[18:02:04.553]                           }
[18:02:04.553]                         }
[18:02:04.553]                       }
[18:02:04.553]                       invisible(muffled)
[18:02:04.553]                     }
[18:02:04.553]                     muffleCondition(cond, pattern = "^muffle")
[18:02:04.553]                   }
[18:02:04.553]                 }
[18:02:04.553]                 else {
[18:02:04.553]                   if (TRUE) {
[18:02:04.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:04.553]                     {
[18:02:04.553]                       inherits <- base::inherits
[18:02:04.553]                       invokeRestart <- base::invokeRestart
[18:02:04.553]                       is.null <- base::is.null
[18:02:04.553]                       muffled <- FALSE
[18:02:04.553]                       if (inherits(cond, "message")) {
[18:02:04.553]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:04.553]                         if (muffled) 
[18:02:04.553]                           invokeRestart("muffleMessage")
[18:02:04.553]                       }
[18:02:04.553]                       else if (inherits(cond, "warning")) {
[18:02:04.553]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:04.553]                         if (muffled) 
[18:02:04.553]                           invokeRestart("muffleWarning")
[18:02:04.553]                       }
[18:02:04.553]                       else if (inherits(cond, "condition")) {
[18:02:04.553]                         if (!is.null(pattern)) {
[18:02:04.553]                           computeRestarts <- base::computeRestarts
[18:02:04.553]                           grepl <- base::grepl
[18:02:04.553]                           restarts <- computeRestarts(cond)
[18:02:04.553]                           for (restart in restarts) {
[18:02:04.553]                             name <- restart$name
[18:02:04.553]                             if (is.null(name)) 
[18:02:04.553]                               next
[18:02:04.553]                             if (!grepl(pattern, name)) 
[18:02:04.553]                               next
[18:02:04.553]                             invokeRestart(restart)
[18:02:04.553]                             muffled <- TRUE
[18:02:04.553]                             break
[18:02:04.553]                           }
[18:02:04.553]                         }
[18:02:04.553]                       }
[18:02:04.553]                       invisible(muffled)
[18:02:04.553]                     }
[18:02:04.553]                     muffleCondition(cond, pattern = "^muffle")
[18:02:04.553]                   }
[18:02:04.553]                 }
[18:02:04.553]             }
[18:02:04.553]         }))
[18:02:04.553]     }, error = function(ex) {
[18:02:04.553]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:04.553]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:04.553]                 ...future.rng), started = ...future.startTime, 
[18:02:04.553]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:04.553]             version = "1.8"), class = "FutureResult")
[18:02:04.553]     }, finally = {
[18:02:04.553]         if (!identical(...future.workdir, getwd())) 
[18:02:04.553]             setwd(...future.workdir)
[18:02:04.553]         {
[18:02:04.553]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:04.553]                 ...future.oldOptions$nwarnings <- NULL
[18:02:04.553]             }
[18:02:04.553]             base::options(...future.oldOptions)
[18:02:04.553]             if (.Platform$OS.type == "windows") {
[18:02:04.553]                 old_names <- names(...future.oldEnvVars)
[18:02:04.553]                 envs <- base::Sys.getenv()
[18:02:04.553]                 names <- names(envs)
[18:02:04.553]                 common <- intersect(names, old_names)
[18:02:04.553]                 added <- setdiff(names, old_names)
[18:02:04.553]                 removed <- setdiff(old_names, names)
[18:02:04.553]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:04.553]                   envs[common]]
[18:02:04.553]                 NAMES <- toupper(changed)
[18:02:04.553]                 args <- list()
[18:02:04.553]                 for (kk in seq_along(NAMES)) {
[18:02:04.553]                   name <- changed[[kk]]
[18:02:04.553]                   NAME <- NAMES[[kk]]
[18:02:04.553]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:04.553]                     next
[18:02:04.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:04.553]                 }
[18:02:04.553]                 NAMES <- toupper(added)
[18:02:04.553]                 for (kk in seq_along(NAMES)) {
[18:02:04.553]                   name <- added[[kk]]
[18:02:04.553]                   NAME <- NAMES[[kk]]
[18:02:04.553]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:04.553]                     next
[18:02:04.553]                   args[[name]] <- ""
[18:02:04.553]                 }
[18:02:04.553]                 NAMES <- toupper(removed)
[18:02:04.553]                 for (kk in seq_along(NAMES)) {
[18:02:04.553]                   name <- removed[[kk]]
[18:02:04.553]                   NAME <- NAMES[[kk]]
[18:02:04.553]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:04.553]                     next
[18:02:04.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:04.553]                 }
[18:02:04.553]                 if (length(args) > 0) 
[18:02:04.553]                   base::do.call(base::Sys.setenv, args = args)
[18:02:04.553]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:04.553]             }
[18:02:04.553]             else {
[18:02:04.553]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:04.553]             }
[18:02:04.553]             {
[18:02:04.553]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:04.553]                   0L) {
[18:02:04.553]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:04.553]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:04.553]                   base::options(opts)
[18:02:04.553]                 }
[18:02:04.553]                 {
[18:02:04.553]                   {
[18:02:04.553]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:04.553]                     NULL
[18:02:04.553]                   }
[18:02:04.553]                   options(future.plan = NULL)
[18:02:04.553]                   if (is.na(NA_character_)) 
[18:02:04.553]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:04.553]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:04.553]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:04.553]                     .init = FALSE)
[18:02:04.553]                 }
[18:02:04.553]             }
[18:02:04.553]         }
[18:02:04.553]     })
[18:02:04.553]     if (TRUE) {
[18:02:04.553]         base::sink(type = "output", split = FALSE)
[18:02:04.553]         if (TRUE) {
[18:02:04.553]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:04.553]         }
[18:02:04.553]         else {
[18:02:04.553]             ...future.result["stdout"] <- base::list(NULL)
[18:02:04.553]         }
[18:02:04.553]         base::close(...future.stdout)
[18:02:04.553]         ...future.stdout <- NULL
[18:02:04.553]     }
[18:02:04.553]     ...future.result$conditions <- ...future.conditions
[18:02:04.553]     ...future.result$finished <- base::Sys.time()
[18:02:04.553]     ...future.result
[18:02:04.553] }
[18:02:04.559] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[18:02:04.559] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[18:02:04.600] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[18:02:04.601] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[18:02:04.602] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[18:02:04.602] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[18:02:04.603] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[18:02:04.603] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[18:02:04.645] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[18:02:04.646] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[18:02:04.687] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[18:02:04.688] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[18:02:04.689] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[18:02:04.689] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[18:02:04.691] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[18:02:04.691] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:04.693] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:04.693] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[18:02:04.694] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[18:02:04.695] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:04.696] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:04.696] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:04.697] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:04.698] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[18:02:04.699] MultisessionFuture started
[18:02:04.700] - Launch lazy future ... done
[18:02:04.700] run() for ‘MultisessionFuture’ ... done
[18:02:04.700] Created future:
[18:02:04.701] MultisessionFuture:
[18:02:04.701] Label: ‘future_vapply-1’
[18:02:04.701] Expression:
[18:02:04.701] {
[18:02:04.701]     do.call(function(...) {
[18:02:04.701]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:04.701]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:04.701]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:04.701]             on.exit(options(oopts), add = TRUE)
[18:02:04.701]         }
[18:02:04.701]         {
[18:02:04.701]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:04.701]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:04.701]                 ...future.FUN(...future.X_jj, ...)
[18:02:04.701]             })
[18:02:04.701]         }
[18:02:04.701]     }, args = future.call.arguments)
[18:02:04.701] }
[18:02:04.701] Lazy evaluation: FALSE
[18:02:04.701] Asynchronous evaluation: TRUE
[18:02:04.701] Local evaluation: TRUE
[18:02:04.701] Environment: R_GlobalEnv
[18:02:04.701] Capture standard output: TRUE
[18:02:04.701] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:04.701] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:04.701] Packages: 1 packages (‘future.apply’)
[18:02:04.701] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:04.701] Resolved: FALSE
[18:02:04.701] Value: <not collected>
[18:02:04.701] Conditions captured: <none>
[18:02:04.701] Early signaling: FALSE
[18:02:04.701] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:04.701] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:04.716] Chunk #1 of 2 ... DONE
[18:02:04.716] Chunk #2 of 2 ...
[18:02:04.716]  - Finding globals in 'X' for chunk #2 ...
[18:02:04.717] getGlobalsAndPackages() ...
[18:02:04.717] Searching for globals...
[18:02:04.718] 
[18:02:04.718] Searching for globals ... DONE
[18:02:04.719] - globals: [0] <none>
[18:02:04.719] getGlobalsAndPackages() ... DONE
[18:02:04.719]    + additional globals found: [n=0] 
[18:02:04.720]    + additional namespaces needed: [n=0] 
[18:02:04.720]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:04.720]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:04.721]  - seeds: <none>
[18:02:04.721]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:04.721] getGlobalsAndPackages() ...
[18:02:04.722] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:04.722] Resolving globals: FALSE
[18:02:04.722] Tweak future expression to call with '...' arguments ...
[18:02:04.723] {
[18:02:04.723]     do.call(function(...) {
[18:02:04.723]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:04.723]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:04.723]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:04.723]             on.exit(options(oopts), add = TRUE)
[18:02:04.723]         }
[18:02:04.723]         {
[18:02:04.723]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:04.723]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:04.723]                 ...future.FUN(...future.X_jj, ...)
[18:02:04.723]             })
[18:02:04.723]         }
[18:02:04.723]     }, args = future.call.arguments)
[18:02:04.723] }
[18:02:04.724] Tweak future expression to call with '...' arguments ... DONE
[18:02:04.725] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:04.726] - packages: [1] ‘future.apply’
[18:02:04.726] getGlobalsAndPackages() ... DONE
[18:02:04.727] run() for ‘Future’ ...
[18:02:04.727] - state: ‘created’
[18:02:04.728] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:04.767] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:04.767] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:04.768]   - Field: ‘node’
[18:02:04.768]   - Field: ‘label’
[18:02:04.768]   - Field: ‘local’
[18:02:04.768]   - Field: ‘owner’
[18:02:04.769]   - Field: ‘envir’
[18:02:04.769]   - Field: ‘workers’
[18:02:04.769]   - Field: ‘packages’
[18:02:04.769]   - Field: ‘gc’
[18:02:04.770]   - Field: ‘conditions’
[18:02:04.770]   - Field: ‘persistent’
[18:02:04.770]   - Field: ‘expr’
[18:02:04.771]   - Field: ‘uuid’
[18:02:04.771]   - Field: ‘seed’
[18:02:04.771]   - Field: ‘version’
[18:02:04.771]   - Field: ‘result’
[18:02:04.772]   - Field: ‘asynchronous’
[18:02:04.772]   - Field: ‘calls’
[18:02:04.772]   - Field: ‘globals’
[18:02:04.772]   - Field: ‘stdout’
[18:02:04.773]   - Field: ‘earlySignal’
[18:02:04.773]   - Field: ‘lazy’
[18:02:04.773]   - Field: ‘state’
[18:02:04.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:04.774] - Launch lazy future ...
[18:02:04.774] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:04.775] Packages needed by future strategies (n = 0): <none>
[18:02:04.776] {
[18:02:04.776]     {
[18:02:04.776]         {
[18:02:04.776]             ...future.startTime <- base::Sys.time()
[18:02:04.776]             {
[18:02:04.776]                 {
[18:02:04.776]                   {
[18:02:04.776]                     {
[18:02:04.776]                       {
[18:02:04.776]                         base::local({
[18:02:04.776]                           has_future <- base::requireNamespace("future", 
[18:02:04.776]                             quietly = TRUE)
[18:02:04.776]                           if (has_future) {
[18:02:04.776]                             ns <- base::getNamespace("future")
[18:02:04.776]                             version <- ns[[".package"]][["version"]]
[18:02:04.776]                             if (is.null(version)) 
[18:02:04.776]                               version <- utils::packageVersion("future")
[18:02:04.776]                           }
[18:02:04.776]                           else {
[18:02:04.776]                             version <- NULL
[18:02:04.776]                           }
[18:02:04.776]                           if (!has_future || version < "1.8.0") {
[18:02:04.776]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:04.776]                               "", base::R.version$version.string), 
[18:02:04.776]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:04.776]                                 base::R.version$platform, 8 * 
[18:02:04.776]                                   base::.Machine$sizeof.pointer), 
[18:02:04.776]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:04.776]                                 "release", "version")], collapse = " "), 
[18:02:04.776]                               hostname = base::Sys.info()[["nodename"]])
[18:02:04.776]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:04.776]                               info)
[18:02:04.776]                             info <- base::paste(info, collapse = "; ")
[18:02:04.776]                             if (!has_future) {
[18:02:04.776]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:04.776]                                 info)
[18:02:04.776]                             }
[18:02:04.776]                             else {
[18:02:04.776]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:04.776]                                 info, version)
[18:02:04.776]                             }
[18:02:04.776]                             base::stop(msg)
[18:02:04.776]                           }
[18:02:04.776]                         })
[18:02:04.776]                       }
[18:02:04.776]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:04.776]                       base::options(mc.cores = 1L)
[18:02:04.776]                     }
[18:02:04.776]                     base::local({
[18:02:04.776]                       for (pkg in "future.apply") {
[18:02:04.776]                         base::loadNamespace(pkg)
[18:02:04.776]                         base::library(pkg, character.only = TRUE)
[18:02:04.776]                       }
[18:02:04.776]                     })
[18:02:04.776]                   }
[18:02:04.776]                   ...future.strategy.old <- future::plan("list")
[18:02:04.776]                   options(future.plan = NULL)
[18:02:04.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:04.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:04.776]                 }
[18:02:04.776]                 ...future.workdir <- getwd()
[18:02:04.776]             }
[18:02:04.776]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:04.776]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:04.776]         }
[18:02:04.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:04.776]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:04.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:04.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:04.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:04.776]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:04.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:04.776]             base::names(...future.oldOptions))
[18:02:04.776]     }
[18:02:04.776]     if (FALSE) {
[18:02:04.776]     }
[18:02:04.776]     else {
[18:02:04.776]         if (TRUE) {
[18:02:04.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:04.776]                 open = "w")
[18:02:04.776]         }
[18:02:04.776]         else {
[18:02:04.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:04.776]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:04.776]         }
[18:02:04.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:04.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:04.776]             base::sink(type = "output", split = FALSE)
[18:02:04.776]             base::close(...future.stdout)
[18:02:04.776]         }, add = TRUE)
[18:02:04.776]     }
[18:02:04.776]     ...future.frame <- base::sys.nframe()
[18:02:04.776]     ...future.conditions <- base::list()
[18:02:04.776]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:04.776]     if (FALSE) {
[18:02:04.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:04.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:04.776]     }
[18:02:04.776]     ...future.result <- base::tryCatch({
[18:02:04.776]         base::withCallingHandlers({
[18:02:04.776]             ...future.value <- base::withVisible(base::local({
[18:02:04.776]                 ...future.makeSendCondition <- base::local({
[18:02:04.776]                   sendCondition <- NULL
[18:02:04.776]                   function(frame = 1L) {
[18:02:04.776]                     if (is.function(sendCondition)) 
[18:02:04.776]                       return(sendCondition)
[18:02:04.776]                     ns <- getNamespace("parallel")
[18:02:04.776]                     if (exists("sendData", mode = "function", 
[18:02:04.776]                       envir = ns)) {
[18:02:04.776]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:04.776]                         envir = ns)
[18:02:04.776]                       envir <- sys.frame(frame)
[18:02:04.776]                       master <- NULL
[18:02:04.776]                       while (!identical(envir, .GlobalEnv) && 
[18:02:04.776]                         !identical(envir, emptyenv())) {
[18:02:04.776]                         if (exists("master", mode = "list", envir = envir, 
[18:02:04.776]                           inherits = FALSE)) {
[18:02:04.776]                           master <- get("master", mode = "list", 
[18:02:04.776]                             envir = envir, inherits = FALSE)
[18:02:04.776]                           if (inherits(master, c("SOCKnode", 
[18:02:04.776]                             "SOCK0node"))) {
[18:02:04.776]                             sendCondition <<- function(cond) {
[18:02:04.776]                               data <- list(type = "VALUE", value = cond, 
[18:02:04.776]                                 success = TRUE)
[18:02:04.776]                               parallel_sendData(master, data)
[18:02:04.776]                             }
[18:02:04.776]                             return(sendCondition)
[18:02:04.776]                           }
[18:02:04.776]                         }
[18:02:04.776]                         frame <- frame + 1L
[18:02:04.776]                         envir <- sys.frame(frame)
[18:02:04.776]                       }
[18:02:04.776]                     }
[18:02:04.776]                     sendCondition <<- function(cond) NULL
[18:02:04.776]                   }
[18:02:04.776]                 })
[18:02:04.776]                 withCallingHandlers({
[18:02:04.776]                   {
[18:02:04.776]                     do.call(function(...) {
[18:02:04.776]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:04.776]                       if (!identical(...future.globals.maxSize.org, 
[18:02:04.776]                         ...future.globals.maxSize)) {
[18:02:04.776]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:04.776]                         on.exit(options(oopts), add = TRUE)
[18:02:04.776]                       }
[18:02:04.776]                       {
[18:02:04.776]                         lapply(seq_along(...future.elements_ii), 
[18:02:04.776]                           FUN = function(jj) {
[18:02:04.776]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:04.776]                             ...future.FUN(...future.X_jj, ...)
[18:02:04.776]                           })
[18:02:04.776]                       }
[18:02:04.776]                     }, args = future.call.arguments)
[18:02:04.776]                   }
[18:02:04.776]                 }, immediateCondition = function(cond) {
[18:02:04.776]                   sendCondition <- ...future.makeSendCondition()
[18:02:04.776]                   sendCondition(cond)
[18:02:04.776]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:04.776]                   {
[18:02:04.776]                     inherits <- base::inherits
[18:02:04.776]                     invokeRestart <- base::invokeRestart
[18:02:04.776]                     is.null <- base::is.null
[18:02:04.776]                     muffled <- FALSE
[18:02:04.776]                     if (inherits(cond, "message")) {
[18:02:04.776]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:04.776]                       if (muffled) 
[18:02:04.776]                         invokeRestart("muffleMessage")
[18:02:04.776]                     }
[18:02:04.776]                     else if (inherits(cond, "warning")) {
[18:02:04.776]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:04.776]                       if (muffled) 
[18:02:04.776]                         invokeRestart("muffleWarning")
[18:02:04.776]                     }
[18:02:04.776]                     else if (inherits(cond, "condition")) {
[18:02:04.776]                       if (!is.null(pattern)) {
[18:02:04.776]                         computeRestarts <- base::computeRestarts
[18:02:04.776]                         grepl <- base::grepl
[18:02:04.776]                         restarts <- computeRestarts(cond)
[18:02:04.776]                         for (restart in restarts) {
[18:02:04.776]                           name <- restart$name
[18:02:04.776]                           if (is.null(name)) 
[18:02:04.776]                             next
[18:02:04.776]                           if (!grepl(pattern, name)) 
[18:02:04.776]                             next
[18:02:04.776]                           invokeRestart(restart)
[18:02:04.776]                           muffled <- TRUE
[18:02:04.776]                           break
[18:02:04.776]                         }
[18:02:04.776]                       }
[18:02:04.776]                     }
[18:02:04.776]                     invisible(muffled)
[18:02:04.776]                   }
[18:02:04.776]                   muffleCondition(cond)
[18:02:04.776]                 })
[18:02:04.776]             }))
[18:02:04.776]             future::FutureResult(value = ...future.value$value, 
[18:02:04.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:04.776]                   ...future.rng), globalenv = if (FALSE) 
[18:02:04.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:04.776]                     ...future.globalenv.names))
[18:02:04.776]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:04.776]         }, condition = base::local({
[18:02:04.776]             c <- base::c
[18:02:04.776]             inherits <- base::inherits
[18:02:04.776]             invokeRestart <- base::invokeRestart
[18:02:04.776]             length <- base::length
[18:02:04.776]             list <- base::list
[18:02:04.776]             seq.int <- base::seq.int
[18:02:04.776]             signalCondition <- base::signalCondition
[18:02:04.776]             sys.calls <- base::sys.calls
[18:02:04.776]             `[[` <- base::`[[`
[18:02:04.776]             `+` <- base::`+`
[18:02:04.776]             `<<-` <- base::`<<-`
[18:02:04.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:04.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:04.776]                   3L)]
[18:02:04.776]             }
[18:02:04.776]             function(cond) {
[18:02:04.776]                 is_error <- inherits(cond, "error")
[18:02:04.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:04.776]                   NULL)
[18:02:04.776]                 if (is_error) {
[18:02:04.776]                   sessionInformation <- function() {
[18:02:04.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:04.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:04.776]                       search = base::search(), system = base::Sys.info())
[18:02:04.776]                   }
[18:02:04.776]                   ...future.conditions[[length(...future.conditions) + 
[18:02:04.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:04.776]                     cond$call), session = sessionInformation(), 
[18:02:04.776]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:04.776]                   signalCondition(cond)
[18:02:04.776]                 }
[18:02:04.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:04.776]                 "immediateCondition"))) {
[18:02:04.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:04.776]                   ...future.conditions[[length(...future.conditions) + 
[18:02:04.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:04.776]                   if (TRUE && !signal) {
[18:02:04.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:04.776]                     {
[18:02:04.776]                       inherits <- base::inherits
[18:02:04.776]                       invokeRestart <- base::invokeRestart
[18:02:04.776]                       is.null <- base::is.null
[18:02:04.776]                       muffled <- FALSE
[18:02:04.776]                       if (inherits(cond, "message")) {
[18:02:04.776]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:04.776]                         if (muffled) 
[18:02:04.776]                           invokeRestart("muffleMessage")
[18:02:04.776]                       }
[18:02:04.776]                       else if (inherits(cond, "warning")) {
[18:02:04.776]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:04.776]                         if (muffled) 
[18:02:04.776]                           invokeRestart("muffleWarning")
[18:02:04.776]                       }
[18:02:04.776]                       else if (inherits(cond, "condition")) {
[18:02:04.776]                         if (!is.null(pattern)) {
[18:02:04.776]                           computeRestarts <- base::computeRestarts
[18:02:04.776]                           grepl <- base::grepl
[18:02:04.776]                           restarts <- computeRestarts(cond)
[18:02:04.776]                           for (restart in restarts) {
[18:02:04.776]                             name <- restart$name
[18:02:04.776]                             if (is.null(name)) 
[18:02:04.776]                               next
[18:02:04.776]                             if (!grepl(pattern, name)) 
[18:02:04.776]                               next
[18:02:04.776]                             invokeRestart(restart)
[18:02:04.776]                             muffled <- TRUE
[18:02:04.776]                             break
[18:02:04.776]                           }
[18:02:04.776]                         }
[18:02:04.776]                       }
[18:02:04.776]                       invisible(muffled)
[18:02:04.776]                     }
[18:02:04.776]                     muffleCondition(cond, pattern = "^muffle")
[18:02:04.776]                   }
[18:02:04.776]                 }
[18:02:04.776]                 else {
[18:02:04.776]                   if (TRUE) {
[18:02:04.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:04.776]                     {
[18:02:04.776]                       inherits <- base::inherits
[18:02:04.776]                       invokeRestart <- base::invokeRestart
[18:02:04.776]                       is.null <- base::is.null
[18:02:04.776]                       muffled <- FALSE
[18:02:04.776]                       if (inherits(cond, "message")) {
[18:02:04.776]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:04.776]                         if (muffled) 
[18:02:04.776]                           invokeRestart("muffleMessage")
[18:02:04.776]                       }
[18:02:04.776]                       else if (inherits(cond, "warning")) {
[18:02:04.776]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:04.776]                         if (muffled) 
[18:02:04.776]                           invokeRestart("muffleWarning")
[18:02:04.776]                       }
[18:02:04.776]                       else if (inherits(cond, "condition")) {
[18:02:04.776]                         if (!is.null(pattern)) {
[18:02:04.776]                           computeRestarts <- base::computeRestarts
[18:02:04.776]                           grepl <- base::grepl
[18:02:04.776]                           restarts <- computeRestarts(cond)
[18:02:04.776]                           for (restart in restarts) {
[18:02:04.776]                             name <- restart$name
[18:02:04.776]                             if (is.null(name)) 
[18:02:04.776]                               next
[18:02:04.776]                             if (!grepl(pattern, name)) 
[18:02:04.776]                               next
[18:02:04.776]                             invokeRestart(restart)
[18:02:04.776]                             muffled <- TRUE
[18:02:04.776]                             break
[18:02:04.776]                           }
[18:02:04.776]                         }
[18:02:04.776]                       }
[18:02:04.776]                       invisible(muffled)
[18:02:04.776]                     }
[18:02:04.776]                     muffleCondition(cond, pattern = "^muffle")
[18:02:04.776]                   }
[18:02:04.776]                 }
[18:02:04.776]             }
[18:02:04.776]         }))
[18:02:04.776]     }, error = function(ex) {
[18:02:04.776]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:04.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:04.776]                 ...future.rng), started = ...future.startTime, 
[18:02:04.776]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:04.776]             version = "1.8"), class = "FutureResult")
[18:02:04.776]     }, finally = {
[18:02:04.776]         if (!identical(...future.workdir, getwd())) 
[18:02:04.776]             setwd(...future.workdir)
[18:02:04.776]         {
[18:02:04.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:04.776]                 ...future.oldOptions$nwarnings <- NULL
[18:02:04.776]             }
[18:02:04.776]             base::options(...future.oldOptions)
[18:02:04.776]             if (.Platform$OS.type == "windows") {
[18:02:04.776]                 old_names <- names(...future.oldEnvVars)
[18:02:04.776]                 envs <- base::Sys.getenv()
[18:02:04.776]                 names <- names(envs)
[18:02:04.776]                 common <- intersect(names, old_names)
[18:02:04.776]                 added <- setdiff(names, old_names)
[18:02:04.776]                 removed <- setdiff(old_names, names)
[18:02:04.776]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:04.776]                   envs[common]]
[18:02:04.776]                 NAMES <- toupper(changed)
[18:02:04.776]                 args <- list()
[18:02:04.776]                 for (kk in seq_along(NAMES)) {
[18:02:04.776]                   name <- changed[[kk]]
[18:02:04.776]                   NAME <- NAMES[[kk]]
[18:02:04.776]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:04.776]                     next
[18:02:04.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:04.776]                 }
[18:02:04.776]                 NAMES <- toupper(added)
[18:02:04.776]                 for (kk in seq_along(NAMES)) {
[18:02:04.776]                   name <- added[[kk]]
[18:02:04.776]                   NAME <- NAMES[[kk]]
[18:02:04.776]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:04.776]                     next
[18:02:04.776]                   args[[name]] <- ""
[18:02:04.776]                 }
[18:02:04.776]                 NAMES <- toupper(removed)
[18:02:04.776]                 for (kk in seq_along(NAMES)) {
[18:02:04.776]                   name <- removed[[kk]]
[18:02:04.776]                   NAME <- NAMES[[kk]]
[18:02:04.776]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:04.776]                     next
[18:02:04.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:04.776]                 }
[18:02:04.776]                 if (length(args) > 0) 
[18:02:04.776]                   base::do.call(base::Sys.setenv, args = args)
[18:02:04.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:04.776]             }
[18:02:04.776]             else {
[18:02:04.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:04.776]             }
[18:02:04.776]             {
[18:02:04.776]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:04.776]                   0L) {
[18:02:04.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:04.776]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:04.776]                   base::options(opts)
[18:02:04.776]                 }
[18:02:04.776]                 {
[18:02:04.776]                   {
[18:02:04.776]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:04.776]                     NULL
[18:02:04.776]                   }
[18:02:04.776]                   options(future.plan = NULL)
[18:02:04.776]                   if (is.na(NA_character_)) 
[18:02:04.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:04.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:04.776]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:04.776]                     .init = FALSE)
[18:02:04.776]                 }
[18:02:04.776]             }
[18:02:04.776]         }
[18:02:04.776]     })
[18:02:04.776]     if (TRUE) {
[18:02:04.776]         base::sink(type = "output", split = FALSE)
[18:02:04.776]         if (TRUE) {
[18:02:04.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:04.776]         }
[18:02:04.776]         else {
[18:02:04.776]             ...future.result["stdout"] <- base::list(NULL)
[18:02:04.776]         }
[18:02:04.776]         base::close(...future.stdout)
[18:02:04.776]         ...future.stdout <- NULL
[18:02:04.776]     }
[18:02:04.776]     ...future.result$conditions <- ...future.conditions
[18:02:04.776]     ...future.result$finished <- base::Sys.time()
[18:02:04.776]     ...future.result
[18:02:04.776] }
[18:02:04.782] Exporting 11 global objects (94.20 KiB) to cluster node #2 ...
[18:02:04.783] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[18:02:04.824] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[18:02:04.825] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ...
[18:02:04.826] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ... DONE
[18:02:04.827] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[18:02:04.828] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[18:02:04.828] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[18:02:04.870] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[18:02:04.871] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[18:02:04.912] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[18:02:04.913] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[18:02:04.914] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[18:02:04.914] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[18:02:04.916] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[18:02:04.916] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:04.919] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:04.919] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[18:02:04.920] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[18:02:04.921] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:04.922] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:04.923] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:04.924] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:04.924] Exporting 11 global objects (94.20 KiB) to cluster node #2 ... DONE
[18:02:04.926] MultisessionFuture started
[18:02:04.926] - Launch lazy future ... done
[18:02:04.927] run() for ‘MultisessionFuture’ ... done
[18:02:04.927] Created future:
[18:02:04.927] MultisessionFuture:
[18:02:04.927] Label: ‘future_vapply-2’
[18:02:04.927] Expression:
[18:02:04.927] {
[18:02:04.927]     do.call(function(...) {
[18:02:04.927]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:04.927]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:04.927]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:04.927]             on.exit(options(oopts), add = TRUE)
[18:02:04.927]         }
[18:02:04.927]         {
[18:02:04.927]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:04.927]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:04.927]                 ...future.FUN(...future.X_jj, ...)
[18:02:04.927]             })
[18:02:04.927]         }
[18:02:04.927]     }, args = future.call.arguments)
[18:02:04.927] }
[18:02:04.927] Lazy evaluation: FALSE
[18:02:04.927] Asynchronous evaluation: TRUE
[18:02:04.927] Local evaluation: TRUE
[18:02:04.927] Environment: R_GlobalEnv
[18:02:04.927] Capture standard output: TRUE
[18:02:04.927] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:04.927] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:04.927] Packages: 1 packages (‘future.apply’)
[18:02:04.927] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:04.927] Resolved: FALSE
[18:02:04.927] Value: <not collected>
[18:02:04.927] Conditions captured: <none>
[18:02:04.927] Early signaling: FALSE
[18:02:04.927] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:04.927] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:04.942] Chunk #2 of 2 ... DONE
[18:02:04.943] Launching 2 futures (chunks) ... DONE
[18:02:04.943] Resolving 2 futures (chunks) ...
[18:02:04.943] resolve() on list ...
[18:02:04.943]  recursive: 0
[18:02:04.944]  length: 2
[18:02:04.944] 
[18:02:04.946] receiveMessageFromWorker() for ClusterFuture ...
[18:02:04.946] - Validating connection of MultisessionFuture
[18:02:04.946] - received message: FutureResult
[18:02:04.947] - Received FutureResult
[18:02:04.947] - Erased future from FutureRegistry
[18:02:04.948] result() for ClusterFuture ...
[18:02:04.948] - result already collected: FutureResult
[18:02:04.948] result() for ClusterFuture ... done
[18:02:04.948] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:04.949] Future #1
[18:02:04.949] result() for ClusterFuture ...
[18:02:04.949] - result already collected: FutureResult
[18:02:04.950] result() for ClusterFuture ... done
[18:02:04.950] result() for ClusterFuture ...
[18:02:04.950] - result already collected: FutureResult
[18:02:04.951] result() for ClusterFuture ... done
[18:02:04.951] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:04.951] - nx: 2
[18:02:04.952] - relay: TRUE
[18:02:04.952] - stdout: TRUE
[18:02:04.952] - signal: TRUE
[18:02:04.952] - resignal: FALSE
[18:02:04.953] - force: TRUE
[18:02:04.953] - relayed: [n=2] FALSE, FALSE
[18:02:04.953] - queued futures: [n=2] FALSE, FALSE
[18:02:04.954]  - until=1
[18:02:04.954]  - relaying element #1
[18:02:04.954] result() for ClusterFuture ...
[18:02:04.954] - result already collected: FutureResult
[18:02:04.955] result() for ClusterFuture ... done
[18:02:04.955] result() for ClusterFuture ...
[18:02:04.955] - result already collected: FutureResult
[18:02:04.956] result() for ClusterFuture ... done
[18:02:04.956] result() for ClusterFuture ...
[18:02:04.956] - result already collected: FutureResult
[18:02:04.957] result() for ClusterFuture ... done
[18:02:04.957] result() for ClusterFuture ...
[18:02:04.957] - result already collected: FutureResult
[18:02:04.958] result() for ClusterFuture ... done
[18:02:04.958] - relayed: [n=2] TRUE, FALSE
[18:02:04.958] - queued futures: [n=2] TRUE, FALSE
[18:02:04.959] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:04.959]  length: 1 (resolved future 1)
[18:02:04.982] receiveMessageFromWorker() for ClusterFuture ...
[18:02:04.982] - Validating connection of MultisessionFuture
[18:02:04.983] - received message: FutureResult
[18:02:04.983] - Received FutureResult
[18:02:04.984] - Erased future from FutureRegistry
[18:02:04.984] result() for ClusterFuture ...
[18:02:04.984] - result already collected: FutureResult
[18:02:04.984] result() for ClusterFuture ... done
[18:02:04.985] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:04.985] Future #2
[18:02:04.985] result() for ClusterFuture ...
[18:02:04.986] - result already collected: FutureResult
[18:02:04.986] result() for ClusterFuture ... done
[18:02:04.986] result() for ClusterFuture ...
[18:02:04.987] - result already collected: FutureResult
[18:02:04.987] result() for ClusterFuture ... done
[18:02:04.987] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:04.988] - nx: 2
[18:02:04.988] - relay: TRUE
[18:02:04.988] - stdout: TRUE
[18:02:04.988] - signal: TRUE
[18:02:04.989] - resignal: FALSE
[18:02:04.989] - force: TRUE
[18:02:04.989] - relayed: [n=2] TRUE, FALSE
[18:02:04.990] - queued futures: [n=2] TRUE, FALSE
[18:02:04.990]  - until=2
[18:02:04.990]  - relaying element #2
[18:02:04.991] result() for ClusterFuture ...
[18:02:04.991] - result already collected: FutureResult
[18:02:04.991] result() for ClusterFuture ... done
[18:02:04.992] result() for ClusterFuture ...
[18:02:04.992] - result already collected: FutureResult
[18:02:04.992] result() for ClusterFuture ... done
[18:02:04.993] result() for ClusterFuture ...
[18:02:04.993] - result already collected: FutureResult
[18:02:04.993] result() for ClusterFuture ... done
[18:02:04.993] result() for ClusterFuture ...
[18:02:04.994] - result already collected: FutureResult
[18:02:04.994] result() for ClusterFuture ... done
[18:02:04.994] - relayed: [n=2] TRUE, TRUE
[18:02:04.995] - queued futures: [n=2] TRUE, TRUE
[18:02:04.995] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:04.995]  length: 0 (resolved future 2)
[18:02:04.996] Relaying remaining futures
[18:02:04.996] signalConditionsASAP(NULL, pos=0) ...
[18:02:04.996] - nx: 2
[18:02:04.996] - relay: TRUE
[18:02:04.997] - stdout: TRUE
[18:02:04.997] - signal: TRUE
[18:02:04.997] - resignal: FALSE
[18:02:04.998] - force: TRUE
[18:02:04.998] - relayed: [n=2] TRUE, TRUE
[18:02:04.998] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:04.999] - relayed: [n=2] TRUE, TRUE
[18:02:04.999] - queued futures: [n=2] TRUE, TRUE
[18:02:04.999] signalConditionsASAP(NULL, pos=0) ... done
[18:02:05.000] resolve() on list ... DONE
[18:02:05.000] result() for ClusterFuture ...
[18:02:05.000] - result already collected: FutureResult
[18:02:05.000] result() for ClusterFuture ... done
[18:02:05.001] result() for ClusterFuture ...
[18:02:05.001] - result already collected: FutureResult
[18:02:05.001] result() for ClusterFuture ... done
[18:02:05.002] result() for ClusterFuture ...
[18:02:05.002] - result already collected: FutureResult
[18:02:05.002] result() for ClusterFuture ... done
[18:02:05.003] result() for ClusterFuture ...
[18:02:05.003] - result already collected: FutureResult
[18:02:05.003] result() for ClusterFuture ... done
[18:02:05.004]  - Number of value chunks collected: 2
[18:02:05.004] Resolving 2 futures (chunks) ... DONE
[18:02:05.004] Reducing values from 2 chunks ...
[18:02:05.004]  - Number of values collected after concatenation: 10
[18:02:05.005]  - Number of values expected: 10
[18:02:05.005] Reducing values from 2 chunks ... DONE
[18:02:05.005] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[18:02:05.008] future_lapply() ...
[18:02:05.022] Number of chunks: 2
[18:02:05.022] getGlobalsAndPackagesXApply() ...
[18:02:05.022]  - future.globals: TRUE
[18:02:05.023] getGlobalsAndPackages() ...
[18:02:05.023] Searching for globals...
[18:02:05.034] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[18:02:05.035] Searching for globals ... DONE
[18:02:05.035] Resolving globals: FALSE
[18:02:05.038] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[18:02:05.039] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:05.039] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:05.040] - packages: [1] ‘future.apply’
[18:02:05.040] getGlobalsAndPackages() ... DONE
[18:02:05.040]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:05.041]  - needed namespaces: [n=1] ‘future.apply’
[18:02:05.041] Finding globals ... DONE
[18:02:05.041]  - use_args: TRUE
[18:02:05.042]  - Getting '...' globals ...
[18:02:05.043] resolve() on list ...
[18:02:05.043]  recursive: 0
[18:02:05.043]  length: 1
[18:02:05.043]  elements: ‘...’
[18:02:05.044]  length: 0 (resolved future 1)
[18:02:05.044] resolve() on list ... DONE
[18:02:05.044]    - '...' content: [n=0] 
[18:02:05.045] List of 1
[18:02:05.045]  $ ...: list()
[18:02:05.045]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:05.045]  - attr(*, "where")=List of 1
[18:02:05.045]   ..$ ...:<environment: 0x6183c1a8bca0> 
[18:02:05.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:05.045]  - attr(*, "resolved")= logi TRUE
[18:02:05.045]  - attr(*, "total_size")= num NA
[18:02:05.052]  - Getting '...' globals ... DONE
[18:02:05.052] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:05.053] List of 8
[18:02:05.053]  $ ...future.FUN:function (x, ...)  
[18:02:05.053]  $ x_FUN        :function (x)  
[18:02:05.053]  $ times        : int 4
[18:02:05.053]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:05.053]  $ stop_if_not  :function (...)  
[18:02:05.053]  $ dim          : int [1:2] 2 2
[18:02:05.053]  $ valid_types  : chr [1:2] "logical" "integer"
[18:02:05.053]  $ ...          : list()
[18:02:05.053]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:05.053]  - attr(*, "where")=List of 8
[18:02:05.053]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:05.053]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:05.053]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:05.053]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:05.053]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:05.053]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:05.053]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:05.053]   ..$ ...          :<environment: 0x6183c1a8bca0> 
[18:02:05.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:05.053]  - attr(*, "resolved")= logi FALSE
[18:02:05.053]  - attr(*, "total_size")= num 97232
[18:02:05.067] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:05.067] getGlobalsAndPackagesXApply() ... DONE
[18:02:05.068] Number of futures (= number of chunks): 2
[18:02:05.068] Launching 2 futures (chunks) ...
[18:02:05.068] Chunk #1 of 2 ...
[18:02:05.069]  - Finding globals in 'X' for chunk #1 ...
[18:02:05.069] getGlobalsAndPackages() ...
[18:02:05.069] Searching for globals...
[18:02:05.070] 
[18:02:05.070] Searching for globals ... DONE
[18:02:05.070] - globals: [0] <none>
[18:02:05.070] getGlobalsAndPackages() ... DONE
[18:02:05.071]    + additional globals found: [n=0] 
[18:02:05.071]    + additional namespaces needed: [n=0] 
[18:02:05.071]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:05.071]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:05.071]  - seeds: <none>
[18:02:05.072]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:05.072] getGlobalsAndPackages() ...
[18:02:05.072] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:05.072] Resolving globals: FALSE
[18:02:05.073] Tweak future expression to call with '...' arguments ...
[18:02:05.073] {
[18:02:05.073]     do.call(function(...) {
[18:02:05.073]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:05.073]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:05.073]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:05.073]             on.exit(options(oopts), add = TRUE)
[18:02:05.073]         }
[18:02:05.073]         {
[18:02:05.073]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:05.073]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:05.073]                 ...future.FUN(...future.X_jj, ...)
[18:02:05.073]             })
[18:02:05.073]         }
[18:02:05.073]     }, args = future.call.arguments)
[18:02:05.073] }
[18:02:05.074] Tweak future expression to call with '...' arguments ... DONE
[18:02:05.075] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:05.075] - packages: [1] ‘future.apply’
[18:02:05.075] getGlobalsAndPackages() ... DONE
[18:02:05.076] run() for ‘Future’ ...
[18:02:05.076] - state: ‘created’
[18:02:05.076] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:05.102] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:05.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:05.102]   - Field: ‘node’
[18:02:05.103]   - Field: ‘label’
[18:02:05.103]   - Field: ‘local’
[18:02:05.103]   - Field: ‘owner’
[18:02:05.103]   - Field: ‘envir’
[18:02:05.103]   - Field: ‘workers’
[18:02:05.104]   - Field: ‘packages’
[18:02:05.104]   - Field: ‘gc’
[18:02:05.104]   - Field: ‘conditions’
[18:02:05.104]   - Field: ‘persistent’
[18:02:05.104]   - Field: ‘expr’
[18:02:05.105]   - Field: ‘uuid’
[18:02:05.105]   - Field: ‘seed’
[18:02:05.105]   - Field: ‘version’
[18:02:05.105]   - Field: ‘result’
[18:02:05.105]   - Field: ‘asynchronous’
[18:02:05.106]   - Field: ‘calls’
[18:02:05.106]   - Field: ‘globals’
[18:02:05.106]   - Field: ‘stdout’
[18:02:05.106]   - Field: ‘earlySignal’
[18:02:05.106]   - Field: ‘lazy’
[18:02:05.106]   - Field: ‘state’
[18:02:05.107] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:05.107] - Launch lazy future ...
[18:02:05.107] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:05.108] Packages needed by future strategies (n = 0): <none>
[18:02:05.109] {
[18:02:05.109]     {
[18:02:05.109]         {
[18:02:05.109]             ...future.startTime <- base::Sys.time()
[18:02:05.109]             {
[18:02:05.109]                 {
[18:02:05.109]                   {
[18:02:05.109]                     {
[18:02:05.109]                       {
[18:02:05.109]                         base::local({
[18:02:05.109]                           has_future <- base::requireNamespace("future", 
[18:02:05.109]                             quietly = TRUE)
[18:02:05.109]                           if (has_future) {
[18:02:05.109]                             ns <- base::getNamespace("future")
[18:02:05.109]                             version <- ns[[".package"]][["version"]]
[18:02:05.109]                             if (is.null(version)) 
[18:02:05.109]                               version <- utils::packageVersion("future")
[18:02:05.109]                           }
[18:02:05.109]                           else {
[18:02:05.109]                             version <- NULL
[18:02:05.109]                           }
[18:02:05.109]                           if (!has_future || version < "1.8.0") {
[18:02:05.109]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:05.109]                               "", base::R.version$version.string), 
[18:02:05.109]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:05.109]                                 base::R.version$platform, 8 * 
[18:02:05.109]                                   base::.Machine$sizeof.pointer), 
[18:02:05.109]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:05.109]                                 "release", "version")], collapse = " "), 
[18:02:05.109]                               hostname = base::Sys.info()[["nodename"]])
[18:02:05.109]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:05.109]                               info)
[18:02:05.109]                             info <- base::paste(info, collapse = "; ")
[18:02:05.109]                             if (!has_future) {
[18:02:05.109]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:05.109]                                 info)
[18:02:05.109]                             }
[18:02:05.109]                             else {
[18:02:05.109]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:05.109]                                 info, version)
[18:02:05.109]                             }
[18:02:05.109]                             base::stop(msg)
[18:02:05.109]                           }
[18:02:05.109]                         })
[18:02:05.109]                       }
[18:02:05.109]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:05.109]                       base::options(mc.cores = 1L)
[18:02:05.109]                     }
[18:02:05.109]                     base::local({
[18:02:05.109]                       for (pkg in "future.apply") {
[18:02:05.109]                         base::loadNamespace(pkg)
[18:02:05.109]                         base::library(pkg, character.only = TRUE)
[18:02:05.109]                       }
[18:02:05.109]                     })
[18:02:05.109]                   }
[18:02:05.109]                   ...future.strategy.old <- future::plan("list")
[18:02:05.109]                   options(future.plan = NULL)
[18:02:05.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:05.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:05.109]                 }
[18:02:05.109]                 ...future.workdir <- getwd()
[18:02:05.109]             }
[18:02:05.109]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:05.109]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:05.109]         }
[18:02:05.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:05.109]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:05.109]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:05.109]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:05.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:05.109]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:05.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:05.109]             base::names(...future.oldOptions))
[18:02:05.109]     }
[18:02:05.109]     if (FALSE) {
[18:02:05.109]     }
[18:02:05.109]     else {
[18:02:05.109]         if (TRUE) {
[18:02:05.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:05.109]                 open = "w")
[18:02:05.109]         }
[18:02:05.109]         else {
[18:02:05.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:05.109]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:05.109]         }
[18:02:05.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:05.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:05.109]             base::sink(type = "output", split = FALSE)
[18:02:05.109]             base::close(...future.stdout)
[18:02:05.109]         }, add = TRUE)
[18:02:05.109]     }
[18:02:05.109]     ...future.frame <- base::sys.nframe()
[18:02:05.109]     ...future.conditions <- base::list()
[18:02:05.109]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:05.109]     if (FALSE) {
[18:02:05.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:05.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:05.109]     }
[18:02:05.109]     ...future.result <- base::tryCatch({
[18:02:05.109]         base::withCallingHandlers({
[18:02:05.109]             ...future.value <- base::withVisible(base::local({
[18:02:05.109]                 ...future.makeSendCondition <- base::local({
[18:02:05.109]                   sendCondition <- NULL
[18:02:05.109]                   function(frame = 1L) {
[18:02:05.109]                     if (is.function(sendCondition)) 
[18:02:05.109]                       return(sendCondition)
[18:02:05.109]                     ns <- getNamespace("parallel")
[18:02:05.109]                     if (exists("sendData", mode = "function", 
[18:02:05.109]                       envir = ns)) {
[18:02:05.109]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:05.109]                         envir = ns)
[18:02:05.109]                       envir <- sys.frame(frame)
[18:02:05.109]                       master <- NULL
[18:02:05.109]                       while (!identical(envir, .GlobalEnv) && 
[18:02:05.109]                         !identical(envir, emptyenv())) {
[18:02:05.109]                         if (exists("master", mode = "list", envir = envir, 
[18:02:05.109]                           inherits = FALSE)) {
[18:02:05.109]                           master <- get("master", mode = "list", 
[18:02:05.109]                             envir = envir, inherits = FALSE)
[18:02:05.109]                           if (inherits(master, c("SOCKnode", 
[18:02:05.109]                             "SOCK0node"))) {
[18:02:05.109]                             sendCondition <<- function(cond) {
[18:02:05.109]                               data <- list(type = "VALUE", value = cond, 
[18:02:05.109]                                 success = TRUE)
[18:02:05.109]                               parallel_sendData(master, data)
[18:02:05.109]                             }
[18:02:05.109]                             return(sendCondition)
[18:02:05.109]                           }
[18:02:05.109]                         }
[18:02:05.109]                         frame <- frame + 1L
[18:02:05.109]                         envir <- sys.frame(frame)
[18:02:05.109]                       }
[18:02:05.109]                     }
[18:02:05.109]                     sendCondition <<- function(cond) NULL
[18:02:05.109]                   }
[18:02:05.109]                 })
[18:02:05.109]                 withCallingHandlers({
[18:02:05.109]                   {
[18:02:05.109]                     do.call(function(...) {
[18:02:05.109]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:05.109]                       if (!identical(...future.globals.maxSize.org, 
[18:02:05.109]                         ...future.globals.maxSize)) {
[18:02:05.109]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:05.109]                         on.exit(options(oopts), add = TRUE)
[18:02:05.109]                       }
[18:02:05.109]                       {
[18:02:05.109]                         lapply(seq_along(...future.elements_ii), 
[18:02:05.109]                           FUN = function(jj) {
[18:02:05.109]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:05.109]                             ...future.FUN(...future.X_jj, ...)
[18:02:05.109]                           })
[18:02:05.109]                       }
[18:02:05.109]                     }, args = future.call.arguments)
[18:02:05.109]                   }
[18:02:05.109]                 }, immediateCondition = function(cond) {
[18:02:05.109]                   sendCondition <- ...future.makeSendCondition()
[18:02:05.109]                   sendCondition(cond)
[18:02:05.109]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:05.109]                   {
[18:02:05.109]                     inherits <- base::inherits
[18:02:05.109]                     invokeRestart <- base::invokeRestart
[18:02:05.109]                     is.null <- base::is.null
[18:02:05.109]                     muffled <- FALSE
[18:02:05.109]                     if (inherits(cond, "message")) {
[18:02:05.109]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:05.109]                       if (muffled) 
[18:02:05.109]                         invokeRestart("muffleMessage")
[18:02:05.109]                     }
[18:02:05.109]                     else if (inherits(cond, "warning")) {
[18:02:05.109]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:05.109]                       if (muffled) 
[18:02:05.109]                         invokeRestart("muffleWarning")
[18:02:05.109]                     }
[18:02:05.109]                     else if (inherits(cond, "condition")) {
[18:02:05.109]                       if (!is.null(pattern)) {
[18:02:05.109]                         computeRestarts <- base::computeRestarts
[18:02:05.109]                         grepl <- base::grepl
[18:02:05.109]                         restarts <- computeRestarts(cond)
[18:02:05.109]                         for (restart in restarts) {
[18:02:05.109]                           name <- restart$name
[18:02:05.109]                           if (is.null(name)) 
[18:02:05.109]                             next
[18:02:05.109]                           if (!grepl(pattern, name)) 
[18:02:05.109]                             next
[18:02:05.109]                           invokeRestart(restart)
[18:02:05.109]                           muffled <- TRUE
[18:02:05.109]                           break
[18:02:05.109]                         }
[18:02:05.109]                       }
[18:02:05.109]                     }
[18:02:05.109]                     invisible(muffled)
[18:02:05.109]                   }
[18:02:05.109]                   muffleCondition(cond)
[18:02:05.109]                 })
[18:02:05.109]             }))
[18:02:05.109]             future::FutureResult(value = ...future.value$value, 
[18:02:05.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:05.109]                   ...future.rng), globalenv = if (FALSE) 
[18:02:05.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:05.109]                     ...future.globalenv.names))
[18:02:05.109]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:05.109]         }, condition = base::local({
[18:02:05.109]             c <- base::c
[18:02:05.109]             inherits <- base::inherits
[18:02:05.109]             invokeRestart <- base::invokeRestart
[18:02:05.109]             length <- base::length
[18:02:05.109]             list <- base::list
[18:02:05.109]             seq.int <- base::seq.int
[18:02:05.109]             signalCondition <- base::signalCondition
[18:02:05.109]             sys.calls <- base::sys.calls
[18:02:05.109]             `[[` <- base::`[[`
[18:02:05.109]             `+` <- base::`+`
[18:02:05.109]             `<<-` <- base::`<<-`
[18:02:05.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:05.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:05.109]                   3L)]
[18:02:05.109]             }
[18:02:05.109]             function(cond) {
[18:02:05.109]                 is_error <- inherits(cond, "error")
[18:02:05.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:05.109]                   NULL)
[18:02:05.109]                 if (is_error) {
[18:02:05.109]                   sessionInformation <- function() {
[18:02:05.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:05.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:05.109]                       search = base::search(), system = base::Sys.info())
[18:02:05.109]                   }
[18:02:05.109]                   ...future.conditions[[length(...future.conditions) + 
[18:02:05.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:05.109]                     cond$call), session = sessionInformation(), 
[18:02:05.109]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:05.109]                   signalCondition(cond)
[18:02:05.109]                 }
[18:02:05.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:05.109]                 "immediateCondition"))) {
[18:02:05.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:05.109]                   ...future.conditions[[length(...future.conditions) + 
[18:02:05.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:05.109]                   if (TRUE && !signal) {
[18:02:05.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:05.109]                     {
[18:02:05.109]                       inherits <- base::inherits
[18:02:05.109]                       invokeRestart <- base::invokeRestart
[18:02:05.109]                       is.null <- base::is.null
[18:02:05.109]                       muffled <- FALSE
[18:02:05.109]                       if (inherits(cond, "message")) {
[18:02:05.109]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:05.109]                         if (muffled) 
[18:02:05.109]                           invokeRestart("muffleMessage")
[18:02:05.109]                       }
[18:02:05.109]                       else if (inherits(cond, "warning")) {
[18:02:05.109]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:05.109]                         if (muffled) 
[18:02:05.109]                           invokeRestart("muffleWarning")
[18:02:05.109]                       }
[18:02:05.109]                       else if (inherits(cond, "condition")) {
[18:02:05.109]                         if (!is.null(pattern)) {
[18:02:05.109]                           computeRestarts <- base::computeRestarts
[18:02:05.109]                           grepl <- base::grepl
[18:02:05.109]                           restarts <- computeRestarts(cond)
[18:02:05.109]                           for (restart in restarts) {
[18:02:05.109]                             name <- restart$name
[18:02:05.109]                             if (is.null(name)) 
[18:02:05.109]                               next
[18:02:05.109]                             if (!grepl(pattern, name)) 
[18:02:05.109]                               next
[18:02:05.109]                             invokeRestart(restart)
[18:02:05.109]                             muffled <- TRUE
[18:02:05.109]                             break
[18:02:05.109]                           }
[18:02:05.109]                         }
[18:02:05.109]                       }
[18:02:05.109]                       invisible(muffled)
[18:02:05.109]                     }
[18:02:05.109]                     muffleCondition(cond, pattern = "^muffle")
[18:02:05.109]                   }
[18:02:05.109]                 }
[18:02:05.109]                 else {
[18:02:05.109]                   if (TRUE) {
[18:02:05.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:05.109]                     {
[18:02:05.109]                       inherits <- base::inherits
[18:02:05.109]                       invokeRestart <- base::invokeRestart
[18:02:05.109]                       is.null <- base::is.null
[18:02:05.109]                       muffled <- FALSE
[18:02:05.109]                       if (inherits(cond, "message")) {
[18:02:05.109]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:05.109]                         if (muffled) 
[18:02:05.109]                           invokeRestart("muffleMessage")
[18:02:05.109]                       }
[18:02:05.109]                       else if (inherits(cond, "warning")) {
[18:02:05.109]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:05.109]                         if (muffled) 
[18:02:05.109]                           invokeRestart("muffleWarning")
[18:02:05.109]                       }
[18:02:05.109]                       else if (inherits(cond, "condition")) {
[18:02:05.109]                         if (!is.null(pattern)) {
[18:02:05.109]                           computeRestarts <- base::computeRestarts
[18:02:05.109]                           grepl <- base::grepl
[18:02:05.109]                           restarts <- computeRestarts(cond)
[18:02:05.109]                           for (restart in restarts) {
[18:02:05.109]                             name <- restart$name
[18:02:05.109]                             if (is.null(name)) 
[18:02:05.109]                               next
[18:02:05.109]                             if (!grepl(pattern, name)) 
[18:02:05.109]                               next
[18:02:05.109]                             invokeRestart(restart)
[18:02:05.109]                             muffled <- TRUE
[18:02:05.109]                             break
[18:02:05.109]                           }
[18:02:05.109]                         }
[18:02:05.109]                       }
[18:02:05.109]                       invisible(muffled)
[18:02:05.109]                     }
[18:02:05.109]                     muffleCondition(cond, pattern = "^muffle")
[18:02:05.109]                   }
[18:02:05.109]                 }
[18:02:05.109]             }
[18:02:05.109]         }))
[18:02:05.109]     }, error = function(ex) {
[18:02:05.109]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:05.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:05.109]                 ...future.rng), started = ...future.startTime, 
[18:02:05.109]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:05.109]             version = "1.8"), class = "FutureResult")
[18:02:05.109]     }, finally = {
[18:02:05.109]         if (!identical(...future.workdir, getwd())) 
[18:02:05.109]             setwd(...future.workdir)
[18:02:05.109]         {
[18:02:05.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:05.109]                 ...future.oldOptions$nwarnings <- NULL
[18:02:05.109]             }
[18:02:05.109]             base::options(...future.oldOptions)
[18:02:05.109]             if (.Platform$OS.type == "windows") {
[18:02:05.109]                 old_names <- names(...future.oldEnvVars)
[18:02:05.109]                 envs <- base::Sys.getenv()
[18:02:05.109]                 names <- names(envs)
[18:02:05.109]                 common <- intersect(names, old_names)
[18:02:05.109]                 added <- setdiff(names, old_names)
[18:02:05.109]                 removed <- setdiff(old_names, names)
[18:02:05.109]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:05.109]                   envs[common]]
[18:02:05.109]                 NAMES <- toupper(changed)
[18:02:05.109]                 args <- list()
[18:02:05.109]                 for (kk in seq_along(NAMES)) {
[18:02:05.109]                   name <- changed[[kk]]
[18:02:05.109]                   NAME <- NAMES[[kk]]
[18:02:05.109]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:05.109]                     next
[18:02:05.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:05.109]                 }
[18:02:05.109]                 NAMES <- toupper(added)
[18:02:05.109]                 for (kk in seq_along(NAMES)) {
[18:02:05.109]                   name <- added[[kk]]
[18:02:05.109]                   NAME <- NAMES[[kk]]
[18:02:05.109]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:05.109]                     next
[18:02:05.109]                   args[[name]] <- ""
[18:02:05.109]                 }
[18:02:05.109]                 NAMES <- toupper(removed)
[18:02:05.109]                 for (kk in seq_along(NAMES)) {
[18:02:05.109]                   name <- removed[[kk]]
[18:02:05.109]                   NAME <- NAMES[[kk]]
[18:02:05.109]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:05.109]                     next
[18:02:05.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:05.109]                 }
[18:02:05.109]                 if (length(args) > 0) 
[18:02:05.109]                   base::do.call(base::Sys.setenv, args = args)
[18:02:05.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:05.109]             }
[18:02:05.109]             else {
[18:02:05.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:05.109]             }
[18:02:05.109]             {
[18:02:05.109]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:05.109]                   0L) {
[18:02:05.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:05.109]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:05.109]                   base::options(opts)
[18:02:05.109]                 }
[18:02:05.109]                 {
[18:02:05.109]                   {
[18:02:05.109]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:05.109]                     NULL
[18:02:05.109]                   }
[18:02:05.109]                   options(future.plan = NULL)
[18:02:05.109]                   if (is.na(NA_character_)) 
[18:02:05.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:05.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:05.109]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:05.109]                     .init = FALSE)
[18:02:05.109]                 }
[18:02:05.109]             }
[18:02:05.109]         }
[18:02:05.109]     })
[18:02:05.109]     if (TRUE) {
[18:02:05.109]         base::sink(type = "output", split = FALSE)
[18:02:05.109]         if (TRUE) {
[18:02:05.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:05.109]         }
[18:02:05.109]         else {
[18:02:05.109]             ...future.result["stdout"] <- base::list(NULL)
[18:02:05.109]         }
[18:02:05.109]         base::close(...future.stdout)
[18:02:05.109]         ...future.stdout <- NULL
[18:02:05.109]     }
[18:02:05.109]     ...future.result$conditions <- ...future.conditions
[18:02:05.109]     ...future.result$finished <- base::Sys.time()
[18:02:05.109]     ...future.result
[18:02:05.109] }
[18:02:05.114] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[18:02:05.114] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[18:02:05.155] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[18:02:05.156] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[18:02:05.157] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[18:02:05.158] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[18:02:05.158] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[18:02:05.159] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[18:02:05.200] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[18:02:05.201] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[18:02:05.242] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[18:02:05.243] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[18:02:05.244] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[18:02:05.244] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[18:02:05.245] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[18:02:05.246] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:05.247] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:05.248] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[18:02:05.249] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[18:02:05.250] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:05.251] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:05.251] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:05.252] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:05.253] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[18:02:05.254] MultisessionFuture started
[18:02:05.255] - Launch lazy future ... done
[18:02:05.255] run() for ‘MultisessionFuture’ ... done
[18:02:05.255] Created future:
[18:02:05.256] MultisessionFuture:
[18:02:05.256] Label: ‘future_vapply-1’
[18:02:05.256] Expression:
[18:02:05.256] {
[18:02:05.256]     do.call(function(...) {
[18:02:05.256]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:05.256]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:05.256]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:05.256]             on.exit(options(oopts), add = TRUE)
[18:02:05.256]         }
[18:02:05.256]         {
[18:02:05.256]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:05.256]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:05.256]                 ...future.FUN(...future.X_jj, ...)
[18:02:05.256]             })
[18:02:05.256]         }
[18:02:05.256]     }, args = future.call.arguments)
[18:02:05.256] }
[18:02:05.256] Lazy evaluation: FALSE
[18:02:05.256] Asynchronous evaluation: TRUE
[18:02:05.256] Local evaluation: TRUE
[18:02:05.256] Environment: R_GlobalEnv
[18:02:05.256] Capture standard output: TRUE
[18:02:05.256] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:05.256] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:05.256] Packages: 1 packages (‘future.apply’)
[18:02:05.256] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:05.256] Resolved: FALSE
[18:02:05.256] Value: <not collected>
[18:02:05.256] Conditions captured: <none>
[18:02:05.256] Early signaling: FALSE
[18:02:05.256] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:05.256] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:05.271] Chunk #1 of 2 ... DONE
[18:02:05.271] Chunk #2 of 2 ...
[18:02:05.271]  - Finding globals in 'X' for chunk #2 ...
[18:02:05.272] getGlobalsAndPackages() ...
[18:02:05.272] Searching for globals...
[18:02:05.273] 
[18:02:05.273] Searching for globals ... DONE
[18:02:05.274] - globals: [0] <none>
[18:02:05.274] getGlobalsAndPackages() ... DONE
[18:02:05.274]    + additional globals found: [n=0] 
[18:02:05.275]    + additional namespaces needed: [n=0] 
[18:02:05.275]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:05.275]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:05.275]  - seeds: <none>
[18:02:05.276]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:05.276] getGlobalsAndPackages() ...
[18:02:05.276] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:05.277] Resolving globals: FALSE
[18:02:05.277] Tweak future expression to call with '...' arguments ...
[18:02:05.278] {
[18:02:05.278]     do.call(function(...) {
[18:02:05.278]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:05.278]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:05.278]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:05.278]             on.exit(options(oopts), add = TRUE)
[18:02:05.278]         }
[18:02:05.278]         {
[18:02:05.278]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:05.278]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:05.278]                 ...future.FUN(...future.X_jj, ...)
[18:02:05.278]             })
[18:02:05.278]         }
[18:02:05.278]     }, args = future.call.arguments)
[18:02:05.278] }
[18:02:05.278] Tweak future expression to call with '...' arguments ... DONE
[18:02:05.280] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:05.281] - packages: [1] ‘future.apply’
[18:02:05.281] getGlobalsAndPackages() ... DONE
[18:02:05.282] run() for ‘Future’ ...
[18:02:05.282] - state: ‘created’
[18:02:05.283] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:05.310] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:05.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:05.311]   - Field: ‘node’
[18:02:05.311]   - Field: ‘label’
[18:02:05.311]   - Field: ‘local’
[18:02:05.312]   - Field: ‘owner’
[18:02:05.312]   - Field: ‘envir’
[18:02:05.312]   - Field: ‘workers’
[18:02:05.312]   - Field: ‘packages’
[18:02:05.313]   - Field: ‘gc’
[18:02:05.313]   - Field: ‘conditions’
[18:02:05.313]   - Field: ‘persistent’
[18:02:05.313]   - Field: ‘expr’
[18:02:05.313]   - Field: ‘uuid’
[18:02:05.314]   - Field: ‘seed’
[18:02:05.314]   - Field: ‘version’
[18:02:05.314]   - Field: ‘result’
[18:02:05.314]   - Field: ‘asynchronous’
[18:02:05.315]   - Field: ‘calls’
[18:02:05.315]   - Field: ‘globals’
[18:02:05.315]   - Field: ‘stdout’
[18:02:05.315]   - Field: ‘earlySignal’
[18:02:05.315]   - Field: ‘lazy’
[18:02:05.316]   - Field: ‘state’
[18:02:05.316] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:05.316] - Launch lazy future ...
[18:02:05.317] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:05.317] Packages needed by future strategies (n = 0): <none>
[18:02:05.319] {
[18:02:05.319]     {
[18:02:05.319]         {
[18:02:05.319]             ...future.startTime <- base::Sys.time()
[18:02:05.319]             {
[18:02:05.319]                 {
[18:02:05.319]                   {
[18:02:05.319]                     {
[18:02:05.319]                       {
[18:02:05.319]                         base::local({
[18:02:05.319]                           has_future <- base::requireNamespace("future", 
[18:02:05.319]                             quietly = TRUE)
[18:02:05.319]                           if (has_future) {
[18:02:05.319]                             ns <- base::getNamespace("future")
[18:02:05.319]                             version <- ns[[".package"]][["version"]]
[18:02:05.319]                             if (is.null(version)) 
[18:02:05.319]                               version <- utils::packageVersion("future")
[18:02:05.319]                           }
[18:02:05.319]                           else {
[18:02:05.319]                             version <- NULL
[18:02:05.319]                           }
[18:02:05.319]                           if (!has_future || version < "1.8.0") {
[18:02:05.319]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:05.319]                               "", base::R.version$version.string), 
[18:02:05.319]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:05.319]                                 base::R.version$platform, 8 * 
[18:02:05.319]                                   base::.Machine$sizeof.pointer), 
[18:02:05.319]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:05.319]                                 "release", "version")], collapse = " "), 
[18:02:05.319]                               hostname = base::Sys.info()[["nodename"]])
[18:02:05.319]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:05.319]                               info)
[18:02:05.319]                             info <- base::paste(info, collapse = "; ")
[18:02:05.319]                             if (!has_future) {
[18:02:05.319]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:05.319]                                 info)
[18:02:05.319]                             }
[18:02:05.319]                             else {
[18:02:05.319]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:05.319]                                 info, version)
[18:02:05.319]                             }
[18:02:05.319]                             base::stop(msg)
[18:02:05.319]                           }
[18:02:05.319]                         })
[18:02:05.319]                       }
[18:02:05.319]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:05.319]                       base::options(mc.cores = 1L)
[18:02:05.319]                     }
[18:02:05.319]                     base::local({
[18:02:05.319]                       for (pkg in "future.apply") {
[18:02:05.319]                         base::loadNamespace(pkg)
[18:02:05.319]                         base::library(pkg, character.only = TRUE)
[18:02:05.319]                       }
[18:02:05.319]                     })
[18:02:05.319]                   }
[18:02:05.319]                   ...future.strategy.old <- future::plan("list")
[18:02:05.319]                   options(future.plan = NULL)
[18:02:05.319]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:05.319]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:05.319]                 }
[18:02:05.319]                 ...future.workdir <- getwd()
[18:02:05.319]             }
[18:02:05.319]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:05.319]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:05.319]         }
[18:02:05.319]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:05.319]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:05.319]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:05.319]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:05.319]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:05.319]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:05.319]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:05.319]             base::names(...future.oldOptions))
[18:02:05.319]     }
[18:02:05.319]     if (FALSE) {
[18:02:05.319]     }
[18:02:05.319]     else {
[18:02:05.319]         if (TRUE) {
[18:02:05.319]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:05.319]                 open = "w")
[18:02:05.319]         }
[18:02:05.319]         else {
[18:02:05.319]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:05.319]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:05.319]         }
[18:02:05.319]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:05.319]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:05.319]             base::sink(type = "output", split = FALSE)
[18:02:05.319]             base::close(...future.stdout)
[18:02:05.319]         }, add = TRUE)
[18:02:05.319]     }
[18:02:05.319]     ...future.frame <- base::sys.nframe()
[18:02:05.319]     ...future.conditions <- base::list()
[18:02:05.319]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:05.319]     if (FALSE) {
[18:02:05.319]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:05.319]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:05.319]     }
[18:02:05.319]     ...future.result <- base::tryCatch({
[18:02:05.319]         base::withCallingHandlers({
[18:02:05.319]             ...future.value <- base::withVisible(base::local({
[18:02:05.319]                 ...future.makeSendCondition <- base::local({
[18:02:05.319]                   sendCondition <- NULL
[18:02:05.319]                   function(frame = 1L) {
[18:02:05.319]                     if (is.function(sendCondition)) 
[18:02:05.319]                       return(sendCondition)
[18:02:05.319]                     ns <- getNamespace("parallel")
[18:02:05.319]                     if (exists("sendData", mode = "function", 
[18:02:05.319]                       envir = ns)) {
[18:02:05.319]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:05.319]                         envir = ns)
[18:02:05.319]                       envir <- sys.frame(frame)
[18:02:05.319]                       master <- NULL
[18:02:05.319]                       while (!identical(envir, .GlobalEnv) && 
[18:02:05.319]                         !identical(envir, emptyenv())) {
[18:02:05.319]                         if (exists("master", mode = "list", envir = envir, 
[18:02:05.319]                           inherits = FALSE)) {
[18:02:05.319]                           master <- get("master", mode = "list", 
[18:02:05.319]                             envir = envir, inherits = FALSE)
[18:02:05.319]                           if (inherits(master, c("SOCKnode", 
[18:02:05.319]                             "SOCK0node"))) {
[18:02:05.319]                             sendCondition <<- function(cond) {
[18:02:05.319]                               data <- list(type = "VALUE", value = cond, 
[18:02:05.319]                                 success = TRUE)
[18:02:05.319]                               parallel_sendData(master, data)
[18:02:05.319]                             }
[18:02:05.319]                             return(sendCondition)
[18:02:05.319]                           }
[18:02:05.319]                         }
[18:02:05.319]                         frame <- frame + 1L
[18:02:05.319]                         envir <- sys.frame(frame)
[18:02:05.319]                       }
[18:02:05.319]                     }
[18:02:05.319]                     sendCondition <<- function(cond) NULL
[18:02:05.319]                   }
[18:02:05.319]                 })
[18:02:05.319]                 withCallingHandlers({
[18:02:05.319]                   {
[18:02:05.319]                     do.call(function(...) {
[18:02:05.319]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:05.319]                       if (!identical(...future.globals.maxSize.org, 
[18:02:05.319]                         ...future.globals.maxSize)) {
[18:02:05.319]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:05.319]                         on.exit(options(oopts), add = TRUE)
[18:02:05.319]                       }
[18:02:05.319]                       {
[18:02:05.319]                         lapply(seq_along(...future.elements_ii), 
[18:02:05.319]                           FUN = function(jj) {
[18:02:05.319]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:05.319]                             ...future.FUN(...future.X_jj, ...)
[18:02:05.319]                           })
[18:02:05.319]                       }
[18:02:05.319]                     }, args = future.call.arguments)
[18:02:05.319]                   }
[18:02:05.319]                 }, immediateCondition = function(cond) {
[18:02:05.319]                   sendCondition <- ...future.makeSendCondition()
[18:02:05.319]                   sendCondition(cond)
[18:02:05.319]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:05.319]                   {
[18:02:05.319]                     inherits <- base::inherits
[18:02:05.319]                     invokeRestart <- base::invokeRestart
[18:02:05.319]                     is.null <- base::is.null
[18:02:05.319]                     muffled <- FALSE
[18:02:05.319]                     if (inherits(cond, "message")) {
[18:02:05.319]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:05.319]                       if (muffled) 
[18:02:05.319]                         invokeRestart("muffleMessage")
[18:02:05.319]                     }
[18:02:05.319]                     else if (inherits(cond, "warning")) {
[18:02:05.319]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:05.319]                       if (muffled) 
[18:02:05.319]                         invokeRestart("muffleWarning")
[18:02:05.319]                     }
[18:02:05.319]                     else if (inherits(cond, "condition")) {
[18:02:05.319]                       if (!is.null(pattern)) {
[18:02:05.319]                         computeRestarts <- base::computeRestarts
[18:02:05.319]                         grepl <- base::grepl
[18:02:05.319]                         restarts <- computeRestarts(cond)
[18:02:05.319]                         for (restart in restarts) {
[18:02:05.319]                           name <- restart$name
[18:02:05.319]                           if (is.null(name)) 
[18:02:05.319]                             next
[18:02:05.319]                           if (!grepl(pattern, name)) 
[18:02:05.319]                             next
[18:02:05.319]                           invokeRestart(restart)
[18:02:05.319]                           muffled <- TRUE
[18:02:05.319]                           break
[18:02:05.319]                         }
[18:02:05.319]                       }
[18:02:05.319]                     }
[18:02:05.319]                     invisible(muffled)
[18:02:05.319]                   }
[18:02:05.319]                   muffleCondition(cond)
[18:02:05.319]                 })
[18:02:05.319]             }))
[18:02:05.319]             future::FutureResult(value = ...future.value$value, 
[18:02:05.319]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:05.319]                   ...future.rng), globalenv = if (FALSE) 
[18:02:05.319]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:05.319]                     ...future.globalenv.names))
[18:02:05.319]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:05.319]         }, condition = base::local({
[18:02:05.319]             c <- base::c
[18:02:05.319]             inherits <- base::inherits
[18:02:05.319]             invokeRestart <- base::invokeRestart
[18:02:05.319]             length <- base::length
[18:02:05.319]             list <- base::list
[18:02:05.319]             seq.int <- base::seq.int
[18:02:05.319]             signalCondition <- base::signalCondition
[18:02:05.319]             sys.calls <- base::sys.calls
[18:02:05.319]             `[[` <- base::`[[`
[18:02:05.319]             `+` <- base::`+`
[18:02:05.319]             `<<-` <- base::`<<-`
[18:02:05.319]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:05.319]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:05.319]                   3L)]
[18:02:05.319]             }
[18:02:05.319]             function(cond) {
[18:02:05.319]                 is_error <- inherits(cond, "error")
[18:02:05.319]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:05.319]                   NULL)
[18:02:05.319]                 if (is_error) {
[18:02:05.319]                   sessionInformation <- function() {
[18:02:05.319]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:05.319]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:05.319]                       search = base::search(), system = base::Sys.info())
[18:02:05.319]                   }
[18:02:05.319]                   ...future.conditions[[length(...future.conditions) + 
[18:02:05.319]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:05.319]                     cond$call), session = sessionInformation(), 
[18:02:05.319]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:05.319]                   signalCondition(cond)
[18:02:05.319]                 }
[18:02:05.319]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:05.319]                 "immediateCondition"))) {
[18:02:05.319]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:05.319]                   ...future.conditions[[length(...future.conditions) + 
[18:02:05.319]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:05.319]                   if (TRUE && !signal) {
[18:02:05.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:05.319]                     {
[18:02:05.319]                       inherits <- base::inherits
[18:02:05.319]                       invokeRestart <- base::invokeRestart
[18:02:05.319]                       is.null <- base::is.null
[18:02:05.319]                       muffled <- FALSE
[18:02:05.319]                       if (inherits(cond, "message")) {
[18:02:05.319]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:05.319]                         if (muffled) 
[18:02:05.319]                           invokeRestart("muffleMessage")
[18:02:05.319]                       }
[18:02:05.319]                       else if (inherits(cond, "warning")) {
[18:02:05.319]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:05.319]                         if (muffled) 
[18:02:05.319]                           invokeRestart("muffleWarning")
[18:02:05.319]                       }
[18:02:05.319]                       else if (inherits(cond, "condition")) {
[18:02:05.319]                         if (!is.null(pattern)) {
[18:02:05.319]                           computeRestarts <- base::computeRestarts
[18:02:05.319]                           grepl <- base::grepl
[18:02:05.319]                           restarts <- computeRestarts(cond)
[18:02:05.319]                           for (restart in restarts) {
[18:02:05.319]                             name <- restart$name
[18:02:05.319]                             if (is.null(name)) 
[18:02:05.319]                               next
[18:02:05.319]                             if (!grepl(pattern, name)) 
[18:02:05.319]                               next
[18:02:05.319]                             invokeRestart(restart)
[18:02:05.319]                             muffled <- TRUE
[18:02:05.319]                             break
[18:02:05.319]                           }
[18:02:05.319]                         }
[18:02:05.319]                       }
[18:02:05.319]                       invisible(muffled)
[18:02:05.319]                     }
[18:02:05.319]                     muffleCondition(cond, pattern = "^muffle")
[18:02:05.319]                   }
[18:02:05.319]                 }
[18:02:05.319]                 else {
[18:02:05.319]                   if (TRUE) {
[18:02:05.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:05.319]                     {
[18:02:05.319]                       inherits <- base::inherits
[18:02:05.319]                       invokeRestart <- base::invokeRestart
[18:02:05.319]                       is.null <- base::is.null
[18:02:05.319]                       muffled <- FALSE
[18:02:05.319]                       if (inherits(cond, "message")) {
[18:02:05.319]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:05.319]                         if (muffled) 
[18:02:05.319]                           invokeRestart("muffleMessage")
[18:02:05.319]                       }
[18:02:05.319]                       else if (inherits(cond, "warning")) {
[18:02:05.319]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:05.319]                         if (muffled) 
[18:02:05.319]                           invokeRestart("muffleWarning")
[18:02:05.319]                       }
[18:02:05.319]                       else if (inherits(cond, "condition")) {
[18:02:05.319]                         if (!is.null(pattern)) {
[18:02:05.319]                           computeRestarts <- base::computeRestarts
[18:02:05.319]                           grepl <- base::grepl
[18:02:05.319]                           restarts <- computeRestarts(cond)
[18:02:05.319]                           for (restart in restarts) {
[18:02:05.319]                             name <- restart$name
[18:02:05.319]                             if (is.null(name)) 
[18:02:05.319]                               next
[18:02:05.319]                             if (!grepl(pattern, name)) 
[18:02:05.319]                               next
[18:02:05.319]                             invokeRestart(restart)
[18:02:05.319]                             muffled <- TRUE
[18:02:05.319]                             break
[18:02:05.319]                           }
[18:02:05.319]                         }
[18:02:05.319]                       }
[18:02:05.319]                       invisible(muffled)
[18:02:05.319]                     }
[18:02:05.319]                     muffleCondition(cond, pattern = "^muffle")
[18:02:05.319]                   }
[18:02:05.319]                 }
[18:02:05.319]             }
[18:02:05.319]         }))
[18:02:05.319]     }, error = function(ex) {
[18:02:05.319]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:05.319]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:05.319]                 ...future.rng), started = ...future.startTime, 
[18:02:05.319]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:05.319]             version = "1.8"), class = "FutureResult")
[18:02:05.319]     }, finally = {
[18:02:05.319]         if (!identical(...future.workdir, getwd())) 
[18:02:05.319]             setwd(...future.workdir)
[18:02:05.319]         {
[18:02:05.319]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:05.319]                 ...future.oldOptions$nwarnings <- NULL
[18:02:05.319]             }
[18:02:05.319]             base::options(...future.oldOptions)
[18:02:05.319]             if (.Platform$OS.type == "windows") {
[18:02:05.319]                 old_names <- names(...future.oldEnvVars)
[18:02:05.319]                 envs <- base::Sys.getenv()
[18:02:05.319]                 names <- names(envs)
[18:02:05.319]                 common <- intersect(names, old_names)
[18:02:05.319]                 added <- setdiff(names, old_names)
[18:02:05.319]                 removed <- setdiff(old_names, names)
[18:02:05.319]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:05.319]                   envs[common]]
[18:02:05.319]                 NAMES <- toupper(changed)
[18:02:05.319]                 args <- list()
[18:02:05.319]                 for (kk in seq_along(NAMES)) {
[18:02:05.319]                   name <- changed[[kk]]
[18:02:05.319]                   NAME <- NAMES[[kk]]
[18:02:05.319]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:05.319]                     next
[18:02:05.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:05.319]                 }
[18:02:05.319]                 NAMES <- toupper(added)
[18:02:05.319]                 for (kk in seq_along(NAMES)) {
[18:02:05.319]                   name <- added[[kk]]
[18:02:05.319]                   NAME <- NAMES[[kk]]
[18:02:05.319]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:05.319]                     next
[18:02:05.319]                   args[[name]] <- ""
[18:02:05.319]                 }
[18:02:05.319]                 NAMES <- toupper(removed)
[18:02:05.319]                 for (kk in seq_along(NAMES)) {
[18:02:05.319]                   name <- removed[[kk]]
[18:02:05.319]                   NAME <- NAMES[[kk]]
[18:02:05.319]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:05.319]                     next
[18:02:05.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:05.319]                 }
[18:02:05.319]                 if (length(args) > 0) 
[18:02:05.319]                   base::do.call(base::Sys.setenv, args = args)
[18:02:05.319]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:05.319]             }
[18:02:05.319]             else {
[18:02:05.319]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:05.319]             }
[18:02:05.319]             {
[18:02:05.319]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:05.319]                   0L) {
[18:02:05.319]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:05.319]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:05.319]                   base::options(opts)
[18:02:05.319]                 }
[18:02:05.319]                 {
[18:02:05.319]                   {
[18:02:05.319]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:05.319]                     NULL
[18:02:05.319]                   }
[18:02:05.319]                   options(future.plan = NULL)
[18:02:05.319]                   if (is.na(NA_character_)) 
[18:02:05.319]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:05.319]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:05.319]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:05.319]                     .init = FALSE)
[18:02:05.319]                 }
[18:02:05.319]             }
[18:02:05.319]         }
[18:02:05.319]     })
[18:02:05.319]     if (TRUE) {
[18:02:05.319]         base::sink(type = "output", split = FALSE)
[18:02:05.319]         if (TRUE) {
[18:02:05.319]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:05.319]         }
[18:02:05.319]         else {
[18:02:05.319]             ...future.result["stdout"] <- base::list(NULL)
[18:02:05.319]         }
[18:02:05.319]         base::close(...future.stdout)
[18:02:05.319]         ...future.stdout <- NULL
[18:02:05.319]     }
[18:02:05.319]     ...future.result$conditions <- ...future.conditions
[18:02:05.319]     ...future.result$finished <- base::Sys.time()
[18:02:05.319]     ...future.result
[18:02:05.319] }
[18:02:05.325] Exporting 11 global objects (94.95 KiB) to cluster node #2 ...
[18:02:05.326] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[18:02:05.367] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[18:02:05.368] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[18:02:05.370] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[18:02:05.371] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[18:02:05.372] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[18:02:05.372] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[18:02:05.413] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[18:02:05.414] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[18:02:05.455] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[18:02:05.456] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[18:02:05.457] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[18:02:05.458] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[18:02:05.459] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[18:02:05.459] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:05.460] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:05.461] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[18:02:05.462] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[18:02:05.463] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:05.464] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:05.464] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:05.465] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:05.466] Exporting 11 global objects (94.95 KiB) to cluster node #2 ... DONE
[18:02:05.467] MultisessionFuture started
[18:02:05.468] - Launch lazy future ... done
[18:02:05.468] run() for ‘MultisessionFuture’ ... done
[18:02:05.469] Created future:
[18:02:05.469] MultisessionFuture:
[18:02:05.469] Label: ‘future_vapply-2’
[18:02:05.469] Expression:
[18:02:05.469] {
[18:02:05.469]     do.call(function(...) {
[18:02:05.469]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:05.469]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:05.469]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:05.469]             on.exit(options(oopts), add = TRUE)
[18:02:05.469]         }
[18:02:05.469]         {
[18:02:05.469]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:05.469]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:05.469]                 ...future.FUN(...future.X_jj, ...)
[18:02:05.469]             })
[18:02:05.469]         }
[18:02:05.469]     }, args = future.call.arguments)
[18:02:05.469] }
[18:02:05.469] Lazy evaluation: FALSE
[18:02:05.469] Asynchronous evaluation: TRUE
[18:02:05.469] Local evaluation: TRUE
[18:02:05.469] Environment: R_GlobalEnv
[18:02:05.469] Capture standard output: TRUE
[18:02:05.469] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:05.469] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:05.469] Packages: 1 packages (‘future.apply’)
[18:02:05.469] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:05.469] Resolved: FALSE
[18:02:05.469] Value: <not collected>
[18:02:05.469] Conditions captured: <none>
[18:02:05.469] Early signaling: FALSE
[18:02:05.469] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:05.469] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:05.484] Chunk #2 of 2 ... DONE
[18:02:05.484] Launching 2 futures (chunks) ... DONE
[18:02:05.485] Resolving 2 futures (chunks) ...
[18:02:05.485] resolve() on list ...
[18:02:05.485]  recursive: 0
[18:02:05.486]  length: 2
[18:02:05.486] 
[18:02:05.487] receiveMessageFromWorker() for ClusterFuture ...
[18:02:05.488] - Validating connection of MultisessionFuture
[18:02:05.488] - received message: FutureResult
[18:02:05.489] - Received FutureResult
[18:02:05.489] - Erased future from FutureRegistry
[18:02:05.489] result() for ClusterFuture ...
[18:02:05.490] - result already collected: FutureResult
[18:02:05.490] result() for ClusterFuture ... done
[18:02:05.490] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:05.491] Future #1
[18:02:05.491] result() for ClusterFuture ...
[18:02:05.491] - result already collected: FutureResult
[18:02:05.492] result() for ClusterFuture ... done
[18:02:05.492] result() for ClusterFuture ...
[18:02:05.492] - result already collected: FutureResult
[18:02:05.492] result() for ClusterFuture ... done
[18:02:05.493] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:05.493] - nx: 2
[18:02:05.493] - relay: TRUE
[18:02:05.494] - stdout: TRUE
[18:02:05.494] - signal: TRUE
[18:02:05.494] - resignal: FALSE
[18:02:05.495] - force: TRUE
[18:02:05.495] - relayed: [n=2] FALSE, FALSE
[18:02:05.495] - queued futures: [n=2] FALSE, FALSE
[18:02:05.495]  - until=1
[18:02:05.496]  - relaying element #1
[18:02:05.496] result() for ClusterFuture ...
[18:02:05.496] - result already collected: FutureResult
[18:02:05.497] result() for ClusterFuture ... done
[18:02:05.497] result() for ClusterFuture ...
[18:02:05.497] - result already collected: FutureResult
[18:02:05.498] result() for ClusterFuture ... done
[18:02:05.498] result() for ClusterFuture ...
[18:02:05.498] - result already collected: FutureResult
[18:02:05.499] result() for ClusterFuture ... done
[18:02:05.499] result() for ClusterFuture ...
[18:02:05.499] - result already collected: FutureResult
[18:02:05.499] result() for ClusterFuture ... done
[18:02:05.500] - relayed: [n=2] TRUE, FALSE
[18:02:05.500] - queued futures: [n=2] TRUE, FALSE
[18:02:05.500] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:05.501]  length: 1 (resolved future 1)
[18:02:05.512] receiveMessageFromWorker() for ClusterFuture ...
[18:02:05.512] - Validating connection of MultisessionFuture
[18:02:05.513] - received message: FutureResult
[18:02:05.513] - Received FutureResult
[18:02:05.514] - Erased future from FutureRegistry
[18:02:05.514] result() for ClusterFuture ...
[18:02:05.514] - result already collected: FutureResult
[18:02:05.515] result() for ClusterFuture ... done
[18:02:05.515] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:05.515] Future #2
[18:02:05.516] result() for ClusterFuture ...
[18:02:05.516] - result already collected: FutureResult
[18:02:05.516] result() for ClusterFuture ... done
[18:02:05.521] result() for ClusterFuture ...
[18:02:05.521] - result already collected: FutureResult
[18:02:05.521] result() for ClusterFuture ... done
[18:02:05.522] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:05.522] - nx: 2
[18:02:05.522] - relay: TRUE
[18:02:05.523] - stdout: TRUE
[18:02:05.523] - signal: TRUE
[18:02:05.523] - resignal: FALSE
[18:02:05.523] - force: TRUE
[18:02:05.524] - relayed: [n=2] TRUE, FALSE
[18:02:05.524] - queued futures: [n=2] TRUE, FALSE
[18:02:05.524]  - until=2
[18:02:05.525]  - relaying element #2
[18:02:05.525] result() for ClusterFuture ...
[18:02:05.525] - result already collected: FutureResult
[18:02:05.526] result() for ClusterFuture ... done
[18:02:05.526] result() for ClusterFuture ...
[18:02:05.526] - result already collected: FutureResult
[18:02:05.526] result() for ClusterFuture ... done
[18:02:05.527] result() for ClusterFuture ...
[18:02:05.527] - result already collected: FutureResult
[18:02:05.528] result() for ClusterFuture ... done
[18:02:05.528] result() for ClusterFuture ...
[18:02:05.528] - result already collected: FutureResult
[18:02:05.528] result() for ClusterFuture ... done
[18:02:05.529] - relayed: [n=2] TRUE, TRUE
[18:02:05.529] - queued futures: [n=2] TRUE, TRUE
[18:02:05.529] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:05.530]  length: 0 (resolved future 2)
[18:02:05.530] Relaying remaining futures
[18:02:05.530] signalConditionsASAP(NULL, pos=0) ...
[18:02:05.531] - nx: 2
[18:02:05.531] - relay: TRUE
[18:02:05.531] - stdout: TRUE
[18:02:05.531] - signal: TRUE
[18:02:05.532] - resignal: FALSE
[18:02:05.532] - force: TRUE
[18:02:05.532] - relayed: [n=2] TRUE, TRUE
[18:02:05.532] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:05.533] - relayed: [n=2] TRUE, TRUE
[18:02:05.533] - queued futures: [n=2] TRUE, TRUE
[18:02:05.534] signalConditionsASAP(NULL, pos=0) ... done
[18:02:05.534] resolve() on list ... DONE
[18:02:05.534] result() for ClusterFuture ...
[18:02:05.534] - result already collected: FutureResult
[18:02:05.535] result() for ClusterFuture ... done
[18:02:05.535] result() for ClusterFuture ...
[18:02:05.535] - result already collected: FutureResult
[18:02:05.536] result() for ClusterFuture ... done
[18:02:05.536] result() for ClusterFuture ...
[18:02:05.536] - result already collected: FutureResult
[18:02:05.537] result() for ClusterFuture ... done
[18:02:05.537] result() for ClusterFuture ...
[18:02:05.537] - result already collected: FutureResult
[18:02:05.537] result() for ClusterFuture ... done
[18:02:05.538]  - Number of value chunks collected: 2
[18:02:05.538] Resolving 2 futures (chunks) ... DONE
[18:02:05.538] Reducing values from 2 chunks ...
[18:02:05.539]  - Number of values collected after concatenation: 10
[18:02:05.539]  - Number of values expected: 10
[18:02:05.539] Reducing values from 2 chunks ... DONE
[18:02:05.540] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[18:02:05.542] future_lapply() ...
[18:02:05.555] Number of chunks: 2
[18:02:05.555] getGlobalsAndPackagesXApply() ...
[18:02:05.555]  - future.globals: TRUE
[18:02:05.556] getGlobalsAndPackages() ...
[18:02:05.556] Searching for globals...
[18:02:05.566] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[18:02:05.566] Searching for globals ... DONE
[18:02:05.567] Resolving globals: FALSE
[18:02:05.569] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[18:02:05.570] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:05.571] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:05.571] - packages: [1] ‘future.apply’
[18:02:05.571] getGlobalsAndPackages() ... DONE
[18:02:05.571]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:05.572]  - needed namespaces: [n=1] ‘future.apply’
[18:02:05.572] Finding globals ... DONE
[18:02:05.572]  - use_args: TRUE
[18:02:05.573]  - Getting '...' globals ...
[18:02:05.573] resolve() on list ...
[18:02:05.574]  recursive: 0
[18:02:05.574]  length: 1
[18:02:05.574]  elements: ‘...’
[18:02:05.575]  length: 0 (resolved future 1)
[18:02:05.575] resolve() on list ... DONE
[18:02:05.575]    - '...' content: [n=0] 
[18:02:05.575] List of 1
[18:02:05.575]  $ ...: list()
[18:02:05.575]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:05.575]  - attr(*, "where")=List of 1
[18:02:05.575]   ..$ ...:<environment: 0x6183c0cafe68> 
[18:02:05.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:05.575]  - attr(*, "resolved")= logi TRUE
[18:02:05.575]  - attr(*, "total_size")= num NA
[18:02:05.582]  - Getting '...' globals ... DONE
[18:02:05.582] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:05.582] List of 8
[18:02:05.582]  $ ...future.FUN:function (x, ...)  
[18:02:05.582]  $ x_FUN        :function (x)  
[18:02:05.582]  $ times        : int 4
[18:02:05.582]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:05.582]  $ stop_if_not  :function (...)  
[18:02:05.582]  $ dim          : int [1:2] 2 2
[18:02:05.582]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:02:05.582]  $ ...          : list()
[18:02:05.582]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:05.582]  - attr(*, "where")=List of 8
[18:02:05.582]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:05.582]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:05.582]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:05.582]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:05.582]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:05.582]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:05.582]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:05.582]   ..$ ...          :<environment: 0x6183c0cafe68> 
[18:02:05.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:05.582]  - attr(*, "resolved")= logi FALSE
[18:02:05.582]  - attr(*, "total_size")= num 97304
[18:02:05.595] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:05.596] getGlobalsAndPackagesXApply() ... DONE
[18:02:05.596] Number of futures (= number of chunks): 2
[18:02:05.596] Launching 2 futures (chunks) ...
[18:02:05.596] Chunk #1 of 2 ...
[18:02:05.597]  - Finding globals in 'X' for chunk #1 ...
[18:02:05.597] getGlobalsAndPackages() ...
[18:02:05.597] Searching for globals...
[18:02:05.598] 
[18:02:05.598] Searching for globals ... DONE
[18:02:05.598] - globals: [0] <none>
[18:02:05.598] getGlobalsAndPackages() ... DONE
[18:02:05.599]    + additional globals found: [n=0] 
[18:02:05.599]    + additional namespaces needed: [n=0] 
[18:02:05.599]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:05.599]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:05.600]  - seeds: <none>
[18:02:05.600]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:05.600] getGlobalsAndPackages() ...
[18:02:05.600] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:05.601] Resolving globals: FALSE
[18:02:05.601] Tweak future expression to call with '...' arguments ...
[18:02:05.601] {
[18:02:05.601]     do.call(function(...) {
[18:02:05.601]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:05.601]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:05.601]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:05.601]             on.exit(options(oopts), add = TRUE)
[18:02:05.601]         }
[18:02:05.601]         {
[18:02:05.601]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:05.601]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:05.601]                 ...future.FUN(...future.X_jj, ...)
[18:02:05.601]             })
[18:02:05.601]         }
[18:02:05.601]     }, args = future.call.arguments)
[18:02:05.601] }
[18:02:05.602] Tweak future expression to call with '...' arguments ... DONE
[18:02:05.603] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:05.603] - packages: [1] ‘future.apply’
[18:02:05.603] getGlobalsAndPackages() ... DONE
[18:02:05.604] run() for ‘Future’ ...
[18:02:05.604] - state: ‘created’
[18:02:05.605] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:05.629] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:05.630] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:05.630]   - Field: ‘node’
[18:02:05.630]   - Field: ‘label’
[18:02:05.630]   - Field: ‘local’
[18:02:05.631]   - Field: ‘owner’
[18:02:05.631]   - Field: ‘envir’
[18:02:05.631]   - Field: ‘workers’
[18:02:05.631]   - Field: ‘packages’
[18:02:05.631]   - Field: ‘gc’
[18:02:05.632]   - Field: ‘conditions’
[18:02:05.632]   - Field: ‘persistent’
[18:02:05.632]   - Field: ‘expr’
[18:02:05.632]   - Field: ‘uuid’
[18:02:05.632]   - Field: ‘seed’
[18:02:05.633]   - Field: ‘version’
[18:02:05.633]   - Field: ‘result’
[18:02:05.633]   - Field: ‘asynchronous’
[18:02:05.633]   - Field: ‘calls’
[18:02:05.633]   - Field: ‘globals’
[18:02:05.634]   - Field: ‘stdout’
[18:02:05.634]   - Field: ‘earlySignal’
[18:02:05.634]   - Field: ‘lazy’
[18:02:05.634]   - Field: ‘state’
[18:02:05.634] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:05.635] - Launch lazy future ...
[18:02:05.635] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:05.635] Packages needed by future strategies (n = 0): <none>
[18:02:05.636] {
[18:02:05.636]     {
[18:02:05.636]         {
[18:02:05.636]             ...future.startTime <- base::Sys.time()
[18:02:05.636]             {
[18:02:05.636]                 {
[18:02:05.636]                   {
[18:02:05.636]                     {
[18:02:05.636]                       {
[18:02:05.636]                         base::local({
[18:02:05.636]                           has_future <- base::requireNamespace("future", 
[18:02:05.636]                             quietly = TRUE)
[18:02:05.636]                           if (has_future) {
[18:02:05.636]                             ns <- base::getNamespace("future")
[18:02:05.636]                             version <- ns[[".package"]][["version"]]
[18:02:05.636]                             if (is.null(version)) 
[18:02:05.636]                               version <- utils::packageVersion("future")
[18:02:05.636]                           }
[18:02:05.636]                           else {
[18:02:05.636]                             version <- NULL
[18:02:05.636]                           }
[18:02:05.636]                           if (!has_future || version < "1.8.0") {
[18:02:05.636]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:05.636]                               "", base::R.version$version.string), 
[18:02:05.636]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:05.636]                                 base::R.version$platform, 8 * 
[18:02:05.636]                                   base::.Machine$sizeof.pointer), 
[18:02:05.636]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:05.636]                                 "release", "version")], collapse = " "), 
[18:02:05.636]                               hostname = base::Sys.info()[["nodename"]])
[18:02:05.636]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:05.636]                               info)
[18:02:05.636]                             info <- base::paste(info, collapse = "; ")
[18:02:05.636]                             if (!has_future) {
[18:02:05.636]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:05.636]                                 info)
[18:02:05.636]                             }
[18:02:05.636]                             else {
[18:02:05.636]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:05.636]                                 info, version)
[18:02:05.636]                             }
[18:02:05.636]                             base::stop(msg)
[18:02:05.636]                           }
[18:02:05.636]                         })
[18:02:05.636]                       }
[18:02:05.636]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:05.636]                       base::options(mc.cores = 1L)
[18:02:05.636]                     }
[18:02:05.636]                     base::local({
[18:02:05.636]                       for (pkg in "future.apply") {
[18:02:05.636]                         base::loadNamespace(pkg)
[18:02:05.636]                         base::library(pkg, character.only = TRUE)
[18:02:05.636]                       }
[18:02:05.636]                     })
[18:02:05.636]                   }
[18:02:05.636]                   ...future.strategy.old <- future::plan("list")
[18:02:05.636]                   options(future.plan = NULL)
[18:02:05.636]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:05.636]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:05.636]                 }
[18:02:05.636]                 ...future.workdir <- getwd()
[18:02:05.636]             }
[18:02:05.636]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:05.636]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:05.636]         }
[18:02:05.636]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:05.636]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:05.636]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:05.636]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:05.636]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:05.636]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:05.636]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:05.636]             base::names(...future.oldOptions))
[18:02:05.636]     }
[18:02:05.636]     if (FALSE) {
[18:02:05.636]     }
[18:02:05.636]     else {
[18:02:05.636]         if (TRUE) {
[18:02:05.636]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:05.636]                 open = "w")
[18:02:05.636]         }
[18:02:05.636]         else {
[18:02:05.636]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:05.636]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:05.636]         }
[18:02:05.636]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:05.636]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:05.636]             base::sink(type = "output", split = FALSE)
[18:02:05.636]             base::close(...future.stdout)
[18:02:05.636]         }, add = TRUE)
[18:02:05.636]     }
[18:02:05.636]     ...future.frame <- base::sys.nframe()
[18:02:05.636]     ...future.conditions <- base::list()
[18:02:05.636]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:05.636]     if (FALSE) {
[18:02:05.636]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:05.636]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:05.636]     }
[18:02:05.636]     ...future.result <- base::tryCatch({
[18:02:05.636]         base::withCallingHandlers({
[18:02:05.636]             ...future.value <- base::withVisible(base::local({
[18:02:05.636]                 ...future.makeSendCondition <- base::local({
[18:02:05.636]                   sendCondition <- NULL
[18:02:05.636]                   function(frame = 1L) {
[18:02:05.636]                     if (is.function(sendCondition)) 
[18:02:05.636]                       return(sendCondition)
[18:02:05.636]                     ns <- getNamespace("parallel")
[18:02:05.636]                     if (exists("sendData", mode = "function", 
[18:02:05.636]                       envir = ns)) {
[18:02:05.636]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:05.636]                         envir = ns)
[18:02:05.636]                       envir <- sys.frame(frame)
[18:02:05.636]                       master <- NULL
[18:02:05.636]                       while (!identical(envir, .GlobalEnv) && 
[18:02:05.636]                         !identical(envir, emptyenv())) {
[18:02:05.636]                         if (exists("master", mode = "list", envir = envir, 
[18:02:05.636]                           inherits = FALSE)) {
[18:02:05.636]                           master <- get("master", mode = "list", 
[18:02:05.636]                             envir = envir, inherits = FALSE)
[18:02:05.636]                           if (inherits(master, c("SOCKnode", 
[18:02:05.636]                             "SOCK0node"))) {
[18:02:05.636]                             sendCondition <<- function(cond) {
[18:02:05.636]                               data <- list(type = "VALUE", value = cond, 
[18:02:05.636]                                 success = TRUE)
[18:02:05.636]                               parallel_sendData(master, data)
[18:02:05.636]                             }
[18:02:05.636]                             return(sendCondition)
[18:02:05.636]                           }
[18:02:05.636]                         }
[18:02:05.636]                         frame <- frame + 1L
[18:02:05.636]                         envir <- sys.frame(frame)
[18:02:05.636]                       }
[18:02:05.636]                     }
[18:02:05.636]                     sendCondition <<- function(cond) NULL
[18:02:05.636]                   }
[18:02:05.636]                 })
[18:02:05.636]                 withCallingHandlers({
[18:02:05.636]                   {
[18:02:05.636]                     do.call(function(...) {
[18:02:05.636]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:05.636]                       if (!identical(...future.globals.maxSize.org, 
[18:02:05.636]                         ...future.globals.maxSize)) {
[18:02:05.636]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:05.636]                         on.exit(options(oopts), add = TRUE)
[18:02:05.636]                       }
[18:02:05.636]                       {
[18:02:05.636]                         lapply(seq_along(...future.elements_ii), 
[18:02:05.636]                           FUN = function(jj) {
[18:02:05.636]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:05.636]                             ...future.FUN(...future.X_jj, ...)
[18:02:05.636]                           })
[18:02:05.636]                       }
[18:02:05.636]                     }, args = future.call.arguments)
[18:02:05.636]                   }
[18:02:05.636]                 }, immediateCondition = function(cond) {
[18:02:05.636]                   sendCondition <- ...future.makeSendCondition()
[18:02:05.636]                   sendCondition(cond)
[18:02:05.636]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:05.636]                   {
[18:02:05.636]                     inherits <- base::inherits
[18:02:05.636]                     invokeRestart <- base::invokeRestart
[18:02:05.636]                     is.null <- base::is.null
[18:02:05.636]                     muffled <- FALSE
[18:02:05.636]                     if (inherits(cond, "message")) {
[18:02:05.636]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:05.636]                       if (muffled) 
[18:02:05.636]                         invokeRestart("muffleMessage")
[18:02:05.636]                     }
[18:02:05.636]                     else if (inherits(cond, "warning")) {
[18:02:05.636]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:05.636]                       if (muffled) 
[18:02:05.636]                         invokeRestart("muffleWarning")
[18:02:05.636]                     }
[18:02:05.636]                     else if (inherits(cond, "condition")) {
[18:02:05.636]                       if (!is.null(pattern)) {
[18:02:05.636]                         computeRestarts <- base::computeRestarts
[18:02:05.636]                         grepl <- base::grepl
[18:02:05.636]                         restarts <- computeRestarts(cond)
[18:02:05.636]                         for (restart in restarts) {
[18:02:05.636]                           name <- restart$name
[18:02:05.636]                           if (is.null(name)) 
[18:02:05.636]                             next
[18:02:05.636]                           if (!grepl(pattern, name)) 
[18:02:05.636]                             next
[18:02:05.636]                           invokeRestart(restart)
[18:02:05.636]                           muffled <- TRUE
[18:02:05.636]                           break
[18:02:05.636]                         }
[18:02:05.636]                       }
[18:02:05.636]                     }
[18:02:05.636]                     invisible(muffled)
[18:02:05.636]                   }
[18:02:05.636]                   muffleCondition(cond)
[18:02:05.636]                 })
[18:02:05.636]             }))
[18:02:05.636]             future::FutureResult(value = ...future.value$value, 
[18:02:05.636]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:05.636]                   ...future.rng), globalenv = if (FALSE) 
[18:02:05.636]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:05.636]                     ...future.globalenv.names))
[18:02:05.636]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:05.636]         }, condition = base::local({
[18:02:05.636]             c <- base::c
[18:02:05.636]             inherits <- base::inherits
[18:02:05.636]             invokeRestart <- base::invokeRestart
[18:02:05.636]             length <- base::length
[18:02:05.636]             list <- base::list
[18:02:05.636]             seq.int <- base::seq.int
[18:02:05.636]             signalCondition <- base::signalCondition
[18:02:05.636]             sys.calls <- base::sys.calls
[18:02:05.636]             `[[` <- base::`[[`
[18:02:05.636]             `+` <- base::`+`
[18:02:05.636]             `<<-` <- base::`<<-`
[18:02:05.636]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:05.636]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:05.636]                   3L)]
[18:02:05.636]             }
[18:02:05.636]             function(cond) {
[18:02:05.636]                 is_error <- inherits(cond, "error")
[18:02:05.636]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:05.636]                   NULL)
[18:02:05.636]                 if (is_error) {
[18:02:05.636]                   sessionInformation <- function() {
[18:02:05.636]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:05.636]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:05.636]                       search = base::search(), system = base::Sys.info())
[18:02:05.636]                   }
[18:02:05.636]                   ...future.conditions[[length(...future.conditions) + 
[18:02:05.636]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:05.636]                     cond$call), session = sessionInformation(), 
[18:02:05.636]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:05.636]                   signalCondition(cond)
[18:02:05.636]                 }
[18:02:05.636]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:05.636]                 "immediateCondition"))) {
[18:02:05.636]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:05.636]                   ...future.conditions[[length(...future.conditions) + 
[18:02:05.636]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:05.636]                   if (TRUE && !signal) {
[18:02:05.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:05.636]                     {
[18:02:05.636]                       inherits <- base::inherits
[18:02:05.636]                       invokeRestart <- base::invokeRestart
[18:02:05.636]                       is.null <- base::is.null
[18:02:05.636]                       muffled <- FALSE
[18:02:05.636]                       if (inherits(cond, "message")) {
[18:02:05.636]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:05.636]                         if (muffled) 
[18:02:05.636]                           invokeRestart("muffleMessage")
[18:02:05.636]                       }
[18:02:05.636]                       else if (inherits(cond, "warning")) {
[18:02:05.636]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:05.636]                         if (muffled) 
[18:02:05.636]                           invokeRestart("muffleWarning")
[18:02:05.636]                       }
[18:02:05.636]                       else if (inherits(cond, "condition")) {
[18:02:05.636]                         if (!is.null(pattern)) {
[18:02:05.636]                           computeRestarts <- base::computeRestarts
[18:02:05.636]                           grepl <- base::grepl
[18:02:05.636]                           restarts <- computeRestarts(cond)
[18:02:05.636]                           for (restart in restarts) {
[18:02:05.636]                             name <- restart$name
[18:02:05.636]                             if (is.null(name)) 
[18:02:05.636]                               next
[18:02:05.636]                             if (!grepl(pattern, name)) 
[18:02:05.636]                               next
[18:02:05.636]                             invokeRestart(restart)
[18:02:05.636]                             muffled <- TRUE
[18:02:05.636]                             break
[18:02:05.636]                           }
[18:02:05.636]                         }
[18:02:05.636]                       }
[18:02:05.636]                       invisible(muffled)
[18:02:05.636]                     }
[18:02:05.636]                     muffleCondition(cond, pattern = "^muffle")
[18:02:05.636]                   }
[18:02:05.636]                 }
[18:02:05.636]                 else {
[18:02:05.636]                   if (TRUE) {
[18:02:05.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:05.636]                     {
[18:02:05.636]                       inherits <- base::inherits
[18:02:05.636]                       invokeRestart <- base::invokeRestart
[18:02:05.636]                       is.null <- base::is.null
[18:02:05.636]                       muffled <- FALSE
[18:02:05.636]                       if (inherits(cond, "message")) {
[18:02:05.636]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:05.636]                         if (muffled) 
[18:02:05.636]                           invokeRestart("muffleMessage")
[18:02:05.636]                       }
[18:02:05.636]                       else if (inherits(cond, "warning")) {
[18:02:05.636]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:05.636]                         if (muffled) 
[18:02:05.636]                           invokeRestart("muffleWarning")
[18:02:05.636]                       }
[18:02:05.636]                       else if (inherits(cond, "condition")) {
[18:02:05.636]                         if (!is.null(pattern)) {
[18:02:05.636]                           computeRestarts <- base::computeRestarts
[18:02:05.636]                           grepl <- base::grepl
[18:02:05.636]                           restarts <- computeRestarts(cond)
[18:02:05.636]                           for (restart in restarts) {
[18:02:05.636]                             name <- restart$name
[18:02:05.636]                             if (is.null(name)) 
[18:02:05.636]                               next
[18:02:05.636]                             if (!grepl(pattern, name)) 
[18:02:05.636]                               next
[18:02:05.636]                             invokeRestart(restart)
[18:02:05.636]                             muffled <- TRUE
[18:02:05.636]                             break
[18:02:05.636]                           }
[18:02:05.636]                         }
[18:02:05.636]                       }
[18:02:05.636]                       invisible(muffled)
[18:02:05.636]                     }
[18:02:05.636]                     muffleCondition(cond, pattern = "^muffle")
[18:02:05.636]                   }
[18:02:05.636]                 }
[18:02:05.636]             }
[18:02:05.636]         }))
[18:02:05.636]     }, error = function(ex) {
[18:02:05.636]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:05.636]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:05.636]                 ...future.rng), started = ...future.startTime, 
[18:02:05.636]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:05.636]             version = "1.8"), class = "FutureResult")
[18:02:05.636]     }, finally = {
[18:02:05.636]         if (!identical(...future.workdir, getwd())) 
[18:02:05.636]             setwd(...future.workdir)
[18:02:05.636]         {
[18:02:05.636]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:05.636]                 ...future.oldOptions$nwarnings <- NULL
[18:02:05.636]             }
[18:02:05.636]             base::options(...future.oldOptions)
[18:02:05.636]             if (.Platform$OS.type == "windows") {
[18:02:05.636]                 old_names <- names(...future.oldEnvVars)
[18:02:05.636]                 envs <- base::Sys.getenv()
[18:02:05.636]                 names <- names(envs)
[18:02:05.636]                 common <- intersect(names, old_names)
[18:02:05.636]                 added <- setdiff(names, old_names)
[18:02:05.636]                 removed <- setdiff(old_names, names)
[18:02:05.636]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:05.636]                   envs[common]]
[18:02:05.636]                 NAMES <- toupper(changed)
[18:02:05.636]                 args <- list()
[18:02:05.636]                 for (kk in seq_along(NAMES)) {
[18:02:05.636]                   name <- changed[[kk]]
[18:02:05.636]                   NAME <- NAMES[[kk]]
[18:02:05.636]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:05.636]                     next
[18:02:05.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:05.636]                 }
[18:02:05.636]                 NAMES <- toupper(added)
[18:02:05.636]                 for (kk in seq_along(NAMES)) {
[18:02:05.636]                   name <- added[[kk]]
[18:02:05.636]                   NAME <- NAMES[[kk]]
[18:02:05.636]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:05.636]                     next
[18:02:05.636]                   args[[name]] <- ""
[18:02:05.636]                 }
[18:02:05.636]                 NAMES <- toupper(removed)
[18:02:05.636]                 for (kk in seq_along(NAMES)) {
[18:02:05.636]                   name <- removed[[kk]]
[18:02:05.636]                   NAME <- NAMES[[kk]]
[18:02:05.636]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:05.636]                     next
[18:02:05.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:05.636]                 }
[18:02:05.636]                 if (length(args) > 0) 
[18:02:05.636]                   base::do.call(base::Sys.setenv, args = args)
[18:02:05.636]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:05.636]             }
[18:02:05.636]             else {
[18:02:05.636]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:05.636]             }
[18:02:05.636]             {
[18:02:05.636]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:05.636]                   0L) {
[18:02:05.636]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:05.636]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:05.636]                   base::options(opts)
[18:02:05.636]                 }
[18:02:05.636]                 {
[18:02:05.636]                   {
[18:02:05.636]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:05.636]                     NULL
[18:02:05.636]                   }
[18:02:05.636]                   options(future.plan = NULL)
[18:02:05.636]                   if (is.na(NA_character_)) 
[18:02:05.636]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:05.636]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:05.636]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:05.636]                     .init = FALSE)
[18:02:05.636]                 }
[18:02:05.636]             }
[18:02:05.636]         }
[18:02:05.636]     })
[18:02:05.636]     if (TRUE) {
[18:02:05.636]         base::sink(type = "output", split = FALSE)
[18:02:05.636]         if (TRUE) {
[18:02:05.636]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:05.636]         }
[18:02:05.636]         else {
[18:02:05.636]             ...future.result["stdout"] <- base::list(NULL)
[18:02:05.636]         }
[18:02:05.636]         base::close(...future.stdout)
[18:02:05.636]         ...future.stdout <- NULL
[18:02:05.636]     }
[18:02:05.636]     ...future.result$conditions <- ...future.conditions
[18:02:05.636]     ...future.result$finished <- base::Sys.time()
[18:02:05.636]     ...future.result
[18:02:05.636] }
[18:02:05.642] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[18:02:05.642] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[18:02:05.683] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[18:02:05.684] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[18:02:05.685] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[18:02:05.685] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[18:02:05.686] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[18:02:05.687] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[18:02:05.728] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[18:02:05.729] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[18:02:05.770] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[18:02:05.771] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[18:02:05.772] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[18:02:05.773] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[18:02:05.774] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[18:02:05.774] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:05.775] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:05.776] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[18:02:05.777] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[18:02:05.778] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:05.779] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:05.779] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:05.780] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:05.781] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[18:02:05.782] MultisessionFuture started
[18:02:05.783] - Launch lazy future ... done
[18:02:05.783] run() for ‘MultisessionFuture’ ... done
[18:02:05.783] Created future:
[18:02:05.784] MultisessionFuture:
[18:02:05.784] Label: ‘future_vapply-1’
[18:02:05.784] Expression:
[18:02:05.784] {
[18:02:05.784]     do.call(function(...) {
[18:02:05.784]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:05.784]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:05.784]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:05.784]             on.exit(options(oopts), add = TRUE)
[18:02:05.784]         }
[18:02:05.784]         {
[18:02:05.784]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:05.784]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:05.784]                 ...future.FUN(...future.X_jj, ...)
[18:02:05.784]             })
[18:02:05.784]         }
[18:02:05.784]     }, args = future.call.arguments)
[18:02:05.784] }
[18:02:05.784] Lazy evaluation: FALSE
[18:02:05.784] Asynchronous evaluation: TRUE
[18:02:05.784] Local evaluation: TRUE
[18:02:05.784] Environment: R_GlobalEnv
[18:02:05.784] Capture standard output: TRUE
[18:02:05.784] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:05.784] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:05.784] Packages: 1 packages (‘future.apply’)
[18:02:05.784] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:05.784] Resolved: FALSE
[18:02:05.784] Value: <not collected>
[18:02:05.784] Conditions captured: <none>
[18:02:05.784] Early signaling: FALSE
[18:02:05.784] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:05.784] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:05.799] Chunk #1 of 2 ... DONE
[18:02:05.799] Chunk #2 of 2 ...
[18:02:05.799]  - Finding globals in 'X' for chunk #2 ...
[18:02:05.800] getGlobalsAndPackages() ...
[18:02:05.800] Searching for globals...
[18:02:05.801] 
[18:02:05.801] Searching for globals ... DONE
[18:02:05.801] - globals: [0] <none>
[18:02:05.802] getGlobalsAndPackages() ... DONE
[18:02:05.802]    + additional globals found: [n=0] 
[18:02:05.802]    + additional namespaces needed: [n=0] 
[18:02:05.803]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:05.803]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:05.803]  - seeds: <none>
[18:02:05.804]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:05.804] getGlobalsAndPackages() ...
[18:02:05.804] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:05.805] Resolving globals: FALSE
[18:02:05.805] Tweak future expression to call with '...' arguments ...
[18:02:05.805] {
[18:02:05.805]     do.call(function(...) {
[18:02:05.805]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:05.805]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:05.805]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:05.805]             on.exit(options(oopts), add = TRUE)
[18:02:05.805]         }
[18:02:05.805]         {
[18:02:05.805]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:05.805]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:05.805]                 ...future.FUN(...future.X_jj, ...)
[18:02:05.805]             })
[18:02:05.805]         }
[18:02:05.805]     }, args = future.call.arguments)
[18:02:05.805] }
[18:02:05.806] Tweak future expression to call with '...' arguments ... DONE
[18:02:05.808] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:05.808] - packages: [1] ‘future.apply’
[18:02:05.809] getGlobalsAndPackages() ... DONE
[18:02:05.810] run() for ‘Future’ ...
[18:02:05.810] - state: ‘created’
[18:02:05.810] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:05.848] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:05.848] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:05.848]   - Field: ‘node’
[18:02:05.849]   - Field: ‘label’
[18:02:05.849]   - Field: ‘local’
[18:02:05.849]   - Field: ‘owner’
[18:02:05.850]   - Field: ‘envir’
[18:02:05.850]   - Field: ‘workers’
[18:02:05.850]   - Field: ‘packages’
[18:02:05.850]   - Field: ‘gc’
[18:02:05.851]   - Field: ‘conditions’
[18:02:05.851]   - Field: ‘persistent’
[18:02:05.851]   - Field: ‘expr’
[18:02:05.852]   - Field: ‘uuid’
[18:02:05.852]   - Field: ‘seed’
[18:02:05.852]   - Field: ‘version’
[18:02:05.852]   - Field: ‘result’
[18:02:05.853]   - Field: ‘asynchronous’
[18:02:05.853]   - Field: ‘calls’
[18:02:05.853]   - Field: ‘globals’
[18:02:05.853]   - Field: ‘stdout’
[18:02:05.854]   - Field: ‘earlySignal’
[18:02:05.854]   - Field: ‘lazy’
[18:02:05.854]   - Field: ‘state’
[18:02:05.855] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:05.855] - Launch lazy future ...
[18:02:05.856] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:05.856] Packages needed by future strategies (n = 0): <none>
[18:02:05.857] {
[18:02:05.857]     {
[18:02:05.857]         {
[18:02:05.857]             ...future.startTime <- base::Sys.time()
[18:02:05.857]             {
[18:02:05.857]                 {
[18:02:05.857]                   {
[18:02:05.857]                     {
[18:02:05.857]                       {
[18:02:05.857]                         base::local({
[18:02:05.857]                           has_future <- base::requireNamespace("future", 
[18:02:05.857]                             quietly = TRUE)
[18:02:05.857]                           if (has_future) {
[18:02:05.857]                             ns <- base::getNamespace("future")
[18:02:05.857]                             version <- ns[[".package"]][["version"]]
[18:02:05.857]                             if (is.null(version)) 
[18:02:05.857]                               version <- utils::packageVersion("future")
[18:02:05.857]                           }
[18:02:05.857]                           else {
[18:02:05.857]                             version <- NULL
[18:02:05.857]                           }
[18:02:05.857]                           if (!has_future || version < "1.8.0") {
[18:02:05.857]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:05.857]                               "", base::R.version$version.string), 
[18:02:05.857]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:05.857]                                 base::R.version$platform, 8 * 
[18:02:05.857]                                   base::.Machine$sizeof.pointer), 
[18:02:05.857]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:05.857]                                 "release", "version")], collapse = " "), 
[18:02:05.857]                               hostname = base::Sys.info()[["nodename"]])
[18:02:05.857]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:05.857]                               info)
[18:02:05.857]                             info <- base::paste(info, collapse = "; ")
[18:02:05.857]                             if (!has_future) {
[18:02:05.857]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:05.857]                                 info)
[18:02:05.857]                             }
[18:02:05.857]                             else {
[18:02:05.857]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:05.857]                                 info, version)
[18:02:05.857]                             }
[18:02:05.857]                             base::stop(msg)
[18:02:05.857]                           }
[18:02:05.857]                         })
[18:02:05.857]                       }
[18:02:05.857]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:05.857]                       base::options(mc.cores = 1L)
[18:02:05.857]                     }
[18:02:05.857]                     base::local({
[18:02:05.857]                       for (pkg in "future.apply") {
[18:02:05.857]                         base::loadNamespace(pkg)
[18:02:05.857]                         base::library(pkg, character.only = TRUE)
[18:02:05.857]                       }
[18:02:05.857]                     })
[18:02:05.857]                   }
[18:02:05.857]                   ...future.strategy.old <- future::plan("list")
[18:02:05.857]                   options(future.plan = NULL)
[18:02:05.857]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:05.857]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:05.857]                 }
[18:02:05.857]                 ...future.workdir <- getwd()
[18:02:05.857]             }
[18:02:05.857]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:05.857]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:05.857]         }
[18:02:05.857]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:05.857]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:05.857]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:05.857]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:05.857]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:05.857]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:05.857]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:05.857]             base::names(...future.oldOptions))
[18:02:05.857]     }
[18:02:05.857]     if (FALSE) {
[18:02:05.857]     }
[18:02:05.857]     else {
[18:02:05.857]         if (TRUE) {
[18:02:05.857]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:05.857]                 open = "w")
[18:02:05.857]         }
[18:02:05.857]         else {
[18:02:05.857]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:05.857]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:05.857]         }
[18:02:05.857]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:05.857]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:05.857]             base::sink(type = "output", split = FALSE)
[18:02:05.857]             base::close(...future.stdout)
[18:02:05.857]         }, add = TRUE)
[18:02:05.857]     }
[18:02:05.857]     ...future.frame <- base::sys.nframe()
[18:02:05.857]     ...future.conditions <- base::list()
[18:02:05.857]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:05.857]     if (FALSE) {
[18:02:05.857]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:05.857]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:05.857]     }
[18:02:05.857]     ...future.result <- base::tryCatch({
[18:02:05.857]         base::withCallingHandlers({
[18:02:05.857]             ...future.value <- base::withVisible(base::local({
[18:02:05.857]                 ...future.makeSendCondition <- base::local({
[18:02:05.857]                   sendCondition <- NULL
[18:02:05.857]                   function(frame = 1L) {
[18:02:05.857]                     if (is.function(sendCondition)) 
[18:02:05.857]                       return(sendCondition)
[18:02:05.857]                     ns <- getNamespace("parallel")
[18:02:05.857]                     if (exists("sendData", mode = "function", 
[18:02:05.857]                       envir = ns)) {
[18:02:05.857]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:05.857]                         envir = ns)
[18:02:05.857]                       envir <- sys.frame(frame)
[18:02:05.857]                       master <- NULL
[18:02:05.857]                       while (!identical(envir, .GlobalEnv) && 
[18:02:05.857]                         !identical(envir, emptyenv())) {
[18:02:05.857]                         if (exists("master", mode = "list", envir = envir, 
[18:02:05.857]                           inherits = FALSE)) {
[18:02:05.857]                           master <- get("master", mode = "list", 
[18:02:05.857]                             envir = envir, inherits = FALSE)
[18:02:05.857]                           if (inherits(master, c("SOCKnode", 
[18:02:05.857]                             "SOCK0node"))) {
[18:02:05.857]                             sendCondition <<- function(cond) {
[18:02:05.857]                               data <- list(type = "VALUE", value = cond, 
[18:02:05.857]                                 success = TRUE)
[18:02:05.857]                               parallel_sendData(master, data)
[18:02:05.857]                             }
[18:02:05.857]                             return(sendCondition)
[18:02:05.857]                           }
[18:02:05.857]                         }
[18:02:05.857]                         frame <- frame + 1L
[18:02:05.857]                         envir <- sys.frame(frame)
[18:02:05.857]                       }
[18:02:05.857]                     }
[18:02:05.857]                     sendCondition <<- function(cond) NULL
[18:02:05.857]                   }
[18:02:05.857]                 })
[18:02:05.857]                 withCallingHandlers({
[18:02:05.857]                   {
[18:02:05.857]                     do.call(function(...) {
[18:02:05.857]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:05.857]                       if (!identical(...future.globals.maxSize.org, 
[18:02:05.857]                         ...future.globals.maxSize)) {
[18:02:05.857]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:05.857]                         on.exit(options(oopts), add = TRUE)
[18:02:05.857]                       }
[18:02:05.857]                       {
[18:02:05.857]                         lapply(seq_along(...future.elements_ii), 
[18:02:05.857]                           FUN = function(jj) {
[18:02:05.857]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:05.857]                             ...future.FUN(...future.X_jj, ...)
[18:02:05.857]                           })
[18:02:05.857]                       }
[18:02:05.857]                     }, args = future.call.arguments)
[18:02:05.857]                   }
[18:02:05.857]                 }, immediateCondition = function(cond) {
[18:02:05.857]                   sendCondition <- ...future.makeSendCondition()
[18:02:05.857]                   sendCondition(cond)
[18:02:05.857]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:05.857]                   {
[18:02:05.857]                     inherits <- base::inherits
[18:02:05.857]                     invokeRestart <- base::invokeRestart
[18:02:05.857]                     is.null <- base::is.null
[18:02:05.857]                     muffled <- FALSE
[18:02:05.857]                     if (inherits(cond, "message")) {
[18:02:05.857]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:05.857]                       if (muffled) 
[18:02:05.857]                         invokeRestart("muffleMessage")
[18:02:05.857]                     }
[18:02:05.857]                     else if (inherits(cond, "warning")) {
[18:02:05.857]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:05.857]                       if (muffled) 
[18:02:05.857]                         invokeRestart("muffleWarning")
[18:02:05.857]                     }
[18:02:05.857]                     else if (inherits(cond, "condition")) {
[18:02:05.857]                       if (!is.null(pattern)) {
[18:02:05.857]                         computeRestarts <- base::computeRestarts
[18:02:05.857]                         grepl <- base::grepl
[18:02:05.857]                         restarts <- computeRestarts(cond)
[18:02:05.857]                         for (restart in restarts) {
[18:02:05.857]                           name <- restart$name
[18:02:05.857]                           if (is.null(name)) 
[18:02:05.857]                             next
[18:02:05.857]                           if (!grepl(pattern, name)) 
[18:02:05.857]                             next
[18:02:05.857]                           invokeRestart(restart)
[18:02:05.857]                           muffled <- TRUE
[18:02:05.857]                           break
[18:02:05.857]                         }
[18:02:05.857]                       }
[18:02:05.857]                     }
[18:02:05.857]                     invisible(muffled)
[18:02:05.857]                   }
[18:02:05.857]                   muffleCondition(cond)
[18:02:05.857]                 })
[18:02:05.857]             }))
[18:02:05.857]             future::FutureResult(value = ...future.value$value, 
[18:02:05.857]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:05.857]                   ...future.rng), globalenv = if (FALSE) 
[18:02:05.857]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:05.857]                     ...future.globalenv.names))
[18:02:05.857]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:05.857]         }, condition = base::local({
[18:02:05.857]             c <- base::c
[18:02:05.857]             inherits <- base::inherits
[18:02:05.857]             invokeRestart <- base::invokeRestart
[18:02:05.857]             length <- base::length
[18:02:05.857]             list <- base::list
[18:02:05.857]             seq.int <- base::seq.int
[18:02:05.857]             signalCondition <- base::signalCondition
[18:02:05.857]             sys.calls <- base::sys.calls
[18:02:05.857]             `[[` <- base::`[[`
[18:02:05.857]             `+` <- base::`+`
[18:02:05.857]             `<<-` <- base::`<<-`
[18:02:05.857]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:05.857]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:05.857]                   3L)]
[18:02:05.857]             }
[18:02:05.857]             function(cond) {
[18:02:05.857]                 is_error <- inherits(cond, "error")
[18:02:05.857]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:05.857]                   NULL)
[18:02:05.857]                 if (is_error) {
[18:02:05.857]                   sessionInformation <- function() {
[18:02:05.857]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:05.857]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:05.857]                       search = base::search(), system = base::Sys.info())
[18:02:05.857]                   }
[18:02:05.857]                   ...future.conditions[[length(...future.conditions) + 
[18:02:05.857]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:05.857]                     cond$call), session = sessionInformation(), 
[18:02:05.857]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:05.857]                   signalCondition(cond)
[18:02:05.857]                 }
[18:02:05.857]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:05.857]                 "immediateCondition"))) {
[18:02:05.857]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:05.857]                   ...future.conditions[[length(...future.conditions) + 
[18:02:05.857]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:05.857]                   if (TRUE && !signal) {
[18:02:05.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:05.857]                     {
[18:02:05.857]                       inherits <- base::inherits
[18:02:05.857]                       invokeRestart <- base::invokeRestart
[18:02:05.857]                       is.null <- base::is.null
[18:02:05.857]                       muffled <- FALSE
[18:02:05.857]                       if (inherits(cond, "message")) {
[18:02:05.857]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:05.857]                         if (muffled) 
[18:02:05.857]                           invokeRestart("muffleMessage")
[18:02:05.857]                       }
[18:02:05.857]                       else if (inherits(cond, "warning")) {
[18:02:05.857]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:05.857]                         if (muffled) 
[18:02:05.857]                           invokeRestart("muffleWarning")
[18:02:05.857]                       }
[18:02:05.857]                       else if (inherits(cond, "condition")) {
[18:02:05.857]                         if (!is.null(pattern)) {
[18:02:05.857]                           computeRestarts <- base::computeRestarts
[18:02:05.857]                           grepl <- base::grepl
[18:02:05.857]                           restarts <- computeRestarts(cond)
[18:02:05.857]                           for (restart in restarts) {
[18:02:05.857]                             name <- restart$name
[18:02:05.857]                             if (is.null(name)) 
[18:02:05.857]                               next
[18:02:05.857]                             if (!grepl(pattern, name)) 
[18:02:05.857]                               next
[18:02:05.857]                             invokeRestart(restart)
[18:02:05.857]                             muffled <- TRUE
[18:02:05.857]                             break
[18:02:05.857]                           }
[18:02:05.857]                         }
[18:02:05.857]                       }
[18:02:05.857]                       invisible(muffled)
[18:02:05.857]                     }
[18:02:05.857]                     muffleCondition(cond, pattern = "^muffle")
[18:02:05.857]                   }
[18:02:05.857]                 }
[18:02:05.857]                 else {
[18:02:05.857]                   if (TRUE) {
[18:02:05.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:05.857]                     {
[18:02:05.857]                       inherits <- base::inherits
[18:02:05.857]                       invokeRestart <- base::invokeRestart
[18:02:05.857]                       is.null <- base::is.null
[18:02:05.857]                       muffled <- FALSE
[18:02:05.857]                       if (inherits(cond, "message")) {
[18:02:05.857]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:05.857]                         if (muffled) 
[18:02:05.857]                           invokeRestart("muffleMessage")
[18:02:05.857]                       }
[18:02:05.857]                       else if (inherits(cond, "warning")) {
[18:02:05.857]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:05.857]                         if (muffled) 
[18:02:05.857]                           invokeRestart("muffleWarning")
[18:02:05.857]                       }
[18:02:05.857]                       else if (inherits(cond, "condition")) {
[18:02:05.857]                         if (!is.null(pattern)) {
[18:02:05.857]                           computeRestarts <- base::computeRestarts
[18:02:05.857]                           grepl <- base::grepl
[18:02:05.857]                           restarts <- computeRestarts(cond)
[18:02:05.857]                           for (restart in restarts) {
[18:02:05.857]                             name <- restart$name
[18:02:05.857]                             if (is.null(name)) 
[18:02:05.857]                               next
[18:02:05.857]                             if (!grepl(pattern, name)) 
[18:02:05.857]                               next
[18:02:05.857]                             invokeRestart(restart)
[18:02:05.857]                             muffled <- TRUE
[18:02:05.857]                             break
[18:02:05.857]                           }
[18:02:05.857]                         }
[18:02:05.857]                       }
[18:02:05.857]                       invisible(muffled)
[18:02:05.857]                     }
[18:02:05.857]                     muffleCondition(cond, pattern = "^muffle")
[18:02:05.857]                   }
[18:02:05.857]                 }
[18:02:05.857]             }
[18:02:05.857]         }))
[18:02:05.857]     }, error = function(ex) {
[18:02:05.857]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:05.857]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:05.857]                 ...future.rng), started = ...future.startTime, 
[18:02:05.857]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:05.857]             version = "1.8"), class = "FutureResult")
[18:02:05.857]     }, finally = {
[18:02:05.857]         if (!identical(...future.workdir, getwd())) 
[18:02:05.857]             setwd(...future.workdir)
[18:02:05.857]         {
[18:02:05.857]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:05.857]                 ...future.oldOptions$nwarnings <- NULL
[18:02:05.857]             }
[18:02:05.857]             base::options(...future.oldOptions)
[18:02:05.857]             if (.Platform$OS.type == "windows") {
[18:02:05.857]                 old_names <- names(...future.oldEnvVars)
[18:02:05.857]                 envs <- base::Sys.getenv()
[18:02:05.857]                 names <- names(envs)
[18:02:05.857]                 common <- intersect(names, old_names)
[18:02:05.857]                 added <- setdiff(names, old_names)
[18:02:05.857]                 removed <- setdiff(old_names, names)
[18:02:05.857]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:05.857]                   envs[common]]
[18:02:05.857]                 NAMES <- toupper(changed)
[18:02:05.857]                 args <- list()
[18:02:05.857]                 for (kk in seq_along(NAMES)) {
[18:02:05.857]                   name <- changed[[kk]]
[18:02:05.857]                   NAME <- NAMES[[kk]]
[18:02:05.857]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:05.857]                     next
[18:02:05.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:05.857]                 }
[18:02:05.857]                 NAMES <- toupper(added)
[18:02:05.857]                 for (kk in seq_along(NAMES)) {
[18:02:05.857]                   name <- added[[kk]]
[18:02:05.857]                   NAME <- NAMES[[kk]]
[18:02:05.857]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:05.857]                     next
[18:02:05.857]                   args[[name]] <- ""
[18:02:05.857]                 }
[18:02:05.857]                 NAMES <- toupper(removed)
[18:02:05.857]                 for (kk in seq_along(NAMES)) {
[18:02:05.857]                   name <- removed[[kk]]
[18:02:05.857]                   NAME <- NAMES[[kk]]
[18:02:05.857]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:05.857]                     next
[18:02:05.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:05.857]                 }
[18:02:05.857]                 if (length(args) > 0) 
[18:02:05.857]                   base::do.call(base::Sys.setenv, args = args)
[18:02:05.857]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:05.857]             }
[18:02:05.857]             else {
[18:02:05.857]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:05.857]             }
[18:02:05.857]             {
[18:02:05.857]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:05.857]                   0L) {
[18:02:05.857]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:05.857]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:05.857]                   base::options(opts)
[18:02:05.857]                 }
[18:02:05.857]                 {
[18:02:05.857]                   {
[18:02:05.857]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:05.857]                     NULL
[18:02:05.857]                   }
[18:02:05.857]                   options(future.plan = NULL)
[18:02:05.857]                   if (is.na(NA_character_)) 
[18:02:05.857]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:05.857]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:05.857]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:05.857]                     .init = FALSE)
[18:02:05.857]                 }
[18:02:05.857]             }
[18:02:05.857]         }
[18:02:05.857]     })
[18:02:05.857]     if (TRUE) {
[18:02:05.857]         base::sink(type = "output", split = FALSE)
[18:02:05.857]         if (TRUE) {
[18:02:05.857]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:05.857]         }
[18:02:05.857]         else {
[18:02:05.857]             ...future.result["stdout"] <- base::list(NULL)
[18:02:05.857]         }
[18:02:05.857]         base::close(...future.stdout)
[18:02:05.857]         ...future.stdout <- NULL
[18:02:05.857]     }
[18:02:05.857]     ...future.result$conditions <- ...future.conditions
[18:02:05.857]     ...future.result$finished <- base::Sys.time()
[18:02:05.857]     ...future.result
[18:02:05.857] }
[18:02:05.864] Exporting 11 global objects (95.02 KiB) to cluster node #2 ...
[18:02:05.864] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[18:02:05.906] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[18:02:05.907] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[18:02:05.908] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[18:02:05.908] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[18:02:05.909] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[18:02:05.910] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[18:02:05.951] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[18:02:05.952] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[18:02:05.993] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[18:02:05.994] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[18:02:05.995] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[18:02:05.995] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[18:02:05.997] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[18:02:05.997] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:05.998] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:05.999] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[18:02:06.000] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[18:02:06.001] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:06.002] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:06.002] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:06.003] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:06.004] Exporting 11 global objects (95.02 KiB) to cluster node #2 ... DONE
[18:02:06.005] MultisessionFuture started
[18:02:06.006] - Launch lazy future ... done
[18:02:06.006] run() for ‘MultisessionFuture’ ... done
[18:02:06.007] Created future:
[18:02:06.007] MultisessionFuture:
[18:02:06.007] Label: ‘future_vapply-2’
[18:02:06.007] Expression:
[18:02:06.007] {
[18:02:06.007]     do.call(function(...) {
[18:02:06.007]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:06.007]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:06.007]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:06.007]             on.exit(options(oopts), add = TRUE)
[18:02:06.007]         }
[18:02:06.007]         {
[18:02:06.007]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:06.007]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:06.007]                 ...future.FUN(...future.X_jj, ...)
[18:02:06.007]             })
[18:02:06.007]         }
[18:02:06.007]     }, args = future.call.arguments)
[18:02:06.007] }
[18:02:06.007] Lazy evaluation: FALSE
[18:02:06.007] Asynchronous evaluation: TRUE
[18:02:06.007] Local evaluation: TRUE
[18:02:06.007] Environment: R_GlobalEnv
[18:02:06.007] Capture standard output: TRUE
[18:02:06.007] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:06.007] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:06.007] Packages: 1 packages (‘future.apply’)
[18:02:06.007] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:06.007] Resolved: FALSE
[18:02:06.007] Value: <not collected>
[18:02:06.007] Conditions captured: <none>
[18:02:06.007] Early signaling: FALSE
[18:02:06.007] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:06.007] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:06.022] Chunk #2 of 2 ... DONE
[18:02:06.022] Launching 2 futures (chunks) ... DONE
[18:02:06.022] Resolving 2 futures (chunks) ...
[18:02:06.023] resolve() on list ...
[18:02:06.023]  recursive: 0
[18:02:06.023]  length: 2
[18:02:06.024] 
[18:02:06.025] receiveMessageFromWorker() for ClusterFuture ...
[18:02:06.026] - Validating connection of MultisessionFuture
[18:02:06.026] - received message: FutureResult
[18:02:06.026] - Received FutureResult
[18:02:06.027] - Erased future from FutureRegistry
[18:02:06.027] result() for ClusterFuture ...
[18:02:06.027] - result already collected: FutureResult
[18:02:06.028] result() for ClusterFuture ... done
[18:02:06.028] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:06.028] Future #1
[18:02:06.029] result() for ClusterFuture ...
[18:02:06.029] - result already collected: FutureResult
[18:02:06.029] result() for ClusterFuture ... done
[18:02:06.030] result() for ClusterFuture ...
[18:02:06.030] - result already collected: FutureResult
[18:02:06.030] result() for ClusterFuture ... done
[18:02:06.031] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:06.031] - nx: 2
[18:02:06.031] - relay: TRUE
[18:02:06.031] - stdout: TRUE
[18:02:06.032] - signal: TRUE
[18:02:06.032] - resignal: FALSE
[18:02:06.033] - force: TRUE
[18:02:06.033] - relayed: [n=2] FALSE, FALSE
[18:02:06.033] - queued futures: [n=2] FALSE, FALSE
[18:02:06.034]  - until=1
[18:02:06.034]  - relaying element #1
[18:02:06.034] result() for ClusterFuture ...
[18:02:06.034] - result already collected: FutureResult
[18:02:06.035] result() for ClusterFuture ... done
[18:02:06.035] result() for ClusterFuture ...
[18:02:06.035] - result already collected: FutureResult
[18:02:06.036] result() for ClusterFuture ... done
[18:02:06.036] result() for ClusterFuture ...
[18:02:06.036] - result already collected: FutureResult
[18:02:06.037] result() for ClusterFuture ... done
[18:02:06.037] result() for ClusterFuture ...
[18:02:06.037] - result already collected: FutureResult
[18:02:06.038] result() for ClusterFuture ... done
[18:02:06.038] - relayed: [n=2] TRUE, FALSE
[18:02:06.038] - queued futures: [n=2] TRUE, FALSE
[18:02:06.038] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:06.039]  length: 1 (resolved future 1)
[18:02:06.050] receiveMessageFromWorker() for ClusterFuture ...
[18:02:06.050] - Validating connection of MultisessionFuture
[18:02:06.051] - received message: FutureResult
[18:02:06.051] - Received FutureResult
[18:02:06.052] - Erased future from FutureRegistry
[18:02:06.052] result() for ClusterFuture ...
[18:02:06.052] - result already collected: FutureResult
[18:02:06.053] result() for ClusterFuture ... done
[18:02:06.053] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:06.053] Future #2
[18:02:06.054] result() for ClusterFuture ...
[18:02:06.054] - result already collected: FutureResult
[18:02:06.054] result() for ClusterFuture ... done
[18:02:06.055] result() for ClusterFuture ...
[18:02:06.055] - result already collected: FutureResult
[18:02:06.055] result() for ClusterFuture ... done
[18:02:06.056] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:06.056] - nx: 2
[18:02:06.056] - relay: TRUE
[18:02:06.056] - stdout: TRUE
[18:02:06.057] - signal: TRUE
[18:02:06.057] - resignal: FALSE
[18:02:06.057] - force: TRUE
[18:02:06.058] - relayed: [n=2] TRUE, FALSE
[18:02:06.058] - queued futures: [n=2] TRUE, FALSE
[18:02:06.058]  - until=2
[18:02:06.059]  - relaying element #2
[18:02:06.059] result() for ClusterFuture ...
[18:02:06.059] - result already collected: FutureResult
[18:02:06.059] result() for ClusterFuture ... done
[18:02:06.060] result() for ClusterFuture ...
[18:02:06.060] - result already collected: FutureResult
[18:02:06.060] result() for ClusterFuture ... done
[18:02:06.061] result() for ClusterFuture ...
[18:02:06.061] - result already collected: FutureResult
[18:02:06.061] result() for ClusterFuture ... done
[18:02:06.062] result() for ClusterFuture ...
[18:02:06.062] - result already collected: FutureResult
[18:02:06.062] result() for ClusterFuture ... done
[18:02:06.063] - relayed: [n=2] TRUE, TRUE
[18:02:06.063] - queued futures: [n=2] TRUE, TRUE
[18:02:06.063] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:06.064]  length: 0 (resolved future 2)
[18:02:06.065] Relaying remaining futures
[18:02:06.065] signalConditionsASAP(NULL, pos=0) ...
[18:02:06.066] - nx: 2
[18:02:06.066] - relay: TRUE
[18:02:06.066] - stdout: TRUE
[18:02:06.066] - signal: TRUE
[18:02:06.067] - resignal: FALSE
[18:02:06.067] - force: TRUE
[18:02:06.067] - relayed: [n=2] TRUE, TRUE
[18:02:06.068] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:06.068] - relayed: [n=2] TRUE, TRUE
[18:02:06.068] - queued futures: [n=2] TRUE, TRUE
[18:02:06.069] signalConditionsASAP(NULL, pos=0) ... done
[18:02:06.069] resolve() on list ... DONE
[18:02:06.069] result() for ClusterFuture ...
[18:02:06.070] - result already collected: FutureResult
[18:02:06.070] result() for ClusterFuture ... done
[18:02:06.070] result() for ClusterFuture ...
[18:02:06.071] - result already collected: FutureResult
[18:02:06.071] result() for ClusterFuture ... done
[18:02:06.071] result() for ClusterFuture ...
[18:02:06.072] - result already collected: FutureResult
[18:02:06.072] result() for ClusterFuture ... done
[18:02:06.072] result() for ClusterFuture ...
[18:02:06.072] - result already collected: FutureResult
[18:02:06.073] result() for ClusterFuture ... done
[18:02:06.073]  - Number of value chunks collected: 2
[18:02:06.073] Resolving 2 futures (chunks) ... DONE
[18:02:06.074] Reducing values from 2 chunks ...
[18:02:06.074]  - Number of values collected after concatenation: 10
[18:02:06.074]  - Number of values expected: 10
[18:02:06.075] Reducing values from 2 chunks ... DONE
[18:02:06.075] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[18:02:06.081] future_lapply() ...
[18:02:06.094] Number of chunks: 2
[18:02:06.094] getGlobalsAndPackagesXApply() ...
[18:02:06.094]  - future.globals: TRUE
[18:02:06.094] getGlobalsAndPackages() ...
[18:02:06.095] Searching for globals...
[18:02:06.103] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[18:02:06.104] Searching for globals ... DONE
[18:02:06.104] Resolving globals: FALSE
[18:02:06.109] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[18:02:06.110] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:06.110] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:06.111] - packages: [1] ‘future.apply’
[18:02:06.111] getGlobalsAndPackages() ... DONE
[18:02:06.111]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:06.111]  - needed namespaces: [n=1] ‘future.apply’
[18:02:06.112] Finding globals ... DONE
[18:02:06.112]  - use_args: TRUE
[18:02:06.112]  - Getting '...' globals ...
[18:02:06.113] resolve() on list ...
[18:02:06.113]  recursive: 0
[18:02:06.113]  length: 1
[18:02:06.113]  elements: ‘...’
[18:02:06.114]  length: 0 (resolved future 1)
[18:02:06.114] resolve() on list ... DONE
[18:02:06.114]    - '...' content: [n=0] 
[18:02:06.114] List of 1
[18:02:06.114]  $ ...: list()
[18:02:06.114]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:06.114]  - attr(*, "where")=List of 1
[18:02:06.114]   ..$ ...:<environment: 0x6183c35248e0> 
[18:02:06.114]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:06.114]  - attr(*, "resolved")= logi TRUE
[18:02:06.114]  - attr(*, "total_size")= num NA
[18:02:06.120]  - Getting '...' globals ... DONE
[18:02:06.120] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:06.120] List of 8
[18:02:06.120]  $ ...future.FUN:function (x, ...)  
[18:02:06.120]  $ x_FUN        :function (x)  
[18:02:06.120]  $ times        : int 4
[18:02:06.120]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:06.120]  $ stop_if_not  :function (...)  
[18:02:06.120]  $ dim          : int [1:2] 2 2
[18:02:06.120]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:02:06.120]  $ ...          : list()
[18:02:06.120]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:06.120]  - attr(*, "where")=List of 8
[18:02:06.120]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:06.120]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:06.120]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:06.120]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:06.120]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:06.120]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:06.120]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:06.120]   ..$ ...          :<environment: 0x6183c35248e0> 
[18:02:06.120]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:06.120]  - attr(*, "resolved")= logi FALSE
[18:02:06.120]  - attr(*, "total_size")= num 105552
[18:02:06.133] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:06.133] getGlobalsAndPackagesXApply() ... DONE
[18:02:06.134] Number of futures (= number of chunks): 2
[18:02:06.134] Launching 2 futures (chunks) ...
[18:02:06.134] Chunk #1 of 2 ...
[18:02:06.134]  - Finding globals in 'X' for chunk #1 ...
[18:02:06.135] getGlobalsAndPackages() ...
[18:02:06.135] Searching for globals...
[18:02:06.135] 
[18:02:06.136] Searching for globals ... DONE
[18:02:06.136] - globals: [0] <none>
[18:02:06.136] getGlobalsAndPackages() ... DONE
[18:02:06.136]    + additional globals found: [n=0] 
[18:02:06.136]    + additional namespaces needed: [n=0] 
[18:02:06.137]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:06.137]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:06.137]  - seeds: <none>
[18:02:06.137]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:06.138] getGlobalsAndPackages() ...
[18:02:06.138] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:06.138] Resolving globals: FALSE
[18:02:06.138] Tweak future expression to call with '...' arguments ...
[18:02:06.139] {
[18:02:06.139]     do.call(function(...) {
[18:02:06.139]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:06.139]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:06.139]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:06.139]             on.exit(options(oopts), add = TRUE)
[18:02:06.139]         }
[18:02:06.139]         {
[18:02:06.139]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:06.139]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:06.139]                 ...future.FUN(...future.X_jj, ...)
[18:02:06.139]             })
[18:02:06.139]         }
[18:02:06.139]     }, args = future.call.arguments)
[18:02:06.139] }
[18:02:06.139] Tweak future expression to call with '...' arguments ... DONE
[18:02:06.140] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:06.141] - packages: [1] ‘future.apply’
[18:02:06.141] getGlobalsAndPackages() ... DONE
[18:02:06.142] run() for ‘Future’ ...
[18:02:06.142] - state: ‘created’
[18:02:06.142] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:06.167] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:06.167] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:06.168]   - Field: ‘node’
[18:02:06.168]   - Field: ‘label’
[18:02:06.168]   - Field: ‘local’
[18:02:06.168]   - Field: ‘owner’
[18:02:06.168]   - Field: ‘envir’
[18:02:06.169]   - Field: ‘workers’
[18:02:06.169]   - Field: ‘packages’
[18:02:06.169]   - Field: ‘gc’
[18:02:06.169]   - Field: ‘conditions’
[18:02:06.169]   - Field: ‘persistent’
[18:02:06.170]   - Field: ‘expr’
[18:02:06.170]   - Field: ‘uuid’
[18:02:06.170]   - Field: ‘seed’
[18:02:06.170]   - Field: ‘version’
[18:02:06.170]   - Field: ‘result’
[18:02:06.171]   - Field: ‘asynchronous’
[18:02:06.171]   - Field: ‘calls’
[18:02:06.171]   - Field: ‘globals’
[18:02:06.171]   - Field: ‘stdout’
[18:02:06.171]   - Field: ‘earlySignal’
[18:02:06.172]   - Field: ‘lazy’
[18:02:06.172]   - Field: ‘state’
[18:02:06.172] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:06.172] - Launch lazy future ...
[18:02:06.173] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:06.173] Packages needed by future strategies (n = 0): <none>
[18:02:06.174] {
[18:02:06.174]     {
[18:02:06.174]         {
[18:02:06.174]             ...future.startTime <- base::Sys.time()
[18:02:06.174]             {
[18:02:06.174]                 {
[18:02:06.174]                   {
[18:02:06.174]                     {
[18:02:06.174]                       {
[18:02:06.174]                         base::local({
[18:02:06.174]                           has_future <- base::requireNamespace("future", 
[18:02:06.174]                             quietly = TRUE)
[18:02:06.174]                           if (has_future) {
[18:02:06.174]                             ns <- base::getNamespace("future")
[18:02:06.174]                             version <- ns[[".package"]][["version"]]
[18:02:06.174]                             if (is.null(version)) 
[18:02:06.174]                               version <- utils::packageVersion("future")
[18:02:06.174]                           }
[18:02:06.174]                           else {
[18:02:06.174]                             version <- NULL
[18:02:06.174]                           }
[18:02:06.174]                           if (!has_future || version < "1.8.0") {
[18:02:06.174]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:06.174]                               "", base::R.version$version.string), 
[18:02:06.174]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:06.174]                                 base::R.version$platform, 8 * 
[18:02:06.174]                                   base::.Machine$sizeof.pointer), 
[18:02:06.174]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:06.174]                                 "release", "version")], collapse = " "), 
[18:02:06.174]                               hostname = base::Sys.info()[["nodename"]])
[18:02:06.174]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:06.174]                               info)
[18:02:06.174]                             info <- base::paste(info, collapse = "; ")
[18:02:06.174]                             if (!has_future) {
[18:02:06.174]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:06.174]                                 info)
[18:02:06.174]                             }
[18:02:06.174]                             else {
[18:02:06.174]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:06.174]                                 info, version)
[18:02:06.174]                             }
[18:02:06.174]                             base::stop(msg)
[18:02:06.174]                           }
[18:02:06.174]                         })
[18:02:06.174]                       }
[18:02:06.174]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:06.174]                       base::options(mc.cores = 1L)
[18:02:06.174]                     }
[18:02:06.174]                     base::local({
[18:02:06.174]                       for (pkg in "future.apply") {
[18:02:06.174]                         base::loadNamespace(pkg)
[18:02:06.174]                         base::library(pkg, character.only = TRUE)
[18:02:06.174]                       }
[18:02:06.174]                     })
[18:02:06.174]                   }
[18:02:06.174]                   ...future.strategy.old <- future::plan("list")
[18:02:06.174]                   options(future.plan = NULL)
[18:02:06.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:06.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:06.174]                 }
[18:02:06.174]                 ...future.workdir <- getwd()
[18:02:06.174]             }
[18:02:06.174]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:06.174]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:06.174]         }
[18:02:06.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:06.174]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:06.174]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:06.174]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:06.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:06.174]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:06.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:06.174]             base::names(...future.oldOptions))
[18:02:06.174]     }
[18:02:06.174]     if (FALSE) {
[18:02:06.174]     }
[18:02:06.174]     else {
[18:02:06.174]         if (TRUE) {
[18:02:06.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:06.174]                 open = "w")
[18:02:06.174]         }
[18:02:06.174]         else {
[18:02:06.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:06.174]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:06.174]         }
[18:02:06.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:06.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:06.174]             base::sink(type = "output", split = FALSE)
[18:02:06.174]             base::close(...future.stdout)
[18:02:06.174]         }, add = TRUE)
[18:02:06.174]     }
[18:02:06.174]     ...future.frame <- base::sys.nframe()
[18:02:06.174]     ...future.conditions <- base::list()
[18:02:06.174]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:06.174]     if (FALSE) {
[18:02:06.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:06.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:06.174]     }
[18:02:06.174]     ...future.result <- base::tryCatch({
[18:02:06.174]         base::withCallingHandlers({
[18:02:06.174]             ...future.value <- base::withVisible(base::local({
[18:02:06.174]                 ...future.makeSendCondition <- base::local({
[18:02:06.174]                   sendCondition <- NULL
[18:02:06.174]                   function(frame = 1L) {
[18:02:06.174]                     if (is.function(sendCondition)) 
[18:02:06.174]                       return(sendCondition)
[18:02:06.174]                     ns <- getNamespace("parallel")
[18:02:06.174]                     if (exists("sendData", mode = "function", 
[18:02:06.174]                       envir = ns)) {
[18:02:06.174]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:06.174]                         envir = ns)
[18:02:06.174]                       envir <- sys.frame(frame)
[18:02:06.174]                       master <- NULL
[18:02:06.174]                       while (!identical(envir, .GlobalEnv) && 
[18:02:06.174]                         !identical(envir, emptyenv())) {
[18:02:06.174]                         if (exists("master", mode = "list", envir = envir, 
[18:02:06.174]                           inherits = FALSE)) {
[18:02:06.174]                           master <- get("master", mode = "list", 
[18:02:06.174]                             envir = envir, inherits = FALSE)
[18:02:06.174]                           if (inherits(master, c("SOCKnode", 
[18:02:06.174]                             "SOCK0node"))) {
[18:02:06.174]                             sendCondition <<- function(cond) {
[18:02:06.174]                               data <- list(type = "VALUE", value = cond, 
[18:02:06.174]                                 success = TRUE)
[18:02:06.174]                               parallel_sendData(master, data)
[18:02:06.174]                             }
[18:02:06.174]                             return(sendCondition)
[18:02:06.174]                           }
[18:02:06.174]                         }
[18:02:06.174]                         frame <- frame + 1L
[18:02:06.174]                         envir <- sys.frame(frame)
[18:02:06.174]                       }
[18:02:06.174]                     }
[18:02:06.174]                     sendCondition <<- function(cond) NULL
[18:02:06.174]                   }
[18:02:06.174]                 })
[18:02:06.174]                 withCallingHandlers({
[18:02:06.174]                   {
[18:02:06.174]                     do.call(function(...) {
[18:02:06.174]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:06.174]                       if (!identical(...future.globals.maxSize.org, 
[18:02:06.174]                         ...future.globals.maxSize)) {
[18:02:06.174]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:06.174]                         on.exit(options(oopts), add = TRUE)
[18:02:06.174]                       }
[18:02:06.174]                       {
[18:02:06.174]                         lapply(seq_along(...future.elements_ii), 
[18:02:06.174]                           FUN = function(jj) {
[18:02:06.174]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:06.174]                             ...future.FUN(...future.X_jj, ...)
[18:02:06.174]                           })
[18:02:06.174]                       }
[18:02:06.174]                     }, args = future.call.arguments)
[18:02:06.174]                   }
[18:02:06.174]                 }, immediateCondition = function(cond) {
[18:02:06.174]                   sendCondition <- ...future.makeSendCondition()
[18:02:06.174]                   sendCondition(cond)
[18:02:06.174]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:06.174]                   {
[18:02:06.174]                     inherits <- base::inherits
[18:02:06.174]                     invokeRestart <- base::invokeRestart
[18:02:06.174]                     is.null <- base::is.null
[18:02:06.174]                     muffled <- FALSE
[18:02:06.174]                     if (inherits(cond, "message")) {
[18:02:06.174]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:06.174]                       if (muffled) 
[18:02:06.174]                         invokeRestart("muffleMessage")
[18:02:06.174]                     }
[18:02:06.174]                     else if (inherits(cond, "warning")) {
[18:02:06.174]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:06.174]                       if (muffled) 
[18:02:06.174]                         invokeRestart("muffleWarning")
[18:02:06.174]                     }
[18:02:06.174]                     else if (inherits(cond, "condition")) {
[18:02:06.174]                       if (!is.null(pattern)) {
[18:02:06.174]                         computeRestarts <- base::computeRestarts
[18:02:06.174]                         grepl <- base::grepl
[18:02:06.174]                         restarts <- computeRestarts(cond)
[18:02:06.174]                         for (restart in restarts) {
[18:02:06.174]                           name <- restart$name
[18:02:06.174]                           if (is.null(name)) 
[18:02:06.174]                             next
[18:02:06.174]                           if (!grepl(pattern, name)) 
[18:02:06.174]                             next
[18:02:06.174]                           invokeRestart(restart)
[18:02:06.174]                           muffled <- TRUE
[18:02:06.174]                           break
[18:02:06.174]                         }
[18:02:06.174]                       }
[18:02:06.174]                     }
[18:02:06.174]                     invisible(muffled)
[18:02:06.174]                   }
[18:02:06.174]                   muffleCondition(cond)
[18:02:06.174]                 })
[18:02:06.174]             }))
[18:02:06.174]             future::FutureResult(value = ...future.value$value, 
[18:02:06.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:06.174]                   ...future.rng), globalenv = if (FALSE) 
[18:02:06.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:06.174]                     ...future.globalenv.names))
[18:02:06.174]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:06.174]         }, condition = base::local({
[18:02:06.174]             c <- base::c
[18:02:06.174]             inherits <- base::inherits
[18:02:06.174]             invokeRestart <- base::invokeRestart
[18:02:06.174]             length <- base::length
[18:02:06.174]             list <- base::list
[18:02:06.174]             seq.int <- base::seq.int
[18:02:06.174]             signalCondition <- base::signalCondition
[18:02:06.174]             sys.calls <- base::sys.calls
[18:02:06.174]             `[[` <- base::`[[`
[18:02:06.174]             `+` <- base::`+`
[18:02:06.174]             `<<-` <- base::`<<-`
[18:02:06.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:06.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:06.174]                   3L)]
[18:02:06.174]             }
[18:02:06.174]             function(cond) {
[18:02:06.174]                 is_error <- inherits(cond, "error")
[18:02:06.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:06.174]                   NULL)
[18:02:06.174]                 if (is_error) {
[18:02:06.174]                   sessionInformation <- function() {
[18:02:06.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:06.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:06.174]                       search = base::search(), system = base::Sys.info())
[18:02:06.174]                   }
[18:02:06.174]                   ...future.conditions[[length(...future.conditions) + 
[18:02:06.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:06.174]                     cond$call), session = sessionInformation(), 
[18:02:06.174]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:06.174]                   signalCondition(cond)
[18:02:06.174]                 }
[18:02:06.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:06.174]                 "immediateCondition"))) {
[18:02:06.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:06.174]                   ...future.conditions[[length(...future.conditions) + 
[18:02:06.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:06.174]                   if (TRUE && !signal) {
[18:02:06.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:06.174]                     {
[18:02:06.174]                       inherits <- base::inherits
[18:02:06.174]                       invokeRestart <- base::invokeRestart
[18:02:06.174]                       is.null <- base::is.null
[18:02:06.174]                       muffled <- FALSE
[18:02:06.174]                       if (inherits(cond, "message")) {
[18:02:06.174]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:06.174]                         if (muffled) 
[18:02:06.174]                           invokeRestart("muffleMessage")
[18:02:06.174]                       }
[18:02:06.174]                       else if (inherits(cond, "warning")) {
[18:02:06.174]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:06.174]                         if (muffled) 
[18:02:06.174]                           invokeRestart("muffleWarning")
[18:02:06.174]                       }
[18:02:06.174]                       else if (inherits(cond, "condition")) {
[18:02:06.174]                         if (!is.null(pattern)) {
[18:02:06.174]                           computeRestarts <- base::computeRestarts
[18:02:06.174]                           grepl <- base::grepl
[18:02:06.174]                           restarts <- computeRestarts(cond)
[18:02:06.174]                           for (restart in restarts) {
[18:02:06.174]                             name <- restart$name
[18:02:06.174]                             if (is.null(name)) 
[18:02:06.174]                               next
[18:02:06.174]                             if (!grepl(pattern, name)) 
[18:02:06.174]                               next
[18:02:06.174]                             invokeRestart(restart)
[18:02:06.174]                             muffled <- TRUE
[18:02:06.174]                             break
[18:02:06.174]                           }
[18:02:06.174]                         }
[18:02:06.174]                       }
[18:02:06.174]                       invisible(muffled)
[18:02:06.174]                     }
[18:02:06.174]                     muffleCondition(cond, pattern = "^muffle")
[18:02:06.174]                   }
[18:02:06.174]                 }
[18:02:06.174]                 else {
[18:02:06.174]                   if (TRUE) {
[18:02:06.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:06.174]                     {
[18:02:06.174]                       inherits <- base::inherits
[18:02:06.174]                       invokeRestart <- base::invokeRestart
[18:02:06.174]                       is.null <- base::is.null
[18:02:06.174]                       muffled <- FALSE
[18:02:06.174]                       if (inherits(cond, "message")) {
[18:02:06.174]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:06.174]                         if (muffled) 
[18:02:06.174]                           invokeRestart("muffleMessage")
[18:02:06.174]                       }
[18:02:06.174]                       else if (inherits(cond, "warning")) {
[18:02:06.174]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:06.174]                         if (muffled) 
[18:02:06.174]                           invokeRestart("muffleWarning")
[18:02:06.174]                       }
[18:02:06.174]                       else if (inherits(cond, "condition")) {
[18:02:06.174]                         if (!is.null(pattern)) {
[18:02:06.174]                           computeRestarts <- base::computeRestarts
[18:02:06.174]                           grepl <- base::grepl
[18:02:06.174]                           restarts <- computeRestarts(cond)
[18:02:06.174]                           for (restart in restarts) {
[18:02:06.174]                             name <- restart$name
[18:02:06.174]                             if (is.null(name)) 
[18:02:06.174]                               next
[18:02:06.174]                             if (!grepl(pattern, name)) 
[18:02:06.174]                               next
[18:02:06.174]                             invokeRestart(restart)
[18:02:06.174]                             muffled <- TRUE
[18:02:06.174]                             break
[18:02:06.174]                           }
[18:02:06.174]                         }
[18:02:06.174]                       }
[18:02:06.174]                       invisible(muffled)
[18:02:06.174]                     }
[18:02:06.174]                     muffleCondition(cond, pattern = "^muffle")
[18:02:06.174]                   }
[18:02:06.174]                 }
[18:02:06.174]             }
[18:02:06.174]         }))
[18:02:06.174]     }, error = function(ex) {
[18:02:06.174]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:06.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:06.174]                 ...future.rng), started = ...future.startTime, 
[18:02:06.174]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:06.174]             version = "1.8"), class = "FutureResult")
[18:02:06.174]     }, finally = {
[18:02:06.174]         if (!identical(...future.workdir, getwd())) 
[18:02:06.174]             setwd(...future.workdir)
[18:02:06.174]         {
[18:02:06.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:06.174]                 ...future.oldOptions$nwarnings <- NULL
[18:02:06.174]             }
[18:02:06.174]             base::options(...future.oldOptions)
[18:02:06.174]             if (.Platform$OS.type == "windows") {
[18:02:06.174]                 old_names <- names(...future.oldEnvVars)
[18:02:06.174]                 envs <- base::Sys.getenv()
[18:02:06.174]                 names <- names(envs)
[18:02:06.174]                 common <- intersect(names, old_names)
[18:02:06.174]                 added <- setdiff(names, old_names)
[18:02:06.174]                 removed <- setdiff(old_names, names)
[18:02:06.174]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:06.174]                   envs[common]]
[18:02:06.174]                 NAMES <- toupper(changed)
[18:02:06.174]                 args <- list()
[18:02:06.174]                 for (kk in seq_along(NAMES)) {
[18:02:06.174]                   name <- changed[[kk]]
[18:02:06.174]                   NAME <- NAMES[[kk]]
[18:02:06.174]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:06.174]                     next
[18:02:06.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:06.174]                 }
[18:02:06.174]                 NAMES <- toupper(added)
[18:02:06.174]                 for (kk in seq_along(NAMES)) {
[18:02:06.174]                   name <- added[[kk]]
[18:02:06.174]                   NAME <- NAMES[[kk]]
[18:02:06.174]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:06.174]                     next
[18:02:06.174]                   args[[name]] <- ""
[18:02:06.174]                 }
[18:02:06.174]                 NAMES <- toupper(removed)
[18:02:06.174]                 for (kk in seq_along(NAMES)) {
[18:02:06.174]                   name <- removed[[kk]]
[18:02:06.174]                   NAME <- NAMES[[kk]]
[18:02:06.174]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:06.174]                     next
[18:02:06.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:06.174]                 }
[18:02:06.174]                 if (length(args) > 0) 
[18:02:06.174]                   base::do.call(base::Sys.setenv, args = args)
[18:02:06.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:06.174]             }
[18:02:06.174]             else {
[18:02:06.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:06.174]             }
[18:02:06.174]             {
[18:02:06.174]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:06.174]                   0L) {
[18:02:06.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:06.174]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:06.174]                   base::options(opts)
[18:02:06.174]                 }
[18:02:06.174]                 {
[18:02:06.174]                   {
[18:02:06.174]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:06.174]                     NULL
[18:02:06.174]                   }
[18:02:06.174]                   options(future.plan = NULL)
[18:02:06.174]                   if (is.na(NA_character_)) 
[18:02:06.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:06.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:06.174]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:06.174]                     .init = FALSE)
[18:02:06.174]                 }
[18:02:06.174]             }
[18:02:06.174]         }
[18:02:06.174]     })
[18:02:06.174]     if (TRUE) {
[18:02:06.174]         base::sink(type = "output", split = FALSE)
[18:02:06.174]         if (TRUE) {
[18:02:06.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:06.174]         }
[18:02:06.174]         else {
[18:02:06.174]             ...future.result["stdout"] <- base::list(NULL)
[18:02:06.174]         }
[18:02:06.174]         base::close(...future.stdout)
[18:02:06.174]         ...future.stdout <- NULL
[18:02:06.174]     }
[18:02:06.174]     ...future.result$conditions <- ...future.conditions
[18:02:06.174]     ...future.result$finished <- base::Sys.time()
[18:02:06.174]     ...future.result
[18:02:06.174] }
[18:02:06.179] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[18:02:06.180] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[18:02:06.221] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[18:02:06.222] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[18:02:06.223] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[18:02:06.223] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[18:02:06.224] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[18:02:06.224] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[18:02:06.266] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[18:02:06.267] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[18:02:06.308] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[18:02:06.309] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[18:02:06.310] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[18:02:06.310] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[18:02:06.312] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[18:02:06.312] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:06.313] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:06.314] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[18:02:06.315] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[18:02:06.316] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:06.317] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:06.317] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:06.318] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:06.319] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[18:02:06.320] MultisessionFuture started
[18:02:06.320] - Launch lazy future ... done
[18:02:06.321] run() for ‘MultisessionFuture’ ... done
[18:02:06.322] Created future:
[18:02:06.322] MultisessionFuture:
[18:02:06.322] Label: ‘future_vapply-1’
[18:02:06.322] Expression:
[18:02:06.322] {
[18:02:06.322]     do.call(function(...) {
[18:02:06.322]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:06.322]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:06.322]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:06.322]             on.exit(options(oopts), add = TRUE)
[18:02:06.322]         }
[18:02:06.322]         {
[18:02:06.322]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:06.322]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:06.322]                 ...future.FUN(...future.X_jj, ...)
[18:02:06.322]             })
[18:02:06.322]         }
[18:02:06.322]     }, args = future.call.arguments)
[18:02:06.322] }
[18:02:06.322] Lazy evaluation: FALSE
[18:02:06.322] Asynchronous evaluation: TRUE
[18:02:06.322] Local evaluation: TRUE
[18:02:06.322] Environment: R_GlobalEnv
[18:02:06.322] Capture standard output: TRUE
[18:02:06.322] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:06.322] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:06.322] Packages: 1 packages (‘future.apply’)
[18:02:06.322] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:06.322] Resolved: FALSE
[18:02:06.322] Value: <not collected>
[18:02:06.322] Conditions captured: <none>
[18:02:06.322] Early signaling: FALSE
[18:02:06.322] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:06.322] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:06.336] Chunk #1 of 2 ... DONE
[18:02:06.337] Chunk #2 of 2 ...
[18:02:06.337]  - Finding globals in 'X' for chunk #2 ...
[18:02:06.338] getGlobalsAndPackages() ...
[18:02:06.338] Searching for globals...
[18:02:06.339] 
[18:02:06.339] Searching for globals ... DONE
[18:02:06.339] - globals: [0] <none>
[18:02:06.340] getGlobalsAndPackages() ... DONE
[18:02:06.340]    + additional globals found: [n=0] 
[18:02:06.340]    + additional namespaces needed: [n=0] 
[18:02:06.340]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:06.341]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:06.341]  - seeds: <none>
[18:02:06.341]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:06.341] getGlobalsAndPackages() ...
[18:02:06.341] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:06.342] Resolving globals: FALSE
[18:02:06.343] Tweak future expression to call with '...' arguments ...
[18:02:06.343] {
[18:02:06.343]     do.call(function(...) {
[18:02:06.343]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:06.343]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:06.343]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:06.343]             on.exit(options(oopts), add = TRUE)
[18:02:06.343]         }
[18:02:06.343]         {
[18:02:06.343]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:06.343]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:06.343]                 ...future.FUN(...future.X_jj, ...)
[18:02:06.343]             })
[18:02:06.343]         }
[18:02:06.343]     }, args = future.call.arguments)
[18:02:06.343] }
[18:02:06.343] Tweak future expression to call with '...' arguments ... DONE
[18:02:06.345] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:06.346] - packages: [1] ‘future.apply’
[18:02:06.346] getGlobalsAndPackages() ... DONE
[18:02:06.347] run() for ‘Future’ ...
[18:02:06.348] - state: ‘created’
[18:02:06.348] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:06.374] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:06.375] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:06.375]   - Field: ‘node’
[18:02:06.375]   - Field: ‘label’
[18:02:06.375]   - Field: ‘local’
[18:02:06.376]   - Field: ‘owner’
[18:02:06.376]   - Field: ‘envir’
[18:02:06.376]   - Field: ‘workers’
[18:02:06.376]   - Field: ‘packages’
[18:02:06.376]   - Field: ‘gc’
[18:02:06.377]   - Field: ‘conditions’
[18:02:06.377]   - Field: ‘persistent’
[18:02:06.377]   - Field: ‘expr’
[18:02:06.377]   - Field: ‘uuid’
[18:02:06.378]   - Field: ‘seed’
[18:02:06.378]   - Field: ‘version’
[18:02:06.378]   - Field: ‘result’
[18:02:06.378]   - Field: ‘asynchronous’
[18:02:06.378]   - Field: ‘calls’
[18:02:06.379]   - Field: ‘globals’
[18:02:06.379]   - Field: ‘stdout’
[18:02:06.379]   - Field: ‘earlySignal’
[18:02:06.379]   - Field: ‘lazy’
[18:02:06.379]   - Field: ‘state’
[18:02:06.380] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:06.380] - Launch lazy future ...
[18:02:06.380] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:06.381] Packages needed by future strategies (n = 0): <none>
[18:02:06.382] {
[18:02:06.382]     {
[18:02:06.382]         {
[18:02:06.382]             ...future.startTime <- base::Sys.time()
[18:02:06.382]             {
[18:02:06.382]                 {
[18:02:06.382]                   {
[18:02:06.382]                     {
[18:02:06.382]                       {
[18:02:06.382]                         base::local({
[18:02:06.382]                           has_future <- base::requireNamespace("future", 
[18:02:06.382]                             quietly = TRUE)
[18:02:06.382]                           if (has_future) {
[18:02:06.382]                             ns <- base::getNamespace("future")
[18:02:06.382]                             version <- ns[[".package"]][["version"]]
[18:02:06.382]                             if (is.null(version)) 
[18:02:06.382]                               version <- utils::packageVersion("future")
[18:02:06.382]                           }
[18:02:06.382]                           else {
[18:02:06.382]                             version <- NULL
[18:02:06.382]                           }
[18:02:06.382]                           if (!has_future || version < "1.8.0") {
[18:02:06.382]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:06.382]                               "", base::R.version$version.string), 
[18:02:06.382]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:06.382]                                 base::R.version$platform, 8 * 
[18:02:06.382]                                   base::.Machine$sizeof.pointer), 
[18:02:06.382]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:06.382]                                 "release", "version")], collapse = " "), 
[18:02:06.382]                               hostname = base::Sys.info()[["nodename"]])
[18:02:06.382]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:06.382]                               info)
[18:02:06.382]                             info <- base::paste(info, collapse = "; ")
[18:02:06.382]                             if (!has_future) {
[18:02:06.382]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:06.382]                                 info)
[18:02:06.382]                             }
[18:02:06.382]                             else {
[18:02:06.382]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:06.382]                                 info, version)
[18:02:06.382]                             }
[18:02:06.382]                             base::stop(msg)
[18:02:06.382]                           }
[18:02:06.382]                         })
[18:02:06.382]                       }
[18:02:06.382]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:06.382]                       base::options(mc.cores = 1L)
[18:02:06.382]                     }
[18:02:06.382]                     base::local({
[18:02:06.382]                       for (pkg in "future.apply") {
[18:02:06.382]                         base::loadNamespace(pkg)
[18:02:06.382]                         base::library(pkg, character.only = TRUE)
[18:02:06.382]                       }
[18:02:06.382]                     })
[18:02:06.382]                   }
[18:02:06.382]                   ...future.strategy.old <- future::plan("list")
[18:02:06.382]                   options(future.plan = NULL)
[18:02:06.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:06.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:06.382]                 }
[18:02:06.382]                 ...future.workdir <- getwd()
[18:02:06.382]             }
[18:02:06.382]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:06.382]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:06.382]         }
[18:02:06.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:06.382]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:06.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:06.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:06.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:06.382]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:06.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:06.382]             base::names(...future.oldOptions))
[18:02:06.382]     }
[18:02:06.382]     if (FALSE) {
[18:02:06.382]     }
[18:02:06.382]     else {
[18:02:06.382]         if (TRUE) {
[18:02:06.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:06.382]                 open = "w")
[18:02:06.382]         }
[18:02:06.382]         else {
[18:02:06.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:06.382]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:06.382]         }
[18:02:06.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:06.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:06.382]             base::sink(type = "output", split = FALSE)
[18:02:06.382]             base::close(...future.stdout)
[18:02:06.382]         }, add = TRUE)
[18:02:06.382]     }
[18:02:06.382]     ...future.frame <- base::sys.nframe()
[18:02:06.382]     ...future.conditions <- base::list()
[18:02:06.382]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:06.382]     if (FALSE) {
[18:02:06.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:06.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:06.382]     }
[18:02:06.382]     ...future.result <- base::tryCatch({
[18:02:06.382]         base::withCallingHandlers({
[18:02:06.382]             ...future.value <- base::withVisible(base::local({
[18:02:06.382]                 ...future.makeSendCondition <- base::local({
[18:02:06.382]                   sendCondition <- NULL
[18:02:06.382]                   function(frame = 1L) {
[18:02:06.382]                     if (is.function(sendCondition)) 
[18:02:06.382]                       return(sendCondition)
[18:02:06.382]                     ns <- getNamespace("parallel")
[18:02:06.382]                     if (exists("sendData", mode = "function", 
[18:02:06.382]                       envir = ns)) {
[18:02:06.382]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:06.382]                         envir = ns)
[18:02:06.382]                       envir <- sys.frame(frame)
[18:02:06.382]                       master <- NULL
[18:02:06.382]                       while (!identical(envir, .GlobalEnv) && 
[18:02:06.382]                         !identical(envir, emptyenv())) {
[18:02:06.382]                         if (exists("master", mode = "list", envir = envir, 
[18:02:06.382]                           inherits = FALSE)) {
[18:02:06.382]                           master <- get("master", mode = "list", 
[18:02:06.382]                             envir = envir, inherits = FALSE)
[18:02:06.382]                           if (inherits(master, c("SOCKnode", 
[18:02:06.382]                             "SOCK0node"))) {
[18:02:06.382]                             sendCondition <<- function(cond) {
[18:02:06.382]                               data <- list(type = "VALUE", value = cond, 
[18:02:06.382]                                 success = TRUE)
[18:02:06.382]                               parallel_sendData(master, data)
[18:02:06.382]                             }
[18:02:06.382]                             return(sendCondition)
[18:02:06.382]                           }
[18:02:06.382]                         }
[18:02:06.382]                         frame <- frame + 1L
[18:02:06.382]                         envir <- sys.frame(frame)
[18:02:06.382]                       }
[18:02:06.382]                     }
[18:02:06.382]                     sendCondition <<- function(cond) NULL
[18:02:06.382]                   }
[18:02:06.382]                 })
[18:02:06.382]                 withCallingHandlers({
[18:02:06.382]                   {
[18:02:06.382]                     do.call(function(...) {
[18:02:06.382]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:06.382]                       if (!identical(...future.globals.maxSize.org, 
[18:02:06.382]                         ...future.globals.maxSize)) {
[18:02:06.382]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:06.382]                         on.exit(options(oopts), add = TRUE)
[18:02:06.382]                       }
[18:02:06.382]                       {
[18:02:06.382]                         lapply(seq_along(...future.elements_ii), 
[18:02:06.382]                           FUN = function(jj) {
[18:02:06.382]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:06.382]                             ...future.FUN(...future.X_jj, ...)
[18:02:06.382]                           })
[18:02:06.382]                       }
[18:02:06.382]                     }, args = future.call.arguments)
[18:02:06.382]                   }
[18:02:06.382]                 }, immediateCondition = function(cond) {
[18:02:06.382]                   sendCondition <- ...future.makeSendCondition()
[18:02:06.382]                   sendCondition(cond)
[18:02:06.382]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:06.382]                   {
[18:02:06.382]                     inherits <- base::inherits
[18:02:06.382]                     invokeRestart <- base::invokeRestart
[18:02:06.382]                     is.null <- base::is.null
[18:02:06.382]                     muffled <- FALSE
[18:02:06.382]                     if (inherits(cond, "message")) {
[18:02:06.382]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:06.382]                       if (muffled) 
[18:02:06.382]                         invokeRestart("muffleMessage")
[18:02:06.382]                     }
[18:02:06.382]                     else if (inherits(cond, "warning")) {
[18:02:06.382]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:06.382]                       if (muffled) 
[18:02:06.382]                         invokeRestart("muffleWarning")
[18:02:06.382]                     }
[18:02:06.382]                     else if (inherits(cond, "condition")) {
[18:02:06.382]                       if (!is.null(pattern)) {
[18:02:06.382]                         computeRestarts <- base::computeRestarts
[18:02:06.382]                         grepl <- base::grepl
[18:02:06.382]                         restarts <- computeRestarts(cond)
[18:02:06.382]                         for (restart in restarts) {
[18:02:06.382]                           name <- restart$name
[18:02:06.382]                           if (is.null(name)) 
[18:02:06.382]                             next
[18:02:06.382]                           if (!grepl(pattern, name)) 
[18:02:06.382]                             next
[18:02:06.382]                           invokeRestart(restart)
[18:02:06.382]                           muffled <- TRUE
[18:02:06.382]                           break
[18:02:06.382]                         }
[18:02:06.382]                       }
[18:02:06.382]                     }
[18:02:06.382]                     invisible(muffled)
[18:02:06.382]                   }
[18:02:06.382]                   muffleCondition(cond)
[18:02:06.382]                 })
[18:02:06.382]             }))
[18:02:06.382]             future::FutureResult(value = ...future.value$value, 
[18:02:06.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:06.382]                   ...future.rng), globalenv = if (FALSE) 
[18:02:06.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:06.382]                     ...future.globalenv.names))
[18:02:06.382]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:06.382]         }, condition = base::local({
[18:02:06.382]             c <- base::c
[18:02:06.382]             inherits <- base::inherits
[18:02:06.382]             invokeRestart <- base::invokeRestart
[18:02:06.382]             length <- base::length
[18:02:06.382]             list <- base::list
[18:02:06.382]             seq.int <- base::seq.int
[18:02:06.382]             signalCondition <- base::signalCondition
[18:02:06.382]             sys.calls <- base::sys.calls
[18:02:06.382]             `[[` <- base::`[[`
[18:02:06.382]             `+` <- base::`+`
[18:02:06.382]             `<<-` <- base::`<<-`
[18:02:06.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:06.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:06.382]                   3L)]
[18:02:06.382]             }
[18:02:06.382]             function(cond) {
[18:02:06.382]                 is_error <- inherits(cond, "error")
[18:02:06.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:06.382]                   NULL)
[18:02:06.382]                 if (is_error) {
[18:02:06.382]                   sessionInformation <- function() {
[18:02:06.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:06.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:06.382]                       search = base::search(), system = base::Sys.info())
[18:02:06.382]                   }
[18:02:06.382]                   ...future.conditions[[length(...future.conditions) + 
[18:02:06.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:06.382]                     cond$call), session = sessionInformation(), 
[18:02:06.382]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:06.382]                   signalCondition(cond)
[18:02:06.382]                 }
[18:02:06.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:06.382]                 "immediateCondition"))) {
[18:02:06.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:06.382]                   ...future.conditions[[length(...future.conditions) + 
[18:02:06.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:06.382]                   if (TRUE && !signal) {
[18:02:06.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:06.382]                     {
[18:02:06.382]                       inherits <- base::inherits
[18:02:06.382]                       invokeRestart <- base::invokeRestart
[18:02:06.382]                       is.null <- base::is.null
[18:02:06.382]                       muffled <- FALSE
[18:02:06.382]                       if (inherits(cond, "message")) {
[18:02:06.382]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:06.382]                         if (muffled) 
[18:02:06.382]                           invokeRestart("muffleMessage")
[18:02:06.382]                       }
[18:02:06.382]                       else if (inherits(cond, "warning")) {
[18:02:06.382]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:06.382]                         if (muffled) 
[18:02:06.382]                           invokeRestart("muffleWarning")
[18:02:06.382]                       }
[18:02:06.382]                       else if (inherits(cond, "condition")) {
[18:02:06.382]                         if (!is.null(pattern)) {
[18:02:06.382]                           computeRestarts <- base::computeRestarts
[18:02:06.382]                           grepl <- base::grepl
[18:02:06.382]                           restarts <- computeRestarts(cond)
[18:02:06.382]                           for (restart in restarts) {
[18:02:06.382]                             name <- restart$name
[18:02:06.382]                             if (is.null(name)) 
[18:02:06.382]                               next
[18:02:06.382]                             if (!grepl(pattern, name)) 
[18:02:06.382]                               next
[18:02:06.382]                             invokeRestart(restart)
[18:02:06.382]                             muffled <- TRUE
[18:02:06.382]                             break
[18:02:06.382]                           }
[18:02:06.382]                         }
[18:02:06.382]                       }
[18:02:06.382]                       invisible(muffled)
[18:02:06.382]                     }
[18:02:06.382]                     muffleCondition(cond, pattern = "^muffle")
[18:02:06.382]                   }
[18:02:06.382]                 }
[18:02:06.382]                 else {
[18:02:06.382]                   if (TRUE) {
[18:02:06.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:06.382]                     {
[18:02:06.382]                       inherits <- base::inherits
[18:02:06.382]                       invokeRestart <- base::invokeRestart
[18:02:06.382]                       is.null <- base::is.null
[18:02:06.382]                       muffled <- FALSE
[18:02:06.382]                       if (inherits(cond, "message")) {
[18:02:06.382]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:06.382]                         if (muffled) 
[18:02:06.382]                           invokeRestart("muffleMessage")
[18:02:06.382]                       }
[18:02:06.382]                       else if (inherits(cond, "warning")) {
[18:02:06.382]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:06.382]                         if (muffled) 
[18:02:06.382]                           invokeRestart("muffleWarning")
[18:02:06.382]                       }
[18:02:06.382]                       else if (inherits(cond, "condition")) {
[18:02:06.382]                         if (!is.null(pattern)) {
[18:02:06.382]                           computeRestarts <- base::computeRestarts
[18:02:06.382]                           grepl <- base::grepl
[18:02:06.382]                           restarts <- computeRestarts(cond)
[18:02:06.382]                           for (restart in restarts) {
[18:02:06.382]                             name <- restart$name
[18:02:06.382]                             if (is.null(name)) 
[18:02:06.382]                               next
[18:02:06.382]                             if (!grepl(pattern, name)) 
[18:02:06.382]                               next
[18:02:06.382]                             invokeRestart(restart)
[18:02:06.382]                             muffled <- TRUE
[18:02:06.382]                             break
[18:02:06.382]                           }
[18:02:06.382]                         }
[18:02:06.382]                       }
[18:02:06.382]                       invisible(muffled)
[18:02:06.382]                     }
[18:02:06.382]                     muffleCondition(cond, pattern = "^muffle")
[18:02:06.382]                   }
[18:02:06.382]                 }
[18:02:06.382]             }
[18:02:06.382]         }))
[18:02:06.382]     }, error = function(ex) {
[18:02:06.382]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:06.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:06.382]                 ...future.rng), started = ...future.startTime, 
[18:02:06.382]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:06.382]             version = "1.8"), class = "FutureResult")
[18:02:06.382]     }, finally = {
[18:02:06.382]         if (!identical(...future.workdir, getwd())) 
[18:02:06.382]             setwd(...future.workdir)
[18:02:06.382]         {
[18:02:06.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:06.382]                 ...future.oldOptions$nwarnings <- NULL
[18:02:06.382]             }
[18:02:06.382]             base::options(...future.oldOptions)
[18:02:06.382]             if (.Platform$OS.type == "windows") {
[18:02:06.382]                 old_names <- names(...future.oldEnvVars)
[18:02:06.382]                 envs <- base::Sys.getenv()
[18:02:06.382]                 names <- names(envs)
[18:02:06.382]                 common <- intersect(names, old_names)
[18:02:06.382]                 added <- setdiff(names, old_names)
[18:02:06.382]                 removed <- setdiff(old_names, names)
[18:02:06.382]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:06.382]                   envs[common]]
[18:02:06.382]                 NAMES <- toupper(changed)
[18:02:06.382]                 args <- list()
[18:02:06.382]                 for (kk in seq_along(NAMES)) {
[18:02:06.382]                   name <- changed[[kk]]
[18:02:06.382]                   NAME <- NAMES[[kk]]
[18:02:06.382]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:06.382]                     next
[18:02:06.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:06.382]                 }
[18:02:06.382]                 NAMES <- toupper(added)
[18:02:06.382]                 for (kk in seq_along(NAMES)) {
[18:02:06.382]                   name <- added[[kk]]
[18:02:06.382]                   NAME <- NAMES[[kk]]
[18:02:06.382]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:06.382]                     next
[18:02:06.382]                   args[[name]] <- ""
[18:02:06.382]                 }
[18:02:06.382]                 NAMES <- toupper(removed)
[18:02:06.382]                 for (kk in seq_along(NAMES)) {
[18:02:06.382]                   name <- removed[[kk]]
[18:02:06.382]                   NAME <- NAMES[[kk]]
[18:02:06.382]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:06.382]                     next
[18:02:06.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:06.382]                 }
[18:02:06.382]                 if (length(args) > 0) 
[18:02:06.382]                   base::do.call(base::Sys.setenv, args = args)
[18:02:06.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:06.382]             }
[18:02:06.382]             else {
[18:02:06.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:06.382]             }
[18:02:06.382]             {
[18:02:06.382]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:06.382]                   0L) {
[18:02:06.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:06.382]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:06.382]                   base::options(opts)
[18:02:06.382]                 }
[18:02:06.382]                 {
[18:02:06.382]                   {
[18:02:06.382]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:06.382]                     NULL
[18:02:06.382]                   }
[18:02:06.382]                   options(future.plan = NULL)
[18:02:06.382]                   if (is.na(NA_character_)) 
[18:02:06.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:06.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:06.382]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:06.382]                     .init = FALSE)
[18:02:06.382]                 }
[18:02:06.382]             }
[18:02:06.382]         }
[18:02:06.382]     })
[18:02:06.382]     if (TRUE) {
[18:02:06.382]         base::sink(type = "output", split = FALSE)
[18:02:06.382]         if (TRUE) {
[18:02:06.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:06.382]         }
[18:02:06.382]         else {
[18:02:06.382]             ...future.result["stdout"] <- base::list(NULL)
[18:02:06.382]         }
[18:02:06.382]         base::close(...future.stdout)
[18:02:06.382]         ...future.stdout <- NULL
[18:02:06.382]     }
[18:02:06.382]     ...future.result$conditions <- ...future.conditions
[18:02:06.382]     ...future.result$finished <- base::Sys.time()
[18:02:06.382]     ...future.result
[18:02:06.382] }
[18:02:06.387] Exporting 11 global objects (103.08 KiB) to cluster node #2 ...
[18:02:06.387] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[18:02:06.430] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[18:02:06.430] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ...
[18:02:06.431] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ... DONE
[18:02:06.431] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[18:02:06.432] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[18:02:06.433] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[18:02:06.474] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[18:02:06.475] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[18:02:06.516] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[18:02:06.517] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[18:02:06.518] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[18:02:06.519] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[18:02:06.520] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[18:02:06.521] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:06.522] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:06.522] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[18:02:06.523] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[18:02:06.524] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:06.525] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:06.525] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:06.527] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:06.527] Exporting 11 global objects (103.08 KiB) to cluster node #2 ... DONE
[18:02:06.528] MultisessionFuture started
[18:02:06.529] - Launch lazy future ... done
[18:02:06.529] run() for ‘MultisessionFuture’ ... done
[18:02:06.530] Created future:
[18:02:06.530] MultisessionFuture:
[18:02:06.530] Label: ‘future_vapply-2’
[18:02:06.530] Expression:
[18:02:06.530] {
[18:02:06.530]     do.call(function(...) {
[18:02:06.530]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:06.530]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:06.530]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:06.530]             on.exit(options(oopts), add = TRUE)
[18:02:06.530]         }
[18:02:06.530]         {
[18:02:06.530]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:06.530]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:06.530]                 ...future.FUN(...future.X_jj, ...)
[18:02:06.530]             })
[18:02:06.530]         }
[18:02:06.530]     }, args = future.call.arguments)
[18:02:06.530] }
[18:02:06.530] Lazy evaluation: FALSE
[18:02:06.530] Asynchronous evaluation: TRUE
[18:02:06.530] Local evaluation: TRUE
[18:02:06.530] Environment: R_GlobalEnv
[18:02:06.530] Capture standard output: TRUE
[18:02:06.530] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:06.530] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:06.530] Packages: 1 packages (‘future.apply’)
[18:02:06.530] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:06.530] Resolved: FALSE
[18:02:06.530] Value: <not collected>
[18:02:06.530] Conditions captured: <none>
[18:02:06.530] Early signaling: FALSE
[18:02:06.530] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:06.530] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:06.545] Chunk #2 of 2 ... DONE
[18:02:06.545] Launching 2 futures (chunks) ... DONE
[18:02:06.545] Resolving 2 futures (chunks) ...
[18:02:06.546] resolve() on list ...
[18:02:06.546]  recursive: 0
[18:02:06.546]  length: 2
[18:02:06.547] 
[18:02:06.548] receiveMessageFromWorker() for ClusterFuture ...
[18:02:06.549] - Validating connection of MultisessionFuture
[18:02:06.549] - received message: FutureResult
[18:02:06.550] - Received FutureResult
[18:02:06.550] - Erased future from FutureRegistry
[18:02:06.550] result() for ClusterFuture ...
[18:02:06.551] - result already collected: FutureResult
[18:02:06.551] result() for ClusterFuture ... done
[18:02:06.551] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:06.551] Future #1
[18:02:06.552] result() for ClusterFuture ...
[18:02:06.552] - result already collected: FutureResult
[18:02:06.552] result() for ClusterFuture ... done
[18:02:06.553] result() for ClusterFuture ...
[18:02:06.553] - result already collected: FutureResult
[18:02:06.553] result() for ClusterFuture ... done
[18:02:06.554] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:06.554] - nx: 2
[18:02:06.554] - relay: TRUE
[18:02:06.554] - stdout: TRUE
[18:02:06.555] - signal: TRUE
[18:02:06.555] - resignal: FALSE
[18:02:06.555] - force: TRUE
[18:02:06.556] - relayed: [n=2] FALSE, FALSE
[18:02:06.556] - queued futures: [n=2] FALSE, FALSE
[18:02:06.556]  - until=1
[18:02:06.557]  - relaying element #1
[18:02:06.557] result() for ClusterFuture ...
[18:02:06.557] - result already collected: FutureResult
[18:02:06.557] result() for ClusterFuture ... done
[18:02:06.558] result() for ClusterFuture ...
[18:02:06.558] - result already collected: FutureResult
[18:02:06.558] result() for ClusterFuture ... done
[18:02:06.559] result() for ClusterFuture ...
[18:02:06.559] - result already collected: FutureResult
[18:02:06.559] result() for ClusterFuture ... done
[18:02:06.560] result() for ClusterFuture ...
[18:02:06.560] - result already collected: FutureResult
[18:02:06.560] result() for ClusterFuture ... done
[18:02:06.561] - relayed: [n=2] TRUE, FALSE
[18:02:06.561] - queued futures: [n=2] TRUE, FALSE
[18:02:06.561] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:06.562]  length: 1 (resolved future 1)
[18:02:06.573] receiveMessageFromWorker() for ClusterFuture ...
[18:02:06.573] - Validating connection of MultisessionFuture
[18:02:06.574] - received message: FutureResult
[18:02:06.574] - Received FutureResult
[18:02:06.575] - Erased future from FutureRegistry
[18:02:06.575] result() for ClusterFuture ...
[18:02:06.575] - result already collected: FutureResult
[18:02:06.576] result() for ClusterFuture ... done
[18:02:06.576] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:06.576] Future #2
[18:02:06.577] result() for ClusterFuture ...
[18:02:06.577] - result already collected: FutureResult
[18:02:06.577] result() for ClusterFuture ... done
[18:02:06.578] result() for ClusterFuture ...
[18:02:06.578] - result already collected: FutureResult
[18:02:06.578] result() for ClusterFuture ... done
[18:02:06.579] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:06.579] - nx: 2
[18:02:06.579] - relay: TRUE
[18:02:06.580] - stdout: TRUE
[18:02:06.580] - signal: TRUE
[18:02:06.580] - resignal: FALSE
[18:02:06.580] - force: TRUE
[18:02:06.581] - relayed: [n=2] TRUE, FALSE
[18:02:06.581] - queued futures: [n=2] TRUE, FALSE
[18:02:06.581]  - until=2
[18:02:06.582]  - relaying element #2
[18:02:06.582] result() for ClusterFuture ...
[18:02:06.582] - result already collected: FutureResult
[18:02:06.582] result() for ClusterFuture ... done
[18:02:06.583] result() for ClusterFuture ...
[18:02:06.583] - result already collected: FutureResult
[18:02:06.583] result() for ClusterFuture ... done
[18:02:06.584] result() for ClusterFuture ...
[18:02:06.584] - result already collected: FutureResult
[18:02:06.584] result() for ClusterFuture ... done
[18:02:06.585] result() for ClusterFuture ...
[18:02:06.585] - result already collected: FutureResult
[18:02:06.585] result() for ClusterFuture ... done
[18:02:06.586] - relayed: [n=2] TRUE, TRUE
[18:02:06.586] - queued futures: [n=2] TRUE, TRUE
[18:02:06.586] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:06.587]  length: 0 (resolved future 2)
[18:02:06.587] Relaying remaining futures
[18:02:06.587] signalConditionsASAP(NULL, pos=0) ...
[18:02:06.587] - nx: 2
[18:02:06.588] - relay: TRUE
[18:02:06.588] - stdout: TRUE
[18:02:06.588] - signal: TRUE
[18:02:06.589] - resignal: FALSE
[18:02:06.589] - force: TRUE
[18:02:06.589] - relayed: [n=2] TRUE, TRUE
[18:02:06.589] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:06.590] - relayed: [n=2] TRUE, TRUE
[18:02:06.590] - queued futures: [n=2] TRUE, TRUE
[18:02:06.591] signalConditionsASAP(NULL, pos=0) ... done
[18:02:06.591] resolve() on list ... DONE
[18:02:06.591] result() for ClusterFuture ...
[18:02:06.591] - result already collected: FutureResult
[18:02:06.592] result() for ClusterFuture ... done
[18:02:06.592] result() for ClusterFuture ...
[18:02:06.592] - result already collected: FutureResult
[18:02:06.593] result() for ClusterFuture ... done
[18:02:06.593] result() for ClusterFuture ...
[18:02:06.593] - result already collected: FutureResult
[18:02:06.594] result() for ClusterFuture ... done
[18:02:06.594] result() for ClusterFuture ...
[18:02:06.594] - result already collected: FutureResult
[18:02:06.594] result() for ClusterFuture ... done
[18:02:06.595]  - Number of value chunks collected: 2
[18:02:06.595] Resolving 2 futures (chunks) ... DONE
[18:02:06.595] Reducing values from 2 chunks ...
[18:02:06.596]  - Number of values collected after concatenation: 10
[18:02:06.596]  - Number of values expected: 10
[18:02:06.596] Reducing values from 2 chunks ... DONE
[18:02:06.597] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[18:02:06.603] future_lapply() ...
[18:02:06.616] Number of chunks: 2
[18:02:06.616] getGlobalsAndPackagesXApply() ...
[18:02:06.616]  - future.globals: TRUE
[18:02:06.616] getGlobalsAndPackages() ...
[18:02:06.617] Searching for globals...
[18:02:06.625] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[18:02:06.625] Searching for globals ... DONE
[18:02:06.625] Resolving globals: FALSE
[18:02:06.627] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[18:02:06.628] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:06.628] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:06.629] - packages: [2] ‘stats’, ‘future.apply’
[18:02:06.629] getGlobalsAndPackages() ... DONE
[18:02:06.629]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:06.629]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[18:02:06.630] Finding globals ... DONE
[18:02:06.630]  - use_args: TRUE
[18:02:06.630]  - Getting '...' globals ...
[18:02:06.631] resolve() on list ...
[18:02:06.631]  recursive: 0
[18:02:06.631]  length: 1
[18:02:06.631]  elements: ‘...’
[18:02:06.632]  length: 0 (resolved future 1)
[18:02:06.632] resolve() on list ... DONE
[18:02:06.632]    - '...' content: [n=0] 
[18:02:06.632] List of 1
[18:02:06.632]  $ ...: list()
[18:02:06.632]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:06.632]  - attr(*, "where")=List of 1
[18:02:06.632]   ..$ ...:<environment: 0x6183c2cf45d8> 
[18:02:06.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:06.632]  - attr(*, "resolved")= logi TRUE
[18:02:06.632]  - attr(*, "total_size")= num NA
[18:02:06.638]  - Getting '...' globals ... DONE
[18:02:06.638] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:06.638] List of 8
[18:02:06.638]  $ ...future.FUN:function (x, ...)  
[18:02:06.638]  $ x_FUN        :function (x, ...)  
[18:02:06.638]  $ times        : int 5
[18:02:06.638]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:06.638]  $ stop_if_not  :function (...)  
[18:02:06.638]  $ dim          : NULL
[18:02:06.638]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:02:06.638]  $ ...          : list()
[18:02:06.638]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:06.638]  - attr(*, "where")=List of 8
[18:02:06.638]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:06.638]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:06.638]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:06.638]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:06.638]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:06.638]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:06.638]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:06.638]   ..$ ...          :<environment: 0x6183c2cf45d8> 
[18:02:06.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:06.638]  - attr(*, "resolved")= logi FALSE
[18:02:06.638]  - attr(*, "total_size")= num 95528
[18:02:06.650] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[18:02:06.651] getGlobalsAndPackagesXApply() ... DONE
[18:02:06.651] Number of futures (= number of chunks): 2
[18:02:06.652] Launching 2 futures (chunks) ...
[18:02:06.652] Chunk #1 of 2 ...
[18:02:06.652]  - Finding globals in 'X' for chunk #1 ...
[18:02:06.652] getGlobalsAndPackages() ...
[18:02:06.653] Searching for globals...
[18:02:06.653] 
[18:02:06.653] Searching for globals ... DONE
[18:02:06.654] - globals: [0] <none>
[18:02:06.654] getGlobalsAndPackages() ... DONE
[18:02:06.654]    + additional globals found: [n=0] 
[18:02:06.654]    + additional namespaces needed: [n=0] 
[18:02:06.654]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:06.655]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:06.655]  - seeds: <none>
[18:02:06.655]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:06.655] getGlobalsAndPackages() ...
[18:02:06.655] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:06.656] Resolving globals: FALSE
[18:02:06.656] Tweak future expression to call with '...' arguments ...
[18:02:06.656] {
[18:02:06.656]     do.call(function(...) {
[18:02:06.656]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:06.656]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:06.656]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:06.656]             on.exit(options(oopts), add = TRUE)
[18:02:06.656]         }
[18:02:06.656]         {
[18:02:06.656]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:06.656]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:06.656]                 ...future.FUN(...future.X_jj, ...)
[18:02:06.656]             })
[18:02:06.656]         }
[18:02:06.656]     }, args = future.call.arguments)
[18:02:06.656] }
[18:02:06.657] Tweak future expression to call with '...' arguments ... DONE
[18:02:06.658] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:06.658] - packages: [2] ‘stats’, ‘future.apply’
[18:02:06.658] getGlobalsAndPackages() ... DONE
[18:02:06.662] run() for ‘Future’ ...
[18:02:06.662] - state: ‘created’
[18:02:06.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:06.686] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:06.687] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:06.687]   - Field: ‘node’
[18:02:06.687]   - Field: ‘label’
[18:02:06.687]   - Field: ‘local’
[18:02:06.687]   - Field: ‘owner’
[18:02:06.688]   - Field: ‘envir’
[18:02:06.688]   - Field: ‘workers’
[18:02:06.688]   - Field: ‘packages’
[18:02:06.688]   - Field: ‘gc’
[18:02:06.688]   - Field: ‘conditions’
[18:02:06.689]   - Field: ‘persistent’
[18:02:06.689]   - Field: ‘expr’
[18:02:06.689]   - Field: ‘uuid’
[18:02:06.689]   - Field: ‘seed’
[18:02:06.689]   - Field: ‘version’
[18:02:06.690]   - Field: ‘result’
[18:02:06.690]   - Field: ‘asynchronous’
[18:02:06.690]   - Field: ‘calls’
[18:02:06.690]   - Field: ‘globals’
[18:02:06.690]   - Field: ‘stdout’
[18:02:06.691]   - Field: ‘earlySignal’
[18:02:06.691]   - Field: ‘lazy’
[18:02:06.691]   - Field: ‘state’
[18:02:06.691] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:06.691] - Launch lazy future ...
[18:02:06.692] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[18:02:06.692] Packages needed by future strategies (n = 0): <none>
[18:02:06.693] {
[18:02:06.693]     {
[18:02:06.693]         {
[18:02:06.693]             ...future.startTime <- base::Sys.time()
[18:02:06.693]             {
[18:02:06.693]                 {
[18:02:06.693]                   {
[18:02:06.693]                     {
[18:02:06.693]                       {
[18:02:06.693]                         base::local({
[18:02:06.693]                           has_future <- base::requireNamespace("future", 
[18:02:06.693]                             quietly = TRUE)
[18:02:06.693]                           if (has_future) {
[18:02:06.693]                             ns <- base::getNamespace("future")
[18:02:06.693]                             version <- ns[[".package"]][["version"]]
[18:02:06.693]                             if (is.null(version)) 
[18:02:06.693]                               version <- utils::packageVersion("future")
[18:02:06.693]                           }
[18:02:06.693]                           else {
[18:02:06.693]                             version <- NULL
[18:02:06.693]                           }
[18:02:06.693]                           if (!has_future || version < "1.8.0") {
[18:02:06.693]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:06.693]                               "", base::R.version$version.string), 
[18:02:06.693]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:06.693]                                 base::R.version$platform, 8 * 
[18:02:06.693]                                   base::.Machine$sizeof.pointer), 
[18:02:06.693]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:06.693]                                 "release", "version")], collapse = " "), 
[18:02:06.693]                               hostname = base::Sys.info()[["nodename"]])
[18:02:06.693]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:06.693]                               info)
[18:02:06.693]                             info <- base::paste(info, collapse = "; ")
[18:02:06.693]                             if (!has_future) {
[18:02:06.693]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:06.693]                                 info)
[18:02:06.693]                             }
[18:02:06.693]                             else {
[18:02:06.693]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:06.693]                                 info, version)
[18:02:06.693]                             }
[18:02:06.693]                             base::stop(msg)
[18:02:06.693]                           }
[18:02:06.693]                         })
[18:02:06.693]                       }
[18:02:06.693]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:06.693]                       base::options(mc.cores = 1L)
[18:02:06.693]                     }
[18:02:06.693]                     base::local({
[18:02:06.693]                       for (pkg in c("stats", "future.apply")) {
[18:02:06.693]                         base::loadNamespace(pkg)
[18:02:06.693]                         base::library(pkg, character.only = TRUE)
[18:02:06.693]                       }
[18:02:06.693]                     })
[18:02:06.693]                   }
[18:02:06.693]                   ...future.strategy.old <- future::plan("list")
[18:02:06.693]                   options(future.plan = NULL)
[18:02:06.693]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:06.693]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:06.693]                 }
[18:02:06.693]                 ...future.workdir <- getwd()
[18:02:06.693]             }
[18:02:06.693]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:06.693]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:06.693]         }
[18:02:06.693]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:06.693]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:06.693]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:06.693]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:06.693]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:06.693]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:06.693]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:06.693]             base::names(...future.oldOptions))
[18:02:06.693]     }
[18:02:06.693]     if (FALSE) {
[18:02:06.693]     }
[18:02:06.693]     else {
[18:02:06.693]         if (TRUE) {
[18:02:06.693]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:06.693]                 open = "w")
[18:02:06.693]         }
[18:02:06.693]         else {
[18:02:06.693]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:06.693]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:06.693]         }
[18:02:06.693]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:06.693]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:06.693]             base::sink(type = "output", split = FALSE)
[18:02:06.693]             base::close(...future.stdout)
[18:02:06.693]         }, add = TRUE)
[18:02:06.693]     }
[18:02:06.693]     ...future.frame <- base::sys.nframe()
[18:02:06.693]     ...future.conditions <- base::list()
[18:02:06.693]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:06.693]     if (FALSE) {
[18:02:06.693]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:06.693]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:06.693]     }
[18:02:06.693]     ...future.result <- base::tryCatch({
[18:02:06.693]         base::withCallingHandlers({
[18:02:06.693]             ...future.value <- base::withVisible(base::local({
[18:02:06.693]                 ...future.makeSendCondition <- base::local({
[18:02:06.693]                   sendCondition <- NULL
[18:02:06.693]                   function(frame = 1L) {
[18:02:06.693]                     if (is.function(sendCondition)) 
[18:02:06.693]                       return(sendCondition)
[18:02:06.693]                     ns <- getNamespace("parallel")
[18:02:06.693]                     if (exists("sendData", mode = "function", 
[18:02:06.693]                       envir = ns)) {
[18:02:06.693]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:06.693]                         envir = ns)
[18:02:06.693]                       envir <- sys.frame(frame)
[18:02:06.693]                       master <- NULL
[18:02:06.693]                       while (!identical(envir, .GlobalEnv) && 
[18:02:06.693]                         !identical(envir, emptyenv())) {
[18:02:06.693]                         if (exists("master", mode = "list", envir = envir, 
[18:02:06.693]                           inherits = FALSE)) {
[18:02:06.693]                           master <- get("master", mode = "list", 
[18:02:06.693]                             envir = envir, inherits = FALSE)
[18:02:06.693]                           if (inherits(master, c("SOCKnode", 
[18:02:06.693]                             "SOCK0node"))) {
[18:02:06.693]                             sendCondition <<- function(cond) {
[18:02:06.693]                               data <- list(type = "VALUE", value = cond, 
[18:02:06.693]                                 success = TRUE)
[18:02:06.693]                               parallel_sendData(master, data)
[18:02:06.693]                             }
[18:02:06.693]                             return(sendCondition)
[18:02:06.693]                           }
[18:02:06.693]                         }
[18:02:06.693]                         frame <- frame + 1L
[18:02:06.693]                         envir <- sys.frame(frame)
[18:02:06.693]                       }
[18:02:06.693]                     }
[18:02:06.693]                     sendCondition <<- function(cond) NULL
[18:02:06.693]                   }
[18:02:06.693]                 })
[18:02:06.693]                 withCallingHandlers({
[18:02:06.693]                   {
[18:02:06.693]                     do.call(function(...) {
[18:02:06.693]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:06.693]                       if (!identical(...future.globals.maxSize.org, 
[18:02:06.693]                         ...future.globals.maxSize)) {
[18:02:06.693]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:06.693]                         on.exit(options(oopts), add = TRUE)
[18:02:06.693]                       }
[18:02:06.693]                       {
[18:02:06.693]                         lapply(seq_along(...future.elements_ii), 
[18:02:06.693]                           FUN = function(jj) {
[18:02:06.693]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:06.693]                             ...future.FUN(...future.X_jj, ...)
[18:02:06.693]                           })
[18:02:06.693]                       }
[18:02:06.693]                     }, args = future.call.arguments)
[18:02:06.693]                   }
[18:02:06.693]                 }, immediateCondition = function(cond) {
[18:02:06.693]                   sendCondition <- ...future.makeSendCondition()
[18:02:06.693]                   sendCondition(cond)
[18:02:06.693]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:06.693]                   {
[18:02:06.693]                     inherits <- base::inherits
[18:02:06.693]                     invokeRestart <- base::invokeRestart
[18:02:06.693]                     is.null <- base::is.null
[18:02:06.693]                     muffled <- FALSE
[18:02:06.693]                     if (inherits(cond, "message")) {
[18:02:06.693]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:06.693]                       if (muffled) 
[18:02:06.693]                         invokeRestart("muffleMessage")
[18:02:06.693]                     }
[18:02:06.693]                     else if (inherits(cond, "warning")) {
[18:02:06.693]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:06.693]                       if (muffled) 
[18:02:06.693]                         invokeRestart("muffleWarning")
[18:02:06.693]                     }
[18:02:06.693]                     else if (inherits(cond, "condition")) {
[18:02:06.693]                       if (!is.null(pattern)) {
[18:02:06.693]                         computeRestarts <- base::computeRestarts
[18:02:06.693]                         grepl <- base::grepl
[18:02:06.693]                         restarts <- computeRestarts(cond)
[18:02:06.693]                         for (restart in restarts) {
[18:02:06.693]                           name <- restart$name
[18:02:06.693]                           if (is.null(name)) 
[18:02:06.693]                             next
[18:02:06.693]                           if (!grepl(pattern, name)) 
[18:02:06.693]                             next
[18:02:06.693]                           invokeRestart(restart)
[18:02:06.693]                           muffled <- TRUE
[18:02:06.693]                           break
[18:02:06.693]                         }
[18:02:06.693]                       }
[18:02:06.693]                     }
[18:02:06.693]                     invisible(muffled)
[18:02:06.693]                   }
[18:02:06.693]                   muffleCondition(cond)
[18:02:06.693]                 })
[18:02:06.693]             }))
[18:02:06.693]             future::FutureResult(value = ...future.value$value, 
[18:02:06.693]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:06.693]                   ...future.rng), globalenv = if (FALSE) 
[18:02:06.693]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:06.693]                     ...future.globalenv.names))
[18:02:06.693]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:06.693]         }, condition = base::local({
[18:02:06.693]             c <- base::c
[18:02:06.693]             inherits <- base::inherits
[18:02:06.693]             invokeRestart <- base::invokeRestart
[18:02:06.693]             length <- base::length
[18:02:06.693]             list <- base::list
[18:02:06.693]             seq.int <- base::seq.int
[18:02:06.693]             signalCondition <- base::signalCondition
[18:02:06.693]             sys.calls <- base::sys.calls
[18:02:06.693]             `[[` <- base::`[[`
[18:02:06.693]             `+` <- base::`+`
[18:02:06.693]             `<<-` <- base::`<<-`
[18:02:06.693]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:06.693]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:06.693]                   3L)]
[18:02:06.693]             }
[18:02:06.693]             function(cond) {
[18:02:06.693]                 is_error <- inherits(cond, "error")
[18:02:06.693]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:06.693]                   NULL)
[18:02:06.693]                 if (is_error) {
[18:02:06.693]                   sessionInformation <- function() {
[18:02:06.693]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:06.693]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:06.693]                       search = base::search(), system = base::Sys.info())
[18:02:06.693]                   }
[18:02:06.693]                   ...future.conditions[[length(...future.conditions) + 
[18:02:06.693]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:06.693]                     cond$call), session = sessionInformation(), 
[18:02:06.693]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:06.693]                   signalCondition(cond)
[18:02:06.693]                 }
[18:02:06.693]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:06.693]                 "immediateCondition"))) {
[18:02:06.693]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:06.693]                   ...future.conditions[[length(...future.conditions) + 
[18:02:06.693]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:06.693]                   if (TRUE && !signal) {
[18:02:06.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:06.693]                     {
[18:02:06.693]                       inherits <- base::inherits
[18:02:06.693]                       invokeRestart <- base::invokeRestart
[18:02:06.693]                       is.null <- base::is.null
[18:02:06.693]                       muffled <- FALSE
[18:02:06.693]                       if (inherits(cond, "message")) {
[18:02:06.693]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:06.693]                         if (muffled) 
[18:02:06.693]                           invokeRestart("muffleMessage")
[18:02:06.693]                       }
[18:02:06.693]                       else if (inherits(cond, "warning")) {
[18:02:06.693]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:06.693]                         if (muffled) 
[18:02:06.693]                           invokeRestart("muffleWarning")
[18:02:06.693]                       }
[18:02:06.693]                       else if (inherits(cond, "condition")) {
[18:02:06.693]                         if (!is.null(pattern)) {
[18:02:06.693]                           computeRestarts <- base::computeRestarts
[18:02:06.693]                           grepl <- base::grepl
[18:02:06.693]                           restarts <- computeRestarts(cond)
[18:02:06.693]                           for (restart in restarts) {
[18:02:06.693]                             name <- restart$name
[18:02:06.693]                             if (is.null(name)) 
[18:02:06.693]                               next
[18:02:06.693]                             if (!grepl(pattern, name)) 
[18:02:06.693]                               next
[18:02:06.693]                             invokeRestart(restart)
[18:02:06.693]                             muffled <- TRUE
[18:02:06.693]                             break
[18:02:06.693]                           }
[18:02:06.693]                         }
[18:02:06.693]                       }
[18:02:06.693]                       invisible(muffled)
[18:02:06.693]                     }
[18:02:06.693]                     muffleCondition(cond, pattern = "^muffle")
[18:02:06.693]                   }
[18:02:06.693]                 }
[18:02:06.693]                 else {
[18:02:06.693]                   if (TRUE) {
[18:02:06.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:06.693]                     {
[18:02:06.693]                       inherits <- base::inherits
[18:02:06.693]                       invokeRestart <- base::invokeRestart
[18:02:06.693]                       is.null <- base::is.null
[18:02:06.693]                       muffled <- FALSE
[18:02:06.693]                       if (inherits(cond, "message")) {
[18:02:06.693]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:06.693]                         if (muffled) 
[18:02:06.693]                           invokeRestart("muffleMessage")
[18:02:06.693]                       }
[18:02:06.693]                       else if (inherits(cond, "warning")) {
[18:02:06.693]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:06.693]                         if (muffled) 
[18:02:06.693]                           invokeRestart("muffleWarning")
[18:02:06.693]                       }
[18:02:06.693]                       else if (inherits(cond, "condition")) {
[18:02:06.693]                         if (!is.null(pattern)) {
[18:02:06.693]                           computeRestarts <- base::computeRestarts
[18:02:06.693]                           grepl <- base::grepl
[18:02:06.693]                           restarts <- computeRestarts(cond)
[18:02:06.693]                           for (restart in restarts) {
[18:02:06.693]                             name <- restart$name
[18:02:06.693]                             if (is.null(name)) 
[18:02:06.693]                               next
[18:02:06.693]                             if (!grepl(pattern, name)) 
[18:02:06.693]                               next
[18:02:06.693]                             invokeRestart(restart)
[18:02:06.693]                             muffled <- TRUE
[18:02:06.693]                             break
[18:02:06.693]                           }
[18:02:06.693]                         }
[18:02:06.693]                       }
[18:02:06.693]                       invisible(muffled)
[18:02:06.693]                     }
[18:02:06.693]                     muffleCondition(cond, pattern = "^muffle")
[18:02:06.693]                   }
[18:02:06.693]                 }
[18:02:06.693]             }
[18:02:06.693]         }))
[18:02:06.693]     }, error = function(ex) {
[18:02:06.693]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:06.693]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:06.693]                 ...future.rng), started = ...future.startTime, 
[18:02:06.693]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:06.693]             version = "1.8"), class = "FutureResult")
[18:02:06.693]     }, finally = {
[18:02:06.693]         if (!identical(...future.workdir, getwd())) 
[18:02:06.693]             setwd(...future.workdir)
[18:02:06.693]         {
[18:02:06.693]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:06.693]                 ...future.oldOptions$nwarnings <- NULL
[18:02:06.693]             }
[18:02:06.693]             base::options(...future.oldOptions)
[18:02:06.693]             if (.Platform$OS.type == "windows") {
[18:02:06.693]                 old_names <- names(...future.oldEnvVars)
[18:02:06.693]                 envs <- base::Sys.getenv()
[18:02:06.693]                 names <- names(envs)
[18:02:06.693]                 common <- intersect(names, old_names)
[18:02:06.693]                 added <- setdiff(names, old_names)
[18:02:06.693]                 removed <- setdiff(old_names, names)
[18:02:06.693]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:06.693]                   envs[common]]
[18:02:06.693]                 NAMES <- toupper(changed)
[18:02:06.693]                 args <- list()
[18:02:06.693]                 for (kk in seq_along(NAMES)) {
[18:02:06.693]                   name <- changed[[kk]]
[18:02:06.693]                   NAME <- NAMES[[kk]]
[18:02:06.693]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:06.693]                     next
[18:02:06.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:06.693]                 }
[18:02:06.693]                 NAMES <- toupper(added)
[18:02:06.693]                 for (kk in seq_along(NAMES)) {
[18:02:06.693]                   name <- added[[kk]]
[18:02:06.693]                   NAME <- NAMES[[kk]]
[18:02:06.693]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:06.693]                     next
[18:02:06.693]                   args[[name]] <- ""
[18:02:06.693]                 }
[18:02:06.693]                 NAMES <- toupper(removed)
[18:02:06.693]                 for (kk in seq_along(NAMES)) {
[18:02:06.693]                   name <- removed[[kk]]
[18:02:06.693]                   NAME <- NAMES[[kk]]
[18:02:06.693]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:06.693]                     next
[18:02:06.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:06.693]                 }
[18:02:06.693]                 if (length(args) > 0) 
[18:02:06.693]                   base::do.call(base::Sys.setenv, args = args)
[18:02:06.693]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:06.693]             }
[18:02:06.693]             else {
[18:02:06.693]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:06.693]             }
[18:02:06.693]             {
[18:02:06.693]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:06.693]                   0L) {
[18:02:06.693]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:06.693]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:06.693]                   base::options(opts)
[18:02:06.693]                 }
[18:02:06.693]                 {
[18:02:06.693]                   {
[18:02:06.693]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:06.693]                     NULL
[18:02:06.693]                   }
[18:02:06.693]                   options(future.plan = NULL)
[18:02:06.693]                   if (is.na(NA_character_)) 
[18:02:06.693]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:06.693]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:06.693]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:06.693]                     .init = FALSE)
[18:02:06.693]                 }
[18:02:06.693]             }
[18:02:06.693]         }
[18:02:06.693]     })
[18:02:06.693]     if (TRUE) {
[18:02:06.693]         base::sink(type = "output", split = FALSE)
[18:02:06.693]         if (TRUE) {
[18:02:06.693]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:06.693]         }
[18:02:06.693]         else {
[18:02:06.693]             ...future.result["stdout"] <- base::list(NULL)
[18:02:06.693]         }
[18:02:06.693]         base::close(...future.stdout)
[18:02:06.693]         ...future.stdout <- NULL
[18:02:06.693]     }
[18:02:06.693]     ...future.result$conditions <- ...future.conditions
[18:02:06.693]     ...future.result$finished <- base::Sys.time()
[18:02:06.693]     ...future.result
[18:02:06.693] }
[18:02:06.699] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[18:02:06.699] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[18:02:06.740] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[18:02:06.741] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[18:02:06.741] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[18:02:06.742] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[18:02:06.743] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[18:02:06.743] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[18:02:06.784] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[18:02:06.785] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[18:02:06.826] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[18:02:06.827] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[18:02:06.828] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[18:02:06.828] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[18:02:06.829] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[18:02:06.830] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:06.831] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:06.832] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[18:02:06.833] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[18:02:06.833] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:06.834] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:06.835] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:06.836] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:06.836] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[18:02:06.838] MultisessionFuture started
[18:02:06.838] - Launch lazy future ... done
[18:02:06.839] run() for ‘MultisessionFuture’ ... done
[18:02:06.839] Created future:
[18:02:06.839] MultisessionFuture:
[18:02:06.839] Label: ‘future_vapply-1’
[18:02:06.839] Expression:
[18:02:06.839] {
[18:02:06.839]     do.call(function(...) {
[18:02:06.839]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:06.839]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:06.839]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:06.839]             on.exit(options(oopts), add = TRUE)
[18:02:06.839]         }
[18:02:06.839]         {
[18:02:06.839]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:06.839]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:06.839]                 ...future.FUN(...future.X_jj, ...)
[18:02:06.839]             })
[18:02:06.839]         }
[18:02:06.839]     }, args = future.call.arguments)
[18:02:06.839] }
[18:02:06.839] Lazy evaluation: FALSE
[18:02:06.839] Asynchronous evaluation: TRUE
[18:02:06.839] Local evaluation: TRUE
[18:02:06.839] Environment: R_GlobalEnv
[18:02:06.839] Capture standard output: TRUE
[18:02:06.839] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:06.839] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:06.839] Packages: 2 packages (‘stats’, ‘future.apply’)
[18:02:06.839] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:06.839] Resolved: FALSE
[18:02:06.839] Value: <not collected>
[18:02:06.839] Conditions captured: <none>
[18:02:06.839] Early signaling: FALSE
[18:02:06.839] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:06.839] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:06.855] Chunk #1 of 2 ... DONE
[18:02:06.855] Chunk #2 of 2 ...
[18:02:06.856]  - Finding globals in 'X' for chunk #2 ...
[18:02:06.856] getGlobalsAndPackages() ...
[18:02:06.856] Searching for globals...
[18:02:06.857] 
[18:02:06.857] Searching for globals ... DONE
[18:02:06.858] - globals: [0] <none>
[18:02:06.858] getGlobalsAndPackages() ... DONE
[18:02:06.858]    + additional globals found: [n=0] 
[18:02:06.859]    + additional namespaces needed: [n=0] 
[18:02:06.859]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:06.859]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:06.860]  - seeds: <none>
[18:02:06.860]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:06.860] getGlobalsAndPackages() ...
[18:02:06.861] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:06.861] Resolving globals: FALSE
[18:02:06.861] Tweak future expression to call with '...' arguments ...
[18:02:06.862] {
[18:02:06.862]     do.call(function(...) {
[18:02:06.862]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:06.862]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:06.862]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:06.862]             on.exit(options(oopts), add = TRUE)
[18:02:06.862]         }
[18:02:06.862]         {
[18:02:06.862]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:06.862]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:06.862]                 ...future.FUN(...future.X_jj, ...)
[18:02:06.862]             })
[18:02:06.862]         }
[18:02:06.862]     }, args = future.call.arguments)
[18:02:06.862] }
[18:02:06.863] Tweak future expression to call with '...' arguments ... DONE
[18:02:06.864] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:06.865] - packages: [2] ‘stats’, ‘future.apply’
[18:02:06.865] getGlobalsAndPackages() ... DONE
[18:02:06.866] run() for ‘Future’ ...
[18:02:06.866] - state: ‘created’
[18:02:06.867] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:06.895] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:06.895] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:06.895]   - Field: ‘node’
[18:02:06.896]   - Field: ‘label’
[18:02:06.896]   - Field: ‘local’
[18:02:06.896]   - Field: ‘owner’
[18:02:06.896]   - Field: ‘envir’
[18:02:06.897]   - Field: ‘workers’
[18:02:06.897]   - Field: ‘packages’
[18:02:06.898]   - Field: ‘gc’
[18:02:06.898]   - Field: ‘conditions’
[18:02:06.898]   - Field: ‘persistent’
[18:02:06.898]   - Field: ‘expr’
[18:02:06.898]   - Field: ‘uuid’
[18:02:06.899]   - Field: ‘seed’
[18:02:06.899]   - Field: ‘version’
[18:02:06.899]   - Field: ‘result’
[18:02:06.899]   - Field: ‘asynchronous’
[18:02:06.900]   - Field: ‘calls’
[18:02:06.900]   - Field: ‘globals’
[18:02:06.900]   - Field: ‘stdout’
[18:02:06.900]   - Field: ‘earlySignal’
[18:02:06.900]   - Field: ‘lazy’
[18:02:06.901]   - Field: ‘state’
[18:02:06.901] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:06.901] - Launch lazy future ...
[18:02:06.902] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[18:02:06.902] Packages needed by future strategies (n = 0): <none>
[18:02:06.903] {
[18:02:06.903]     {
[18:02:06.903]         {
[18:02:06.903]             ...future.startTime <- base::Sys.time()
[18:02:06.903]             {
[18:02:06.903]                 {
[18:02:06.903]                   {
[18:02:06.903]                     {
[18:02:06.903]                       {
[18:02:06.903]                         base::local({
[18:02:06.903]                           has_future <- base::requireNamespace("future", 
[18:02:06.903]                             quietly = TRUE)
[18:02:06.903]                           if (has_future) {
[18:02:06.903]                             ns <- base::getNamespace("future")
[18:02:06.903]                             version <- ns[[".package"]][["version"]]
[18:02:06.903]                             if (is.null(version)) 
[18:02:06.903]                               version <- utils::packageVersion("future")
[18:02:06.903]                           }
[18:02:06.903]                           else {
[18:02:06.903]                             version <- NULL
[18:02:06.903]                           }
[18:02:06.903]                           if (!has_future || version < "1.8.0") {
[18:02:06.903]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:06.903]                               "", base::R.version$version.string), 
[18:02:06.903]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:06.903]                                 base::R.version$platform, 8 * 
[18:02:06.903]                                   base::.Machine$sizeof.pointer), 
[18:02:06.903]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:06.903]                                 "release", "version")], collapse = " "), 
[18:02:06.903]                               hostname = base::Sys.info()[["nodename"]])
[18:02:06.903]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:06.903]                               info)
[18:02:06.903]                             info <- base::paste(info, collapse = "; ")
[18:02:06.903]                             if (!has_future) {
[18:02:06.903]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:06.903]                                 info)
[18:02:06.903]                             }
[18:02:06.903]                             else {
[18:02:06.903]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:06.903]                                 info, version)
[18:02:06.903]                             }
[18:02:06.903]                             base::stop(msg)
[18:02:06.903]                           }
[18:02:06.903]                         })
[18:02:06.903]                       }
[18:02:06.903]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:06.903]                       base::options(mc.cores = 1L)
[18:02:06.903]                     }
[18:02:06.903]                     base::local({
[18:02:06.903]                       for (pkg in c("stats", "future.apply")) {
[18:02:06.903]                         base::loadNamespace(pkg)
[18:02:06.903]                         base::library(pkg, character.only = TRUE)
[18:02:06.903]                       }
[18:02:06.903]                     })
[18:02:06.903]                   }
[18:02:06.903]                   ...future.strategy.old <- future::plan("list")
[18:02:06.903]                   options(future.plan = NULL)
[18:02:06.903]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:06.903]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:06.903]                 }
[18:02:06.903]                 ...future.workdir <- getwd()
[18:02:06.903]             }
[18:02:06.903]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:06.903]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:06.903]         }
[18:02:06.903]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:06.903]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:06.903]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:06.903]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:06.903]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:06.903]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:06.903]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:06.903]             base::names(...future.oldOptions))
[18:02:06.903]     }
[18:02:06.903]     if (FALSE) {
[18:02:06.903]     }
[18:02:06.903]     else {
[18:02:06.903]         if (TRUE) {
[18:02:06.903]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:06.903]                 open = "w")
[18:02:06.903]         }
[18:02:06.903]         else {
[18:02:06.903]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:06.903]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:06.903]         }
[18:02:06.903]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:06.903]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:06.903]             base::sink(type = "output", split = FALSE)
[18:02:06.903]             base::close(...future.stdout)
[18:02:06.903]         }, add = TRUE)
[18:02:06.903]     }
[18:02:06.903]     ...future.frame <- base::sys.nframe()
[18:02:06.903]     ...future.conditions <- base::list()
[18:02:06.903]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:06.903]     if (FALSE) {
[18:02:06.903]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:06.903]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:06.903]     }
[18:02:06.903]     ...future.result <- base::tryCatch({
[18:02:06.903]         base::withCallingHandlers({
[18:02:06.903]             ...future.value <- base::withVisible(base::local({
[18:02:06.903]                 ...future.makeSendCondition <- base::local({
[18:02:06.903]                   sendCondition <- NULL
[18:02:06.903]                   function(frame = 1L) {
[18:02:06.903]                     if (is.function(sendCondition)) 
[18:02:06.903]                       return(sendCondition)
[18:02:06.903]                     ns <- getNamespace("parallel")
[18:02:06.903]                     if (exists("sendData", mode = "function", 
[18:02:06.903]                       envir = ns)) {
[18:02:06.903]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:06.903]                         envir = ns)
[18:02:06.903]                       envir <- sys.frame(frame)
[18:02:06.903]                       master <- NULL
[18:02:06.903]                       while (!identical(envir, .GlobalEnv) && 
[18:02:06.903]                         !identical(envir, emptyenv())) {
[18:02:06.903]                         if (exists("master", mode = "list", envir = envir, 
[18:02:06.903]                           inherits = FALSE)) {
[18:02:06.903]                           master <- get("master", mode = "list", 
[18:02:06.903]                             envir = envir, inherits = FALSE)
[18:02:06.903]                           if (inherits(master, c("SOCKnode", 
[18:02:06.903]                             "SOCK0node"))) {
[18:02:06.903]                             sendCondition <<- function(cond) {
[18:02:06.903]                               data <- list(type = "VALUE", value = cond, 
[18:02:06.903]                                 success = TRUE)
[18:02:06.903]                               parallel_sendData(master, data)
[18:02:06.903]                             }
[18:02:06.903]                             return(sendCondition)
[18:02:06.903]                           }
[18:02:06.903]                         }
[18:02:06.903]                         frame <- frame + 1L
[18:02:06.903]                         envir <- sys.frame(frame)
[18:02:06.903]                       }
[18:02:06.903]                     }
[18:02:06.903]                     sendCondition <<- function(cond) NULL
[18:02:06.903]                   }
[18:02:06.903]                 })
[18:02:06.903]                 withCallingHandlers({
[18:02:06.903]                   {
[18:02:06.903]                     do.call(function(...) {
[18:02:06.903]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:06.903]                       if (!identical(...future.globals.maxSize.org, 
[18:02:06.903]                         ...future.globals.maxSize)) {
[18:02:06.903]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:06.903]                         on.exit(options(oopts), add = TRUE)
[18:02:06.903]                       }
[18:02:06.903]                       {
[18:02:06.903]                         lapply(seq_along(...future.elements_ii), 
[18:02:06.903]                           FUN = function(jj) {
[18:02:06.903]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:06.903]                             ...future.FUN(...future.X_jj, ...)
[18:02:06.903]                           })
[18:02:06.903]                       }
[18:02:06.903]                     }, args = future.call.arguments)
[18:02:06.903]                   }
[18:02:06.903]                 }, immediateCondition = function(cond) {
[18:02:06.903]                   sendCondition <- ...future.makeSendCondition()
[18:02:06.903]                   sendCondition(cond)
[18:02:06.903]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:06.903]                   {
[18:02:06.903]                     inherits <- base::inherits
[18:02:06.903]                     invokeRestart <- base::invokeRestart
[18:02:06.903]                     is.null <- base::is.null
[18:02:06.903]                     muffled <- FALSE
[18:02:06.903]                     if (inherits(cond, "message")) {
[18:02:06.903]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:06.903]                       if (muffled) 
[18:02:06.903]                         invokeRestart("muffleMessage")
[18:02:06.903]                     }
[18:02:06.903]                     else if (inherits(cond, "warning")) {
[18:02:06.903]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:06.903]                       if (muffled) 
[18:02:06.903]                         invokeRestart("muffleWarning")
[18:02:06.903]                     }
[18:02:06.903]                     else if (inherits(cond, "condition")) {
[18:02:06.903]                       if (!is.null(pattern)) {
[18:02:06.903]                         computeRestarts <- base::computeRestarts
[18:02:06.903]                         grepl <- base::grepl
[18:02:06.903]                         restarts <- computeRestarts(cond)
[18:02:06.903]                         for (restart in restarts) {
[18:02:06.903]                           name <- restart$name
[18:02:06.903]                           if (is.null(name)) 
[18:02:06.903]                             next
[18:02:06.903]                           if (!grepl(pattern, name)) 
[18:02:06.903]                             next
[18:02:06.903]                           invokeRestart(restart)
[18:02:06.903]                           muffled <- TRUE
[18:02:06.903]                           break
[18:02:06.903]                         }
[18:02:06.903]                       }
[18:02:06.903]                     }
[18:02:06.903]                     invisible(muffled)
[18:02:06.903]                   }
[18:02:06.903]                   muffleCondition(cond)
[18:02:06.903]                 })
[18:02:06.903]             }))
[18:02:06.903]             future::FutureResult(value = ...future.value$value, 
[18:02:06.903]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:06.903]                   ...future.rng), globalenv = if (FALSE) 
[18:02:06.903]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:06.903]                     ...future.globalenv.names))
[18:02:06.903]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:06.903]         }, condition = base::local({
[18:02:06.903]             c <- base::c
[18:02:06.903]             inherits <- base::inherits
[18:02:06.903]             invokeRestart <- base::invokeRestart
[18:02:06.903]             length <- base::length
[18:02:06.903]             list <- base::list
[18:02:06.903]             seq.int <- base::seq.int
[18:02:06.903]             signalCondition <- base::signalCondition
[18:02:06.903]             sys.calls <- base::sys.calls
[18:02:06.903]             `[[` <- base::`[[`
[18:02:06.903]             `+` <- base::`+`
[18:02:06.903]             `<<-` <- base::`<<-`
[18:02:06.903]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:06.903]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:06.903]                   3L)]
[18:02:06.903]             }
[18:02:06.903]             function(cond) {
[18:02:06.903]                 is_error <- inherits(cond, "error")
[18:02:06.903]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:06.903]                   NULL)
[18:02:06.903]                 if (is_error) {
[18:02:06.903]                   sessionInformation <- function() {
[18:02:06.903]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:06.903]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:06.903]                       search = base::search(), system = base::Sys.info())
[18:02:06.903]                   }
[18:02:06.903]                   ...future.conditions[[length(...future.conditions) + 
[18:02:06.903]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:06.903]                     cond$call), session = sessionInformation(), 
[18:02:06.903]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:06.903]                   signalCondition(cond)
[18:02:06.903]                 }
[18:02:06.903]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:06.903]                 "immediateCondition"))) {
[18:02:06.903]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:06.903]                   ...future.conditions[[length(...future.conditions) + 
[18:02:06.903]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:06.903]                   if (TRUE && !signal) {
[18:02:06.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:06.903]                     {
[18:02:06.903]                       inherits <- base::inherits
[18:02:06.903]                       invokeRestart <- base::invokeRestart
[18:02:06.903]                       is.null <- base::is.null
[18:02:06.903]                       muffled <- FALSE
[18:02:06.903]                       if (inherits(cond, "message")) {
[18:02:06.903]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:06.903]                         if (muffled) 
[18:02:06.903]                           invokeRestart("muffleMessage")
[18:02:06.903]                       }
[18:02:06.903]                       else if (inherits(cond, "warning")) {
[18:02:06.903]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:06.903]                         if (muffled) 
[18:02:06.903]                           invokeRestart("muffleWarning")
[18:02:06.903]                       }
[18:02:06.903]                       else if (inherits(cond, "condition")) {
[18:02:06.903]                         if (!is.null(pattern)) {
[18:02:06.903]                           computeRestarts <- base::computeRestarts
[18:02:06.903]                           grepl <- base::grepl
[18:02:06.903]                           restarts <- computeRestarts(cond)
[18:02:06.903]                           for (restart in restarts) {
[18:02:06.903]                             name <- restart$name
[18:02:06.903]                             if (is.null(name)) 
[18:02:06.903]                               next
[18:02:06.903]                             if (!grepl(pattern, name)) 
[18:02:06.903]                               next
[18:02:06.903]                             invokeRestart(restart)
[18:02:06.903]                             muffled <- TRUE
[18:02:06.903]                             break
[18:02:06.903]                           }
[18:02:06.903]                         }
[18:02:06.903]                       }
[18:02:06.903]                       invisible(muffled)
[18:02:06.903]                     }
[18:02:06.903]                     muffleCondition(cond, pattern = "^muffle")
[18:02:06.903]                   }
[18:02:06.903]                 }
[18:02:06.903]                 else {
[18:02:06.903]                   if (TRUE) {
[18:02:06.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:06.903]                     {
[18:02:06.903]                       inherits <- base::inherits
[18:02:06.903]                       invokeRestart <- base::invokeRestart
[18:02:06.903]                       is.null <- base::is.null
[18:02:06.903]                       muffled <- FALSE
[18:02:06.903]                       if (inherits(cond, "message")) {
[18:02:06.903]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:06.903]                         if (muffled) 
[18:02:06.903]                           invokeRestart("muffleMessage")
[18:02:06.903]                       }
[18:02:06.903]                       else if (inherits(cond, "warning")) {
[18:02:06.903]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:06.903]                         if (muffled) 
[18:02:06.903]                           invokeRestart("muffleWarning")
[18:02:06.903]                       }
[18:02:06.903]                       else if (inherits(cond, "condition")) {
[18:02:06.903]                         if (!is.null(pattern)) {
[18:02:06.903]                           computeRestarts <- base::computeRestarts
[18:02:06.903]                           grepl <- base::grepl
[18:02:06.903]                           restarts <- computeRestarts(cond)
[18:02:06.903]                           for (restart in restarts) {
[18:02:06.903]                             name <- restart$name
[18:02:06.903]                             if (is.null(name)) 
[18:02:06.903]                               next
[18:02:06.903]                             if (!grepl(pattern, name)) 
[18:02:06.903]                               next
[18:02:06.903]                             invokeRestart(restart)
[18:02:06.903]                             muffled <- TRUE
[18:02:06.903]                             break
[18:02:06.903]                           }
[18:02:06.903]                         }
[18:02:06.903]                       }
[18:02:06.903]                       invisible(muffled)
[18:02:06.903]                     }
[18:02:06.903]                     muffleCondition(cond, pattern = "^muffle")
[18:02:06.903]                   }
[18:02:06.903]                 }
[18:02:06.903]             }
[18:02:06.903]         }))
[18:02:06.903]     }, error = function(ex) {
[18:02:06.903]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:06.903]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:06.903]                 ...future.rng), started = ...future.startTime, 
[18:02:06.903]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:06.903]             version = "1.8"), class = "FutureResult")
[18:02:06.903]     }, finally = {
[18:02:06.903]         if (!identical(...future.workdir, getwd())) 
[18:02:06.903]             setwd(...future.workdir)
[18:02:06.903]         {
[18:02:06.903]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:06.903]                 ...future.oldOptions$nwarnings <- NULL
[18:02:06.903]             }
[18:02:06.903]             base::options(...future.oldOptions)
[18:02:06.903]             if (.Platform$OS.type == "windows") {
[18:02:06.903]                 old_names <- names(...future.oldEnvVars)
[18:02:06.903]                 envs <- base::Sys.getenv()
[18:02:06.903]                 names <- names(envs)
[18:02:06.903]                 common <- intersect(names, old_names)
[18:02:06.903]                 added <- setdiff(names, old_names)
[18:02:06.903]                 removed <- setdiff(old_names, names)
[18:02:06.903]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:06.903]                   envs[common]]
[18:02:06.903]                 NAMES <- toupper(changed)
[18:02:06.903]                 args <- list()
[18:02:06.903]                 for (kk in seq_along(NAMES)) {
[18:02:06.903]                   name <- changed[[kk]]
[18:02:06.903]                   NAME <- NAMES[[kk]]
[18:02:06.903]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:06.903]                     next
[18:02:06.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:06.903]                 }
[18:02:06.903]                 NAMES <- toupper(added)
[18:02:06.903]                 for (kk in seq_along(NAMES)) {
[18:02:06.903]                   name <- added[[kk]]
[18:02:06.903]                   NAME <- NAMES[[kk]]
[18:02:06.903]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:06.903]                     next
[18:02:06.903]                   args[[name]] <- ""
[18:02:06.903]                 }
[18:02:06.903]                 NAMES <- toupper(removed)
[18:02:06.903]                 for (kk in seq_along(NAMES)) {
[18:02:06.903]                   name <- removed[[kk]]
[18:02:06.903]                   NAME <- NAMES[[kk]]
[18:02:06.903]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:06.903]                     next
[18:02:06.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:06.903]                 }
[18:02:06.903]                 if (length(args) > 0) 
[18:02:06.903]                   base::do.call(base::Sys.setenv, args = args)
[18:02:06.903]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:06.903]             }
[18:02:06.903]             else {
[18:02:06.903]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:06.903]             }
[18:02:06.903]             {
[18:02:06.903]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:06.903]                   0L) {
[18:02:06.903]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:06.903]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:06.903]                   base::options(opts)
[18:02:06.903]                 }
[18:02:06.903]                 {
[18:02:06.903]                   {
[18:02:06.903]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:06.903]                     NULL
[18:02:06.903]                   }
[18:02:06.903]                   options(future.plan = NULL)
[18:02:06.903]                   if (is.na(NA_character_)) 
[18:02:06.903]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:06.903]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:06.903]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:06.903]                     .init = FALSE)
[18:02:06.903]                 }
[18:02:06.903]             }
[18:02:06.903]         }
[18:02:06.903]     })
[18:02:06.903]     if (TRUE) {
[18:02:06.903]         base::sink(type = "output", split = FALSE)
[18:02:06.903]         if (TRUE) {
[18:02:06.903]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:06.903]         }
[18:02:06.903]         else {
[18:02:06.903]             ...future.result["stdout"] <- base::list(NULL)
[18:02:06.903]         }
[18:02:06.903]         base::close(...future.stdout)
[18:02:06.903]         ...future.stdout <- NULL
[18:02:06.903]     }
[18:02:06.903]     ...future.result$conditions <- ...future.conditions
[18:02:06.903]     ...future.result$finished <- base::Sys.time()
[18:02:06.903]     ...future.result
[18:02:06.903] }
[18:02:06.909] Exporting 11 global objects (93.29 KiB) to cluster node #2 ...
[18:02:06.909] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[18:02:06.950] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[18:02:06.951] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ...
[18:02:06.952] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ... DONE
[18:02:06.952] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[18:02:06.953] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[18:02:06.954] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[18:02:06.995] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[18:02:06.996] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[18:02:07.037] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[18:02:07.038] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[18:02:07.039] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[18:02:07.040] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[18:02:07.041] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[18:02:07.042] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:07.043] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:07.043] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ...
[18:02:07.044] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ... DONE
[18:02:07.045] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:07.046] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:07.046] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:07.047] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:07.048] Exporting 11 global objects (93.29 KiB) to cluster node #2 ... DONE
[18:02:07.049] MultisessionFuture started
[18:02:07.050] - Launch lazy future ... done
[18:02:07.050] run() for ‘MultisessionFuture’ ... done
[18:02:07.051] Created future:
[18:02:07.051] MultisessionFuture:
[18:02:07.051] Label: ‘future_vapply-2’
[18:02:07.051] Expression:
[18:02:07.051] {
[18:02:07.051]     do.call(function(...) {
[18:02:07.051]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:07.051]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:07.051]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:07.051]             on.exit(options(oopts), add = TRUE)
[18:02:07.051]         }
[18:02:07.051]         {
[18:02:07.051]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:07.051]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:07.051]                 ...future.FUN(...future.X_jj, ...)
[18:02:07.051]             })
[18:02:07.051]         }
[18:02:07.051]     }, args = future.call.arguments)
[18:02:07.051] }
[18:02:07.051] Lazy evaluation: FALSE
[18:02:07.051] Asynchronous evaluation: TRUE
[18:02:07.051] Local evaluation: TRUE
[18:02:07.051] Environment: R_GlobalEnv
[18:02:07.051] Capture standard output: TRUE
[18:02:07.051] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:07.051] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:07.051] Packages: 2 packages (‘stats’, ‘future.apply’)
[18:02:07.051] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:07.051] Resolved: FALSE
[18:02:07.051] Value: <not collected>
[18:02:07.051] Conditions captured: <none>
[18:02:07.051] Early signaling: FALSE
[18:02:07.051] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:07.051] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:07.066] Chunk #2 of 2 ... DONE
[18:02:07.067] Launching 2 futures (chunks) ... DONE
[18:02:07.067] Resolving 2 futures (chunks) ...
[18:02:07.067] resolve() on list ...
[18:02:07.068]  recursive: 0
[18:02:07.068]  length: 2
[18:02:07.068] 
[18:02:07.070] receiveMessageFromWorker() for ClusterFuture ...
[18:02:07.070] - Validating connection of MultisessionFuture
[18:02:07.071] - received message: FutureResult
[18:02:07.071] - Received FutureResult
[18:02:07.071] - Erased future from FutureRegistry
[18:02:07.072] result() for ClusterFuture ...
[18:02:07.072] - result already collected: FutureResult
[18:02:07.072] result() for ClusterFuture ... done
[18:02:07.073] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:07.073] Future #1
[18:02:07.073] result() for ClusterFuture ...
[18:02:07.074] - result already collected: FutureResult
[18:02:07.074] result() for ClusterFuture ... done
[18:02:07.074] result() for ClusterFuture ...
[18:02:07.075] - result already collected: FutureResult
[18:02:07.075] result() for ClusterFuture ... done
[18:02:07.075] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:07.076] - nx: 2
[18:02:07.076] - relay: TRUE
[18:02:07.076] - stdout: TRUE
[18:02:07.076] - signal: TRUE
[18:02:07.077] - resignal: FALSE
[18:02:07.077] - force: TRUE
[18:02:07.077] - relayed: [n=2] FALSE, FALSE
[18:02:07.078] - queued futures: [n=2] FALSE, FALSE
[18:02:07.078]  - until=1
[18:02:07.078]  - relaying element #1
[18:02:07.079] result() for ClusterFuture ...
[18:02:07.079] - result already collected: FutureResult
[18:02:07.079] result() for ClusterFuture ... done
[18:02:07.079] result() for ClusterFuture ...
[18:02:07.080] - result already collected: FutureResult
[18:02:07.080] result() for ClusterFuture ... done
[18:02:07.080] result() for ClusterFuture ...
[18:02:07.081] - result already collected: FutureResult
[18:02:07.081] result() for ClusterFuture ... done
[18:02:07.081] result() for ClusterFuture ...
[18:02:07.082] - result already collected: FutureResult
[18:02:07.082] result() for ClusterFuture ... done
[18:02:07.082] - relayed: [n=2] TRUE, FALSE
[18:02:07.082] - queued futures: [n=2] TRUE, FALSE
[18:02:07.083] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:07.083]  length: 1 (resolved future 1)
[18:02:07.106] receiveMessageFromWorker() for ClusterFuture ...
[18:02:07.107] - Validating connection of MultisessionFuture
[18:02:07.107] - received message: FutureResult
[18:02:07.108] - Received FutureResult
[18:02:07.108] - Erased future from FutureRegistry
[18:02:07.108] result() for ClusterFuture ...
[18:02:07.109] - result already collected: FutureResult
[18:02:07.109] result() for ClusterFuture ... done
[18:02:07.109] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:07.110] Future #2
[18:02:07.110] result() for ClusterFuture ...
[18:02:07.110] - result already collected: FutureResult
[18:02:07.111] result() for ClusterFuture ... done
[18:02:07.111] result() for ClusterFuture ...
[18:02:07.111] - result already collected: FutureResult
[18:02:07.112] result() for ClusterFuture ... done
[18:02:07.112] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:07.112] - nx: 2
[18:02:07.113] - relay: TRUE
[18:02:07.113] - stdout: TRUE
[18:02:07.113] - signal: TRUE
[18:02:07.113] - resignal: FALSE
[18:02:07.114] - force: TRUE
[18:02:07.114] - relayed: [n=2] TRUE, FALSE
[18:02:07.114] - queued futures: [n=2] TRUE, FALSE
[18:02:07.115]  - until=2
[18:02:07.115]  - relaying element #2
[18:02:07.115] result() for ClusterFuture ...
[18:02:07.116] - result already collected: FutureResult
[18:02:07.116] result() for ClusterFuture ... done
[18:02:07.116] result() for ClusterFuture ...
[18:02:07.116] - result already collected: FutureResult
[18:02:07.117] result() for ClusterFuture ... done
[18:02:07.117] result() for ClusterFuture ...
[18:02:07.118] - result already collected: FutureResult
[18:02:07.118] result() for ClusterFuture ... done
[18:02:07.118] result() for ClusterFuture ...
[18:02:07.118] - result already collected: FutureResult
[18:02:07.119] result() for ClusterFuture ... done
[18:02:07.119] - relayed: [n=2] TRUE, TRUE
[18:02:07.119] - queued futures: [n=2] TRUE, TRUE
[18:02:07.120] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:07.120]  length: 0 (resolved future 2)
[18:02:07.120] Relaying remaining futures
[18:02:07.121] signalConditionsASAP(NULL, pos=0) ...
[18:02:07.121] - nx: 2
[18:02:07.121] - relay: TRUE
[18:02:07.121] - stdout: TRUE
[18:02:07.122] - signal: TRUE
[18:02:07.122] - resignal: FALSE
[18:02:07.122] - force: TRUE
[18:02:07.122] - relayed: [n=2] TRUE, TRUE
[18:02:07.123] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:07.123] - relayed: [n=2] TRUE, TRUE
[18:02:07.124] - queued futures: [n=2] TRUE, TRUE
[18:02:07.124] signalConditionsASAP(NULL, pos=0) ... done
[18:02:07.124] resolve() on list ... DONE
[18:02:07.125] result() for ClusterFuture ...
[18:02:07.125] - result already collected: FutureResult
[18:02:07.125] result() for ClusterFuture ... done
[18:02:07.125] result() for ClusterFuture ...
[18:02:07.126] - result already collected: FutureResult
[18:02:07.126] result() for ClusterFuture ... done
[18:02:07.126] result() for ClusterFuture ...
[18:02:07.127] - result already collected: FutureResult
[18:02:07.127] result() for ClusterFuture ... done
[18:02:07.127] result() for ClusterFuture ...
[18:02:07.128] - result already collected: FutureResult
[18:02:07.128] result() for ClusterFuture ... done
[18:02:07.128]  - Number of value chunks collected: 2
[18:02:07.128] Resolving 2 futures (chunks) ... DONE
[18:02:07.129] Reducing values from 2 chunks ...
[18:02:07.129]  - Number of values collected after concatenation: 3
[18:02:07.129]  - Number of values expected: 3
[18:02:07.130] Reducing values from 2 chunks ... DONE
[18:02:07.130] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[18:02:07.135] future_lapply() ...
[18:02:07.154] Number of chunks: 2
[18:02:07.154] getGlobalsAndPackagesXApply() ...
[18:02:07.155]  - future.globals: TRUE
[18:02:07.155] getGlobalsAndPackages() ...
[18:02:07.155] Searching for globals...
[18:02:07.169] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[18:02:07.170] Searching for globals ... DONE
[18:02:07.170] Resolving globals: FALSE
[18:02:07.172] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[18:02:07.173] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[18:02:07.173] - globals: [1] ‘FUN’
[18:02:07.174] - packages: [1] ‘stats’
[18:02:07.174] getGlobalsAndPackages() ... DONE
[18:02:07.174]  - globals found/used: [n=1] ‘FUN’
[18:02:07.175]  - needed namespaces: [n=1] ‘stats’
[18:02:07.175] Finding globals ... DONE
[18:02:07.175]  - use_args: TRUE
[18:02:07.175]  - Getting '...' globals ...
[18:02:07.176] resolve() on list ...
[18:02:07.177]  recursive: 0
[18:02:07.177]  length: 1
[18:02:07.177]  elements: ‘...’
[18:02:07.177]  length: 0 (resolved future 1)
[18:02:07.178] resolve() on list ... DONE
[18:02:07.178]    - '...' content: [n=0] 
[18:02:07.178] List of 1
[18:02:07.178]  $ ...: list()
[18:02:07.178]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:07.178]  - attr(*, "where")=List of 1
[18:02:07.178]   ..$ ...:<environment: 0x6183c263fee8> 
[18:02:07.178]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:07.178]  - attr(*, "resolved")= logi TRUE
[18:02:07.178]  - attr(*, "total_size")= num NA
[18:02:07.184]  - Getting '...' globals ... DONE
[18:02:07.185] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:07.185] List of 2
[18:02:07.185]  $ ...future.FUN:function (x, na.rm = TRUE)  
[18:02:07.185]  $ ...          : list()
[18:02:07.185]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:07.185]  - attr(*, "where")=List of 2
[18:02:07.185]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:07.185]   ..$ ...          :<environment: 0x6183c263fee8> 
[18:02:07.185]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:07.185]  - attr(*, "resolved")= logi FALSE
[18:02:07.185]  - attr(*, "total_size")= num 46960
[18:02:07.193] Packages to be attached in all futures: [n=1] ‘stats’
[18:02:07.193] getGlobalsAndPackagesXApply() ... DONE
[18:02:07.193] Number of futures (= number of chunks): 2
[18:02:07.194] Launching 2 futures (chunks) ...
[18:02:07.194] Chunk #1 of 2 ...
[18:02:07.194]  - Finding globals in 'X' for chunk #1 ...
[18:02:07.194] getGlobalsAndPackages() ...
[18:02:07.195] Searching for globals...
[18:02:07.195] 
[18:02:07.196] Searching for globals ... DONE
[18:02:07.196] - globals: [0] <none>
[18:02:07.196] getGlobalsAndPackages() ... DONE
[18:02:07.196]    + additional globals found: [n=0] 
[18:02:07.197]    + additional namespaces needed: [n=0] 
[18:02:07.197]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:07.197]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:07.197]  - seeds: <none>
[18:02:07.197]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:07.198] getGlobalsAndPackages() ...
[18:02:07.198] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:07.198] Resolving globals: FALSE
[18:02:07.198] Tweak future expression to call with '...' arguments ...
[18:02:07.199] {
[18:02:07.199]     do.call(function(...) {
[18:02:07.199]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:07.199]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:07.199]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:07.199]             on.exit(options(oopts), add = TRUE)
[18:02:07.199]         }
[18:02:07.199]         {
[18:02:07.199]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:07.199]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:07.199]                 ...future.FUN(...future.X_jj, ...)
[18:02:07.199]             })
[18:02:07.199]         }
[18:02:07.199]     }, args = future.call.arguments)
[18:02:07.199] }
[18:02:07.199] Tweak future expression to call with '...' arguments ... DONE
[18:02:07.200] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:07.201] - packages: [1] ‘stats’
[18:02:07.201] getGlobalsAndPackages() ... DONE
[18:02:07.202] run() for ‘Future’ ...
[18:02:07.202] - state: ‘created’
[18:02:07.202] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:07.229] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:07.229] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:07.229]   - Field: ‘node’
[18:02:07.230]   - Field: ‘label’
[18:02:07.230]   - Field: ‘local’
[18:02:07.230]   - Field: ‘owner’
[18:02:07.230]   - Field: ‘envir’
[18:02:07.230]   - Field: ‘workers’
[18:02:07.231]   - Field: ‘packages’
[18:02:07.231]   - Field: ‘gc’
[18:02:07.231]   - Field: ‘conditions’
[18:02:07.231]   - Field: ‘persistent’
[18:02:07.231]   - Field: ‘expr’
[18:02:07.232]   - Field: ‘uuid’
[18:02:07.232]   - Field: ‘seed’
[18:02:07.232]   - Field: ‘version’
[18:02:07.232]   - Field: ‘result’
[18:02:07.232]   - Field: ‘asynchronous’
[18:02:07.233]   - Field: ‘calls’
[18:02:07.233]   - Field: ‘globals’
[18:02:07.233]   - Field: ‘stdout’
[18:02:07.233]   - Field: ‘earlySignal’
[18:02:07.233]   - Field: ‘lazy’
[18:02:07.233]   - Field: ‘state’
[18:02:07.234] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:07.234] - Launch lazy future ...
[18:02:07.234] Packages needed by the future expression (n = 1): ‘stats’
[18:02:07.235] Packages needed by future strategies (n = 0): <none>
[18:02:07.236] {
[18:02:07.236]     {
[18:02:07.236]         {
[18:02:07.236]             ...future.startTime <- base::Sys.time()
[18:02:07.236]             {
[18:02:07.236]                 {
[18:02:07.236]                   {
[18:02:07.236]                     {
[18:02:07.236]                       {
[18:02:07.236]                         base::local({
[18:02:07.236]                           has_future <- base::requireNamespace("future", 
[18:02:07.236]                             quietly = TRUE)
[18:02:07.236]                           if (has_future) {
[18:02:07.236]                             ns <- base::getNamespace("future")
[18:02:07.236]                             version <- ns[[".package"]][["version"]]
[18:02:07.236]                             if (is.null(version)) 
[18:02:07.236]                               version <- utils::packageVersion("future")
[18:02:07.236]                           }
[18:02:07.236]                           else {
[18:02:07.236]                             version <- NULL
[18:02:07.236]                           }
[18:02:07.236]                           if (!has_future || version < "1.8.0") {
[18:02:07.236]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:07.236]                               "", base::R.version$version.string), 
[18:02:07.236]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:07.236]                                 base::R.version$platform, 8 * 
[18:02:07.236]                                   base::.Machine$sizeof.pointer), 
[18:02:07.236]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:07.236]                                 "release", "version")], collapse = " "), 
[18:02:07.236]                               hostname = base::Sys.info()[["nodename"]])
[18:02:07.236]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:07.236]                               info)
[18:02:07.236]                             info <- base::paste(info, collapse = "; ")
[18:02:07.236]                             if (!has_future) {
[18:02:07.236]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:07.236]                                 info)
[18:02:07.236]                             }
[18:02:07.236]                             else {
[18:02:07.236]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:07.236]                                 info, version)
[18:02:07.236]                             }
[18:02:07.236]                             base::stop(msg)
[18:02:07.236]                           }
[18:02:07.236]                         })
[18:02:07.236]                       }
[18:02:07.236]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:07.236]                       base::options(mc.cores = 1L)
[18:02:07.236]                     }
[18:02:07.236]                     base::local({
[18:02:07.236]                       for (pkg in "stats") {
[18:02:07.236]                         base::loadNamespace(pkg)
[18:02:07.236]                         base::library(pkg, character.only = TRUE)
[18:02:07.236]                       }
[18:02:07.236]                     })
[18:02:07.236]                   }
[18:02:07.236]                   ...future.strategy.old <- future::plan("list")
[18:02:07.236]                   options(future.plan = NULL)
[18:02:07.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:07.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:07.236]                 }
[18:02:07.236]                 ...future.workdir <- getwd()
[18:02:07.236]             }
[18:02:07.236]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:07.236]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:07.236]         }
[18:02:07.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:07.236]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:07.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:07.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:07.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:07.236]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:07.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:07.236]             base::names(...future.oldOptions))
[18:02:07.236]     }
[18:02:07.236]     if (FALSE) {
[18:02:07.236]     }
[18:02:07.236]     else {
[18:02:07.236]         if (TRUE) {
[18:02:07.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:07.236]                 open = "w")
[18:02:07.236]         }
[18:02:07.236]         else {
[18:02:07.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:07.236]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:07.236]         }
[18:02:07.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:07.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:07.236]             base::sink(type = "output", split = FALSE)
[18:02:07.236]             base::close(...future.stdout)
[18:02:07.236]         }, add = TRUE)
[18:02:07.236]     }
[18:02:07.236]     ...future.frame <- base::sys.nframe()
[18:02:07.236]     ...future.conditions <- base::list()
[18:02:07.236]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:07.236]     if (FALSE) {
[18:02:07.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:07.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:07.236]     }
[18:02:07.236]     ...future.result <- base::tryCatch({
[18:02:07.236]         base::withCallingHandlers({
[18:02:07.236]             ...future.value <- base::withVisible(base::local({
[18:02:07.236]                 ...future.makeSendCondition <- base::local({
[18:02:07.236]                   sendCondition <- NULL
[18:02:07.236]                   function(frame = 1L) {
[18:02:07.236]                     if (is.function(sendCondition)) 
[18:02:07.236]                       return(sendCondition)
[18:02:07.236]                     ns <- getNamespace("parallel")
[18:02:07.236]                     if (exists("sendData", mode = "function", 
[18:02:07.236]                       envir = ns)) {
[18:02:07.236]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:07.236]                         envir = ns)
[18:02:07.236]                       envir <- sys.frame(frame)
[18:02:07.236]                       master <- NULL
[18:02:07.236]                       while (!identical(envir, .GlobalEnv) && 
[18:02:07.236]                         !identical(envir, emptyenv())) {
[18:02:07.236]                         if (exists("master", mode = "list", envir = envir, 
[18:02:07.236]                           inherits = FALSE)) {
[18:02:07.236]                           master <- get("master", mode = "list", 
[18:02:07.236]                             envir = envir, inherits = FALSE)
[18:02:07.236]                           if (inherits(master, c("SOCKnode", 
[18:02:07.236]                             "SOCK0node"))) {
[18:02:07.236]                             sendCondition <<- function(cond) {
[18:02:07.236]                               data <- list(type = "VALUE", value = cond, 
[18:02:07.236]                                 success = TRUE)
[18:02:07.236]                               parallel_sendData(master, data)
[18:02:07.236]                             }
[18:02:07.236]                             return(sendCondition)
[18:02:07.236]                           }
[18:02:07.236]                         }
[18:02:07.236]                         frame <- frame + 1L
[18:02:07.236]                         envir <- sys.frame(frame)
[18:02:07.236]                       }
[18:02:07.236]                     }
[18:02:07.236]                     sendCondition <<- function(cond) NULL
[18:02:07.236]                   }
[18:02:07.236]                 })
[18:02:07.236]                 withCallingHandlers({
[18:02:07.236]                   {
[18:02:07.236]                     do.call(function(...) {
[18:02:07.236]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:07.236]                       if (!identical(...future.globals.maxSize.org, 
[18:02:07.236]                         ...future.globals.maxSize)) {
[18:02:07.236]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:07.236]                         on.exit(options(oopts), add = TRUE)
[18:02:07.236]                       }
[18:02:07.236]                       {
[18:02:07.236]                         lapply(seq_along(...future.elements_ii), 
[18:02:07.236]                           FUN = function(jj) {
[18:02:07.236]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:07.236]                             ...future.FUN(...future.X_jj, ...)
[18:02:07.236]                           })
[18:02:07.236]                       }
[18:02:07.236]                     }, args = future.call.arguments)
[18:02:07.236]                   }
[18:02:07.236]                 }, immediateCondition = function(cond) {
[18:02:07.236]                   sendCondition <- ...future.makeSendCondition()
[18:02:07.236]                   sendCondition(cond)
[18:02:07.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:07.236]                   {
[18:02:07.236]                     inherits <- base::inherits
[18:02:07.236]                     invokeRestart <- base::invokeRestart
[18:02:07.236]                     is.null <- base::is.null
[18:02:07.236]                     muffled <- FALSE
[18:02:07.236]                     if (inherits(cond, "message")) {
[18:02:07.236]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:07.236]                       if (muffled) 
[18:02:07.236]                         invokeRestart("muffleMessage")
[18:02:07.236]                     }
[18:02:07.236]                     else if (inherits(cond, "warning")) {
[18:02:07.236]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:07.236]                       if (muffled) 
[18:02:07.236]                         invokeRestart("muffleWarning")
[18:02:07.236]                     }
[18:02:07.236]                     else if (inherits(cond, "condition")) {
[18:02:07.236]                       if (!is.null(pattern)) {
[18:02:07.236]                         computeRestarts <- base::computeRestarts
[18:02:07.236]                         grepl <- base::grepl
[18:02:07.236]                         restarts <- computeRestarts(cond)
[18:02:07.236]                         for (restart in restarts) {
[18:02:07.236]                           name <- restart$name
[18:02:07.236]                           if (is.null(name)) 
[18:02:07.236]                             next
[18:02:07.236]                           if (!grepl(pattern, name)) 
[18:02:07.236]                             next
[18:02:07.236]                           invokeRestart(restart)
[18:02:07.236]                           muffled <- TRUE
[18:02:07.236]                           break
[18:02:07.236]                         }
[18:02:07.236]                       }
[18:02:07.236]                     }
[18:02:07.236]                     invisible(muffled)
[18:02:07.236]                   }
[18:02:07.236]                   muffleCondition(cond)
[18:02:07.236]                 })
[18:02:07.236]             }))
[18:02:07.236]             future::FutureResult(value = ...future.value$value, 
[18:02:07.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:07.236]                   ...future.rng), globalenv = if (FALSE) 
[18:02:07.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:07.236]                     ...future.globalenv.names))
[18:02:07.236]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:07.236]         }, condition = base::local({
[18:02:07.236]             c <- base::c
[18:02:07.236]             inherits <- base::inherits
[18:02:07.236]             invokeRestart <- base::invokeRestart
[18:02:07.236]             length <- base::length
[18:02:07.236]             list <- base::list
[18:02:07.236]             seq.int <- base::seq.int
[18:02:07.236]             signalCondition <- base::signalCondition
[18:02:07.236]             sys.calls <- base::sys.calls
[18:02:07.236]             `[[` <- base::`[[`
[18:02:07.236]             `+` <- base::`+`
[18:02:07.236]             `<<-` <- base::`<<-`
[18:02:07.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:07.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:07.236]                   3L)]
[18:02:07.236]             }
[18:02:07.236]             function(cond) {
[18:02:07.236]                 is_error <- inherits(cond, "error")
[18:02:07.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:07.236]                   NULL)
[18:02:07.236]                 if (is_error) {
[18:02:07.236]                   sessionInformation <- function() {
[18:02:07.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:07.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:07.236]                       search = base::search(), system = base::Sys.info())
[18:02:07.236]                   }
[18:02:07.236]                   ...future.conditions[[length(...future.conditions) + 
[18:02:07.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:07.236]                     cond$call), session = sessionInformation(), 
[18:02:07.236]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:07.236]                   signalCondition(cond)
[18:02:07.236]                 }
[18:02:07.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:07.236]                 "immediateCondition"))) {
[18:02:07.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:07.236]                   ...future.conditions[[length(...future.conditions) + 
[18:02:07.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:07.236]                   if (TRUE && !signal) {
[18:02:07.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:07.236]                     {
[18:02:07.236]                       inherits <- base::inherits
[18:02:07.236]                       invokeRestart <- base::invokeRestart
[18:02:07.236]                       is.null <- base::is.null
[18:02:07.236]                       muffled <- FALSE
[18:02:07.236]                       if (inherits(cond, "message")) {
[18:02:07.236]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:07.236]                         if (muffled) 
[18:02:07.236]                           invokeRestart("muffleMessage")
[18:02:07.236]                       }
[18:02:07.236]                       else if (inherits(cond, "warning")) {
[18:02:07.236]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:07.236]                         if (muffled) 
[18:02:07.236]                           invokeRestart("muffleWarning")
[18:02:07.236]                       }
[18:02:07.236]                       else if (inherits(cond, "condition")) {
[18:02:07.236]                         if (!is.null(pattern)) {
[18:02:07.236]                           computeRestarts <- base::computeRestarts
[18:02:07.236]                           grepl <- base::grepl
[18:02:07.236]                           restarts <- computeRestarts(cond)
[18:02:07.236]                           for (restart in restarts) {
[18:02:07.236]                             name <- restart$name
[18:02:07.236]                             if (is.null(name)) 
[18:02:07.236]                               next
[18:02:07.236]                             if (!grepl(pattern, name)) 
[18:02:07.236]                               next
[18:02:07.236]                             invokeRestart(restart)
[18:02:07.236]                             muffled <- TRUE
[18:02:07.236]                             break
[18:02:07.236]                           }
[18:02:07.236]                         }
[18:02:07.236]                       }
[18:02:07.236]                       invisible(muffled)
[18:02:07.236]                     }
[18:02:07.236]                     muffleCondition(cond, pattern = "^muffle")
[18:02:07.236]                   }
[18:02:07.236]                 }
[18:02:07.236]                 else {
[18:02:07.236]                   if (TRUE) {
[18:02:07.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:07.236]                     {
[18:02:07.236]                       inherits <- base::inherits
[18:02:07.236]                       invokeRestart <- base::invokeRestart
[18:02:07.236]                       is.null <- base::is.null
[18:02:07.236]                       muffled <- FALSE
[18:02:07.236]                       if (inherits(cond, "message")) {
[18:02:07.236]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:07.236]                         if (muffled) 
[18:02:07.236]                           invokeRestart("muffleMessage")
[18:02:07.236]                       }
[18:02:07.236]                       else if (inherits(cond, "warning")) {
[18:02:07.236]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:07.236]                         if (muffled) 
[18:02:07.236]                           invokeRestart("muffleWarning")
[18:02:07.236]                       }
[18:02:07.236]                       else if (inherits(cond, "condition")) {
[18:02:07.236]                         if (!is.null(pattern)) {
[18:02:07.236]                           computeRestarts <- base::computeRestarts
[18:02:07.236]                           grepl <- base::grepl
[18:02:07.236]                           restarts <- computeRestarts(cond)
[18:02:07.236]                           for (restart in restarts) {
[18:02:07.236]                             name <- restart$name
[18:02:07.236]                             if (is.null(name)) 
[18:02:07.236]                               next
[18:02:07.236]                             if (!grepl(pattern, name)) 
[18:02:07.236]                               next
[18:02:07.236]                             invokeRestart(restart)
[18:02:07.236]                             muffled <- TRUE
[18:02:07.236]                             break
[18:02:07.236]                           }
[18:02:07.236]                         }
[18:02:07.236]                       }
[18:02:07.236]                       invisible(muffled)
[18:02:07.236]                     }
[18:02:07.236]                     muffleCondition(cond, pattern = "^muffle")
[18:02:07.236]                   }
[18:02:07.236]                 }
[18:02:07.236]             }
[18:02:07.236]         }))
[18:02:07.236]     }, error = function(ex) {
[18:02:07.236]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:07.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:07.236]                 ...future.rng), started = ...future.startTime, 
[18:02:07.236]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:07.236]             version = "1.8"), class = "FutureResult")
[18:02:07.236]     }, finally = {
[18:02:07.236]         if (!identical(...future.workdir, getwd())) 
[18:02:07.236]             setwd(...future.workdir)
[18:02:07.236]         {
[18:02:07.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:07.236]                 ...future.oldOptions$nwarnings <- NULL
[18:02:07.236]             }
[18:02:07.236]             base::options(...future.oldOptions)
[18:02:07.236]             if (.Platform$OS.type == "windows") {
[18:02:07.236]                 old_names <- names(...future.oldEnvVars)
[18:02:07.236]                 envs <- base::Sys.getenv()
[18:02:07.236]                 names <- names(envs)
[18:02:07.236]                 common <- intersect(names, old_names)
[18:02:07.236]                 added <- setdiff(names, old_names)
[18:02:07.236]                 removed <- setdiff(old_names, names)
[18:02:07.236]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:07.236]                   envs[common]]
[18:02:07.236]                 NAMES <- toupper(changed)
[18:02:07.236]                 args <- list()
[18:02:07.236]                 for (kk in seq_along(NAMES)) {
[18:02:07.236]                   name <- changed[[kk]]
[18:02:07.236]                   NAME <- NAMES[[kk]]
[18:02:07.236]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:07.236]                     next
[18:02:07.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:07.236]                 }
[18:02:07.236]                 NAMES <- toupper(added)
[18:02:07.236]                 for (kk in seq_along(NAMES)) {
[18:02:07.236]                   name <- added[[kk]]
[18:02:07.236]                   NAME <- NAMES[[kk]]
[18:02:07.236]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:07.236]                     next
[18:02:07.236]                   args[[name]] <- ""
[18:02:07.236]                 }
[18:02:07.236]                 NAMES <- toupper(removed)
[18:02:07.236]                 for (kk in seq_along(NAMES)) {
[18:02:07.236]                   name <- removed[[kk]]
[18:02:07.236]                   NAME <- NAMES[[kk]]
[18:02:07.236]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:07.236]                     next
[18:02:07.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:07.236]                 }
[18:02:07.236]                 if (length(args) > 0) 
[18:02:07.236]                   base::do.call(base::Sys.setenv, args = args)
[18:02:07.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:07.236]             }
[18:02:07.236]             else {
[18:02:07.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:07.236]             }
[18:02:07.236]             {
[18:02:07.236]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:07.236]                   0L) {
[18:02:07.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:07.236]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:07.236]                   base::options(opts)
[18:02:07.236]                 }
[18:02:07.236]                 {
[18:02:07.236]                   {
[18:02:07.236]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:07.236]                     NULL
[18:02:07.236]                   }
[18:02:07.236]                   options(future.plan = NULL)
[18:02:07.236]                   if (is.na(NA_character_)) 
[18:02:07.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:07.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:07.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:07.236]                     .init = FALSE)
[18:02:07.236]                 }
[18:02:07.236]             }
[18:02:07.236]         }
[18:02:07.236]     })
[18:02:07.236]     if (TRUE) {
[18:02:07.236]         base::sink(type = "output", split = FALSE)
[18:02:07.236]         if (TRUE) {
[18:02:07.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:07.236]         }
[18:02:07.236]         else {
[18:02:07.236]             ...future.result["stdout"] <- base::list(NULL)
[18:02:07.236]         }
[18:02:07.236]         base::close(...future.stdout)
[18:02:07.236]         ...future.stdout <- NULL
[18:02:07.236]     }
[18:02:07.236]     ...future.result$conditions <- ...future.conditions
[18:02:07.236]     ...future.result$finished <- base::Sys.time()
[18:02:07.236]     ...future.result
[18:02:07.236] }
[18:02:07.241] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[18:02:07.241] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[18:02:07.282] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[18:02:07.283] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:07.284] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:07.284] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[18:02:07.285] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[18:02:07.286] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:07.287] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:07.287] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:07.288] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:07.288] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[18:02:07.289] MultisessionFuture started
[18:02:07.289] - Launch lazy future ... done
[18:02:07.290] run() for ‘MultisessionFuture’ ... done
[18:02:07.290] Created future:
[18:02:07.290] MultisessionFuture:
[18:02:07.290] Label: ‘future_sapply-1’
[18:02:07.290] Expression:
[18:02:07.290] {
[18:02:07.290]     do.call(function(...) {
[18:02:07.290]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:07.290]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:07.290]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:07.290]             on.exit(options(oopts), add = TRUE)
[18:02:07.290]         }
[18:02:07.290]         {
[18:02:07.290]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:07.290]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:07.290]                 ...future.FUN(...future.X_jj, ...)
[18:02:07.290]             })
[18:02:07.290]         }
[18:02:07.290]     }, args = future.call.arguments)
[18:02:07.290] }
[18:02:07.290] Lazy evaluation: FALSE
[18:02:07.290] Asynchronous evaluation: TRUE
[18:02:07.290] Local evaluation: TRUE
[18:02:07.290] Environment: R_GlobalEnv
[18:02:07.290] Capture standard output: TRUE
[18:02:07.290] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:07.290] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:07.290] Packages: 1 packages (‘stats’)
[18:02:07.290] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:07.290] Resolved: FALSE
[18:02:07.290] Value: <not collected>
[18:02:07.290] Conditions captured: <none>
[18:02:07.290] Early signaling: FALSE
[18:02:07.290] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:07.290] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:07.304] Chunk #1 of 2 ... DONE
[18:02:07.304] Chunk #2 of 2 ...
[18:02:07.304]  - Finding globals in 'X' for chunk #2 ...
[18:02:07.305] getGlobalsAndPackages() ...
[18:02:07.305] Searching for globals...
[18:02:07.305] 
[18:02:07.306] Searching for globals ... DONE
[18:02:07.306] - globals: [0] <none>
[18:02:07.306] getGlobalsAndPackages() ... DONE
[18:02:07.306]    + additional globals found: [n=0] 
[18:02:07.306]    + additional namespaces needed: [n=0] 
[18:02:07.307]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:07.307]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:07.307]  - seeds: <none>
[18:02:07.307]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:07.307] getGlobalsAndPackages() ...
[18:02:07.308] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:07.308] Resolving globals: FALSE
[18:02:07.308] Tweak future expression to call with '...' arguments ...
[18:02:07.308] {
[18:02:07.308]     do.call(function(...) {
[18:02:07.308]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:07.308]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:07.308]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:07.308]             on.exit(options(oopts), add = TRUE)
[18:02:07.308]         }
[18:02:07.308]         {
[18:02:07.308]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:07.308]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:07.308]                 ...future.FUN(...future.X_jj, ...)
[18:02:07.308]             })
[18:02:07.308]         }
[18:02:07.308]     }, args = future.call.arguments)
[18:02:07.308] }
[18:02:07.309] Tweak future expression to call with '...' arguments ... DONE
[18:02:07.310] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:07.310] - packages: [1] ‘stats’
[18:02:07.310] getGlobalsAndPackages() ... DONE
[18:02:07.311] run() for ‘Future’ ...
[18:02:07.311] - state: ‘created’
[18:02:07.311] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:07.338] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:07.338] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:07.338]   - Field: ‘node’
[18:02:07.338]   - Field: ‘label’
[18:02:07.339]   - Field: ‘local’
[18:02:07.339]   - Field: ‘owner’
[18:02:07.339]   - Field: ‘envir’
[18:02:07.339]   - Field: ‘workers’
[18:02:07.339]   - Field: ‘packages’
[18:02:07.340]   - Field: ‘gc’
[18:02:07.340]   - Field: ‘conditions’
[18:02:07.340]   - Field: ‘persistent’
[18:02:07.340]   - Field: ‘expr’
[18:02:07.340]   - Field: ‘uuid’
[18:02:07.341]   - Field: ‘seed’
[18:02:07.341]   - Field: ‘version’
[18:02:07.341]   - Field: ‘result’
[18:02:07.341]   - Field: ‘asynchronous’
[18:02:07.341]   - Field: ‘calls’
[18:02:07.342]   - Field: ‘globals’
[18:02:07.342]   - Field: ‘stdout’
[18:02:07.342]   - Field: ‘earlySignal’
[18:02:07.342]   - Field: ‘lazy’
[18:02:07.343]   - Field: ‘state’
[18:02:07.343] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:07.343] - Launch lazy future ...
[18:02:07.344] Packages needed by the future expression (n = 1): ‘stats’
[18:02:07.345] Packages needed by future strategies (n = 0): <none>
[18:02:07.346] {
[18:02:07.346]     {
[18:02:07.346]         {
[18:02:07.346]             ...future.startTime <- base::Sys.time()
[18:02:07.346]             {
[18:02:07.346]                 {
[18:02:07.346]                   {
[18:02:07.346]                     {
[18:02:07.346]                       {
[18:02:07.346]                         base::local({
[18:02:07.346]                           has_future <- base::requireNamespace("future", 
[18:02:07.346]                             quietly = TRUE)
[18:02:07.346]                           if (has_future) {
[18:02:07.346]                             ns <- base::getNamespace("future")
[18:02:07.346]                             version <- ns[[".package"]][["version"]]
[18:02:07.346]                             if (is.null(version)) 
[18:02:07.346]                               version <- utils::packageVersion("future")
[18:02:07.346]                           }
[18:02:07.346]                           else {
[18:02:07.346]                             version <- NULL
[18:02:07.346]                           }
[18:02:07.346]                           if (!has_future || version < "1.8.0") {
[18:02:07.346]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:07.346]                               "", base::R.version$version.string), 
[18:02:07.346]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:07.346]                                 base::R.version$platform, 8 * 
[18:02:07.346]                                   base::.Machine$sizeof.pointer), 
[18:02:07.346]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:07.346]                                 "release", "version")], collapse = " "), 
[18:02:07.346]                               hostname = base::Sys.info()[["nodename"]])
[18:02:07.346]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:07.346]                               info)
[18:02:07.346]                             info <- base::paste(info, collapse = "; ")
[18:02:07.346]                             if (!has_future) {
[18:02:07.346]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:07.346]                                 info)
[18:02:07.346]                             }
[18:02:07.346]                             else {
[18:02:07.346]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:07.346]                                 info, version)
[18:02:07.346]                             }
[18:02:07.346]                             base::stop(msg)
[18:02:07.346]                           }
[18:02:07.346]                         })
[18:02:07.346]                       }
[18:02:07.346]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:07.346]                       base::options(mc.cores = 1L)
[18:02:07.346]                     }
[18:02:07.346]                     base::local({
[18:02:07.346]                       for (pkg in "stats") {
[18:02:07.346]                         base::loadNamespace(pkg)
[18:02:07.346]                         base::library(pkg, character.only = TRUE)
[18:02:07.346]                       }
[18:02:07.346]                     })
[18:02:07.346]                   }
[18:02:07.346]                   ...future.strategy.old <- future::plan("list")
[18:02:07.346]                   options(future.plan = NULL)
[18:02:07.346]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:07.346]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:07.346]                 }
[18:02:07.346]                 ...future.workdir <- getwd()
[18:02:07.346]             }
[18:02:07.346]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:07.346]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:07.346]         }
[18:02:07.346]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:07.346]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:07.346]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:07.346]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:07.346]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:07.346]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:07.346]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:07.346]             base::names(...future.oldOptions))
[18:02:07.346]     }
[18:02:07.346]     if (FALSE) {
[18:02:07.346]     }
[18:02:07.346]     else {
[18:02:07.346]         if (TRUE) {
[18:02:07.346]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:07.346]                 open = "w")
[18:02:07.346]         }
[18:02:07.346]         else {
[18:02:07.346]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:07.346]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:07.346]         }
[18:02:07.346]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:07.346]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:07.346]             base::sink(type = "output", split = FALSE)
[18:02:07.346]             base::close(...future.stdout)
[18:02:07.346]         }, add = TRUE)
[18:02:07.346]     }
[18:02:07.346]     ...future.frame <- base::sys.nframe()
[18:02:07.346]     ...future.conditions <- base::list()
[18:02:07.346]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:07.346]     if (FALSE) {
[18:02:07.346]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:07.346]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:07.346]     }
[18:02:07.346]     ...future.result <- base::tryCatch({
[18:02:07.346]         base::withCallingHandlers({
[18:02:07.346]             ...future.value <- base::withVisible(base::local({
[18:02:07.346]                 ...future.makeSendCondition <- base::local({
[18:02:07.346]                   sendCondition <- NULL
[18:02:07.346]                   function(frame = 1L) {
[18:02:07.346]                     if (is.function(sendCondition)) 
[18:02:07.346]                       return(sendCondition)
[18:02:07.346]                     ns <- getNamespace("parallel")
[18:02:07.346]                     if (exists("sendData", mode = "function", 
[18:02:07.346]                       envir = ns)) {
[18:02:07.346]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:07.346]                         envir = ns)
[18:02:07.346]                       envir <- sys.frame(frame)
[18:02:07.346]                       master <- NULL
[18:02:07.346]                       while (!identical(envir, .GlobalEnv) && 
[18:02:07.346]                         !identical(envir, emptyenv())) {
[18:02:07.346]                         if (exists("master", mode = "list", envir = envir, 
[18:02:07.346]                           inherits = FALSE)) {
[18:02:07.346]                           master <- get("master", mode = "list", 
[18:02:07.346]                             envir = envir, inherits = FALSE)
[18:02:07.346]                           if (inherits(master, c("SOCKnode", 
[18:02:07.346]                             "SOCK0node"))) {
[18:02:07.346]                             sendCondition <<- function(cond) {
[18:02:07.346]                               data <- list(type = "VALUE", value = cond, 
[18:02:07.346]                                 success = TRUE)
[18:02:07.346]                               parallel_sendData(master, data)
[18:02:07.346]                             }
[18:02:07.346]                             return(sendCondition)
[18:02:07.346]                           }
[18:02:07.346]                         }
[18:02:07.346]                         frame <- frame + 1L
[18:02:07.346]                         envir <- sys.frame(frame)
[18:02:07.346]                       }
[18:02:07.346]                     }
[18:02:07.346]                     sendCondition <<- function(cond) NULL
[18:02:07.346]                   }
[18:02:07.346]                 })
[18:02:07.346]                 withCallingHandlers({
[18:02:07.346]                   {
[18:02:07.346]                     do.call(function(...) {
[18:02:07.346]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:07.346]                       if (!identical(...future.globals.maxSize.org, 
[18:02:07.346]                         ...future.globals.maxSize)) {
[18:02:07.346]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:07.346]                         on.exit(options(oopts), add = TRUE)
[18:02:07.346]                       }
[18:02:07.346]                       {
[18:02:07.346]                         lapply(seq_along(...future.elements_ii), 
[18:02:07.346]                           FUN = function(jj) {
[18:02:07.346]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:07.346]                             ...future.FUN(...future.X_jj, ...)
[18:02:07.346]                           })
[18:02:07.346]                       }
[18:02:07.346]                     }, args = future.call.arguments)
[18:02:07.346]                   }
[18:02:07.346]                 }, immediateCondition = function(cond) {
[18:02:07.346]                   sendCondition <- ...future.makeSendCondition()
[18:02:07.346]                   sendCondition(cond)
[18:02:07.346]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:07.346]                   {
[18:02:07.346]                     inherits <- base::inherits
[18:02:07.346]                     invokeRestart <- base::invokeRestart
[18:02:07.346]                     is.null <- base::is.null
[18:02:07.346]                     muffled <- FALSE
[18:02:07.346]                     if (inherits(cond, "message")) {
[18:02:07.346]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:07.346]                       if (muffled) 
[18:02:07.346]                         invokeRestart("muffleMessage")
[18:02:07.346]                     }
[18:02:07.346]                     else if (inherits(cond, "warning")) {
[18:02:07.346]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:07.346]                       if (muffled) 
[18:02:07.346]                         invokeRestart("muffleWarning")
[18:02:07.346]                     }
[18:02:07.346]                     else if (inherits(cond, "condition")) {
[18:02:07.346]                       if (!is.null(pattern)) {
[18:02:07.346]                         computeRestarts <- base::computeRestarts
[18:02:07.346]                         grepl <- base::grepl
[18:02:07.346]                         restarts <- computeRestarts(cond)
[18:02:07.346]                         for (restart in restarts) {
[18:02:07.346]                           name <- restart$name
[18:02:07.346]                           if (is.null(name)) 
[18:02:07.346]                             next
[18:02:07.346]                           if (!grepl(pattern, name)) 
[18:02:07.346]                             next
[18:02:07.346]                           invokeRestart(restart)
[18:02:07.346]                           muffled <- TRUE
[18:02:07.346]                           break
[18:02:07.346]                         }
[18:02:07.346]                       }
[18:02:07.346]                     }
[18:02:07.346]                     invisible(muffled)
[18:02:07.346]                   }
[18:02:07.346]                   muffleCondition(cond)
[18:02:07.346]                 })
[18:02:07.346]             }))
[18:02:07.346]             future::FutureResult(value = ...future.value$value, 
[18:02:07.346]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:07.346]                   ...future.rng), globalenv = if (FALSE) 
[18:02:07.346]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:07.346]                     ...future.globalenv.names))
[18:02:07.346]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:07.346]         }, condition = base::local({
[18:02:07.346]             c <- base::c
[18:02:07.346]             inherits <- base::inherits
[18:02:07.346]             invokeRestart <- base::invokeRestart
[18:02:07.346]             length <- base::length
[18:02:07.346]             list <- base::list
[18:02:07.346]             seq.int <- base::seq.int
[18:02:07.346]             signalCondition <- base::signalCondition
[18:02:07.346]             sys.calls <- base::sys.calls
[18:02:07.346]             `[[` <- base::`[[`
[18:02:07.346]             `+` <- base::`+`
[18:02:07.346]             `<<-` <- base::`<<-`
[18:02:07.346]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:07.346]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:07.346]                   3L)]
[18:02:07.346]             }
[18:02:07.346]             function(cond) {
[18:02:07.346]                 is_error <- inherits(cond, "error")
[18:02:07.346]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:07.346]                   NULL)
[18:02:07.346]                 if (is_error) {
[18:02:07.346]                   sessionInformation <- function() {
[18:02:07.346]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:07.346]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:07.346]                       search = base::search(), system = base::Sys.info())
[18:02:07.346]                   }
[18:02:07.346]                   ...future.conditions[[length(...future.conditions) + 
[18:02:07.346]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:07.346]                     cond$call), session = sessionInformation(), 
[18:02:07.346]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:07.346]                   signalCondition(cond)
[18:02:07.346]                 }
[18:02:07.346]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:07.346]                 "immediateCondition"))) {
[18:02:07.346]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:07.346]                   ...future.conditions[[length(...future.conditions) + 
[18:02:07.346]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:07.346]                   if (TRUE && !signal) {
[18:02:07.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:07.346]                     {
[18:02:07.346]                       inherits <- base::inherits
[18:02:07.346]                       invokeRestart <- base::invokeRestart
[18:02:07.346]                       is.null <- base::is.null
[18:02:07.346]                       muffled <- FALSE
[18:02:07.346]                       if (inherits(cond, "message")) {
[18:02:07.346]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:07.346]                         if (muffled) 
[18:02:07.346]                           invokeRestart("muffleMessage")
[18:02:07.346]                       }
[18:02:07.346]                       else if (inherits(cond, "warning")) {
[18:02:07.346]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:07.346]                         if (muffled) 
[18:02:07.346]                           invokeRestart("muffleWarning")
[18:02:07.346]                       }
[18:02:07.346]                       else if (inherits(cond, "condition")) {
[18:02:07.346]                         if (!is.null(pattern)) {
[18:02:07.346]                           computeRestarts <- base::computeRestarts
[18:02:07.346]                           grepl <- base::grepl
[18:02:07.346]                           restarts <- computeRestarts(cond)
[18:02:07.346]                           for (restart in restarts) {
[18:02:07.346]                             name <- restart$name
[18:02:07.346]                             if (is.null(name)) 
[18:02:07.346]                               next
[18:02:07.346]                             if (!grepl(pattern, name)) 
[18:02:07.346]                               next
[18:02:07.346]                             invokeRestart(restart)
[18:02:07.346]                             muffled <- TRUE
[18:02:07.346]                             break
[18:02:07.346]                           }
[18:02:07.346]                         }
[18:02:07.346]                       }
[18:02:07.346]                       invisible(muffled)
[18:02:07.346]                     }
[18:02:07.346]                     muffleCondition(cond, pattern = "^muffle")
[18:02:07.346]                   }
[18:02:07.346]                 }
[18:02:07.346]                 else {
[18:02:07.346]                   if (TRUE) {
[18:02:07.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:07.346]                     {
[18:02:07.346]                       inherits <- base::inherits
[18:02:07.346]                       invokeRestart <- base::invokeRestart
[18:02:07.346]                       is.null <- base::is.null
[18:02:07.346]                       muffled <- FALSE
[18:02:07.346]                       if (inherits(cond, "message")) {
[18:02:07.346]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:07.346]                         if (muffled) 
[18:02:07.346]                           invokeRestart("muffleMessage")
[18:02:07.346]                       }
[18:02:07.346]                       else if (inherits(cond, "warning")) {
[18:02:07.346]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:07.346]                         if (muffled) 
[18:02:07.346]                           invokeRestart("muffleWarning")
[18:02:07.346]                       }
[18:02:07.346]                       else if (inherits(cond, "condition")) {
[18:02:07.346]                         if (!is.null(pattern)) {
[18:02:07.346]                           computeRestarts <- base::computeRestarts
[18:02:07.346]                           grepl <- base::grepl
[18:02:07.346]                           restarts <- computeRestarts(cond)
[18:02:07.346]                           for (restart in restarts) {
[18:02:07.346]                             name <- restart$name
[18:02:07.346]                             if (is.null(name)) 
[18:02:07.346]                               next
[18:02:07.346]                             if (!grepl(pattern, name)) 
[18:02:07.346]                               next
[18:02:07.346]                             invokeRestart(restart)
[18:02:07.346]                             muffled <- TRUE
[18:02:07.346]                             break
[18:02:07.346]                           }
[18:02:07.346]                         }
[18:02:07.346]                       }
[18:02:07.346]                       invisible(muffled)
[18:02:07.346]                     }
[18:02:07.346]                     muffleCondition(cond, pattern = "^muffle")
[18:02:07.346]                   }
[18:02:07.346]                 }
[18:02:07.346]             }
[18:02:07.346]         }))
[18:02:07.346]     }, error = function(ex) {
[18:02:07.346]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:07.346]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:07.346]                 ...future.rng), started = ...future.startTime, 
[18:02:07.346]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:07.346]             version = "1.8"), class = "FutureResult")
[18:02:07.346]     }, finally = {
[18:02:07.346]         if (!identical(...future.workdir, getwd())) 
[18:02:07.346]             setwd(...future.workdir)
[18:02:07.346]         {
[18:02:07.346]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:07.346]                 ...future.oldOptions$nwarnings <- NULL
[18:02:07.346]             }
[18:02:07.346]             base::options(...future.oldOptions)
[18:02:07.346]             if (.Platform$OS.type == "windows") {
[18:02:07.346]                 old_names <- names(...future.oldEnvVars)
[18:02:07.346]                 envs <- base::Sys.getenv()
[18:02:07.346]                 names <- names(envs)
[18:02:07.346]                 common <- intersect(names, old_names)
[18:02:07.346]                 added <- setdiff(names, old_names)
[18:02:07.346]                 removed <- setdiff(old_names, names)
[18:02:07.346]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:07.346]                   envs[common]]
[18:02:07.346]                 NAMES <- toupper(changed)
[18:02:07.346]                 args <- list()
[18:02:07.346]                 for (kk in seq_along(NAMES)) {
[18:02:07.346]                   name <- changed[[kk]]
[18:02:07.346]                   NAME <- NAMES[[kk]]
[18:02:07.346]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:07.346]                     next
[18:02:07.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:07.346]                 }
[18:02:07.346]                 NAMES <- toupper(added)
[18:02:07.346]                 for (kk in seq_along(NAMES)) {
[18:02:07.346]                   name <- added[[kk]]
[18:02:07.346]                   NAME <- NAMES[[kk]]
[18:02:07.346]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:07.346]                     next
[18:02:07.346]                   args[[name]] <- ""
[18:02:07.346]                 }
[18:02:07.346]                 NAMES <- toupper(removed)
[18:02:07.346]                 for (kk in seq_along(NAMES)) {
[18:02:07.346]                   name <- removed[[kk]]
[18:02:07.346]                   NAME <- NAMES[[kk]]
[18:02:07.346]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:07.346]                     next
[18:02:07.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:07.346]                 }
[18:02:07.346]                 if (length(args) > 0) 
[18:02:07.346]                   base::do.call(base::Sys.setenv, args = args)
[18:02:07.346]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:07.346]             }
[18:02:07.346]             else {
[18:02:07.346]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:07.346]             }
[18:02:07.346]             {
[18:02:07.346]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:07.346]                   0L) {
[18:02:07.346]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:07.346]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:07.346]                   base::options(opts)
[18:02:07.346]                 }
[18:02:07.346]                 {
[18:02:07.346]                   {
[18:02:07.346]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:07.346]                     NULL
[18:02:07.346]                   }
[18:02:07.346]                   options(future.plan = NULL)
[18:02:07.346]                   if (is.na(NA_character_)) 
[18:02:07.346]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:07.346]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:07.346]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:07.346]                     .init = FALSE)
[18:02:07.346]                 }
[18:02:07.346]             }
[18:02:07.346]         }
[18:02:07.346]     })
[18:02:07.346]     if (TRUE) {
[18:02:07.346]         base::sink(type = "output", split = FALSE)
[18:02:07.346]         if (TRUE) {
[18:02:07.346]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:07.346]         }
[18:02:07.346]         else {
[18:02:07.346]             ...future.result["stdout"] <- base::list(NULL)
[18:02:07.346]         }
[18:02:07.346]         base::close(...future.stdout)
[18:02:07.346]         ...future.stdout <- NULL
[18:02:07.346]     }
[18:02:07.346]     ...future.result$conditions <- ...future.conditions
[18:02:07.346]     ...future.result$finished <- base::Sys.time()
[18:02:07.346]     ...future.result
[18:02:07.346] }
[18:02:07.351] Exporting 5 global objects (45.86 KiB) to cluster node #2 ...
[18:02:07.352] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ...
[18:02:07.393] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ... DONE
[18:02:07.394] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:07.395] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:07.396] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[18:02:07.397] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[18:02:07.397] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:07.398] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:07.398] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:07.399] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:07.399] Exporting 5 global objects (45.86 KiB) to cluster node #2 ... DONE
[18:02:07.400] MultisessionFuture started
[18:02:07.400] - Launch lazy future ... done
[18:02:07.400] run() for ‘MultisessionFuture’ ... done
[18:02:07.401] Created future:
[18:02:07.401] MultisessionFuture:
[18:02:07.401] Label: ‘future_sapply-2’
[18:02:07.401] Expression:
[18:02:07.401] {
[18:02:07.401]     do.call(function(...) {
[18:02:07.401]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:07.401]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:07.401]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:07.401]             on.exit(options(oopts), add = TRUE)
[18:02:07.401]         }
[18:02:07.401]         {
[18:02:07.401]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:07.401]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:07.401]                 ...future.FUN(...future.X_jj, ...)
[18:02:07.401]             })
[18:02:07.401]         }
[18:02:07.401]     }, args = future.call.arguments)
[18:02:07.401] }
[18:02:07.401] Lazy evaluation: FALSE
[18:02:07.401] Asynchronous evaluation: TRUE
[18:02:07.401] Local evaluation: TRUE
[18:02:07.401] Environment: R_GlobalEnv
[18:02:07.401] Capture standard output: TRUE
[18:02:07.401] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:07.401] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:07.401] Packages: 1 packages (‘stats’)
[18:02:07.401] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:07.401] Resolved: FALSE
[18:02:07.401] Value: <not collected>
[18:02:07.401] Conditions captured: <none>
[18:02:07.401] Early signaling: FALSE
[18:02:07.401] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:07.401] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:07.414] Chunk #2 of 2 ... DONE
[18:02:07.414] Launching 2 futures (chunks) ... DONE
[18:02:07.414] Resolving 2 futures (chunks) ...
[18:02:07.414] resolve() on list ...
[18:02:07.415]  recursive: 0
[18:02:07.415]  length: 2
[18:02:07.415] 
[18:02:07.416] receiveMessageFromWorker() for ClusterFuture ...
[18:02:07.416] - Validating connection of MultisessionFuture
[18:02:07.416] - received message: FutureResult
[18:02:07.417] - Received FutureResult
[18:02:07.417] - Erased future from FutureRegistry
[18:02:07.417] result() for ClusterFuture ...
[18:02:07.417] - result already collected: FutureResult
[18:02:07.417] result() for ClusterFuture ... done
[18:02:07.418] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:07.418] Future #1
[18:02:07.418] result() for ClusterFuture ...
[18:02:07.418] - result already collected: FutureResult
[18:02:07.418] result() for ClusterFuture ... done
[18:02:07.419] result() for ClusterFuture ...
[18:02:07.419] - result already collected: FutureResult
[18:02:07.419] result() for ClusterFuture ... done
[18:02:07.419] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:07.419] - nx: 2
[18:02:07.420] - relay: TRUE
[18:02:07.420] - stdout: TRUE
[18:02:07.420] - signal: TRUE
[18:02:07.420] - resignal: FALSE
[18:02:07.420] - force: TRUE
[18:02:07.420] - relayed: [n=2] FALSE, FALSE
[18:02:07.421] - queued futures: [n=2] FALSE, FALSE
[18:02:07.421]  - until=1
[18:02:07.421]  - relaying element #1
[18:02:07.421] result() for ClusterFuture ...
[18:02:07.421] - result already collected: FutureResult
[18:02:07.421] result() for ClusterFuture ... done
[18:02:07.422] result() for ClusterFuture ...
[18:02:07.422] - result already collected: FutureResult
[18:02:07.422] result() for ClusterFuture ... done
[18:02:07.422] result() for ClusterFuture ...
[18:02:07.422] - result already collected: FutureResult
[18:02:07.423] result() for ClusterFuture ... done
[18:02:07.423] result() for ClusterFuture ...
[18:02:07.423] - result already collected: FutureResult
[18:02:07.423] result() for ClusterFuture ... done
[18:02:07.423] - relayed: [n=2] TRUE, FALSE
[18:02:07.424] - queued futures: [n=2] TRUE, FALSE
[18:02:07.424] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:07.424]  length: 1 (resolved future 1)
[18:02:07.446] receiveMessageFromWorker() for ClusterFuture ...
[18:02:07.447] - Validating connection of MultisessionFuture
[18:02:07.447] - received message: FutureResult
[18:02:07.447] - Received FutureResult
[18:02:07.448] - Erased future from FutureRegistry
[18:02:07.448] result() for ClusterFuture ...
[18:02:07.448] - result already collected: FutureResult
[18:02:07.448] result() for ClusterFuture ... done
[18:02:07.449] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:07.449] Future #2
[18:02:07.449] result() for ClusterFuture ...
[18:02:07.449] - result already collected: FutureResult
[18:02:07.449] result() for ClusterFuture ... done
[18:02:07.450] result() for ClusterFuture ...
[18:02:07.450] - result already collected: FutureResult
[18:02:07.450] result() for ClusterFuture ... done
[18:02:07.450] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:07.451] - nx: 2
[18:02:07.451] - relay: TRUE
[18:02:07.451] - stdout: TRUE
[18:02:07.451] - signal: TRUE
[18:02:07.451] - resignal: FALSE
[18:02:07.452] - force: TRUE
[18:02:07.452] - relayed: [n=2] TRUE, FALSE
[18:02:07.452] - queued futures: [n=2] TRUE, FALSE
[18:02:07.452]  - until=2
[18:02:07.453]  - relaying element #2
[18:02:07.453] result() for ClusterFuture ...
[18:02:07.453] - result already collected: FutureResult
[18:02:07.453] result() for ClusterFuture ... done
[18:02:07.454] result() for ClusterFuture ...
[18:02:07.454] - result already collected: FutureResult
[18:02:07.454] result() for ClusterFuture ... done
[18:02:07.454] result() for ClusterFuture ...
[18:02:07.455] - result already collected: FutureResult
[18:02:07.455] result() for ClusterFuture ... done
[18:02:07.455] result() for ClusterFuture ...
[18:02:07.455] - result already collected: FutureResult
[18:02:07.455] result() for ClusterFuture ... done
[18:02:07.456] - relayed: [n=2] TRUE, TRUE
[18:02:07.456] - queued futures: [n=2] TRUE, TRUE
[18:02:07.456] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:07.456]  length: 0 (resolved future 2)
[18:02:07.457] Relaying remaining futures
[18:02:07.457] signalConditionsASAP(NULL, pos=0) ...
[18:02:07.457] - nx: 2
[18:02:07.457] - relay: TRUE
[18:02:07.457] - stdout: TRUE
[18:02:07.458] - signal: TRUE
[18:02:07.458] - resignal: FALSE
[18:02:07.458] - force: TRUE
[18:02:07.458] - relayed: [n=2] TRUE, TRUE
[18:02:07.458] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:07.459] - relayed: [n=2] TRUE, TRUE
[18:02:07.459] - queued futures: [n=2] TRUE, TRUE
[18:02:07.459] signalConditionsASAP(NULL, pos=0) ... done
[18:02:07.459] resolve() on list ... DONE
[18:02:07.460] result() for ClusterFuture ...
[18:02:07.460] - result already collected: FutureResult
[18:02:07.460] result() for ClusterFuture ... done
[18:02:07.460] result() for ClusterFuture ...
[18:02:07.461] - result already collected: FutureResult
[18:02:07.461] result() for ClusterFuture ... done
[18:02:07.461] result() for ClusterFuture ...
[18:02:07.461] - result already collected: FutureResult
[18:02:07.461] result() for ClusterFuture ... done
[18:02:07.462] result() for ClusterFuture ...
[18:02:07.462] - result already collected: FutureResult
[18:02:07.462] result() for ClusterFuture ... done
[18:02:07.462]  - Number of value chunks collected: 2
[18:02:07.463] Resolving 2 futures (chunks) ... DONE
[18:02:07.463] Reducing values from 2 chunks ...
[18:02:07.463]  - Number of values collected after concatenation: 7
[18:02:07.463]  - Number of values expected: 7
[18:02:07.464] Reducing values from 2 chunks ... DONE
[18:02:07.464] future_lapply() ... DONE
[18:02:07.465] future_lapply() ...
[18:02:07.475] Number of chunks: 2
[18:02:07.476] getGlobalsAndPackagesXApply() ...
[18:02:07.476]  - future.globals: TRUE
[18:02:07.476] getGlobalsAndPackages() ...
[18:02:07.476] Searching for globals...
[18:02:07.491] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[18:02:07.492] Searching for globals ... DONE
[18:02:07.492] Resolving globals: FALSE
[18:02:07.494] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[18:02:07.495] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[18:02:07.496] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:07.496] - packages: [2] ‘stats’, ‘future.apply’
[18:02:07.496] getGlobalsAndPackages() ... DONE
[18:02:07.496]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:07.496]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[18:02:07.497] Finding globals ... DONE
[18:02:07.497]  - use_args: TRUE
[18:02:07.497]  - Getting '...' globals ...
[18:02:07.498] resolve() on list ...
[18:02:07.498]  recursive: 0
[18:02:07.498]  length: 1
[18:02:07.498]  elements: ‘...’
[18:02:07.499]  length: 0 (resolved future 1)
[18:02:07.499] resolve() on list ... DONE
[18:02:07.499]    - '...' content: [n=0] 
[18:02:07.499] List of 1
[18:02:07.499]  $ ...: list()
[18:02:07.499]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:07.499]  - attr(*, "where")=List of 1
[18:02:07.499]   ..$ ...:<environment: 0x6183c17a9f70> 
[18:02:07.499]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:07.499]  - attr(*, "resolved")= logi TRUE
[18:02:07.499]  - attr(*, "total_size")= num NA
[18:02:07.505]  - Getting '...' globals ... DONE
[18:02:07.505] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:07.505] List of 8
[18:02:07.505]  $ ...future.FUN:function (x, ...)  
[18:02:07.505]  $ x_FUN        :function (x, na.rm = TRUE)  
[18:02:07.505]  $ times        : int 5
[18:02:07.505]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:07.505]  $ stop_if_not  :function (...)  
[18:02:07.505]  $ dim          : NULL
[18:02:07.505]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:02:07.505]  $ ...          : list()
[18:02:07.505]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:07.505]  - attr(*, "where")=List of 8
[18:02:07.505]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:07.505]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:07.505]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:07.505]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:07.505]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:07.505]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:07.505]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:07.505]   ..$ ...          :<environment: 0x6183c17a9f70> 
[18:02:07.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:07.505]  - attr(*, "resolved")= logi FALSE
[18:02:07.505]  - attr(*, "total_size")= num 141240
[18:02:07.517] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[18:02:07.518] getGlobalsAndPackagesXApply() ... DONE
[18:02:07.518] Number of futures (= number of chunks): 2
[18:02:07.518] Launching 2 futures (chunks) ...
[18:02:07.519] Chunk #1 of 2 ...
[18:02:07.519]  - Finding globals in 'X' for chunk #1 ...
[18:02:07.519] getGlobalsAndPackages() ...
[18:02:07.519] Searching for globals...
[18:02:07.520] 
[18:02:07.520] Searching for globals ... DONE
[18:02:07.520] - globals: [0] <none>
[18:02:07.521] getGlobalsAndPackages() ... DONE
[18:02:07.521]    + additional globals found: [n=0] 
[18:02:07.521]    + additional namespaces needed: [n=0] 
[18:02:07.521]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:07.521]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:07.522]  - seeds: <none>
[18:02:07.522]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:07.522] getGlobalsAndPackages() ...
[18:02:07.522] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:07.522] Resolving globals: FALSE
[18:02:07.523] Tweak future expression to call with '...' arguments ...
[18:02:07.523] {
[18:02:07.523]     do.call(function(...) {
[18:02:07.523]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:07.523]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:07.523]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:07.523]             on.exit(options(oopts), add = TRUE)
[18:02:07.523]         }
[18:02:07.523]         {
[18:02:07.523]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:07.523]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:07.523]                 ...future.FUN(...future.X_jj, ...)
[18:02:07.523]             })
[18:02:07.523]         }
[18:02:07.523]     }, args = future.call.arguments)
[18:02:07.523] }
[18:02:07.524] Tweak future expression to call with '...' arguments ... DONE
[18:02:07.525] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:07.525] - packages: [2] ‘stats’, ‘future.apply’
[18:02:07.525] getGlobalsAndPackages() ... DONE
[18:02:07.526] run() for ‘Future’ ...
[18:02:07.526] - state: ‘created’
[18:02:07.526] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:07.550] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:07.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:07.551]   - Field: ‘node’
[18:02:07.551]   - Field: ‘label’
[18:02:07.551]   - Field: ‘local’
[18:02:07.551]   - Field: ‘owner’
[18:02:07.551]   - Field: ‘envir’
[18:02:07.552]   - Field: ‘workers’
[18:02:07.552]   - Field: ‘packages’
[18:02:07.552]   - Field: ‘gc’
[18:02:07.552]   - Field: ‘conditions’
[18:02:07.552]   - Field: ‘persistent’
[18:02:07.553]   - Field: ‘expr’
[18:02:07.553]   - Field: ‘uuid’
[18:02:07.553]   - Field: ‘seed’
[18:02:07.553]   - Field: ‘version’
[18:02:07.553]   - Field: ‘result’
[18:02:07.554]   - Field: ‘asynchronous’
[18:02:07.554]   - Field: ‘calls’
[18:02:07.554]   - Field: ‘globals’
[18:02:07.554]   - Field: ‘stdout’
[18:02:07.554]   - Field: ‘earlySignal’
[18:02:07.555]   - Field: ‘lazy’
[18:02:07.555]   - Field: ‘state’
[18:02:07.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:07.555] - Launch lazy future ...
[18:02:07.556] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[18:02:07.556] Packages needed by future strategies (n = 0): <none>
[18:02:07.557] {
[18:02:07.557]     {
[18:02:07.557]         {
[18:02:07.557]             ...future.startTime <- base::Sys.time()
[18:02:07.557]             {
[18:02:07.557]                 {
[18:02:07.557]                   {
[18:02:07.557]                     {
[18:02:07.557]                       {
[18:02:07.557]                         base::local({
[18:02:07.557]                           has_future <- base::requireNamespace("future", 
[18:02:07.557]                             quietly = TRUE)
[18:02:07.557]                           if (has_future) {
[18:02:07.557]                             ns <- base::getNamespace("future")
[18:02:07.557]                             version <- ns[[".package"]][["version"]]
[18:02:07.557]                             if (is.null(version)) 
[18:02:07.557]                               version <- utils::packageVersion("future")
[18:02:07.557]                           }
[18:02:07.557]                           else {
[18:02:07.557]                             version <- NULL
[18:02:07.557]                           }
[18:02:07.557]                           if (!has_future || version < "1.8.0") {
[18:02:07.557]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:07.557]                               "", base::R.version$version.string), 
[18:02:07.557]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:07.557]                                 base::R.version$platform, 8 * 
[18:02:07.557]                                   base::.Machine$sizeof.pointer), 
[18:02:07.557]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:07.557]                                 "release", "version")], collapse = " "), 
[18:02:07.557]                               hostname = base::Sys.info()[["nodename"]])
[18:02:07.557]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:07.557]                               info)
[18:02:07.557]                             info <- base::paste(info, collapse = "; ")
[18:02:07.557]                             if (!has_future) {
[18:02:07.557]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:07.557]                                 info)
[18:02:07.557]                             }
[18:02:07.557]                             else {
[18:02:07.557]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:07.557]                                 info, version)
[18:02:07.557]                             }
[18:02:07.557]                             base::stop(msg)
[18:02:07.557]                           }
[18:02:07.557]                         })
[18:02:07.557]                       }
[18:02:07.557]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:07.557]                       base::options(mc.cores = 1L)
[18:02:07.557]                     }
[18:02:07.557]                     base::local({
[18:02:07.557]                       for (pkg in c("stats", "future.apply")) {
[18:02:07.557]                         base::loadNamespace(pkg)
[18:02:07.557]                         base::library(pkg, character.only = TRUE)
[18:02:07.557]                       }
[18:02:07.557]                     })
[18:02:07.557]                   }
[18:02:07.557]                   ...future.strategy.old <- future::plan("list")
[18:02:07.557]                   options(future.plan = NULL)
[18:02:07.557]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:07.557]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:07.557]                 }
[18:02:07.557]                 ...future.workdir <- getwd()
[18:02:07.557]             }
[18:02:07.557]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:07.557]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:07.557]         }
[18:02:07.557]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:07.557]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:07.557]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:07.557]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:07.557]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:07.557]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:07.557]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:07.557]             base::names(...future.oldOptions))
[18:02:07.557]     }
[18:02:07.557]     if (FALSE) {
[18:02:07.557]     }
[18:02:07.557]     else {
[18:02:07.557]         if (TRUE) {
[18:02:07.557]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:07.557]                 open = "w")
[18:02:07.557]         }
[18:02:07.557]         else {
[18:02:07.557]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:07.557]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:07.557]         }
[18:02:07.557]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:07.557]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:07.557]             base::sink(type = "output", split = FALSE)
[18:02:07.557]             base::close(...future.stdout)
[18:02:07.557]         }, add = TRUE)
[18:02:07.557]     }
[18:02:07.557]     ...future.frame <- base::sys.nframe()
[18:02:07.557]     ...future.conditions <- base::list()
[18:02:07.557]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:07.557]     if (FALSE) {
[18:02:07.557]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:07.557]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:07.557]     }
[18:02:07.557]     ...future.result <- base::tryCatch({
[18:02:07.557]         base::withCallingHandlers({
[18:02:07.557]             ...future.value <- base::withVisible(base::local({
[18:02:07.557]                 ...future.makeSendCondition <- base::local({
[18:02:07.557]                   sendCondition <- NULL
[18:02:07.557]                   function(frame = 1L) {
[18:02:07.557]                     if (is.function(sendCondition)) 
[18:02:07.557]                       return(sendCondition)
[18:02:07.557]                     ns <- getNamespace("parallel")
[18:02:07.557]                     if (exists("sendData", mode = "function", 
[18:02:07.557]                       envir = ns)) {
[18:02:07.557]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:07.557]                         envir = ns)
[18:02:07.557]                       envir <- sys.frame(frame)
[18:02:07.557]                       master <- NULL
[18:02:07.557]                       while (!identical(envir, .GlobalEnv) && 
[18:02:07.557]                         !identical(envir, emptyenv())) {
[18:02:07.557]                         if (exists("master", mode = "list", envir = envir, 
[18:02:07.557]                           inherits = FALSE)) {
[18:02:07.557]                           master <- get("master", mode = "list", 
[18:02:07.557]                             envir = envir, inherits = FALSE)
[18:02:07.557]                           if (inherits(master, c("SOCKnode", 
[18:02:07.557]                             "SOCK0node"))) {
[18:02:07.557]                             sendCondition <<- function(cond) {
[18:02:07.557]                               data <- list(type = "VALUE", value = cond, 
[18:02:07.557]                                 success = TRUE)
[18:02:07.557]                               parallel_sendData(master, data)
[18:02:07.557]                             }
[18:02:07.557]                             return(sendCondition)
[18:02:07.557]                           }
[18:02:07.557]                         }
[18:02:07.557]                         frame <- frame + 1L
[18:02:07.557]                         envir <- sys.frame(frame)
[18:02:07.557]                       }
[18:02:07.557]                     }
[18:02:07.557]                     sendCondition <<- function(cond) NULL
[18:02:07.557]                   }
[18:02:07.557]                 })
[18:02:07.557]                 withCallingHandlers({
[18:02:07.557]                   {
[18:02:07.557]                     do.call(function(...) {
[18:02:07.557]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:07.557]                       if (!identical(...future.globals.maxSize.org, 
[18:02:07.557]                         ...future.globals.maxSize)) {
[18:02:07.557]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:07.557]                         on.exit(options(oopts), add = TRUE)
[18:02:07.557]                       }
[18:02:07.557]                       {
[18:02:07.557]                         lapply(seq_along(...future.elements_ii), 
[18:02:07.557]                           FUN = function(jj) {
[18:02:07.557]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:07.557]                             ...future.FUN(...future.X_jj, ...)
[18:02:07.557]                           })
[18:02:07.557]                       }
[18:02:07.557]                     }, args = future.call.arguments)
[18:02:07.557]                   }
[18:02:07.557]                 }, immediateCondition = function(cond) {
[18:02:07.557]                   sendCondition <- ...future.makeSendCondition()
[18:02:07.557]                   sendCondition(cond)
[18:02:07.557]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:07.557]                   {
[18:02:07.557]                     inherits <- base::inherits
[18:02:07.557]                     invokeRestart <- base::invokeRestart
[18:02:07.557]                     is.null <- base::is.null
[18:02:07.557]                     muffled <- FALSE
[18:02:07.557]                     if (inherits(cond, "message")) {
[18:02:07.557]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:07.557]                       if (muffled) 
[18:02:07.557]                         invokeRestart("muffleMessage")
[18:02:07.557]                     }
[18:02:07.557]                     else if (inherits(cond, "warning")) {
[18:02:07.557]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:07.557]                       if (muffled) 
[18:02:07.557]                         invokeRestart("muffleWarning")
[18:02:07.557]                     }
[18:02:07.557]                     else if (inherits(cond, "condition")) {
[18:02:07.557]                       if (!is.null(pattern)) {
[18:02:07.557]                         computeRestarts <- base::computeRestarts
[18:02:07.557]                         grepl <- base::grepl
[18:02:07.557]                         restarts <- computeRestarts(cond)
[18:02:07.557]                         for (restart in restarts) {
[18:02:07.557]                           name <- restart$name
[18:02:07.557]                           if (is.null(name)) 
[18:02:07.557]                             next
[18:02:07.557]                           if (!grepl(pattern, name)) 
[18:02:07.557]                             next
[18:02:07.557]                           invokeRestart(restart)
[18:02:07.557]                           muffled <- TRUE
[18:02:07.557]                           break
[18:02:07.557]                         }
[18:02:07.557]                       }
[18:02:07.557]                     }
[18:02:07.557]                     invisible(muffled)
[18:02:07.557]                   }
[18:02:07.557]                   muffleCondition(cond)
[18:02:07.557]                 })
[18:02:07.557]             }))
[18:02:07.557]             future::FutureResult(value = ...future.value$value, 
[18:02:07.557]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:07.557]                   ...future.rng), globalenv = if (FALSE) 
[18:02:07.557]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:07.557]                     ...future.globalenv.names))
[18:02:07.557]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:07.557]         }, condition = base::local({
[18:02:07.557]             c <- base::c
[18:02:07.557]             inherits <- base::inherits
[18:02:07.557]             invokeRestart <- base::invokeRestart
[18:02:07.557]             length <- base::length
[18:02:07.557]             list <- base::list
[18:02:07.557]             seq.int <- base::seq.int
[18:02:07.557]             signalCondition <- base::signalCondition
[18:02:07.557]             sys.calls <- base::sys.calls
[18:02:07.557]             `[[` <- base::`[[`
[18:02:07.557]             `+` <- base::`+`
[18:02:07.557]             `<<-` <- base::`<<-`
[18:02:07.557]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:07.557]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:07.557]                   3L)]
[18:02:07.557]             }
[18:02:07.557]             function(cond) {
[18:02:07.557]                 is_error <- inherits(cond, "error")
[18:02:07.557]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:07.557]                   NULL)
[18:02:07.557]                 if (is_error) {
[18:02:07.557]                   sessionInformation <- function() {
[18:02:07.557]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:07.557]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:07.557]                       search = base::search(), system = base::Sys.info())
[18:02:07.557]                   }
[18:02:07.557]                   ...future.conditions[[length(...future.conditions) + 
[18:02:07.557]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:07.557]                     cond$call), session = sessionInformation(), 
[18:02:07.557]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:07.557]                   signalCondition(cond)
[18:02:07.557]                 }
[18:02:07.557]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:07.557]                 "immediateCondition"))) {
[18:02:07.557]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:07.557]                   ...future.conditions[[length(...future.conditions) + 
[18:02:07.557]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:07.557]                   if (TRUE && !signal) {
[18:02:07.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:07.557]                     {
[18:02:07.557]                       inherits <- base::inherits
[18:02:07.557]                       invokeRestart <- base::invokeRestart
[18:02:07.557]                       is.null <- base::is.null
[18:02:07.557]                       muffled <- FALSE
[18:02:07.557]                       if (inherits(cond, "message")) {
[18:02:07.557]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:07.557]                         if (muffled) 
[18:02:07.557]                           invokeRestart("muffleMessage")
[18:02:07.557]                       }
[18:02:07.557]                       else if (inherits(cond, "warning")) {
[18:02:07.557]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:07.557]                         if (muffled) 
[18:02:07.557]                           invokeRestart("muffleWarning")
[18:02:07.557]                       }
[18:02:07.557]                       else if (inherits(cond, "condition")) {
[18:02:07.557]                         if (!is.null(pattern)) {
[18:02:07.557]                           computeRestarts <- base::computeRestarts
[18:02:07.557]                           grepl <- base::grepl
[18:02:07.557]                           restarts <- computeRestarts(cond)
[18:02:07.557]                           for (restart in restarts) {
[18:02:07.557]                             name <- restart$name
[18:02:07.557]                             if (is.null(name)) 
[18:02:07.557]                               next
[18:02:07.557]                             if (!grepl(pattern, name)) 
[18:02:07.557]                               next
[18:02:07.557]                             invokeRestart(restart)
[18:02:07.557]                             muffled <- TRUE
[18:02:07.557]                             break
[18:02:07.557]                           }
[18:02:07.557]                         }
[18:02:07.557]                       }
[18:02:07.557]                       invisible(muffled)
[18:02:07.557]                     }
[18:02:07.557]                     muffleCondition(cond, pattern = "^muffle")
[18:02:07.557]                   }
[18:02:07.557]                 }
[18:02:07.557]                 else {
[18:02:07.557]                   if (TRUE) {
[18:02:07.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:07.557]                     {
[18:02:07.557]                       inherits <- base::inherits
[18:02:07.557]                       invokeRestart <- base::invokeRestart
[18:02:07.557]                       is.null <- base::is.null
[18:02:07.557]                       muffled <- FALSE
[18:02:07.557]                       if (inherits(cond, "message")) {
[18:02:07.557]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:07.557]                         if (muffled) 
[18:02:07.557]                           invokeRestart("muffleMessage")
[18:02:07.557]                       }
[18:02:07.557]                       else if (inherits(cond, "warning")) {
[18:02:07.557]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:07.557]                         if (muffled) 
[18:02:07.557]                           invokeRestart("muffleWarning")
[18:02:07.557]                       }
[18:02:07.557]                       else if (inherits(cond, "condition")) {
[18:02:07.557]                         if (!is.null(pattern)) {
[18:02:07.557]                           computeRestarts <- base::computeRestarts
[18:02:07.557]                           grepl <- base::grepl
[18:02:07.557]                           restarts <- computeRestarts(cond)
[18:02:07.557]                           for (restart in restarts) {
[18:02:07.557]                             name <- restart$name
[18:02:07.557]                             if (is.null(name)) 
[18:02:07.557]                               next
[18:02:07.557]                             if (!grepl(pattern, name)) 
[18:02:07.557]                               next
[18:02:07.557]                             invokeRestart(restart)
[18:02:07.557]                             muffled <- TRUE
[18:02:07.557]                             break
[18:02:07.557]                           }
[18:02:07.557]                         }
[18:02:07.557]                       }
[18:02:07.557]                       invisible(muffled)
[18:02:07.557]                     }
[18:02:07.557]                     muffleCondition(cond, pattern = "^muffle")
[18:02:07.557]                   }
[18:02:07.557]                 }
[18:02:07.557]             }
[18:02:07.557]         }))
[18:02:07.557]     }, error = function(ex) {
[18:02:07.557]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:07.557]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:07.557]                 ...future.rng), started = ...future.startTime, 
[18:02:07.557]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:07.557]             version = "1.8"), class = "FutureResult")
[18:02:07.557]     }, finally = {
[18:02:07.557]         if (!identical(...future.workdir, getwd())) 
[18:02:07.557]             setwd(...future.workdir)
[18:02:07.557]         {
[18:02:07.557]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:07.557]                 ...future.oldOptions$nwarnings <- NULL
[18:02:07.557]             }
[18:02:07.557]             base::options(...future.oldOptions)
[18:02:07.557]             if (.Platform$OS.type == "windows") {
[18:02:07.557]                 old_names <- names(...future.oldEnvVars)
[18:02:07.557]                 envs <- base::Sys.getenv()
[18:02:07.557]                 names <- names(envs)
[18:02:07.557]                 common <- intersect(names, old_names)
[18:02:07.557]                 added <- setdiff(names, old_names)
[18:02:07.557]                 removed <- setdiff(old_names, names)
[18:02:07.557]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:07.557]                   envs[common]]
[18:02:07.557]                 NAMES <- toupper(changed)
[18:02:07.557]                 args <- list()
[18:02:07.557]                 for (kk in seq_along(NAMES)) {
[18:02:07.557]                   name <- changed[[kk]]
[18:02:07.557]                   NAME <- NAMES[[kk]]
[18:02:07.557]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:07.557]                     next
[18:02:07.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:07.557]                 }
[18:02:07.557]                 NAMES <- toupper(added)
[18:02:07.557]                 for (kk in seq_along(NAMES)) {
[18:02:07.557]                   name <- added[[kk]]
[18:02:07.557]                   NAME <- NAMES[[kk]]
[18:02:07.557]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:07.557]                     next
[18:02:07.557]                   args[[name]] <- ""
[18:02:07.557]                 }
[18:02:07.557]                 NAMES <- toupper(removed)
[18:02:07.557]                 for (kk in seq_along(NAMES)) {
[18:02:07.557]                   name <- removed[[kk]]
[18:02:07.557]                   NAME <- NAMES[[kk]]
[18:02:07.557]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:07.557]                     next
[18:02:07.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:07.557]                 }
[18:02:07.557]                 if (length(args) > 0) 
[18:02:07.557]                   base::do.call(base::Sys.setenv, args = args)
[18:02:07.557]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:07.557]             }
[18:02:07.557]             else {
[18:02:07.557]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:07.557]             }
[18:02:07.557]             {
[18:02:07.557]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:07.557]                   0L) {
[18:02:07.557]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:07.557]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:07.557]                   base::options(opts)
[18:02:07.557]                 }
[18:02:07.557]                 {
[18:02:07.557]                   {
[18:02:07.557]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:07.557]                     NULL
[18:02:07.557]                   }
[18:02:07.557]                   options(future.plan = NULL)
[18:02:07.557]                   if (is.na(NA_character_)) 
[18:02:07.557]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:07.557]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:07.557]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:07.557]                     .init = FALSE)
[18:02:07.557]                 }
[18:02:07.557]             }
[18:02:07.557]         }
[18:02:07.557]     })
[18:02:07.557]     if (TRUE) {
[18:02:07.557]         base::sink(type = "output", split = FALSE)
[18:02:07.557]         if (TRUE) {
[18:02:07.557]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:07.557]         }
[18:02:07.557]         else {
[18:02:07.557]             ...future.result["stdout"] <- base::list(NULL)
[18:02:07.557]         }
[18:02:07.557]         base::close(...future.stdout)
[18:02:07.557]         ...future.stdout <- NULL
[18:02:07.557]     }
[18:02:07.557]     ...future.result$conditions <- ...future.conditions
[18:02:07.557]     ...future.result$finished <- base::Sys.time()
[18:02:07.557]     ...future.result
[18:02:07.557] }
[18:02:07.562] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[18:02:07.563] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[18:02:07.605] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[18:02:07.605] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[18:02:07.646] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[18:02:07.647] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[18:02:07.648] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[18:02:07.648] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[18:02:07.689] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[18:02:07.690] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[18:02:07.731] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[18:02:07.732] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[18:02:07.733] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[18:02:07.734] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[18:02:07.735] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[18:02:07.736] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:07.737] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:07.738] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[18:02:07.739] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[18:02:07.740] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:07.741] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:07.742] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:07.743] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:07.743] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[18:02:07.746] MultisessionFuture started
[18:02:07.746] - Launch lazy future ... done
[18:02:07.747] run() for ‘MultisessionFuture’ ... done
[18:02:07.747] Created future:
[18:02:07.748] MultisessionFuture:
[18:02:07.748] Label: ‘future_vapply-1’
[18:02:07.748] Expression:
[18:02:07.748] {
[18:02:07.748]     do.call(function(...) {
[18:02:07.748]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:07.748]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:07.748]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:07.748]             on.exit(options(oopts), add = TRUE)
[18:02:07.748]         }
[18:02:07.748]         {
[18:02:07.748]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:07.748]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:07.748]                 ...future.FUN(...future.X_jj, ...)
[18:02:07.748]             })
[18:02:07.748]         }
[18:02:07.748]     }, args = future.call.arguments)
[18:02:07.748] }
[18:02:07.748] Lazy evaluation: FALSE
[18:02:07.748] Asynchronous evaluation: TRUE
[18:02:07.748] Local evaluation: TRUE
[18:02:07.748] Environment: R_GlobalEnv
[18:02:07.748] Capture standard output: TRUE
[18:02:07.748] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:07.748] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:07.748] Packages: 2 packages (‘stats’, ‘future.apply’)
[18:02:07.748] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:07.748] Resolved: FALSE
[18:02:07.748] Value: <not collected>
[18:02:07.748] Conditions captured: <none>
[18:02:07.748] Early signaling: FALSE
[18:02:07.748] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:07.748] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:07.763] Chunk #1 of 2 ... DONE
[18:02:07.763] Chunk #2 of 2 ...
[18:02:07.764]  - Finding globals in 'X' for chunk #2 ...
[18:02:07.764] getGlobalsAndPackages() ...
[18:02:07.764] Searching for globals...
[18:02:07.765] 
[18:02:07.766] Searching for globals ... DONE
[18:02:07.766] - globals: [0] <none>
[18:02:07.766] getGlobalsAndPackages() ... DONE
[18:02:07.766]    + additional globals found: [n=0] 
[18:02:07.767]    + additional namespaces needed: [n=0] 
[18:02:07.767]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:07.767]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:07.768]  - seeds: <none>
[18:02:07.768]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:07.768] getGlobalsAndPackages() ...
[18:02:07.769] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:07.769] Resolving globals: FALSE
[18:02:07.769] Tweak future expression to call with '...' arguments ...
[18:02:07.770] {
[18:02:07.770]     do.call(function(...) {
[18:02:07.770]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:07.770]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:07.770]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:07.770]             on.exit(options(oopts), add = TRUE)
[18:02:07.770]         }
[18:02:07.770]         {
[18:02:07.770]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:07.770]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:07.770]                 ...future.FUN(...future.X_jj, ...)
[18:02:07.770]             })
[18:02:07.770]         }
[18:02:07.770]     }, args = future.call.arguments)
[18:02:07.770] }
[18:02:07.771] Tweak future expression to call with '...' arguments ... DONE
[18:02:07.772] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:07.773] - packages: [2] ‘stats’, ‘future.apply’
[18:02:07.773] getGlobalsAndPackages() ... DONE
[18:02:07.774] run() for ‘Future’ ...
[18:02:07.774] - state: ‘created’
[18:02:07.775] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:07.808] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:07.808] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:07.808]   - Field: ‘node’
[18:02:07.808]   - Field: ‘label’
[18:02:07.809]   - Field: ‘local’
[18:02:07.809]   - Field: ‘owner’
[18:02:07.809]   - Field: ‘envir’
[18:02:07.809]   - Field: ‘workers’
[18:02:07.809]   - Field: ‘packages’
[18:02:07.810]   - Field: ‘gc’
[18:02:07.810]   - Field: ‘conditions’
[18:02:07.810]   - Field: ‘persistent’
[18:02:07.810]   - Field: ‘expr’
[18:02:07.810]   - Field: ‘uuid’
[18:02:07.811]   - Field: ‘seed’
[18:02:07.811]   - Field: ‘version’
[18:02:07.811]   - Field: ‘result’
[18:02:07.811]   - Field: ‘asynchronous’
[18:02:07.811]   - Field: ‘calls’
[18:02:07.812]   - Field: ‘globals’
[18:02:07.812]   - Field: ‘stdout’
[18:02:07.812]   - Field: ‘earlySignal’
[18:02:07.812]   - Field: ‘lazy’
[18:02:07.812]   - Field: ‘state’
[18:02:07.813] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:07.813] - Launch lazy future ...
[18:02:07.813] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[18:02:07.814] Packages needed by future strategies (n = 0): <none>
[18:02:07.815] {
[18:02:07.815]     {
[18:02:07.815]         {
[18:02:07.815]             ...future.startTime <- base::Sys.time()
[18:02:07.815]             {
[18:02:07.815]                 {
[18:02:07.815]                   {
[18:02:07.815]                     {
[18:02:07.815]                       {
[18:02:07.815]                         base::local({
[18:02:07.815]                           has_future <- base::requireNamespace("future", 
[18:02:07.815]                             quietly = TRUE)
[18:02:07.815]                           if (has_future) {
[18:02:07.815]                             ns <- base::getNamespace("future")
[18:02:07.815]                             version <- ns[[".package"]][["version"]]
[18:02:07.815]                             if (is.null(version)) 
[18:02:07.815]                               version <- utils::packageVersion("future")
[18:02:07.815]                           }
[18:02:07.815]                           else {
[18:02:07.815]                             version <- NULL
[18:02:07.815]                           }
[18:02:07.815]                           if (!has_future || version < "1.8.0") {
[18:02:07.815]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:07.815]                               "", base::R.version$version.string), 
[18:02:07.815]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:07.815]                                 base::R.version$platform, 8 * 
[18:02:07.815]                                   base::.Machine$sizeof.pointer), 
[18:02:07.815]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:07.815]                                 "release", "version")], collapse = " "), 
[18:02:07.815]                               hostname = base::Sys.info()[["nodename"]])
[18:02:07.815]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:07.815]                               info)
[18:02:07.815]                             info <- base::paste(info, collapse = "; ")
[18:02:07.815]                             if (!has_future) {
[18:02:07.815]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:07.815]                                 info)
[18:02:07.815]                             }
[18:02:07.815]                             else {
[18:02:07.815]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:07.815]                                 info, version)
[18:02:07.815]                             }
[18:02:07.815]                             base::stop(msg)
[18:02:07.815]                           }
[18:02:07.815]                         })
[18:02:07.815]                       }
[18:02:07.815]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:07.815]                       base::options(mc.cores = 1L)
[18:02:07.815]                     }
[18:02:07.815]                     base::local({
[18:02:07.815]                       for (pkg in c("stats", "future.apply")) {
[18:02:07.815]                         base::loadNamespace(pkg)
[18:02:07.815]                         base::library(pkg, character.only = TRUE)
[18:02:07.815]                       }
[18:02:07.815]                     })
[18:02:07.815]                   }
[18:02:07.815]                   ...future.strategy.old <- future::plan("list")
[18:02:07.815]                   options(future.plan = NULL)
[18:02:07.815]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:07.815]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:07.815]                 }
[18:02:07.815]                 ...future.workdir <- getwd()
[18:02:07.815]             }
[18:02:07.815]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:07.815]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:07.815]         }
[18:02:07.815]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:07.815]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:07.815]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:07.815]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:07.815]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:07.815]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:07.815]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:07.815]             base::names(...future.oldOptions))
[18:02:07.815]     }
[18:02:07.815]     if (FALSE) {
[18:02:07.815]     }
[18:02:07.815]     else {
[18:02:07.815]         if (TRUE) {
[18:02:07.815]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:07.815]                 open = "w")
[18:02:07.815]         }
[18:02:07.815]         else {
[18:02:07.815]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:07.815]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:07.815]         }
[18:02:07.815]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:07.815]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:07.815]             base::sink(type = "output", split = FALSE)
[18:02:07.815]             base::close(...future.stdout)
[18:02:07.815]         }, add = TRUE)
[18:02:07.815]     }
[18:02:07.815]     ...future.frame <- base::sys.nframe()
[18:02:07.815]     ...future.conditions <- base::list()
[18:02:07.815]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:07.815]     if (FALSE) {
[18:02:07.815]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:07.815]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:07.815]     }
[18:02:07.815]     ...future.result <- base::tryCatch({
[18:02:07.815]         base::withCallingHandlers({
[18:02:07.815]             ...future.value <- base::withVisible(base::local({
[18:02:07.815]                 ...future.makeSendCondition <- base::local({
[18:02:07.815]                   sendCondition <- NULL
[18:02:07.815]                   function(frame = 1L) {
[18:02:07.815]                     if (is.function(sendCondition)) 
[18:02:07.815]                       return(sendCondition)
[18:02:07.815]                     ns <- getNamespace("parallel")
[18:02:07.815]                     if (exists("sendData", mode = "function", 
[18:02:07.815]                       envir = ns)) {
[18:02:07.815]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:07.815]                         envir = ns)
[18:02:07.815]                       envir <- sys.frame(frame)
[18:02:07.815]                       master <- NULL
[18:02:07.815]                       while (!identical(envir, .GlobalEnv) && 
[18:02:07.815]                         !identical(envir, emptyenv())) {
[18:02:07.815]                         if (exists("master", mode = "list", envir = envir, 
[18:02:07.815]                           inherits = FALSE)) {
[18:02:07.815]                           master <- get("master", mode = "list", 
[18:02:07.815]                             envir = envir, inherits = FALSE)
[18:02:07.815]                           if (inherits(master, c("SOCKnode", 
[18:02:07.815]                             "SOCK0node"))) {
[18:02:07.815]                             sendCondition <<- function(cond) {
[18:02:07.815]                               data <- list(type = "VALUE", value = cond, 
[18:02:07.815]                                 success = TRUE)
[18:02:07.815]                               parallel_sendData(master, data)
[18:02:07.815]                             }
[18:02:07.815]                             return(sendCondition)
[18:02:07.815]                           }
[18:02:07.815]                         }
[18:02:07.815]                         frame <- frame + 1L
[18:02:07.815]                         envir <- sys.frame(frame)
[18:02:07.815]                       }
[18:02:07.815]                     }
[18:02:07.815]                     sendCondition <<- function(cond) NULL
[18:02:07.815]                   }
[18:02:07.815]                 })
[18:02:07.815]                 withCallingHandlers({
[18:02:07.815]                   {
[18:02:07.815]                     do.call(function(...) {
[18:02:07.815]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:07.815]                       if (!identical(...future.globals.maxSize.org, 
[18:02:07.815]                         ...future.globals.maxSize)) {
[18:02:07.815]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:07.815]                         on.exit(options(oopts), add = TRUE)
[18:02:07.815]                       }
[18:02:07.815]                       {
[18:02:07.815]                         lapply(seq_along(...future.elements_ii), 
[18:02:07.815]                           FUN = function(jj) {
[18:02:07.815]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:07.815]                             ...future.FUN(...future.X_jj, ...)
[18:02:07.815]                           })
[18:02:07.815]                       }
[18:02:07.815]                     }, args = future.call.arguments)
[18:02:07.815]                   }
[18:02:07.815]                 }, immediateCondition = function(cond) {
[18:02:07.815]                   sendCondition <- ...future.makeSendCondition()
[18:02:07.815]                   sendCondition(cond)
[18:02:07.815]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:07.815]                   {
[18:02:07.815]                     inherits <- base::inherits
[18:02:07.815]                     invokeRestart <- base::invokeRestart
[18:02:07.815]                     is.null <- base::is.null
[18:02:07.815]                     muffled <- FALSE
[18:02:07.815]                     if (inherits(cond, "message")) {
[18:02:07.815]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:07.815]                       if (muffled) 
[18:02:07.815]                         invokeRestart("muffleMessage")
[18:02:07.815]                     }
[18:02:07.815]                     else if (inherits(cond, "warning")) {
[18:02:07.815]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:07.815]                       if (muffled) 
[18:02:07.815]                         invokeRestart("muffleWarning")
[18:02:07.815]                     }
[18:02:07.815]                     else if (inherits(cond, "condition")) {
[18:02:07.815]                       if (!is.null(pattern)) {
[18:02:07.815]                         computeRestarts <- base::computeRestarts
[18:02:07.815]                         grepl <- base::grepl
[18:02:07.815]                         restarts <- computeRestarts(cond)
[18:02:07.815]                         for (restart in restarts) {
[18:02:07.815]                           name <- restart$name
[18:02:07.815]                           if (is.null(name)) 
[18:02:07.815]                             next
[18:02:07.815]                           if (!grepl(pattern, name)) 
[18:02:07.815]                             next
[18:02:07.815]                           invokeRestart(restart)
[18:02:07.815]                           muffled <- TRUE
[18:02:07.815]                           break
[18:02:07.815]                         }
[18:02:07.815]                       }
[18:02:07.815]                     }
[18:02:07.815]                     invisible(muffled)
[18:02:07.815]                   }
[18:02:07.815]                   muffleCondition(cond)
[18:02:07.815]                 })
[18:02:07.815]             }))
[18:02:07.815]             future::FutureResult(value = ...future.value$value, 
[18:02:07.815]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:07.815]                   ...future.rng), globalenv = if (FALSE) 
[18:02:07.815]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:07.815]                     ...future.globalenv.names))
[18:02:07.815]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:07.815]         }, condition = base::local({
[18:02:07.815]             c <- base::c
[18:02:07.815]             inherits <- base::inherits
[18:02:07.815]             invokeRestart <- base::invokeRestart
[18:02:07.815]             length <- base::length
[18:02:07.815]             list <- base::list
[18:02:07.815]             seq.int <- base::seq.int
[18:02:07.815]             signalCondition <- base::signalCondition
[18:02:07.815]             sys.calls <- base::sys.calls
[18:02:07.815]             `[[` <- base::`[[`
[18:02:07.815]             `+` <- base::`+`
[18:02:07.815]             `<<-` <- base::`<<-`
[18:02:07.815]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:07.815]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:07.815]                   3L)]
[18:02:07.815]             }
[18:02:07.815]             function(cond) {
[18:02:07.815]                 is_error <- inherits(cond, "error")
[18:02:07.815]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:07.815]                   NULL)
[18:02:07.815]                 if (is_error) {
[18:02:07.815]                   sessionInformation <- function() {
[18:02:07.815]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:07.815]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:07.815]                       search = base::search(), system = base::Sys.info())
[18:02:07.815]                   }
[18:02:07.815]                   ...future.conditions[[length(...future.conditions) + 
[18:02:07.815]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:07.815]                     cond$call), session = sessionInformation(), 
[18:02:07.815]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:07.815]                   signalCondition(cond)
[18:02:07.815]                 }
[18:02:07.815]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:07.815]                 "immediateCondition"))) {
[18:02:07.815]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:07.815]                   ...future.conditions[[length(...future.conditions) + 
[18:02:07.815]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:07.815]                   if (TRUE && !signal) {
[18:02:07.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:07.815]                     {
[18:02:07.815]                       inherits <- base::inherits
[18:02:07.815]                       invokeRestart <- base::invokeRestart
[18:02:07.815]                       is.null <- base::is.null
[18:02:07.815]                       muffled <- FALSE
[18:02:07.815]                       if (inherits(cond, "message")) {
[18:02:07.815]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:07.815]                         if (muffled) 
[18:02:07.815]                           invokeRestart("muffleMessage")
[18:02:07.815]                       }
[18:02:07.815]                       else if (inherits(cond, "warning")) {
[18:02:07.815]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:07.815]                         if (muffled) 
[18:02:07.815]                           invokeRestart("muffleWarning")
[18:02:07.815]                       }
[18:02:07.815]                       else if (inherits(cond, "condition")) {
[18:02:07.815]                         if (!is.null(pattern)) {
[18:02:07.815]                           computeRestarts <- base::computeRestarts
[18:02:07.815]                           grepl <- base::grepl
[18:02:07.815]                           restarts <- computeRestarts(cond)
[18:02:07.815]                           for (restart in restarts) {
[18:02:07.815]                             name <- restart$name
[18:02:07.815]                             if (is.null(name)) 
[18:02:07.815]                               next
[18:02:07.815]                             if (!grepl(pattern, name)) 
[18:02:07.815]                               next
[18:02:07.815]                             invokeRestart(restart)
[18:02:07.815]                             muffled <- TRUE
[18:02:07.815]                             break
[18:02:07.815]                           }
[18:02:07.815]                         }
[18:02:07.815]                       }
[18:02:07.815]                       invisible(muffled)
[18:02:07.815]                     }
[18:02:07.815]                     muffleCondition(cond, pattern = "^muffle")
[18:02:07.815]                   }
[18:02:07.815]                 }
[18:02:07.815]                 else {
[18:02:07.815]                   if (TRUE) {
[18:02:07.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:07.815]                     {
[18:02:07.815]                       inherits <- base::inherits
[18:02:07.815]                       invokeRestart <- base::invokeRestart
[18:02:07.815]                       is.null <- base::is.null
[18:02:07.815]                       muffled <- FALSE
[18:02:07.815]                       if (inherits(cond, "message")) {
[18:02:07.815]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:07.815]                         if (muffled) 
[18:02:07.815]                           invokeRestart("muffleMessage")
[18:02:07.815]                       }
[18:02:07.815]                       else if (inherits(cond, "warning")) {
[18:02:07.815]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:07.815]                         if (muffled) 
[18:02:07.815]                           invokeRestart("muffleWarning")
[18:02:07.815]                       }
[18:02:07.815]                       else if (inherits(cond, "condition")) {
[18:02:07.815]                         if (!is.null(pattern)) {
[18:02:07.815]                           computeRestarts <- base::computeRestarts
[18:02:07.815]                           grepl <- base::grepl
[18:02:07.815]                           restarts <- computeRestarts(cond)
[18:02:07.815]                           for (restart in restarts) {
[18:02:07.815]                             name <- restart$name
[18:02:07.815]                             if (is.null(name)) 
[18:02:07.815]                               next
[18:02:07.815]                             if (!grepl(pattern, name)) 
[18:02:07.815]                               next
[18:02:07.815]                             invokeRestart(restart)
[18:02:07.815]                             muffled <- TRUE
[18:02:07.815]                             break
[18:02:07.815]                           }
[18:02:07.815]                         }
[18:02:07.815]                       }
[18:02:07.815]                       invisible(muffled)
[18:02:07.815]                     }
[18:02:07.815]                     muffleCondition(cond, pattern = "^muffle")
[18:02:07.815]                   }
[18:02:07.815]                 }
[18:02:07.815]             }
[18:02:07.815]         }))
[18:02:07.815]     }, error = function(ex) {
[18:02:07.815]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:07.815]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:07.815]                 ...future.rng), started = ...future.startTime, 
[18:02:07.815]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:07.815]             version = "1.8"), class = "FutureResult")
[18:02:07.815]     }, finally = {
[18:02:07.815]         if (!identical(...future.workdir, getwd())) 
[18:02:07.815]             setwd(...future.workdir)
[18:02:07.815]         {
[18:02:07.815]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:07.815]                 ...future.oldOptions$nwarnings <- NULL
[18:02:07.815]             }
[18:02:07.815]             base::options(...future.oldOptions)
[18:02:07.815]             if (.Platform$OS.type == "windows") {
[18:02:07.815]                 old_names <- names(...future.oldEnvVars)
[18:02:07.815]                 envs <- base::Sys.getenv()
[18:02:07.815]                 names <- names(envs)
[18:02:07.815]                 common <- intersect(names, old_names)
[18:02:07.815]                 added <- setdiff(names, old_names)
[18:02:07.815]                 removed <- setdiff(old_names, names)
[18:02:07.815]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:07.815]                   envs[common]]
[18:02:07.815]                 NAMES <- toupper(changed)
[18:02:07.815]                 args <- list()
[18:02:07.815]                 for (kk in seq_along(NAMES)) {
[18:02:07.815]                   name <- changed[[kk]]
[18:02:07.815]                   NAME <- NAMES[[kk]]
[18:02:07.815]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:07.815]                     next
[18:02:07.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:07.815]                 }
[18:02:07.815]                 NAMES <- toupper(added)
[18:02:07.815]                 for (kk in seq_along(NAMES)) {
[18:02:07.815]                   name <- added[[kk]]
[18:02:07.815]                   NAME <- NAMES[[kk]]
[18:02:07.815]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:07.815]                     next
[18:02:07.815]                   args[[name]] <- ""
[18:02:07.815]                 }
[18:02:07.815]                 NAMES <- toupper(removed)
[18:02:07.815]                 for (kk in seq_along(NAMES)) {
[18:02:07.815]                   name <- removed[[kk]]
[18:02:07.815]                   NAME <- NAMES[[kk]]
[18:02:07.815]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:07.815]                     next
[18:02:07.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:07.815]                 }
[18:02:07.815]                 if (length(args) > 0) 
[18:02:07.815]                   base::do.call(base::Sys.setenv, args = args)
[18:02:07.815]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:07.815]             }
[18:02:07.815]             else {
[18:02:07.815]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:07.815]             }
[18:02:07.815]             {
[18:02:07.815]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:07.815]                   0L) {
[18:02:07.815]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:07.815]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:07.815]                   base::options(opts)
[18:02:07.815]                 }
[18:02:07.815]                 {
[18:02:07.815]                   {
[18:02:07.815]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:07.815]                     NULL
[18:02:07.815]                   }
[18:02:07.815]                   options(future.plan = NULL)
[18:02:07.815]                   if (is.na(NA_character_)) 
[18:02:07.815]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:07.815]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:07.815]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:07.815]                     .init = FALSE)
[18:02:07.815]                 }
[18:02:07.815]             }
[18:02:07.815]         }
[18:02:07.815]     })
[18:02:07.815]     if (TRUE) {
[18:02:07.815]         base::sink(type = "output", split = FALSE)
[18:02:07.815]         if (TRUE) {
[18:02:07.815]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:07.815]         }
[18:02:07.815]         else {
[18:02:07.815]             ...future.result["stdout"] <- base::list(NULL)
[18:02:07.815]         }
[18:02:07.815]         base::close(...future.stdout)
[18:02:07.815]         ...future.stdout <- NULL
[18:02:07.815]     }
[18:02:07.815]     ...future.result$conditions <- ...future.conditions
[18:02:07.815]     ...future.result$finished <- base::Sys.time()
[18:02:07.815]     ...future.result
[18:02:07.815] }
[18:02:07.820] Exporting 11 global objects (137.93 KiB) to cluster node #2 ...
[18:02:07.820] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[18:02:07.863] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[18:02:07.863] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ...
[18:02:07.904] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ... DONE
[18:02:07.905] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[18:02:07.906] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[18:02:07.906] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[18:02:07.947] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[18:02:07.948] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[18:02:07.989] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[18:02:07.990] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[18:02:07.991] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[18:02:07.991] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[18:02:07.993] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[18:02:07.993] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:07.994] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:07.995] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[18:02:07.996] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[18:02:07.997] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:07.998] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:07.998] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:07.999] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:08.000] Exporting 11 global objects (137.93 KiB) to cluster node #2 ... DONE
[18:02:08.001] MultisessionFuture started
[18:02:08.002] - Launch lazy future ... done
[18:02:08.002] run() for ‘MultisessionFuture’ ... done
[18:02:08.002] Created future:
[18:02:08.003] MultisessionFuture:
[18:02:08.003] Label: ‘future_vapply-2’
[18:02:08.003] Expression:
[18:02:08.003] {
[18:02:08.003]     do.call(function(...) {
[18:02:08.003]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.003]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:08.003]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.003]             on.exit(options(oopts), add = TRUE)
[18:02:08.003]         }
[18:02:08.003]         {
[18:02:08.003]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:08.003]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.003]                 ...future.FUN(...future.X_jj, ...)
[18:02:08.003]             })
[18:02:08.003]         }
[18:02:08.003]     }, args = future.call.arguments)
[18:02:08.003] }
[18:02:08.003] Lazy evaluation: FALSE
[18:02:08.003] Asynchronous evaluation: TRUE
[18:02:08.003] Local evaluation: TRUE
[18:02:08.003] Environment: R_GlobalEnv
[18:02:08.003] Capture standard output: TRUE
[18:02:08.003] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:08.003] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:08.003] Packages: 2 packages (‘stats’, ‘future.apply’)
[18:02:08.003] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:08.003] Resolved: FALSE
[18:02:08.003] Value: <not collected>
[18:02:08.003] Conditions captured: <none>
[18:02:08.003] Early signaling: FALSE
[18:02:08.003] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:08.003] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:08.018] Chunk #2 of 2 ... DONE
[18:02:08.018] Launching 2 futures (chunks) ... DONE
[18:02:08.018] Resolving 2 futures (chunks) ...
[18:02:08.019] resolve() on list ...
[18:02:08.019]  recursive: 0
[18:02:08.019]  length: 2
[18:02:08.020] 
[18:02:08.037] receiveMessageFromWorker() for ClusterFuture ...
[18:02:08.038] - Validating connection of MultisessionFuture
[18:02:08.038] - received message: FutureResult
[18:02:08.039] - Received FutureResult
[18:02:08.039] - Erased future from FutureRegistry
[18:02:08.039] result() for ClusterFuture ...
[18:02:08.040] - result already collected: FutureResult
[18:02:08.040] result() for ClusterFuture ... done
[18:02:08.040] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:08.041] Future #1
[18:02:08.041] result() for ClusterFuture ...
[18:02:08.041] - result already collected: FutureResult
[18:02:08.042] result() for ClusterFuture ... done
[18:02:08.042] result() for ClusterFuture ...
[18:02:08.042] - result already collected: FutureResult
[18:02:08.043] result() for ClusterFuture ... done
[18:02:08.043] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:08.043] - nx: 2
[18:02:08.044] - relay: TRUE
[18:02:08.044] - stdout: TRUE
[18:02:08.044] - signal: TRUE
[18:02:08.044] - resignal: FALSE
[18:02:08.045] - force: TRUE
[18:02:08.045] - relayed: [n=2] FALSE, FALSE
[18:02:08.045] - queued futures: [n=2] FALSE, FALSE
[18:02:08.046]  - until=1
[18:02:08.046]  - relaying element #1
[18:02:08.046] result() for ClusterFuture ...
[18:02:08.047] - result already collected: FutureResult
[18:02:08.047] result() for ClusterFuture ... done
[18:02:08.047] result() for ClusterFuture ...
[18:02:08.048] - result already collected: FutureResult
[18:02:08.048] result() for ClusterFuture ... done
[18:02:08.048] result() for ClusterFuture ...
[18:02:08.049] - result already collected: FutureResult
[18:02:08.049] result() for ClusterFuture ... done
[18:02:08.049] result() for ClusterFuture ...
[18:02:08.049] - result already collected: FutureResult
[18:02:08.050] result() for ClusterFuture ... done
[18:02:08.050] - relayed: [n=2] TRUE, FALSE
[18:02:08.050] - queued futures: [n=2] TRUE, FALSE
[18:02:08.051] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:08.051]  length: 1 (resolved future 1)
[18:02:08.052] receiveMessageFromWorker() for ClusterFuture ...
[18:02:08.053] - Validating connection of MultisessionFuture
[18:02:08.053] - received message: FutureResult
[18:02:08.054] - Received FutureResult
[18:02:08.054] - Erased future from FutureRegistry
[18:02:08.054] result() for ClusterFuture ...
[18:02:08.055] - result already collected: FutureResult
[18:02:08.055] result() for ClusterFuture ... done
[18:02:08.055] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:08.056] Future #2
[18:02:08.056] result() for ClusterFuture ...
[18:02:08.056] - result already collected: FutureResult
[18:02:08.056] result() for ClusterFuture ... done
[18:02:08.057] result() for ClusterFuture ...
[18:02:08.057] - result already collected: FutureResult
[18:02:08.057] result() for ClusterFuture ... done
[18:02:08.058] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:08.058] - nx: 2
[18:02:08.058] - relay: TRUE
[18:02:08.058] - stdout: TRUE
[18:02:08.059] - signal: TRUE
[18:02:08.059] - resignal: FALSE
[18:02:08.059] - force: TRUE
[18:02:08.059] - relayed: [n=2] TRUE, FALSE
[18:02:08.060] - queued futures: [n=2] TRUE, FALSE
[18:02:08.060]  - until=2
[18:02:08.060]  - relaying element #2
[18:02:08.061] result() for ClusterFuture ...
[18:02:08.061] - result already collected: FutureResult
[18:02:08.061] result() for ClusterFuture ... done
[18:02:08.061] result() for ClusterFuture ...
[18:02:08.062] - result already collected: FutureResult
[18:02:08.062] result() for ClusterFuture ... done
[18:02:08.062] result() for ClusterFuture ...
[18:02:08.063] - result already collected: FutureResult
[18:02:08.063] result() for ClusterFuture ... done
[18:02:08.063] result() for ClusterFuture ...
[18:02:08.063] - result already collected: FutureResult
[18:02:08.064] result() for ClusterFuture ... done
[18:02:08.064] - relayed: [n=2] TRUE, TRUE
[18:02:08.064] - queued futures: [n=2] TRUE, TRUE
[18:02:08.064] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:08.065]  length: 0 (resolved future 2)
[18:02:08.065] Relaying remaining futures
[18:02:08.065] signalConditionsASAP(NULL, pos=0) ...
[18:02:08.065] - nx: 2
[18:02:08.066] - relay: TRUE
[18:02:08.066] - stdout: TRUE
[18:02:08.066] - signal: TRUE
[18:02:08.066] - resignal: FALSE
[18:02:08.066] - force: TRUE
[18:02:08.067] - relayed: [n=2] TRUE, TRUE
[18:02:08.067] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:08.067] - relayed: [n=2] TRUE, TRUE
[18:02:08.068] - queued futures: [n=2] TRUE, TRUE
[18:02:08.068] signalConditionsASAP(NULL, pos=0) ... done
[18:02:08.068] resolve() on list ... DONE
[18:02:08.069] result() for ClusterFuture ...
[18:02:08.069] - result already collected: FutureResult
[18:02:08.069] result() for ClusterFuture ... done
[18:02:08.069] result() for ClusterFuture ...
[18:02:08.070] - result already collected: FutureResult
[18:02:08.070] result() for ClusterFuture ... done
[18:02:08.070] result() for ClusterFuture ...
[18:02:08.070] - result already collected: FutureResult
[18:02:08.071] result() for ClusterFuture ... done
[18:02:08.071] result() for ClusterFuture ...
[18:02:08.071] - result already collected: FutureResult
[18:02:08.071] result() for ClusterFuture ... done
[18:02:08.072]  - Number of value chunks collected: 2
[18:02:08.072] Resolving 2 futures (chunks) ... DONE
[18:02:08.072] Reducing values from 2 chunks ...
[18:02:08.072]  - Number of values collected after concatenation: 7
[18:02:08.072]  - Number of values expected: 7
[18:02:08.073] Reducing values from 2 chunks ... DONE
[18:02:08.073] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[18:02:08.077] future_lapply() ...
[18:02:08.084] Number of chunks: 2
[18:02:08.084] getGlobalsAndPackagesXApply() ...
[18:02:08.085]  - future.globals: TRUE
[18:02:08.085] getGlobalsAndPackages() ...
[18:02:08.085] Searching for globals...
[18:02:08.088] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[18:02:08.088] Searching for globals ... DONE
[18:02:08.088] Resolving globals: FALSE
[18:02:08.089] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[18:02:08.090] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[18:02:08.090] - globals: [1] ‘FUN’
[18:02:08.091] 
[18:02:08.091] getGlobalsAndPackages() ... DONE
[18:02:08.091]  - globals found/used: [n=1] ‘FUN’
[18:02:08.091]  - needed namespaces: [n=0] 
[18:02:08.091] Finding globals ... DONE
[18:02:08.092]  - use_args: TRUE
[18:02:08.092]  - Getting '...' globals ...
[18:02:08.092] resolve() on list ...
[18:02:08.093]  recursive: 0
[18:02:08.093]  length: 1
[18:02:08.093]  elements: ‘...’
[18:02:08.093]  length: 0 (resolved future 1)
[18:02:08.094] resolve() on list ... DONE
[18:02:08.094]    - '...' content: [n=1] ‘y’
[18:02:08.094] List of 1
[18:02:08.094]  $ ...:List of 1
[18:02:08.094]   ..$ y: num [1:5] 2 4 6 8 10
[18:02:08.094]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:08.094]  - attr(*, "where")=List of 1
[18:02:08.094]   ..$ ...:<environment: 0x6183c091f120> 
[18:02:08.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:08.094]  - attr(*, "resolved")= logi TRUE
[18:02:08.094]  - attr(*, "total_size")= num NA
[18:02:08.100]  - Getting '...' globals ... DONE
[18:02:08.101] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:08.101] List of 2
[18:02:08.101]  $ ...future.FUN:function (x, y)  
[18:02:08.101]  $ ...          :List of 1
[18:02:08.101]   ..$ y: num [1:5] 2 4 6 8 10
[18:02:08.101]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:08.101]  - attr(*, "where")=List of 2
[18:02:08.101]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:08.101]   ..$ ...          :<environment: 0x6183c091f120> 
[18:02:08.101]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:08.101]  - attr(*, "resolved")= logi FALSE
[18:02:08.101]  - attr(*, "total_size")= num 4264
[18:02:08.107] Packages to be attached in all futures: [n=0] 
[18:02:08.107] getGlobalsAndPackagesXApply() ... DONE
[18:02:08.108] Number of futures (= number of chunks): 2
[18:02:08.108] Launching 2 futures (chunks) ...
[18:02:08.108] Chunk #1 of 2 ...
[18:02:08.108]  - Finding globals in 'X' for chunk #1 ...
[18:02:08.108] getGlobalsAndPackages() ...
[18:02:08.109] Searching for globals...
[18:02:08.109] 
[18:02:08.109] Searching for globals ... DONE
[18:02:08.110] - globals: [0] <none>
[18:02:08.110] getGlobalsAndPackages() ... DONE
[18:02:08.110]    + additional globals found: [n=0] 
[18:02:08.110]    + additional namespaces needed: [n=0] 
[18:02:08.110]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:08.110]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:08.111]  - seeds: <none>
[18:02:08.111]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.111] getGlobalsAndPackages() ...
[18:02:08.111] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.112] Resolving globals: FALSE
[18:02:08.112] Tweak future expression to call with '...' arguments ...
[18:02:08.112] {
[18:02:08.112]     do.call(function(...) {
[18:02:08.112]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.112]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:08.112]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.112]             on.exit(options(oopts), add = TRUE)
[18:02:08.112]         }
[18:02:08.112]         {
[18:02:08.112]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:08.112]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.112]                 ...future.FUN(...future.X_jj, ...)
[18:02:08.112]             })
[18:02:08.112]         }
[18:02:08.112]     }, args = future.call.arguments)
[18:02:08.112] }
[18:02:08.112] Tweak future expression to call with '...' arguments ... DONE
[18:02:08.113] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.114] 
[18:02:08.114] getGlobalsAndPackages() ... DONE
[18:02:08.114] run() for ‘Future’ ...
[18:02:08.114] - state: ‘created’
[18:02:08.115] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:08.139] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:08.139] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:08.139]   - Field: ‘node’
[18:02:08.140]   - Field: ‘label’
[18:02:08.140]   - Field: ‘local’
[18:02:08.140]   - Field: ‘owner’
[18:02:08.140]   - Field: ‘envir’
[18:02:08.141]   - Field: ‘workers’
[18:02:08.141]   - Field: ‘packages’
[18:02:08.141]   - Field: ‘gc’
[18:02:08.141]   - Field: ‘conditions’
[18:02:08.141]   - Field: ‘persistent’
[18:02:08.142]   - Field: ‘expr’
[18:02:08.142]   - Field: ‘uuid’
[18:02:08.142]   - Field: ‘seed’
[18:02:08.142]   - Field: ‘version’
[18:02:08.142]   - Field: ‘result’
[18:02:08.143]   - Field: ‘asynchronous’
[18:02:08.143]   - Field: ‘calls’
[18:02:08.143]   - Field: ‘globals’
[18:02:08.143]   - Field: ‘stdout’
[18:02:08.143]   - Field: ‘earlySignal’
[18:02:08.144]   - Field: ‘lazy’
[18:02:08.144]   - Field: ‘state’
[18:02:08.144] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:08.144] - Launch lazy future ...
[18:02:08.145] Packages needed by the future expression (n = 0): <none>
[18:02:08.145] Packages needed by future strategies (n = 0): <none>
[18:02:08.146] {
[18:02:08.146]     {
[18:02:08.146]         {
[18:02:08.146]             ...future.startTime <- base::Sys.time()
[18:02:08.146]             {
[18:02:08.146]                 {
[18:02:08.146]                   {
[18:02:08.146]                     {
[18:02:08.146]                       base::local({
[18:02:08.146]                         has_future <- base::requireNamespace("future", 
[18:02:08.146]                           quietly = TRUE)
[18:02:08.146]                         if (has_future) {
[18:02:08.146]                           ns <- base::getNamespace("future")
[18:02:08.146]                           version <- ns[[".package"]][["version"]]
[18:02:08.146]                           if (is.null(version)) 
[18:02:08.146]                             version <- utils::packageVersion("future")
[18:02:08.146]                         }
[18:02:08.146]                         else {
[18:02:08.146]                           version <- NULL
[18:02:08.146]                         }
[18:02:08.146]                         if (!has_future || version < "1.8.0") {
[18:02:08.146]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:08.146]                             "", base::R.version$version.string), 
[18:02:08.146]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:08.146]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:08.146]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:08.146]                               "release", "version")], collapse = " "), 
[18:02:08.146]                             hostname = base::Sys.info()[["nodename"]])
[18:02:08.146]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:08.146]                             info)
[18:02:08.146]                           info <- base::paste(info, collapse = "; ")
[18:02:08.146]                           if (!has_future) {
[18:02:08.146]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:08.146]                               info)
[18:02:08.146]                           }
[18:02:08.146]                           else {
[18:02:08.146]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:08.146]                               info, version)
[18:02:08.146]                           }
[18:02:08.146]                           base::stop(msg)
[18:02:08.146]                         }
[18:02:08.146]                       })
[18:02:08.146]                     }
[18:02:08.146]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:08.146]                     base::options(mc.cores = 1L)
[18:02:08.146]                   }
[18:02:08.146]                   ...future.strategy.old <- future::plan("list")
[18:02:08.146]                   options(future.plan = NULL)
[18:02:08.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:08.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:08.146]                 }
[18:02:08.146]                 ...future.workdir <- getwd()
[18:02:08.146]             }
[18:02:08.146]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:08.146]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:08.146]         }
[18:02:08.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:08.146]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:08.146]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:08.146]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:08.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:08.146]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:08.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:08.146]             base::names(...future.oldOptions))
[18:02:08.146]     }
[18:02:08.146]     if (FALSE) {
[18:02:08.146]     }
[18:02:08.146]     else {
[18:02:08.146]         if (TRUE) {
[18:02:08.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:08.146]                 open = "w")
[18:02:08.146]         }
[18:02:08.146]         else {
[18:02:08.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:08.146]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:08.146]         }
[18:02:08.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:08.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:08.146]             base::sink(type = "output", split = FALSE)
[18:02:08.146]             base::close(...future.stdout)
[18:02:08.146]         }, add = TRUE)
[18:02:08.146]     }
[18:02:08.146]     ...future.frame <- base::sys.nframe()
[18:02:08.146]     ...future.conditions <- base::list()
[18:02:08.146]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:08.146]     if (FALSE) {
[18:02:08.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:08.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:08.146]     }
[18:02:08.146]     ...future.result <- base::tryCatch({
[18:02:08.146]         base::withCallingHandlers({
[18:02:08.146]             ...future.value <- base::withVisible(base::local({
[18:02:08.146]                 ...future.makeSendCondition <- base::local({
[18:02:08.146]                   sendCondition <- NULL
[18:02:08.146]                   function(frame = 1L) {
[18:02:08.146]                     if (is.function(sendCondition)) 
[18:02:08.146]                       return(sendCondition)
[18:02:08.146]                     ns <- getNamespace("parallel")
[18:02:08.146]                     if (exists("sendData", mode = "function", 
[18:02:08.146]                       envir = ns)) {
[18:02:08.146]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:08.146]                         envir = ns)
[18:02:08.146]                       envir <- sys.frame(frame)
[18:02:08.146]                       master <- NULL
[18:02:08.146]                       while (!identical(envir, .GlobalEnv) && 
[18:02:08.146]                         !identical(envir, emptyenv())) {
[18:02:08.146]                         if (exists("master", mode = "list", envir = envir, 
[18:02:08.146]                           inherits = FALSE)) {
[18:02:08.146]                           master <- get("master", mode = "list", 
[18:02:08.146]                             envir = envir, inherits = FALSE)
[18:02:08.146]                           if (inherits(master, c("SOCKnode", 
[18:02:08.146]                             "SOCK0node"))) {
[18:02:08.146]                             sendCondition <<- function(cond) {
[18:02:08.146]                               data <- list(type = "VALUE", value = cond, 
[18:02:08.146]                                 success = TRUE)
[18:02:08.146]                               parallel_sendData(master, data)
[18:02:08.146]                             }
[18:02:08.146]                             return(sendCondition)
[18:02:08.146]                           }
[18:02:08.146]                         }
[18:02:08.146]                         frame <- frame + 1L
[18:02:08.146]                         envir <- sys.frame(frame)
[18:02:08.146]                       }
[18:02:08.146]                     }
[18:02:08.146]                     sendCondition <<- function(cond) NULL
[18:02:08.146]                   }
[18:02:08.146]                 })
[18:02:08.146]                 withCallingHandlers({
[18:02:08.146]                   {
[18:02:08.146]                     do.call(function(...) {
[18:02:08.146]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.146]                       if (!identical(...future.globals.maxSize.org, 
[18:02:08.146]                         ...future.globals.maxSize)) {
[18:02:08.146]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.146]                         on.exit(options(oopts), add = TRUE)
[18:02:08.146]                       }
[18:02:08.146]                       {
[18:02:08.146]                         lapply(seq_along(...future.elements_ii), 
[18:02:08.146]                           FUN = function(jj) {
[18:02:08.146]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.146]                             ...future.FUN(...future.X_jj, ...)
[18:02:08.146]                           })
[18:02:08.146]                       }
[18:02:08.146]                     }, args = future.call.arguments)
[18:02:08.146]                   }
[18:02:08.146]                 }, immediateCondition = function(cond) {
[18:02:08.146]                   sendCondition <- ...future.makeSendCondition()
[18:02:08.146]                   sendCondition(cond)
[18:02:08.146]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.146]                   {
[18:02:08.146]                     inherits <- base::inherits
[18:02:08.146]                     invokeRestart <- base::invokeRestart
[18:02:08.146]                     is.null <- base::is.null
[18:02:08.146]                     muffled <- FALSE
[18:02:08.146]                     if (inherits(cond, "message")) {
[18:02:08.146]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:08.146]                       if (muffled) 
[18:02:08.146]                         invokeRestart("muffleMessage")
[18:02:08.146]                     }
[18:02:08.146]                     else if (inherits(cond, "warning")) {
[18:02:08.146]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:08.146]                       if (muffled) 
[18:02:08.146]                         invokeRestart("muffleWarning")
[18:02:08.146]                     }
[18:02:08.146]                     else if (inherits(cond, "condition")) {
[18:02:08.146]                       if (!is.null(pattern)) {
[18:02:08.146]                         computeRestarts <- base::computeRestarts
[18:02:08.146]                         grepl <- base::grepl
[18:02:08.146]                         restarts <- computeRestarts(cond)
[18:02:08.146]                         for (restart in restarts) {
[18:02:08.146]                           name <- restart$name
[18:02:08.146]                           if (is.null(name)) 
[18:02:08.146]                             next
[18:02:08.146]                           if (!grepl(pattern, name)) 
[18:02:08.146]                             next
[18:02:08.146]                           invokeRestart(restart)
[18:02:08.146]                           muffled <- TRUE
[18:02:08.146]                           break
[18:02:08.146]                         }
[18:02:08.146]                       }
[18:02:08.146]                     }
[18:02:08.146]                     invisible(muffled)
[18:02:08.146]                   }
[18:02:08.146]                   muffleCondition(cond)
[18:02:08.146]                 })
[18:02:08.146]             }))
[18:02:08.146]             future::FutureResult(value = ...future.value$value, 
[18:02:08.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:08.146]                   ...future.rng), globalenv = if (FALSE) 
[18:02:08.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:08.146]                     ...future.globalenv.names))
[18:02:08.146]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:08.146]         }, condition = base::local({
[18:02:08.146]             c <- base::c
[18:02:08.146]             inherits <- base::inherits
[18:02:08.146]             invokeRestart <- base::invokeRestart
[18:02:08.146]             length <- base::length
[18:02:08.146]             list <- base::list
[18:02:08.146]             seq.int <- base::seq.int
[18:02:08.146]             signalCondition <- base::signalCondition
[18:02:08.146]             sys.calls <- base::sys.calls
[18:02:08.146]             `[[` <- base::`[[`
[18:02:08.146]             `+` <- base::`+`
[18:02:08.146]             `<<-` <- base::`<<-`
[18:02:08.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:08.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:08.146]                   3L)]
[18:02:08.146]             }
[18:02:08.146]             function(cond) {
[18:02:08.146]                 is_error <- inherits(cond, "error")
[18:02:08.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:08.146]                   NULL)
[18:02:08.146]                 if (is_error) {
[18:02:08.146]                   sessionInformation <- function() {
[18:02:08.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:08.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:08.146]                       search = base::search(), system = base::Sys.info())
[18:02:08.146]                   }
[18:02:08.146]                   ...future.conditions[[length(...future.conditions) + 
[18:02:08.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:08.146]                     cond$call), session = sessionInformation(), 
[18:02:08.146]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:08.146]                   signalCondition(cond)
[18:02:08.146]                 }
[18:02:08.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:08.146]                 "immediateCondition"))) {
[18:02:08.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:08.146]                   ...future.conditions[[length(...future.conditions) + 
[18:02:08.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:08.146]                   if (TRUE && !signal) {
[18:02:08.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.146]                     {
[18:02:08.146]                       inherits <- base::inherits
[18:02:08.146]                       invokeRestart <- base::invokeRestart
[18:02:08.146]                       is.null <- base::is.null
[18:02:08.146]                       muffled <- FALSE
[18:02:08.146]                       if (inherits(cond, "message")) {
[18:02:08.146]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:08.146]                         if (muffled) 
[18:02:08.146]                           invokeRestart("muffleMessage")
[18:02:08.146]                       }
[18:02:08.146]                       else if (inherits(cond, "warning")) {
[18:02:08.146]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:08.146]                         if (muffled) 
[18:02:08.146]                           invokeRestart("muffleWarning")
[18:02:08.146]                       }
[18:02:08.146]                       else if (inherits(cond, "condition")) {
[18:02:08.146]                         if (!is.null(pattern)) {
[18:02:08.146]                           computeRestarts <- base::computeRestarts
[18:02:08.146]                           grepl <- base::grepl
[18:02:08.146]                           restarts <- computeRestarts(cond)
[18:02:08.146]                           for (restart in restarts) {
[18:02:08.146]                             name <- restart$name
[18:02:08.146]                             if (is.null(name)) 
[18:02:08.146]                               next
[18:02:08.146]                             if (!grepl(pattern, name)) 
[18:02:08.146]                               next
[18:02:08.146]                             invokeRestart(restart)
[18:02:08.146]                             muffled <- TRUE
[18:02:08.146]                             break
[18:02:08.146]                           }
[18:02:08.146]                         }
[18:02:08.146]                       }
[18:02:08.146]                       invisible(muffled)
[18:02:08.146]                     }
[18:02:08.146]                     muffleCondition(cond, pattern = "^muffle")
[18:02:08.146]                   }
[18:02:08.146]                 }
[18:02:08.146]                 else {
[18:02:08.146]                   if (TRUE) {
[18:02:08.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.146]                     {
[18:02:08.146]                       inherits <- base::inherits
[18:02:08.146]                       invokeRestart <- base::invokeRestart
[18:02:08.146]                       is.null <- base::is.null
[18:02:08.146]                       muffled <- FALSE
[18:02:08.146]                       if (inherits(cond, "message")) {
[18:02:08.146]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:08.146]                         if (muffled) 
[18:02:08.146]                           invokeRestart("muffleMessage")
[18:02:08.146]                       }
[18:02:08.146]                       else if (inherits(cond, "warning")) {
[18:02:08.146]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:08.146]                         if (muffled) 
[18:02:08.146]                           invokeRestart("muffleWarning")
[18:02:08.146]                       }
[18:02:08.146]                       else if (inherits(cond, "condition")) {
[18:02:08.146]                         if (!is.null(pattern)) {
[18:02:08.146]                           computeRestarts <- base::computeRestarts
[18:02:08.146]                           grepl <- base::grepl
[18:02:08.146]                           restarts <- computeRestarts(cond)
[18:02:08.146]                           for (restart in restarts) {
[18:02:08.146]                             name <- restart$name
[18:02:08.146]                             if (is.null(name)) 
[18:02:08.146]                               next
[18:02:08.146]                             if (!grepl(pattern, name)) 
[18:02:08.146]                               next
[18:02:08.146]                             invokeRestart(restart)
[18:02:08.146]                             muffled <- TRUE
[18:02:08.146]                             break
[18:02:08.146]                           }
[18:02:08.146]                         }
[18:02:08.146]                       }
[18:02:08.146]                       invisible(muffled)
[18:02:08.146]                     }
[18:02:08.146]                     muffleCondition(cond, pattern = "^muffle")
[18:02:08.146]                   }
[18:02:08.146]                 }
[18:02:08.146]             }
[18:02:08.146]         }))
[18:02:08.146]     }, error = function(ex) {
[18:02:08.146]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:08.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:08.146]                 ...future.rng), started = ...future.startTime, 
[18:02:08.146]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:08.146]             version = "1.8"), class = "FutureResult")
[18:02:08.146]     }, finally = {
[18:02:08.146]         if (!identical(...future.workdir, getwd())) 
[18:02:08.146]             setwd(...future.workdir)
[18:02:08.146]         {
[18:02:08.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:08.146]                 ...future.oldOptions$nwarnings <- NULL
[18:02:08.146]             }
[18:02:08.146]             base::options(...future.oldOptions)
[18:02:08.146]             if (.Platform$OS.type == "windows") {
[18:02:08.146]                 old_names <- names(...future.oldEnvVars)
[18:02:08.146]                 envs <- base::Sys.getenv()
[18:02:08.146]                 names <- names(envs)
[18:02:08.146]                 common <- intersect(names, old_names)
[18:02:08.146]                 added <- setdiff(names, old_names)
[18:02:08.146]                 removed <- setdiff(old_names, names)
[18:02:08.146]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:08.146]                   envs[common]]
[18:02:08.146]                 NAMES <- toupper(changed)
[18:02:08.146]                 args <- list()
[18:02:08.146]                 for (kk in seq_along(NAMES)) {
[18:02:08.146]                   name <- changed[[kk]]
[18:02:08.146]                   NAME <- NAMES[[kk]]
[18:02:08.146]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.146]                     next
[18:02:08.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:08.146]                 }
[18:02:08.146]                 NAMES <- toupper(added)
[18:02:08.146]                 for (kk in seq_along(NAMES)) {
[18:02:08.146]                   name <- added[[kk]]
[18:02:08.146]                   NAME <- NAMES[[kk]]
[18:02:08.146]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.146]                     next
[18:02:08.146]                   args[[name]] <- ""
[18:02:08.146]                 }
[18:02:08.146]                 NAMES <- toupper(removed)
[18:02:08.146]                 for (kk in seq_along(NAMES)) {
[18:02:08.146]                   name <- removed[[kk]]
[18:02:08.146]                   NAME <- NAMES[[kk]]
[18:02:08.146]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.146]                     next
[18:02:08.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:08.146]                 }
[18:02:08.146]                 if (length(args) > 0) 
[18:02:08.146]                   base::do.call(base::Sys.setenv, args = args)
[18:02:08.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:08.146]             }
[18:02:08.146]             else {
[18:02:08.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:08.146]             }
[18:02:08.146]             {
[18:02:08.146]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:08.146]                   0L) {
[18:02:08.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:08.146]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:08.146]                   base::options(opts)
[18:02:08.146]                 }
[18:02:08.146]                 {
[18:02:08.146]                   {
[18:02:08.146]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:08.146]                     NULL
[18:02:08.146]                   }
[18:02:08.146]                   options(future.plan = NULL)
[18:02:08.146]                   if (is.na(NA_character_)) 
[18:02:08.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:08.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:08.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:08.146]                     .init = FALSE)
[18:02:08.146]                 }
[18:02:08.146]             }
[18:02:08.146]         }
[18:02:08.146]     })
[18:02:08.146]     if (TRUE) {
[18:02:08.146]         base::sink(type = "output", split = FALSE)
[18:02:08.146]         if (TRUE) {
[18:02:08.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:08.146]         }
[18:02:08.146]         else {
[18:02:08.146]             ...future.result["stdout"] <- base::list(NULL)
[18:02:08.146]         }
[18:02:08.146]         base::close(...future.stdout)
[18:02:08.146]         ...future.stdout <- NULL
[18:02:08.146]     }
[18:02:08.146]     ...future.result$conditions <- ...future.conditions
[18:02:08.146]     ...future.result$finished <- base::Sys.time()
[18:02:08.146]     ...future.result
[18:02:08.146] }
[18:02:08.151] Exporting 5 global objects (4.16 KiB) to cluster node #1 ...
[18:02:08.151] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ...
[18:02:08.152] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ... DONE
[18:02:08.153] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[18:02:08.154] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[18:02:08.154] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[18:02:08.155] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[18:02:08.155] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:08.156] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:08.156] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:08.157] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:08.157] Exporting 5 global objects (4.16 KiB) to cluster node #1 ... DONE
[18:02:08.158] MultisessionFuture started
[18:02:08.159] - Launch lazy future ... done
[18:02:08.159] run() for ‘MultisessionFuture’ ... done
[18:02:08.159] Created future:
[18:02:08.159] MultisessionFuture:
[18:02:08.159] Label: ‘future_sapply-1’
[18:02:08.159] Expression:
[18:02:08.159] {
[18:02:08.159]     do.call(function(...) {
[18:02:08.159]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.159]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:08.159]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.159]             on.exit(options(oopts), add = TRUE)
[18:02:08.159]         }
[18:02:08.159]         {
[18:02:08.159]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:08.159]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.159]                 ...future.FUN(...future.X_jj, ...)
[18:02:08.159]             })
[18:02:08.159]         }
[18:02:08.159]     }, args = future.call.arguments)
[18:02:08.159] }
[18:02:08.159] Lazy evaluation: FALSE
[18:02:08.159] Asynchronous evaluation: TRUE
[18:02:08.159] Local evaluation: TRUE
[18:02:08.159] Environment: R_GlobalEnv
[18:02:08.159] Capture standard output: TRUE
[18:02:08.159] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:08.159] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:08.159] Packages: <none>
[18:02:08.159] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:08.159] Resolved: FALSE
[18:02:08.159] Value: <not collected>
[18:02:08.159] Conditions captured: <none>
[18:02:08.159] Early signaling: FALSE
[18:02:08.159] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:08.159] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:08.173] Chunk #1 of 2 ... DONE
[18:02:08.173] Chunk #2 of 2 ...
[18:02:08.173]  - Finding globals in 'X' for chunk #2 ...
[18:02:08.173] getGlobalsAndPackages() ...
[18:02:08.174] Searching for globals...
[18:02:08.174] 
[18:02:08.174] Searching for globals ... DONE
[18:02:08.175] - globals: [0] <none>
[18:02:08.175] getGlobalsAndPackages() ... DONE
[18:02:08.175]    + additional globals found: [n=0] 
[18:02:08.175]    + additional namespaces needed: [n=0] 
[18:02:08.175]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:08.176]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:08.176]  - seeds: <none>
[18:02:08.176]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.176] getGlobalsAndPackages() ...
[18:02:08.176] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.177] Resolving globals: FALSE
[18:02:08.177] Tweak future expression to call with '...' arguments ...
[18:02:08.177] {
[18:02:08.177]     do.call(function(...) {
[18:02:08.177]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.177]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:08.177]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.177]             on.exit(options(oopts), add = TRUE)
[18:02:08.177]         }
[18:02:08.177]         {
[18:02:08.177]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:08.177]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.177]                 ...future.FUN(...future.X_jj, ...)
[18:02:08.177]             })
[18:02:08.177]         }
[18:02:08.177]     }, args = future.call.arguments)
[18:02:08.177] }
[18:02:08.178] Tweak future expression to call with '...' arguments ... DONE
[18:02:08.178] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.179] 
[18:02:08.179] getGlobalsAndPackages() ... DONE
[18:02:08.179] run() for ‘Future’ ...
[18:02:08.180] - state: ‘created’
[18:02:08.180] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:08.206] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:08.206] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:08.206]   - Field: ‘node’
[18:02:08.207]   - Field: ‘label’
[18:02:08.207]   - Field: ‘local’
[18:02:08.207]   - Field: ‘owner’
[18:02:08.207]   - Field: ‘envir’
[18:02:08.207]   - Field: ‘workers’
[18:02:08.208]   - Field: ‘packages’
[18:02:08.208]   - Field: ‘gc’
[18:02:08.208]   - Field: ‘conditions’
[18:02:08.208]   - Field: ‘persistent’
[18:02:08.208]   - Field: ‘expr’
[18:02:08.209]   - Field: ‘uuid’
[18:02:08.209]   - Field: ‘seed’
[18:02:08.209]   - Field: ‘version’
[18:02:08.209]   - Field: ‘result’
[18:02:08.209]   - Field: ‘asynchronous’
[18:02:08.210]   - Field: ‘calls’
[18:02:08.210]   - Field: ‘globals’
[18:02:08.210]   - Field: ‘stdout’
[18:02:08.210]   - Field: ‘earlySignal’
[18:02:08.210]   - Field: ‘lazy’
[18:02:08.211]   - Field: ‘state’
[18:02:08.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:08.211] - Launch lazy future ...
[18:02:08.212] Packages needed by the future expression (n = 0): <none>
[18:02:08.212] Packages needed by future strategies (n = 0): <none>
[18:02:08.213] {
[18:02:08.213]     {
[18:02:08.213]         {
[18:02:08.213]             ...future.startTime <- base::Sys.time()
[18:02:08.213]             {
[18:02:08.213]                 {
[18:02:08.213]                   {
[18:02:08.213]                     {
[18:02:08.213]                       base::local({
[18:02:08.213]                         has_future <- base::requireNamespace("future", 
[18:02:08.213]                           quietly = TRUE)
[18:02:08.213]                         if (has_future) {
[18:02:08.213]                           ns <- base::getNamespace("future")
[18:02:08.213]                           version <- ns[[".package"]][["version"]]
[18:02:08.213]                           if (is.null(version)) 
[18:02:08.213]                             version <- utils::packageVersion("future")
[18:02:08.213]                         }
[18:02:08.213]                         else {
[18:02:08.213]                           version <- NULL
[18:02:08.213]                         }
[18:02:08.213]                         if (!has_future || version < "1.8.0") {
[18:02:08.213]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:08.213]                             "", base::R.version$version.string), 
[18:02:08.213]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:08.213]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:08.213]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:08.213]                               "release", "version")], collapse = " "), 
[18:02:08.213]                             hostname = base::Sys.info()[["nodename"]])
[18:02:08.213]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:08.213]                             info)
[18:02:08.213]                           info <- base::paste(info, collapse = "; ")
[18:02:08.213]                           if (!has_future) {
[18:02:08.213]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:08.213]                               info)
[18:02:08.213]                           }
[18:02:08.213]                           else {
[18:02:08.213]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:08.213]                               info, version)
[18:02:08.213]                           }
[18:02:08.213]                           base::stop(msg)
[18:02:08.213]                         }
[18:02:08.213]                       })
[18:02:08.213]                     }
[18:02:08.213]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:08.213]                     base::options(mc.cores = 1L)
[18:02:08.213]                   }
[18:02:08.213]                   ...future.strategy.old <- future::plan("list")
[18:02:08.213]                   options(future.plan = NULL)
[18:02:08.213]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:08.213]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:08.213]                 }
[18:02:08.213]                 ...future.workdir <- getwd()
[18:02:08.213]             }
[18:02:08.213]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:08.213]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:08.213]         }
[18:02:08.213]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:08.213]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:08.213]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:08.213]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:08.213]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:08.213]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:08.213]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:08.213]             base::names(...future.oldOptions))
[18:02:08.213]     }
[18:02:08.213]     if (FALSE) {
[18:02:08.213]     }
[18:02:08.213]     else {
[18:02:08.213]         if (TRUE) {
[18:02:08.213]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:08.213]                 open = "w")
[18:02:08.213]         }
[18:02:08.213]         else {
[18:02:08.213]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:08.213]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:08.213]         }
[18:02:08.213]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:08.213]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:08.213]             base::sink(type = "output", split = FALSE)
[18:02:08.213]             base::close(...future.stdout)
[18:02:08.213]         }, add = TRUE)
[18:02:08.213]     }
[18:02:08.213]     ...future.frame <- base::sys.nframe()
[18:02:08.213]     ...future.conditions <- base::list()
[18:02:08.213]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:08.213]     if (FALSE) {
[18:02:08.213]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:08.213]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:08.213]     }
[18:02:08.213]     ...future.result <- base::tryCatch({
[18:02:08.213]         base::withCallingHandlers({
[18:02:08.213]             ...future.value <- base::withVisible(base::local({
[18:02:08.213]                 ...future.makeSendCondition <- base::local({
[18:02:08.213]                   sendCondition <- NULL
[18:02:08.213]                   function(frame = 1L) {
[18:02:08.213]                     if (is.function(sendCondition)) 
[18:02:08.213]                       return(sendCondition)
[18:02:08.213]                     ns <- getNamespace("parallel")
[18:02:08.213]                     if (exists("sendData", mode = "function", 
[18:02:08.213]                       envir = ns)) {
[18:02:08.213]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:08.213]                         envir = ns)
[18:02:08.213]                       envir <- sys.frame(frame)
[18:02:08.213]                       master <- NULL
[18:02:08.213]                       while (!identical(envir, .GlobalEnv) && 
[18:02:08.213]                         !identical(envir, emptyenv())) {
[18:02:08.213]                         if (exists("master", mode = "list", envir = envir, 
[18:02:08.213]                           inherits = FALSE)) {
[18:02:08.213]                           master <- get("master", mode = "list", 
[18:02:08.213]                             envir = envir, inherits = FALSE)
[18:02:08.213]                           if (inherits(master, c("SOCKnode", 
[18:02:08.213]                             "SOCK0node"))) {
[18:02:08.213]                             sendCondition <<- function(cond) {
[18:02:08.213]                               data <- list(type = "VALUE", value = cond, 
[18:02:08.213]                                 success = TRUE)
[18:02:08.213]                               parallel_sendData(master, data)
[18:02:08.213]                             }
[18:02:08.213]                             return(sendCondition)
[18:02:08.213]                           }
[18:02:08.213]                         }
[18:02:08.213]                         frame <- frame + 1L
[18:02:08.213]                         envir <- sys.frame(frame)
[18:02:08.213]                       }
[18:02:08.213]                     }
[18:02:08.213]                     sendCondition <<- function(cond) NULL
[18:02:08.213]                   }
[18:02:08.213]                 })
[18:02:08.213]                 withCallingHandlers({
[18:02:08.213]                   {
[18:02:08.213]                     do.call(function(...) {
[18:02:08.213]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.213]                       if (!identical(...future.globals.maxSize.org, 
[18:02:08.213]                         ...future.globals.maxSize)) {
[18:02:08.213]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.213]                         on.exit(options(oopts), add = TRUE)
[18:02:08.213]                       }
[18:02:08.213]                       {
[18:02:08.213]                         lapply(seq_along(...future.elements_ii), 
[18:02:08.213]                           FUN = function(jj) {
[18:02:08.213]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.213]                             ...future.FUN(...future.X_jj, ...)
[18:02:08.213]                           })
[18:02:08.213]                       }
[18:02:08.213]                     }, args = future.call.arguments)
[18:02:08.213]                   }
[18:02:08.213]                 }, immediateCondition = function(cond) {
[18:02:08.213]                   sendCondition <- ...future.makeSendCondition()
[18:02:08.213]                   sendCondition(cond)
[18:02:08.213]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.213]                   {
[18:02:08.213]                     inherits <- base::inherits
[18:02:08.213]                     invokeRestart <- base::invokeRestart
[18:02:08.213]                     is.null <- base::is.null
[18:02:08.213]                     muffled <- FALSE
[18:02:08.213]                     if (inherits(cond, "message")) {
[18:02:08.213]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:08.213]                       if (muffled) 
[18:02:08.213]                         invokeRestart("muffleMessage")
[18:02:08.213]                     }
[18:02:08.213]                     else if (inherits(cond, "warning")) {
[18:02:08.213]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:08.213]                       if (muffled) 
[18:02:08.213]                         invokeRestart("muffleWarning")
[18:02:08.213]                     }
[18:02:08.213]                     else if (inherits(cond, "condition")) {
[18:02:08.213]                       if (!is.null(pattern)) {
[18:02:08.213]                         computeRestarts <- base::computeRestarts
[18:02:08.213]                         grepl <- base::grepl
[18:02:08.213]                         restarts <- computeRestarts(cond)
[18:02:08.213]                         for (restart in restarts) {
[18:02:08.213]                           name <- restart$name
[18:02:08.213]                           if (is.null(name)) 
[18:02:08.213]                             next
[18:02:08.213]                           if (!grepl(pattern, name)) 
[18:02:08.213]                             next
[18:02:08.213]                           invokeRestart(restart)
[18:02:08.213]                           muffled <- TRUE
[18:02:08.213]                           break
[18:02:08.213]                         }
[18:02:08.213]                       }
[18:02:08.213]                     }
[18:02:08.213]                     invisible(muffled)
[18:02:08.213]                   }
[18:02:08.213]                   muffleCondition(cond)
[18:02:08.213]                 })
[18:02:08.213]             }))
[18:02:08.213]             future::FutureResult(value = ...future.value$value, 
[18:02:08.213]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:08.213]                   ...future.rng), globalenv = if (FALSE) 
[18:02:08.213]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:08.213]                     ...future.globalenv.names))
[18:02:08.213]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:08.213]         }, condition = base::local({
[18:02:08.213]             c <- base::c
[18:02:08.213]             inherits <- base::inherits
[18:02:08.213]             invokeRestart <- base::invokeRestart
[18:02:08.213]             length <- base::length
[18:02:08.213]             list <- base::list
[18:02:08.213]             seq.int <- base::seq.int
[18:02:08.213]             signalCondition <- base::signalCondition
[18:02:08.213]             sys.calls <- base::sys.calls
[18:02:08.213]             `[[` <- base::`[[`
[18:02:08.213]             `+` <- base::`+`
[18:02:08.213]             `<<-` <- base::`<<-`
[18:02:08.213]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:08.213]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:08.213]                   3L)]
[18:02:08.213]             }
[18:02:08.213]             function(cond) {
[18:02:08.213]                 is_error <- inherits(cond, "error")
[18:02:08.213]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:08.213]                   NULL)
[18:02:08.213]                 if (is_error) {
[18:02:08.213]                   sessionInformation <- function() {
[18:02:08.213]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:08.213]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:08.213]                       search = base::search(), system = base::Sys.info())
[18:02:08.213]                   }
[18:02:08.213]                   ...future.conditions[[length(...future.conditions) + 
[18:02:08.213]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:08.213]                     cond$call), session = sessionInformation(), 
[18:02:08.213]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:08.213]                   signalCondition(cond)
[18:02:08.213]                 }
[18:02:08.213]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:08.213]                 "immediateCondition"))) {
[18:02:08.213]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:08.213]                   ...future.conditions[[length(...future.conditions) + 
[18:02:08.213]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:08.213]                   if (TRUE && !signal) {
[18:02:08.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.213]                     {
[18:02:08.213]                       inherits <- base::inherits
[18:02:08.213]                       invokeRestart <- base::invokeRestart
[18:02:08.213]                       is.null <- base::is.null
[18:02:08.213]                       muffled <- FALSE
[18:02:08.213]                       if (inherits(cond, "message")) {
[18:02:08.213]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:08.213]                         if (muffled) 
[18:02:08.213]                           invokeRestart("muffleMessage")
[18:02:08.213]                       }
[18:02:08.213]                       else if (inherits(cond, "warning")) {
[18:02:08.213]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:08.213]                         if (muffled) 
[18:02:08.213]                           invokeRestart("muffleWarning")
[18:02:08.213]                       }
[18:02:08.213]                       else if (inherits(cond, "condition")) {
[18:02:08.213]                         if (!is.null(pattern)) {
[18:02:08.213]                           computeRestarts <- base::computeRestarts
[18:02:08.213]                           grepl <- base::grepl
[18:02:08.213]                           restarts <- computeRestarts(cond)
[18:02:08.213]                           for (restart in restarts) {
[18:02:08.213]                             name <- restart$name
[18:02:08.213]                             if (is.null(name)) 
[18:02:08.213]                               next
[18:02:08.213]                             if (!grepl(pattern, name)) 
[18:02:08.213]                               next
[18:02:08.213]                             invokeRestart(restart)
[18:02:08.213]                             muffled <- TRUE
[18:02:08.213]                             break
[18:02:08.213]                           }
[18:02:08.213]                         }
[18:02:08.213]                       }
[18:02:08.213]                       invisible(muffled)
[18:02:08.213]                     }
[18:02:08.213]                     muffleCondition(cond, pattern = "^muffle")
[18:02:08.213]                   }
[18:02:08.213]                 }
[18:02:08.213]                 else {
[18:02:08.213]                   if (TRUE) {
[18:02:08.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.213]                     {
[18:02:08.213]                       inherits <- base::inherits
[18:02:08.213]                       invokeRestart <- base::invokeRestart
[18:02:08.213]                       is.null <- base::is.null
[18:02:08.213]                       muffled <- FALSE
[18:02:08.213]                       if (inherits(cond, "message")) {
[18:02:08.213]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:08.213]                         if (muffled) 
[18:02:08.213]                           invokeRestart("muffleMessage")
[18:02:08.213]                       }
[18:02:08.213]                       else if (inherits(cond, "warning")) {
[18:02:08.213]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:08.213]                         if (muffled) 
[18:02:08.213]                           invokeRestart("muffleWarning")
[18:02:08.213]                       }
[18:02:08.213]                       else if (inherits(cond, "condition")) {
[18:02:08.213]                         if (!is.null(pattern)) {
[18:02:08.213]                           computeRestarts <- base::computeRestarts
[18:02:08.213]                           grepl <- base::grepl
[18:02:08.213]                           restarts <- computeRestarts(cond)
[18:02:08.213]                           for (restart in restarts) {
[18:02:08.213]                             name <- restart$name
[18:02:08.213]                             if (is.null(name)) 
[18:02:08.213]                               next
[18:02:08.213]                             if (!grepl(pattern, name)) 
[18:02:08.213]                               next
[18:02:08.213]                             invokeRestart(restart)
[18:02:08.213]                             muffled <- TRUE
[18:02:08.213]                             break
[18:02:08.213]                           }
[18:02:08.213]                         }
[18:02:08.213]                       }
[18:02:08.213]                       invisible(muffled)
[18:02:08.213]                     }
[18:02:08.213]                     muffleCondition(cond, pattern = "^muffle")
[18:02:08.213]                   }
[18:02:08.213]                 }
[18:02:08.213]             }
[18:02:08.213]         }))
[18:02:08.213]     }, error = function(ex) {
[18:02:08.213]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:08.213]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:08.213]                 ...future.rng), started = ...future.startTime, 
[18:02:08.213]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:08.213]             version = "1.8"), class = "FutureResult")
[18:02:08.213]     }, finally = {
[18:02:08.213]         if (!identical(...future.workdir, getwd())) 
[18:02:08.213]             setwd(...future.workdir)
[18:02:08.213]         {
[18:02:08.213]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:08.213]                 ...future.oldOptions$nwarnings <- NULL
[18:02:08.213]             }
[18:02:08.213]             base::options(...future.oldOptions)
[18:02:08.213]             if (.Platform$OS.type == "windows") {
[18:02:08.213]                 old_names <- names(...future.oldEnvVars)
[18:02:08.213]                 envs <- base::Sys.getenv()
[18:02:08.213]                 names <- names(envs)
[18:02:08.213]                 common <- intersect(names, old_names)
[18:02:08.213]                 added <- setdiff(names, old_names)
[18:02:08.213]                 removed <- setdiff(old_names, names)
[18:02:08.213]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:08.213]                   envs[common]]
[18:02:08.213]                 NAMES <- toupper(changed)
[18:02:08.213]                 args <- list()
[18:02:08.213]                 for (kk in seq_along(NAMES)) {
[18:02:08.213]                   name <- changed[[kk]]
[18:02:08.213]                   NAME <- NAMES[[kk]]
[18:02:08.213]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.213]                     next
[18:02:08.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:08.213]                 }
[18:02:08.213]                 NAMES <- toupper(added)
[18:02:08.213]                 for (kk in seq_along(NAMES)) {
[18:02:08.213]                   name <- added[[kk]]
[18:02:08.213]                   NAME <- NAMES[[kk]]
[18:02:08.213]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.213]                     next
[18:02:08.213]                   args[[name]] <- ""
[18:02:08.213]                 }
[18:02:08.213]                 NAMES <- toupper(removed)
[18:02:08.213]                 for (kk in seq_along(NAMES)) {
[18:02:08.213]                   name <- removed[[kk]]
[18:02:08.213]                   NAME <- NAMES[[kk]]
[18:02:08.213]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.213]                     next
[18:02:08.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:08.213]                 }
[18:02:08.213]                 if (length(args) > 0) 
[18:02:08.213]                   base::do.call(base::Sys.setenv, args = args)
[18:02:08.213]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:08.213]             }
[18:02:08.213]             else {
[18:02:08.213]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:08.213]             }
[18:02:08.213]             {
[18:02:08.213]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:08.213]                   0L) {
[18:02:08.213]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:08.213]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:08.213]                   base::options(opts)
[18:02:08.213]                 }
[18:02:08.213]                 {
[18:02:08.213]                   {
[18:02:08.213]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:08.213]                     NULL
[18:02:08.213]                   }
[18:02:08.213]                   options(future.plan = NULL)
[18:02:08.213]                   if (is.na(NA_character_)) 
[18:02:08.213]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:08.213]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:08.213]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:08.213]                     .init = FALSE)
[18:02:08.213]                 }
[18:02:08.213]             }
[18:02:08.213]         }
[18:02:08.213]     })
[18:02:08.213]     if (TRUE) {
[18:02:08.213]         base::sink(type = "output", split = FALSE)
[18:02:08.213]         if (TRUE) {
[18:02:08.213]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:08.213]         }
[18:02:08.213]         else {
[18:02:08.213]             ...future.result["stdout"] <- base::list(NULL)
[18:02:08.213]         }
[18:02:08.213]         base::close(...future.stdout)
[18:02:08.213]         ...future.stdout <- NULL
[18:02:08.213]     }
[18:02:08.213]     ...future.result$conditions <- ...future.conditions
[18:02:08.213]     ...future.result$finished <- base::Sys.time()
[18:02:08.213]     ...future.result
[18:02:08.213] }
[18:02:08.218] Exporting 5 global objects (4.16 KiB) to cluster node #2 ...
[18:02:08.218] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ...
[18:02:08.219] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ... DONE
[18:02:08.220] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[18:02:08.220] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[18:02:08.221] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[18:02:08.221] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[18:02:08.222] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:08.223] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:08.223] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:08.224] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:08.224] Exporting 5 global objects (4.16 KiB) to cluster node #2 ... DONE
[18:02:08.225] MultisessionFuture started
[18:02:08.225] - Launch lazy future ... done
[18:02:08.225] run() for ‘MultisessionFuture’ ... done
[18:02:08.226] Created future:
[18:02:08.226] MultisessionFuture:
[18:02:08.226] Label: ‘future_sapply-2’
[18:02:08.226] Expression:
[18:02:08.226] {
[18:02:08.226]     do.call(function(...) {
[18:02:08.226]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.226]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:08.226]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.226]             on.exit(options(oopts), add = TRUE)
[18:02:08.226]         }
[18:02:08.226]         {
[18:02:08.226]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:08.226]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.226]                 ...future.FUN(...future.X_jj, ...)
[18:02:08.226]             })
[18:02:08.226]         }
[18:02:08.226]     }, args = future.call.arguments)
[18:02:08.226] }
[18:02:08.226] Lazy evaluation: FALSE
[18:02:08.226] Asynchronous evaluation: TRUE
[18:02:08.226] Local evaluation: TRUE
[18:02:08.226] Environment: R_GlobalEnv
[18:02:08.226] Capture standard output: TRUE
[18:02:08.226] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:08.226] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:08.226] Packages: <none>
[18:02:08.226] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:08.226] Resolved: FALSE
[18:02:08.226] Value: <not collected>
[18:02:08.226] Conditions captured: <none>
[18:02:08.226] Early signaling: FALSE
[18:02:08.226] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:08.226] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:08.239] Chunk #2 of 2 ... DONE
[18:02:08.239] Launching 2 futures (chunks) ... DONE
[18:02:08.240] Resolving 2 futures (chunks) ...
[18:02:08.240] resolve() on list ...
[18:02:08.240]  recursive: 0
[18:02:08.240]  length: 2
[18:02:08.240] 
[18:02:08.241] receiveMessageFromWorker() for ClusterFuture ...
[18:02:08.242] - Validating connection of MultisessionFuture
[18:02:08.242] - received message: FutureResult
[18:02:08.242] - Received FutureResult
[18:02:08.242] - Erased future from FutureRegistry
[18:02:08.243] result() for ClusterFuture ...
[18:02:08.243] - result already collected: FutureResult
[18:02:08.243] result() for ClusterFuture ... done
[18:02:08.243] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:08.243] Future #1
[18:02:08.244] result() for ClusterFuture ...
[18:02:08.244] - result already collected: FutureResult
[18:02:08.244] result() for ClusterFuture ... done
[18:02:08.244] result() for ClusterFuture ...
[18:02:08.244] - result already collected: FutureResult
[18:02:08.244] result() for ClusterFuture ... done
[18:02:08.245] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:08.245] - nx: 2
[18:02:08.245] - relay: TRUE
[18:02:08.245] - stdout: TRUE
[18:02:08.245] - signal: TRUE
[18:02:08.246] - resignal: FALSE
[18:02:08.246] - force: TRUE
[18:02:08.246] - relayed: [n=2] FALSE, FALSE
[18:02:08.246] - queued futures: [n=2] FALSE, FALSE
[18:02:08.246]  - until=1
[18:02:08.246]  - relaying element #1
[18:02:08.247] result() for ClusterFuture ...
[18:02:08.247] - result already collected: FutureResult
[18:02:08.247] result() for ClusterFuture ... done
[18:02:08.247] result() for ClusterFuture ...
[18:02:08.247] - result already collected: FutureResult
[18:02:08.248] result() for ClusterFuture ... done
[18:02:08.248] result() for ClusterFuture ...
[18:02:08.248] - result already collected: FutureResult
[18:02:08.248] result() for ClusterFuture ... done
[18:02:08.248] result() for ClusterFuture ...
[18:02:08.249] - result already collected: FutureResult
[18:02:08.249] result() for ClusterFuture ... done
[18:02:08.249] - relayed: [n=2] TRUE, FALSE
[18:02:08.249] - queued futures: [n=2] TRUE, FALSE
[18:02:08.249] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:08.250]  length: 1 (resolved future 1)
[18:02:08.272] receiveMessageFromWorker() for ClusterFuture ...
[18:02:08.272] - Validating connection of MultisessionFuture
[18:02:08.272] - received message: FutureResult
[18:02:08.273] - Received FutureResult
[18:02:08.273] - Erased future from FutureRegistry
[18:02:08.273] result() for ClusterFuture ...
[18:02:08.273] - result already collected: FutureResult
[18:02:08.273] result() for ClusterFuture ... done
[18:02:08.274] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:08.274] Future #2
[18:02:08.274] result() for ClusterFuture ...
[18:02:08.274] - result already collected: FutureResult
[18:02:08.274] result() for ClusterFuture ... done
[18:02:08.275] result() for ClusterFuture ...
[18:02:08.275] - result already collected: FutureResult
[18:02:08.275] result() for ClusterFuture ... done
[18:02:08.275] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:08.276] - nx: 2
[18:02:08.276] - relay: TRUE
[18:02:08.276] - stdout: TRUE
[18:02:08.276] - signal: TRUE
[18:02:08.276] - resignal: FALSE
[18:02:08.276] - force: TRUE
[18:02:08.277] - relayed: [n=2] TRUE, FALSE
[18:02:08.277] - queued futures: [n=2] TRUE, FALSE
[18:02:08.277]  - until=2
[18:02:08.277]  - relaying element #2
[18:02:08.277] result() for ClusterFuture ...
[18:02:08.278] - result already collected: FutureResult
[18:02:08.278] result() for ClusterFuture ... done
[18:02:08.278] result() for ClusterFuture ...
[18:02:08.278] - result already collected: FutureResult
[18:02:08.278] result() for ClusterFuture ... done
[18:02:08.279] result() for ClusterFuture ...
[18:02:08.279] - result already collected: FutureResult
[18:02:08.279] result() for ClusterFuture ... done
[18:02:08.279] result() for ClusterFuture ...
[18:02:08.280] - result already collected: FutureResult
[18:02:08.280] result() for ClusterFuture ... done
[18:02:08.280] - relayed: [n=2] TRUE, TRUE
[18:02:08.280] - queued futures: [n=2] TRUE, TRUE
[18:02:08.280] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:08.281]  length: 0 (resolved future 2)
[18:02:08.281] Relaying remaining futures
[18:02:08.281] signalConditionsASAP(NULL, pos=0) ...
[18:02:08.281] - nx: 2
[18:02:08.281] - relay: TRUE
[18:02:08.281] - stdout: TRUE
[18:02:08.282] - signal: TRUE
[18:02:08.282] - resignal: FALSE
[18:02:08.282] - force: TRUE
[18:02:08.282] - relayed: [n=2] TRUE, TRUE
[18:02:08.282] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:08.283] - relayed: [n=2] TRUE, TRUE
[18:02:08.283] - queued futures: [n=2] TRUE, TRUE
[18:02:08.283] signalConditionsASAP(NULL, pos=0) ... done
[18:02:08.283] resolve() on list ... DONE
[18:02:08.284] result() for ClusterFuture ...
[18:02:08.284] - result already collected: FutureResult
[18:02:08.284] result() for ClusterFuture ... done
[18:02:08.284] result() for ClusterFuture ...
[18:02:08.284] - result already collected: FutureResult
[18:02:08.285] result() for ClusterFuture ... done
[18:02:08.285] result() for ClusterFuture ...
[18:02:08.285] - result already collected: FutureResult
[18:02:08.286] result() for ClusterFuture ... done
[18:02:08.286] result() for ClusterFuture ...
[18:02:08.286] - result already collected: FutureResult
[18:02:08.286] result() for ClusterFuture ... done
[18:02:08.287]  - Number of value chunks collected: 2
[18:02:08.287] Resolving 2 futures (chunks) ... DONE
[18:02:08.287] Reducing values from 2 chunks ...
[18:02:08.287]  - Number of values collected after concatenation: 4
[18:02:08.287]  - Number of values expected: 4
[18:02:08.288] Reducing values from 2 chunks ... DONE
[18:02:08.288] future_lapply() ... DONE
[18:02:08.289] future_lapply() ...
[18:02:08.299] Number of chunks: 2
[18:02:08.299] getGlobalsAndPackagesXApply() ...
[18:02:08.299]  - future.globals: TRUE
[18:02:08.299] getGlobalsAndPackages() ...
[18:02:08.300] Searching for globals...
[18:02:08.308] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[18:02:08.308] Searching for globals ... DONE
[18:02:08.309] Resolving globals: FALSE
[18:02:08.311] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[18:02:08.312] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:08.312] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:08.312] - packages: [1] ‘future.apply’
[18:02:08.313] getGlobalsAndPackages() ... DONE
[18:02:08.313]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:08.313]  - needed namespaces: [n=1] ‘future.apply’
[18:02:08.313] Finding globals ... DONE
[18:02:08.313]  - use_args: TRUE
[18:02:08.314]  - Getting '...' globals ...
[18:02:08.314] resolve() on list ...
[18:02:08.315]  recursive: 0
[18:02:08.315]  length: 1
[18:02:08.315]  elements: ‘...’
[18:02:08.315]  length: 0 (resolved future 1)
[18:02:08.315] resolve() on list ... DONE
[18:02:08.316]    - '...' content: [n=1] ‘y’
[18:02:08.316] List of 1
[18:02:08.316]  $ ...:List of 1
[18:02:08.316]   ..$ y: num [1:5] 2 4 6 8 10
[18:02:08.316]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:08.316]  - attr(*, "where")=List of 1
[18:02:08.316]   ..$ ...:<environment: 0x6183c285f338> 
[18:02:08.316]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:08.316]  - attr(*, "resolved")= logi TRUE
[18:02:08.316]  - attr(*, "total_size")= num NA
[18:02:08.322]  - Getting '...' globals ... DONE
[18:02:08.323] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:08.323] List of 8
[18:02:08.323]  $ ...future.FUN:function (x, ...)  
[18:02:08.323]  $ x_FUN        :function (x, y)  
[18:02:08.323]  $ times        : int 15
[18:02:08.323]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:08.323]  $ stop_if_not  :function (...)  
[18:02:08.323]  $ dim          : int [1:2] 3 5
[18:02:08.323]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:02:08.323]  $ ...          :List of 1
[18:02:08.323]   ..$ y: num [1:5] 2 4 6 8 10
[18:02:08.323]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:08.323]  - attr(*, "where")=List of 8
[18:02:08.323]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:08.323]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:08.323]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:08.323]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:08.323]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:08.323]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:08.323]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:08.323]   ..$ ...          :<environment: 0x6183c285f338> 
[18:02:08.323]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:08.323]  - attr(*, "resolved")= logi FALSE
[18:02:08.323]  - attr(*, "total_size")= num 98600
[18:02:08.340] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:08.340] getGlobalsAndPackagesXApply() ... DONE
[18:02:08.340] Number of futures (= number of chunks): 2
[18:02:08.341] Launching 2 futures (chunks) ...
[18:02:08.341] Chunk #1 of 2 ...
[18:02:08.341]  - Finding globals in 'X' for chunk #1 ...
[18:02:08.341] getGlobalsAndPackages() ...
[18:02:08.342] Searching for globals...
[18:02:08.342] 
[18:02:08.342] Searching for globals ... DONE
[18:02:08.343] - globals: [0] <none>
[18:02:08.343] getGlobalsAndPackages() ... DONE
[18:02:08.343]    + additional globals found: [n=0] 
[18:02:08.343]    + additional namespaces needed: [n=0] 
[18:02:08.343]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:08.343]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:08.344]  - seeds: <none>
[18:02:08.344]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.344] getGlobalsAndPackages() ...
[18:02:08.344] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.345] Resolving globals: FALSE
[18:02:08.345] Tweak future expression to call with '...' arguments ...
[18:02:08.345] {
[18:02:08.345]     do.call(function(...) {
[18:02:08.345]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.345]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:08.345]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.345]             on.exit(options(oopts), add = TRUE)
[18:02:08.345]         }
[18:02:08.345]         {
[18:02:08.345]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:08.345]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.345]                 ...future.FUN(...future.X_jj, ...)
[18:02:08.345]             })
[18:02:08.345]         }
[18:02:08.345]     }, args = future.call.arguments)
[18:02:08.345] }
[18:02:08.346] Tweak future expression to call with '...' arguments ... DONE
[18:02:08.347] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.347] - packages: [1] ‘future.apply’
[18:02:08.347] getGlobalsAndPackages() ... DONE
[18:02:08.348] run() for ‘Future’ ...
[18:02:08.348] - state: ‘created’
[18:02:08.348] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:08.373] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:08.373] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:08.374]   - Field: ‘node’
[18:02:08.374]   - Field: ‘label’
[18:02:08.374]   - Field: ‘local’
[18:02:08.374]   - Field: ‘owner’
[18:02:08.374]   - Field: ‘envir’
[18:02:08.375]   - Field: ‘workers’
[18:02:08.375]   - Field: ‘packages’
[18:02:08.375]   - Field: ‘gc’
[18:02:08.375]   - Field: ‘conditions’
[18:02:08.376]   - Field: ‘persistent’
[18:02:08.376]   - Field: ‘expr’
[18:02:08.376]   - Field: ‘uuid’
[18:02:08.376]   - Field: ‘seed’
[18:02:08.376]   - Field: ‘version’
[18:02:08.377]   - Field: ‘result’
[18:02:08.377]   - Field: ‘asynchronous’
[18:02:08.377]   - Field: ‘calls’
[18:02:08.377]   - Field: ‘globals’
[18:02:08.377]   - Field: ‘stdout’
[18:02:08.378]   - Field: ‘earlySignal’
[18:02:08.378]   - Field: ‘lazy’
[18:02:08.378]   - Field: ‘state’
[18:02:08.378] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:08.378] - Launch lazy future ...
[18:02:08.379] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:08.379] Packages needed by future strategies (n = 0): <none>
[18:02:08.380] {
[18:02:08.380]     {
[18:02:08.380]         {
[18:02:08.380]             ...future.startTime <- base::Sys.time()
[18:02:08.380]             {
[18:02:08.380]                 {
[18:02:08.380]                   {
[18:02:08.380]                     {
[18:02:08.380]                       {
[18:02:08.380]                         base::local({
[18:02:08.380]                           has_future <- base::requireNamespace("future", 
[18:02:08.380]                             quietly = TRUE)
[18:02:08.380]                           if (has_future) {
[18:02:08.380]                             ns <- base::getNamespace("future")
[18:02:08.380]                             version <- ns[[".package"]][["version"]]
[18:02:08.380]                             if (is.null(version)) 
[18:02:08.380]                               version <- utils::packageVersion("future")
[18:02:08.380]                           }
[18:02:08.380]                           else {
[18:02:08.380]                             version <- NULL
[18:02:08.380]                           }
[18:02:08.380]                           if (!has_future || version < "1.8.0") {
[18:02:08.380]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:08.380]                               "", base::R.version$version.string), 
[18:02:08.380]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:08.380]                                 base::R.version$platform, 8 * 
[18:02:08.380]                                   base::.Machine$sizeof.pointer), 
[18:02:08.380]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:08.380]                                 "release", "version")], collapse = " "), 
[18:02:08.380]                               hostname = base::Sys.info()[["nodename"]])
[18:02:08.380]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:08.380]                               info)
[18:02:08.380]                             info <- base::paste(info, collapse = "; ")
[18:02:08.380]                             if (!has_future) {
[18:02:08.380]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:08.380]                                 info)
[18:02:08.380]                             }
[18:02:08.380]                             else {
[18:02:08.380]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:08.380]                                 info, version)
[18:02:08.380]                             }
[18:02:08.380]                             base::stop(msg)
[18:02:08.380]                           }
[18:02:08.380]                         })
[18:02:08.380]                       }
[18:02:08.380]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:08.380]                       base::options(mc.cores = 1L)
[18:02:08.380]                     }
[18:02:08.380]                     base::local({
[18:02:08.380]                       for (pkg in "future.apply") {
[18:02:08.380]                         base::loadNamespace(pkg)
[18:02:08.380]                         base::library(pkg, character.only = TRUE)
[18:02:08.380]                       }
[18:02:08.380]                     })
[18:02:08.380]                   }
[18:02:08.380]                   ...future.strategy.old <- future::plan("list")
[18:02:08.380]                   options(future.plan = NULL)
[18:02:08.380]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:08.380]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:08.380]                 }
[18:02:08.380]                 ...future.workdir <- getwd()
[18:02:08.380]             }
[18:02:08.380]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:08.380]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:08.380]         }
[18:02:08.380]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:08.380]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:08.380]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:08.380]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:08.380]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:08.380]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:08.380]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:08.380]             base::names(...future.oldOptions))
[18:02:08.380]     }
[18:02:08.380]     if (FALSE) {
[18:02:08.380]     }
[18:02:08.380]     else {
[18:02:08.380]         if (TRUE) {
[18:02:08.380]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:08.380]                 open = "w")
[18:02:08.380]         }
[18:02:08.380]         else {
[18:02:08.380]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:08.380]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:08.380]         }
[18:02:08.380]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:08.380]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:08.380]             base::sink(type = "output", split = FALSE)
[18:02:08.380]             base::close(...future.stdout)
[18:02:08.380]         }, add = TRUE)
[18:02:08.380]     }
[18:02:08.380]     ...future.frame <- base::sys.nframe()
[18:02:08.380]     ...future.conditions <- base::list()
[18:02:08.380]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:08.380]     if (FALSE) {
[18:02:08.380]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:08.380]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:08.380]     }
[18:02:08.380]     ...future.result <- base::tryCatch({
[18:02:08.380]         base::withCallingHandlers({
[18:02:08.380]             ...future.value <- base::withVisible(base::local({
[18:02:08.380]                 ...future.makeSendCondition <- base::local({
[18:02:08.380]                   sendCondition <- NULL
[18:02:08.380]                   function(frame = 1L) {
[18:02:08.380]                     if (is.function(sendCondition)) 
[18:02:08.380]                       return(sendCondition)
[18:02:08.380]                     ns <- getNamespace("parallel")
[18:02:08.380]                     if (exists("sendData", mode = "function", 
[18:02:08.380]                       envir = ns)) {
[18:02:08.380]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:08.380]                         envir = ns)
[18:02:08.380]                       envir <- sys.frame(frame)
[18:02:08.380]                       master <- NULL
[18:02:08.380]                       while (!identical(envir, .GlobalEnv) && 
[18:02:08.380]                         !identical(envir, emptyenv())) {
[18:02:08.380]                         if (exists("master", mode = "list", envir = envir, 
[18:02:08.380]                           inherits = FALSE)) {
[18:02:08.380]                           master <- get("master", mode = "list", 
[18:02:08.380]                             envir = envir, inherits = FALSE)
[18:02:08.380]                           if (inherits(master, c("SOCKnode", 
[18:02:08.380]                             "SOCK0node"))) {
[18:02:08.380]                             sendCondition <<- function(cond) {
[18:02:08.380]                               data <- list(type = "VALUE", value = cond, 
[18:02:08.380]                                 success = TRUE)
[18:02:08.380]                               parallel_sendData(master, data)
[18:02:08.380]                             }
[18:02:08.380]                             return(sendCondition)
[18:02:08.380]                           }
[18:02:08.380]                         }
[18:02:08.380]                         frame <- frame + 1L
[18:02:08.380]                         envir <- sys.frame(frame)
[18:02:08.380]                       }
[18:02:08.380]                     }
[18:02:08.380]                     sendCondition <<- function(cond) NULL
[18:02:08.380]                   }
[18:02:08.380]                 })
[18:02:08.380]                 withCallingHandlers({
[18:02:08.380]                   {
[18:02:08.380]                     do.call(function(...) {
[18:02:08.380]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.380]                       if (!identical(...future.globals.maxSize.org, 
[18:02:08.380]                         ...future.globals.maxSize)) {
[18:02:08.380]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.380]                         on.exit(options(oopts), add = TRUE)
[18:02:08.380]                       }
[18:02:08.380]                       {
[18:02:08.380]                         lapply(seq_along(...future.elements_ii), 
[18:02:08.380]                           FUN = function(jj) {
[18:02:08.380]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.380]                             ...future.FUN(...future.X_jj, ...)
[18:02:08.380]                           })
[18:02:08.380]                       }
[18:02:08.380]                     }, args = future.call.arguments)
[18:02:08.380]                   }
[18:02:08.380]                 }, immediateCondition = function(cond) {
[18:02:08.380]                   sendCondition <- ...future.makeSendCondition()
[18:02:08.380]                   sendCondition(cond)
[18:02:08.380]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.380]                   {
[18:02:08.380]                     inherits <- base::inherits
[18:02:08.380]                     invokeRestart <- base::invokeRestart
[18:02:08.380]                     is.null <- base::is.null
[18:02:08.380]                     muffled <- FALSE
[18:02:08.380]                     if (inherits(cond, "message")) {
[18:02:08.380]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:08.380]                       if (muffled) 
[18:02:08.380]                         invokeRestart("muffleMessage")
[18:02:08.380]                     }
[18:02:08.380]                     else if (inherits(cond, "warning")) {
[18:02:08.380]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:08.380]                       if (muffled) 
[18:02:08.380]                         invokeRestart("muffleWarning")
[18:02:08.380]                     }
[18:02:08.380]                     else if (inherits(cond, "condition")) {
[18:02:08.380]                       if (!is.null(pattern)) {
[18:02:08.380]                         computeRestarts <- base::computeRestarts
[18:02:08.380]                         grepl <- base::grepl
[18:02:08.380]                         restarts <- computeRestarts(cond)
[18:02:08.380]                         for (restart in restarts) {
[18:02:08.380]                           name <- restart$name
[18:02:08.380]                           if (is.null(name)) 
[18:02:08.380]                             next
[18:02:08.380]                           if (!grepl(pattern, name)) 
[18:02:08.380]                             next
[18:02:08.380]                           invokeRestart(restart)
[18:02:08.380]                           muffled <- TRUE
[18:02:08.380]                           break
[18:02:08.380]                         }
[18:02:08.380]                       }
[18:02:08.380]                     }
[18:02:08.380]                     invisible(muffled)
[18:02:08.380]                   }
[18:02:08.380]                   muffleCondition(cond)
[18:02:08.380]                 })
[18:02:08.380]             }))
[18:02:08.380]             future::FutureResult(value = ...future.value$value, 
[18:02:08.380]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:08.380]                   ...future.rng), globalenv = if (FALSE) 
[18:02:08.380]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:08.380]                     ...future.globalenv.names))
[18:02:08.380]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:08.380]         }, condition = base::local({
[18:02:08.380]             c <- base::c
[18:02:08.380]             inherits <- base::inherits
[18:02:08.380]             invokeRestart <- base::invokeRestart
[18:02:08.380]             length <- base::length
[18:02:08.380]             list <- base::list
[18:02:08.380]             seq.int <- base::seq.int
[18:02:08.380]             signalCondition <- base::signalCondition
[18:02:08.380]             sys.calls <- base::sys.calls
[18:02:08.380]             `[[` <- base::`[[`
[18:02:08.380]             `+` <- base::`+`
[18:02:08.380]             `<<-` <- base::`<<-`
[18:02:08.380]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:08.380]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:08.380]                   3L)]
[18:02:08.380]             }
[18:02:08.380]             function(cond) {
[18:02:08.380]                 is_error <- inherits(cond, "error")
[18:02:08.380]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:08.380]                   NULL)
[18:02:08.380]                 if (is_error) {
[18:02:08.380]                   sessionInformation <- function() {
[18:02:08.380]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:08.380]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:08.380]                       search = base::search(), system = base::Sys.info())
[18:02:08.380]                   }
[18:02:08.380]                   ...future.conditions[[length(...future.conditions) + 
[18:02:08.380]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:08.380]                     cond$call), session = sessionInformation(), 
[18:02:08.380]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:08.380]                   signalCondition(cond)
[18:02:08.380]                 }
[18:02:08.380]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:08.380]                 "immediateCondition"))) {
[18:02:08.380]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:08.380]                   ...future.conditions[[length(...future.conditions) + 
[18:02:08.380]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:08.380]                   if (TRUE && !signal) {
[18:02:08.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.380]                     {
[18:02:08.380]                       inherits <- base::inherits
[18:02:08.380]                       invokeRestart <- base::invokeRestart
[18:02:08.380]                       is.null <- base::is.null
[18:02:08.380]                       muffled <- FALSE
[18:02:08.380]                       if (inherits(cond, "message")) {
[18:02:08.380]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:08.380]                         if (muffled) 
[18:02:08.380]                           invokeRestart("muffleMessage")
[18:02:08.380]                       }
[18:02:08.380]                       else if (inherits(cond, "warning")) {
[18:02:08.380]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:08.380]                         if (muffled) 
[18:02:08.380]                           invokeRestart("muffleWarning")
[18:02:08.380]                       }
[18:02:08.380]                       else if (inherits(cond, "condition")) {
[18:02:08.380]                         if (!is.null(pattern)) {
[18:02:08.380]                           computeRestarts <- base::computeRestarts
[18:02:08.380]                           grepl <- base::grepl
[18:02:08.380]                           restarts <- computeRestarts(cond)
[18:02:08.380]                           for (restart in restarts) {
[18:02:08.380]                             name <- restart$name
[18:02:08.380]                             if (is.null(name)) 
[18:02:08.380]                               next
[18:02:08.380]                             if (!grepl(pattern, name)) 
[18:02:08.380]                               next
[18:02:08.380]                             invokeRestart(restart)
[18:02:08.380]                             muffled <- TRUE
[18:02:08.380]                             break
[18:02:08.380]                           }
[18:02:08.380]                         }
[18:02:08.380]                       }
[18:02:08.380]                       invisible(muffled)
[18:02:08.380]                     }
[18:02:08.380]                     muffleCondition(cond, pattern = "^muffle")
[18:02:08.380]                   }
[18:02:08.380]                 }
[18:02:08.380]                 else {
[18:02:08.380]                   if (TRUE) {
[18:02:08.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.380]                     {
[18:02:08.380]                       inherits <- base::inherits
[18:02:08.380]                       invokeRestart <- base::invokeRestart
[18:02:08.380]                       is.null <- base::is.null
[18:02:08.380]                       muffled <- FALSE
[18:02:08.380]                       if (inherits(cond, "message")) {
[18:02:08.380]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:08.380]                         if (muffled) 
[18:02:08.380]                           invokeRestart("muffleMessage")
[18:02:08.380]                       }
[18:02:08.380]                       else if (inherits(cond, "warning")) {
[18:02:08.380]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:08.380]                         if (muffled) 
[18:02:08.380]                           invokeRestart("muffleWarning")
[18:02:08.380]                       }
[18:02:08.380]                       else if (inherits(cond, "condition")) {
[18:02:08.380]                         if (!is.null(pattern)) {
[18:02:08.380]                           computeRestarts <- base::computeRestarts
[18:02:08.380]                           grepl <- base::grepl
[18:02:08.380]                           restarts <- computeRestarts(cond)
[18:02:08.380]                           for (restart in restarts) {
[18:02:08.380]                             name <- restart$name
[18:02:08.380]                             if (is.null(name)) 
[18:02:08.380]                               next
[18:02:08.380]                             if (!grepl(pattern, name)) 
[18:02:08.380]                               next
[18:02:08.380]                             invokeRestart(restart)
[18:02:08.380]                             muffled <- TRUE
[18:02:08.380]                             break
[18:02:08.380]                           }
[18:02:08.380]                         }
[18:02:08.380]                       }
[18:02:08.380]                       invisible(muffled)
[18:02:08.380]                     }
[18:02:08.380]                     muffleCondition(cond, pattern = "^muffle")
[18:02:08.380]                   }
[18:02:08.380]                 }
[18:02:08.380]             }
[18:02:08.380]         }))
[18:02:08.380]     }, error = function(ex) {
[18:02:08.380]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:08.380]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:08.380]                 ...future.rng), started = ...future.startTime, 
[18:02:08.380]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:08.380]             version = "1.8"), class = "FutureResult")
[18:02:08.380]     }, finally = {
[18:02:08.380]         if (!identical(...future.workdir, getwd())) 
[18:02:08.380]             setwd(...future.workdir)
[18:02:08.380]         {
[18:02:08.380]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:08.380]                 ...future.oldOptions$nwarnings <- NULL
[18:02:08.380]             }
[18:02:08.380]             base::options(...future.oldOptions)
[18:02:08.380]             if (.Platform$OS.type == "windows") {
[18:02:08.380]                 old_names <- names(...future.oldEnvVars)
[18:02:08.380]                 envs <- base::Sys.getenv()
[18:02:08.380]                 names <- names(envs)
[18:02:08.380]                 common <- intersect(names, old_names)
[18:02:08.380]                 added <- setdiff(names, old_names)
[18:02:08.380]                 removed <- setdiff(old_names, names)
[18:02:08.380]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:08.380]                   envs[common]]
[18:02:08.380]                 NAMES <- toupper(changed)
[18:02:08.380]                 args <- list()
[18:02:08.380]                 for (kk in seq_along(NAMES)) {
[18:02:08.380]                   name <- changed[[kk]]
[18:02:08.380]                   NAME <- NAMES[[kk]]
[18:02:08.380]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.380]                     next
[18:02:08.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:08.380]                 }
[18:02:08.380]                 NAMES <- toupper(added)
[18:02:08.380]                 for (kk in seq_along(NAMES)) {
[18:02:08.380]                   name <- added[[kk]]
[18:02:08.380]                   NAME <- NAMES[[kk]]
[18:02:08.380]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.380]                     next
[18:02:08.380]                   args[[name]] <- ""
[18:02:08.380]                 }
[18:02:08.380]                 NAMES <- toupper(removed)
[18:02:08.380]                 for (kk in seq_along(NAMES)) {
[18:02:08.380]                   name <- removed[[kk]]
[18:02:08.380]                   NAME <- NAMES[[kk]]
[18:02:08.380]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.380]                     next
[18:02:08.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:08.380]                 }
[18:02:08.380]                 if (length(args) > 0) 
[18:02:08.380]                   base::do.call(base::Sys.setenv, args = args)
[18:02:08.380]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:08.380]             }
[18:02:08.380]             else {
[18:02:08.380]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:08.380]             }
[18:02:08.380]             {
[18:02:08.380]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:08.380]                   0L) {
[18:02:08.380]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:08.380]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:08.380]                   base::options(opts)
[18:02:08.380]                 }
[18:02:08.380]                 {
[18:02:08.380]                   {
[18:02:08.380]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:08.380]                     NULL
[18:02:08.380]                   }
[18:02:08.380]                   options(future.plan = NULL)
[18:02:08.380]                   if (is.na(NA_character_)) 
[18:02:08.380]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:08.380]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:08.380]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:08.380]                     .init = FALSE)
[18:02:08.380]                 }
[18:02:08.380]             }
[18:02:08.380]         }
[18:02:08.380]     })
[18:02:08.380]     if (TRUE) {
[18:02:08.380]         base::sink(type = "output", split = FALSE)
[18:02:08.380]         if (TRUE) {
[18:02:08.380]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:08.380]         }
[18:02:08.380]         else {
[18:02:08.380]             ...future.result["stdout"] <- base::list(NULL)
[18:02:08.380]         }
[18:02:08.380]         base::close(...future.stdout)
[18:02:08.380]         ...future.stdout <- NULL
[18:02:08.380]     }
[18:02:08.380]     ...future.result$conditions <- ...future.conditions
[18:02:08.380]     ...future.result$finished <- base::Sys.time()
[18:02:08.380]     ...future.result
[18:02:08.380] }
[18:02:08.386] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[18:02:08.386] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[18:02:08.427] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[18:02:08.428] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[18:02:08.429] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[18:02:08.429] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[18:02:08.430] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[18:02:08.430] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[18:02:08.471] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[18:02:08.472] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[18:02:08.513] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[18:02:08.514] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[18:02:08.515] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[18:02:08.516] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[18:02:08.517] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[18:02:08.517] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[18:02:08.519] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[18:02:08.519] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[18:02:08.520] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[18:02:08.521] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:08.522] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:08.522] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:08.523] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:08.524] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[18:02:08.526] MultisessionFuture started
[18:02:08.526] - Launch lazy future ... done
[18:02:08.526] run() for ‘MultisessionFuture’ ... done
[18:02:08.527] Created future:
[18:02:08.527] MultisessionFuture:
[18:02:08.527] Label: ‘future_vapply-1’
[18:02:08.527] Expression:
[18:02:08.527] {
[18:02:08.527]     do.call(function(...) {
[18:02:08.527]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.527]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:08.527]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.527]             on.exit(options(oopts), add = TRUE)
[18:02:08.527]         }
[18:02:08.527]         {
[18:02:08.527]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:08.527]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.527]                 ...future.FUN(...future.X_jj, ...)
[18:02:08.527]             })
[18:02:08.527]         }
[18:02:08.527]     }, args = future.call.arguments)
[18:02:08.527] }
[18:02:08.527] Lazy evaluation: FALSE
[18:02:08.527] Asynchronous evaluation: TRUE
[18:02:08.527] Local evaluation: TRUE
[18:02:08.527] Environment: R_GlobalEnv
[18:02:08.527] Capture standard output: TRUE
[18:02:08.527] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:08.527] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:08.527] Packages: 1 packages (‘future.apply’)
[18:02:08.527] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:08.527] Resolved: FALSE
[18:02:08.527] Value: <not collected>
[18:02:08.527] Conditions captured: <none>
[18:02:08.527] Early signaling: FALSE
[18:02:08.527] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:08.527] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:08.542] Chunk #1 of 2 ... DONE
[18:02:08.542] Chunk #2 of 2 ...
[18:02:08.543]  - Finding globals in 'X' for chunk #2 ...
[18:02:08.543] getGlobalsAndPackages() ...
[18:02:08.543] Searching for globals...
[18:02:08.544] 
[18:02:08.545] Searching for globals ... DONE
[18:02:08.545] - globals: [0] <none>
[18:02:08.545] getGlobalsAndPackages() ... DONE
[18:02:08.545]    + additional globals found: [n=0] 
[18:02:08.546]    + additional namespaces needed: [n=0] 
[18:02:08.546]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:08.546]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:08.547]  - seeds: <none>
[18:02:08.547]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.547] getGlobalsAndPackages() ...
[18:02:08.548] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.548] Resolving globals: FALSE
[18:02:08.549] Tweak future expression to call with '...' arguments ...
[18:02:08.549] {
[18:02:08.549]     do.call(function(...) {
[18:02:08.549]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.549]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:08.549]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.549]             on.exit(options(oopts), add = TRUE)
[18:02:08.549]         }
[18:02:08.549]         {
[18:02:08.549]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:08.549]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.549]                 ...future.FUN(...future.X_jj, ...)
[18:02:08.549]             })
[18:02:08.549]         }
[18:02:08.549]     }, args = future.call.arguments)
[18:02:08.549] }
[18:02:08.550] Tweak future expression to call with '...' arguments ... DONE
[18:02:08.551] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.552] - packages: [1] ‘future.apply’
[18:02:08.552] getGlobalsAndPackages() ... DONE
[18:02:08.553] run() for ‘Future’ ...
[18:02:08.553] - state: ‘created’
[18:02:08.554] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:08.583] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:08.583] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:08.583]   - Field: ‘node’
[18:02:08.583]   - Field: ‘label’
[18:02:08.584]   - Field: ‘local’
[18:02:08.584]   - Field: ‘owner’
[18:02:08.584]   - Field: ‘envir’
[18:02:08.584]   - Field: ‘workers’
[18:02:08.585]   - Field: ‘packages’
[18:02:08.585]   - Field: ‘gc’
[18:02:08.585]   - Field: ‘conditions’
[18:02:08.585]   - Field: ‘persistent’
[18:02:08.586]   - Field: ‘expr’
[18:02:08.586]   - Field: ‘uuid’
[18:02:08.586]   - Field: ‘seed’
[18:02:08.586]   - Field: ‘version’
[18:02:08.586]   - Field: ‘result’
[18:02:08.587]   - Field: ‘asynchronous’
[18:02:08.587]   - Field: ‘calls’
[18:02:08.587]   - Field: ‘globals’
[18:02:08.587]   - Field: ‘stdout’
[18:02:08.588]   - Field: ‘earlySignal’
[18:02:08.588]   - Field: ‘lazy’
[18:02:08.588]   - Field: ‘state’
[18:02:08.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:08.589] - Launch lazy future ...
[18:02:08.589] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:08.590] Packages needed by future strategies (n = 0): <none>
[18:02:08.591] {
[18:02:08.591]     {
[18:02:08.591]         {
[18:02:08.591]             ...future.startTime <- base::Sys.time()
[18:02:08.591]             {
[18:02:08.591]                 {
[18:02:08.591]                   {
[18:02:08.591]                     {
[18:02:08.591]                       {
[18:02:08.591]                         base::local({
[18:02:08.591]                           has_future <- base::requireNamespace("future", 
[18:02:08.591]                             quietly = TRUE)
[18:02:08.591]                           if (has_future) {
[18:02:08.591]                             ns <- base::getNamespace("future")
[18:02:08.591]                             version <- ns[[".package"]][["version"]]
[18:02:08.591]                             if (is.null(version)) 
[18:02:08.591]                               version <- utils::packageVersion("future")
[18:02:08.591]                           }
[18:02:08.591]                           else {
[18:02:08.591]                             version <- NULL
[18:02:08.591]                           }
[18:02:08.591]                           if (!has_future || version < "1.8.0") {
[18:02:08.591]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:08.591]                               "", base::R.version$version.string), 
[18:02:08.591]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:08.591]                                 base::R.version$platform, 8 * 
[18:02:08.591]                                   base::.Machine$sizeof.pointer), 
[18:02:08.591]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:08.591]                                 "release", "version")], collapse = " "), 
[18:02:08.591]                               hostname = base::Sys.info()[["nodename"]])
[18:02:08.591]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:08.591]                               info)
[18:02:08.591]                             info <- base::paste(info, collapse = "; ")
[18:02:08.591]                             if (!has_future) {
[18:02:08.591]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:08.591]                                 info)
[18:02:08.591]                             }
[18:02:08.591]                             else {
[18:02:08.591]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:08.591]                                 info, version)
[18:02:08.591]                             }
[18:02:08.591]                             base::stop(msg)
[18:02:08.591]                           }
[18:02:08.591]                         })
[18:02:08.591]                       }
[18:02:08.591]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:08.591]                       base::options(mc.cores = 1L)
[18:02:08.591]                     }
[18:02:08.591]                     base::local({
[18:02:08.591]                       for (pkg in "future.apply") {
[18:02:08.591]                         base::loadNamespace(pkg)
[18:02:08.591]                         base::library(pkg, character.only = TRUE)
[18:02:08.591]                       }
[18:02:08.591]                     })
[18:02:08.591]                   }
[18:02:08.591]                   ...future.strategy.old <- future::plan("list")
[18:02:08.591]                   options(future.plan = NULL)
[18:02:08.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:08.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:08.591]                 }
[18:02:08.591]                 ...future.workdir <- getwd()
[18:02:08.591]             }
[18:02:08.591]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:08.591]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:08.591]         }
[18:02:08.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:08.591]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:08.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:08.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:08.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:08.591]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:08.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:08.591]             base::names(...future.oldOptions))
[18:02:08.591]     }
[18:02:08.591]     if (FALSE) {
[18:02:08.591]     }
[18:02:08.591]     else {
[18:02:08.591]         if (TRUE) {
[18:02:08.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:08.591]                 open = "w")
[18:02:08.591]         }
[18:02:08.591]         else {
[18:02:08.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:08.591]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:08.591]         }
[18:02:08.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:08.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:08.591]             base::sink(type = "output", split = FALSE)
[18:02:08.591]             base::close(...future.stdout)
[18:02:08.591]         }, add = TRUE)
[18:02:08.591]     }
[18:02:08.591]     ...future.frame <- base::sys.nframe()
[18:02:08.591]     ...future.conditions <- base::list()
[18:02:08.591]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:08.591]     if (FALSE) {
[18:02:08.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:08.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:08.591]     }
[18:02:08.591]     ...future.result <- base::tryCatch({
[18:02:08.591]         base::withCallingHandlers({
[18:02:08.591]             ...future.value <- base::withVisible(base::local({
[18:02:08.591]                 ...future.makeSendCondition <- base::local({
[18:02:08.591]                   sendCondition <- NULL
[18:02:08.591]                   function(frame = 1L) {
[18:02:08.591]                     if (is.function(sendCondition)) 
[18:02:08.591]                       return(sendCondition)
[18:02:08.591]                     ns <- getNamespace("parallel")
[18:02:08.591]                     if (exists("sendData", mode = "function", 
[18:02:08.591]                       envir = ns)) {
[18:02:08.591]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:08.591]                         envir = ns)
[18:02:08.591]                       envir <- sys.frame(frame)
[18:02:08.591]                       master <- NULL
[18:02:08.591]                       while (!identical(envir, .GlobalEnv) && 
[18:02:08.591]                         !identical(envir, emptyenv())) {
[18:02:08.591]                         if (exists("master", mode = "list", envir = envir, 
[18:02:08.591]                           inherits = FALSE)) {
[18:02:08.591]                           master <- get("master", mode = "list", 
[18:02:08.591]                             envir = envir, inherits = FALSE)
[18:02:08.591]                           if (inherits(master, c("SOCKnode", 
[18:02:08.591]                             "SOCK0node"))) {
[18:02:08.591]                             sendCondition <<- function(cond) {
[18:02:08.591]                               data <- list(type = "VALUE", value = cond, 
[18:02:08.591]                                 success = TRUE)
[18:02:08.591]                               parallel_sendData(master, data)
[18:02:08.591]                             }
[18:02:08.591]                             return(sendCondition)
[18:02:08.591]                           }
[18:02:08.591]                         }
[18:02:08.591]                         frame <- frame + 1L
[18:02:08.591]                         envir <- sys.frame(frame)
[18:02:08.591]                       }
[18:02:08.591]                     }
[18:02:08.591]                     sendCondition <<- function(cond) NULL
[18:02:08.591]                   }
[18:02:08.591]                 })
[18:02:08.591]                 withCallingHandlers({
[18:02:08.591]                   {
[18:02:08.591]                     do.call(function(...) {
[18:02:08.591]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.591]                       if (!identical(...future.globals.maxSize.org, 
[18:02:08.591]                         ...future.globals.maxSize)) {
[18:02:08.591]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.591]                         on.exit(options(oopts), add = TRUE)
[18:02:08.591]                       }
[18:02:08.591]                       {
[18:02:08.591]                         lapply(seq_along(...future.elements_ii), 
[18:02:08.591]                           FUN = function(jj) {
[18:02:08.591]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.591]                             ...future.FUN(...future.X_jj, ...)
[18:02:08.591]                           })
[18:02:08.591]                       }
[18:02:08.591]                     }, args = future.call.arguments)
[18:02:08.591]                   }
[18:02:08.591]                 }, immediateCondition = function(cond) {
[18:02:08.591]                   sendCondition <- ...future.makeSendCondition()
[18:02:08.591]                   sendCondition(cond)
[18:02:08.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.591]                   {
[18:02:08.591]                     inherits <- base::inherits
[18:02:08.591]                     invokeRestart <- base::invokeRestart
[18:02:08.591]                     is.null <- base::is.null
[18:02:08.591]                     muffled <- FALSE
[18:02:08.591]                     if (inherits(cond, "message")) {
[18:02:08.591]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:08.591]                       if (muffled) 
[18:02:08.591]                         invokeRestart("muffleMessage")
[18:02:08.591]                     }
[18:02:08.591]                     else if (inherits(cond, "warning")) {
[18:02:08.591]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:08.591]                       if (muffled) 
[18:02:08.591]                         invokeRestart("muffleWarning")
[18:02:08.591]                     }
[18:02:08.591]                     else if (inherits(cond, "condition")) {
[18:02:08.591]                       if (!is.null(pattern)) {
[18:02:08.591]                         computeRestarts <- base::computeRestarts
[18:02:08.591]                         grepl <- base::grepl
[18:02:08.591]                         restarts <- computeRestarts(cond)
[18:02:08.591]                         for (restart in restarts) {
[18:02:08.591]                           name <- restart$name
[18:02:08.591]                           if (is.null(name)) 
[18:02:08.591]                             next
[18:02:08.591]                           if (!grepl(pattern, name)) 
[18:02:08.591]                             next
[18:02:08.591]                           invokeRestart(restart)
[18:02:08.591]                           muffled <- TRUE
[18:02:08.591]                           break
[18:02:08.591]                         }
[18:02:08.591]                       }
[18:02:08.591]                     }
[18:02:08.591]                     invisible(muffled)
[18:02:08.591]                   }
[18:02:08.591]                   muffleCondition(cond)
[18:02:08.591]                 })
[18:02:08.591]             }))
[18:02:08.591]             future::FutureResult(value = ...future.value$value, 
[18:02:08.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:08.591]                   ...future.rng), globalenv = if (FALSE) 
[18:02:08.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:08.591]                     ...future.globalenv.names))
[18:02:08.591]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:08.591]         }, condition = base::local({
[18:02:08.591]             c <- base::c
[18:02:08.591]             inherits <- base::inherits
[18:02:08.591]             invokeRestart <- base::invokeRestart
[18:02:08.591]             length <- base::length
[18:02:08.591]             list <- base::list
[18:02:08.591]             seq.int <- base::seq.int
[18:02:08.591]             signalCondition <- base::signalCondition
[18:02:08.591]             sys.calls <- base::sys.calls
[18:02:08.591]             `[[` <- base::`[[`
[18:02:08.591]             `+` <- base::`+`
[18:02:08.591]             `<<-` <- base::`<<-`
[18:02:08.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:08.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:08.591]                   3L)]
[18:02:08.591]             }
[18:02:08.591]             function(cond) {
[18:02:08.591]                 is_error <- inherits(cond, "error")
[18:02:08.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:08.591]                   NULL)
[18:02:08.591]                 if (is_error) {
[18:02:08.591]                   sessionInformation <- function() {
[18:02:08.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:08.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:08.591]                       search = base::search(), system = base::Sys.info())
[18:02:08.591]                   }
[18:02:08.591]                   ...future.conditions[[length(...future.conditions) + 
[18:02:08.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:08.591]                     cond$call), session = sessionInformation(), 
[18:02:08.591]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:08.591]                   signalCondition(cond)
[18:02:08.591]                 }
[18:02:08.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:08.591]                 "immediateCondition"))) {
[18:02:08.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:08.591]                   ...future.conditions[[length(...future.conditions) + 
[18:02:08.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:08.591]                   if (TRUE && !signal) {
[18:02:08.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.591]                     {
[18:02:08.591]                       inherits <- base::inherits
[18:02:08.591]                       invokeRestart <- base::invokeRestart
[18:02:08.591]                       is.null <- base::is.null
[18:02:08.591]                       muffled <- FALSE
[18:02:08.591]                       if (inherits(cond, "message")) {
[18:02:08.591]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:08.591]                         if (muffled) 
[18:02:08.591]                           invokeRestart("muffleMessage")
[18:02:08.591]                       }
[18:02:08.591]                       else if (inherits(cond, "warning")) {
[18:02:08.591]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:08.591]                         if (muffled) 
[18:02:08.591]                           invokeRestart("muffleWarning")
[18:02:08.591]                       }
[18:02:08.591]                       else if (inherits(cond, "condition")) {
[18:02:08.591]                         if (!is.null(pattern)) {
[18:02:08.591]                           computeRestarts <- base::computeRestarts
[18:02:08.591]                           grepl <- base::grepl
[18:02:08.591]                           restarts <- computeRestarts(cond)
[18:02:08.591]                           for (restart in restarts) {
[18:02:08.591]                             name <- restart$name
[18:02:08.591]                             if (is.null(name)) 
[18:02:08.591]                               next
[18:02:08.591]                             if (!grepl(pattern, name)) 
[18:02:08.591]                               next
[18:02:08.591]                             invokeRestart(restart)
[18:02:08.591]                             muffled <- TRUE
[18:02:08.591]                             break
[18:02:08.591]                           }
[18:02:08.591]                         }
[18:02:08.591]                       }
[18:02:08.591]                       invisible(muffled)
[18:02:08.591]                     }
[18:02:08.591]                     muffleCondition(cond, pattern = "^muffle")
[18:02:08.591]                   }
[18:02:08.591]                 }
[18:02:08.591]                 else {
[18:02:08.591]                   if (TRUE) {
[18:02:08.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.591]                     {
[18:02:08.591]                       inherits <- base::inherits
[18:02:08.591]                       invokeRestart <- base::invokeRestart
[18:02:08.591]                       is.null <- base::is.null
[18:02:08.591]                       muffled <- FALSE
[18:02:08.591]                       if (inherits(cond, "message")) {
[18:02:08.591]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:08.591]                         if (muffled) 
[18:02:08.591]                           invokeRestart("muffleMessage")
[18:02:08.591]                       }
[18:02:08.591]                       else if (inherits(cond, "warning")) {
[18:02:08.591]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:08.591]                         if (muffled) 
[18:02:08.591]                           invokeRestart("muffleWarning")
[18:02:08.591]                       }
[18:02:08.591]                       else if (inherits(cond, "condition")) {
[18:02:08.591]                         if (!is.null(pattern)) {
[18:02:08.591]                           computeRestarts <- base::computeRestarts
[18:02:08.591]                           grepl <- base::grepl
[18:02:08.591]                           restarts <- computeRestarts(cond)
[18:02:08.591]                           for (restart in restarts) {
[18:02:08.591]                             name <- restart$name
[18:02:08.591]                             if (is.null(name)) 
[18:02:08.591]                               next
[18:02:08.591]                             if (!grepl(pattern, name)) 
[18:02:08.591]                               next
[18:02:08.591]                             invokeRestart(restart)
[18:02:08.591]                             muffled <- TRUE
[18:02:08.591]                             break
[18:02:08.591]                           }
[18:02:08.591]                         }
[18:02:08.591]                       }
[18:02:08.591]                       invisible(muffled)
[18:02:08.591]                     }
[18:02:08.591]                     muffleCondition(cond, pattern = "^muffle")
[18:02:08.591]                   }
[18:02:08.591]                 }
[18:02:08.591]             }
[18:02:08.591]         }))
[18:02:08.591]     }, error = function(ex) {
[18:02:08.591]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:08.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:08.591]                 ...future.rng), started = ...future.startTime, 
[18:02:08.591]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:08.591]             version = "1.8"), class = "FutureResult")
[18:02:08.591]     }, finally = {
[18:02:08.591]         if (!identical(...future.workdir, getwd())) 
[18:02:08.591]             setwd(...future.workdir)
[18:02:08.591]         {
[18:02:08.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:08.591]                 ...future.oldOptions$nwarnings <- NULL
[18:02:08.591]             }
[18:02:08.591]             base::options(...future.oldOptions)
[18:02:08.591]             if (.Platform$OS.type == "windows") {
[18:02:08.591]                 old_names <- names(...future.oldEnvVars)
[18:02:08.591]                 envs <- base::Sys.getenv()
[18:02:08.591]                 names <- names(envs)
[18:02:08.591]                 common <- intersect(names, old_names)
[18:02:08.591]                 added <- setdiff(names, old_names)
[18:02:08.591]                 removed <- setdiff(old_names, names)
[18:02:08.591]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:08.591]                   envs[common]]
[18:02:08.591]                 NAMES <- toupper(changed)
[18:02:08.591]                 args <- list()
[18:02:08.591]                 for (kk in seq_along(NAMES)) {
[18:02:08.591]                   name <- changed[[kk]]
[18:02:08.591]                   NAME <- NAMES[[kk]]
[18:02:08.591]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.591]                     next
[18:02:08.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:08.591]                 }
[18:02:08.591]                 NAMES <- toupper(added)
[18:02:08.591]                 for (kk in seq_along(NAMES)) {
[18:02:08.591]                   name <- added[[kk]]
[18:02:08.591]                   NAME <- NAMES[[kk]]
[18:02:08.591]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.591]                     next
[18:02:08.591]                   args[[name]] <- ""
[18:02:08.591]                 }
[18:02:08.591]                 NAMES <- toupper(removed)
[18:02:08.591]                 for (kk in seq_along(NAMES)) {
[18:02:08.591]                   name <- removed[[kk]]
[18:02:08.591]                   NAME <- NAMES[[kk]]
[18:02:08.591]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.591]                     next
[18:02:08.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:08.591]                 }
[18:02:08.591]                 if (length(args) > 0) 
[18:02:08.591]                   base::do.call(base::Sys.setenv, args = args)
[18:02:08.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:08.591]             }
[18:02:08.591]             else {
[18:02:08.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:08.591]             }
[18:02:08.591]             {
[18:02:08.591]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:08.591]                   0L) {
[18:02:08.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:08.591]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:08.591]                   base::options(opts)
[18:02:08.591]                 }
[18:02:08.591]                 {
[18:02:08.591]                   {
[18:02:08.591]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:08.591]                     NULL
[18:02:08.591]                   }
[18:02:08.591]                   options(future.plan = NULL)
[18:02:08.591]                   if (is.na(NA_character_)) 
[18:02:08.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:08.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:08.591]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:08.591]                     .init = FALSE)
[18:02:08.591]                 }
[18:02:08.591]             }
[18:02:08.591]         }
[18:02:08.591]     })
[18:02:08.591]     if (TRUE) {
[18:02:08.591]         base::sink(type = "output", split = FALSE)
[18:02:08.591]         if (TRUE) {
[18:02:08.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:08.591]         }
[18:02:08.591]         else {
[18:02:08.591]             ...future.result["stdout"] <- base::list(NULL)
[18:02:08.591]         }
[18:02:08.591]         base::close(...future.stdout)
[18:02:08.591]         ...future.stdout <- NULL
[18:02:08.591]     }
[18:02:08.591]     ...future.result$conditions <- ...future.conditions
[18:02:08.591]     ...future.result$finished <- base::Sys.time()
[18:02:08.591]     ...future.result
[18:02:08.591] }
[18:02:08.597] Exporting 11 global objects (96.29 KiB) to cluster node #2 ...
[18:02:08.597] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[18:02:08.640] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[18:02:08.641] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ...
[18:02:08.642] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ... DONE
[18:02:08.642] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[18:02:08.643] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[18:02:08.644] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[18:02:08.685] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[18:02:08.686] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[18:02:08.727] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[18:02:08.728] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[18:02:08.729] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[18:02:08.729] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[18:02:08.731] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[18:02:08.731] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[18:02:08.732] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[18:02:08.733] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[18:02:08.734] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[18:02:08.735] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:08.736] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:08.736] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:08.737] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:08.738] Exporting 11 global objects (96.29 KiB) to cluster node #2 ... DONE
[18:02:08.739] MultisessionFuture started
[18:02:08.740] - Launch lazy future ... done
[18:02:08.740] run() for ‘MultisessionFuture’ ... done
[18:02:08.740] Created future:
[18:02:08.741] MultisessionFuture:
[18:02:08.741] Label: ‘future_vapply-2’
[18:02:08.741] Expression:
[18:02:08.741] {
[18:02:08.741]     do.call(function(...) {
[18:02:08.741]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.741]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:08.741]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.741]             on.exit(options(oopts), add = TRUE)
[18:02:08.741]         }
[18:02:08.741]         {
[18:02:08.741]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:08.741]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.741]                 ...future.FUN(...future.X_jj, ...)
[18:02:08.741]             })
[18:02:08.741]         }
[18:02:08.741]     }, args = future.call.arguments)
[18:02:08.741] }
[18:02:08.741] Lazy evaluation: FALSE
[18:02:08.741] Asynchronous evaluation: TRUE
[18:02:08.741] Local evaluation: TRUE
[18:02:08.741] Environment: R_GlobalEnv
[18:02:08.741] Capture standard output: TRUE
[18:02:08.741] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:08.741] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:08.741] Packages: 1 packages (‘future.apply’)
[18:02:08.741] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:08.741] Resolved: FALSE
[18:02:08.741] Value: <not collected>
[18:02:08.741] Conditions captured: <none>
[18:02:08.741] Early signaling: FALSE
[18:02:08.741] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:08.741] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:08.756] Chunk #2 of 2 ... DONE
[18:02:08.756] Launching 2 futures (chunks) ... DONE
[18:02:08.757] Resolving 2 futures (chunks) ...
[18:02:08.757] resolve() on list ...
[18:02:08.757]  recursive: 0
[18:02:08.758]  length: 2
[18:02:08.758] 
[18:02:08.759] receiveMessageFromWorker() for ClusterFuture ...
[18:02:08.760] - Validating connection of MultisessionFuture
[18:02:08.760] - received message: FutureResult
[18:02:08.761] - Received FutureResult
[18:02:08.761] - Erased future from FutureRegistry
[18:02:08.761] result() for ClusterFuture ...
[18:02:08.762] - result already collected: FutureResult
[18:02:08.762] result() for ClusterFuture ... done
[18:02:08.762] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:08.762] Future #1
[18:02:08.763] result() for ClusterFuture ...
[18:02:08.763] - result already collected: FutureResult
[18:02:08.763] result() for ClusterFuture ... done
[18:02:08.764] result() for ClusterFuture ...
[18:02:08.764] - result already collected: FutureResult
[18:02:08.764] result() for ClusterFuture ... done
[18:02:08.765] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:08.765] - nx: 2
[18:02:08.765] - relay: TRUE
[18:02:08.766] - stdout: TRUE
[18:02:08.766] - signal: TRUE
[18:02:08.766] - resignal: FALSE
[18:02:08.766] - force: TRUE
[18:02:08.767] - relayed: [n=2] FALSE, FALSE
[18:02:08.767] - queued futures: [n=2] FALSE, FALSE
[18:02:08.767]  - until=1
[18:02:08.768]  - relaying element #1
[18:02:08.768] result() for ClusterFuture ...
[18:02:08.768] - result already collected: FutureResult
[18:02:08.769] result() for ClusterFuture ... done
[18:02:08.769] result() for ClusterFuture ...
[18:02:08.769] - result already collected: FutureResult
[18:02:08.769] result() for ClusterFuture ... done
[18:02:08.770] result() for ClusterFuture ...
[18:02:08.770] - result already collected: FutureResult
[18:02:08.771] result() for ClusterFuture ... done
[18:02:08.771] result() for ClusterFuture ...
[18:02:08.771] - result already collected: FutureResult
[18:02:08.771] result() for ClusterFuture ... done
[18:02:08.772] - relayed: [n=2] TRUE, FALSE
[18:02:08.772] - queued futures: [n=2] TRUE, FALSE
[18:02:08.772] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:08.773]  length: 1 (resolved future 1)
[18:02:08.784] receiveMessageFromWorker() for ClusterFuture ...
[18:02:08.784] - Validating connection of MultisessionFuture
[18:02:08.785] - received message: FutureResult
[18:02:08.785] - Received FutureResult
[18:02:08.786] - Erased future from FutureRegistry
[18:02:08.786] result() for ClusterFuture ...
[18:02:08.786] - result already collected: FutureResult
[18:02:08.787] result() for ClusterFuture ... done
[18:02:08.787] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:08.787] Future #2
[18:02:08.788] result() for ClusterFuture ...
[18:02:08.788] - result already collected: FutureResult
[18:02:08.788] result() for ClusterFuture ... done
[18:02:08.789] result() for ClusterFuture ...
[18:02:08.789] - result already collected: FutureResult
[18:02:08.789] result() for ClusterFuture ... done
[18:02:08.790] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:08.790] - nx: 2
[18:02:08.790] - relay: TRUE
[18:02:08.790] - stdout: TRUE
[18:02:08.791] - signal: TRUE
[18:02:08.791] - resignal: FALSE
[18:02:08.791] - force: TRUE
[18:02:08.792] - relayed: [n=2] TRUE, FALSE
[18:02:08.792] - queued futures: [n=2] TRUE, FALSE
[18:02:08.792]  - until=2
[18:02:08.793]  - relaying element #2
[18:02:08.793] result() for ClusterFuture ...
[18:02:08.793] - result already collected: FutureResult
[18:02:08.793] result() for ClusterFuture ... done
[18:02:08.794] result() for ClusterFuture ...
[18:02:08.794] - result already collected: FutureResult
[18:02:08.794] result() for ClusterFuture ... done
[18:02:08.795] result() for ClusterFuture ...
[18:02:08.795] - result already collected: FutureResult
[18:02:08.795] result() for ClusterFuture ... done
[18:02:08.796] result() for ClusterFuture ...
[18:02:08.796] - result already collected: FutureResult
[18:02:08.796] result() for ClusterFuture ... done
[18:02:08.797] - relayed: [n=2] TRUE, TRUE
[18:02:08.797] - queued futures: [n=2] TRUE, TRUE
[18:02:08.797] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:08.797]  length: 0 (resolved future 2)
[18:02:08.798] Relaying remaining futures
[18:02:08.798] signalConditionsASAP(NULL, pos=0) ...
[18:02:08.798] - nx: 2
[18:02:08.799] - relay: TRUE
[18:02:08.799] - stdout: TRUE
[18:02:08.799] - signal: TRUE
[18:02:08.799] - resignal: FALSE
[18:02:08.800] - force: TRUE
[18:02:08.800] - relayed: [n=2] TRUE, TRUE
[18:02:08.800] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:08.801] - relayed: [n=2] TRUE, TRUE
[18:02:08.801] - queued futures: [n=2] TRUE, TRUE
[18:02:08.801] signalConditionsASAP(NULL, pos=0) ... done
[18:02:08.802] resolve() on list ... DONE
[18:02:08.802] result() for ClusterFuture ...
[18:02:08.802] - result already collected: FutureResult
[18:02:08.803] result() for ClusterFuture ... done
[18:02:08.803] result() for ClusterFuture ...
[18:02:08.803] - result already collected: FutureResult
[18:02:08.803] result() for ClusterFuture ... done
[18:02:08.804] result() for ClusterFuture ...
[18:02:08.804] - result already collected: FutureResult
[18:02:08.804] result() for ClusterFuture ... done
[18:02:08.805] result() for ClusterFuture ...
[18:02:08.805] - result already collected: FutureResult
[18:02:08.805] result() for ClusterFuture ... done
[18:02:08.806]  - Number of value chunks collected: 2
[18:02:08.806] Resolving 2 futures (chunks) ... DONE
[18:02:08.806] Reducing values from 2 chunks ...
[18:02:08.807]  - Number of values collected after concatenation: 4
[18:02:08.807]  - Number of values expected: 4
[18:02:08.807] Reducing values from 2 chunks ... DONE
[18:02:08.808] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[18:02:08.813] future_lapply() ...
[18:02:08.826] Number of chunks: 2
[18:02:08.826] getGlobalsAndPackagesXApply() ...
[18:02:08.826]  - future.globals: TRUE
[18:02:08.827] getGlobalsAndPackages() ...
[18:02:08.827] Searching for globals...
[18:02:08.836] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:02:08.836] Searching for globals ... DONE
[18:02:08.837] Resolving globals: FALSE
[18:02:08.839] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[18:02:08.840] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:08.841] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:08.841] - packages: [1] ‘future.apply’
[18:02:08.841] getGlobalsAndPackages() ... DONE
[18:02:08.842]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:08.842]  - needed namespaces: [n=1] ‘future.apply’
[18:02:08.842] Finding globals ... DONE
[18:02:08.842]  - use_args: TRUE
[18:02:08.843]  - Getting '...' globals ...
[18:02:08.844] resolve() on list ...
[18:02:08.844]  recursive: 0
[18:02:08.844]  length: 1
[18:02:08.844]  elements: ‘...’
[18:02:08.845]  length: 0 (resolved future 1)
[18:02:08.845] resolve() on list ... DONE
[18:02:08.845]    - '...' content: [n=0] 
[18:02:08.846] List of 1
[18:02:08.846]  $ ...: list()
[18:02:08.846]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:08.846]  - attr(*, "where")=List of 1
[18:02:08.846]   ..$ ...:<environment: 0x6183c265fce8> 
[18:02:08.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:08.846]  - attr(*, "resolved")= logi TRUE
[18:02:08.846]  - attr(*, "total_size")= num NA
[18:02:08.852]  - Getting '...' globals ... DONE
[18:02:08.853] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:08.853] List of 8
[18:02:08.853]  $ ...future.FUN:function (x, ...)  
[18:02:08.853]  $ x_FUN        :function (x)  
[18:02:08.853]  $ times        : int 1
[18:02:08.853]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:08.853]  $ stop_if_not  :function (...)  
[18:02:08.853]  $ dim          : NULL
[18:02:08.853]  $ valid_types  : chr "logical"
[18:02:08.853]  $ ...          : list()
[18:02:08.853]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:08.853]  - attr(*, "where")=List of 8
[18:02:08.853]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:08.853]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:08.853]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:08.853]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:08.853]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:08.853]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:08.853]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:08.853]   ..$ ...          :<environment: 0x6183c265fce8> 
[18:02:08.853]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:08.853]  - attr(*, "resolved")= logi FALSE
[18:02:08.853]  - attr(*, "total_size")= num 94200
[18:02:08.867] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:08.867] getGlobalsAndPackagesXApply() ... DONE
[18:02:08.868] Number of futures (= number of chunks): 2
[18:02:08.868] Launching 2 futures (chunks) ...
[18:02:08.868] Chunk #1 of 2 ...
[18:02:08.868]  - Finding globals in 'X' for chunk #1 ...
[18:02:08.869] getGlobalsAndPackages() ...
[18:02:08.869] Searching for globals...
[18:02:08.870] 
[18:02:08.870] Searching for globals ... DONE
[18:02:08.870] - globals: [0] <none>
[18:02:08.870] getGlobalsAndPackages() ... DONE
[18:02:08.870]    + additional globals found: [n=0] 
[18:02:08.871]    + additional namespaces needed: [n=0] 
[18:02:08.871]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:08.871]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:08.871]  - seeds: <none>
[18:02:08.872]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.872] getGlobalsAndPackages() ...
[18:02:08.872] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.872] Resolving globals: FALSE
[18:02:08.873] Tweak future expression to call with '...' arguments ...
[18:02:08.873] {
[18:02:08.873]     do.call(function(...) {
[18:02:08.873]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.873]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:08.873]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.873]             on.exit(options(oopts), add = TRUE)
[18:02:08.873]         }
[18:02:08.873]         {
[18:02:08.873]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:08.873]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.873]                 ...future.FUN(...future.X_jj, ...)
[18:02:08.873]             })
[18:02:08.873]         }
[18:02:08.873]     }, args = future.call.arguments)
[18:02:08.873] }
[18:02:08.874] Tweak future expression to call with '...' arguments ... DONE
[18:02:08.875] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:08.875] - packages: [1] ‘future.apply’
[18:02:08.875] getGlobalsAndPackages() ... DONE
[18:02:08.876] run() for ‘Future’ ...
[18:02:08.876] - state: ‘created’
[18:02:08.877] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:08.901] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:08.902] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:08.902]   - Field: ‘node’
[18:02:08.902]   - Field: ‘label’
[18:02:08.902]   - Field: ‘local’
[18:02:08.903]   - Field: ‘owner’
[18:02:08.903]   - Field: ‘envir’
[18:02:08.903]   - Field: ‘workers’
[18:02:08.903]   - Field: ‘packages’
[18:02:08.903]   - Field: ‘gc’
[18:02:08.904]   - Field: ‘conditions’
[18:02:08.904]   - Field: ‘persistent’
[18:02:08.904]   - Field: ‘expr’
[18:02:08.904]   - Field: ‘uuid’
[18:02:08.904]   - Field: ‘seed’
[18:02:08.905]   - Field: ‘version’
[18:02:08.905]   - Field: ‘result’
[18:02:08.905]   - Field: ‘asynchronous’
[18:02:08.905]   - Field: ‘calls’
[18:02:08.905]   - Field: ‘globals’
[18:02:08.905]   - Field: ‘stdout’
[18:02:08.906]   - Field: ‘earlySignal’
[18:02:08.906]   - Field: ‘lazy’
[18:02:08.906]   - Field: ‘state’
[18:02:08.906] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:08.906] - Launch lazy future ...
[18:02:08.907] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:08.907] Packages needed by future strategies (n = 0): <none>
[18:02:08.908] {
[18:02:08.908]     {
[18:02:08.908]         {
[18:02:08.908]             ...future.startTime <- base::Sys.time()
[18:02:08.908]             {
[18:02:08.908]                 {
[18:02:08.908]                   {
[18:02:08.908]                     {
[18:02:08.908]                       {
[18:02:08.908]                         base::local({
[18:02:08.908]                           has_future <- base::requireNamespace("future", 
[18:02:08.908]                             quietly = TRUE)
[18:02:08.908]                           if (has_future) {
[18:02:08.908]                             ns <- base::getNamespace("future")
[18:02:08.908]                             version <- ns[[".package"]][["version"]]
[18:02:08.908]                             if (is.null(version)) 
[18:02:08.908]                               version <- utils::packageVersion("future")
[18:02:08.908]                           }
[18:02:08.908]                           else {
[18:02:08.908]                             version <- NULL
[18:02:08.908]                           }
[18:02:08.908]                           if (!has_future || version < "1.8.0") {
[18:02:08.908]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:08.908]                               "", base::R.version$version.string), 
[18:02:08.908]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:08.908]                                 base::R.version$platform, 8 * 
[18:02:08.908]                                   base::.Machine$sizeof.pointer), 
[18:02:08.908]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:08.908]                                 "release", "version")], collapse = " "), 
[18:02:08.908]                               hostname = base::Sys.info()[["nodename"]])
[18:02:08.908]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:08.908]                               info)
[18:02:08.908]                             info <- base::paste(info, collapse = "; ")
[18:02:08.908]                             if (!has_future) {
[18:02:08.908]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:08.908]                                 info)
[18:02:08.908]                             }
[18:02:08.908]                             else {
[18:02:08.908]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:08.908]                                 info, version)
[18:02:08.908]                             }
[18:02:08.908]                             base::stop(msg)
[18:02:08.908]                           }
[18:02:08.908]                         })
[18:02:08.908]                       }
[18:02:08.908]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:08.908]                       base::options(mc.cores = 1L)
[18:02:08.908]                     }
[18:02:08.908]                     base::local({
[18:02:08.908]                       for (pkg in "future.apply") {
[18:02:08.908]                         base::loadNamespace(pkg)
[18:02:08.908]                         base::library(pkg, character.only = TRUE)
[18:02:08.908]                       }
[18:02:08.908]                     })
[18:02:08.908]                   }
[18:02:08.908]                   ...future.strategy.old <- future::plan("list")
[18:02:08.908]                   options(future.plan = NULL)
[18:02:08.908]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:08.908]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:08.908]                 }
[18:02:08.908]                 ...future.workdir <- getwd()
[18:02:08.908]             }
[18:02:08.908]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:08.908]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:08.908]         }
[18:02:08.908]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:08.908]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:08.908]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:08.908]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:08.908]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:08.908]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:08.908]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:08.908]             base::names(...future.oldOptions))
[18:02:08.908]     }
[18:02:08.908]     if (FALSE) {
[18:02:08.908]     }
[18:02:08.908]     else {
[18:02:08.908]         if (TRUE) {
[18:02:08.908]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:08.908]                 open = "w")
[18:02:08.908]         }
[18:02:08.908]         else {
[18:02:08.908]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:08.908]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:08.908]         }
[18:02:08.908]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:08.908]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:08.908]             base::sink(type = "output", split = FALSE)
[18:02:08.908]             base::close(...future.stdout)
[18:02:08.908]         }, add = TRUE)
[18:02:08.908]     }
[18:02:08.908]     ...future.frame <- base::sys.nframe()
[18:02:08.908]     ...future.conditions <- base::list()
[18:02:08.908]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:08.908]     if (FALSE) {
[18:02:08.908]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:08.908]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:08.908]     }
[18:02:08.908]     ...future.result <- base::tryCatch({
[18:02:08.908]         base::withCallingHandlers({
[18:02:08.908]             ...future.value <- base::withVisible(base::local({
[18:02:08.908]                 ...future.makeSendCondition <- base::local({
[18:02:08.908]                   sendCondition <- NULL
[18:02:08.908]                   function(frame = 1L) {
[18:02:08.908]                     if (is.function(sendCondition)) 
[18:02:08.908]                       return(sendCondition)
[18:02:08.908]                     ns <- getNamespace("parallel")
[18:02:08.908]                     if (exists("sendData", mode = "function", 
[18:02:08.908]                       envir = ns)) {
[18:02:08.908]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:08.908]                         envir = ns)
[18:02:08.908]                       envir <- sys.frame(frame)
[18:02:08.908]                       master <- NULL
[18:02:08.908]                       while (!identical(envir, .GlobalEnv) && 
[18:02:08.908]                         !identical(envir, emptyenv())) {
[18:02:08.908]                         if (exists("master", mode = "list", envir = envir, 
[18:02:08.908]                           inherits = FALSE)) {
[18:02:08.908]                           master <- get("master", mode = "list", 
[18:02:08.908]                             envir = envir, inherits = FALSE)
[18:02:08.908]                           if (inherits(master, c("SOCKnode", 
[18:02:08.908]                             "SOCK0node"))) {
[18:02:08.908]                             sendCondition <<- function(cond) {
[18:02:08.908]                               data <- list(type = "VALUE", value = cond, 
[18:02:08.908]                                 success = TRUE)
[18:02:08.908]                               parallel_sendData(master, data)
[18:02:08.908]                             }
[18:02:08.908]                             return(sendCondition)
[18:02:08.908]                           }
[18:02:08.908]                         }
[18:02:08.908]                         frame <- frame + 1L
[18:02:08.908]                         envir <- sys.frame(frame)
[18:02:08.908]                       }
[18:02:08.908]                     }
[18:02:08.908]                     sendCondition <<- function(cond) NULL
[18:02:08.908]                   }
[18:02:08.908]                 })
[18:02:08.908]                 withCallingHandlers({
[18:02:08.908]                   {
[18:02:08.908]                     do.call(function(...) {
[18:02:08.908]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:08.908]                       if (!identical(...future.globals.maxSize.org, 
[18:02:08.908]                         ...future.globals.maxSize)) {
[18:02:08.908]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:08.908]                         on.exit(options(oopts), add = TRUE)
[18:02:08.908]                       }
[18:02:08.908]                       {
[18:02:08.908]                         lapply(seq_along(...future.elements_ii), 
[18:02:08.908]                           FUN = function(jj) {
[18:02:08.908]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:08.908]                             ...future.FUN(...future.X_jj, ...)
[18:02:08.908]                           })
[18:02:08.908]                       }
[18:02:08.908]                     }, args = future.call.arguments)
[18:02:08.908]                   }
[18:02:08.908]                 }, immediateCondition = function(cond) {
[18:02:08.908]                   sendCondition <- ...future.makeSendCondition()
[18:02:08.908]                   sendCondition(cond)
[18:02:08.908]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.908]                   {
[18:02:08.908]                     inherits <- base::inherits
[18:02:08.908]                     invokeRestart <- base::invokeRestart
[18:02:08.908]                     is.null <- base::is.null
[18:02:08.908]                     muffled <- FALSE
[18:02:08.908]                     if (inherits(cond, "message")) {
[18:02:08.908]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:08.908]                       if (muffled) 
[18:02:08.908]                         invokeRestart("muffleMessage")
[18:02:08.908]                     }
[18:02:08.908]                     else if (inherits(cond, "warning")) {
[18:02:08.908]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:08.908]                       if (muffled) 
[18:02:08.908]                         invokeRestart("muffleWarning")
[18:02:08.908]                     }
[18:02:08.908]                     else if (inherits(cond, "condition")) {
[18:02:08.908]                       if (!is.null(pattern)) {
[18:02:08.908]                         computeRestarts <- base::computeRestarts
[18:02:08.908]                         grepl <- base::grepl
[18:02:08.908]                         restarts <- computeRestarts(cond)
[18:02:08.908]                         for (restart in restarts) {
[18:02:08.908]                           name <- restart$name
[18:02:08.908]                           if (is.null(name)) 
[18:02:08.908]                             next
[18:02:08.908]                           if (!grepl(pattern, name)) 
[18:02:08.908]                             next
[18:02:08.908]                           invokeRestart(restart)
[18:02:08.908]                           muffled <- TRUE
[18:02:08.908]                           break
[18:02:08.908]                         }
[18:02:08.908]                       }
[18:02:08.908]                     }
[18:02:08.908]                     invisible(muffled)
[18:02:08.908]                   }
[18:02:08.908]                   muffleCondition(cond)
[18:02:08.908]                 })
[18:02:08.908]             }))
[18:02:08.908]             future::FutureResult(value = ...future.value$value, 
[18:02:08.908]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:08.908]                   ...future.rng), globalenv = if (FALSE) 
[18:02:08.908]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:08.908]                     ...future.globalenv.names))
[18:02:08.908]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:08.908]         }, condition = base::local({
[18:02:08.908]             c <- base::c
[18:02:08.908]             inherits <- base::inherits
[18:02:08.908]             invokeRestart <- base::invokeRestart
[18:02:08.908]             length <- base::length
[18:02:08.908]             list <- base::list
[18:02:08.908]             seq.int <- base::seq.int
[18:02:08.908]             signalCondition <- base::signalCondition
[18:02:08.908]             sys.calls <- base::sys.calls
[18:02:08.908]             `[[` <- base::`[[`
[18:02:08.908]             `+` <- base::`+`
[18:02:08.908]             `<<-` <- base::`<<-`
[18:02:08.908]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:08.908]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:08.908]                   3L)]
[18:02:08.908]             }
[18:02:08.908]             function(cond) {
[18:02:08.908]                 is_error <- inherits(cond, "error")
[18:02:08.908]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:08.908]                   NULL)
[18:02:08.908]                 if (is_error) {
[18:02:08.908]                   sessionInformation <- function() {
[18:02:08.908]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:08.908]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:08.908]                       search = base::search(), system = base::Sys.info())
[18:02:08.908]                   }
[18:02:08.908]                   ...future.conditions[[length(...future.conditions) + 
[18:02:08.908]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:08.908]                     cond$call), session = sessionInformation(), 
[18:02:08.908]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:08.908]                   signalCondition(cond)
[18:02:08.908]                 }
[18:02:08.908]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:08.908]                 "immediateCondition"))) {
[18:02:08.908]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:08.908]                   ...future.conditions[[length(...future.conditions) + 
[18:02:08.908]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:08.908]                   if (TRUE && !signal) {
[18:02:08.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.908]                     {
[18:02:08.908]                       inherits <- base::inherits
[18:02:08.908]                       invokeRestart <- base::invokeRestart
[18:02:08.908]                       is.null <- base::is.null
[18:02:08.908]                       muffled <- FALSE
[18:02:08.908]                       if (inherits(cond, "message")) {
[18:02:08.908]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:08.908]                         if (muffled) 
[18:02:08.908]                           invokeRestart("muffleMessage")
[18:02:08.908]                       }
[18:02:08.908]                       else if (inherits(cond, "warning")) {
[18:02:08.908]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:08.908]                         if (muffled) 
[18:02:08.908]                           invokeRestart("muffleWarning")
[18:02:08.908]                       }
[18:02:08.908]                       else if (inherits(cond, "condition")) {
[18:02:08.908]                         if (!is.null(pattern)) {
[18:02:08.908]                           computeRestarts <- base::computeRestarts
[18:02:08.908]                           grepl <- base::grepl
[18:02:08.908]                           restarts <- computeRestarts(cond)
[18:02:08.908]                           for (restart in restarts) {
[18:02:08.908]                             name <- restart$name
[18:02:08.908]                             if (is.null(name)) 
[18:02:08.908]                               next
[18:02:08.908]                             if (!grepl(pattern, name)) 
[18:02:08.908]                               next
[18:02:08.908]                             invokeRestart(restart)
[18:02:08.908]                             muffled <- TRUE
[18:02:08.908]                             break
[18:02:08.908]                           }
[18:02:08.908]                         }
[18:02:08.908]                       }
[18:02:08.908]                       invisible(muffled)
[18:02:08.908]                     }
[18:02:08.908]                     muffleCondition(cond, pattern = "^muffle")
[18:02:08.908]                   }
[18:02:08.908]                 }
[18:02:08.908]                 else {
[18:02:08.908]                   if (TRUE) {
[18:02:08.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:08.908]                     {
[18:02:08.908]                       inherits <- base::inherits
[18:02:08.908]                       invokeRestart <- base::invokeRestart
[18:02:08.908]                       is.null <- base::is.null
[18:02:08.908]                       muffled <- FALSE
[18:02:08.908]                       if (inherits(cond, "message")) {
[18:02:08.908]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:08.908]                         if (muffled) 
[18:02:08.908]                           invokeRestart("muffleMessage")
[18:02:08.908]                       }
[18:02:08.908]                       else if (inherits(cond, "warning")) {
[18:02:08.908]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:08.908]                         if (muffled) 
[18:02:08.908]                           invokeRestart("muffleWarning")
[18:02:08.908]                       }
[18:02:08.908]                       else if (inherits(cond, "condition")) {
[18:02:08.908]                         if (!is.null(pattern)) {
[18:02:08.908]                           computeRestarts <- base::computeRestarts
[18:02:08.908]                           grepl <- base::grepl
[18:02:08.908]                           restarts <- computeRestarts(cond)
[18:02:08.908]                           for (restart in restarts) {
[18:02:08.908]                             name <- restart$name
[18:02:08.908]                             if (is.null(name)) 
[18:02:08.908]                               next
[18:02:08.908]                             if (!grepl(pattern, name)) 
[18:02:08.908]                               next
[18:02:08.908]                             invokeRestart(restart)
[18:02:08.908]                             muffled <- TRUE
[18:02:08.908]                             break
[18:02:08.908]                           }
[18:02:08.908]                         }
[18:02:08.908]                       }
[18:02:08.908]                       invisible(muffled)
[18:02:08.908]                     }
[18:02:08.908]                     muffleCondition(cond, pattern = "^muffle")
[18:02:08.908]                   }
[18:02:08.908]                 }
[18:02:08.908]             }
[18:02:08.908]         }))
[18:02:08.908]     }, error = function(ex) {
[18:02:08.908]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:08.908]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:08.908]                 ...future.rng), started = ...future.startTime, 
[18:02:08.908]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:08.908]             version = "1.8"), class = "FutureResult")
[18:02:08.908]     }, finally = {
[18:02:08.908]         if (!identical(...future.workdir, getwd())) 
[18:02:08.908]             setwd(...future.workdir)
[18:02:08.908]         {
[18:02:08.908]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:08.908]                 ...future.oldOptions$nwarnings <- NULL
[18:02:08.908]             }
[18:02:08.908]             base::options(...future.oldOptions)
[18:02:08.908]             if (.Platform$OS.type == "windows") {
[18:02:08.908]                 old_names <- names(...future.oldEnvVars)
[18:02:08.908]                 envs <- base::Sys.getenv()
[18:02:08.908]                 names <- names(envs)
[18:02:08.908]                 common <- intersect(names, old_names)
[18:02:08.908]                 added <- setdiff(names, old_names)
[18:02:08.908]                 removed <- setdiff(old_names, names)
[18:02:08.908]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:08.908]                   envs[common]]
[18:02:08.908]                 NAMES <- toupper(changed)
[18:02:08.908]                 args <- list()
[18:02:08.908]                 for (kk in seq_along(NAMES)) {
[18:02:08.908]                   name <- changed[[kk]]
[18:02:08.908]                   NAME <- NAMES[[kk]]
[18:02:08.908]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.908]                     next
[18:02:08.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:08.908]                 }
[18:02:08.908]                 NAMES <- toupper(added)
[18:02:08.908]                 for (kk in seq_along(NAMES)) {
[18:02:08.908]                   name <- added[[kk]]
[18:02:08.908]                   NAME <- NAMES[[kk]]
[18:02:08.908]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.908]                     next
[18:02:08.908]                   args[[name]] <- ""
[18:02:08.908]                 }
[18:02:08.908]                 NAMES <- toupper(removed)
[18:02:08.908]                 for (kk in seq_along(NAMES)) {
[18:02:08.908]                   name <- removed[[kk]]
[18:02:08.908]                   NAME <- NAMES[[kk]]
[18:02:08.908]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:08.908]                     next
[18:02:08.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:08.908]                 }
[18:02:08.908]                 if (length(args) > 0) 
[18:02:08.908]                   base::do.call(base::Sys.setenv, args = args)
[18:02:08.908]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:08.908]             }
[18:02:08.908]             else {
[18:02:08.908]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:08.908]             }
[18:02:08.908]             {
[18:02:08.908]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:08.908]                   0L) {
[18:02:08.908]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:08.908]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:08.908]                   base::options(opts)
[18:02:08.908]                 }
[18:02:08.908]                 {
[18:02:08.908]                   {
[18:02:08.908]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:08.908]                     NULL
[18:02:08.908]                   }
[18:02:08.908]                   options(future.plan = NULL)
[18:02:08.908]                   if (is.na(NA_character_)) 
[18:02:08.908]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:08.908]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:08.908]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:08.908]                     .init = FALSE)
[18:02:08.908]                 }
[18:02:08.908]             }
[18:02:08.908]         }
[18:02:08.908]     })
[18:02:08.908]     if (TRUE) {
[18:02:08.908]         base::sink(type = "output", split = FALSE)
[18:02:08.908]         if (TRUE) {
[18:02:08.908]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:08.908]         }
[18:02:08.908]         else {
[18:02:08.908]             ...future.result["stdout"] <- base::list(NULL)
[18:02:08.908]         }
[18:02:08.908]         base::close(...future.stdout)
[18:02:08.908]         ...future.stdout <- NULL
[18:02:08.908]     }
[18:02:08.908]     ...future.result$conditions <- ...future.conditions
[18:02:08.908]     ...future.result$finished <- base::Sys.time()
[18:02:08.908]     ...future.result
[18:02:08.908] }
[18:02:08.913] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[18:02:08.914] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[18:02:08.955] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[18:02:08.956] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[18:02:08.957] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[18:02:08.957] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[18:02:08.958] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[18:02:08.958] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[18:02:08.999] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[18:02:09.000] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[18:02:09.046] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[18:02:09.046] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[18:02:09.047] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[18:02:09.048] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[18:02:09.049] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[18:02:09.050] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:09.051] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:09.052] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ...
[18:02:09.053] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ... DONE
[18:02:09.053] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:09.054] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:09.055] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:09.056] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:09.056] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[18:02:09.058] MultisessionFuture started
[18:02:09.058] - Launch lazy future ... done
[18:02:09.059] run() for ‘MultisessionFuture’ ... done
[18:02:09.059] Created future:
[18:02:09.059] MultisessionFuture:
[18:02:09.059] Label: ‘future_vapply-1’
[18:02:09.059] Expression:
[18:02:09.059] {
[18:02:09.059]     do.call(function(...) {
[18:02:09.059]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:09.059]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:09.059]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:09.059]             on.exit(options(oopts), add = TRUE)
[18:02:09.059]         }
[18:02:09.059]         {
[18:02:09.059]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:09.059]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:09.059]                 ...future.FUN(...future.X_jj, ...)
[18:02:09.059]             })
[18:02:09.059]         }
[18:02:09.059]     }, args = future.call.arguments)
[18:02:09.059] }
[18:02:09.059] Lazy evaluation: FALSE
[18:02:09.059] Asynchronous evaluation: TRUE
[18:02:09.059] Local evaluation: TRUE
[18:02:09.059] Environment: R_GlobalEnv
[18:02:09.059] Capture standard output: TRUE
[18:02:09.059] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:09.059] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:09.059] Packages: 1 packages (‘future.apply’)
[18:02:09.059] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:09.059] Resolved: FALSE
[18:02:09.059] Value: <not collected>
[18:02:09.059] Conditions captured: <none>
[18:02:09.059] Early signaling: FALSE
[18:02:09.059] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:09.059] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:09.074] Chunk #1 of 2 ... DONE
[18:02:09.075] Chunk #2 of 2 ...
[18:02:09.075]  - Finding globals in 'X' for chunk #2 ...
[18:02:09.075] getGlobalsAndPackages() ...
[18:02:09.076] Searching for globals...
[18:02:09.077] 
[18:02:09.077] Searching for globals ... DONE
[18:02:09.077] - globals: [0] <none>
[18:02:09.077] getGlobalsAndPackages() ... DONE
[18:02:09.078]    + additional globals found: [n=0] 
[18:02:09.078]    + additional namespaces needed: [n=0] 
[18:02:09.078]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:09.079]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:09.079]  - seeds: <none>
[18:02:09.079]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:09.080] getGlobalsAndPackages() ...
[18:02:09.080] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:09.080] Resolving globals: FALSE
[18:02:09.081] Tweak future expression to call with '...' arguments ...
[18:02:09.081] {
[18:02:09.081]     do.call(function(...) {
[18:02:09.081]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:09.081]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:09.081]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:09.081]             on.exit(options(oopts), add = TRUE)
[18:02:09.081]         }
[18:02:09.081]         {
[18:02:09.081]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:09.081]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:09.081]                 ...future.FUN(...future.X_jj, ...)
[18:02:09.081]             })
[18:02:09.081]         }
[18:02:09.081]     }, args = future.call.arguments)
[18:02:09.081] }
[18:02:09.082] Tweak future expression to call with '...' arguments ... DONE
[18:02:09.084] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:09.084] - packages: [1] ‘future.apply’
[18:02:09.084] getGlobalsAndPackages() ... DONE
[18:02:09.085] run() for ‘Future’ ...
[18:02:09.086] - state: ‘created’
[18:02:09.086] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:09.114] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:09.114] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:09.114]   - Field: ‘node’
[18:02:09.115]   - Field: ‘label’
[18:02:09.115]   - Field: ‘local’
[18:02:09.115]   - Field: ‘owner’
[18:02:09.115]   - Field: ‘envir’
[18:02:09.116]   - Field: ‘workers’
[18:02:09.116]   - Field: ‘packages’
[18:02:09.116]   - Field: ‘gc’
[18:02:09.116]   - Field: ‘conditions’
[18:02:09.117]   - Field: ‘persistent’
[18:02:09.117]   - Field: ‘expr’
[18:02:09.117]   - Field: ‘uuid’
[18:02:09.117]   - Field: ‘seed’
[18:02:09.118]   - Field: ‘version’
[18:02:09.118]   - Field: ‘result’
[18:02:09.118]   - Field: ‘asynchronous’
[18:02:09.119]   - Field: ‘calls’
[18:02:09.119]   - Field: ‘globals’
[18:02:09.119]   - Field: ‘stdout’
[18:02:09.119]   - Field: ‘earlySignal’
[18:02:09.120]   - Field: ‘lazy’
[18:02:09.120]   - Field: ‘state’
[18:02:09.120] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:09.120] - Launch lazy future ...
[18:02:09.121] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:09.121] Packages needed by future strategies (n = 0): <none>
[18:02:09.123] {
[18:02:09.123]     {
[18:02:09.123]         {
[18:02:09.123]             ...future.startTime <- base::Sys.time()
[18:02:09.123]             {
[18:02:09.123]                 {
[18:02:09.123]                   {
[18:02:09.123]                     {
[18:02:09.123]                       {
[18:02:09.123]                         base::local({
[18:02:09.123]                           has_future <- base::requireNamespace("future", 
[18:02:09.123]                             quietly = TRUE)
[18:02:09.123]                           if (has_future) {
[18:02:09.123]                             ns <- base::getNamespace("future")
[18:02:09.123]                             version <- ns[[".package"]][["version"]]
[18:02:09.123]                             if (is.null(version)) 
[18:02:09.123]                               version <- utils::packageVersion("future")
[18:02:09.123]                           }
[18:02:09.123]                           else {
[18:02:09.123]                             version <- NULL
[18:02:09.123]                           }
[18:02:09.123]                           if (!has_future || version < "1.8.0") {
[18:02:09.123]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:09.123]                               "", base::R.version$version.string), 
[18:02:09.123]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:09.123]                                 base::R.version$platform, 8 * 
[18:02:09.123]                                   base::.Machine$sizeof.pointer), 
[18:02:09.123]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:09.123]                                 "release", "version")], collapse = " "), 
[18:02:09.123]                               hostname = base::Sys.info()[["nodename"]])
[18:02:09.123]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:09.123]                               info)
[18:02:09.123]                             info <- base::paste(info, collapse = "; ")
[18:02:09.123]                             if (!has_future) {
[18:02:09.123]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:09.123]                                 info)
[18:02:09.123]                             }
[18:02:09.123]                             else {
[18:02:09.123]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:09.123]                                 info, version)
[18:02:09.123]                             }
[18:02:09.123]                             base::stop(msg)
[18:02:09.123]                           }
[18:02:09.123]                         })
[18:02:09.123]                       }
[18:02:09.123]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:09.123]                       base::options(mc.cores = 1L)
[18:02:09.123]                     }
[18:02:09.123]                     base::local({
[18:02:09.123]                       for (pkg in "future.apply") {
[18:02:09.123]                         base::loadNamespace(pkg)
[18:02:09.123]                         base::library(pkg, character.only = TRUE)
[18:02:09.123]                       }
[18:02:09.123]                     })
[18:02:09.123]                   }
[18:02:09.123]                   ...future.strategy.old <- future::plan("list")
[18:02:09.123]                   options(future.plan = NULL)
[18:02:09.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:09.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:09.123]                 }
[18:02:09.123]                 ...future.workdir <- getwd()
[18:02:09.123]             }
[18:02:09.123]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:09.123]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:09.123]         }
[18:02:09.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:09.123]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:09.123]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:09.123]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:09.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:09.123]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:09.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:09.123]             base::names(...future.oldOptions))
[18:02:09.123]     }
[18:02:09.123]     if (FALSE) {
[18:02:09.123]     }
[18:02:09.123]     else {
[18:02:09.123]         if (TRUE) {
[18:02:09.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:09.123]                 open = "w")
[18:02:09.123]         }
[18:02:09.123]         else {
[18:02:09.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:09.123]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:09.123]         }
[18:02:09.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:09.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:09.123]             base::sink(type = "output", split = FALSE)
[18:02:09.123]             base::close(...future.stdout)
[18:02:09.123]         }, add = TRUE)
[18:02:09.123]     }
[18:02:09.123]     ...future.frame <- base::sys.nframe()
[18:02:09.123]     ...future.conditions <- base::list()
[18:02:09.123]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:09.123]     if (FALSE) {
[18:02:09.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:09.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:09.123]     }
[18:02:09.123]     ...future.result <- base::tryCatch({
[18:02:09.123]         base::withCallingHandlers({
[18:02:09.123]             ...future.value <- base::withVisible(base::local({
[18:02:09.123]                 ...future.makeSendCondition <- base::local({
[18:02:09.123]                   sendCondition <- NULL
[18:02:09.123]                   function(frame = 1L) {
[18:02:09.123]                     if (is.function(sendCondition)) 
[18:02:09.123]                       return(sendCondition)
[18:02:09.123]                     ns <- getNamespace("parallel")
[18:02:09.123]                     if (exists("sendData", mode = "function", 
[18:02:09.123]                       envir = ns)) {
[18:02:09.123]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:09.123]                         envir = ns)
[18:02:09.123]                       envir <- sys.frame(frame)
[18:02:09.123]                       master <- NULL
[18:02:09.123]                       while (!identical(envir, .GlobalEnv) && 
[18:02:09.123]                         !identical(envir, emptyenv())) {
[18:02:09.123]                         if (exists("master", mode = "list", envir = envir, 
[18:02:09.123]                           inherits = FALSE)) {
[18:02:09.123]                           master <- get("master", mode = "list", 
[18:02:09.123]                             envir = envir, inherits = FALSE)
[18:02:09.123]                           if (inherits(master, c("SOCKnode", 
[18:02:09.123]                             "SOCK0node"))) {
[18:02:09.123]                             sendCondition <<- function(cond) {
[18:02:09.123]                               data <- list(type = "VALUE", value = cond, 
[18:02:09.123]                                 success = TRUE)
[18:02:09.123]                               parallel_sendData(master, data)
[18:02:09.123]                             }
[18:02:09.123]                             return(sendCondition)
[18:02:09.123]                           }
[18:02:09.123]                         }
[18:02:09.123]                         frame <- frame + 1L
[18:02:09.123]                         envir <- sys.frame(frame)
[18:02:09.123]                       }
[18:02:09.123]                     }
[18:02:09.123]                     sendCondition <<- function(cond) NULL
[18:02:09.123]                   }
[18:02:09.123]                 })
[18:02:09.123]                 withCallingHandlers({
[18:02:09.123]                   {
[18:02:09.123]                     do.call(function(...) {
[18:02:09.123]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:09.123]                       if (!identical(...future.globals.maxSize.org, 
[18:02:09.123]                         ...future.globals.maxSize)) {
[18:02:09.123]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:09.123]                         on.exit(options(oopts), add = TRUE)
[18:02:09.123]                       }
[18:02:09.123]                       {
[18:02:09.123]                         lapply(seq_along(...future.elements_ii), 
[18:02:09.123]                           FUN = function(jj) {
[18:02:09.123]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:09.123]                             ...future.FUN(...future.X_jj, ...)
[18:02:09.123]                           })
[18:02:09.123]                       }
[18:02:09.123]                     }, args = future.call.arguments)
[18:02:09.123]                   }
[18:02:09.123]                 }, immediateCondition = function(cond) {
[18:02:09.123]                   sendCondition <- ...future.makeSendCondition()
[18:02:09.123]                   sendCondition(cond)
[18:02:09.123]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:09.123]                   {
[18:02:09.123]                     inherits <- base::inherits
[18:02:09.123]                     invokeRestart <- base::invokeRestart
[18:02:09.123]                     is.null <- base::is.null
[18:02:09.123]                     muffled <- FALSE
[18:02:09.123]                     if (inherits(cond, "message")) {
[18:02:09.123]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:09.123]                       if (muffled) 
[18:02:09.123]                         invokeRestart("muffleMessage")
[18:02:09.123]                     }
[18:02:09.123]                     else if (inherits(cond, "warning")) {
[18:02:09.123]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:09.123]                       if (muffled) 
[18:02:09.123]                         invokeRestart("muffleWarning")
[18:02:09.123]                     }
[18:02:09.123]                     else if (inherits(cond, "condition")) {
[18:02:09.123]                       if (!is.null(pattern)) {
[18:02:09.123]                         computeRestarts <- base::computeRestarts
[18:02:09.123]                         grepl <- base::grepl
[18:02:09.123]                         restarts <- computeRestarts(cond)
[18:02:09.123]                         for (restart in restarts) {
[18:02:09.123]                           name <- restart$name
[18:02:09.123]                           if (is.null(name)) 
[18:02:09.123]                             next
[18:02:09.123]                           if (!grepl(pattern, name)) 
[18:02:09.123]                             next
[18:02:09.123]                           invokeRestart(restart)
[18:02:09.123]                           muffled <- TRUE
[18:02:09.123]                           break
[18:02:09.123]                         }
[18:02:09.123]                       }
[18:02:09.123]                     }
[18:02:09.123]                     invisible(muffled)
[18:02:09.123]                   }
[18:02:09.123]                   muffleCondition(cond)
[18:02:09.123]                 })
[18:02:09.123]             }))
[18:02:09.123]             future::FutureResult(value = ...future.value$value, 
[18:02:09.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:09.123]                   ...future.rng), globalenv = if (FALSE) 
[18:02:09.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:09.123]                     ...future.globalenv.names))
[18:02:09.123]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:09.123]         }, condition = base::local({
[18:02:09.123]             c <- base::c
[18:02:09.123]             inherits <- base::inherits
[18:02:09.123]             invokeRestart <- base::invokeRestart
[18:02:09.123]             length <- base::length
[18:02:09.123]             list <- base::list
[18:02:09.123]             seq.int <- base::seq.int
[18:02:09.123]             signalCondition <- base::signalCondition
[18:02:09.123]             sys.calls <- base::sys.calls
[18:02:09.123]             `[[` <- base::`[[`
[18:02:09.123]             `+` <- base::`+`
[18:02:09.123]             `<<-` <- base::`<<-`
[18:02:09.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:09.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:09.123]                   3L)]
[18:02:09.123]             }
[18:02:09.123]             function(cond) {
[18:02:09.123]                 is_error <- inherits(cond, "error")
[18:02:09.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:09.123]                   NULL)
[18:02:09.123]                 if (is_error) {
[18:02:09.123]                   sessionInformation <- function() {
[18:02:09.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:09.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:09.123]                       search = base::search(), system = base::Sys.info())
[18:02:09.123]                   }
[18:02:09.123]                   ...future.conditions[[length(...future.conditions) + 
[18:02:09.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:09.123]                     cond$call), session = sessionInformation(), 
[18:02:09.123]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:09.123]                   signalCondition(cond)
[18:02:09.123]                 }
[18:02:09.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:09.123]                 "immediateCondition"))) {
[18:02:09.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:09.123]                   ...future.conditions[[length(...future.conditions) + 
[18:02:09.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:09.123]                   if (TRUE && !signal) {
[18:02:09.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:09.123]                     {
[18:02:09.123]                       inherits <- base::inherits
[18:02:09.123]                       invokeRestart <- base::invokeRestart
[18:02:09.123]                       is.null <- base::is.null
[18:02:09.123]                       muffled <- FALSE
[18:02:09.123]                       if (inherits(cond, "message")) {
[18:02:09.123]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:09.123]                         if (muffled) 
[18:02:09.123]                           invokeRestart("muffleMessage")
[18:02:09.123]                       }
[18:02:09.123]                       else if (inherits(cond, "warning")) {
[18:02:09.123]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:09.123]                         if (muffled) 
[18:02:09.123]                           invokeRestart("muffleWarning")
[18:02:09.123]                       }
[18:02:09.123]                       else if (inherits(cond, "condition")) {
[18:02:09.123]                         if (!is.null(pattern)) {
[18:02:09.123]                           computeRestarts <- base::computeRestarts
[18:02:09.123]                           grepl <- base::grepl
[18:02:09.123]                           restarts <- computeRestarts(cond)
[18:02:09.123]                           for (restart in restarts) {
[18:02:09.123]                             name <- restart$name
[18:02:09.123]                             if (is.null(name)) 
[18:02:09.123]                               next
[18:02:09.123]                             if (!grepl(pattern, name)) 
[18:02:09.123]                               next
[18:02:09.123]                             invokeRestart(restart)
[18:02:09.123]                             muffled <- TRUE
[18:02:09.123]                             break
[18:02:09.123]                           }
[18:02:09.123]                         }
[18:02:09.123]                       }
[18:02:09.123]                       invisible(muffled)
[18:02:09.123]                     }
[18:02:09.123]                     muffleCondition(cond, pattern = "^muffle")
[18:02:09.123]                   }
[18:02:09.123]                 }
[18:02:09.123]                 else {
[18:02:09.123]                   if (TRUE) {
[18:02:09.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:09.123]                     {
[18:02:09.123]                       inherits <- base::inherits
[18:02:09.123]                       invokeRestart <- base::invokeRestart
[18:02:09.123]                       is.null <- base::is.null
[18:02:09.123]                       muffled <- FALSE
[18:02:09.123]                       if (inherits(cond, "message")) {
[18:02:09.123]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:09.123]                         if (muffled) 
[18:02:09.123]                           invokeRestart("muffleMessage")
[18:02:09.123]                       }
[18:02:09.123]                       else if (inherits(cond, "warning")) {
[18:02:09.123]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:09.123]                         if (muffled) 
[18:02:09.123]                           invokeRestart("muffleWarning")
[18:02:09.123]                       }
[18:02:09.123]                       else if (inherits(cond, "condition")) {
[18:02:09.123]                         if (!is.null(pattern)) {
[18:02:09.123]                           computeRestarts <- base::computeRestarts
[18:02:09.123]                           grepl <- base::grepl
[18:02:09.123]                           restarts <- computeRestarts(cond)
[18:02:09.123]                           for (restart in restarts) {
[18:02:09.123]                             name <- restart$name
[18:02:09.123]                             if (is.null(name)) 
[18:02:09.123]                               next
[18:02:09.123]                             if (!grepl(pattern, name)) 
[18:02:09.123]                               next
[18:02:09.123]                             invokeRestart(restart)
[18:02:09.123]                             muffled <- TRUE
[18:02:09.123]                             break
[18:02:09.123]                           }
[18:02:09.123]                         }
[18:02:09.123]                       }
[18:02:09.123]                       invisible(muffled)
[18:02:09.123]                     }
[18:02:09.123]                     muffleCondition(cond, pattern = "^muffle")
[18:02:09.123]                   }
[18:02:09.123]                 }
[18:02:09.123]             }
[18:02:09.123]         }))
[18:02:09.123]     }, error = function(ex) {
[18:02:09.123]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:09.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:09.123]                 ...future.rng), started = ...future.startTime, 
[18:02:09.123]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:09.123]             version = "1.8"), class = "FutureResult")
[18:02:09.123]     }, finally = {
[18:02:09.123]         if (!identical(...future.workdir, getwd())) 
[18:02:09.123]             setwd(...future.workdir)
[18:02:09.123]         {
[18:02:09.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:09.123]                 ...future.oldOptions$nwarnings <- NULL
[18:02:09.123]             }
[18:02:09.123]             base::options(...future.oldOptions)
[18:02:09.123]             if (.Platform$OS.type == "windows") {
[18:02:09.123]                 old_names <- names(...future.oldEnvVars)
[18:02:09.123]                 envs <- base::Sys.getenv()
[18:02:09.123]                 names <- names(envs)
[18:02:09.123]                 common <- intersect(names, old_names)
[18:02:09.123]                 added <- setdiff(names, old_names)
[18:02:09.123]                 removed <- setdiff(old_names, names)
[18:02:09.123]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:09.123]                   envs[common]]
[18:02:09.123]                 NAMES <- toupper(changed)
[18:02:09.123]                 args <- list()
[18:02:09.123]                 for (kk in seq_along(NAMES)) {
[18:02:09.123]                   name <- changed[[kk]]
[18:02:09.123]                   NAME <- NAMES[[kk]]
[18:02:09.123]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:09.123]                     next
[18:02:09.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:09.123]                 }
[18:02:09.123]                 NAMES <- toupper(added)
[18:02:09.123]                 for (kk in seq_along(NAMES)) {
[18:02:09.123]                   name <- added[[kk]]
[18:02:09.123]                   NAME <- NAMES[[kk]]
[18:02:09.123]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:09.123]                     next
[18:02:09.123]                   args[[name]] <- ""
[18:02:09.123]                 }
[18:02:09.123]                 NAMES <- toupper(removed)
[18:02:09.123]                 for (kk in seq_along(NAMES)) {
[18:02:09.123]                   name <- removed[[kk]]
[18:02:09.123]                   NAME <- NAMES[[kk]]
[18:02:09.123]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:09.123]                     next
[18:02:09.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:09.123]                 }
[18:02:09.123]                 if (length(args) > 0) 
[18:02:09.123]                   base::do.call(base::Sys.setenv, args = args)
[18:02:09.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:09.123]             }
[18:02:09.123]             else {
[18:02:09.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:09.123]             }
[18:02:09.123]             {
[18:02:09.123]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:09.123]                   0L) {
[18:02:09.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:09.123]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:09.123]                   base::options(opts)
[18:02:09.123]                 }
[18:02:09.123]                 {
[18:02:09.123]                   {
[18:02:09.123]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:09.123]                     NULL
[18:02:09.123]                   }
[18:02:09.123]                   options(future.plan = NULL)
[18:02:09.123]                   if (is.na(NA_character_)) 
[18:02:09.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:09.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:09.123]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:09.123]                     .init = FALSE)
[18:02:09.123]                 }
[18:02:09.123]             }
[18:02:09.123]         }
[18:02:09.123]     })
[18:02:09.123]     if (TRUE) {
[18:02:09.123]         base::sink(type = "output", split = FALSE)
[18:02:09.123]         if (TRUE) {
[18:02:09.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:09.123]         }
[18:02:09.123]         else {
[18:02:09.123]             ...future.result["stdout"] <- base::list(NULL)
[18:02:09.123]         }
[18:02:09.123]         base::close(...future.stdout)
[18:02:09.123]         ...future.stdout <- NULL
[18:02:09.123]     }
[18:02:09.123]     ...future.result$conditions <- ...future.conditions
[18:02:09.123]     ...future.result$finished <- base::Sys.time()
[18:02:09.123]     ...future.result
[18:02:09.123] }
[18:02:09.129] Exporting 11 global objects (91.99 KiB) to cluster node #2 ...
[18:02:09.130] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[18:02:09.172] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[18:02:09.172] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[18:02:09.173] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[18:02:09.174] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[18:02:09.175] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[18:02:09.175] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[18:02:09.217] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[18:02:09.218] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[18:02:09.259] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[18:02:09.260] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[18:02:09.261] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[18:02:09.262] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ...
[18:02:09.263] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ... DONE
[18:02:09.264] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:09.265] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:09.265] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ...
[18:02:09.266] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ... DONE
[18:02:09.267] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:09.268] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:09.269] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:09.270] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:09.270] Exporting 11 global objects (91.99 KiB) to cluster node #2 ... DONE
[18:02:09.272] MultisessionFuture started
[18:02:09.272] - Launch lazy future ... done
[18:02:09.272] run() for ‘MultisessionFuture’ ... done
[18:02:09.273] Created future:
[18:02:09.273] MultisessionFuture:
[18:02:09.273] Label: ‘future_vapply-2’
[18:02:09.273] Expression:
[18:02:09.273] {
[18:02:09.273]     do.call(function(...) {
[18:02:09.273]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:09.273]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:09.273]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:09.273]             on.exit(options(oopts), add = TRUE)
[18:02:09.273]         }
[18:02:09.273]         {
[18:02:09.273]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:09.273]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:09.273]                 ...future.FUN(...future.X_jj, ...)
[18:02:09.273]             })
[18:02:09.273]         }
[18:02:09.273]     }, args = future.call.arguments)
[18:02:09.273] }
[18:02:09.273] Lazy evaluation: FALSE
[18:02:09.273] Asynchronous evaluation: TRUE
[18:02:09.273] Local evaluation: TRUE
[18:02:09.273] Environment: R_GlobalEnv
[18:02:09.273] Capture standard output: TRUE
[18:02:09.273] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:09.273] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:09.273] Packages: 1 packages (‘future.apply’)
[18:02:09.273] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:09.273] Resolved: FALSE
[18:02:09.273] Value: <not collected>
[18:02:09.273] Conditions captured: <none>
[18:02:09.273] Early signaling: FALSE
[18:02:09.273] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:09.273] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:09.288] Chunk #2 of 2 ... DONE
[18:02:09.288] Launching 2 futures (chunks) ... DONE
[18:02:09.289] Resolving 2 futures (chunks) ...
[18:02:09.289] resolve() on list ...
[18:02:09.289]  recursive: 0
[18:02:09.290]  length: 2
[18:02:09.290] 
[18:02:09.291] receiveMessageFromWorker() for ClusterFuture ...
[18:02:09.292] - Validating connection of MultisessionFuture
[18:02:09.292] - received message: FutureResult
[18:02:09.293] - Received FutureResult
[18:02:09.293] - Erased future from FutureRegistry
[18:02:09.293] result() for ClusterFuture ...
[18:02:09.294] - result already collected: FutureResult
[18:02:09.294] result() for ClusterFuture ... done
[18:02:09.294] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:09.295] Future #1
[18:02:09.295] result() for ClusterFuture ...
[18:02:09.295] - result already collected: FutureResult
[18:02:09.295] result() for ClusterFuture ... done
[18:02:09.296] result() for ClusterFuture ...
[18:02:09.296] - result already collected: FutureResult
[18:02:09.296] result() for ClusterFuture ... done
[18:02:09.297] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:09.297] - nx: 2
[18:02:09.297] - relay: TRUE
[18:02:09.298] - stdout: TRUE
[18:02:09.298] - signal: TRUE
[18:02:09.298] - resignal: FALSE
[18:02:09.298] - force: TRUE
[18:02:09.299] - relayed: [n=2] FALSE, FALSE
[18:02:09.299] - queued futures: [n=2] FALSE, FALSE
[18:02:09.299]  - until=1
[18:02:09.300]  - relaying element #1
[18:02:09.300] result() for ClusterFuture ...
[18:02:09.300] - result already collected: FutureResult
[18:02:09.301] result() for ClusterFuture ... done
[18:02:09.301] result() for ClusterFuture ...
[18:02:09.301] - result already collected: FutureResult
[18:02:09.301] result() for ClusterFuture ... done
[18:02:09.302] result() for ClusterFuture ...
[18:02:09.302] - result already collected: FutureResult
[18:02:09.303] result() for ClusterFuture ... done
[18:02:09.303] result() for ClusterFuture ...
[18:02:09.303] - result already collected: FutureResult
[18:02:09.303] result() for ClusterFuture ... done
[18:02:09.304] - relayed: [n=2] TRUE, FALSE
[18:02:09.304] - queued futures: [n=2] TRUE, FALSE
[18:02:09.304] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:09.305]  length: 1 (resolved future 1)
[18:02:09.316] receiveMessageFromWorker() for ClusterFuture ...
[18:02:09.316] - Validating connection of MultisessionFuture
[18:02:09.317] - received message: FutureResult
[18:02:09.317] - Received FutureResult
[18:02:09.318] - Erased future from FutureRegistry
[18:02:09.318] result() for ClusterFuture ...
[18:02:09.318] - result already collected: FutureResult
[18:02:09.319] result() for ClusterFuture ... done
[18:02:09.319] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:09.319] Future #2
[18:02:09.320] result() for ClusterFuture ...
[18:02:09.320] - result already collected: FutureResult
[18:02:09.320] result() for ClusterFuture ... done
[18:02:09.321] result() for ClusterFuture ...
[18:02:09.321] - result already collected: FutureResult
[18:02:09.321] result() for ClusterFuture ... done
[18:02:09.322] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:09.322] - nx: 2
[18:02:09.322] - relay: TRUE
[18:02:09.323] - stdout: TRUE
[18:02:09.323] - signal: TRUE
[18:02:09.323] - resignal: FALSE
[18:02:09.323] - force: TRUE
[18:02:09.324] - relayed: [n=2] TRUE, FALSE
[18:02:09.324] - queued futures: [n=2] TRUE, FALSE
[18:02:09.324]  - until=2
[18:02:09.325]  - relaying element #2
[18:02:09.325] result() for ClusterFuture ...
[18:02:09.325] - result already collected: FutureResult
[18:02:09.326] result() for ClusterFuture ... done
[18:02:09.326] result() for ClusterFuture ...
[18:02:09.326] - result already collected: FutureResult
[18:02:09.326] result() for ClusterFuture ... done
[18:02:09.327] result() for ClusterFuture ...
[18:02:09.327] - result already collected: FutureResult
[18:02:09.327] result() for ClusterFuture ... done
[18:02:09.328] result() for ClusterFuture ...
[18:02:09.328] - result already collected: FutureResult
[18:02:09.328] result() for ClusterFuture ... done
[18:02:09.329] - relayed: [n=2] TRUE, TRUE
[18:02:09.329] - queued futures: [n=2] TRUE, TRUE
[18:02:09.329] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:09.330]  length: 0 (resolved future 2)
[18:02:09.330] Relaying remaining futures
[18:02:09.330] signalConditionsASAP(NULL, pos=0) ...
[18:02:09.330] - nx: 2
[18:02:09.331] - relay: TRUE
[18:02:09.331] - stdout: TRUE
[18:02:09.331] - signal: TRUE
[18:02:09.332] - resignal: FALSE
[18:02:09.332] - force: TRUE
[18:02:09.332] - relayed: [n=2] TRUE, TRUE
[18:02:09.332] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:09.333] - relayed: [n=2] TRUE, TRUE
[18:02:09.333] - queued futures: [n=2] TRUE, TRUE
[18:02:09.334] signalConditionsASAP(NULL, pos=0) ... done
[18:02:09.334] resolve() on list ... DONE
[18:02:09.334] result() for ClusterFuture ...
[18:02:09.334] - result already collected: FutureResult
[18:02:09.335] result() for ClusterFuture ... done
[18:02:09.335] result() for ClusterFuture ...
[18:02:09.335] - result already collected: FutureResult
[18:02:09.336] result() for ClusterFuture ... done
[18:02:09.336] result() for ClusterFuture ...
[18:02:09.336] - result already collected: FutureResult
[18:02:09.337] result() for ClusterFuture ... done
[18:02:09.337] result() for ClusterFuture ...
[18:02:09.337] - result already collected: FutureResult
[18:02:09.338] result() for ClusterFuture ... done
[18:02:09.338]  - Number of value chunks collected: 2
[18:02:09.338] Resolving 2 futures (chunks) ... DONE
[18:02:09.339] Reducing values from 2 chunks ...
[18:02:09.339]  - Number of values collected after concatenation: 11
[18:02:09.339]  - Number of values expected: 11
[18:02:09.339] Reducing values from 2 chunks ... DONE
[18:02:09.340] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[18:02:09.343] future_lapply() ...
[18:02:09.355] Number of chunks: 2
[18:02:09.355] getGlobalsAndPackagesXApply() ...
[18:02:09.356]  - future.globals: TRUE
[18:02:09.356] getGlobalsAndPackages() ...
[18:02:09.356] Searching for globals...
[18:02:09.363] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:02:09.363] Searching for globals ... DONE
[18:02:09.363] Resolving globals: FALSE
[18:02:09.365] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[18:02:09.366] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:09.366] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:09.367] - packages: [1] ‘future.apply’
[18:02:09.367] getGlobalsAndPackages() ... DONE
[18:02:09.367]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:09.367]  - needed namespaces: [n=1] ‘future.apply’
[18:02:09.368] Finding globals ... DONE
[18:02:09.368]  - use_args: TRUE
[18:02:09.368]  - Getting '...' globals ...
[18:02:09.369] resolve() on list ...
[18:02:09.369]  recursive: 0
[18:02:09.369]  length: 1
[18:02:09.369]  elements: ‘...’
[18:02:09.370]  length: 0 (resolved future 1)
[18:02:09.370] resolve() on list ... DONE
[18:02:09.371]    - '...' content: [n=0] 
[18:02:09.371] List of 1
[18:02:09.371]  $ ...: list()
[18:02:09.371]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:09.371]  - attr(*, "where")=List of 1
[18:02:09.371]   ..$ ...:<environment: 0x6183c32d4e20> 
[18:02:09.371]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:09.371]  - attr(*, "resolved")= logi TRUE
[18:02:09.371]  - attr(*, "total_size")= num NA
[18:02:09.377]  - Getting '...' globals ... DONE
[18:02:09.377] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:09.377] List of 8
[18:02:09.377]  $ ...future.FUN:function (x, ...)  
[18:02:09.377]  $ x_FUN        :function (x)  
[18:02:09.377]  $ times        : int 1
[18:02:09.377]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:09.377]  $ stop_if_not  :function (...)  
[18:02:09.377]  $ dim          : NULL
[18:02:09.377]  $ valid_types  : chr [1:2] "logical" "integer"
[18:02:09.377]  $ ...          : list()
[18:02:09.377]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:09.377]  - attr(*, "where")=List of 8
[18:02:09.377]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:09.377]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:09.377]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:09.377]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:09.377]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:09.377]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:09.377]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:09.377]   ..$ ...          :<environment: 0x6183c32d4e20> 
[18:02:09.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:09.377]  - attr(*, "resolved")= logi FALSE
[18:02:09.377]  - attr(*, "total_size")= num 94264
[18:02:09.388] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:09.389] getGlobalsAndPackagesXApply() ... DONE
[18:02:09.389] Number of futures (= number of chunks): 2
[18:02:09.389] Launching 2 futures (chunks) ...
[18:02:09.390] Chunk #1 of 2 ...
[18:02:09.390]  - Finding globals in 'X' for chunk #1 ...
[18:02:09.390] getGlobalsAndPackages() ...
[18:02:09.390] Searching for globals...
[18:02:09.391] 
[18:02:09.391] Searching for globals ... DONE
[18:02:09.391] - globals: [0] <none>
[18:02:09.391] getGlobalsAndPackages() ... DONE
[18:02:09.392]    + additional globals found: [n=0] 
[18:02:09.392]    + additional namespaces needed: [n=0] 
[18:02:09.392]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:09.392]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:09.392]  - seeds: <none>
[18:02:09.392]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:09.393] getGlobalsAndPackages() ...
[18:02:09.393] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:09.393] Resolving globals: FALSE
[18:02:09.393] Tweak future expression to call with '...' arguments ...
[18:02:09.394] {
[18:02:09.394]     do.call(function(...) {
[18:02:09.394]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:09.394]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:09.394]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:09.394]             on.exit(options(oopts), add = TRUE)
[18:02:09.394]         }
[18:02:09.394]         {
[18:02:09.394]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:09.394]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:09.394]                 ...future.FUN(...future.X_jj, ...)
[18:02:09.394]             })
[18:02:09.394]         }
[18:02:09.394]     }, args = future.call.arguments)
[18:02:09.394] }
[18:02:09.394] Tweak future expression to call with '...' arguments ... DONE
[18:02:09.395] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:09.396] - packages: [1] ‘future.apply’
[18:02:09.396] getGlobalsAndPackages() ... DONE
[18:02:09.396] run() for ‘Future’ ...
[18:02:09.397] - state: ‘created’
[18:02:09.397] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:09.422] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:09.422] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:09.423]   - Field: ‘node’
[18:02:09.423]   - Field: ‘label’
[18:02:09.423]   - Field: ‘local’
[18:02:09.423]   - Field: ‘owner’
[18:02:09.423]   - Field: ‘envir’
[18:02:09.424]   - Field: ‘workers’
[18:02:09.424]   - Field: ‘packages’
[18:02:09.424]   - Field: ‘gc’
[18:02:09.424]   - Field: ‘conditions’
[18:02:09.425]   - Field: ‘persistent’
[18:02:09.425]   - Field: ‘expr’
[18:02:09.425]   - Field: ‘uuid’
[18:02:09.425]   - Field: ‘seed’
[18:02:09.425]   - Field: ‘version’
[18:02:09.426]   - Field: ‘result’
[18:02:09.426]   - Field: ‘asynchronous’
[18:02:09.426]   - Field: ‘calls’
[18:02:09.426]   - Field: ‘globals’
[18:02:09.426]   - Field: ‘stdout’
[18:02:09.427]   - Field: ‘earlySignal’
[18:02:09.427]   - Field: ‘lazy’
[18:02:09.427]   - Field: ‘state’
[18:02:09.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:09.427] - Launch lazy future ...
[18:02:09.428] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:09.428] Packages needed by future strategies (n = 0): <none>
[18:02:09.429] {
[18:02:09.429]     {
[18:02:09.429]         {
[18:02:09.429]             ...future.startTime <- base::Sys.time()
[18:02:09.429]             {
[18:02:09.429]                 {
[18:02:09.429]                   {
[18:02:09.429]                     {
[18:02:09.429]                       {
[18:02:09.429]                         base::local({
[18:02:09.429]                           has_future <- base::requireNamespace("future", 
[18:02:09.429]                             quietly = TRUE)
[18:02:09.429]                           if (has_future) {
[18:02:09.429]                             ns <- base::getNamespace("future")
[18:02:09.429]                             version <- ns[[".package"]][["version"]]
[18:02:09.429]                             if (is.null(version)) 
[18:02:09.429]                               version <- utils::packageVersion("future")
[18:02:09.429]                           }
[18:02:09.429]                           else {
[18:02:09.429]                             version <- NULL
[18:02:09.429]                           }
[18:02:09.429]                           if (!has_future || version < "1.8.0") {
[18:02:09.429]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:09.429]                               "", base::R.version$version.string), 
[18:02:09.429]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:09.429]                                 base::R.version$platform, 8 * 
[18:02:09.429]                                   base::.Machine$sizeof.pointer), 
[18:02:09.429]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:09.429]                                 "release", "version")], collapse = " "), 
[18:02:09.429]                               hostname = base::Sys.info()[["nodename"]])
[18:02:09.429]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:09.429]                               info)
[18:02:09.429]                             info <- base::paste(info, collapse = "; ")
[18:02:09.429]                             if (!has_future) {
[18:02:09.429]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:09.429]                                 info)
[18:02:09.429]                             }
[18:02:09.429]                             else {
[18:02:09.429]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:09.429]                                 info, version)
[18:02:09.429]                             }
[18:02:09.429]                             base::stop(msg)
[18:02:09.429]                           }
[18:02:09.429]                         })
[18:02:09.429]                       }
[18:02:09.429]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:09.429]                       base::options(mc.cores = 1L)
[18:02:09.429]                     }
[18:02:09.429]                     base::local({
[18:02:09.429]                       for (pkg in "future.apply") {
[18:02:09.429]                         base::loadNamespace(pkg)
[18:02:09.429]                         base::library(pkg, character.only = TRUE)
[18:02:09.429]                       }
[18:02:09.429]                     })
[18:02:09.429]                   }
[18:02:09.429]                   ...future.strategy.old <- future::plan("list")
[18:02:09.429]                   options(future.plan = NULL)
[18:02:09.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:09.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:09.429]                 }
[18:02:09.429]                 ...future.workdir <- getwd()
[18:02:09.429]             }
[18:02:09.429]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:09.429]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:09.429]         }
[18:02:09.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:09.429]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:09.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:09.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:09.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:09.429]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:09.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:09.429]             base::names(...future.oldOptions))
[18:02:09.429]     }
[18:02:09.429]     if (FALSE) {
[18:02:09.429]     }
[18:02:09.429]     else {
[18:02:09.429]         if (TRUE) {
[18:02:09.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:09.429]                 open = "w")
[18:02:09.429]         }
[18:02:09.429]         else {
[18:02:09.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:09.429]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:09.429]         }
[18:02:09.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:09.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:09.429]             base::sink(type = "output", split = FALSE)
[18:02:09.429]             base::close(...future.stdout)
[18:02:09.429]         }, add = TRUE)
[18:02:09.429]     }
[18:02:09.429]     ...future.frame <- base::sys.nframe()
[18:02:09.429]     ...future.conditions <- base::list()
[18:02:09.429]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:09.429]     if (FALSE) {
[18:02:09.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:09.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:09.429]     }
[18:02:09.429]     ...future.result <- base::tryCatch({
[18:02:09.429]         base::withCallingHandlers({
[18:02:09.429]             ...future.value <- base::withVisible(base::local({
[18:02:09.429]                 ...future.makeSendCondition <- base::local({
[18:02:09.429]                   sendCondition <- NULL
[18:02:09.429]                   function(frame = 1L) {
[18:02:09.429]                     if (is.function(sendCondition)) 
[18:02:09.429]                       return(sendCondition)
[18:02:09.429]                     ns <- getNamespace("parallel")
[18:02:09.429]                     if (exists("sendData", mode = "function", 
[18:02:09.429]                       envir = ns)) {
[18:02:09.429]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:09.429]                         envir = ns)
[18:02:09.429]                       envir <- sys.frame(frame)
[18:02:09.429]                       master <- NULL
[18:02:09.429]                       while (!identical(envir, .GlobalEnv) && 
[18:02:09.429]                         !identical(envir, emptyenv())) {
[18:02:09.429]                         if (exists("master", mode = "list", envir = envir, 
[18:02:09.429]                           inherits = FALSE)) {
[18:02:09.429]                           master <- get("master", mode = "list", 
[18:02:09.429]                             envir = envir, inherits = FALSE)
[18:02:09.429]                           if (inherits(master, c("SOCKnode", 
[18:02:09.429]                             "SOCK0node"))) {
[18:02:09.429]                             sendCondition <<- function(cond) {
[18:02:09.429]                               data <- list(type = "VALUE", value = cond, 
[18:02:09.429]                                 success = TRUE)
[18:02:09.429]                               parallel_sendData(master, data)
[18:02:09.429]                             }
[18:02:09.429]                             return(sendCondition)
[18:02:09.429]                           }
[18:02:09.429]                         }
[18:02:09.429]                         frame <- frame + 1L
[18:02:09.429]                         envir <- sys.frame(frame)
[18:02:09.429]                       }
[18:02:09.429]                     }
[18:02:09.429]                     sendCondition <<- function(cond) NULL
[18:02:09.429]                   }
[18:02:09.429]                 })
[18:02:09.429]                 withCallingHandlers({
[18:02:09.429]                   {
[18:02:09.429]                     do.call(function(...) {
[18:02:09.429]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:09.429]                       if (!identical(...future.globals.maxSize.org, 
[18:02:09.429]                         ...future.globals.maxSize)) {
[18:02:09.429]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:09.429]                         on.exit(options(oopts), add = TRUE)
[18:02:09.429]                       }
[18:02:09.429]                       {
[18:02:09.429]                         lapply(seq_along(...future.elements_ii), 
[18:02:09.429]                           FUN = function(jj) {
[18:02:09.429]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:09.429]                             ...future.FUN(...future.X_jj, ...)
[18:02:09.429]                           })
[18:02:09.429]                       }
[18:02:09.429]                     }, args = future.call.arguments)
[18:02:09.429]                   }
[18:02:09.429]                 }, immediateCondition = function(cond) {
[18:02:09.429]                   sendCondition <- ...future.makeSendCondition()
[18:02:09.429]                   sendCondition(cond)
[18:02:09.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:09.429]                   {
[18:02:09.429]                     inherits <- base::inherits
[18:02:09.429]                     invokeRestart <- base::invokeRestart
[18:02:09.429]                     is.null <- base::is.null
[18:02:09.429]                     muffled <- FALSE
[18:02:09.429]                     if (inherits(cond, "message")) {
[18:02:09.429]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:09.429]                       if (muffled) 
[18:02:09.429]                         invokeRestart("muffleMessage")
[18:02:09.429]                     }
[18:02:09.429]                     else if (inherits(cond, "warning")) {
[18:02:09.429]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:09.429]                       if (muffled) 
[18:02:09.429]                         invokeRestart("muffleWarning")
[18:02:09.429]                     }
[18:02:09.429]                     else if (inherits(cond, "condition")) {
[18:02:09.429]                       if (!is.null(pattern)) {
[18:02:09.429]                         computeRestarts <- base::computeRestarts
[18:02:09.429]                         grepl <- base::grepl
[18:02:09.429]                         restarts <- computeRestarts(cond)
[18:02:09.429]                         for (restart in restarts) {
[18:02:09.429]                           name <- restart$name
[18:02:09.429]                           if (is.null(name)) 
[18:02:09.429]                             next
[18:02:09.429]                           if (!grepl(pattern, name)) 
[18:02:09.429]                             next
[18:02:09.429]                           invokeRestart(restart)
[18:02:09.429]                           muffled <- TRUE
[18:02:09.429]                           break
[18:02:09.429]                         }
[18:02:09.429]                       }
[18:02:09.429]                     }
[18:02:09.429]                     invisible(muffled)
[18:02:09.429]                   }
[18:02:09.429]                   muffleCondition(cond)
[18:02:09.429]                 })
[18:02:09.429]             }))
[18:02:09.429]             future::FutureResult(value = ...future.value$value, 
[18:02:09.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:09.429]                   ...future.rng), globalenv = if (FALSE) 
[18:02:09.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:09.429]                     ...future.globalenv.names))
[18:02:09.429]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:09.429]         }, condition = base::local({
[18:02:09.429]             c <- base::c
[18:02:09.429]             inherits <- base::inherits
[18:02:09.429]             invokeRestart <- base::invokeRestart
[18:02:09.429]             length <- base::length
[18:02:09.429]             list <- base::list
[18:02:09.429]             seq.int <- base::seq.int
[18:02:09.429]             signalCondition <- base::signalCondition
[18:02:09.429]             sys.calls <- base::sys.calls
[18:02:09.429]             `[[` <- base::`[[`
[18:02:09.429]             `+` <- base::`+`
[18:02:09.429]             `<<-` <- base::`<<-`
[18:02:09.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:09.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:09.429]                   3L)]
[18:02:09.429]             }
[18:02:09.429]             function(cond) {
[18:02:09.429]                 is_error <- inherits(cond, "error")
[18:02:09.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:09.429]                   NULL)
[18:02:09.429]                 if (is_error) {
[18:02:09.429]                   sessionInformation <- function() {
[18:02:09.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:09.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:09.429]                       search = base::search(), system = base::Sys.info())
[18:02:09.429]                   }
[18:02:09.429]                   ...future.conditions[[length(...future.conditions) + 
[18:02:09.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:09.429]                     cond$call), session = sessionInformation(), 
[18:02:09.429]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:09.429]                   signalCondition(cond)
[18:02:09.429]                 }
[18:02:09.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:09.429]                 "immediateCondition"))) {
[18:02:09.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:09.429]                   ...future.conditions[[length(...future.conditions) + 
[18:02:09.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:09.429]                   if (TRUE && !signal) {
[18:02:09.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:09.429]                     {
[18:02:09.429]                       inherits <- base::inherits
[18:02:09.429]                       invokeRestart <- base::invokeRestart
[18:02:09.429]                       is.null <- base::is.null
[18:02:09.429]                       muffled <- FALSE
[18:02:09.429]                       if (inherits(cond, "message")) {
[18:02:09.429]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:09.429]                         if (muffled) 
[18:02:09.429]                           invokeRestart("muffleMessage")
[18:02:09.429]                       }
[18:02:09.429]                       else if (inherits(cond, "warning")) {
[18:02:09.429]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:09.429]                         if (muffled) 
[18:02:09.429]                           invokeRestart("muffleWarning")
[18:02:09.429]                       }
[18:02:09.429]                       else if (inherits(cond, "condition")) {
[18:02:09.429]                         if (!is.null(pattern)) {
[18:02:09.429]                           computeRestarts <- base::computeRestarts
[18:02:09.429]                           grepl <- base::grepl
[18:02:09.429]                           restarts <- computeRestarts(cond)
[18:02:09.429]                           for (restart in restarts) {
[18:02:09.429]                             name <- restart$name
[18:02:09.429]                             if (is.null(name)) 
[18:02:09.429]                               next
[18:02:09.429]                             if (!grepl(pattern, name)) 
[18:02:09.429]                               next
[18:02:09.429]                             invokeRestart(restart)
[18:02:09.429]                             muffled <- TRUE
[18:02:09.429]                             break
[18:02:09.429]                           }
[18:02:09.429]                         }
[18:02:09.429]                       }
[18:02:09.429]                       invisible(muffled)
[18:02:09.429]                     }
[18:02:09.429]                     muffleCondition(cond, pattern = "^muffle")
[18:02:09.429]                   }
[18:02:09.429]                 }
[18:02:09.429]                 else {
[18:02:09.429]                   if (TRUE) {
[18:02:09.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:09.429]                     {
[18:02:09.429]                       inherits <- base::inherits
[18:02:09.429]                       invokeRestart <- base::invokeRestart
[18:02:09.429]                       is.null <- base::is.null
[18:02:09.429]                       muffled <- FALSE
[18:02:09.429]                       if (inherits(cond, "message")) {
[18:02:09.429]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:09.429]                         if (muffled) 
[18:02:09.429]                           invokeRestart("muffleMessage")
[18:02:09.429]                       }
[18:02:09.429]                       else if (inherits(cond, "warning")) {
[18:02:09.429]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:09.429]                         if (muffled) 
[18:02:09.429]                           invokeRestart("muffleWarning")
[18:02:09.429]                       }
[18:02:09.429]                       else if (inherits(cond, "condition")) {
[18:02:09.429]                         if (!is.null(pattern)) {
[18:02:09.429]                           computeRestarts <- base::computeRestarts
[18:02:09.429]                           grepl <- base::grepl
[18:02:09.429]                           restarts <- computeRestarts(cond)
[18:02:09.429]                           for (restart in restarts) {
[18:02:09.429]                             name <- restart$name
[18:02:09.429]                             if (is.null(name)) 
[18:02:09.429]                               next
[18:02:09.429]                             if (!grepl(pattern, name)) 
[18:02:09.429]                               next
[18:02:09.429]                             invokeRestart(restart)
[18:02:09.429]                             muffled <- TRUE
[18:02:09.429]                             break
[18:02:09.429]                           }
[18:02:09.429]                         }
[18:02:09.429]                       }
[18:02:09.429]                       invisible(muffled)
[18:02:09.429]                     }
[18:02:09.429]                     muffleCondition(cond, pattern = "^muffle")
[18:02:09.429]                   }
[18:02:09.429]                 }
[18:02:09.429]             }
[18:02:09.429]         }))
[18:02:09.429]     }, error = function(ex) {
[18:02:09.429]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:09.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:09.429]                 ...future.rng), started = ...future.startTime, 
[18:02:09.429]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:09.429]             version = "1.8"), class = "FutureResult")
[18:02:09.429]     }, finally = {
[18:02:09.429]         if (!identical(...future.workdir, getwd())) 
[18:02:09.429]             setwd(...future.workdir)
[18:02:09.429]         {
[18:02:09.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:09.429]                 ...future.oldOptions$nwarnings <- NULL
[18:02:09.429]             }
[18:02:09.429]             base::options(...future.oldOptions)
[18:02:09.429]             if (.Platform$OS.type == "windows") {
[18:02:09.429]                 old_names <- names(...future.oldEnvVars)
[18:02:09.429]                 envs <- base::Sys.getenv()
[18:02:09.429]                 names <- names(envs)
[18:02:09.429]                 common <- intersect(names, old_names)
[18:02:09.429]                 added <- setdiff(names, old_names)
[18:02:09.429]                 removed <- setdiff(old_names, names)
[18:02:09.429]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:09.429]                   envs[common]]
[18:02:09.429]                 NAMES <- toupper(changed)
[18:02:09.429]                 args <- list()
[18:02:09.429]                 for (kk in seq_along(NAMES)) {
[18:02:09.429]                   name <- changed[[kk]]
[18:02:09.429]                   NAME <- NAMES[[kk]]
[18:02:09.429]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:09.429]                     next
[18:02:09.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:09.429]                 }
[18:02:09.429]                 NAMES <- toupper(added)
[18:02:09.429]                 for (kk in seq_along(NAMES)) {
[18:02:09.429]                   name <- added[[kk]]
[18:02:09.429]                   NAME <- NAMES[[kk]]
[18:02:09.429]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:09.429]                     next
[18:02:09.429]                   args[[name]] <- ""
[18:02:09.429]                 }
[18:02:09.429]                 NAMES <- toupper(removed)
[18:02:09.429]                 for (kk in seq_along(NAMES)) {
[18:02:09.429]                   name <- removed[[kk]]
[18:02:09.429]                   NAME <- NAMES[[kk]]
[18:02:09.429]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:09.429]                     next
[18:02:09.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:09.429]                 }
[18:02:09.429]                 if (length(args) > 0) 
[18:02:09.429]                   base::do.call(base::Sys.setenv, args = args)
[18:02:09.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:09.429]             }
[18:02:09.429]             else {
[18:02:09.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:09.429]             }
[18:02:09.429]             {
[18:02:09.429]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:09.429]                   0L) {
[18:02:09.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:09.429]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:09.429]                   base::options(opts)
[18:02:09.429]                 }
[18:02:09.429]                 {
[18:02:09.429]                   {
[18:02:09.429]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:09.429]                     NULL
[18:02:09.429]                   }
[18:02:09.429]                   options(future.plan = NULL)
[18:02:09.429]                   if (is.na(NA_character_)) 
[18:02:09.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:09.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:09.429]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:09.429]                     .init = FALSE)
[18:02:09.429]                 }
[18:02:09.429]             }
[18:02:09.429]         }
[18:02:09.429]     })
[18:02:09.429]     if (TRUE) {
[18:02:09.429]         base::sink(type = "output", split = FALSE)
[18:02:09.429]         if (TRUE) {
[18:02:09.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:09.429]         }
[18:02:09.429]         else {
[18:02:09.429]             ...future.result["stdout"] <- base::list(NULL)
[18:02:09.429]         }
[18:02:09.429]         base::close(...future.stdout)
[18:02:09.429]         ...future.stdout <- NULL
[18:02:09.429]     }
[18:02:09.429]     ...future.result$conditions <- ...future.conditions
[18:02:09.429]     ...future.result$finished <- base::Sys.time()
[18:02:09.429]     ...future.result
[18:02:09.429] }
[18:02:09.435] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[18:02:09.435] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[18:02:09.476] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[18:02:09.477] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[18:02:09.478] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[18:02:09.478] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[18:02:09.479] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[18:02:09.479] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[18:02:09.520] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[18:02:09.521] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[18:02:09.562] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[18:02:09.563] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[18:02:09.564] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[18:02:09.565] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[18:02:09.566] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[18:02:09.567] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:09.568] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:09.568] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[18:02:09.569] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[18:02:09.569] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:09.572] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:09.572] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:09.575] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:09.576] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[18:02:09.577] MultisessionFuture started
[18:02:09.578] - Launch lazy future ... done
[18:02:09.578] run() for ‘MultisessionFuture’ ... done
[18:02:09.578] Created future:
[18:02:09.578] MultisessionFuture:
[18:02:09.578] Label: ‘future_vapply-1’
[18:02:09.578] Expression:
[18:02:09.578] {
[18:02:09.578]     do.call(function(...) {
[18:02:09.578]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:09.578]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:09.578]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:09.578]             on.exit(options(oopts), add = TRUE)
[18:02:09.578]         }
[18:02:09.578]         {
[18:02:09.578]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:09.578]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:09.578]                 ...future.FUN(...future.X_jj, ...)
[18:02:09.578]             })
[18:02:09.578]         }
[18:02:09.578]     }, args = future.call.arguments)
[18:02:09.578] }
[18:02:09.578] Lazy evaluation: FALSE
[18:02:09.578] Asynchronous evaluation: TRUE
[18:02:09.578] Local evaluation: TRUE
[18:02:09.578] Environment: R_GlobalEnv
[18:02:09.578] Capture standard output: TRUE
[18:02:09.578] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:09.578] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:09.578] Packages: 1 packages (‘future.apply’)
[18:02:09.578] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:09.578] Resolved: FALSE
[18:02:09.578] Value: <not collected>
[18:02:09.578] Conditions captured: <none>
[18:02:09.578] Early signaling: FALSE
[18:02:09.578] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:09.578] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:09.592] Chunk #1 of 2 ... DONE
[18:02:09.592] Chunk #2 of 2 ...
[18:02:09.592]  - Finding globals in 'X' for chunk #2 ...
[18:02:09.593] getGlobalsAndPackages() ...
[18:02:09.593] Searching for globals...
[18:02:09.594] 
[18:02:09.594] Searching for globals ... DONE
[18:02:09.595] - globals: [0] <none>
[18:02:09.595] getGlobalsAndPackages() ... DONE
[18:02:09.595]    + additional globals found: [n=0] 
[18:02:09.595]    + additional namespaces needed: [n=0] 
[18:02:09.596]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:09.596]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:09.596]  - seeds: <none>
[18:02:09.597]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:09.597] getGlobalsAndPackages() ...
[18:02:09.597] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:09.598] Resolving globals: FALSE
[18:02:09.598] Tweak future expression to call with '...' arguments ...
[18:02:09.599] {
[18:02:09.599]     do.call(function(...) {
[18:02:09.599]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:09.599]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:09.599]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:09.599]             on.exit(options(oopts), add = TRUE)
[18:02:09.599]         }
[18:02:09.599]         {
[18:02:09.599]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:09.599]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:09.599]                 ...future.FUN(...future.X_jj, ...)
[18:02:09.599]             })
[18:02:09.599]         }
[18:02:09.599]     }, args = future.call.arguments)
[18:02:09.599] }
[18:02:09.599] Tweak future expression to call with '...' arguments ... DONE
[18:02:09.601] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:09.602] - packages: [1] ‘future.apply’
[18:02:09.602] getGlobalsAndPackages() ... DONE
[18:02:09.603] run() for ‘Future’ ...
[18:02:09.603] - state: ‘created’
[18:02:09.604] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:09.632] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:09.633] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:09.633]   - Field: ‘node’
[18:02:09.633]   - Field: ‘label’
[18:02:09.633]   - Field: ‘local’
[18:02:09.634]   - Field: ‘owner’
[18:02:09.634]   - Field: ‘envir’
[18:02:09.634]   - Field: ‘workers’
[18:02:09.634]   - Field: ‘packages’
[18:02:09.635]   - Field: ‘gc’
[18:02:09.635]   - Field: ‘conditions’
[18:02:09.635]   - Field: ‘persistent’
[18:02:09.635]   - Field: ‘expr’
[18:02:09.635]   - Field: ‘uuid’
[18:02:09.636]   - Field: ‘seed’
[18:02:09.636]   - Field: ‘version’
[18:02:09.636]   - Field: ‘result’
[18:02:09.636]   - Field: ‘asynchronous’
[18:02:09.637]   - Field: ‘calls’
[18:02:09.637]   - Field: ‘globals’
[18:02:09.637]   - Field: ‘stdout’
[18:02:09.637]   - Field: ‘earlySignal’
[18:02:09.637]   - Field: ‘lazy’
[18:02:09.638]   - Field: ‘state’
[18:02:09.638] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:09.638] - Launch lazy future ...
[18:02:09.639] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:09.639] Packages needed by future strategies (n = 0): <none>
[18:02:09.640] {
[18:02:09.640]     {
[18:02:09.640]         {
[18:02:09.640]             ...future.startTime <- base::Sys.time()
[18:02:09.640]             {
[18:02:09.640]                 {
[18:02:09.640]                   {
[18:02:09.640]                     {
[18:02:09.640]                       {
[18:02:09.640]                         base::local({
[18:02:09.640]                           has_future <- base::requireNamespace("future", 
[18:02:09.640]                             quietly = TRUE)
[18:02:09.640]                           if (has_future) {
[18:02:09.640]                             ns <- base::getNamespace("future")
[18:02:09.640]                             version <- ns[[".package"]][["version"]]
[18:02:09.640]                             if (is.null(version)) 
[18:02:09.640]                               version <- utils::packageVersion("future")
[18:02:09.640]                           }
[18:02:09.640]                           else {
[18:02:09.640]                             version <- NULL
[18:02:09.640]                           }
[18:02:09.640]                           if (!has_future || version < "1.8.0") {
[18:02:09.640]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:09.640]                               "", base::R.version$version.string), 
[18:02:09.640]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:09.640]                                 base::R.version$platform, 8 * 
[18:02:09.640]                                   base::.Machine$sizeof.pointer), 
[18:02:09.640]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:09.640]                                 "release", "version")], collapse = " "), 
[18:02:09.640]                               hostname = base::Sys.info()[["nodename"]])
[18:02:09.640]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:09.640]                               info)
[18:02:09.640]                             info <- base::paste(info, collapse = "; ")
[18:02:09.640]                             if (!has_future) {
[18:02:09.640]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:09.640]                                 info)
[18:02:09.640]                             }
[18:02:09.640]                             else {
[18:02:09.640]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:09.640]                                 info, version)
[18:02:09.640]                             }
[18:02:09.640]                             base::stop(msg)
[18:02:09.640]                           }
[18:02:09.640]                         })
[18:02:09.640]                       }
[18:02:09.640]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:09.640]                       base::options(mc.cores = 1L)
[18:02:09.640]                     }
[18:02:09.640]                     base::local({
[18:02:09.640]                       for (pkg in "future.apply") {
[18:02:09.640]                         base::loadNamespace(pkg)
[18:02:09.640]                         base::library(pkg, character.only = TRUE)
[18:02:09.640]                       }
[18:02:09.640]                     })
[18:02:09.640]                   }
[18:02:09.640]                   ...future.strategy.old <- future::plan("list")
[18:02:09.640]                   options(future.plan = NULL)
[18:02:09.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:09.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:09.640]                 }
[18:02:09.640]                 ...future.workdir <- getwd()
[18:02:09.640]             }
[18:02:09.640]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:09.640]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:09.640]         }
[18:02:09.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:09.640]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:09.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:09.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:09.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:09.640]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:09.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:09.640]             base::names(...future.oldOptions))
[18:02:09.640]     }
[18:02:09.640]     if (FALSE) {
[18:02:09.640]     }
[18:02:09.640]     else {
[18:02:09.640]         if (TRUE) {
[18:02:09.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:09.640]                 open = "w")
[18:02:09.640]         }
[18:02:09.640]         else {
[18:02:09.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:09.640]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:09.640]         }
[18:02:09.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:09.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:09.640]             base::sink(type = "output", split = FALSE)
[18:02:09.640]             base::close(...future.stdout)
[18:02:09.640]         }, add = TRUE)
[18:02:09.640]     }
[18:02:09.640]     ...future.frame <- base::sys.nframe()
[18:02:09.640]     ...future.conditions <- base::list()
[18:02:09.640]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:09.640]     if (FALSE) {
[18:02:09.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:09.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:09.640]     }
[18:02:09.640]     ...future.result <- base::tryCatch({
[18:02:09.640]         base::withCallingHandlers({
[18:02:09.640]             ...future.value <- base::withVisible(base::local({
[18:02:09.640]                 ...future.makeSendCondition <- base::local({
[18:02:09.640]                   sendCondition <- NULL
[18:02:09.640]                   function(frame = 1L) {
[18:02:09.640]                     if (is.function(sendCondition)) 
[18:02:09.640]                       return(sendCondition)
[18:02:09.640]                     ns <- getNamespace("parallel")
[18:02:09.640]                     if (exists("sendData", mode = "function", 
[18:02:09.640]                       envir = ns)) {
[18:02:09.640]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:09.640]                         envir = ns)
[18:02:09.640]                       envir <- sys.frame(frame)
[18:02:09.640]                       master <- NULL
[18:02:09.640]                       while (!identical(envir, .GlobalEnv) && 
[18:02:09.640]                         !identical(envir, emptyenv())) {
[18:02:09.640]                         if (exists("master", mode = "list", envir = envir, 
[18:02:09.640]                           inherits = FALSE)) {
[18:02:09.640]                           master <- get("master", mode = "list", 
[18:02:09.640]                             envir = envir, inherits = FALSE)
[18:02:09.640]                           if (inherits(master, c("SOCKnode", 
[18:02:09.640]                             "SOCK0node"))) {
[18:02:09.640]                             sendCondition <<- function(cond) {
[18:02:09.640]                               data <- list(type = "VALUE", value = cond, 
[18:02:09.640]                                 success = TRUE)
[18:02:09.640]                               parallel_sendData(master, data)
[18:02:09.640]                             }
[18:02:09.640]                             return(sendCondition)
[18:02:09.640]                           }
[18:02:09.640]                         }
[18:02:09.640]                         frame <- frame + 1L
[18:02:09.640]                         envir <- sys.frame(frame)
[18:02:09.640]                       }
[18:02:09.640]                     }
[18:02:09.640]                     sendCondition <<- function(cond) NULL
[18:02:09.640]                   }
[18:02:09.640]                 })
[18:02:09.640]                 withCallingHandlers({
[18:02:09.640]                   {
[18:02:09.640]                     do.call(function(...) {
[18:02:09.640]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:09.640]                       if (!identical(...future.globals.maxSize.org, 
[18:02:09.640]                         ...future.globals.maxSize)) {
[18:02:09.640]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:09.640]                         on.exit(options(oopts), add = TRUE)
[18:02:09.640]                       }
[18:02:09.640]                       {
[18:02:09.640]                         lapply(seq_along(...future.elements_ii), 
[18:02:09.640]                           FUN = function(jj) {
[18:02:09.640]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:09.640]                             ...future.FUN(...future.X_jj, ...)
[18:02:09.640]                           })
[18:02:09.640]                       }
[18:02:09.640]                     }, args = future.call.arguments)
[18:02:09.640]                   }
[18:02:09.640]                 }, immediateCondition = function(cond) {
[18:02:09.640]                   sendCondition <- ...future.makeSendCondition()
[18:02:09.640]                   sendCondition(cond)
[18:02:09.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:09.640]                   {
[18:02:09.640]                     inherits <- base::inherits
[18:02:09.640]                     invokeRestart <- base::invokeRestart
[18:02:09.640]                     is.null <- base::is.null
[18:02:09.640]                     muffled <- FALSE
[18:02:09.640]                     if (inherits(cond, "message")) {
[18:02:09.640]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:09.640]                       if (muffled) 
[18:02:09.640]                         invokeRestart("muffleMessage")
[18:02:09.640]                     }
[18:02:09.640]                     else if (inherits(cond, "warning")) {
[18:02:09.640]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:09.640]                       if (muffled) 
[18:02:09.640]                         invokeRestart("muffleWarning")
[18:02:09.640]                     }
[18:02:09.640]                     else if (inherits(cond, "condition")) {
[18:02:09.640]                       if (!is.null(pattern)) {
[18:02:09.640]                         computeRestarts <- base::computeRestarts
[18:02:09.640]                         grepl <- base::grepl
[18:02:09.640]                         restarts <- computeRestarts(cond)
[18:02:09.640]                         for (restart in restarts) {
[18:02:09.640]                           name <- restart$name
[18:02:09.640]                           if (is.null(name)) 
[18:02:09.640]                             next
[18:02:09.640]                           if (!grepl(pattern, name)) 
[18:02:09.640]                             next
[18:02:09.640]                           invokeRestart(restart)
[18:02:09.640]                           muffled <- TRUE
[18:02:09.640]                           break
[18:02:09.640]                         }
[18:02:09.640]                       }
[18:02:09.640]                     }
[18:02:09.640]                     invisible(muffled)
[18:02:09.640]                   }
[18:02:09.640]                   muffleCondition(cond)
[18:02:09.640]                 })
[18:02:09.640]             }))
[18:02:09.640]             future::FutureResult(value = ...future.value$value, 
[18:02:09.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:09.640]                   ...future.rng), globalenv = if (FALSE) 
[18:02:09.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:09.640]                     ...future.globalenv.names))
[18:02:09.640]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:09.640]         }, condition = base::local({
[18:02:09.640]             c <- base::c
[18:02:09.640]             inherits <- base::inherits
[18:02:09.640]             invokeRestart <- base::invokeRestart
[18:02:09.640]             length <- base::length
[18:02:09.640]             list <- base::list
[18:02:09.640]             seq.int <- base::seq.int
[18:02:09.640]             signalCondition <- base::signalCondition
[18:02:09.640]             sys.calls <- base::sys.calls
[18:02:09.640]             `[[` <- base::`[[`
[18:02:09.640]             `+` <- base::`+`
[18:02:09.640]             `<<-` <- base::`<<-`
[18:02:09.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:09.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:09.640]                   3L)]
[18:02:09.640]             }
[18:02:09.640]             function(cond) {
[18:02:09.640]                 is_error <- inherits(cond, "error")
[18:02:09.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:09.640]                   NULL)
[18:02:09.640]                 if (is_error) {
[18:02:09.640]                   sessionInformation <- function() {
[18:02:09.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:09.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:09.640]                       search = base::search(), system = base::Sys.info())
[18:02:09.640]                   }
[18:02:09.640]                   ...future.conditions[[length(...future.conditions) + 
[18:02:09.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:09.640]                     cond$call), session = sessionInformation(), 
[18:02:09.640]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:09.640]                   signalCondition(cond)
[18:02:09.640]                 }
[18:02:09.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:09.640]                 "immediateCondition"))) {
[18:02:09.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:09.640]                   ...future.conditions[[length(...future.conditions) + 
[18:02:09.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:09.640]                   if (TRUE && !signal) {
[18:02:09.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:09.640]                     {
[18:02:09.640]                       inherits <- base::inherits
[18:02:09.640]                       invokeRestart <- base::invokeRestart
[18:02:09.640]                       is.null <- base::is.null
[18:02:09.640]                       muffled <- FALSE
[18:02:09.640]                       if (inherits(cond, "message")) {
[18:02:09.640]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:09.640]                         if (muffled) 
[18:02:09.640]                           invokeRestart("muffleMessage")
[18:02:09.640]                       }
[18:02:09.640]                       else if (inherits(cond, "warning")) {
[18:02:09.640]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:09.640]                         if (muffled) 
[18:02:09.640]                           invokeRestart("muffleWarning")
[18:02:09.640]                       }
[18:02:09.640]                       else if (inherits(cond, "condition")) {
[18:02:09.640]                         if (!is.null(pattern)) {
[18:02:09.640]                           computeRestarts <- base::computeRestarts
[18:02:09.640]                           grepl <- base::grepl
[18:02:09.640]                           restarts <- computeRestarts(cond)
[18:02:09.640]                           for (restart in restarts) {
[18:02:09.640]                             name <- restart$name
[18:02:09.640]                             if (is.null(name)) 
[18:02:09.640]                               next
[18:02:09.640]                             if (!grepl(pattern, name)) 
[18:02:09.640]                               next
[18:02:09.640]                             invokeRestart(restart)
[18:02:09.640]                             muffled <- TRUE
[18:02:09.640]                             break
[18:02:09.640]                           }
[18:02:09.640]                         }
[18:02:09.640]                       }
[18:02:09.640]                       invisible(muffled)
[18:02:09.640]                     }
[18:02:09.640]                     muffleCondition(cond, pattern = "^muffle")
[18:02:09.640]                   }
[18:02:09.640]                 }
[18:02:09.640]                 else {
[18:02:09.640]                   if (TRUE) {
[18:02:09.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:09.640]                     {
[18:02:09.640]                       inherits <- base::inherits
[18:02:09.640]                       invokeRestart <- base::invokeRestart
[18:02:09.640]                       is.null <- base::is.null
[18:02:09.640]                       muffled <- FALSE
[18:02:09.640]                       if (inherits(cond, "message")) {
[18:02:09.640]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:09.640]                         if (muffled) 
[18:02:09.640]                           invokeRestart("muffleMessage")
[18:02:09.640]                       }
[18:02:09.640]                       else if (inherits(cond, "warning")) {
[18:02:09.640]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:09.640]                         if (muffled) 
[18:02:09.640]                           invokeRestart("muffleWarning")
[18:02:09.640]                       }
[18:02:09.640]                       else if (inherits(cond, "condition")) {
[18:02:09.640]                         if (!is.null(pattern)) {
[18:02:09.640]                           computeRestarts <- base::computeRestarts
[18:02:09.640]                           grepl <- base::grepl
[18:02:09.640]                           restarts <- computeRestarts(cond)
[18:02:09.640]                           for (restart in restarts) {
[18:02:09.640]                             name <- restart$name
[18:02:09.640]                             if (is.null(name)) 
[18:02:09.640]                               next
[18:02:09.640]                             if (!grepl(pattern, name)) 
[18:02:09.640]                               next
[18:02:09.640]                             invokeRestart(restart)
[18:02:09.640]                             muffled <- TRUE
[18:02:09.640]                             break
[18:02:09.640]                           }
[18:02:09.640]                         }
[18:02:09.640]                       }
[18:02:09.640]                       invisible(muffled)
[18:02:09.640]                     }
[18:02:09.640]                     muffleCondition(cond, pattern = "^muffle")
[18:02:09.640]                   }
[18:02:09.640]                 }
[18:02:09.640]             }
[18:02:09.640]         }))
[18:02:09.640]     }, error = function(ex) {
[18:02:09.640]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:09.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:09.640]                 ...future.rng), started = ...future.startTime, 
[18:02:09.640]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:09.640]             version = "1.8"), class = "FutureResult")
[18:02:09.640]     }, finally = {
[18:02:09.640]         if (!identical(...future.workdir, getwd())) 
[18:02:09.640]             setwd(...future.workdir)
[18:02:09.640]         {
[18:02:09.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:09.640]                 ...future.oldOptions$nwarnings <- NULL
[18:02:09.640]             }
[18:02:09.640]             base::options(...future.oldOptions)
[18:02:09.640]             if (.Platform$OS.type == "windows") {
[18:02:09.640]                 old_names <- names(...future.oldEnvVars)
[18:02:09.640]                 envs <- base::Sys.getenv()
[18:02:09.640]                 names <- names(envs)
[18:02:09.640]                 common <- intersect(names, old_names)
[18:02:09.640]                 added <- setdiff(names, old_names)
[18:02:09.640]                 removed <- setdiff(old_names, names)
[18:02:09.640]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:09.640]                   envs[common]]
[18:02:09.640]                 NAMES <- toupper(changed)
[18:02:09.640]                 args <- list()
[18:02:09.640]                 for (kk in seq_along(NAMES)) {
[18:02:09.640]                   name <- changed[[kk]]
[18:02:09.640]                   NAME <- NAMES[[kk]]
[18:02:09.640]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:09.640]                     next
[18:02:09.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:09.640]                 }
[18:02:09.640]                 NAMES <- toupper(added)
[18:02:09.640]                 for (kk in seq_along(NAMES)) {
[18:02:09.640]                   name <- added[[kk]]
[18:02:09.640]                   NAME <- NAMES[[kk]]
[18:02:09.640]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:09.640]                     next
[18:02:09.640]                   args[[name]] <- ""
[18:02:09.640]                 }
[18:02:09.640]                 NAMES <- toupper(removed)
[18:02:09.640]                 for (kk in seq_along(NAMES)) {
[18:02:09.640]                   name <- removed[[kk]]
[18:02:09.640]                   NAME <- NAMES[[kk]]
[18:02:09.640]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:09.640]                     next
[18:02:09.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:09.640]                 }
[18:02:09.640]                 if (length(args) > 0) 
[18:02:09.640]                   base::do.call(base::Sys.setenv, args = args)
[18:02:09.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:09.640]             }
[18:02:09.640]             else {
[18:02:09.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:09.640]             }
[18:02:09.640]             {
[18:02:09.640]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:09.640]                   0L) {
[18:02:09.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:09.640]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:09.640]                   base::options(opts)
[18:02:09.640]                 }
[18:02:09.640]                 {
[18:02:09.640]                   {
[18:02:09.640]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:09.640]                     NULL
[18:02:09.640]                   }
[18:02:09.640]                   options(future.plan = NULL)
[18:02:09.640]                   if (is.na(NA_character_)) 
[18:02:09.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:09.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:09.640]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:09.640]                     .init = FALSE)
[18:02:09.640]                 }
[18:02:09.640]             }
[18:02:09.640]         }
[18:02:09.640]     })
[18:02:09.640]     if (TRUE) {
[18:02:09.640]         base::sink(type = "output", split = FALSE)
[18:02:09.640]         if (TRUE) {
[18:02:09.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:09.640]         }
[18:02:09.640]         else {
[18:02:09.640]             ...future.result["stdout"] <- base::list(NULL)
[18:02:09.640]         }
[18:02:09.640]         base::close(...future.stdout)
[18:02:09.640]         ...future.stdout <- NULL
[18:02:09.640]     }
[18:02:09.640]     ...future.result$conditions <- ...future.conditions
[18:02:09.640]     ...future.result$finished <- base::Sys.time()
[18:02:09.640]     ...future.result
[18:02:09.640] }
[18:02:09.646] Exporting 11 global objects (92.05 KiB) to cluster node #2 ...
[18:02:09.646] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[18:02:09.689] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[18:02:09.689] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[18:02:09.690] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[18:02:09.691] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[18:02:09.692] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[18:02:09.692] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[18:02:09.734] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[18:02:09.735] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[18:02:09.776] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[18:02:09.777] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[18:02:09.778] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[18:02:09.779] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[18:02:09.780] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[18:02:09.781] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:09.782] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:09.782] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[18:02:09.783] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[18:02:09.784] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:09.785] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:09.785] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:09.790] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:09.791] Exporting 11 global objects (92.05 KiB) to cluster node #2 ... DONE
[18:02:09.793] MultisessionFuture started
[18:02:09.793] - Launch lazy future ... done
[18:02:09.793] run() for ‘MultisessionFuture’ ... done
[18:02:09.794] Created future:
[18:02:09.794] MultisessionFuture:
[18:02:09.794] Label: ‘future_vapply-2’
[18:02:09.794] Expression:
[18:02:09.794] {
[18:02:09.794]     do.call(function(...) {
[18:02:09.794]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:09.794]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:09.794]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:09.794]             on.exit(options(oopts), add = TRUE)
[18:02:09.794]         }
[18:02:09.794]         {
[18:02:09.794]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:09.794]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:09.794]                 ...future.FUN(...future.X_jj, ...)
[18:02:09.794]             })
[18:02:09.794]         }
[18:02:09.794]     }, args = future.call.arguments)
[18:02:09.794] }
[18:02:09.794] Lazy evaluation: FALSE
[18:02:09.794] Asynchronous evaluation: TRUE
[18:02:09.794] Local evaluation: TRUE
[18:02:09.794] Environment: R_GlobalEnv
[18:02:09.794] Capture standard output: TRUE
[18:02:09.794] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:09.794] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:09.794] Packages: 1 packages (‘future.apply’)
[18:02:09.794] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:09.794] Resolved: FALSE
[18:02:09.794] Value: <not collected>
[18:02:09.794] Conditions captured: <none>
[18:02:09.794] Early signaling: FALSE
[18:02:09.794] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:09.794] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:09.809] Chunk #2 of 2 ... DONE
[18:02:09.809] Launching 2 futures (chunks) ... DONE
[18:02:09.810] Resolving 2 futures (chunks) ...
[18:02:09.810] resolve() on list ...
[18:02:09.810]  recursive: 0
[18:02:09.811]  length: 2
[18:02:09.811] 
[18:02:09.812] receiveMessageFromWorker() for ClusterFuture ...
[18:02:09.813] - Validating connection of MultisessionFuture
[18:02:09.813] - received message: FutureResult
[18:02:09.814] - Received FutureResult
[18:02:09.814] - Erased future from FutureRegistry
[18:02:09.814] result() for ClusterFuture ...
[18:02:09.815] - result already collected: FutureResult
[18:02:09.815] result() for ClusterFuture ... done
[18:02:09.815] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:09.816] Future #1
[18:02:09.816] result() for ClusterFuture ...
[18:02:09.816] - result already collected: FutureResult
[18:02:09.816] result() for ClusterFuture ... done
[18:02:09.817] result() for ClusterFuture ...
[18:02:09.817] - result already collected: FutureResult
[18:02:09.817] result() for ClusterFuture ... done
[18:02:09.818] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:09.818] - nx: 2
[18:02:09.818] - relay: TRUE
[18:02:09.819] - stdout: TRUE
[18:02:09.819] - signal: TRUE
[18:02:09.819] - resignal: FALSE
[18:02:09.819] - force: TRUE
[18:02:09.820] - relayed: [n=2] FALSE, FALSE
[18:02:09.820] - queued futures: [n=2] FALSE, FALSE
[18:02:09.820]  - until=1
[18:02:09.821]  - relaying element #1
[18:02:09.821] result() for ClusterFuture ...
[18:02:09.821] - result already collected: FutureResult
[18:02:09.822] result() for ClusterFuture ... done
[18:02:09.822] result() for ClusterFuture ...
[18:02:09.822] - result already collected: FutureResult
[18:02:09.822] result() for ClusterFuture ... done
[18:02:09.823] result() for ClusterFuture ...
[18:02:09.823] - result already collected: FutureResult
[18:02:09.823] result() for ClusterFuture ... done
[18:02:09.824] result() for ClusterFuture ...
[18:02:09.824] - result already collected: FutureResult
[18:02:09.824] result() for ClusterFuture ... done
[18:02:09.825] - relayed: [n=2] TRUE, FALSE
[18:02:09.825] - queued futures: [n=2] TRUE, FALSE
[18:02:09.825] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:09.826]  length: 1 (resolved future 1)
[18:02:09.849] receiveMessageFromWorker() for ClusterFuture ...
[18:02:09.849] - Validating connection of MultisessionFuture
[18:02:09.850] - received message: FutureResult
[18:02:09.850] - Received FutureResult
[18:02:09.850] - Erased future from FutureRegistry
[18:02:09.851] result() for ClusterFuture ...
[18:02:09.851] - result already collected: FutureResult
[18:02:09.851] result() for ClusterFuture ... done
[18:02:09.852] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:09.852] Future #2
[18:02:09.853] result() for ClusterFuture ...
[18:02:09.853] - result already collected: FutureResult
[18:02:09.853] result() for ClusterFuture ... done
[18:02:09.854] result() for ClusterFuture ...
[18:02:09.854] - result already collected: FutureResult
[18:02:09.854] result() for ClusterFuture ... done
[18:02:09.855] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:09.855] - nx: 2
[18:02:09.855] - relay: TRUE
[18:02:09.855] - stdout: TRUE
[18:02:09.856] - signal: TRUE
[18:02:09.856] - resignal: FALSE
[18:02:09.856] - force: TRUE
[18:02:09.857] - relayed: [n=2] TRUE, FALSE
[18:02:09.857] - queued futures: [n=2] TRUE, FALSE
[18:02:09.858]  - until=2
[18:02:09.858]  - relaying element #2
[18:02:09.858] result() for ClusterFuture ...
[18:02:09.859] - result already collected: FutureResult
[18:02:09.859] result() for ClusterFuture ... done
[18:02:09.859] result() for ClusterFuture ...
[18:02:09.859] - result already collected: FutureResult
[18:02:09.860] result() for ClusterFuture ... done
[18:02:09.860] result() for ClusterFuture ...
[18:02:09.861] - result already collected: FutureResult
[18:02:09.861] result() for ClusterFuture ... done
[18:02:09.861] result() for ClusterFuture ...
[18:02:09.861] - result already collected: FutureResult
[18:02:09.862] result() for ClusterFuture ... done
[18:02:09.862] - relayed: [n=2] TRUE, TRUE
[18:02:09.862] - queued futures: [n=2] TRUE, TRUE
[18:02:09.863] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[18:02:09.863]  length: 0 (resolved future 2)
[18:02:09.863] Relaying remaining futures
[18:02:09.864] signalConditionsASAP(NULL, pos=0) ...
[18:02:09.864] - nx: 2
[18:02:09.864] - relay: TRUE
[18:02:09.864] - stdout: TRUE
[18:02:09.865] - signal: TRUE
[18:02:09.865] - resignal: FALSE
[18:02:09.865] - force: TRUE
[18:02:09.865] - relayed: [n=2] TRUE, TRUE
[18:02:09.866] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:09.866] - relayed: [n=2] TRUE, TRUE
[18:02:09.867] - queued futures: [n=2] TRUE, TRUE
[18:02:09.867] signalConditionsASAP(NULL, pos=0) ... done
[18:02:09.867] resolve() on list ... DONE
[18:02:09.868] result() for ClusterFuture ...
[18:02:09.868] - result already collected: FutureResult
[18:02:09.868] result() for ClusterFuture ... done
[18:02:09.868] result() for ClusterFuture ...
[18:02:09.869] - result already collected: FutureResult
[18:02:09.869] result() for ClusterFuture ... done
[18:02:09.869] result() for ClusterFuture ...
[18:02:09.870] - result already collected: FutureResult
[18:02:09.870] result() for ClusterFuture ... done
[18:02:09.870] result() for ClusterFuture ...
[18:02:09.871] - result already collected: FutureResult
[18:02:09.871] result() for ClusterFuture ... done
[18:02:09.871]  - Number of value chunks collected: 2
[18:02:09.872] Resolving 2 futures (chunks) ... DONE
[18:02:09.872] Reducing values from 2 chunks ...
[18:02:09.872]  - Number of values collected after concatenation: 3
[18:02:09.872]  - Number of values expected: 3
[18:02:09.873] Reducing values from 2 chunks ... DONE
[18:02:09.873] future_lapply() ... DONE
- exceptions ...
[18:02:09.874] future_lapply() ...
[18:02:09.887] Number of chunks: 2
[18:02:09.887] getGlobalsAndPackagesXApply() ...
[18:02:09.887]  - future.globals: TRUE
[18:02:09.887] getGlobalsAndPackages() ...
[18:02:09.888] Searching for globals...
[18:02:09.895] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[18:02:09.896] Searching for globals ... DONE
[18:02:09.896] Resolving globals: FALSE
[18:02:09.898] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[18:02:09.899] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[18:02:09.899] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:09.899] - packages: [1] ‘future.apply’
[18:02:09.900] getGlobalsAndPackages() ... DONE
[18:02:09.900]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[18:02:09.900]  - needed namespaces: [n=1] ‘future.apply’
[18:02:09.900] Finding globals ... DONE
[18:02:09.901]  - use_args: TRUE
[18:02:09.901]  - Getting '...' globals ...
[18:02:09.901] resolve() on list ...
[18:02:09.902]  recursive: 0
[18:02:09.902]  length: 1
[18:02:09.902]  elements: ‘...’
[18:02:09.902]  length: 0 (resolved future 1)
[18:02:09.903] resolve() on list ... DONE
[18:02:09.903]    - '...' content: [n=0] 
[18:02:09.903] List of 1
[18:02:09.903]  $ ...: list()
[18:02:09.903]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:09.903]  - attr(*, "where")=List of 1
[18:02:09.903]   ..$ ...:<environment: 0x6183c0157040> 
[18:02:09.903]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:09.903]  - attr(*, "resolved")= logi TRUE
[18:02:09.903]  - attr(*, "total_size")= num NA
[18:02:09.908]  - Getting '...' globals ... DONE
[18:02:09.909] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[18:02:09.909] List of 8
[18:02:09.909]  $ ...future.FUN:function (x, ...)  
[18:02:09.909]  $ x_FUN        :function (x)  
[18:02:09.909]  $ times        : int 2
[18:02:09.909]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[18:02:09.909]  $ stop_if_not  :function (...)  
[18:02:09.909]  $ dim          : NULL
[18:02:09.909]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[18:02:09.909]  $ ...          : list()
[18:02:09.909]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:09.909]  - attr(*, "where")=List of 8
[18:02:09.909]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:09.909]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[18:02:09.909]   ..$ times        :<environment: R_EmptyEnv> 
[18:02:09.909]   ..$ stopf        :<environment: R_EmptyEnv> 
[18:02:09.909]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[18:02:09.909]   ..$ dim          :<environment: R_EmptyEnv> 
[18:02:09.909]   ..$ valid_types  :<environment: R_EmptyEnv> 
[18:02:09.909]   ..$ ...          :<environment: 0x6183c0157040> 
[18:02:09.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:09.909]  - attr(*, "resolved")= logi FALSE
[18:02:09.909]  - attr(*, "total_size")= num 95128
[18:02:09.921] Packages to be attached in all futures: [n=1] ‘future.apply’
[18:02:09.922] getGlobalsAndPackagesXApply() ... DONE
[18:02:09.922] Number of futures (= number of chunks): 2
[18:02:09.922] Launching 2 futures (chunks) ...
[18:02:09.923] Chunk #1 of 2 ...
[18:02:09.923]  - Finding globals in 'X' for chunk #1 ...
[18:02:09.923] getGlobalsAndPackages() ...
[18:02:09.923] Searching for globals...
[18:02:09.924] 
[18:02:09.924] Searching for globals ... DONE
[18:02:09.925] - globals: [0] <none>
[18:02:09.925] getGlobalsAndPackages() ... DONE
[18:02:09.925]    + additional globals found: [n=0] 
[18:02:09.925]    + additional namespaces needed: [n=0] 
[18:02:09.925]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:09.926]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:09.926]  - seeds: <none>
[18:02:09.926]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:09.926] getGlobalsAndPackages() ...
[18:02:09.927] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:09.927] Resolving globals: FALSE
[18:02:09.927] Tweak future expression to call with '...' arguments ...
[18:02:09.927] {
[18:02:09.927]     do.call(function(...) {
[18:02:09.927]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:09.927]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:09.927]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:09.927]             on.exit(options(oopts), add = TRUE)
[18:02:09.927]         }
[18:02:09.927]         {
[18:02:09.927]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:09.927]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:09.927]                 ...future.FUN(...future.X_jj, ...)
[18:02:09.927]             })
[18:02:09.927]         }
[18:02:09.927]     }, args = future.call.arguments)
[18:02:09.927] }
[18:02:09.928] Tweak future expression to call with '...' arguments ... DONE
[18:02:09.929] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:09.930] - packages: [1] ‘future.apply’
[18:02:09.930] getGlobalsAndPackages() ... DONE
[18:02:09.931] run() for ‘Future’ ...
[18:02:09.931] - state: ‘created’
[18:02:09.931] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:09.956] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:09.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:09.957]   - Field: ‘node’
[18:02:09.957]   - Field: ‘label’
[18:02:09.957]   - Field: ‘local’
[18:02:09.957]   - Field: ‘owner’
[18:02:09.958]   - Field: ‘envir’
[18:02:09.958]   - Field: ‘workers’
[18:02:09.958]   - Field: ‘packages’
[18:02:09.958]   - Field: ‘gc’
[18:02:09.958]   - Field: ‘conditions’
[18:02:09.959]   - Field: ‘persistent’
[18:02:09.959]   - Field: ‘expr’
[18:02:09.959]   - Field: ‘uuid’
[18:02:09.959]   - Field: ‘seed’
[18:02:09.959]   - Field: ‘version’
[18:02:09.960]   - Field: ‘result’
[18:02:09.960]   - Field: ‘asynchronous’
[18:02:09.960]   - Field: ‘calls’
[18:02:09.960]   - Field: ‘globals’
[18:02:09.960]   - Field: ‘stdout’
[18:02:09.961]   - Field: ‘earlySignal’
[18:02:09.961]   - Field: ‘lazy’
[18:02:09.961]   - Field: ‘state’
[18:02:09.961] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:09.961] - Launch lazy future ...
[18:02:09.962] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:09.962] Packages needed by future strategies (n = 0): <none>
[18:02:09.963] {
[18:02:09.963]     {
[18:02:09.963]         {
[18:02:09.963]             ...future.startTime <- base::Sys.time()
[18:02:09.963]             {
[18:02:09.963]                 {
[18:02:09.963]                   {
[18:02:09.963]                     {
[18:02:09.963]                       {
[18:02:09.963]                         base::local({
[18:02:09.963]                           has_future <- base::requireNamespace("future", 
[18:02:09.963]                             quietly = TRUE)
[18:02:09.963]                           if (has_future) {
[18:02:09.963]                             ns <- base::getNamespace("future")
[18:02:09.963]                             version <- ns[[".package"]][["version"]]
[18:02:09.963]                             if (is.null(version)) 
[18:02:09.963]                               version <- utils::packageVersion("future")
[18:02:09.963]                           }
[18:02:09.963]                           else {
[18:02:09.963]                             version <- NULL
[18:02:09.963]                           }
[18:02:09.963]                           if (!has_future || version < "1.8.0") {
[18:02:09.963]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:09.963]                               "", base::R.version$version.string), 
[18:02:09.963]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:09.963]                                 base::R.version$platform, 8 * 
[18:02:09.963]                                   base::.Machine$sizeof.pointer), 
[18:02:09.963]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:09.963]                                 "release", "version")], collapse = " "), 
[18:02:09.963]                               hostname = base::Sys.info()[["nodename"]])
[18:02:09.963]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:09.963]                               info)
[18:02:09.963]                             info <- base::paste(info, collapse = "; ")
[18:02:09.963]                             if (!has_future) {
[18:02:09.963]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:09.963]                                 info)
[18:02:09.963]                             }
[18:02:09.963]                             else {
[18:02:09.963]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:09.963]                                 info, version)
[18:02:09.963]                             }
[18:02:09.963]                             base::stop(msg)
[18:02:09.963]                           }
[18:02:09.963]                         })
[18:02:09.963]                       }
[18:02:09.963]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:09.963]                       base::options(mc.cores = 1L)
[18:02:09.963]                     }
[18:02:09.963]                     base::local({
[18:02:09.963]                       for (pkg in "future.apply") {
[18:02:09.963]                         base::loadNamespace(pkg)
[18:02:09.963]                         base::library(pkg, character.only = TRUE)
[18:02:09.963]                       }
[18:02:09.963]                     })
[18:02:09.963]                   }
[18:02:09.963]                   ...future.strategy.old <- future::plan("list")
[18:02:09.963]                   options(future.plan = NULL)
[18:02:09.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:09.963]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:09.963]                 }
[18:02:09.963]                 ...future.workdir <- getwd()
[18:02:09.963]             }
[18:02:09.963]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:09.963]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:09.963]         }
[18:02:09.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:09.963]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:09.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:09.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:09.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:09.963]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:09.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:09.963]             base::names(...future.oldOptions))
[18:02:09.963]     }
[18:02:09.963]     if (FALSE) {
[18:02:09.963]     }
[18:02:09.963]     else {
[18:02:09.963]         if (TRUE) {
[18:02:09.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:09.963]                 open = "w")
[18:02:09.963]         }
[18:02:09.963]         else {
[18:02:09.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:09.963]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:09.963]         }
[18:02:09.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:09.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:09.963]             base::sink(type = "output", split = FALSE)
[18:02:09.963]             base::close(...future.stdout)
[18:02:09.963]         }, add = TRUE)
[18:02:09.963]     }
[18:02:09.963]     ...future.frame <- base::sys.nframe()
[18:02:09.963]     ...future.conditions <- base::list()
[18:02:09.963]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:09.963]     if (FALSE) {
[18:02:09.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:09.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:09.963]     }
[18:02:09.963]     ...future.result <- base::tryCatch({
[18:02:09.963]         base::withCallingHandlers({
[18:02:09.963]             ...future.value <- base::withVisible(base::local({
[18:02:09.963]                 ...future.makeSendCondition <- base::local({
[18:02:09.963]                   sendCondition <- NULL
[18:02:09.963]                   function(frame = 1L) {
[18:02:09.963]                     if (is.function(sendCondition)) 
[18:02:09.963]                       return(sendCondition)
[18:02:09.963]                     ns <- getNamespace("parallel")
[18:02:09.963]                     if (exists("sendData", mode = "function", 
[18:02:09.963]                       envir = ns)) {
[18:02:09.963]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:09.963]                         envir = ns)
[18:02:09.963]                       envir <- sys.frame(frame)
[18:02:09.963]                       master <- NULL
[18:02:09.963]                       while (!identical(envir, .GlobalEnv) && 
[18:02:09.963]                         !identical(envir, emptyenv())) {
[18:02:09.963]                         if (exists("master", mode = "list", envir = envir, 
[18:02:09.963]                           inherits = FALSE)) {
[18:02:09.963]                           master <- get("master", mode = "list", 
[18:02:09.963]                             envir = envir, inherits = FALSE)
[18:02:09.963]                           if (inherits(master, c("SOCKnode", 
[18:02:09.963]                             "SOCK0node"))) {
[18:02:09.963]                             sendCondition <<- function(cond) {
[18:02:09.963]                               data <- list(type = "VALUE", value = cond, 
[18:02:09.963]                                 success = TRUE)
[18:02:09.963]                               parallel_sendData(master, data)
[18:02:09.963]                             }
[18:02:09.963]                             return(sendCondition)
[18:02:09.963]                           }
[18:02:09.963]                         }
[18:02:09.963]                         frame <- frame + 1L
[18:02:09.963]                         envir <- sys.frame(frame)
[18:02:09.963]                       }
[18:02:09.963]                     }
[18:02:09.963]                     sendCondition <<- function(cond) NULL
[18:02:09.963]                   }
[18:02:09.963]                 })
[18:02:09.963]                 withCallingHandlers({
[18:02:09.963]                   {
[18:02:09.963]                     do.call(function(...) {
[18:02:09.963]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:09.963]                       if (!identical(...future.globals.maxSize.org, 
[18:02:09.963]                         ...future.globals.maxSize)) {
[18:02:09.963]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:09.963]                         on.exit(options(oopts), add = TRUE)
[18:02:09.963]                       }
[18:02:09.963]                       {
[18:02:09.963]                         lapply(seq_along(...future.elements_ii), 
[18:02:09.963]                           FUN = function(jj) {
[18:02:09.963]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:09.963]                             ...future.FUN(...future.X_jj, ...)
[18:02:09.963]                           })
[18:02:09.963]                       }
[18:02:09.963]                     }, args = future.call.arguments)
[18:02:09.963]                   }
[18:02:09.963]                 }, immediateCondition = function(cond) {
[18:02:09.963]                   sendCondition <- ...future.makeSendCondition()
[18:02:09.963]                   sendCondition(cond)
[18:02:09.963]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:09.963]                   {
[18:02:09.963]                     inherits <- base::inherits
[18:02:09.963]                     invokeRestart <- base::invokeRestart
[18:02:09.963]                     is.null <- base::is.null
[18:02:09.963]                     muffled <- FALSE
[18:02:09.963]                     if (inherits(cond, "message")) {
[18:02:09.963]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:09.963]                       if (muffled) 
[18:02:09.963]                         invokeRestart("muffleMessage")
[18:02:09.963]                     }
[18:02:09.963]                     else if (inherits(cond, "warning")) {
[18:02:09.963]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:09.963]                       if (muffled) 
[18:02:09.963]                         invokeRestart("muffleWarning")
[18:02:09.963]                     }
[18:02:09.963]                     else if (inherits(cond, "condition")) {
[18:02:09.963]                       if (!is.null(pattern)) {
[18:02:09.963]                         computeRestarts <- base::computeRestarts
[18:02:09.963]                         grepl <- base::grepl
[18:02:09.963]                         restarts <- computeRestarts(cond)
[18:02:09.963]                         for (restart in restarts) {
[18:02:09.963]                           name <- restart$name
[18:02:09.963]                           if (is.null(name)) 
[18:02:09.963]                             next
[18:02:09.963]                           if (!grepl(pattern, name)) 
[18:02:09.963]                             next
[18:02:09.963]                           invokeRestart(restart)
[18:02:09.963]                           muffled <- TRUE
[18:02:09.963]                           break
[18:02:09.963]                         }
[18:02:09.963]                       }
[18:02:09.963]                     }
[18:02:09.963]                     invisible(muffled)
[18:02:09.963]                   }
[18:02:09.963]                   muffleCondition(cond)
[18:02:09.963]                 })
[18:02:09.963]             }))
[18:02:09.963]             future::FutureResult(value = ...future.value$value, 
[18:02:09.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:09.963]                   ...future.rng), globalenv = if (FALSE) 
[18:02:09.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:09.963]                     ...future.globalenv.names))
[18:02:09.963]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:09.963]         }, condition = base::local({
[18:02:09.963]             c <- base::c
[18:02:09.963]             inherits <- base::inherits
[18:02:09.963]             invokeRestart <- base::invokeRestart
[18:02:09.963]             length <- base::length
[18:02:09.963]             list <- base::list
[18:02:09.963]             seq.int <- base::seq.int
[18:02:09.963]             signalCondition <- base::signalCondition
[18:02:09.963]             sys.calls <- base::sys.calls
[18:02:09.963]             `[[` <- base::`[[`
[18:02:09.963]             `+` <- base::`+`
[18:02:09.963]             `<<-` <- base::`<<-`
[18:02:09.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:09.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:09.963]                   3L)]
[18:02:09.963]             }
[18:02:09.963]             function(cond) {
[18:02:09.963]                 is_error <- inherits(cond, "error")
[18:02:09.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:09.963]                   NULL)
[18:02:09.963]                 if (is_error) {
[18:02:09.963]                   sessionInformation <- function() {
[18:02:09.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:09.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:09.963]                       search = base::search(), system = base::Sys.info())
[18:02:09.963]                   }
[18:02:09.963]                   ...future.conditions[[length(...future.conditions) + 
[18:02:09.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:09.963]                     cond$call), session = sessionInformation(), 
[18:02:09.963]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:09.963]                   signalCondition(cond)
[18:02:09.963]                 }
[18:02:09.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:09.963]                 "immediateCondition"))) {
[18:02:09.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:09.963]                   ...future.conditions[[length(...future.conditions) + 
[18:02:09.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:09.963]                   if (TRUE && !signal) {
[18:02:09.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:09.963]                     {
[18:02:09.963]                       inherits <- base::inherits
[18:02:09.963]                       invokeRestart <- base::invokeRestart
[18:02:09.963]                       is.null <- base::is.null
[18:02:09.963]                       muffled <- FALSE
[18:02:09.963]                       if (inherits(cond, "message")) {
[18:02:09.963]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:09.963]                         if (muffled) 
[18:02:09.963]                           invokeRestart("muffleMessage")
[18:02:09.963]                       }
[18:02:09.963]                       else if (inherits(cond, "warning")) {
[18:02:09.963]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:09.963]                         if (muffled) 
[18:02:09.963]                           invokeRestart("muffleWarning")
[18:02:09.963]                       }
[18:02:09.963]                       else if (inherits(cond, "condition")) {
[18:02:09.963]                         if (!is.null(pattern)) {
[18:02:09.963]                           computeRestarts <- base::computeRestarts
[18:02:09.963]                           grepl <- base::grepl
[18:02:09.963]                           restarts <- computeRestarts(cond)
[18:02:09.963]                           for (restart in restarts) {
[18:02:09.963]                             name <- restart$name
[18:02:09.963]                             if (is.null(name)) 
[18:02:09.963]                               next
[18:02:09.963]                             if (!grepl(pattern, name)) 
[18:02:09.963]                               next
[18:02:09.963]                             invokeRestart(restart)
[18:02:09.963]                             muffled <- TRUE
[18:02:09.963]                             break
[18:02:09.963]                           }
[18:02:09.963]                         }
[18:02:09.963]                       }
[18:02:09.963]                       invisible(muffled)
[18:02:09.963]                     }
[18:02:09.963]                     muffleCondition(cond, pattern = "^muffle")
[18:02:09.963]                   }
[18:02:09.963]                 }
[18:02:09.963]                 else {
[18:02:09.963]                   if (TRUE) {
[18:02:09.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:09.963]                     {
[18:02:09.963]                       inherits <- base::inherits
[18:02:09.963]                       invokeRestart <- base::invokeRestart
[18:02:09.963]                       is.null <- base::is.null
[18:02:09.963]                       muffled <- FALSE
[18:02:09.963]                       if (inherits(cond, "message")) {
[18:02:09.963]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:09.963]                         if (muffled) 
[18:02:09.963]                           invokeRestart("muffleMessage")
[18:02:09.963]                       }
[18:02:09.963]                       else if (inherits(cond, "warning")) {
[18:02:09.963]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:09.963]                         if (muffled) 
[18:02:09.963]                           invokeRestart("muffleWarning")
[18:02:09.963]                       }
[18:02:09.963]                       else if (inherits(cond, "condition")) {
[18:02:09.963]                         if (!is.null(pattern)) {
[18:02:09.963]                           computeRestarts <- base::computeRestarts
[18:02:09.963]                           grepl <- base::grepl
[18:02:09.963]                           restarts <- computeRestarts(cond)
[18:02:09.963]                           for (restart in restarts) {
[18:02:09.963]                             name <- restart$name
[18:02:09.963]                             if (is.null(name)) 
[18:02:09.963]                               next
[18:02:09.963]                             if (!grepl(pattern, name)) 
[18:02:09.963]                               next
[18:02:09.963]                             invokeRestart(restart)
[18:02:09.963]                             muffled <- TRUE
[18:02:09.963]                             break
[18:02:09.963]                           }
[18:02:09.963]                         }
[18:02:09.963]                       }
[18:02:09.963]                       invisible(muffled)
[18:02:09.963]                     }
[18:02:09.963]                     muffleCondition(cond, pattern = "^muffle")
[18:02:09.963]                   }
[18:02:09.963]                 }
[18:02:09.963]             }
[18:02:09.963]         }))
[18:02:09.963]     }, error = function(ex) {
[18:02:09.963]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:09.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:09.963]                 ...future.rng), started = ...future.startTime, 
[18:02:09.963]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:09.963]             version = "1.8"), class = "FutureResult")
[18:02:09.963]     }, finally = {
[18:02:09.963]         if (!identical(...future.workdir, getwd())) 
[18:02:09.963]             setwd(...future.workdir)
[18:02:09.963]         {
[18:02:09.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:09.963]                 ...future.oldOptions$nwarnings <- NULL
[18:02:09.963]             }
[18:02:09.963]             base::options(...future.oldOptions)
[18:02:09.963]             if (.Platform$OS.type == "windows") {
[18:02:09.963]                 old_names <- names(...future.oldEnvVars)
[18:02:09.963]                 envs <- base::Sys.getenv()
[18:02:09.963]                 names <- names(envs)
[18:02:09.963]                 common <- intersect(names, old_names)
[18:02:09.963]                 added <- setdiff(names, old_names)
[18:02:09.963]                 removed <- setdiff(old_names, names)
[18:02:09.963]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:09.963]                   envs[common]]
[18:02:09.963]                 NAMES <- toupper(changed)
[18:02:09.963]                 args <- list()
[18:02:09.963]                 for (kk in seq_along(NAMES)) {
[18:02:09.963]                   name <- changed[[kk]]
[18:02:09.963]                   NAME <- NAMES[[kk]]
[18:02:09.963]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:09.963]                     next
[18:02:09.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:09.963]                 }
[18:02:09.963]                 NAMES <- toupper(added)
[18:02:09.963]                 for (kk in seq_along(NAMES)) {
[18:02:09.963]                   name <- added[[kk]]
[18:02:09.963]                   NAME <- NAMES[[kk]]
[18:02:09.963]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:09.963]                     next
[18:02:09.963]                   args[[name]] <- ""
[18:02:09.963]                 }
[18:02:09.963]                 NAMES <- toupper(removed)
[18:02:09.963]                 for (kk in seq_along(NAMES)) {
[18:02:09.963]                   name <- removed[[kk]]
[18:02:09.963]                   NAME <- NAMES[[kk]]
[18:02:09.963]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:09.963]                     next
[18:02:09.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:09.963]                 }
[18:02:09.963]                 if (length(args) > 0) 
[18:02:09.963]                   base::do.call(base::Sys.setenv, args = args)
[18:02:09.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:09.963]             }
[18:02:09.963]             else {
[18:02:09.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:09.963]             }
[18:02:09.963]             {
[18:02:09.963]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:09.963]                   0L) {
[18:02:09.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:09.963]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:09.963]                   base::options(opts)
[18:02:09.963]                 }
[18:02:09.963]                 {
[18:02:09.963]                   {
[18:02:09.963]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:09.963]                     NULL
[18:02:09.963]                   }
[18:02:09.963]                   options(future.plan = NULL)
[18:02:09.963]                   if (is.na(NA_character_)) 
[18:02:09.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:09.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:09.963]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:09.963]                     .init = FALSE)
[18:02:09.963]                 }
[18:02:09.963]             }
[18:02:09.963]         }
[18:02:09.963]     })
[18:02:09.963]     if (TRUE) {
[18:02:09.963]         base::sink(type = "output", split = FALSE)
[18:02:09.963]         if (TRUE) {
[18:02:09.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:09.963]         }
[18:02:09.963]         else {
[18:02:09.963]             ...future.result["stdout"] <- base::list(NULL)
[18:02:09.963]         }
[18:02:09.963]         base::close(...future.stdout)
[18:02:09.963]         ...future.stdout <- NULL
[18:02:09.963]     }
[18:02:09.963]     ...future.result$conditions <- ...future.conditions
[18:02:09.963]     ...future.result$finished <- base::Sys.time()
[18:02:09.963]     ...future.result
[18:02:09.963] }
[18:02:09.969] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[18:02:09.969] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[18:02:10.010] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[18:02:10.011] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[18:02:10.012] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[18:02:10.012] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[18:02:10.013] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[18:02:10.013] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[18:02:10.055] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[18:02:10.056] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[18:02:10.097] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[18:02:10.098] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[18:02:10.099] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[18:02:10.100] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[18:02:10.101] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[18:02:10.102] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:10.103] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:10.103] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[18:02:10.104] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[18:02:10.105] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:10.106] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:10.106] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:10.107] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:10.108] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[18:02:10.109] MultisessionFuture started
[18:02:10.110] - Launch lazy future ... done
[18:02:10.110] run() for ‘MultisessionFuture’ ... done
[18:02:10.110] Created future:
[18:02:10.111] MultisessionFuture:
[18:02:10.111] Label: ‘future_vapply-1’
[18:02:10.111] Expression:
[18:02:10.111] {
[18:02:10.111]     do.call(function(...) {
[18:02:10.111]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:10.111]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:10.111]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:10.111]             on.exit(options(oopts), add = TRUE)
[18:02:10.111]         }
[18:02:10.111]         {
[18:02:10.111]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:10.111]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:10.111]                 ...future.FUN(...future.X_jj, ...)
[18:02:10.111]             })
[18:02:10.111]         }
[18:02:10.111]     }, args = future.call.arguments)
[18:02:10.111] }
[18:02:10.111] Lazy evaluation: FALSE
[18:02:10.111] Asynchronous evaluation: TRUE
[18:02:10.111] Local evaluation: TRUE
[18:02:10.111] Environment: R_GlobalEnv
[18:02:10.111] Capture standard output: TRUE
[18:02:10.111] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:10.111] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:10.111] Packages: 1 packages (‘future.apply’)
[18:02:10.111] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:10.111] Resolved: FALSE
[18:02:10.111] Value: <not collected>
[18:02:10.111] Conditions captured: <none>
[18:02:10.111] Early signaling: FALSE
[18:02:10.111] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:10.111] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:10.126] Chunk #1 of 2 ... DONE
[18:02:10.126] Chunk #2 of 2 ...
[18:02:10.126]  - Finding globals in 'X' for chunk #2 ...
[18:02:10.127] getGlobalsAndPackages() ...
[18:02:10.127] Searching for globals...
[18:02:10.128] 
[18:02:10.128] Searching for globals ... DONE
[18:02:10.128] - globals: [0] <none>
[18:02:10.129] getGlobalsAndPackages() ... DONE
[18:02:10.129]    + additional globals found: [n=0] 
[18:02:10.129]    + additional namespaces needed: [n=0] 
[18:02:10.130]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:10.130]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:10.130]  - seeds: <none>
[18:02:10.131]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:10.131] getGlobalsAndPackages() ...
[18:02:10.131] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:10.132] Resolving globals: FALSE
[18:02:10.133] Tweak future expression to call with '...' arguments ...
[18:02:10.133] {
[18:02:10.133]     do.call(function(...) {
[18:02:10.133]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:10.133]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:10.133]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:10.133]             on.exit(options(oopts), add = TRUE)
[18:02:10.133]         }
[18:02:10.133]         {
[18:02:10.133]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:10.133]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:10.133]                 ...future.FUN(...future.X_jj, ...)
[18:02:10.133]             })
[18:02:10.133]         }
[18:02:10.133]     }, args = future.call.arguments)
[18:02:10.133] }
[18:02:10.134] Tweak future expression to call with '...' arguments ... DONE
[18:02:10.135] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:10.136] - packages: [1] ‘future.apply’
[18:02:10.136] getGlobalsAndPackages() ... DONE
[18:02:10.137] run() for ‘Future’ ...
[18:02:10.137] - state: ‘created’
[18:02:10.138] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:10.174] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:10.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:10.175]   - Field: ‘node’
[18:02:10.175]   - Field: ‘label’
[18:02:10.175]   - Field: ‘local’
[18:02:10.175]   - Field: ‘owner’
[18:02:10.176]   - Field: ‘envir’
[18:02:10.176]   - Field: ‘workers’
[18:02:10.176]   - Field: ‘packages’
[18:02:10.177]   - Field: ‘gc’
[18:02:10.177]   - Field: ‘conditions’
[18:02:10.177]   - Field: ‘persistent’
[18:02:10.177]   - Field: ‘expr’
[18:02:10.178]   - Field: ‘uuid’
[18:02:10.178]   - Field: ‘seed’
[18:02:10.178]   - Field: ‘version’
[18:02:10.179]   - Field: ‘result’
[18:02:10.179]   - Field: ‘asynchronous’
[18:02:10.179]   - Field: ‘calls’
[18:02:10.179]   - Field: ‘globals’
[18:02:10.180]   - Field: ‘stdout’
[18:02:10.180]   - Field: ‘earlySignal’
[18:02:10.180]   - Field: ‘lazy’
[18:02:10.180]   - Field: ‘state’
[18:02:10.181] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:10.181] - Launch lazy future ...
[18:02:10.182] Packages needed by the future expression (n = 1): ‘future.apply’
[18:02:10.182] Packages needed by future strategies (n = 0): <none>
[18:02:10.183] {
[18:02:10.183]     {
[18:02:10.183]         {
[18:02:10.183]             ...future.startTime <- base::Sys.time()
[18:02:10.183]             {
[18:02:10.183]                 {
[18:02:10.183]                   {
[18:02:10.183]                     {
[18:02:10.183]                       {
[18:02:10.183]                         base::local({
[18:02:10.183]                           has_future <- base::requireNamespace("future", 
[18:02:10.183]                             quietly = TRUE)
[18:02:10.183]                           if (has_future) {
[18:02:10.183]                             ns <- base::getNamespace("future")
[18:02:10.183]                             version <- ns[[".package"]][["version"]]
[18:02:10.183]                             if (is.null(version)) 
[18:02:10.183]                               version <- utils::packageVersion("future")
[18:02:10.183]                           }
[18:02:10.183]                           else {
[18:02:10.183]                             version <- NULL
[18:02:10.183]                           }
[18:02:10.183]                           if (!has_future || version < "1.8.0") {
[18:02:10.183]                             info <- base::c(r_version = base::gsub("R version ", 
[18:02:10.183]                               "", base::R.version$version.string), 
[18:02:10.183]                               platform = base::sprintf("%s (%s-bit)", 
[18:02:10.183]                                 base::R.version$platform, 8 * 
[18:02:10.183]                                   base::.Machine$sizeof.pointer), 
[18:02:10.183]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:10.183]                                 "release", "version")], collapse = " "), 
[18:02:10.183]                               hostname = base::Sys.info()[["nodename"]])
[18:02:10.183]                             info <- base::sprintf("%s: %s", base::names(info), 
[18:02:10.183]                               info)
[18:02:10.183]                             info <- base::paste(info, collapse = "; ")
[18:02:10.183]                             if (!has_future) {
[18:02:10.183]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:10.183]                                 info)
[18:02:10.183]                             }
[18:02:10.183]                             else {
[18:02:10.183]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:10.183]                                 info, version)
[18:02:10.183]                             }
[18:02:10.183]                             base::stop(msg)
[18:02:10.183]                           }
[18:02:10.183]                         })
[18:02:10.183]                       }
[18:02:10.183]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:10.183]                       base::options(mc.cores = 1L)
[18:02:10.183]                     }
[18:02:10.183]                     base::local({
[18:02:10.183]                       for (pkg in "future.apply") {
[18:02:10.183]                         base::loadNamespace(pkg)
[18:02:10.183]                         base::library(pkg, character.only = TRUE)
[18:02:10.183]                       }
[18:02:10.183]                     })
[18:02:10.183]                   }
[18:02:10.183]                   ...future.strategy.old <- future::plan("list")
[18:02:10.183]                   options(future.plan = NULL)
[18:02:10.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:10.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:10.183]                 }
[18:02:10.183]                 ...future.workdir <- getwd()
[18:02:10.183]             }
[18:02:10.183]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:10.183]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:10.183]         }
[18:02:10.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:10.183]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:10.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:10.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:10.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:10.183]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:10.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:10.183]             base::names(...future.oldOptions))
[18:02:10.183]     }
[18:02:10.183]     if (FALSE) {
[18:02:10.183]     }
[18:02:10.183]     else {
[18:02:10.183]         if (TRUE) {
[18:02:10.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:10.183]                 open = "w")
[18:02:10.183]         }
[18:02:10.183]         else {
[18:02:10.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:10.183]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:10.183]         }
[18:02:10.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:10.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:10.183]             base::sink(type = "output", split = FALSE)
[18:02:10.183]             base::close(...future.stdout)
[18:02:10.183]         }, add = TRUE)
[18:02:10.183]     }
[18:02:10.183]     ...future.frame <- base::sys.nframe()
[18:02:10.183]     ...future.conditions <- base::list()
[18:02:10.183]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:10.183]     if (FALSE) {
[18:02:10.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:10.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:10.183]     }
[18:02:10.183]     ...future.result <- base::tryCatch({
[18:02:10.183]         base::withCallingHandlers({
[18:02:10.183]             ...future.value <- base::withVisible(base::local({
[18:02:10.183]                 ...future.makeSendCondition <- base::local({
[18:02:10.183]                   sendCondition <- NULL
[18:02:10.183]                   function(frame = 1L) {
[18:02:10.183]                     if (is.function(sendCondition)) 
[18:02:10.183]                       return(sendCondition)
[18:02:10.183]                     ns <- getNamespace("parallel")
[18:02:10.183]                     if (exists("sendData", mode = "function", 
[18:02:10.183]                       envir = ns)) {
[18:02:10.183]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:10.183]                         envir = ns)
[18:02:10.183]                       envir <- sys.frame(frame)
[18:02:10.183]                       master <- NULL
[18:02:10.183]                       while (!identical(envir, .GlobalEnv) && 
[18:02:10.183]                         !identical(envir, emptyenv())) {
[18:02:10.183]                         if (exists("master", mode = "list", envir = envir, 
[18:02:10.183]                           inherits = FALSE)) {
[18:02:10.183]                           master <- get("master", mode = "list", 
[18:02:10.183]                             envir = envir, inherits = FALSE)
[18:02:10.183]                           if (inherits(master, c("SOCKnode", 
[18:02:10.183]                             "SOCK0node"))) {
[18:02:10.183]                             sendCondition <<- function(cond) {
[18:02:10.183]                               data <- list(type = "VALUE", value = cond, 
[18:02:10.183]                                 success = TRUE)
[18:02:10.183]                               parallel_sendData(master, data)
[18:02:10.183]                             }
[18:02:10.183]                             return(sendCondition)
[18:02:10.183]                           }
[18:02:10.183]                         }
[18:02:10.183]                         frame <- frame + 1L
[18:02:10.183]                         envir <- sys.frame(frame)
[18:02:10.183]                       }
[18:02:10.183]                     }
[18:02:10.183]                     sendCondition <<- function(cond) NULL
[18:02:10.183]                   }
[18:02:10.183]                 })
[18:02:10.183]                 withCallingHandlers({
[18:02:10.183]                   {
[18:02:10.183]                     do.call(function(...) {
[18:02:10.183]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:10.183]                       if (!identical(...future.globals.maxSize.org, 
[18:02:10.183]                         ...future.globals.maxSize)) {
[18:02:10.183]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:10.183]                         on.exit(options(oopts), add = TRUE)
[18:02:10.183]                       }
[18:02:10.183]                       {
[18:02:10.183]                         lapply(seq_along(...future.elements_ii), 
[18:02:10.183]                           FUN = function(jj) {
[18:02:10.183]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:10.183]                             ...future.FUN(...future.X_jj, ...)
[18:02:10.183]                           })
[18:02:10.183]                       }
[18:02:10.183]                     }, args = future.call.arguments)
[18:02:10.183]                   }
[18:02:10.183]                 }, immediateCondition = function(cond) {
[18:02:10.183]                   sendCondition <- ...future.makeSendCondition()
[18:02:10.183]                   sendCondition(cond)
[18:02:10.183]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:10.183]                   {
[18:02:10.183]                     inherits <- base::inherits
[18:02:10.183]                     invokeRestart <- base::invokeRestart
[18:02:10.183]                     is.null <- base::is.null
[18:02:10.183]                     muffled <- FALSE
[18:02:10.183]                     if (inherits(cond, "message")) {
[18:02:10.183]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:10.183]                       if (muffled) 
[18:02:10.183]                         invokeRestart("muffleMessage")
[18:02:10.183]                     }
[18:02:10.183]                     else if (inherits(cond, "warning")) {
[18:02:10.183]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:10.183]                       if (muffled) 
[18:02:10.183]                         invokeRestart("muffleWarning")
[18:02:10.183]                     }
[18:02:10.183]                     else if (inherits(cond, "condition")) {
[18:02:10.183]                       if (!is.null(pattern)) {
[18:02:10.183]                         computeRestarts <- base::computeRestarts
[18:02:10.183]                         grepl <- base::grepl
[18:02:10.183]                         restarts <- computeRestarts(cond)
[18:02:10.183]                         for (restart in restarts) {
[18:02:10.183]                           name <- restart$name
[18:02:10.183]                           if (is.null(name)) 
[18:02:10.183]                             next
[18:02:10.183]                           if (!grepl(pattern, name)) 
[18:02:10.183]                             next
[18:02:10.183]                           invokeRestart(restart)
[18:02:10.183]                           muffled <- TRUE
[18:02:10.183]                           break
[18:02:10.183]                         }
[18:02:10.183]                       }
[18:02:10.183]                     }
[18:02:10.183]                     invisible(muffled)
[18:02:10.183]                   }
[18:02:10.183]                   muffleCondition(cond)
[18:02:10.183]                 })
[18:02:10.183]             }))
[18:02:10.183]             future::FutureResult(value = ...future.value$value, 
[18:02:10.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:10.183]                   ...future.rng), globalenv = if (FALSE) 
[18:02:10.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:10.183]                     ...future.globalenv.names))
[18:02:10.183]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:10.183]         }, condition = base::local({
[18:02:10.183]             c <- base::c
[18:02:10.183]             inherits <- base::inherits
[18:02:10.183]             invokeRestart <- base::invokeRestart
[18:02:10.183]             length <- base::length
[18:02:10.183]             list <- base::list
[18:02:10.183]             seq.int <- base::seq.int
[18:02:10.183]             signalCondition <- base::signalCondition
[18:02:10.183]             sys.calls <- base::sys.calls
[18:02:10.183]             `[[` <- base::`[[`
[18:02:10.183]             `+` <- base::`+`
[18:02:10.183]             `<<-` <- base::`<<-`
[18:02:10.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:10.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:10.183]                   3L)]
[18:02:10.183]             }
[18:02:10.183]             function(cond) {
[18:02:10.183]                 is_error <- inherits(cond, "error")
[18:02:10.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:10.183]                   NULL)
[18:02:10.183]                 if (is_error) {
[18:02:10.183]                   sessionInformation <- function() {
[18:02:10.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:10.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:10.183]                       search = base::search(), system = base::Sys.info())
[18:02:10.183]                   }
[18:02:10.183]                   ...future.conditions[[length(...future.conditions) + 
[18:02:10.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:10.183]                     cond$call), session = sessionInformation(), 
[18:02:10.183]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:10.183]                   signalCondition(cond)
[18:02:10.183]                 }
[18:02:10.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:10.183]                 "immediateCondition"))) {
[18:02:10.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:10.183]                   ...future.conditions[[length(...future.conditions) + 
[18:02:10.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:10.183]                   if (TRUE && !signal) {
[18:02:10.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:10.183]                     {
[18:02:10.183]                       inherits <- base::inherits
[18:02:10.183]                       invokeRestart <- base::invokeRestart
[18:02:10.183]                       is.null <- base::is.null
[18:02:10.183]                       muffled <- FALSE
[18:02:10.183]                       if (inherits(cond, "message")) {
[18:02:10.183]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:10.183]                         if (muffled) 
[18:02:10.183]                           invokeRestart("muffleMessage")
[18:02:10.183]                       }
[18:02:10.183]                       else if (inherits(cond, "warning")) {
[18:02:10.183]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:10.183]                         if (muffled) 
[18:02:10.183]                           invokeRestart("muffleWarning")
[18:02:10.183]                       }
[18:02:10.183]                       else if (inherits(cond, "condition")) {
[18:02:10.183]                         if (!is.null(pattern)) {
[18:02:10.183]                           computeRestarts <- base::computeRestarts
[18:02:10.183]                           grepl <- base::grepl
[18:02:10.183]                           restarts <- computeRestarts(cond)
[18:02:10.183]                           for (restart in restarts) {
[18:02:10.183]                             name <- restart$name
[18:02:10.183]                             if (is.null(name)) 
[18:02:10.183]                               next
[18:02:10.183]                             if (!grepl(pattern, name)) 
[18:02:10.183]                               next
[18:02:10.183]                             invokeRestart(restart)
[18:02:10.183]                             muffled <- TRUE
[18:02:10.183]                             break
[18:02:10.183]                           }
[18:02:10.183]                         }
[18:02:10.183]                       }
[18:02:10.183]                       invisible(muffled)
[18:02:10.183]                     }
[18:02:10.183]                     muffleCondition(cond, pattern = "^muffle")
[18:02:10.183]                   }
[18:02:10.183]                 }
[18:02:10.183]                 else {
[18:02:10.183]                   if (TRUE) {
[18:02:10.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:10.183]                     {
[18:02:10.183]                       inherits <- base::inherits
[18:02:10.183]                       invokeRestart <- base::invokeRestart
[18:02:10.183]                       is.null <- base::is.null
[18:02:10.183]                       muffled <- FALSE
[18:02:10.183]                       if (inherits(cond, "message")) {
[18:02:10.183]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:10.183]                         if (muffled) 
[18:02:10.183]                           invokeRestart("muffleMessage")
[18:02:10.183]                       }
[18:02:10.183]                       else if (inherits(cond, "warning")) {
[18:02:10.183]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:10.183]                         if (muffled) 
[18:02:10.183]                           invokeRestart("muffleWarning")
[18:02:10.183]                       }
[18:02:10.183]                       else if (inherits(cond, "condition")) {
[18:02:10.183]                         if (!is.null(pattern)) {
[18:02:10.183]                           computeRestarts <- base::computeRestarts
[18:02:10.183]                           grepl <- base::grepl
[18:02:10.183]                           restarts <- computeRestarts(cond)
[18:02:10.183]                           for (restart in restarts) {
[18:02:10.183]                             name <- restart$name
[18:02:10.183]                             if (is.null(name)) 
[18:02:10.183]                               next
[18:02:10.183]                             if (!grepl(pattern, name)) 
[18:02:10.183]                               next
[18:02:10.183]                             invokeRestart(restart)
[18:02:10.183]                             muffled <- TRUE
[18:02:10.183]                             break
[18:02:10.183]                           }
[18:02:10.183]                         }
[18:02:10.183]                       }
[18:02:10.183]                       invisible(muffled)
[18:02:10.183]                     }
[18:02:10.183]                     muffleCondition(cond, pattern = "^muffle")
[18:02:10.183]                   }
[18:02:10.183]                 }
[18:02:10.183]             }
[18:02:10.183]         }))
[18:02:10.183]     }, error = function(ex) {
[18:02:10.183]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:10.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:10.183]                 ...future.rng), started = ...future.startTime, 
[18:02:10.183]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:10.183]             version = "1.8"), class = "FutureResult")
[18:02:10.183]     }, finally = {
[18:02:10.183]         if (!identical(...future.workdir, getwd())) 
[18:02:10.183]             setwd(...future.workdir)
[18:02:10.183]         {
[18:02:10.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:10.183]                 ...future.oldOptions$nwarnings <- NULL
[18:02:10.183]             }
[18:02:10.183]             base::options(...future.oldOptions)
[18:02:10.183]             if (.Platform$OS.type == "windows") {
[18:02:10.183]                 old_names <- names(...future.oldEnvVars)
[18:02:10.183]                 envs <- base::Sys.getenv()
[18:02:10.183]                 names <- names(envs)
[18:02:10.183]                 common <- intersect(names, old_names)
[18:02:10.183]                 added <- setdiff(names, old_names)
[18:02:10.183]                 removed <- setdiff(old_names, names)
[18:02:10.183]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:10.183]                   envs[common]]
[18:02:10.183]                 NAMES <- toupper(changed)
[18:02:10.183]                 args <- list()
[18:02:10.183]                 for (kk in seq_along(NAMES)) {
[18:02:10.183]                   name <- changed[[kk]]
[18:02:10.183]                   NAME <- NAMES[[kk]]
[18:02:10.183]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:10.183]                     next
[18:02:10.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:10.183]                 }
[18:02:10.183]                 NAMES <- toupper(added)
[18:02:10.183]                 for (kk in seq_along(NAMES)) {
[18:02:10.183]                   name <- added[[kk]]
[18:02:10.183]                   NAME <- NAMES[[kk]]
[18:02:10.183]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:10.183]                     next
[18:02:10.183]                   args[[name]] <- ""
[18:02:10.183]                 }
[18:02:10.183]                 NAMES <- toupper(removed)
[18:02:10.183]                 for (kk in seq_along(NAMES)) {
[18:02:10.183]                   name <- removed[[kk]]
[18:02:10.183]                   NAME <- NAMES[[kk]]
[18:02:10.183]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:10.183]                     next
[18:02:10.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:10.183]                 }
[18:02:10.183]                 if (length(args) > 0) 
[18:02:10.183]                   base::do.call(base::Sys.setenv, args = args)
[18:02:10.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:10.183]             }
[18:02:10.183]             else {
[18:02:10.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:10.183]             }
[18:02:10.183]             {
[18:02:10.183]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:10.183]                   0L) {
[18:02:10.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:10.183]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:10.183]                   base::options(opts)
[18:02:10.183]                 }
[18:02:10.183]                 {
[18:02:10.183]                   {
[18:02:10.183]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:10.183]                     NULL
[18:02:10.183]                   }
[18:02:10.183]                   options(future.plan = NULL)
[18:02:10.183]                   if (is.na(NA_character_)) 
[18:02:10.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:10.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:10.183]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:10.183]                     .init = FALSE)
[18:02:10.183]                 }
[18:02:10.183]             }
[18:02:10.183]         }
[18:02:10.183]     })
[18:02:10.183]     if (TRUE) {
[18:02:10.183]         base::sink(type = "output", split = FALSE)
[18:02:10.183]         if (TRUE) {
[18:02:10.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:10.183]         }
[18:02:10.183]         else {
[18:02:10.183]             ...future.result["stdout"] <- base::list(NULL)
[18:02:10.183]         }
[18:02:10.183]         base::close(...future.stdout)
[18:02:10.183]         ...future.stdout <- NULL
[18:02:10.183]     }
[18:02:10.183]     ...future.result$conditions <- ...future.conditions
[18:02:10.183]     ...future.result$finished <- base::Sys.time()
[18:02:10.183]     ...future.result
[18:02:10.183] }
[18:02:10.190] Exporting 11 global objects (92.90 KiB) to cluster node #2 ...
[18:02:10.190] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[18:02:10.233] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[18:02:10.234] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ...
[18:02:10.235] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ... DONE
[18:02:10.235] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[18:02:10.236] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[18:02:10.237] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[18:02:10.278] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[18:02:10.279] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[18:02:10.320] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[18:02:10.321] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[18:02:10.322] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[18:02:10.323] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[18:02:10.324] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[18:02:10.325] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:10.326] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:10.326] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[18:02:10.327] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[18:02:10.328] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:10.329] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:10.329] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:10.330] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:10.331] Exporting 11 global objects (92.90 KiB) to cluster node #2 ... DONE
[18:02:10.332] MultisessionFuture started
[18:02:10.333] - Launch lazy future ... done
[18:02:10.333] run() for ‘MultisessionFuture’ ... done
[18:02:10.334] Created future:
[18:02:10.334] MultisessionFuture:
[18:02:10.334] Label: ‘future_vapply-2’
[18:02:10.334] Expression:
[18:02:10.334] {
[18:02:10.334]     do.call(function(...) {
[18:02:10.334]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:10.334]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:10.334]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:10.334]             on.exit(options(oopts), add = TRUE)
[18:02:10.334]         }
[18:02:10.334]         {
[18:02:10.334]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:10.334]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:10.334]                 ...future.FUN(...future.X_jj, ...)
[18:02:10.334]             })
[18:02:10.334]         }
[18:02:10.334]     }, args = future.call.arguments)
[18:02:10.334] }
[18:02:10.334] Lazy evaluation: FALSE
[18:02:10.334] Asynchronous evaluation: TRUE
[18:02:10.334] Local evaluation: TRUE
[18:02:10.334] Environment: R_GlobalEnv
[18:02:10.334] Capture standard output: TRUE
[18:02:10.334] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:10.334] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[18:02:10.334] Packages: 1 packages (‘future.apply’)
[18:02:10.334] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:10.334] Resolved: FALSE
[18:02:10.334] Value: <not collected>
[18:02:10.334] Conditions captured: <none>
[18:02:10.334] Early signaling: FALSE
[18:02:10.334] Owner process: b6c8f4b5-6889-40e8-f243-1b825bf44a49
[18:02:10.334] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:10.349] Chunk #2 of 2 ... DONE
[18:02:10.349] Launching 2 futures (chunks) ... DONE
[18:02:10.350] Resolving 2 futures (chunks) ...
[18:02:10.350] resolve() on list ...
[18:02:10.350]  recursive: 0
[18:02:10.351]  length: 2
[18:02:10.351] 
[18:02:10.353] receiveMessageFromWorker() for ClusterFuture ...
[18:02:10.353] - Validating connection of MultisessionFuture
[18:02:10.354] - received message: FutureResult
[18:02:10.355] - Received FutureResult
[18:02:10.355] - Erased future from FutureRegistry
[18:02:10.356] result() for ClusterFuture ...
[18:02:10.356] - result already collected: FutureResult
[18:02:10.356] result() for ClusterFuture ... done
[18:02:10.356] signalConditions() ...
[18:02:10.357]  - include = ‘immediateCondition’
[18:02:10.357]  - exclude = 
[18:02:10.357]  - resignal = FALSE
[18:02:10.358]  - Number of conditions: 1
[18:02:10.358] signalConditions() ... done
[18:02:10.358] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:10.359] Future #1
[18:02:10.359] result() for ClusterFuture ...
[18:02:10.359] - result already collected: FutureResult
[18:02:10.360] result() for ClusterFuture ... done
[18:02:10.360] result() for ClusterFuture ...
[18:02:10.360] - result already collected: FutureResult
[18:02:10.360] result() for ClusterFuture ... done
[18:02:10.361] signalConditions() ...
[18:02:10.361]  - include = ‘immediateCondition’
[18:02:10.361]  - exclude = 
[18:02:10.362]  - resignal = FALSE
[18:02:10.362]  - Number of conditions: 1
[18:02:10.362] signalConditions() ... done
[18:02:10.363] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:10.363] - nx: 2
[18:02:10.363] - relay: TRUE
[18:02:10.364] - stdout: TRUE
[18:02:10.364] - signal: TRUE
[18:02:10.364] - resignal: FALSE
[18:02:10.364] - force: TRUE
[18:02:10.365] - relayed: [n=2] FALSE, FALSE
[18:02:10.365] - queued futures: [n=2] FALSE, FALSE
[18:02:10.365]  - until=1
[18:02:10.366]  - relaying element #1
[18:02:10.366] result() for ClusterFuture ...
[18:02:10.366] - result already collected: FutureResult
[18:02:10.367] result() for ClusterFuture ... done
[18:02:10.367] result() for ClusterFuture ...
[18:02:10.367] - result already collected: FutureResult
[18:02:10.367] result() for ClusterFuture ... done
[18:02:10.368] signalConditions() ...
[18:02:10.368]  - include = ‘immediateCondition’
[18:02:10.368]  - exclude = 
[18:02:10.369]  - resignal = FALSE
[18:02:10.369]  - Number of conditions: 1
[18:02:10.369] signalConditions() ... done
[18:02:10.370] result() for ClusterFuture ...
[18:02:10.370] - result already collected: FutureResult
[18:02:10.370] result() for ClusterFuture ... done
[18:02:10.371] signalConditions() ...
[18:02:10.371]  - include = ‘immediateCondition’
[18:02:10.371]  - exclude = 
[18:02:10.372]  - resignal = FALSE
[18:02:10.372]  - Number of conditions: 1
[18:02:10.372] signalConditions() ... done
[18:02:10.373] result() for ClusterFuture ...
[18:02:10.373] - result already collected: FutureResult
[18:02:10.373] result() for ClusterFuture ... done
[18:02:10.374] signalConditions() ...
[18:02:10.374]  - include = ‘condition’
[18:02:10.374]  - exclude = ‘immediateCondition’
[18:02:10.375]  - resignal = TRUE
[18:02:10.375]  - Number of conditions: 1
[18:02:10.375]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[18:02:10.376] signalConditions() ... done
[18:02:10.376] - relayed: [n=2] FALSE, FALSE
[18:02:10.376] - queued futures: [n=2] TRUE, FALSE
[18:02:10.376] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:10.377] plan(): Setting new future strategy stack:
[18:02:10.377] List of future strategies:
[18:02:10.377] 1. sequential:
[18:02:10.377]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:10.377]    - tweaked: FALSE
[18:02:10.377]    - call: plan(sequential)
[18:02:10.379] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[18:02:10.382] plan(): Setting new future strategy stack:
[18:02:10.384] List of future strategies:
[18:02:10.384] 1. FutureStrategy:
[18:02:10.384]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:10.384]    - tweaked: FALSE
[18:02:10.384]    - call: future::plan(oplan)
[18:02:10.388] plan(): nbrOfWorkers() = 1
> 
