
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:45:31.622] plan(): Setting new future strategy stack:
[17:45:31.623] List of future strategies:
[17:45:31.623] 1. sequential:
[17:45:31.623]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:31.623]    - tweaked: FALSE
[17:45:31.623]    - call: future::plan("sequential")
[17:45:31.637] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[17:45:31.670] plan(): Setting new future strategy stack:
[17:45:31.670] List of future strategies:
[17:45:31.670] 1. sequential:
[17:45:31.670]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:31.670]    - tweaked: FALSE
[17:45:31.670]    - call: plan(strategy)
[17:45:31.681] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:45:31.681] future_lapply() ...
[17:45:31.685] Number of chunks: 1
[17:45:31.686] getGlobalsAndPackagesXApply() ...
[17:45:31.686]  - future.globals: TRUE
[17:45:31.686] getGlobalsAndPackages() ...
[17:45:31.686] Searching for globals...
[17:45:31.689] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:31.689] Searching for globals ... DONE
[17:45:31.689] Resolving globals: FALSE
[17:45:31.690] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:31.690] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:31.691] - globals: [1] ‘FUN’
[17:45:31.691] 
[17:45:31.691] getGlobalsAndPackages() ... DONE
[17:45:31.691]  - globals found/used: [n=1] ‘FUN’
[17:45:31.691]  - needed namespaces: [n=0] 
[17:45:31.691] Finding globals ... DONE
[17:45:31.691]  - use_args: TRUE
[17:45:31.691]  - Getting '...' globals ...
[17:45:31.692] resolve() on list ...
[17:45:31.692]  recursive: 0
[17:45:31.692]  length: 1
[17:45:31.692]  elements: ‘...’
[17:45:31.693]  length: 0 (resolved future 1)
[17:45:31.693] resolve() on list ... DONE
[17:45:31.693]    - '...' content: [n=0] 
[17:45:31.693] List of 1
[17:45:31.693]  $ ...: list()
[17:45:31.693]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:31.693]  - attr(*, "where")=List of 1
[17:45:31.693]   ..$ ...:<environment: 0x55f6c70d4e08> 
[17:45:31.693]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:31.693]  - attr(*, "resolved")= logi TRUE
[17:45:31.693]  - attr(*, "total_size")= num NA
[17:45:31.697]  - Getting '...' globals ... DONE
[17:45:31.698] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:31.698] List of 2
[17:45:31.698]  $ ...future.FUN:function (x)  
[17:45:31.698]  $ ...          : list()
[17:45:31.698]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:31.698]  - attr(*, "where")=List of 2
[17:45:31.698]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:31.698]   ..$ ...          :<environment: 0x55f6c70d4e08> 
[17:45:31.698]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:31.698]  - attr(*, "resolved")= logi FALSE
[17:45:31.698]  - attr(*, "total_size")= num 4720
[17:45:31.700] Packages to be attached in all futures: [n=0] 
[17:45:31.703] getGlobalsAndPackagesXApply() ... DONE
[17:45:31.703] Number of futures (= number of chunks): 1
[17:45:31.703] Launching 1 futures (chunks) ...
[17:45:31.703] Chunk #1 of 1 ...
[17:45:31.704]  - Finding globals in 'X' for chunk #1 ...
[17:45:31.704] getGlobalsAndPackages() ...
[17:45:31.704] Searching for globals...
[17:45:31.704] 
[17:45:31.704] Searching for globals ... DONE
[17:45:31.704] - globals: [0] <none>
[17:45:31.704] getGlobalsAndPackages() ... DONE
[17:45:31.704]    + additional globals found: [n=0] 
[17:45:31.704]    + additional namespaces needed: [n=0] 
[17:45:31.705]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:31.705]  - seeds: <none>
[17:45:31.705]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:31.705] getGlobalsAndPackages() ...
[17:45:31.705] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:31.705] Resolving globals: FALSE
[17:45:31.705] Tweak future expression to call with '...' arguments ...
[17:45:31.705] {
[17:45:31.705]     do.call(function(...) {
[17:45:31.705]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:31.705]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:31.705]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:31.705]             on.exit(options(oopts), add = TRUE)
[17:45:31.705]         }
[17:45:31.705]         {
[17:45:31.705]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:31.705]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:31.705]                 ...future.FUN(...future.X_jj, ...)
[17:45:31.705]             })
[17:45:31.705]         }
[17:45:31.705]     }, args = future.call.arguments)
[17:45:31.705] }
[17:45:31.706] Tweak future expression to call with '...' arguments ... DONE
[17:45:31.706] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:31.706] 
[17:45:31.706] getGlobalsAndPackages() ... DONE
[17:45:31.707] run() for ‘Future’ ...
[17:45:31.707] - state: ‘created’
[17:45:31.707] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:31.708] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:31.708] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:31.708]   - Field: ‘label’
[17:45:31.708]   - Field: ‘local’
[17:45:31.708]   - Field: ‘owner’
[17:45:31.708]   - Field: ‘envir’
[17:45:31.708]   - Field: ‘packages’
[17:45:31.708]   - Field: ‘gc’
[17:45:31.708]   - Field: ‘conditions’
[17:45:31.709]   - Field: ‘expr’
[17:45:31.709]   - Field: ‘uuid’
[17:45:31.709]   - Field: ‘seed’
[17:45:31.709]   - Field: ‘version’
[17:45:31.709]   - Field: ‘result’
[17:45:31.709]   - Field: ‘asynchronous’
[17:45:31.709]   - Field: ‘calls’
[17:45:31.709]   - Field: ‘globals’
[17:45:31.709]   - Field: ‘stdout’
[17:45:31.709]   - Field: ‘earlySignal’
[17:45:31.710]   - Field: ‘lazy’
[17:45:31.710]   - Field: ‘state’
[17:45:31.710] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:31.710] - Launch lazy future ...
[17:45:31.711] Packages needed by the future expression (n = 0): <none>
[17:45:31.711] Packages needed by future strategies (n = 0): <none>
[17:45:31.711] {
[17:45:31.711]     {
[17:45:31.711]         {
[17:45:31.711]             ...future.startTime <- base::Sys.time()
[17:45:31.711]             {
[17:45:31.711]                 {
[17:45:31.711]                   {
[17:45:31.711]                     base::local({
[17:45:31.711]                       has_future <- base::requireNamespace("future", 
[17:45:31.711]                         quietly = TRUE)
[17:45:31.711]                       if (has_future) {
[17:45:31.711]                         ns <- base::getNamespace("future")
[17:45:31.711]                         version <- ns[[".package"]][["version"]]
[17:45:31.711]                         if (is.null(version)) 
[17:45:31.711]                           version <- utils::packageVersion("future")
[17:45:31.711]                       }
[17:45:31.711]                       else {
[17:45:31.711]                         version <- NULL
[17:45:31.711]                       }
[17:45:31.711]                       if (!has_future || version < "1.8.0") {
[17:45:31.711]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:31.711]                           "", base::R.version$version.string), 
[17:45:31.711]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:31.711]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:31.711]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:31.711]                             "release", "version")], collapse = " "), 
[17:45:31.711]                           hostname = base::Sys.info()[["nodename"]])
[17:45:31.711]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:31.711]                           info)
[17:45:31.711]                         info <- base::paste(info, collapse = "; ")
[17:45:31.711]                         if (!has_future) {
[17:45:31.711]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:31.711]                             info)
[17:45:31.711]                         }
[17:45:31.711]                         else {
[17:45:31.711]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:31.711]                             info, version)
[17:45:31.711]                         }
[17:45:31.711]                         base::stop(msg)
[17:45:31.711]                       }
[17:45:31.711]                     })
[17:45:31.711]                   }
[17:45:31.711]                   ...future.strategy.old <- future::plan("list")
[17:45:31.711]                   options(future.plan = NULL)
[17:45:31.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:31.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:31.711]                 }
[17:45:31.711]                 ...future.workdir <- getwd()
[17:45:31.711]             }
[17:45:31.711]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:31.711]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:31.711]         }
[17:45:31.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:31.711]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:31.711]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:31.711]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:31.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:31.711]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:31.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:31.711]             base::names(...future.oldOptions))
[17:45:31.711]     }
[17:45:31.711]     if (FALSE) {
[17:45:31.711]     }
[17:45:31.711]     else {
[17:45:31.711]         if (FALSE) {
[17:45:31.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:31.711]                 open = "w")
[17:45:31.711]         }
[17:45:31.711]         else {
[17:45:31.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:31.711]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:31.711]         }
[17:45:31.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:31.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:31.711]             base::sink(type = "output", split = FALSE)
[17:45:31.711]             base::close(...future.stdout)
[17:45:31.711]         }, add = TRUE)
[17:45:31.711]     }
[17:45:31.711]     ...future.frame <- base::sys.nframe()
[17:45:31.711]     ...future.conditions <- base::list()
[17:45:31.711]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:31.711]     if (FALSE) {
[17:45:31.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:31.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:31.711]     }
[17:45:31.711]     ...future.result <- base::tryCatch({
[17:45:31.711]         base::withCallingHandlers({
[17:45:31.711]             ...future.value <- base::withVisible(base::local({
[17:45:31.711]                 do.call(function(...) {
[17:45:31.711]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:31.711]                   if (!identical(...future.globals.maxSize.org, 
[17:45:31.711]                     ...future.globals.maxSize)) {
[17:45:31.711]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:31.711]                     on.exit(options(oopts), add = TRUE)
[17:45:31.711]                   }
[17:45:31.711]                   {
[17:45:31.711]                     lapply(seq_along(...future.elements_ii), 
[17:45:31.711]                       FUN = function(jj) {
[17:45:31.711]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:31.711]                         ...future.FUN(...future.X_jj, ...)
[17:45:31.711]                       })
[17:45:31.711]                   }
[17:45:31.711]                 }, args = future.call.arguments)
[17:45:31.711]             }))
[17:45:31.711]             future::FutureResult(value = ...future.value$value, 
[17:45:31.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:31.711]                   ...future.rng), globalenv = if (FALSE) 
[17:45:31.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:31.711]                     ...future.globalenv.names))
[17:45:31.711]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:31.711]         }, condition = base::local({
[17:45:31.711]             c <- base::c
[17:45:31.711]             inherits <- base::inherits
[17:45:31.711]             invokeRestart <- base::invokeRestart
[17:45:31.711]             length <- base::length
[17:45:31.711]             list <- base::list
[17:45:31.711]             seq.int <- base::seq.int
[17:45:31.711]             signalCondition <- base::signalCondition
[17:45:31.711]             sys.calls <- base::sys.calls
[17:45:31.711]             `[[` <- base::`[[`
[17:45:31.711]             `+` <- base::`+`
[17:45:31.711]             `<<-` <- base::`<<-`
[17:45:31.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:31.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:31.711]                   3L)]
[17:45:31.711]             }
[17:45:31.711]             function(cond) {
[17:45:31.711]                 is_error <- inherits(cond, "error")
[17:45:31.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:31.711]                   NULL)
[17:45:31.711]                 if (is_error) {
[17:45:31.711]                   sessionInformation <- function() {
[17:45:31.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:31.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:31.711]                       search = base::search(), system = base::Sys.info())
[17:45:31.711]                   }
[17:45:31.711]                   ...future.conditions[[length(...future.conditions) + 
[17:45:31.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:31.711]                     cond$call), session = sessionInformation(), 
[17:45:31.711]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:31.711]                   signalCondition(cond)
[17:45:31.711]                 }
[17:45:31.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:31.711]                 "immediateCondition"))) {
[17:45:31.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:31.711]                   ...future.conditions[[length(...future.conditions) + 
[17:45:31.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:31.711]                   if (TRUE && !signal) {
[17:45:31.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:31.711]                     {
[17:45:31.711]                       inherits <- base::inherits
[17:45:31.711]                       invokeRestart <- base::invokeRestart
[17:45:31.711]                       is.null <- base::is.null
[17:45:31.711]                       muffled <- FALSE
[17:45:31.711]                       if (inherits(cond, "message")) {
[17:45:31.711]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:31.711]                         if (muffled) 
[17:45:31.711]                           invokeRestart("muffleMessage")
[17:45:31.711]                       }
[17:45:31.711]                       else if (inherits(cond, "warning")) {
[17:45:31.711]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:31.711]                         if (muffled) 
[17:45:31.711]                           invokeRestart("muffleWarning")
[17:45:31.711]                       }
[17:45:31.711]                       else if (inherits(cond, "condition")) {
[17:45:31.711]                         if (!is.null(pattern)) {
[17:45:31.711]                           computeRestarts <- base::computeRestarts
[17:45:31.711]                           grepl <- base::grepl
[17:45:31.711]                           restarts <- computeRestarts(cond)
[17:45:31.711]                           for (restart in restarts) {
[17:45:31.711]                             name <- restart$name
[17:45:31.711]                             if (is.null(name)) 
[17:45:31.711]                               next
[17:45:31.711]                             if (!grepl(pattern, name)) 
[17:45:31.711]                               next
[17:45:31.711]                             invokeRestart(restart)
[17:45:31.711]                             muffled <- TRUE
[17:45:31.711]                             break
[17:45:31.711]                           }
[17:45:31.711]                         }
[17:45:31.711]                       }
[17:45:31.711]                       invisible(muffled)
[17:45:31.711]                     }
[17:45:31.711]                     muffleCondition(cond, pattern = "^muffle")
[17:45:31.711]                   }
[17:45:31.711]                 }
[17:45:31.711]                 else {
[17:45:31.711]                   if (TRUE) {
[17:45:31.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:31.711]                     {
[17:45:31.711]                       inherits <- base::inherits
[17:45:31.711]                       invokeRestart <- base::invokeRestart
[17:45:31.711]                       is.null <- base::is.null
[17:45:31.711]                       muffled <- FALSE
[17:45:31.711]                       if (inherits(cond, "message")) {
[17:45:31.711]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:31.711]                         if (muffled) 
[17:45:31.711]                           invokeRestart("muffleMessage")
[17:45:31.711]                       }
[17:45:31.711]                       else if (inherits(cond, "warning")) {
[17:45:31.711]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:31.711]                         if (muffled) 
[17:45:31.711]                           invokeRestart("muffleWarning")
[17:45:31.711]                       }
[17:45:31.711]                       else if (inherits(cond, "condition")) {
[17:45:31.711]                         if (!is.null(pattern)) {
[17:45:31.711]                           computeRestarts <- base::computeRestarts
[17:45:31.711]                           grepl <- base::grepl
[17:45:31.711]                           restarts <- computeRestarts(cond)
[17:45:31.711]                           for (restart in restarts) {
[17:45:31.711]                             name <- restart$name
[17:45:31.711]                             if (is.null(name)) 
[17:45:31.711]                               next
[17:45:31.711]                             if (!grepl(pattern, name)) 
[17:45:31.711]                               next
[17:45:31.711]                             invokeRestart(restart)
[17:45:31.711]                             muffled <- TRUE
[17:45:31.711]                             break
[17:45:31.711]                           }
[17:45:31.711]                         }
[17:45:31.711]                       }
[17:45:31.711]                       invisible(muffled)
[17:45:31.711]                     }
[17:45:31.711]                     muffleCondition(cond, pattern = "^muffle")
[17:45:31.711]                   }
[17:45:31.711]                 }
[17:45:31.711]             }
[17:45:31.711]         }))
[17:45:31.711]     }, error = function(ex) {
[17:45:31.711]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:31.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:31.711]                 ...future.rng), started = ...future.startTime, 
[17:45:31.711]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:31.711]             version = "1.8"), class = "FutureResult")
[17:45:31.711]     }, finally = {
[17:45:31.711]         if (!identical(...future.workdir, getwd())) 
[17:45:31.711]             setwd(...future.workdir)
[17:45:31.711]         {
[17:45:31.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:31.711]                 ...future.oldOptions$nwarnings <- NULL
[17:45:31.711]             }
[17:45:31.711]             base::options(...future.oldOptions)
[17:45:31.711]             if (.Platform$OS.type == "windows") {
[17:45:31.711]                 old_names <- names(...future.oldEnvVars)
[17:45:31.711]                 envs <- base::Sys.getenv()
[17:45:31.711]                 names <- names(envs)
[17:45:31.711]                 common <- intersect(names, old_names)
[17:45:31.711]                 added <- setdiff(names, old_names)
[17:45:31.711]                 removed <- setdiff(old_names, names)
[17:45:31.711]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:31.711]                   envs[common]]
[17:45:31.711]                 NAMES <- toupper(changed)
[17:45:31.711]                 args <- list()
[17:45:31.711]                 for (kk in seq_along(NAMES)) {
[17:45:31.711]                   name <- changed[[kk]]
[17:45:31.711]                   NAME <- NAMES[[kk]]
[17:45:31.711]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:31.711]                     next
[17:45:31.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:31.711]                 }
[17:45:31.711]                 NAMES <- toupper(added)
[17:45:31.711]                 for (kk in seq_along(NAMES)) {
[17:45:31.711]                   name <- added[[kk]]
[17:45:31.711]                   NAME <- NAMES[[kk]]
[17:45:31.711]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:31.711]                     next
[17:45:31.711]                   args[[name]] <- ""
[17:45:31.711]                 }
[17:45:31.711]                 NAMES <- toupper(removed)
[17:45:31.711]                 for (kk in seq_along(NAMES)) {
[17:45:31.711]                   name <- removed[[kk]]
[17:45:31.711]                   NAME <- NAMES[[kk]]
[17:45:31.711]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:31.711]                     next
[17:45:31.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:31.711]                 }
[17:45:31.711]                 if (length(args) > 0) 
[17:45:31.711]                   base::do.call(base::Sys.setenv, args = args)
[17:45:31.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:31.711]             }
[17:45:31.711]             else {
[17:45:31.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:31.711]             }
[17:45:31.711]             {
[17:45:31.711]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:31.711]                   0L) {
[17:45:31.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:31.711]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:31.711]                   base::options(opts)
[17:45:31.711]                 }
[17:45:31.711]                 {
[17:45:31.711]                   {
[17:45:31.711]                     NULL
[17:45:31.711]                     RNGkind("Mersenne-Twister")
[17:45:31.711]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:31.711]                       inherits = FALSE)
[17:45:31.711]                   }
[17:45:31.711]                   options(future.plan = NULL)
[17:45:31.711]                   if (is.na(NA_character_)) 
[17:45:31.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:31.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:31.711]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:31.711]                     .init = FALSE)
[17:45:31.711]                 }
[17:45:31.711]             }
[17:45:31.711]         }
[17:45:31.711]     })
[17:45:31.711]     if (TRUE) {
[17:45:31.711]         base::sink(type = "output", split = FALSE)
[17:45:31.711]         if (FALSE) {
[17:45:31.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:31.711]         }
[17:45:31.711]         else {
[17:45:31.711]             ...future.result["stdout"] <- base::list(NULL)
[17:45:31.711]         }
[17:45:31.711]         base::close(...future.stdout)
[17:45:31.711]         ...future.stdout <- NULL
[17:45:31.711]     }
[17:45:31.711]     ...future.result$conditions <- ...future.conditions
[17:45:31.711]     ...future.result$finished <- base::Sys.time()
[17:45:31.711]     ...future.result
[17:45:31.711] }
[17:45:31.713] assign_globals() ...
[17:45:31.713] List of 5
[17:45:31.713]  $ ...future.FUN            :function (x)  
[17:45:31.713]  $ future.call.arguments    : list()
[17:45:31.713]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:31.713]  $ ...future.elements_ii    :List of 2
[17:45:31.713]   ..$ : int 1
[17:45:31.713]   ..$ : int 0
[17:45:31.713]  $ ...future.seeds_ii       : NULL
[17:45:31.713]  $ ...future.globals.maxSize: NULL
[17:45:31.713]  - attr(*, "where")=List of 5
[17:45:31.713]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:31.713]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:31.713]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:31.713]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:31.713]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:31.713]  - attr(*, "resolved")= logi FALSE
[17:45:31.713]  - attr(*, "total_size")= num 4720
[17:45:31.713]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:31.713]  - attr(*, "already-done")= logi TRUE
[17:45:31.718] - reassign environment for ‘...future.FUN’
[17:45:31.718] - copied ‘...future.FUN’ to environment
[17:45:31.718] - copied ‘future.call.arguments’ to environment
[17:45:31.718] - copied ‘...future.elements_ii’ to environment
[17:45:31.719] - copied ‘...future.seeds_ii’ to environment
[17:45:31.719] - copied ‘...future.globals.maxSize’ to environment
[17:45:31.719] assign_globals() ... done
[17:45:31.719] plan(): Setting new future strategy stack:
[17:45:31.719] List of future strategies:
[17:45:31.719] 1. sequential:
[17:45:31.719]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:31.719]    - tweaked: FALSE
[17:45:31.719]    - call: NULL
[17:45:31.720] plan(): nbrOfWorkers() = 1
[17:45:32.222] plan(): Setting new future strategy stack:
[17:45:32.222] List of future strategies:
[17:45:32.222] 1. sequential:
[17:45:32.222]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:32.222]    - tweaked: FALSE
[17:45:32.222]    - call: plan(strategy)
[17:45:32.223] plan(): nbrOfWorkers() = 1
[17:45:32.223] SequentialFuture started (and completed)
[17:45:32.223] - Launch lazy future ... done
[17:45:32.223] run() for ‘SequentialFuture’ ... done
[17:45:32.224] Created future:
[17:45:32.224] SequentialFuture:
[17:45:32.224] Label: ‘future_lapply-1’
[17:45:32.224] Expression:
[17:45:32.224] {
[17:45:32.224]     do.call(function(...) {
[17:45:32.224]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:32.224]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:32.224]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:32.224]             on.exit(options(oopts), add = TRUE)
[17:45:32.224]         }
[17:45:32.224]         {
[17:45:32.224]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:32.224]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:32.224]                 ...future.FUN(...future.X_jj, ...)
[17:45:32.224]             })
[17:45:32.224]         }
[17:45:32.224]     }, args = future.call.arguments)
[17:45:32.224] }
[17:45:32.224] Lazy evaluation: FALSE
[17:45:32.224] Asynchronous evaluation: FALSE
[17:45:32.224] Local evaluation: TRUE
[17:45:32.224] Environment: R_GlobalEnv
[17:45:32.224] Capture standard output: FALSE
[17:45:32.224] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:32.224] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:32.224] Packages: <none>
[17:45:32.224] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:32.224] Resolved: TRUE
[17:45:32.224] Value: 112 bytes of class ‘list’
[17:45:32.224] Early signaling: FALSE
[17:45:32.224] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:32.224] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:32.225] Chunk #1 of 1 ... DONE
[17:45:32.225] Launching 1 futures (chunks) ... DONE
[17:45:32.225] Resolving 1 futures (chunks) ...
[17:45:32.226] resolve() on list ...
[17:45:32.226]  recursive: 0
[17:45:32.226]  length: 1
[17:45:32.226] 
[17:45:32.226] resolved() for ‘SequentialFuture’ ...
[17:45:32.226] - state: ‘finished’
[17:45:32.226] - run: TRUE
[17:45:32.226] - result: ‘FutureResult’
[17:45:32.226] resolved() for ‘SequentialFuture’ ... done
[17:45:32.226] Future #1
[17:45:32.227] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:32.227] - nx: 1
[17:45:32.227] - relay: TRUE
[17:45:32.227] - stdout: TRUE
[17:45:32.227] - signal: TRUE
[17:45:32.227] - resignal: FALSE
[17:45:32.227] - force: TRUE
[17:45:32.227] - relayed: [n=1] FALSE
[17:45:32.228] - queued futures: [n=1] FALSE
[17:45:32.228]  - until=1
[17:45:32.228]  - relaying element #1
[17:45:32.228] - relayed: [n=1] TRUE
[17:45:32.228] - queued futures: [n=1] TRUE
[17:45:32.228] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:32.228]  length: 0 (resolved future 1)
[17:45:32.228] Relaying remaining futures
[17:45:32.228] signalConditionsASAP(NULL, pos=0) ...
[17:45:32.229] - nx: 1
[17:45:32.229] - relay: TRUE
[17:45:32.229] - stdout: TRUE
[17:45:32.229] - signal: TRUE
[17:45:32.229] - resignal: FALSE
[17:45:32.229] - force: TRUE
[17:45:32.229] - relayed: [n=1] TRUE
[17:45:32.229] - queued futures: [n=1] TRUE
 - flush all
[17:45:32.229] - relayed: [n=1] TRUE
[17:45:32.229] - queued futures: [n=1] TRUE
[17:45:32.229] signalConditionsASAP(NULL, pos=0) ... done
[17:45:32.229] resolve() on list ... DONE
[17:45:32.230]  - Number of value chunks collected: 1
[17:45:32.230] Resolving 1 futures (chunks) ... DONE
[17:45:32.230] Reducing values from 1 chunks ...
[17:45:32.230]  - Number of values collected after concatenation: 2
[17:45:32.230]  - Number of values expected: 2
[17:45:32.230] Reducing values from 1 chunks ... DONE
[17:45:32.230] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:45:32.231] future_lapply() ...
[17:45:32.231] Number of chunks: 1
[17:45:32.231] getGlobalsAndPackagesXApply() ...
[17:45:32.231]  - future.globals: TRUE
[17:45:32.232] getGlobalsAndPackages() ...
[17:45:32.232] Searching for globals...
[17:45:32.233] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:32.233] Searching for globals ... DONE
[17:45:32.233] Resolving globals: FALSE
[17:45:32.234] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:32.234] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:32.234] - globals: [1] ‘FUN’
[17:45:32.234] 
[17:45:32.234] getGlobalsAndPackages() ... DONE
[17:45:32.236]  - globals found/used: [n=1] ‘FUN’
[17:45:32.237]  - needed namespaces: [n=0] 
[17:45:32.237] Finding globals ... DONE
[17:45:32.237]  - use_args: TRUE
[17:45:32.237]  - Getting '...' globals ...
[17:45:32.237] resolve() on list ...
[17:45:32.237]  recursive: 0
[17:45:32.237]  length: 1
[17:45:32.237]  elements: ‘...’
[17:45:32.238]  length: 0 (resolved future 1)
[17:45:32.238] resolve() on list ... DONE
[17:45:32.238]    - '...' content: [n=0] 
[17:45:32.238] List of 1
[17:45:32.238]  $ ...: list()
[17:45:32.238]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:32.238]  - attr(*, "where")=List of 1
[17:45:32.238]   ..$ ...:<environment: 0x55f6c779ab18> 
[17:45:32.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:32.238]  - attr(*, "resolved")= logi TRUE
[17:45:32.238]  - attr(*, "total_size")= num NA
[17:45:32.240]  - Getting '...' globals ... DONE
[17:45:32.241] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:32.241] List of 2
[17:45:32.241]  $ ...future.FUN:function (x)  
[17:45:32.241]  $ ...          : list()
[17:45:32.241]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:32.241]  - attr(*, "where")=List of 2
[17:45:32.241]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:32.241]   ..$ ...          :<environment: 0x55f6c779ab18> 
[17:45:32.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:32.241]  - attr(*, "resolved")= logi FALSE
[17:45:32.241]  - attr(*, "total_size")= num 4720
[17:45:32.243] Packages to be attached in all futures: [n=0] 
[17:45:32.243] getGlobalsAndPackagesXApply() ... DONE
[17:45:32.244] Number of futures (= number of chunks): 1
[17:45:32.244] Launching 1 futures (chunks) ...
[17:45:32.244] Chunk #1 of 1 ...
[17:45:32.244]  - Finding globals in 'X' for chunk #1 ...
[17:45:32.244] getGlobalsAndPackages() ...
[17:45:32.244] Searching for globals...
[17:45:32.244] 
[17:45:32.245] Searching for globals ... DONE
[17:45:32.245] - globals: [0] <none>
[17:45:32.245] getGlobalsAndPackages() ... DONE
[17:45:32.245]    + additional globals found: [n=0] 
[17:45:32.245]    + additional namespaces needed: [n=0] 
[17:45:32.245]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:32.245]  - seeds: <none>
[17:45:32.245]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:32.245] getGlobalsAndPackages() ...
[17:45:32.245] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:32.245] Resolving globals: FALSE
[17:45:32.246] Tweak future expression to call with '...' arguments ...
[17:45:32.246] {
[17:45:32.246]     do.call(function(...) {
[17:45:32.246]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:32.246]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:32.246]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:32.246]             on.exit(options(oopts), add = TRUE)
[17:45:32.246]         }
[17:45:32.246]         {
[17:45:32.246]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:32.246]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:32.246]                 ...future.FUN(...future.X_jj, ...)
[17:45:32.246]             })
[17:45:32.246]         }
[17:45:32.246]     }, args = future.call.arguments)
[17:45:32.246] }
[17:45:32.246] Tweak future expression to call with '...' arguments ... DONE
[17:45:32.246] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:32.246] 
[17:45:32.246] getGlobalsAndPackages() ... DONE
[17:45:32.247] run() for ‘Future’ ...
[17:45:32.247] - state: ‘created’
[17:45:32.247] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:32.247] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:32.247] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:32.248]   - Field: ‘label’
[17:45:32.248]   - Field: ‘local’
[17:45:32.248]   - Field: ‘owner’
[17:45:32.248]   - Field: ‘envir’
[17:45:32.248]   - Field: ‘packages’
[17:45:32.248]   - Field: ‘gc’
[17:45:32.248]   - Field: ‘conditions’
[17:45:32.248]   - Field: ‘expr’
[17:45:32.248]   - Field: ‘uuid’
[17:45:32.248]   - Field: ‘seed’
[17:45:32.249]   - Field: ‘version’
[17:45:32.249]   - Field: ‘result’
[17:45:32.249]   - Field: ‘asynchronous’
[17:45:32.249]   - Field: ‘calls’
[17:45:32.249]   - Field: ‘globals’
[17:45:32.249]   - Field: ‘stdout’
[17:45:32.249]   - Field: ‘earlySignal’
[17:45:32.249]   - Field: ‘lazy’
[17:45:32.249]   - Field: ‘state’
[17:45:32.249] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:32.250] - Launch lazy future ...
[17:45:32.250] Packages needed by the future expression (n = 0): <none>
[17:45:32.250] Packages needed by future strategies (n = 0): <none>
[17:45:32.250] {
[17:45:32.250]     {
[17:45:32.250]         {
[17:45:32.250]             ...future.startTime <- base::Sys.time()
[17:45:32.250]             {
[17:45:32.250]                 {
[17:45:32.250]                   {
[17:45:32.250]                     base::local({
[17:45:32.250]                       has_future <- base::requireNamespace("future", 
[17:45:32.250]                         quietly = TRUE)
[17:45:32.250]                       if (has_future) {
[17:45:32.250]                         ns <- base::getNamespace("future")
[17:45:32.250]                         version <- ns[[".package"]][["version"]]
[17:45:32.250]                         if (is.null(version)) 
[17:45:32.250]                           version <- utils::packageVersion("future")
[17:45:32.250]                       }
[17:45:32.250]                       else {
[17:45:32.250]                         version <- NULL
[17:45:32.250]                       }
[17:45:32.250]                       if (!has_future || version < "1.8.0") {
[17:45:32.250]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:32.250]                           "", base::R.version$version.string), 
[17:45:32.250]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:32.250]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:32.250]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:32.250]                             "release", "version")], collapse = " "), 
[17:45:32.250]                           hostname = base::Sys.info()[["nodename"]])
[17:45:32.250]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:32.250]                           info)
[17:45:32.250]                         info <- base::paste(info, collapse = "; ")
[17:45:32.250]                         if (!has_future) {
[17:45:32.250]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:32.250]                             info)
[17:45:32.250]                         }
[17:45:32.250]                         else {
[17:45:32.250]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:32.250]                             info, version)
[17:45:32.250]                         }
[17:45:32.250]                         base::stop(msg)
[17:45:32.250]                       }
[17:45:32.250]                     })
[17:45:32.250]                   }
[17:45:32.250]                   ...future.strategy.old <- future::plan("list")
[17:45:32.250]                   options(future.plan = NULL)
[17:45:32.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:32.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:32.250]                 }
[17:45:32.250]                 ...future.workdir <- getwd()
[17:45:32.250]             }
[17:45:32.250]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:32.250]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:32.250]         }
[17:45:32.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:32.250]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:32.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:32.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:32.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:32.250]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:32.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:32.250]             base::names(...future.oldOptions))
[17:45:32.250]     }
[17:45:32.250]     if (FALSE) {
[17:45:32.250]     }
[17:45:32.250]     else {
[17:45:32.250]         if (TRUE) {
[17:45:32.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:32.250]                 open = "w")
[17:45:32.250]         }
[17:45:32.250]         else {
[17:45:32.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:32.250]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:32.250]         }
[17:45:32.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:32.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:32.250]             base::sink(type = "output", split = FALSE)
[17:45:32.250]             base::close(...future.stdout)
[17:45:32.250]         }, add = TRUE)
[17:45:32.250]     }
[17:45:32.250]     ...future.frame <- base::sys.nframe()
[17:45:32.250]     ...future.conditions <- base::list()
[17:45:32.250]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:32.250]     if (FALSE) {
[17:45:32.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:32.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:32.250]     }
[17:45:32.250]     ...future.result <- base::tryCatch({
[17:45:32.250]         base::withCallingHandlers({
[17:45:32.250]             ...future.value <- base::withVisible(base::local({
[17:45:32.250]                 do.call(function(...) {
[17:45:32.250]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:32.250]                   if (!identical(...future.globals.maxSize.org, 
[17:45:32.250]                     ...future.globals.maxSize)) {
[17:45:32.250]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:32.250]                     on.exit(options(oopts), add = TRUE)
[17:45:32.250]                   }
[17:45:32.250]                   {
[17:45:32.250]                     lapply(seq_along(...future.elements_ii), 
[17:45:32.250]                       FUN = function(jj) {
[17:45:32.250]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:32.250]                         ...future.FUN(...future.X_jj, ...)
[17:45:32.250]                       })
[17:45:32.250]                   }
[17:45:32.250]                 }, args = future.call.arguments)
[17:45:32.250]             }))
[17:45:32.250]             future::FutureResult(value = ...future.value$value, 
[17:45:32.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:32.250]                   ...future.rng), globalenv = if (FALSE) 
[17:45:32.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:32.250]                     ...future.globalenv.names))
[17:45:32.250]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:32.250]         }, condition = base::local({
[17:45:32.250]             c <- base::c
[17:45:32.250]             inherits <- base::inherits
[17:45:32.250]             invokeRestart <- base::invokeRestart
[17:45:32.250]             length <- base::length
[17:45:32.250]             list <- base::list
[17:45:32.250]             seq.int <- base::seq.int
[17:45:32.250]             signalCondition <- base::signalCondition
[17:45:32.250]             sys.calls <- base::sys.calls
[17:45:32.250]             `[[` <- base::`[[`
[17:45:32.250]             `+` <- base::`+`
[17:45:32.250]             `<<-` <- base::`<<-`
[17:45:32.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:32.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:32.250]                   3L)]
[17:45:32.250]             }
[17:45:32.250]             function(cond) {
[17:45:32.250]                 is_error <- inherits(cond, "error")
[17:45:32.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:32.250]                   NULL)
[17:45:32.250]                 if (is_error) {
[17:45:32.250]                   sessionInformation <- function() {
[17:45:32.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:32.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:32.250]                       search = base::search(), system = base::Sys.info())
[17:45:32.250]                   }
[17:45:32.250]                   ...future.conditions[[length(...future.conditions) + 
[17:45:32.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:32.250]                     cond$call), session = sessionInformation(), 
[17:45:32.250]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:32.250]                   signalCondition(cond)
[17:45:32.250]                 }
[17:45:32.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:32.250]                 "immediateCondition"))) {
[17:45:32.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:32.250]                   ...future.conditions[[length(...future.conditions) + 
[17:45:32.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:32.250]                   if (TRUE && !signal) {
[17:45:32.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:32.250]                     {
[17:45:32.250]                       inherits <- base::inherits
[17:45:32.250]                       invokeRestart <- base::invokeRestart
[17:45:32.250]                       is.null <- base::is.null
[17:45:32.250]                       muffled <- FALSE
[17:45:32.250]                       if (inherits(cond, "message")) {
[17:45:32.250]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:32.250]                         if (muffled) 
[17:45:32.250]                           invokeRestart("muffleMessage")
[17:45:32.250]                       }
[17:45:32.250]                       else if (inherits(cond, "warning")) {
[17:45:32.250]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:32.250]                         if (muffled) 
[17:45:32.250]                           invokeRestart("muffleWarning")
[17:45:32.250]                       }
[17:45:32.250]                       else if (inherits(cond, "condition")) {
[17:45:32.250]                         if (!is.null(pattern)) {
[17:45:32.250]                           computeRestarts <- base::computeRestarts
[17:45:32.250]                           grepl <- base::grepl
[17:45:32.250]                           restarts <- computeRestarts(cond)
[17:45:32.250]                           for (restart in restarts) {
[17:45:32.250]                             name <- restart$name
[17:45:32.250]                             if (is.null(name)) 
[17:45:32.250]                               next
[17:45:32.250]                             if (!grepl(pattern, name)) 
[17:45:32.250]                               next
[17:45:32.250]                             invokeRestart(restart)
[17:45:32.250]                             muffled <- TRUE
[17:45:32.250]                             break
[17:45:32.250]                           }
[17:45:32.250]                         }
[17:45:32.250]                       }
[17:45:32.250]                       invisible(muffled)
[17:45:32.250]                     }
[17:45:32.250]                     muffleCondition(cond, pattern = "^muffle")
[17:45:32.250]                   }
[17:45:32.250]                 }
[17:45:32.250]                 else {
[17:45:32.250]                   if (TRUE) {
[17:45:32.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:32.250]                     {
[17:45:32.250]                       inherits <- base::inherits
[17:45:32.250]                       invokeRestart <- base::invokeRestart
[17:45:32.250]                       is.null <- base::is.null
[17:45:32.250]                       muffled <- FALSE
[17:45:32.250]                       if (inherits(cond, "message")) {
[17:45:32.250]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:32.250]                         if (muffled) 
[17:45:32.250]                           invokeRestart("muffleMessage")
[17:45:32.250]                       }
[17:45:32.250]                       else if (inherits(cond, "warning")) {
[17:45:32.250]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:32.250]                         if (muffled) 
[17:45:32.250]                           invokeRestart("muffleWarning")
[17:45:32.250]                       }
[17:45:32.250]                       else if (inherits(cond, "condition")) {
[17:45:32.250]                         if (!is.null(pattern)) {
[17:45:32.250]                           computeRestarts <- base::computeRestarts
[17:45:32.250]                           grepl <- base::grepl
[17:45:32.250]                           restarts <- computeRestarts(cond)
[17:45:32.250]                           for (restart in restarts) {
[17:45:32.250]                             name <- restart$name
[17:45:32.250]                             if (is.null(name)) 
[17:45:32.250]                               next
[17:45:32.250]                             if (!grepl(pattern, name)) 
[17:45:32.250]                               next
[17:45:32.250]                             invokeRestart(restart)
[17:45:32.250]                             muffled <- TRUE
[17:45:32.250]                             break
[17:45:32.250]                           }
[17:45:32.250]                         }
[17:45:32.250]                       }
[17:45:32.250]                       invisible(muffled)
[17:45:32.250]                     }
[17:45:32.250]                     muffleCondition(cond, pattern = "^muffle")
[17:45:32.250]                   }
[17:45:32.250]                 }
[17:45:32.250]             }
[17:45:32.250]         }))
[17:45:32.250]     }, error = function(ex) {
[17:45:32.250]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:32.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:32.250]                 ...future.rng), started = ...future.startTime, 
[17:45:32.250]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:32.250]             version = "1.8"), class = "FutureResult")
[17:45:32.250]     }, finally = {
[17:45:32.250]         if (!identical(...future.workdir, getwd())) 
[17:45:32.250]             setwd(...future.workdir)
[17:45:32.250]         {
[17:45:32.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:32.250]                 ...future.oldOptions$nwarnings <- NULL
[17:45:32.250]             }
[17:45:32.250]             base::options(...future.oldOptions)
[17:45:32.250]             if (.Platform$OS.type == "windows") {
[17:45:32.250]                 old_names <- names(...future.oldEnvVars)
[17:45:32.250]                 envs <- base::Sys.getenv()
[17:45:32.250]                 names <- names(envs)
[17:45:32.250]                 common <- intersect(names, old_names)
[17:45:32.250]                 added <- setdiff(names, old_names)
[17:45:32.250]                 removed <- setdiff(old_names, names)
[17:45:32.250]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:32.250]                   envs[common]]
[17:45:32.250]                 NAMES <- toupper(changed)
[17:45:32.250]                 args <- list()
[17:45:32.250]                 for (kk in seq_along(NAMES)) {
[17:45:32.250]                   name <- changed[[kk]]
[17:45:32.250]                   NAME <- NAMES[[kk]]
[17:45:32.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:32.250]                     next
[17:45:32.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:32.250]                 }
[17:45:32.250]                 NAMES <- toupper(added)
[17:45:32.250]                 for (kk in seq_along(NAMES)) {
[17:45:32.250]                   name <- added[[kk]]
[17:45:32.250]                   NAME <- NAMES[[kk]]
[17:45:32.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:32.250]                     next
[17:45:32.250]                   args[[name]] <- ""
[17:45:32.250]                 }
[17:45:32.250]                 NAMES <- toupper(removed)
[17:45:32.250]                 for (kk in seq_along(NAMES)) {
[17:45:32.250]                   name <- removed[[kk]]
[17:45:32.250]                   NAME <- NAMES[[kk]]
[17:45:32.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:32.250]                     next
[17:45:32.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:32.250]                 }
[17:45:32.250]                 if (length(args) > 0) 
[17:45:32.250]                   base::do.call(base::Sys.setenv, args = args)
[17:45:32.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:32.250]             }
[17:45:32.250]             else {
[17:45:32.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:32.250]             }
[17:45:32.250]             {
[17:45:32.250]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:32.250]                   0L) {
[17:45:32.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:32.250]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:32.250]                   base::options(opts)
[17:45:32.250]                 }
[17:45:32.250]                 {
[17:45:32.250]                   {
[17:45:32.250]                     NULL
[17:45:32.250]                     RNGkind("Mersenne-Twister")
[17:45:32.250]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:32.250]                       inherits = FALSE)
[17:45:32.250]                   }
[17:45:32.250]                   options(future.plan = NULL)
[17:45:32.250]                   if (is.na(NA_character_)) 
[17:45:32.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:32.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:32.250]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:32.250]                     .init = FALSE)
[17:45:32.250]                 }
[17:45:32.250]             }
[17:45:32.250]         }
[17:45:32.250]     })
[17:45:32.250]     if (TRUE) {
[17:45:32.250]         base::sink(type = "output", split = FALSE)
[17:45:32.250]         if (TRUE) {
[17:45:32.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:32.250]         }
[17:45:32.250]         else {
[17:45:32.250]             ...future.result["stdout"] <- base::list(NULL)
[17:45:32.250]         }
[17:45:32.250]         base::close(...future.stdout)
[17:45:32.250]         ...future.stdout <- NULL
[17:45:32.250]     }
[17:45:32.250]     ...future.result$conditions <- ...future.conditions
[17:45:32.250]     ...future.result$finished <- base::Sys.time()
[17:45:32.250]     ...future.result
[17:45:32.250] }
[17:45:32.252] assign_globals() ...
[17:45:32.252] List of 5
[17:45:32.252]  $ ...future.FUN            :function (x)  
[17:45:32.252]  $ future.call.arguments    : list()
[17:45:32.252]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:32.252]  $ ...future.elements_ii    :List of 2
[17:45:32.252]   ..$ : int 1
[17:45:32.252]   ..$ : int 0
[17:45:32.252]  $ ...future.seeds_ii       : NULL
[17:45:32.252]  $ ...future.globals.maxSize: NULL
[17:45:32.252]  - attr(*, "where")=List of 5
[17:45:32.252]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:32.252]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:32.252]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:32.252]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:32.252]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:32.252]  - attr(*, "resolved")= logi FALSE
[17:45:32.252]  - attr(*, "total_size")= num 4720
[17:45:32.252]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:32.252]  - attr(*, "already-done")= logi TRUE
[17:45:32.257] - reassign environment for ‘...future.FUN’
[17:45:32.257] - copied ‘...future.FUN’ to environment
[17:45:32.257] - copied ‘future.call.arguments’ to environment
[17:45:32.257] - copied ‘...future.elements_ii’ to environment
[17:45:32.257] - copied ‘...future.seeds_ii’ to environment
[17:45:32.257] - copied ‘...future.globals.maxSize’ to environment
[17:45:32.257] assign_globals() ... done
[17:45:32.257] plan(): Setting new future strategy stack:
[17:45:32.258] List of future strategies:
[17:45:32.258] 1. sequential:
[17:45:32.258]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:32.258]    - tweaked: FALSE
[17:45:32.258]    - call: NULL
[17:45:32.258] plan(): nbrOfWorkers() = 1
[17:45:32.760] plan(): Setting new future strategy stack:
[17:45:32.760] List of future strategies:
[17:45:32.760] 1. sequential:
[17:45:32.760]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:32.760]    - tweaked: FALSE
[17:45:32.760]    - call: plan(strategy)
[17:45:32.760] plan(): nbrOfWorkers() = 1
[17:45:32.761] SequentialFuture started (and completed)
[17:45:32.761] - Launch lazy future ... done
[17:45:32.761] run() for ‘SequentialFuture’ ... done
[17:45:32.761] Created future:
[17:45:32.761] SequentialFuture:
[17:45:32.761] Label: ‘future_lapply-1’
[17:45:32.761] Expression:
[17:45:32.761] {
[17:45:32.761]     do.call(function(...) {
[17:45:32.761]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:32.761]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:32.761]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:32.761]             on.exit(options(oopts), add = TRUE)
[17:45:32.761]         }
[17:45:32.761]         {
[17:45:32.761]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:32.761]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:32.761]                 ...future.FUN(...future.X_jj, ...)
[17:45:32.761]             })
[17:45:32.761]         }
[17:45:32.761]     }, args = future.call.arguments)
[17:45:32.761] }
[17:45:32.761] Lazy evaluation: FALSE
[17:45:32.761] Asynchronous evaluation: FALSE
[17:45:32.761] Local evaluation: TRUE
[17:45:32.761] Environment: R_GlobalEnv
[17:45:32.761] Capture standard output: TRUE
[17:45:32.761] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:32.761] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:32.761] Packages: <none>
[17:45:32.761] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:32.761] Resolved: TRUE
[17:45:32.761] Value: 112 bytes of class ‘list’
[17:45:32.761] Early signaling: FALSE
[17:45:32.761] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:32.761] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:32.762] Chunk #1 of 1 ... DONE
[17:45:32.762] Launching 1 futures (chunks) ... DONE
[17:45:32.762] Resolving 1 futures (chunks) ...
[17:45:32.762] resolve() on list ...
[17:45:32.763]  recursive: 0
[17:45:32.763]  length: 1
[17:45:32.763] 
[17:45:32.763] resolved() for ‘SequentialFuture’ ...
[17:45:32.763] - state: ‘finished’
[17:45:32.763] - run: TRUE
[17:45:32.763] - result: ‘FutureResult’
[17:45:32.763] resolved() for ‘SequentialFuture’ ... done
[17:45:32.763] Future #1
[17:45:32.764] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:32.764] - nx: 1
[17:45:32.764] - relay: TRUE
[17:45:32.764] - stdout: TRUE
[17:45:32.764] - signal: TRUE
[17:45:32.764] - resignal: FALSE
[17:45:32.766] - force: TRUE
[17:45:32.766] - relayed: [n=1] FALSE
[17:45:32.766] - queued futures: [n=1] FALSE
[17:45:32.766]  - until=1
[17:45:32.766]  - relaying element #1
[17:45:32.766] - relayed: [n=1] TRUE
[17:45:32.766] - queued futures: [n=1] TRUE
[17:45:32.766] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:32.766]  length: 0 (resolved future 1)
[17:45:32.766] Relaying remaining futures
[17:45:32.767] signalConditionsASAP(NULL, pos=0) ...
[17:45:32.767] - nx: 1
[17:45:32.767] - relay: TRUE
[17:45:32.767] - stdout: TRUE
[17:45:32.767] - signal: TRUE
[17:45:32.767] - resignal: FALSE
[17:45:32.767] - force: TRUE
[17:45:32.767] - relayed: [n=1] TRUE
[17:45:32.767] - queued futures: [n=1] TRUE
 - flush all
[17:45:32.767] - relayed: [n=1] TRUE
[17:45:32.767] - queued futures: [n=1] TRUE
[17:45:32.768] signalConditionsASAP(NULL, pos=0) ... done
[17:45:32.768] resolve() on list ... DONE
[17:45:32.768]  - Number of value chunks collected: 1
[17:45:32.768] Resolving 1 futures (chunks) ... DONE
[17:45:32.768] Reducing values from 1 chunks ...
[17:45:32.768]  - Number of values collected after concatenation: 2
[17:45:32.768]  - Number of values expected: 2
[17:45:32.768] Reducing values from 1 chunks ... DONE
[17:45:32.768] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:45:32.769] future_lapply() ...
[17:45:32.770] Number of chunks: 1
[17:45:32.770] getGlobalsAndPackagesXApply() ...
[17:45:32.770]  - future.globals: TRUE
[17:45:32.770] getGlobalsAndPackages() ...
[17:45:32.770] Searching for globals...
[17:45:32.771] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:32.771] Searching for globals ... DONE
[17:45:32.771] Resolving globals: FALSE
[17:45:32.772] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:32.772] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:32.772] - globals: [1] ‘FUN’
[17:45:32.772] 
[17:45:32.773] getGlobalsAndPackages() ... DONE
[17:45:32.773]  - globals found/used: [n=1] ‘FUN’
[17:45:32.773]  - needed namespaces: [n=0] 
[17:45:32.773] Finding globals ... DONE
[17:45:32.773]  - use_args: TRUE
[17:45:32.773]  - Getting '...' globals ...
[17:45:32.773] resolve() on list ...
[17:45:32.773]  recursive: 0
[17:45:32.773]  length: 1
[17:45:32.774]  elements: ‘...’
[17:45:32.774]  length: 0 (resolved future 1)
[17:45:32.774] resolve() on list ... DONE
[17:45:32.774]    - '...' content: [n=0] 
[17:45:32.774] List of 1
[17:45:32.774]  $ ...: list()
[17:45:32.774]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:32.774]  - attr(*, "where")=List of 1
[17:45:32.774]   ..$ ...:<environment: 0x55f6c59c76c0> 
[17:45:32.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:32.774]  - attr(*, "resolved")= logi TRUE
[17:45:32.774]  - attr(*, "total_size")= num NA
[17:45:32.776]  - Getting '...' globals ... DONE
[17:45:32.777] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:32.777] List of 2
[17:45:32.777]  $ ...future.FUN:function (x)  
[17:45:32.777]  $ ...          : list()
[17:45:32.777]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:32.777]  - attr(*, "where")=List of 2
[17:45:32.777]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:32.777]   ..$ ...          :<environment: 0x55f6c59c76c0> 
[17:45:32.777]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:32.777]  - attr(*, "resolved")= logi FALSE
[17:45:32.777]  - attr(*, "total_size")= num 4720
[17:45:32.779] Packages to be attached in all futures: [n=0] 
[17:45:32.779] getGlobalsAndPackagesXApply() ... DONE
[17:45:32.780] Number of futures (= number of chunks): 1
[17:45:32.780] Launching 1 futures (chunks) ...
[17:45:32.780] Chunk #1 of 1 ...
[17:45:32.780]  - Finding globals in 'X' for chunk #1 ...
[17:45:32.780] getGlobalsAndPackages() ...
[17:45:32.780] Searching for globals...
[17:45:32.780] 
[17:45:32.781] Searching for globals ... DONE
[17:45:32.781] - globals: [0] <none>
[17:45:32.781] getGlobalsAndPackages() ... DONE
[17:45:32.781]    + additional globals found: [n=0] 
[17:45:32.781]    + additional namespaces needed: [n=0] 
[17:45:32.781]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:32.781]  - seeds: <none>
[17:45:32.781]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:32.781] getGlobalsAndPackages() ...
[17:45:32.781] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:32.781] Resolving globals: FALSE
[17:45:32.782] Tweak future expression to call with '...' arguments ...
[17:45:32.782] {
[17:45:32.782]     do.call(function(...) {
[17:45:32.782]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:32.782]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:32.782]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:32.782]             on.exit(options(oopts), add = TRUE)
[17:45:32.782]         }
[17:45:32.782]         {
[17:45:32.782]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:32.782]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:32.782]                 ...future.FUN(...future.X_jj, ...)
[17:45:32.782]             })
[17:45:32.782]         }
[17:45:32.782]     }, args = future.call.arguments)
[17:45:32.782] }
[17:45:32.782] Tweak future expression to call with '...' arguments ... DONE
[17:45:32.782] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:32.782] 
[17:45:32.783] getGlobalsAndPackages() ... DONE
[17:45:32.783] run() for ‘Future’ ...
[17:45:32.783] - state: ‘created’
[17:45:32.783] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:32.783] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:32.783] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:32.784]   - Field: ‘label’
[17:45:32.784]   - Field: ‘local’
[17:45:32.784]   - Field: ‘owner’
[17:45:32.784]   - Field: ‘envir’
[17:45:32.784]   - Field: ‘packages’
[17:45:32.784]   - Field: ‘gc’
[17:45:32.784]   - Field: ‘conditions’
[17:45:32.784]   - Field: ‘expr’
[17:45:32.784]   - Field: ‘uuid’
[17:45:32.785]   - Field: ‘seed’
[17:45:32.785]   - Field: ‘version’
[17:45:32.785]   - Field: ‘result’
[17:45:32.785]   - Field: ‘asynchronous’
[17:45:32.785]   - Field: ‘calls’
[17:45:32.785]   - Field: ‘globals’
[17:45:32.785]   - Field: ‘stdout’
[17:45:32.785]   - Field: ‘earlySignal’
[17:45:32.785]   - Field: ‘lazy’
[17:45:32.785]   - Field: ‘state’
[17:45:32.785] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:32.786] - Launch lazy future ...
[17:45:32.786] Packages needed by the future expression (n = 0): <none>
[17:45:32.786] Packages needed by future strategies (n = 0): <none>
[17:45:32.786] {
[17:45:32.786]     {
[17:45:32.786]         {
[17:45:32.786]             ...future.startTime <- base::Sys.time()
[17:45:32.786]             {
[17:45:32.786]                 {
[17:45:32.786]                   {
[17:45:32.786]                     base::local({
[17:45:32.786]                       has_future <- base::requireNamespace("future", 
[17:45:32.786]                         quietly = TRUE)
[17:45:32.786]                       if (has_future) {
[17:45:32.786]                         ns <- base::getNamespace("future")
[17:45:32.786]                         version <- ns[[".package"]][["version"]]
[17:45:32.786]                         if (is.null(version)) 
[17:45:32.786]                           version <- utils::packageVersion("future")
[17:45:32.786]                       }
[17:45:32.786]                       else {
[17:45:32.786]                         version <- NULL
[17:45:32.786]                       }
[17:45:32.786]                       if (!has_future || version < "1.8.0") {
[17:45:32.786]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:32.786]                           "", base::R.version$version.string), 
[17:45:32.786]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:32.786]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:32.786]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:32.786]                             "release", "version")], collapse = " "), 
[17:45:32.786]                           hostname = base::Sys.info()[["nodename"]])
[17:45:32.786]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:32.786]                           info)
[17:45:32.786]                         info <- base::paste(info, collapse = "; ")
[17:45:32.786]                         if (!has_future) {
[17:45:32.786]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:32.786]                             info)
[17:45:32.786]                         }
[17:45:32.786]                         else {
[17:45:32.786]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:32.786]                             info, version)
[17:45:32.786]                         }
[17:45:32.786]                         base::stop(msg)
[17:45:32.786]                       }
[17:45:32.786]                     })
[17:45:32.786]                   }
[17:45:32.786]                   ...future.strategy.old <- future::plan("list")
[17:45:32.786]                   options(future.plan = NULL)
[17:45:32.786]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:32.786]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:32.786]                 }
[17:45:32.786]                 ...future.workdir <- getwd()
[17:45:32.786]             }
[17:45:32.786]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:32.786]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:32.786]         }
[17:45:32.786]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:32.786]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:32.786]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:32.786]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:32.786]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:32.786]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:32.786]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:32.786]             base::names(...future.oldOptions))
[17:45:32.786]     }
[17:45:32.786]     if (TRUE) {
[17:45:32.786]     }
[17:45:32.786]     else {
[17:45:32.786]         if (NA) {
[17:45:32.786]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:32.786]                 open = "w")
[17:45:32.786]         }
[17:45:32.786]         else {
[17:45:32.786]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:32.786]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:32.786]         }
[17:45:32.786]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:32.786]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:32.786]             base::sink(type = "output", split = FALSE)
[17:45:32.786]             base::close(...future.stdout)
[17:45:32.786]         }, add = TRUE)
[17:45:32.786]     }
[17:45:32.786]     ...future.frame <- base::sys.nframe()
[17:45:32.786]     ...future.conditions <- base::list()
[17:45:32.786]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:32.786]     if (FALSE) {
[17:45:32.786]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:32.786]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:32.786]     }
[17:45:32.786]     ...future.result <- base::tryCatch({
[17:45:32.786]         base::withCallingHandlers({
[17:45:32.786]             ...future.value <- base::withVisible(base::local({
[17:45:32.786]                 do.call(function(...) {
[17:45:32.786]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:32.786]                   if (!identical(...future.globals.maxSize.org, 
[17:45:32.786]                     ...future.globals.maxSize)) {
[17:45:32.786]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:32.786]                     on.exit(options(oopts), add = TRUE)
[17:45:32.786]                   }
[17:45:32.786]                   {
[17:45:32.786]                     lapply(seq_along(...future.elements_ii), 
[17:45:32.786]                       FUN = function(jj) {
[17:45:32.786]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:32.786]                         ...future.FUN(...future.X_jj, ...)
[17:45:32.786]                       })
[17:45:32.786]                   }
[17:45:32.786]                 }, args = future.call.arguments)
[17:45:32.786]             }))
[17:45:32.786]             future::FutureResult(value = ...future.value$value, 
[17:45:32.786]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:32.786]                   ...future.rng), globalenv = if (FALSE) 
[17:45:32.786]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:32.786]                     ...future.globalenv.names))
[17:45:32.786]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:32.786]         }, condition = base::local({
[17:45:32.786]             c <- base::c
[17:45:32.786]             inherits <- base::inherits
[17:45:32.786]             invokeRestart <- base::invokeRestart
[17:45:32.786]             length <- base::length
[17:45:32.786]             list <- base::list
[17:45:32.786]             seq.int <- base::seq.int
[17:45:32.786]             signalCondition <- base::signalCondition
[17:45:32.786]             sys.calls <- base::sys.calls
[17:45:32.786]             `[[` <- base::`[[`
[17:45:32.786]             `+` <- base::`+`
[17:45:32.786]             `<<-` <- base::`<<-`
[17:45:32.786]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:32.786]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:32.786]                   3L)]
[17:45:32.786]             }
[17:45:32.786]             function(cond) {
[17:45:32.786]                 is_error <- inherits(cond, "error")
[17:45:32.786]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:32.786]                   NULL)
[17:45:32.786]                 if (is_error) {
[17:45:32.786]                   sessionInformation <- function() {
[17:45:32.786]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:32.786]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:32.786]                       search = base::search(), system = base::Sys.info())
[17:45:32.786]                   }
[17:45:32.786]                   ...future.conditions[[length(...future.conditions) + 
[17:45:32.786]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:32.786]                     cond$call), session = sessionInformation(), 
[17:45:32.786]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:32.786]                   signalCondition(cond)
[17:45:32.786]                 }
[17:45:32.786]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:32.786]                 "immediateCondition"))) {
[17:45:32.786]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:32.786]                   ...future.conditions[[length(...future.conditions) + 
[17:45:32.786]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:32.786]                   if (TRUE && !signal) {
[17:45:32.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:32.786]                     {
[17:45:32.786]                       inherits <- base::inherits
[17:45:32.786]                       invokeRestart <- base::invokeRestart
[17:45:32.786]                       is.null <- base::is.null
[17:45:32.786]                       muffled <- FALSE
[17:45:32.786]                       if (inherits(cond, "message")) {
[17:45:32.786]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:32.786]                         if (muffled) 
[17:45:32.786]                           invokeRestart("muffleMessage")
[17:45:32.786]                       }
[17:45:32.786]                       else if (inherits(cond, "warning")) {
[17:45:32.786]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:32.786]                         if (muffled) 
[17:45:32.786]                           invokeRestart("muffleWarning")
[17:45:32.786]                       }
[17:45:32.786]                       else if (inherits(cond, "condition")) {
[17:45:32.786]                         if (!is.null(pattern)) {
[17:45:32.786]                           computeRestarts <- base::computeRestarts
[17:45:32.786]                           grepl <- base::grepl
[17:45:32.786]                           restarts <- computeRestarts(cond)
[17:45:32.786]                           for (restart in restarts) {
[17:45:32.786]                             name <- restart$name
[17:45:32.786]                             if (is.null(name)) 
[17:45:32.786]                               next
[17:45:32.786]                             if (!grepl(pattern, name)) 
[17:45:32.786]                               next
[17:45:32.786]                             invokeRestart(restart)
[17:45:32.786]                             muffled <- TRUE
[17:45:32.786]                             break
[17:45:32.786]                           }
[17:45:32.786]                         }
[17:45:32.786]                       }
[17:45:32.786]                       invisible(muffled)
[17:45:32.786]                     }
[17:45:32.786]                     muffleCondition(cond, pattern = "^muffle")
[17:45:32.786]                   }
[17:45:32.786]                 }
[17:45:32.786]                 else {
[17:45:32.786]                   if (TRUE) {
[17:45:32.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:32.786]                     {
[17:45:32.786]                       inherits <- base::inherits
[17:45:32.786]                       invokeRestart <- base::invokeRestart
[17:45:32.786]                       is.null <- base::is.null
[17:45:32.786]                       muffled <- FALSE
[17:45:32.786]                       if (inherits(cond, "message")) {
[17:45:32.786]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:32.786]                         if (muffled) 
[17:45:32.786]                           invokeRestart("muffleMessage")
[17:45:32.786]                       }
[17:45:32.786]                       else if (inherits(cond, "warning")) {
[17:45:32.786]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:32.786]                         if (muffled) 
[17:45:32.786]                           invokeRestart("muffleWarning")
[17:45:32.786]                       }
[17:45:32.786]                       else if (inherits(cond, "condition")) {
[17:45:32.786]                         if (!is.null(pattern)) {
[17:45:32.786]                           computeRestarts <- base::computeRestarts
[17:45:32.786]                           grepl <- base::grepl
[17:45:32.786]                           restarts <- computeRestarts(cond)
[17:45:32.786]                           for (restart in restarts) {
[17:45:32.786]                             name <- restart$name
[17:45:32.786]                             if (is.null(name)) 
[17:45:32.786]                               next
[17:45:32.786]                             if (!grepl(pattern, name)) 
[17:45:32.786]                               next
[17:45:32.786]                             invokeRestart(restart)
[17:45:32.786]                             muffled <- TRUE
[17:45:32.786]                             break
[17:45:32.786]                           }
[17:45:32.786]                         }
[17:45:32.786]                       }
[17:45:32.786]                       invisible(muffled)
[17:45:32.786]                     }
[17:45:32.786]                     muffleCondition(cond, pattern = "^muffle")
[17:45:32.786]                   }
[17:45:32.786]                 }
[17:45:32.786]             }
[17:45:32.786]         }))
[17:45:32.786]     }, error = function(ex) {
[17:45:32.786]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:32.786]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:32.786]                 ...future.rng), started = ...future.startTime, 
[17:45:32.786]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:32.786]             version = "1.8"), class = "FutureResult")
[17:45:32.786]     }, finally = {
[17:45:32.786]         if (!identical(...future.workdir, getwd())) 
[17:45:32.786]             setwd(...future.workdir)
[17:45:32.786]         {
[17:45:32.786]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:32.786]                 ...future.oldOptions$nwarnings <- NULL
[17:45:32.786]             }
[17:45:32.786]             base::options(...future.oldOptions)
[17:45:32.786]             if (.Platform$OS.type == "windows") {
[17:45:32.786]                 old_names <- names(...future.oldEnvVars)
[17:45:32.786]                 envs <- base::Sys.getenv()
[17:45:32.786]                 names <- names(envs)
[17:45:32.786]                 common <- intersect(names, old_names)
[17:45:32.786]                 added <- setdiff(names, old_names)
[17:45:32.786]                 removed <- setdiff(old_names, names)
[17:45:32.786]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:32.786]                   envs[common]]
[17:45:32.786]                 NAMES <- toupper(changed)
[17:45:32.786]                 args <- list()
[17:45:32.786]                 for (kk in seq_along(NAMES)) {
[17:45:32.786]                   name <- changed[[kk]]
[17:45:32.786]                   NAME <- NAMES[[kk]]
[17:45:32.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:32.786]                     next
[17:45:32.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:32.786]                 }
[17:45:32.786]                 NAMES <- toupper(added)
[17:45:32.786]                 for (kk in seq_along(NAMES)) {
[17:45:32.786]                   name <- added[[kk]]
[17:45:32.786]                   NAME <- NAMES[[kk]]
[17:45:32.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:32.786]                     next
[17:45:32.786]                   args[[name]] <- ""
[17:45:32.786]                 }
[17:45:32.786]                 NAMES <- toupper(removed)
[17:45:32.786]                 for (kk in seq_along(NAMES)) {
[17:45:32.786]                   name <- removed[[kk]]
[17:45:32.786]                   NAME <- NAMES[[kk]]
[17:45:32.786]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:32.786]                     next
[17:45:32.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:32.786]                 }
[17:45:32.786]                 if (length(args) > 0) 
[17:45:32.786]                   base::do.call(base::Sys.setenv, args = args)
[17:45:32.786]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:32.786]             }
[17:45:32.786]             else {
[17:45:32.786]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:32.786]             }
[17:45:32.786]             {
[17:45:32.786]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:32.786]                   0L) {
[17:45:32.786]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:32.786]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:32.786]                   base::options(opts)
[17:45:32.786]                 }
[17:45:32.786]                 {
[17:45:32.786]                   {
[17:45:32.786]                     NULL
[17:45:32.786]                     RNGkind("Mersenne-Twister")
[17:45:32.786]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:32.786]                       inherits = FALSE)
[17:45:32.786]                   }
[17:45:32.786]                   options(future.plan = NULL)
[17:45:32.786]                   if (is.na(NA_character_)) 
[17:45:32.786]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:32.786]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:32.786]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:32.786]                     .init = FALSE)
[17:45:32.786]                 }
[17:45:32.786]             }
[17:45:32.786]         }
[17:45:32.786]     })
[17:45:32.786]     if (FALSE) {
[17:45:32.786]         base::sink(type = "output", split = FALSE)
[17:45:32.786]         if (NA) {
[17:45:32.786]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:32.786]         }
[17:45:32.786]         else {
[17:45:32.786]             ...future.result["stdout"] <- base::list(NULL)
[17:45:32.786]         }
[17:45:32.786]         base::close(...future.stdout)
[17:45:32.786]         ...future.stdout <- NULL
[17:45:32.786]     }
[17:45:32.786]     ...future.result$conditions <- ...future.conditions
[17:45:32.786]     ...future.result$finished <- base::Sys.time()
[17:45:32.786]     ...future.result
[17:45:32.786] }
[17:45:32.788] assign_globals() ...
[17:45:32.788] List of 5
[17:45:32.788]  $ ...future.FUN            :function (x)  
[17:45:32.788]  $ future.call.arguments    : list()
[17:45:32.788]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:32.788]  $ ...future.elements_ii    :List of 2
[17:45:32.788]   ..$ : int 1
[17:45:32.788]   ..$ : int 0
[17:45:32.788]  $ ...future.seeds_ii       : NULL
[17:45:32.788]  $ ...future.globals.maxSize: NULL
[17:45:32.788]  - attr(*, "where")=List of 5
[17:45:32.788]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:32.788]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:32.788]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:32.788]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:32.788]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:32.788]  - attr(*, "resolved")= logi FALSE
[17:45:32.788]  - attr(*, "total_size")= num 4720
[17:45:32.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:32.788]  - attr(*, "already-done")= logi TRUE
[17:45:32.794] - reassign environment for ‘...future.FUN’
[17:45:32.794] - copied ‘...future.FUN’ to environment
[17:45:32.795] - copied ‘future.call.arguments’ to environment
[17:45:32.795] - copied ‘...future.elements_ii’ to environment
[17:45:32.795] - copied ‘...future.seeds_ii’ to environment
[17:45:32.795] - copied ‘...future.globals.maxSize’ to environment
[17:45:32.795] assign_globals() ... done
[17:45:32.795] plan(): Setting new future strategy stack:
[17:45:32.795] List of future strategies:
[17:45:32.795] 1. sequential:
[17:45:32.795]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:32.795]    - tweaked: FALSE
[17:45:32.795]    - call: NULL
[17:45:32.796] plan(): nbrOfWorkers() = 1
[17:45:33.297] plan(): Setting new future strategy stack:
[17:45:33.298] List of future strategies:
[17:45:33.298] 1. sequential:
[17:45:33.298]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:33.298]    - tweaked: FALSE
[17:45:33.298]    - call: plan(strategy)
[17:45:33.298] plan(): nbrOfWorkers() = 1
[17:45:33.298] SequentialFuture started (and completed)
[17:45:33.298] - Launch lazy future ... done
[17:45:33.299] run() for ‘SequentialFuture’ ... done
[17:45:33.299] Created future:
[17:45:33.299] SequentialFuture:
[17:45:33.299] Label: ‘future_lapply-1’
[17:45:33.299] Expression:
[17:45:33.299] {
[17:45:33.299]     do.call(function(...) {
[17:45:33.299]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:33.299]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:33.299]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:33.299]             on.exit(options(oopts), add = TRUE)
[17:45:33.299]         }
[17:45:33.299]         {
[17:45:33.299]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:33.299]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:33.299]                 ...future.FUN(...future.X_jj, ...)
[17:45:33.299]             })
[17:45:33.299]         }
[17:45:33.299]     }, args = future.call.arguments)
[17:45:33.299] }
[17:45:33.299] Lazy evaluation: FALSE
[17:45:33.299] Asynchronous evaluation: FALSE
[17:45:33.299] Local evaluation: TRUE
[17:45:33.299] Environment: R_GlobalEnv
[17:45:33.299] Capture standard output: NA
[17:45:33.299] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:33.299] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:33.299] Packages: <none>
[17:45:33.299] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:33.299] Resolved: TRUE
[17:45:33.299] Value: 112 bytes of class ‘list’
[17:45:33.299] Early signaling: FALSE
[17:45:33.299] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:33.299] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:33.300] Chunk #1 of 1 ... DONE
[17:45:33.300] Launching 1 futures (chunks) ... DONE
[17:45:33.300] Resolving 1 futures (chunks) ...
[17:45:33.300] resolve() on list ...
[17:45:33.300]  recursive: 0
[17:45:33.300]  length: 1
[17:45:33.300] 
[17:45:33.301] resolved() for ‘SequentialFuture’ ...
[17:45:33.301] - state: ‘finished’
[17:45:33.301] - run: TRUE
[17:45:33.301] - result: ‘FutureResult’
[17:45:33.301] resolved() for ‘SequentialFuture’ ... done
[17:45:33.301] Future #1
[17:45:33.301] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:33.301] - nx: 1
[17:45:33.301] - relay: TRUE
[17:45:33.301] - stdout: TRUE
[17:45:33.302] - signal: TRUE
[17:45:33.302] - resignal: FALSE
[17:45:33.302] - force: TRUE
[17:45:33.302] - relayed: [n=1] FALSE
[17:45:33.302] - queued futures: [n=1] FALSE
[17:45:33.302]  - until=1
[17:45:33.302]  - relaying element #1
[17:45:33.302] - relayed: [n=1] TRUE
[17:45:33.302] - queued futures: [n=1] TRUE
[17:45:33.302] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:33.303]  length: 0 (resolved future 1)
[17:45:33.303] Relaying remaining futures
[17:45:33.303] signalConditionsASAP(NULL, pos=0) ...
[17:45:33.303] - nx: 1
[17:45:33.303] - relay: TRUE
[17:45:33.303] - stdout: TRUE
[17:45:33.303] - signal: TRUE
[17:45:33.303] - resignal: FALSE
[17:45:33.303] - force: TRUE
[17:45:33.303] - relayed: [n=1] TRUE
[17:45:33.303] - queued futures: [n=1] TRUE
 - flush all
[17:45:33.304] - relayed: [n=1] TRUE
[17:45:33.304] - queued futures: [n=1] TRUE
[17:45:33.304] signalConditionsASAP(NULL, pos=0) ... done
[17:45:33.304] resolve() on list ... DONE
[17:45:33.304]  - Number of value chunks collected: 1
[17:45:33.304] Resolving 1 futures (chunks) ... DONE
[17:45:33.304] Reducing values from 1 chunks ...
[17:45:33.304]  - Number of values collected after concatenation: 2
[17:45:33.304]  - Number of values expected: 2
[17:45:33.304] Reducing values from 1 chunks ... DONE
[17:45:33.304] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:45:33.305] future_mapply() ...
[17:45:33.305] Number of chunks: 1
[17:45:33.305] getGlobalsAndPackagesXApply() ...
[17:45:33.305]  - future.globals: TRUE
[17:45:33.305] getGlobalsAndPackages() ...
[17:45:33.305] Searching for globals...
[17:45:33.307] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:33.307] Searching for globals ... DONE
[17:45:33.307] Resolving globals: FALSE
[17:45:33.307] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:33.308] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:33.308] - globals: [1] ‘FUN’
[17:45:33.308] 
[17:45:33.308] getGlobalsAndPackages() ... DONE
[17:45:33.308]  - globals found/used: [n=1] ‘FUN’
[17:45:33.308]  - needed namespaces: [n=0] 
[17:45:33.308] Finding globals ... DONE
[17:45:33.309] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:33.309] List of 2
[17:45:33.309]  $ ...future.FUN:function (x, y)  
[17:45:33.309]  $ MoreArgs     : NULL
[17:45:33.309]  - attr(*, "where")=List of 2
[17:45:33.309]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:33.309]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:33.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:33.309]  - attr(*, "resolved")= logi FALSE
[17:45:33.309]  - attr(*, "total_size")= num NA
[17:45:33.311] Packages to be attached in all futures: [n=0] 
[17:45:33.311] getGlobalsAndPackagesXApply() ... DONE
[17:45:33.311] Number of futures (= number of chunks): 1
[17:45:33.312] Launching 1 futures (chunks) ...
[17:45:33.312] Chunk #1 of 1 ...
[17:45:33.312]  - Finding globals in '...' for chunk #1 ...
[17:45:33.312] getGlobalsAndPackages() ...
[17:45:33.312] Searching for globals...
[17:45:33.312] 
[17:45:33.312] Searching for globals ... DONE
[17:45:33.312] - globals: [0] <none>
[17:45:33.313] getGlobalsAndPackages() ... DONE
[17:45:33.313]    + additional globals found: [n=0] 
[17:45:33.313]    + additional namespaces needed: [n=0] 
[17:45:33.313]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:33.313]  - seeds: <none>
[17:45:33.313]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:33.313] getGlobalsAndPackages() ...
[17:45:33.313] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:33.313] Resolving globals: FALSE
[17:45:33.314] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:45:33.314] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:33.314] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:33.314] 
[17:45:33.315] getGlobalsAndPackages() ... DONE
[17:45:33.315] run() for ‘Future’ ...
[17:45:33.315] - state: ‘created’
[17:45:33.315] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:33.315] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:33.316] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:33.316]   - Field: ‘label’
[17:45:33.316]   - Field: ‘local’
[17:45:33.316]   - Field: ‘owner’
[17:45:33.316]   - Field: ‘envir’
[17:45:33.316]   - Field: ‘packages’
[17:45:33.316]   - Field: ‘gc’
[17:45:33.316]   - Field: ‘conditions’
[17:45:33.316]   - Field: ‘expr’
[17:45:33.316]   - Field: ‘uuid’
[17:45:33.317]   - Field: ‘seed’
[17:45:33.317]   - Field: ‘version’
[17:45:33.317]   - Field: ‘result’
[17:45:33.317]   - Field: ‘asynchronous’
[17:45:33.317]   - Field: ‘calls’
[17:45:33.317]   - Field: ‘globals’
[17:45:33.317]   - Field: ‘stdout’
[17:45:33.317]   - Field: ‘earlySignal’
[17:45:33.317]   - Field: ‘lazy’
[17:45:33.317]   - Field: ‘state’
[17:45:33.318] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:33.318] - Launch lazy future ...
[17:45:33.318] Packages needed by the future expression (n = 0): <none>
[17:45:33.318] Packages needed by future strategies (n = 0): <none>
[17:45:33.318] {
[17:45:33.318]     {
[17:45:33.318]         {
[17:45:33.318]             ...future.startTime <- base::Sys.time()
[17:45:33.318]             {
[17:45:33.318]                 {
[17:45:33.318]                   {
[17:45:33.318]                     base::local({
[17:45:33.318]                       has_future <- base::requireNamespace("future", 
[17:45:33.318]                         quietly = TRUE)
[17:45:33.318]                       if (has_future) {
[17:45:33.318]                         ns <- base::getNamespace("future")
[17:45:33.318]                         version <- ns[[".package"]][["version"]]
[17:45:33.318]                         if (is.null(version)) 
[17:45:33.318]                           version <- utils::packageVersion("future")
[17:45:33.318]                       }
[17:45:33.318]                       else {
[17:45:33.318]                         version <- NULL
[17:45:33.318]                       }
[17:45:33.318]                       if (!has_future || version < "1.8.0") {
[17:45:33.318]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:33.318]                           "", base::R.version$version.string), 
[17:45:33.318]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:33.318]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:33.318]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:33.318]                             "release", "version")], collapse = " "), 
[17:45:33.318]                           hostname = base::Sys.info()[["nodename"]])
[17:45:33.318]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:33.318]                           info)
[17:45:33.318]                         info <- base::paste(info, collapse = "; ")
[17:45:33.318]                         if (!has_future) {
[17:45:33.318]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:33.318]                             info)
[17:45:33.318]                         }
[17:45:33.318]                         else {
[17:45:33.318]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:33.318]                             info, version)
[17:45:33.318]                         }
[17:45:33.318]                         base::stop(msg)
[17:45:33.318]                       }
[17:45:33.318]                     })
[17:45:33.318]                   }
[17:45:33.318]                   ...future.strategy.old <- future::plan("list")
[17:45:33.318]                   options(future.plan = NULL)
[17:45:33.318]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:33.318]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:33.318]                 }
[17:45:33.318]                 ...future.workdir <- getwd()
[17:45:33.318]             }
[17:45:33.318]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:33.318]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:33.318]         }
[17:45:33.318]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:33.318]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:33.318]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:33.318]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:33.318]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:33.318]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:33.318]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:33.318]             base::names(...future.oldOptions))
[17:45:33.318]     }
[17:45:33.318]     if (FALSE) {
[17:45:33.318]     }
[17:45:33.318]     else {
[17:45:33.318]         if (FALSE) {
[17:45:33.318]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:33.318]                 open = "w")
[17:45:33.318]         }
[17:45:33.318]         else {
[17:45:33.318]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:33.318]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:33.318]         }
[17:45:33.318]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:33.318]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:33.318]             base::sink(type = "output", split = FALSE)
[17:45:33.318]             base::close(...future.stdout)
[17:45:33.318]         }, add = TRUE)
[17:45:33.318]     }
[17:45:33.318]     ...future.frame <- base::sys.nframe()
[17:45:33.318]     ...future.conditions <- base::list()
[17:45:33.318]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:33.318]     if (FALSE) {
[17:45:33.318]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:33.318]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:33.318]     }
[17:45:33.318]     ...future.result <- base::tryCatch({
[17:45:33.318]         base::withCallingHandlers({
[17:45:33.318]             ...future.value <- base::withVisible(base::local({
[17:45:33.318]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:33.318]                 if (!identical(...future.globals.maxSize.org, 
[17:45:33.318]                   ...future.globals.maxSize)) {
[17:45:33.318]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:33.318]                   on.exit(options(oopts), add = TRUE)
[17:45:33.318]                 }
[17:45:33.318]                 {
[17:45:33.318]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:33.318]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:33.318]                     USE.NAMES = FALSE)
[17:45:33.318]                   do.call(mapply, args = args)
[17:45:33.318]                 }
[17:45:33.318]             }))
[17:45:33.318]             future::FutureResult(value = ...future.value$value, 
[17:45:33.318]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:33.318]                   ...future.rng), globalenv = if (FALSE) 
[17:45:33.318]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:33.318]                     ...future.globalenv.names))
[17:45:33.318]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:33.318]         }, condition = base::local({
[17:45:33.318]             c <- base::c
[17:45:33.318]             inherits <- base::inherits
[17:45:33.318]             invokeRestart <- base::invokeRestart
[17:45:33.318]             length <- base::length
[17:45:33.318]             list <- base::list
[17:45:33.318]             seq.int <- base::seq.int
[17:45:33.318]             signalCondition <- base::signalCondition
[17:45:33.318]             sys.calls <- base::sys.calls
[17:45:33.318]             `[[` <- base::`[[`
[17:45:33.318]             `+` <- base::`+`
[17:45:33.318]             `<<-` <- base::`<<-`
[17:45:33.318]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:33.318]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:33.318]                   3L)]
[17:45:33.318]             }
[17:45:33.318]             function(cond) {
[17:45:33.318]                 is_error <- inherits(cond, "error")
[17:45:33.318]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:33.318]                   NULL)
[17:45:33.318]                 if (is_error) {
[17:45:33.318]                   sessionInformation <- function() {
[17:45:33.318]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:33.318]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:33.318]                       search = base::search(), system = base::Sys.info())
[17:45:33.318]                   }
[17:45:33.318]                   ...future.conditions[[length(...future.conditions) + 
[17:45:33.318]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:33.318]                     cond$call), session = sessionInformation(), 
[17:45:33.318]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:33.318]                   signalCondition(cond)
[17:45:33.318]                 }
[17:45:33.318]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:33.318]                 "immediateCondition"))) {
[17:45:33.318]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:33.318]                   ...future.conditions[[length(...future.conditions) + 
[17:45:33.318]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:33.318]                   if (TRUE && !signal) {
[17:45:33.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:33.318]                     {
[17:45:33.318]                       inherits <- base::inherits
[17:45:33.318]                       invokeRestart <- base::invokeRestart
[17:45:33.318]                       is.null <- base::is.null
[17:45:33.318]                       muffled <- FALSE
[17:45:33.318]                       if (inherits(cond, "message")) {
[17:45:33.318]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:33.318]                         if (muffled) 
[17:45:33.318]                           invokeRestart("muffleMessage")
[17:45:33.318]                       }
[17:45:33.318]                       else if (inherits(cond, "warning")) {
[17:45:33.318]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:33.318]                         if (muffled) 
[17:45:33.318]                           invokeRestart("muffleWarning")
[17:45:33.318]                       }
[17:45:33.318]                       else if (inherits(cond, "condition")) {
[17:45:33.318]                         if (!is.null(pattern)) {
[17:45:33.318]                           computeRestarts <- base::computeRestarts
[17:45:33.318]                           grepl <- base::grepl
[17:45:33.318]                           restarts <- computeRestarts(cond)
[17:45:33.318]                           for (restart in restarts) {
[17:45:33.318]                             name <- restart$name
[17:45:33.318]                             if (is.null(name)) 
[17:45:33.318]                               next
[17:45:33.318]                             if (!grepl(pattern, name)) 
[17:45:33.318]                               next
[17:45:33.318]                             invokeRestart(restart)
[17:45:33.318]                             muffled <- TRUE
[17:45:33.318]                             break
[17:45:33.318]                           }
[17:45:33.318]                         }
[17:45:33.318]                       }
[17:45:33.318]                       invisible(muffled)
[17:45:33.318]                     }
[17:45:33.318]                     muffleCondition(cond, pattern = "^muffle")
[17:45:33.318]                   }
[17:45:33.318]                 }
[17:45:33.318]                 else {
[17:45:33.318]                   if (TRUE) {
[17:45:33.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:33.318]                     {
[17:45:33.318]                       inherits <- base::inherits
[17:45:33.318]                       invokeRestart <- base::invokeRestart
[17:45:33.318]                       is.null <- base::is.null
[17:45:33.318]                       muffled <- FALSE
[17:45:33.318]                       if (inherits(cond, "message")) {
[17:45:33.318]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:33.318]                         if (muffled) 
[17:45:33.318]                           invokeRestart("muffleMessage")
[17:45:33.318]                       }
[17:45:33.318]                       else if (inherits(cond, "warning")) {
[17:45:33.318]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:33.318]                         if (muffled) 
[17:45:33.318]                           invokeRestart("muffleWarning")
[17:45:33.318]                       }
[17:45:33.318]                       else if (inherits(cond, "condition")) {
[17:45:33.318]                         if (!is.null(pattern)) {
[17:45:33.318]                           computeRestarts <- base::computeRestarts
[17:45:33.318]                           grepl <- base::grepl
[17:45:33.318]                           restarts <- computeRestarts(cond)
[17:45:33.318]                           for (restart in restarts) {
[17:45:33.318]                             name <- restart$name
[17:45:33.318]                             if (is.null(name)) 
[17:45:33.318]                               next
[17:45:33.318]                             if (!grepl(pattern, name)) 
[17:45:33.318]                               next
[17:45:33.318]                             invokeRestart(restart)
[17:45:33.318]                             muffled <- TRUE
[17:45:33.318]                             break
[17:45:33.318]                           }
[17:45:33.318]                         }
[17:45:33.318]                       }
[17:45:33.318]                       invisible(muffled)
[17:45:33.318]                     }
[17:45:33.318]                     muffleCondition(cond, pattern = "^muffle")
[17:45:33.318]                   }
[17:45:33.318]                 }
[17:45:33.318]             }
[17:45:33.318]         }))
[17:45:33.318]     }, error = function(ex) {
[17:45:33.318]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:33.318]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:33.318]                 ...future.rng), started = ...future.startTime, 
[17:45:33.318]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:33.318]             version = "1.8"), class = "FutureResult")
[17:45:33.318]     }, finally = {
[17:45:33.318]         if (!identical(...future.workdir, getwd())) 
[17:45:33.318]             setwd(...future.workdir)
[17:45:33.318]         {
[17:45:33.318]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:33.318]                 ...future.oldOptions$nwarnings <- NULL
[17:45:33.318]             }
[17:45:33.318]             base::options(...future.oldOptions)
[17:45:33.318]             if (.Platform$OS.type == "windows") {
[17:45:33.318]                 old_names <- names(...future.oldEnvVars)
[17:45:33.318]                 envs <- base::Sys.getenv()
[17:45:33.318]                 names <- names(envs)
[17:45:33.318]                 common <- intersect(names, old_names)
[17:45:33.318]                 added <- setdiff(names, old_names)
[17:45:33.318]                 removed <- setdiff(old_names, names)
[17:45:33.318]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:33.318]                   envs[common]]
[17:45:33.318]                 NAMES <- toupper(changed)
[17:45:33.318]                 args <- list()
[17:45:33.318]                 for (kk in seq_along(NAMES)) {
[17:45:33.318]                   name <- changed[[kk]]
[17:45:33.318]                   NAME <- NAMES[[kk]]
[17:45:33.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:33.318]                     next
[17:45:33.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:33.318]                 }
[17:45:33.318]                 NAMES <- toupper(added)
[17:45:33.318]                 for (kk in seq_along(NAMES)) {
[17:45:33.318]                   name <- added[[kk]]
[17:45:33.318]                   NAME <- NAMES[[kk]]
[17:45:33.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:33.318]                     next
[17:45:33.318]                   args[[name]] <- ""
[17:45:33.318]                 }
[17:45:33.318]                 NAMES <- toupper(removed)
[17:45:33.318]                 for (kk in seq_along(NAMES)) {
[17:45:33.318]                   name <- removed[[kk]]
[17:45:33.318]                   NAME <- NAMES[[kk]]
[17:45:33.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:33.318]                     next
[17:45:33.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:33.318]                 }
[17:45:33.318]                 if (length(args) > 0) 
[17:45:33.318]                   base::do.call(base::Sys.setenv, args = args)
[17:45:33.318]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:33.318]             }
[17:45:33.318]             else {
[17:45:33.318]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:33.318]             }
[17:45:33.318]             {
[17:45:33.318]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:33.318]                   0L) {
[17:45:33.318]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:33.318]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:33.318]                   base::options(opts)
[17:45:33.318]                 }
[17:45:33.318]                 {
[17:45:33.318]                   {
[17:45:33.318]                     NULL
[17:45:33.318]                     RNGkind("Mersenne-Twister")
[17:45:33.318]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:33.318]                       inherits = FALSE)
[17:45:33.318]                   }
[17:45:33.318]                   options(future.plan = NULL)
[17:45:33.318]                   if (is.na(NA_character_)) 
[17:45:33.318]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:33.318]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:33.318]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:33.318]                     .init = FALSE)
[17:45:33.318]                 }
[17:45:33.318]             }
[17:45:33.318]         }
[17:45:33.318]     })
[17:45:33.318]     if (TRUE) {
[17:45:33.318]         base::sink(type = "output", split = FALSE)
[17:45:33.318]         if (FALSE) {
[17:45:33.318]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:33.318]         }
[17:45:33.318]         else {
[17:45:33.318]             ...future.result["stdout"] <- base::list(NULL)
[17:45:33.318]         }
[17:45:33.318]         base::close(...future.stdout)
[17:45:33.318]         ...future.stdout <- NULL
[17:45:33.318]     }
[17:45:33.318]     ...future.result$conditions <- ...future.conditions
[17:45:33.318]     ...future.result$finished <- base::Sys.time()
[17:45:33.318]     ...future.result
[17:45:33.318] }
[17:45:33.320] assign_globals() ...
[17:45:33.320] List of 5
[17:45:33.320]  $ ...future.FUN            :function (x, y)  
[17:45:33.320]  $ MoreArgs                 : NULL
[17:45:33.320]  $ ...future.elements_ii    :List of 2
[17:45:33.320]   ..$ :List of 2
[17:45:33.320]   .. ..$ : int 1
[17:45:33.320]   .. ..$ : int 0
[17:45:33.320]   ..$ :List of 2
[17:45:33.320]   .. ..$ : int 0
[17:45:33.320]   .. ..$ : int 1
[17:45:33.320]  $ ...future.seeds_ii       : NULL
[17:45:33.320]  $ ...future.globals.maxSize: NULL
[17:45:33.320]  - attr(*, "where")=List of 5
[17:45:33.320]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:33.320]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:33.320]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:33.320]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:33.320]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:33.320]  - attr(*, "resolved")= logi FALSE
[17:45:33.320]  - attr(*, "total_size")= num 6480
[17:45:33.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:33.320]  - attr(*, "already-done")= logi TRUE
[17:45:33.327] - reassign environment for ‘...future.FUN’
[17:45:33.328] - copied ‘...future.FUN’ to environment
[17:45:33.328] - copied ‘MoreArgs’ to environment
[17:45:33.328] - copied ‘...future.elements_ii’ to environment
[17:45:33.328] - copied ‘...future.seeds_ii’ to environment
[17:45:33.328] - copied ‘...future.globals.maxSize’ to environment
[17:45:33.328] assign_globals() ... done
[17:45:33.328] plan(): Setting new future strategy stack:
[17:45:33.328] List of future strategies:
[17:45:33.328] 1. sequential:
[17:45:33.328]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:33.328]    - tweaked: FALSE
[17:45:33.328]    - call: NULL
[17:45:33.329] plan(): nbrOfWorkers() = 1
[17:45:33.830] plan(): Setting new future strategy stack:
[17:45:33.831] List of future strategies:
[17:45:33.831] 1. sequential:
[17:45:33.831]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:33.831]    - tweaked: FALSE
[17:45:33.831]    - call: plan(strategy)
[17:45:33.831] plan(): nbrOfWorkers() = 1
[17:45:33.831] SequentialFuture started (and completed)
[17:45:33.832] - Launch lazy future ... done
[17:45:33.832] run() for ‘SequentialFuture’ ... done
[17:45:33.832] Created future:
[17:45:33.832] SequentialFuture:
[17:45:33.832] Label: ‘future_mapply-1’
[17:45:33.832] Expression:
[17:45:33.832] {
[17:45:33.832]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:33.832]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:33.832]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:33.832]         on.exit(options(oopts), add = TRUE)
[17:45:33.832]     }
[17:45:33.832]     {
[17:45:33.832]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:33.832]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:33.832]         do.call(mapply, args = args)
[17:45:33.832]     }
[17:45:33.832] }
[17:45:33.832] Lazy evaluation: FALSE
[17:45:33.832] Asynchronous evaluation: FALSE
[17:45:33.832] Local evaluation: TRUE
[17:45:33.832] Environment: R_GlobalEnv
[17:45:33.832] Capture standard output: FALSE
[17:45:33.832] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:33.832] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:33.832] Packages: <none>
[17:45:33.832] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:33.832] Resolved: TRUE
[17:45:33.832] Value: 224 bytes of class ‘list’
[17:45:33.832] Early signaling: FALSE
[17:45:33.832] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:33.832] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:33.833] Chunk #1 of 1 ... DONE
[17:45:33.833] Launching 1 futures (chunks) ... DONE
[17:45:33.833] Resolving 1 futures (chunks) ...
[17:45:33.833] resolve() on list ...
[17:45:33.833]  recursive: 0
[17:45:33.834]  length: 1
[17:45:33.834] 
[17:45:33.834] resolved() for ‘SequentialFuture’ ...
[17:45:33.834] - state: ‘finished’
[17:45:33.834] - run: TRUE
[17:45:33.834] - result: ‘FutureResult’
[17:45:33.834] resolved() for ‘SequentialFuture’ ... done
[17:45:33.834] Future #1
[17:45:33.834] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:33.834] - nx: 1
[17:45:33.834] - relay: TRUE
[17:45:33.835] - stdout: TRUE
[17:45:33.835] - signal: TRUE
[17:45:33.835] - resignal: FALSE
[17:45:33.835] - force: TRUE
[17:45:33.835] - relayed: [n=1] FALSE
[17:45:33.835] - queued futures: [n=1] FALSE
[17:45:33.835]  - until=1
[17:45:33.835]  - relaying element #1
[17:45:33.835] - relayed: [n=1] TRUE
[17:45:33.835] - queued futures: [n=1] TRUE
[17:45:33.836] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:33.836]  length: 0 (resolved future 1)
[17:45:33.836] Relaying remaining futures
[17:45:33.836] signalConditionsASAP(NULL, pos=0) ...
[17:45:33.836] - nx: 1
[17:45:33.836] - relay: TRUE
[17:45:33.836] - stdout: TRUE
[17:45:33.836] - signal: TRUE
[17:45:33.836] - resignal: FALSE
[17:45:33.836] - force: TRUE
[17:45:33.836] - relayed: [n=1] TRUE
[17:45:33.836] - queued futures: [n=1] TRUE
 - flush all
[17:45:33.837] - relayed: [n=1] TRUE
[17:45:33.837] - queued futures: [n=1] TRUE
[17:45:33.837] signalConditionsASAP(NULL, pos=0) ... done
[17:45:33.837] resolve() on list ... DONE
[17:45:33.837]  - Number of value chunks collected: 1
[17:45:33.837] Resolving 1 futures (chunks) ... DONE
[17:45:33.837] Reducing values from 1 chunks ...
[17:45:33.837]  - Number of values collected after concatenation: 2
[17:45:33.837]  - Number of values expected: 2
[17:45:33.837] Reducing values from 1 chunks ... DONE
[17:45:33.838] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:45:33.838] future_mapply() ...
[17:45:33.838] Number of chunks: 1
[17:45:33.838] getGlobalsAndPackagesXApply() ...
[17:45:33.838]  - future.globals: TRUE
[17:45:33.838] getGlobalsAndPackages() ...
[17:45:33.839] Searching for globals...
[17:45:33.840] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:33.840] Searching for globals ... DONE
[17:45:33.840] Resolving globals: FALSE
[17:45:33.841] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:33.841] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:33.841] - globals: [1] ‘FUN’
[17:45:33.841] 
[17:45:33.841] getGlobalsAndPackages() ... DONE
[17:45:33.841]  - globals found/used: [n=1] ‘FUN’
[17:45:33.842]  - needed namespaces: [n=0] 
[17:45:33.842] Finding globals ... DONE
[17:45:33.842] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:33.842] List of 2
[17:45:33.842]  $ ...future.FUN:function (x, y)  
[17:45:33.842]  $ MoreArgs     : NULL
[17:45:33.842]  - attr(*, "where")=List of 2
[17:45:33.842]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:33.842]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:33.842]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:33.842]  - attr(*, "resolved")= logi FALSE
[17:45:33.842]  - attr(*, "total_size")= num NA
[17:45:33.844] Packages to be attached in all futures: [n=0] 
[17:45:33.845] getGlobalsAndPackagesXApply() ... DONE
[17:45:33.845] Number of futures (= number of chunks): 1
[17:45:33.845] Launching 1 futures (chunks) ...
[17:45:33.845] Chunk #1 of 1 ...
[17:45:33.845]  - Finding globals in '...' for chunk #1 ...
[17:45:33.845] getGlobalsAndPackages() ...
[17:45:33.845] Searching for globals...
[17:45:33.846] 
[17:45:33.846] Searching for globals ... DONE
[17:45:33.846] - globals: [0] <none>
[17:45:33.846] getGlobalsAndPackages() ... DONE
[17:45:33.846]    + additional globals found: [n=0] 
[17:45:33.846]    + additional namespaces needed: [n=0] 
[17:45:33.846]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:33.846]  - seeds: <none>
[17:45:33.846]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:33.846] getGlobalsAndPackages() ...
[17:45:33.846] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:33.847] Resolving globals: FALSE
[17:45:33.847] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:45:33.848] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:33.848] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:33.848] 
[17:45:33.848] getGlobalsAndPackages() ... DONE
[17:45:33.850] run() for ‘Future’ ...
[17:45:33.850] - state: ‘created’
[17:45:33.850] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:33.850] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:33.851] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:33.851]   - Field: ‘label’
[17:45:33.851]   - Field: ‘local’
[17:45:33.851]   - Field: ‘owner’
[17:45:33.851]   - Field: ‘envir’
[17:45:33.851]   - Field: ‘packages’
[17:45:33.851]   - Field: ‘gc’
[17:45:33.851]   - Field: ‘conditions’
[17:45:33.851]   - Field: ‘expr’
[17:45:33.852]   - Field: ‘uuid’
[17:45:33.852]   - Field: ‘seed’
[17:45:33.852]   - Field: ‘version’
[17:45:33.852]   - Field: ‘result’
[17:45:33.852]   - Field: ‘asynchronous’
[17:45:33.852]   - Field: ‘calls’
[17:45:33.852]   - Field: ‘globals’
[17:45:33.852]   - Field: ‘stdout’
[17:45:33.852]   - Field: ‘earlySignal’
[17:45:33.852]   - Field: ‘lazy’
[17:45:33.852]   - Field: ‘state’
[17:45:33.853] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:33.853] - Launch lazy future ...
[17:45:33.853] Packages needed by the future expression (n = 0): <none>
[17:45:33.853] Packages needed by future strategies (n = 0): <none>
[17:45:33.853] {
[17:45:33.853]     {
[17:45:33.853]         {
[17:45:33.853]             ...future.startTime <- base::Sys.time()
[17:45:33.853]             {
[17:45:33.853]                 {
[17:45:33.853]                   {
[17:45:33.853]                     base::local({
[17:45:33.853]                       has_future <- base::requireNamespace("future", 
[17:45:33.853]                         quietly = TRUE)
[17:45:33.853]                       if (has_future) {
[17:45:33.853]                         ns <- base::getNamespace("future")
[17:45:33.853]                         version <- ns[[".package"]][["version"]]
[17:45:33.853]                         if (is.null(version)) 
[17:45:33.853]                           version <- utils::packageVersion("future")
[17:45:33.853]                       }
[17:45:33.853]                       else {
[17:45:33.853]                         version <- NULL
[17:45:33.853]                       }
[17:45:33.853]                       if (!has_future || version < "1.8.0") {
[17:45:33.853]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:33.853]                           "", base::R.version$version.string), 
[17:45:33.853]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:33.853]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:33.853]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:33.853]                             "release", "version")], collapse = " "), 
[17:45:33.853]                           hostname = base::Sys.info()[["nodename"]])
[17:45:33.853]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:33.853]                           info)
[17:45:33.853]                         info <- base::paste(info, collapse = "; ")
[17:45:33.853]                         if (!has_future) {
[17:45:33.853]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:33.853]                             info)
[17:45:33.853]                         }
[17:45:33.853]                         else {
[17:45:33.853]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:33.853]                             info, version)
[17:45:33.853]                         }
[17:45:33.853]                         base::stop(msg)
[17:45:33.853]                       }
[17:45:33.853]                     })
[17:45:33.853]                   }
[17:45:33.853]                   ...future.strategy.old <- future::plan("list")
[17:45:33.853]                   options(future.plan = NULL)
[17:45:33.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:33.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:33.853]                 }
[17:45:33.853]                 ...future.workdir <- getwd()
[17:45:33.853]             }
[17:45:33.853]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:33.853]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:33.853]         }
[17:45:33.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:33.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:33.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:33.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:33.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:33.853]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:33.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:33.853]             base::names(...future.oldOptions))
[17:45:33.853]     }
[17:45:33.853]     if (FALSE) {
[17:45:33.853]     }
[17:45:33.853]     else {
[17:45:33.853]         if (TRUE) {
[17:45:33.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:33.853]                 open = "w")
[17:45:33.853]         }
[17:45:33.853]         else {
[17:45:33.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:33.853]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:33.853]         }
[17:45:33.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:33.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:33.853]             base::sink(type = "output", split = FALSE)
[17:45:33.853]             base::close(...future.stdout)
[17:45:33.853]         }, add = TRUE)
[17:45:33.853]     }
[17:45:33.853]     ...future.frame <- base::sys.nframe()
[17:45:33.853]     ...future.conditions <- base::list()
[17:45:33.853]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:33.853]     if (FALSE) {
[17:45:33.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:33.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:33.853]     }
[17:45:33.853]     ...future.result <- base::tryCatch({
[17:45:33.853]         base::withCallingHandlers({
[17:45:33.853]             ...future.value <- base::withVisible(base::local({
[17:45:33.853]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:33.853]                 if (!identical(...future.globals.maxSize.org, 
[17:45:33.853]                   ...future.globals.maxSize)) {
[17:45:33.853]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:33.853]                   on.exit(options(oopts), add = TRUE)
[17:45:33.853]                 }
[17:45:33.853]                 {
[17:45:33.853]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:33.853]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:33.853]                     USE.NAMES = FALSE)
[17:45:33.853]                   do.call(mapply, args = args)
[17:45:33.853]                 }
[17:45:33.853]             }))
[17:45:33.853]             future::FutureResult(value = ...future.value$value, 
[17:45:33.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:33.853]                   ...future.rng), globalenv = if (FALSE) 
[17:45:33.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:33.853]                     ...future.globalenv.names))
[17:45:33.853]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:33.853]         }, condition = base::local({
[17:45:33.853]             c <- base::c
[17:45:33.853]             inherits <- base::inherits
[17:45:33.853]             invokeRestart <- base::invokeRestart
[17:45:33.853]             length <- base::length
[17:45:33.853]             list <- base::list
[17:45:33.853]             seq.int <- base::seq.int
[17:45:33.853]             signalCondition <- base::signalCondition
[17:45:33.853]             sys.calls <- base::sys.calls
[17:45:33.853]             `[[` <- base::`[[`
[17:45:33.853]             `+` <- base::`+`
[17:45:33.853]             `<<-` <- base::`<<-`
[17:45:33.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:33.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:33.853]                   3L)]
[17:45:33.853]             }
[17:45:33.853]             function(cond) {
[17:45:33.853]                 is_error <- inherits(cond, "error")
[17:45:33.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:33.853]                   NULL)
[17:45:33.853]                 if (is_error) {
[17:45:33.853]                   sessionInformation <- function() {
[17:45:33.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:33.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:33.853]                       search = base::search(), system = base::Sys.info())
[17:45:33.853]                   }
[17:45:33.853]                   ...future.conditions[[length(...future.conditions) + 
[17:45:33.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:33.853]                     cond$call), session = sessionInformation(), 
[17:45:33.853]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:33.853]                   signalCondition(cond)
[17:45:33.853]                 }
[17:45:33.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:33.853]                 "immediateCondition"))) {
[17:45:33.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:33.853]                   ...future.conditions[[length(...future.conditions) + 
[17:45:33.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:33.853]                   if (TRUE && !signal) {
[17:45:33.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:33.853]                     {
[17:45:33.853]                       inherits <- base::inherits
[17:45:33.853]                       invokeRestart <- base::invokeRestart
[17:45:33.853]                       is.null <- base::is.null
[17:45:33.853]                       muffled <- FALSE
[17:45:33.853]                       if (inherits(cond, "message")) {
[17:45:33.853]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:33.853]                         if (muffled) 
[17:45:33.853]                           invokeRestart("muffleMessage")
[17:45:33.853]                       }
[17:45:33.853]                       else if (inherits(cond, "warning")) {
[17:45:33.853]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:33.853]                         if (muffled) 
[17:45:33.853]                           invokeRestart("muffleWarning")
[17:45:33.853]                       }
[17:45:33.853]                       else if (inherits(cond, "condition")) {
[17:45:33.853]                         if (!is.null(pattern)) {
[17:45:33.853]                           computeRestarts <- base::computeRestarts
[17:45:33.853]                           grepl <- base::grepl
[17:45:33.853]                           restarts <- computeRestarts(cond)
[17:45:33.853]                           for (restart in restarts) {
[17:45:33.853]                             name <- restart$name
[17:45:33.853]                             if (is.null(name)) 
[17:45:33.853]                               next
[17:45:33.853]                             if (!grepl(pattern, name)) 
[17:45:33.853]                               next
[17:45:33.853]                             invokeRestart(restart)
[17:45:33.853]                             muffled <- TRUE
[17:45:33.853]                             break
[17:45:33.853]                           }
[17:45:33.853]                         }
[17:45:33.853]                       }
[17:45:33.853]                       invisible(muffled)
[17:45:33.853]                     }
[17:45:33.853]                     muffleCondition(cond, pattern = "^muffle")
[17:45:33.853]                   }
[17:45:33.853]                 }
[17:45:33.853]                 else {
[17:45:33.853]                   if (TRUE) {
[17:45:33.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:33.853]                     {
[17:45:33.853]                       inherits <- base::inherits
[17:45:33.853]                       invokeRestart <- base::invokeRestart
[17:45:33.853]                       is.null <- base::is.null
[17:45:33.853]                       muffled <- FALSE
[17:45:33.853]                       if (inherits(cond, "message")) {
[17:45:33.853]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:33.853]                         if (muffled) 
[17:45:33.853]                           invokeRestart("muffleMessage")
[17:45:33.853]                       }
[17:45:33.853]                       else if (inherits(cond, "warning")) {
[17:45:33.853]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:33.853]                         if (muffled) 
[17:45:33.853]                           invokeRestart("muffleWarning")
[17:45:33.853]                       }
[17:45:33.853]                       else if (inherits(cond, "condition")) {
[17:45:33.853]                         if (!is.null(pattern)) {
[17:45:33.853]                           computeRestarts <- base::computeRestarts
[17:45:33.853]                           grepl <- base::grepl
[17:45:33.853]                           restarts <- computeRestarts(cond)
[17:45:33.853]                           for (restart in restarts) {
[17:45:33.853]                             name <- restart$name
[17:45:33.853]                             if (is.null(name)) 
[17:45:33.853]                               next
[17:45:33.853]                             if (!grepl(pattern, name)) 
[17:45:33.853]                               next
[17:45:33.853]                             invokeRestart(restart)
[17:45:33.853]                             muffled <- TRUE
[17:45:33.853]                             break
[17:45:33.853]                           }
[17:45:33.853]                         }
[17:45:33.853]                       }
[17:45:33.853]                       invisible(muffled)
[17:45:33.853]                     }
[17:45:33.853]                     muffleCondition(cond, pattern = "^muffle")
[17:45:33.853]                   }
[17:45:33.853]                 }
[17:45:33.853]             }
[17:45:33.853]         }))
[17:45:33.853]     }, error = function(ex) {
[17:45:33.853]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:33.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:33.853]                 ...future.rng), started = ...future.startTime, 
[17:45:33.853]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:33.853]             version = "1.8"), class = "FutureResult")
[17:45:33.853]     }, finally = {
[17:45:33.853]         if (!identical(...future.workdir, getwd())) 
[17:45:33.853]             setwd(...future.workdir)
[17:45:33.853]         {
[17:45:33.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:33.853]                 ...future.oldOptions$nwarnings <- NULL
[17:45:33.853]             }
[17:45:33.853]             base::options(...future.oldOptions)
[17:45:33.853]             if (.Platform$OS.type == "windows") {
[17:45:33.853]                 old_names <- names(...future.oldEnvVars)
[17:45:33.853]                 envs <- base::Sys.getenv()
[17:45:33.853]                 names <- names(envs)
[17:45:33.853]                 common <- intersect(names, old_names)
[17:45:33.853]                 added <- setdiff(names, old_names)
[17:45:33.853]                 removed <- setdiff(old_names, names)
[17:45:33.853]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:33.853]                   envs[common]]
[17:45:33.853]                 NAMES <- toupper(changed)
[17:45:33.853]                 args <- list()
[17:45:33.853]                 for (kk in seq_along(NAMES)) {
[17:45:33.853]                   name <- changed[[kk]]
[17:45:33.853]                   NAME <- NAMES[[kk]]
[17:45:33.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:33.853]                     next
[17:45:33.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:33.853]                 }
[17:45:33.853]                 NAMES <- toupper(added)
[17:45:33.853]                 for (kk in seq_along(NAMES)) {
[17:45:33.853]                   name <- added[[kk]]
[17:45:33.853]                   NAME <- NAMES[[kk]]
[17:45:33.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:33.853]                     next
[17:45:33.853]                   args[[name]] <- ""
[17:45:33.853]                 }
[17:45:33.853]                 NAMES <- toupper(removed)
[17:45:33.853]                 for (kk in seq_along(NAMES)) {
[17:45:33.853]                   name <- removed[[kk]]
[17:45:33.853]                   NAME <- NAMES[[kk]]
[17:45:33.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:33.853]                     next
[17:45:33.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:33.853]                 }
[17:45:33.853]                 if (length(args) > 0) 
[17:45:33.853]                   base::do.call(base::Sys.setenv, args = args)
[17:45:33.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:33.853]             }
[17:45:33.853]             else {
[17:45:33.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:33.853]             }
[17:45:33.853]             {
[17:45:33.853]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:33.853]                   0L) {
[17:45:33.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:33.853]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:33.853]                   base::options(opts)
[17:45:33.853]                 }
[17:45:33.853]                 {
[17:45:33.853]                   {
[17:45:33.853]                     NULL
[17:45:33.853]                     RNGkind("Mersenne-Twister")
[17:45:33.853]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:33.853]                       inherits = FALSE)
[17:45:33.853]                   }
[17:45:33.853]                   options(future.plan = NULL)
[17:45:33.853]                   if (is.na(NA_character_)) 
[17:45:33.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:33.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:33.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:33.853]                     .init = FALSE)
[17:45:33.853]                 }
[17:45:33.853]             }
[17:45:33.853]         }
[17:45:33.853]     })
[17:45:33.853]     if (TRUE) {
[17:45:33.853]         base::sink(type = "output", split = FALSE)
[17:45:33.853]         if (TRUE) {
[17:45:33.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:33.853]         }
[17:45:33.853]         else {
[17:45:33.853]             ...future.result["stdout"] <- base::list(NULL)
[17:45:33.853]         }
[17:45:33.853]         base::close(...future.stdout)
[17:45:33.853]         ...future.stdout <- NULL
[17:45:33.853]     }
[17:45:33.853]     ...future.result$conditions <- ...future.conditions
[17:45:33.853]     ...future.result$finished <- base::Sys.time()
[17:45:33.853]     ...future.result
[17:45:33.853] }
[17:45:33.855] assign_globals() ...
[17:45:33.855] List of 5
[17:45:33.855]  $ ...future.FUN            :function (x, y)  
[17:45:33.855]  $ MoreArgs                 : NULL
[17:45:33.855]  $ ...future.elements_ii    :List of 2
[17:45:33.855]   ..$ :List of 2
[17:45:33.855]   .. ..$ : int 1
[17:45:33.855]   .. ..$ : int 0
[17:45:33.855]   ..$ :List of 2
[17:45:33.855]   .. ..$ : int 0
[17:45:33.855]   .. ..$ : int 1
[17:45:33.855]  $ ...future.seeds_ii       : NULL
[17:45:33.855]  $ ...future.globals.maxSize: NULL
[17:45:33.855]  - attr(*, "where")=List of 5
[17:45:33.855]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:33.855]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:33.855]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:33.855]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:33.855]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:33.855]  - attr(*, "resolved")= logi FALSE
[17:45:33.855]  - attr(*, "total_size")= num 6480
[17:45:33.855]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:33.855]  - attr(*, "already-done")= logi TRUE
[17:45:33.860] - reassign environment for ‘...future.FUN’
[17:45:33.861] - copied ‘...future.FUN’ to environment
[17:45:33.861] - copied ‘MoreArgs’ to environment
[17:45:33.861] - copied ‘...future.elements_ii’ to environment
[17:45:33.861] - copied ‘...future.seeds_ii’ to environment
[17:45:33.861] - copied ‘...future.globals.maxSize’ to environment
[17:45:33.861] assign_globals() ... done
[17:45:33.861] plan(): Setting new future strategy stack:
[17:45:33.861] List of future strategies:
[17:45:33.861] 1. sequential:
[17:45:33.861]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:33.861]    - tweaked: FALSE
[17:45:33.861]    - call: NULL
[17:45:33.862] plan(): nbrOfWorkers() = 1
[17:45:34.364] plan(): Setting new future strategy stack:
[17:45:34.364] List of future strategies:
[17:45:34.364] 1. sequential:
[17:45:34.364]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:34.364]    - tweaked: FALSE
[17:45:34.364]    - call: plan(strategy)
[17:45:34.364] plan(): nbrOfWorkers() = 1
[17:45:34.365] SequentialFuture started (and completed)
[17:45:34.365] - Launch lazy future ... done
[17:45:34.365] run() for ‘SequentialFuture’ ... done
[17:45:34.365] Created future:
[17:45:34.365] SequentialFuture:
[17:45:34.365] Label: ‘future_mapply-1’
[17:45:34.365] Expression:
[17:45:34.365] {
[17:45:34.365]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:34.365]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:34.365]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:34.365]         on.exit(options(oopts), add = TRUE)
[17:45:34.365]     }
[17:45:34.365]     {
[17:45:34.365]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:34.365]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:34.365]         do.call(mapply, args = args)
[17:45:34.365]     }
[17:45:34.365] }
[17:45:34.365] Lazy evaluation: FALSE
[17:45:34.365] Asynchronous evaluation: FALSE
[17:45:34.365] Local evaluation: TRUE
[17:45:34.365] Environment: R_GlobalEnv
[17:45:34.365] Capture standard output: TRUE
[17:45:34.365] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:34.365] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:34.365] Packages: <none>
[17:45:34.365] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:34.365] Resolved: TRUE
[17:45:34.365] Value: 224 bytes of class ‘list’
[17:45:34.365] Early signaling: FALSE
[17:45:34.365] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:34.365] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:34.366] Chunk #1 of 1 ... DONE
[17:45:34.366] Launching 1 futures (chunks) ... DONE
[17:45:34.366] Resolving 1 futures (chunks) ...
[17:45:34.366] resolve() on list ...
[17:45:34.366]  recursive: 0
[17:45:34.366]  length: 1
[17:45:34.367] 
[17:45:34.367] resolved() for ‘SequentialFuture’ ...
[17:45:34.367] - state: ‘finished’
[17:45:34.367] - run: TRUE
[17:45:34.367] - result: ‘FutureResult’
[17:45:34.367] resolved() for ‘SequentialFuture’ ... done
[17:45:34.367] Future #1
[17:45:34.367] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:34.367] - nx: 1
[17:45:34.367] - relay: TRUE
[17:45:34.368] - stdout: TRUE
[17:45:34.368] - signal: TRUE
[17:45:34.368] - resignal: FALSE
[17:45:34.368] - force: TRUE
[17:45:34.368] - relayed: [n=1] FALSE
[17:45:34.368] - queued futures: [n=1] FALSE
[17:45:34.368]  - until=1
[17:45:34.368]  - relaying element #1
[17:45:34.368] - relayed: [n=1] TRUE
[17:45:34.368] - queued futures: [n=1] TRUE
[17:45:34.369] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:34.369]  length: 0 (resolved future 1)
[17:45:34.369] Relaying remaining futures
[17:45:34.369] signalConditionsASAP(NULL, pos=0) ...
[17:45:34.369] - nx: 1
[17:45:34.369] - relay: TRUE
[17:45:34.369] - stdout: TRUE
[17:45:34.369] - signal: TRUE
[17:45:34.369] - resignal: FALSE
[17:45:34.369] - force: TRUE
[17:45:34.369] - relayed: [n=1] TRUE
[17:45:34.369] - queued futures: [n=1] TRUE
 - flush all
[17:45:34.370] - relayed: [n=1] TRUE
[17:45:34.370] - queued futures: [n=1] TRUE
[17:45:34.370] signalConditionsASAP(NULL, pos=0) ... done
[17:45:34.370] resolve() on list ... DONE
[17:45:34.370]  - Number of value chunks collected: 1
[17:45:34.370] Resolving 1 futures (chunks) ... DONE
[17:45:34.370] Reducing values from 1 chunks ...
[17:45:34.370]  - Number of values collected after concatenation: 2
[17:45:34.370]  - Number of values expected: 2
[17:45:34.370] Reducing values from 1 chunks ... DONE
[17:45:34.371] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:45:34.371] future_mapply() ...
[17:45:34.371] Number of chunks: 1
[17:45:34.371] getGlobalsAndPackagesXApply() ...
[17:45:34.371]  - future.globals: TRUE
[17:45:34.371] getGlobalsAndPackages() ...
[17:45:34.371] Searching for globals...
[17:45:34.373] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:34.373] Searching for globals ... DONE
[17:45:34.373] Resolving globals: FALSE
[17:45:34.374] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:34.374] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:34.374] - globals: [1] ‘FUN’
[17:45:34.374] 
[17:45:34.374] getGlobalsAndPackages() ... DONE
[17:45:34.374]  - globals found/used: [n=1] ‘FUN’
[17:45:34.374]  - needed namespaces: [n=0] 
[17:45:34.375] Finding globals ... DONE
[17:45:34.375] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:34.375] List of 2
[17:45:34.375]  $ ...future.FUN:function (x, y)  
[17:45:34.375]  $ MoreArgs     : NULL
[17:45:34.375]  - attr(*, "where")=List of 2
[17:45:34.375]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:34.375]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:34.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:34.375]  - attr(*, "resolved")= logi FALSE
[17:45:34.375]  - attr(*, "total_size")= num NA
[17:45:34.379] Packages to be attached in all futures: [n=0] 
[17:45:34.379] getGlobalsAndPackagesXApply() ... DONE
[17:45:34.379] Number of futures (= number of chunks): 1
[17:45:34.380] Launching 1 futures (chunks) ...
[17:45:34.380] Chunk #1 of 1 ...
[17:45:34.380]  - Finding globals in '...' for chunk #1 ...
[17:45:34.380] getGlobalsAndPackages() ...
[17:45:34.380] Searching for globals...
[17:45:34.380] 
[17:45:34.380] Searching for globals ... DONE
[17:45:34.381] - globals: [0] <none>
[17:45:34.381] getGlobalsAndPackages() ... DONE
[17:45:34.381]    + additional globals found: [n=0] 
[17:45:34.381]    + additional namespaces needed: [n=0] 
[17:45:34.381]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:34.381]  - seeds: <none>
[17:45:34.381]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:34.381] getGlobalsAndPackages() ...
[17:45:34.381] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:34.381] Resolving globals: FALSE
[17:45:34.382] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:45:34.382] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:34.382] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:34.383] 
[17:45:34.383] getGlobalsAndPackages() ... DONE
[17:45:34.383] run() for ‘Future’ ...
[17:45:34.383] - state: ‘created’
[17:45:34.383] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:34.383] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:34.384] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:34.384]   - Field: ‘label’
[17:45:34.384]   - Field: ‘local’
[17:45:34.384]   - Field: ‘owner’
[17:45:34.384]   - Field: ‘envir’
[17:45:34.384]   - Field: ‘packages’
[17:45:34.384]   - Field: ‘gc’
[17:45:34.384]   - Field: ‘conditions’
[17:45:34.384]   - Field: ‘expr’
[17:45:34.384]   - Field: ‘uuid’
[17:45:34.385]   - Field: ‘seed’
[17:45:34.385]   - Field: ‘version’
[17:45:34.385]   - Field: ‘result’
[17:45:34.385]   - Field: ‘asynchronous’
[17:45:34.385]   - Field: ‘calls’
[17:45:34.385]   - Field: ‘globals’
[17:45:34.385]   - Field: ‘stdout’
[17:45:34.385]   - Field: ‘earlySignal’
[17:45:34.385]   - Field: ‘lazy’
[17:45:34.385]   - Field: ‘state’
[17:45:34.386] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:34.386] - Launch lazy future ...
[17:45:34.386] Packages needed by the future expression (n = 0): <none>
[17:45:34.386] Packages needed by future strategies (n = 0): <none>
[17:45:34.386] {
[17:45:34.386]     {
[17:45:34.386]         {
[17:45:34.386]             ...future.startTime <- base::Sys.time()
[17:45:34.386]             {
[17:45:34.386]                 {
[17:45:34.386]                   {
[17:45:34.386]                     base::local({
[17:45:34.386]                       has_future <- base::requireNamespace("future", 
[17:45:34.386]                         quietly = TRUE)
[17:45:34.386]                       if (has_future) {
[17:45:34.386]                         ns <- base::getNamespace("future")
[17:45:34.386]                         version <- ns[[".package"]][["version"]]
[17:45:34.386]                         if (is.null(version)) 
[17:45:34.386]                           version <- utils::packageVersion("future")
[17:45:34.386]                       }
[17:45:34.386]                       else {
[17:45:34.386]                         version <- NULL
[17:45:34.386]                       }
[17:45:34.386]                       if (!has_future || version < "1.8.0") {
[17:45:34.386]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:34.386]                           "", base::R.version$version.string), 
[17:45:34.386]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:34.386]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:34.386]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:34.386]                             "release", "version")], collapse = " "), 
[17:45:34.386]                           hostname = base::Sys.info()[["nodename"]])
[17:45:34.386]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:34.386]                           info)
[17:45:34.386]                         info <- base::paste(info, collapse = "; ")
[17:45:34.386]                         if (!has_future) {
[17:45:34.386]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:34.386]                             info)
[17:45:34.386]                         }
[17:45:34.386]                         else {
[17:45:34.386]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:34.386]                             info, version)
[17:45:34.386]                         }
[17:45:34.386]                         base::stop(msg)
[17:45:34.386]                       }
[17:45:34.386]                     })
[17:45:34.386]                   }
[17:45:34.386]                   ...future.strategy.old <- future::plan("list")
[17:45:34.386]                   options(future.plan = NULL)
[17:45:34.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:34.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:34.386]                 }
[17:45:34.386]                 ...future.workdir <- getwd()
[17:45:34.386]             }
[17:45:34.386]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:34.386]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:34.386]         }
[17:45:34.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:34.386]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:34.386]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:34.386]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:34.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:34.386]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:34.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:34.386]             base::names(...future.oldOptions))
[17:45:34.386]     }
[17:45:34.386]     if (TRUE) {
[17:45:34.386]     }
[17:45:34.386]     else {
[17:45:34.386]         if (NA) {
[17:45:34.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:34.386]                 open = "w")
[17:45:34.386]         }
[17:45:34.386]         else {
[17:45:34.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:34.386]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:34.386]         }
[17:45:34.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:34.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:34.386]             base::sink(type = "output", split = FALSE)
[17:45:34.386]             base::close(...future.stdout)
[17:45:34.386]         }, add = TRUE)
[17:45:34.386]     }
[17:45:34.386]     ...future.frame <- base::sys.nframe()
[17:45:34.386]     ...future.conditions <- base::list()
[17:45:34.386]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:34.386]     if (FALSE) {
[17:45:34.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:34.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:34.386]     }
[17:45:34.386]     ...future.result <- base::tryCatch({
[17:45:34.386]         base::withCallingHandlers({
[17:45:34.386]             ...future.value <- base::withVisible(base::local({
[17:45:34.386]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:34.386]                 if (!identical(...future.globals.maxSize.org, 
[17:45:34.386]                   ...future.globals.maxSize)) {
[17:45:34.386]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:34.386]                   on.exit(options(oopts), add = TRUE)
[17:45:34.386]                 }
[17:45:34.386]                 {
[17:45:34.386]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:34.386]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:34.386]                     USE.NAMES = FALSE)
[17:45:34.386]                   do.call(mapply, args = args)
[17:45:34.386]                 }
[17:45:34.386]             }))
[17:45:34.386]             future::FutureResult(value = ...future.value$value, 
[17:45:34.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:34.386]                   ...future.rng), globalenv = if (FALSE) 
[17:45:34.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:34.386]                     ...future.globalenv.names))
[17:45:34.386]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:34.386]         }, condition = base::local({
[17:45:34.386]             c <- base::c
[17:45:34.386]             inherits <- base::inherits
[17:45:34.386]             invokeRestart <- base::invokeRestart
[17:45:34.386]             length <- base::length
[17:45:34.386]             list <- base::list
[17:45:34.386]             seq.int <- base::seq.int
[17:45:34.386]             signalCondition <- base::signalCondition
[17:45:34.386]             sys.calls <- base::sys.calls
[17:45:34.386]             `[[` <- base::`[[`
[17:45:34.386]             `+` <- base::`+`
[17:45:34.386]             `<<-` <- base::`<<-`
[17:45:34.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:34.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:34.386]                   3L)]
[17:45:34.386]             }
[17:45:34.386]             function(cond) {
[17:45:34.386]                 is_error <- inherits(cond, "error")
[17:45:34.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:34.386]                   NULL)
[17:45:34.386]                 if (is_error) {
[17:45:34.386]                   sessionInformation <- function() {
[17:45:34.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:34.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:34.386]                       search = base::search(), system = base::Sys.info())
[17:45:34.386]                   }
[17:45:34.386]                   ...future.conditions[[length(...future.conditions) + 
[17:45:34.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:34.386]                     cond$call), session = sessionInformation(), 
[17:45:34.386]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:34.386]                   signalCondition(cond)
[17:45:34.386]                 }
[17:45:34.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:34.386]                 "immediateCondition"))) {
[17:45:34.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:34.386]                   ...future.conditions[[length(...future.conditions) + 
[17:45:34.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:34.386]                   if (TRUE && !signal) {
[17:45:34.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:34.386]                     {
[17:45:34.386]                       inherits <- base::inherits
[17:45:34.386]                       invokeRestart <- base::invokeRestart
[17:45:34.386]                       is.null <- base::is.null
[17:45:34.386]                       muffled <- FALSE
[17:45:34.386]                       if (inherits(cond, "message")) {
[17:45:34.386]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:34.386]                         if (muffled) 
[17:45:34.386]                           invokeRestart("muffleMessage")
[17:45:34.386]                       }
[17:45:34.386]                       else if (inherits(cond, "warning")) {
[17:45:34.386]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:34.386]                         if (muffled) 
[17:45:34.386]                           invokeRestart("muffleWarning")
[17:45:34.386]                       }
[17:45:34.386]                       else if (inherits(cond, "condition")) {
[17:45:34.386]                         if (!is.null(pattern)) {
[17:45:34.386]                           computeRestarts <- base::computeRestarts
[17:45:34.386]                           grepl <- base::grepl
[17:45:34.386]                           restarts <- computeRestarts(cond)
[17:45:34.386]                           for (restart in restarts) {
[17:45:34.386]                             name <- restart$name
[17:45:34.386]                             if (is.null(name)) 
[17:45:34.386]                               next
[17:45:34.386]                             if (!grepl(pattern, name)) 
[17:45:34.386]                               next
[17:45:34.386]                             invokeRestart(restart)
[17:45:34.386]                             muffled <- TRUE
[17:45:34.386]                             break
[17:45:34.386]                           }
[17:45:34.386]                         }
[17:45:34.386]                       }
[17:45:34.386]                       invisible(muffled)
[17:45:34.386]                     }
[17:45:34.386]                     muffleCondition(cond, pattern = "^muffle")
[17:45:34.386]                   }
[17:45:34.386]                 }
[17:45:34.386]                 else {
[17:45:34.386]                   if (TRUE) {
[17:45:34.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:34.386]                     {
[17:45:34.386]                       inherits <- base::inherits
[17:45:34.386]                       invokeRestart <- base::invokeRestart
[17:45:34.386]                       is.null <- base::is.null
[17:45:34.386]                       muffled <- FALSE
[17:45:34.386]                       if (inherits(cond, "message")) {
[17:45:34.386]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:34.386]                         if (muffled) 
[17:45:34.386]                           invokeRestart("muffleMessage")
[17:45:34.386]                       }
[17:45:34.386]                       else if (inherits(cond, "warning")) {
[17:45:34.386]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:34.386]                         if (muffled) 
[17:45:34.386]                           invokeRestart("muffleWarning")
[17:45:34.386]                       }
[17:45:34.386]                       else if (inherits(cond, "condition")) {
[17:45:34.386]                         if (!is.null(pattern)) {
[17:45:34.386]                           computeRestarts <- base::computeRestarts
[17:45:34.386]                           grepl <- base::grepl
[17:45:34.386]                           restarts <- computeRestarts(cond)
[17:45:34.386]                           for (restart in restarts) {
[17:45:34.386]                             name <- restart$name
[17:45:34.386]                             if (is.null(name)) 
[17:45:34.386]                               next
[17:45:34.386]                             if (!grepl(pattern, name)) 
[17:45:34.386]                               next
[17:45:34.386]                             invokeRestart(restart)
[17:45:34.386]                             muffled <- TRUE
[17:45:34.386]                             break
[17:45:34.386]                           }
[17:45:34.386]                         }
[17:45:34.386]                       }
[17:45:34.386]                       invisible(muffled)
[17:45:34.386]                     }
[17:45:34.386]                     muffleCondition(cond, pattern = "^muffle")
[17:45:34.386]                   }
[17:45:34.386]                 }
[17:45:34.386]             }
[17:45:34.386]         }))
[17:45:34.386]     }, error = function(ex) {
[17:45:34.386]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:34.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:34.386]                 ...future.rng), started = ...future.startTime, 
[17:45:34.386]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:34.386]             version = "1.8"), class = "FutureResult")
[17:45:34.386]     }, finally = {
[17:45:34.386]         if (!identical(...future.workdir, getwd())) 
[17:45:34.386]             setwd(...future.workdir)
[17:45:34.386]         {
[17:45:34.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:34.386]                 ...future.oldOptions$nwarnings <- NULL
[17:45:34.386]             }
[17:45:34.386]             base::options(...future.oldOptions)
[17:45:34.386]             if (.Platform$OS.type == "windows") {
[17:45:34.386]                 old_names <- names(...future.oldEnvVars)
[17:45:34.386]                 envs <- base::Sys.getenv()
[17:45:34.386]                 names <- names(envs)
[17:45:34.386]                 common <- intersect(names, old_names)
[17:45:34.386]                 added <- setdiff(names, old_names)
[17:45:34.386]                 removed <- setdiff(old_names, names)
[17:45:34.386]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:34.386]                   envs[common]]
[17:45:34.386]                 NAMES <- toupper(changed)
[17:45:34.386]                 args <- list()
[17:45:34.386]                 for (kk in seq_along(NAMES)) {
[17:45:34.386]                   name <- changed[[kk]]
[17:45:34.386]                   NAME <- NAMES[[kk]]
[17:45:34.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:34.386]                     next
[17:45:34.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:34.386]                 }
[17:45:34.386]                 NAMES <- toupper(added)
[17:45:34.386]                 for (kk in seq_along(NAMES)) {
[17:45:34.386]                   name <- added[[kk]]
[17:45:34.386]                   NAME <- NAMES[[kk]]
[17:45:34.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:34.386]                     next
[17:45:34.386]                   args[[name]] <- ""
[17:45:34.386]                 }
[17:45:34.386]                 NAMES <- toupper(removed)
[17:45:34.386]                 for (kk in seq_along(NAMES)) {
[17:45:34.386]                   name <- removed[[kk]]
[17:45:34.386]                   NAME <- NAMES[[kk]]
[17:45:34.386]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:34.386]                     next
[17:45:34.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:34.386]                 }
[17:45:34.386]                 if (length(args) > 0) 
[17:45:34.386]                   base::do.call(base::Sys.setenv, args = args)
[17:45:34.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:34.386]             }
[17:45:34.386]             else {
[17:45:34.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:34.386]             }
[17:45:34.386]             {
[17:45:34.386]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:34.386]                   0L) {
[17:45:34.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:34.386]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:34.386]                   base::options(opts)
[17:45:34.386]                 }
[17:45:34.386]                 {
[17:45:34.386]                   {
[17:45:34.386]                     NULL
[17:45:34.386]                     RNGkind("Mersenne-Twister")
[17:45:34.386]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:34.386]                       inherits = FALSE)
[17:45:34.386]                   }
[17:45:34.386]                   options(future.plan = NULL)
[17:45:34.386]                   if (is.na(NA_character_)) 
[17:45:34.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:34.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:34.386]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:34.386]                     .init = FALSE)
[17:45:34.386]                 }
[17:45:34.386]             }
[17:45:34.386]         }
[17:45:34.386]     })
[17:45:34.386]     if (FALSE) {
[17:45:34.386]         base::sink(type = "output", split = FALSE)
[17:45:34.386]         if (NA) {
[17:45:34.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:34.386]         }
[17:45:34.386]         else {
[17:45:34.386]             ...future.result["stdout"] <- base::list(NULL)
[17:45:34.386]         }
[17:45:34.386]         base::close(...future.stdout)
[17:45:34.386]         ...future.stdout <- NULL
[17:45:34.386]     }
[17:45:34.386]     ...future.result$conditions <- ...future.conditions
[17:45:34.386]     ...future.result$finished <- base::Sys.time()
[17:45:34.386]     ...future.result
[17:45:34.386] }
[17:45:34.388] assign_globals() ...
[17:45:34.388] List of 5
[17:45:34.388]  $ ...future.FUN            :function (x, y)  
[17:45:34.388]  $ MoreArgs                 : NULL
[17:45:34.388]  $ ...future.elements_ii    :List of 2
[17:45:34.388]   ..$ :List of 2
[17:45:34.388]   .. ..$ : int 1
[17:45:34.388]   .. ..$ : int 0
[17:45:34.388]   ..$ :List of 2
[17:45:34.388]   .. ..$ : int 0
[17:45:34.388]   .. ..$ : int 1
[17:45:34.388]  $ ...future.seeds_ii       : NULL
[17:45:34.388]  $ ...future.globals.maxSize: NULL
[17:45:34.388]  - attr(*, "where")=List of 5
[17:45:34.388]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:34.388]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:34.388]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:34.388]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:34.388]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:34.388]  - attr(*, "resolved")= logi FALSE
[17:45:34.388]  - attr(*, "total_size")= num 6480
[17:45:34.388]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:34.388]  - attr(*, "already-done")= logi TRUE
[17:45:34.393] - reassign environment for ‘...future.FUN’
[17:45:34.394] - copied ‘...future.FUN’ to environment
[17:45:34.394] - copied ‘MoreArgs’ to environment
[17:45:34.394] - copied ‘...future.elements_ii’ to environment
[17:45:34.394] - copied ‘...future.seeds_ii’ to environment
[17:45:34.394] - copied ‘...future.globals.maxSize’ to environment
[17:45:34.394] assign_globals() ... done
[17:45:34.394] plan(): Setting new future strategy stack:
[17:45:34.394] List of future strategies:
[17:45:34.394] 1. sequential:
[17:45:34.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:34.394]    - tweaked: FALSE
[17:45:34.394]    - call: NULL
[17:45:34.395] plan(): nbrOfWorkers() = 1
[17:45:34.896] plan(): Setting new future strategy stack:
[17:45:34.897] List of future strategies:
[17:45:34.897] 1. sequential:
[17:45:34.897]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:34.897]    - tweaked: FALSE
[17:45:34.897]    - call: plan(strategy)
[17:45:34.897] plan(): nbrOfWorkers() = 1
[17:45:34.897] SequentialFuture started (and completed)
[17:45:34.897] - Launch lazy future ... done
[17:45:34.898] run() for ‘SequentialFuture’ ... done
[17:45:34.898] Created future:
[17:45:34.898] SequentialFuture:
[17:45:34.898] Label: ‘future_mapply-1’
[17:45:34.898] Expression:
[17:45:34.898] {
[17:45:34.898]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:34.898]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:34.898]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:34.898]         on.exit(options(oopts), add = TRUE)
[17:45:34.898]     }
[17:45:34.898]     {
[17:45:34.898]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:34.898]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:34.898]         do.call(mapply, args = args)
[17:45:34.898]     }
[17:45:34.898] }
[17:45:34.898] Lazy evaluation: FALSE
[17:45:34.898] Asynchronous evaluation: FALSE
[17:45:34.898] Local evaluation: TRUE
[17:45:34.898] Environment: R_GlobalEnv
[17:45:34.898] Capture standard output: NA
[17:45:34.898] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:34.898] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:34.898] Packages: <none>
[17:45:34.898] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:34.898] Resolved: TRUE
[17:45:34.898] Value: 224 bytes of class ‘list’
[17:45:34.898] Early signaling: FALSE
[17:45:34.898] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:34.898] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:34.899] Chunk #1 of 1 ... DONE
[17:45:34.899] Launching 1 futures (chunks) ... DONE
[17:45:34.899] Resolving 1 futures (chunks) ...
[17:45:34.899] resolve() on list ...
[17:45:34.899]  recursive: 0
[17:45:34.899]  length: 1
[17:45:34.899] 
[17:45:34.899] resolved() for ‘SequentialFuture’ ...
[17:45:34.900] - state: ‘finished’
[17:45:34.900] - run: TRUE
[17:45:34.900] - result: ‘FutureResult’
[17:45:34.900] resolved() for ‘SequentialFuture’ ... done
[17:45:34.900] Future #1
[17:45:34.900] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:34.900] - nx: 1
[17:45:34.900] - relay: TRUE
[17:45:34.900] - stdout: TRUE
[17:45:34.900] - signal: TRUE
[17:45:34.900] - resignal: FALSE
[17:45:34.901] - force: TRUE
[17:45:34.901] - relayed: [n=1] FALSE
[17:45:34.901] - queued futures: [n=1] FALSE
[17:45:34.901]  - until=1
[17:45:34.901]  - relaying element #1
[17:45:34.901] - relayed: [n=1] TRUE
[17:45:34.901] - queued futures: [n=1] TRUE
[17:45:34.901] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:34.901]  length: 0 (resolved future 1)
[17:45:34.901] Relaying remaining futures
[17:45:34.902] signalConditionsASAP(NULL, pos=0) ...
[17:45:34.902] - nx: 1
[17:45:34.902] - relay: TRUE
[17:45:34.902] - stdout: TRUE
[17:45:34.902] - signal: TRUE
[17:45:34.902] - resignal: FALSE
[17:45:34.902] - force: TRUE
[17:45:34.902] - relayed: [n=1] TRUE
[17:45:34.902] - queued futures: [n=1] TRUE
 - flush all
[17:45:34.902] - relayed: [n=1] TRUE
[17:45:34.902] - queued futures: [n=1] TRUE
[17:45:34.902] signalConditionsASAP(NULL, pos=0) ... done
[17:45:34.903] resolve() on list ... DONE
[17:45:34.903]  - Number of value chunks collected: 1
[17:45:34.903] Resolving 1 futures (chunks) ... DONE
[17:45:34.903] Reducing values from 1 chunks ...
[17:45:34.903]  - Number of values collected after concatenation: 2
[17:45:34.903]  - Number of values expected: 2
[17:45:34.903] Reducing values from 1 chunks ... DONE
[17:45:34.903] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[17:45:34.904] plan(): Setting new future strategy stack:
[17:45:34.904] List of future strategies:
[17:45:34.904] 1. multicore:
[17:45:34.904]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:34.904]    - tweaked: FALSE
[17:45:34.904]    - call: plan(strategy)
[17:45:34.910] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:45:34.910] future_lapply() ...
[17:45:34.914] Number of chunks: 1
[17:45:34.914] getGlobalsAndPackagesXApply() ...
[17:45:34.914]  - future.globals: TRUE
[17:45:34.914] getGlobalsAndPackages() ...
[17:45:34.914] Searching for globals...
[17:45:34.916] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:34.916] Searching for globals ... DONE
[17:45:34.916] Resolving globals: FALSE
[17:45:34.916] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:34.917] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:34.917] - globals: [1] ‘FUN’
[17:45:34.917] 
[17:45:34.917] getGlobalsAndPackages() ... DONE
[17:45:34.917]  - globals found/used: [n=1] ‘FUN’
[17:45:34.917]  - needed namespaces: [n=0] 
[17:45:34.917] Finding globals ... DONE
[17:45:34.917]  - use_args: TRUE
[17:45:34.917]  - Getting '...' globals ...
[17:45:34.918] resolve() on list ...
[17:45:34.918]  recursive: 0
[17:45:34.918]  length: 1
[17:45:34.918]  elements: ‘...’
[17:45:34.918]  length: 0 (resolved future 1)
[17:45:34.918] resolve() on list ... DONE
[17:45:34.918]    - '...' content: [n=0] 
[17:45:34.918] List of 1
[17:45:34.918]  $ ...: list()
[17:45:34.918]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:34.918]  - attr(*, "where")=List of 1
[17:45:34.918]   ..$ ...:<environment: 0x55f6c674e3a8> 
[17:45:34.918]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:34.918]  - attr(*, "resolved")= logi TRUE
[17:45:34.918]  - attr(*, "total_size")= num NA
[17:45:34.921]  - Getting '...' globals ... DONE
[17:45:34.921] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:34.921] List of 2
[17:45:34.921]  $ ...future.FUN:function (x)  
[17:45:34.921]  $ ...          : list()
[17:45:34.921]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:34.921]  - attr(*, "where")=List of 2
[17:45:34.921]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:34.921]   ..$ ...          :<environment: 0x55f6c674e3a8> 
[17:45:34.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:34.921]  - attr(*, "resolved")= logi FALSE
[17:45:34.921]  - attr(*, "total_size")= num 4720
[17:45:34.924] Packages to be attached in all futures: [n=0] 
[17:45:34.924] getGlobalsAndPackagesXApply() ... DONE
[17:45:34.924] Number of futures (= number of chunks): 1
[17:45:34.924] Launching 1 futures (chunks) ...
[17:45:34.924] Chunk #1 of 1 ...
[17:45:34.924]  - Finding globals in 'X' for chunk #1 ...
[17:45:34.924] getGlobalsAndPackages() ...
[17:45:34.925] Searching for globals...
[17:45:34.925] 
[17:45:34.925] Searching for globals ... DONE
[17:45:34.925] - globals: [0] <none>
[17:45:34.925] getGlobalsAndPackages() ... DONE
[17:45:34.925]    + additional globals found: [n=0] 
[17:45:34.925]    + additional namespaces needed: [n=0] 
[17:45:34.925]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:34.925]  - seeds: <none>
[17:45:34.925]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:34.926] getGlobalsAndPackages() ...
[17:45:34.926] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:34.926] Resolving globals: FALSE
[17:45:34.926] Tweak future expression to call with '...' arguments ...
[17:45:34.926] {
[17:45:34.926]     do.call(function(...) {
[17:45:34.926]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:34.926]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:34.926]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:34.926]             on.exit(options(oopts), add = TRUE)
[17:45:34.926]         }
[17:45:34.926]         {
[17:45:34.926]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:34.926]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:34.926]                 ...future.FUN(...future.X_jj, ...)
[17:45:34.926]             })
[17:45:34.926]         }
[17:45:34.926]     }, args = future.call.arguments)
[17:45:34.926] }
[17:45:34.926] Tweak future expression to call with '...' arguments ... DONE
[17:45:34.927] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:34.927] 
[17:45:34.927] getGlobalsAndPackages() ... DONE
[17:45:34.927] run() for ‘Future’ ...
[17:45:34.927] - state: ‘created’
[17:45:34.927] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:34.931] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:34.931] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:34.931]   - Field: ‘label’
[17:45:34.931]   - Field: ‘local’
[17:45:34.931]   - Field: ‘owner’
[17:45:34.931]   - Field: ‘envir’
[17:45:34.931]   - Field: ‘packages’
[17:45:34.931]   - Field: ‘gc’
[17:45:34.932]   - Field: ‘conditions’
[17:45:34.932]   - Field: ‘expr’
[17:45:34.932]   - Field: ‘uuid’
[17:45:34.932]   - Field: ‘seed’
[17:45:34.932]   - Field: ‘version’
[17:45:34.932]   - Field: ‘result’
[17:45:34.932]   - Field: ‘asynchronous’
[17:45:34.932]   - Field: ‘calls’
[17:45:34.932]   - Field: ‘globals’
[17:45:34.932]   - Field: ‘stdout’
[17:45:34.933]   - Field: ‘earlySignal’
[17:45:34.933]   - Field: ‘lazy’
[17:45:34.933]   - Field: ‘state’
[17:45:34.933] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:34.933] - Launch lazy future ...
[17:45:34.933] Packages needed by the future expression (n = 0): <none>
[17:45:34.933] Packages needed by future strategies (n = 0): <none>
[17:45:34.934] {
[17:45:34.934]     {
[17:45:34.934]         {
[17:45:34.934]             ...future.startTime <- base::Sys.time()
[17:45:34.934]             {
[17:45:34.934]                 {
[17:45:34.934]                   {
[17:45:34.934]                     base::local({
[17:45:34.934]                       has_future <- base::requireNamespace("future", 
[17:45:34.934]                         quietly = TRUE)
[17:45:34.934]                       if (has_future) {
[17:45:34.934]                         ns <- base::getNamespace("future")
[17:45:34.934]                         version <- ns[[".package"]][["version"]]
[17:45:34.934]                         if (is.null(version)) 
[17:45:34.934]                           version <- utils::packageVersion("future")
[17:45:34.934]                       }
[17:45:34.934]                       else {
[17:45:34.934]                         version <- NULL
[17:45:34.934]                       }
[17:45:34.934]                       if (!has_future || version < "1.8.0") {
[17:45:34.934]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:34.934]                           "", base::R.version$version.string), 
[17:45:34.934]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:34.934]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:34.934]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:34.934]                             "release", "version")], collapse = " "), 
[17:45:34.934]                           hostname = base::Sys.info()[["nodename"]])
[17:45:34.934]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:34.934]                           info)
[17:45:34.934]                         info <- base::paste(info, collapse = "; ")
[17:45:34.934]                         if (!has_future) {
[17:45:34.934]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:34.934]                             info)
[17:45:34.934]                         }
[17:45:34.934]                         else {
[17:45:34.934]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:34.934]                             info, version)
[17:45:34.934]                         }
[17:45:34.934]                         base::stop(msg)
[17:45:34.934]                       }
[17:45:34.934]                     })
[17:45:34.934]                   }
[17:45:34.934]                   ...future.strategy.old <- future::plan("list")
[17:45:34.934]                   options(future.plan = NULL)
[17:45:34.934]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:34.934]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:34.934]                 }
[17:45:34.934]                 ...future.workdir <- getwd()
[17:45:34.934]             }
[17:45:34.934]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:34.934]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:34.934]         }
[17:45:34.934]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:34.934]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:34.934]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:34.934]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:34.934]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:34.934]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:34.934]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:34.934]             base::names(...future.oldOptions))
[17:45:34.934]     }
[17:45:34.934]     if (FALSE) {
[17:45:34.934]     }
[17:45:34.934]     else {
[17:45:34.934]         if (FALSE) {
[17:45:34.934]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:34.934]                 open = "w")
[17:45:34.934]         }
[17:45:34.934]         else {
[17:45:34.934]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:34.934]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:34.934]         }
[17:45:34.934]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:34.934]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:34.934]             base::sink(type = "output", split = FALSE)
[17:45:34.934]             base::close(...future.stdout)
[17:45:34.934]         }, add = TRUE)
[17:45:34.934]     }
[17:45:34.934]     ...future.frame <- base::sys.nframe()
[17:45:34.934]     ...future.conditions <- base::list()
[17:45:34.934]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:34.934]     if (FALSE) {
[17:45:34.934]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:34.934]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:34.934]     }
[17:45:34.934]     ...future.result <- base::tryCatch({
[17:45:34.934]         base::withCallingHandlers({
[17:45:34.934]             ...future.value <- base::withVisible(base::local({
[17:45:34.934]                 do.call(function(...) {
[17:45:34.934]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:34.934]                   if (!identical(...future.globals.maxSize.org, 
[17:45:34.934]                     ...future.globals.maxSize)) {
[17:45:34.934]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:34.934]                     on.exit(options(oopts), add = TRUE)
[17:45:34.934]                   }
[17:45:34.934]                   {
[17:45:34.934]                     lapply(seq_along(...future.elements_ii), 
[17:45:34.934]                       FUN = function(jj) {
[17:45:34.934]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:34.934]                         ...future.FUN(...future.X_jj, ...)
[17:45:34.934]                       })
[17:45:34.934]                   }
[17:45:34.934]                 }, args = future.call.arguments)
[17:45:34.934]             }))
[17:45:34.934]             future::FutureResult(value = ...future.value$value, 
[17:45:34.934]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:34.934]                   ...future.rng), globalenv = if (FALSE) 
[17:45:34.934]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:34.934]                     ...future.globalenv.names))
[17:45:34.934]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:34.934]         }, condition = base::local({
[17:45:34.934]             c <- base::c
[17:45:34.934]             inherits <- base::inherits
[17:45:34.934]             invokeRestart <- base::invokeRestart
[17:45:34.934]             length <- base::length
[17:45:34.934]             list <- base::list
[17:45:34.934]             seq.int <- base::seq.int
[17:45:34.934]             signalCondition <- base::signalCondition
[17:45:34.934]             sys.calls <- base::sys.calls
[17:45:34.934]             `[[` <- base::`[[`
[17:45:34.934]             `+` <- base::`+`
[17:45:34.934]             `<<-` <- base::`<<-`
[17:45:34.934]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:34.934]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:34.934]                   3L)]
[17:45:34.934]             }
[17:45:34.934]             function(cond) {
[17:45:34.934]                 is_error <- inherits(cond, "error")
[17:45:34.934]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:34.934]                   NULL)
[17:45:34.934]                 if (is_error) {
[17:45:34.934]                   sessionInformation <- function() {
[17:45:34.934]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:34.934]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:34.934]                       search = base::search(), system = base::Sys.info())
[17:45:34.934]                   }
[17:45:34.934]                   ...future.conditions[[length(...future.conditions) + 
[17:45:34.934]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:34.934]                     cond$call), session = sessionInformation(), 
[17:45:34.934]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:34.934]                   signalCondition(cond)
[17:45:34.934]                 }
[17:45:34.934]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:34.934]                 "immediateCondition"))) {
[17:45:34.934]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:34.934]                   ...future.conditions[[length(...future.conditions) + 
[17:45:34.934]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:34.934]                   if (TRUE && !signal) {
[17:45:34.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:34.934]                     {
[17:45:34.934]                       inherits <- base::inherits
[17:45:34.934]                       invokeRestart <- base::invokeRestart
[17:45:34.934]                       is.null <- base::is.null
[17:45:34.934]                       muffled <- FALSE
[17:45:34.934]                       if (inherits(cond, "message")) {
[17:45:34.934]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:34.934]                         if (muffled) 
[17:45:34.934]                           invokeRestart("muffleMessage")
[17:45:34.934]                       }
[17:45:34.934]                       else if (inherits(cond, "warning")) {
[17:45:34.934]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:34.934]                         if (muffled) 
[17:45:34.934]                           invokeRestart("muffleWarning")
[17:45:34.934]                       }
[17:45:34.934]                       else if (inherits(cond, "condition")) {
[17:45:34.934]                         if (!is.null(pattern)) {
[17:45:34.934]                           computeRestarts <- base::computeRestarts
[17:45:34.934]                           grepl <- base::grepl
[17:45:34.934]                           restarts <- computeRestarts(cond)
[17:45:34.934]                           for (restart in restarts) {
[17:45:34.934]                             name <- restart$name
[17:45:34.934]                             if (is.null(name)) 
[17:45:34.934]                               next
[17:45:34.934]                             if (!grepl(pattern, name)) 
[17:45:34.934]                               next
[17:45:34.934]                             invokeRestart(restart)
[17:45:34.934]                             muffled <- TRUE
[17:45:34.934]                             break
[17:45:34.934]                           }
[17:45:34.934]                         }
[17:45:34.934]                       }
[17:45:34.934]                       invisible(muffled)
[17:45:34.934]                     }
[17:45:34.934]                     muffleCondition(cond, pattern = "^muffle")
[17:45:34.934]                   }
[17:45:34.934]                 }
[17:45:34.934]                 else {
[17:45:34.934]                   if (TRUE) {
[17:45:34.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:34.934]                     {
[17:45:34.934]                       inherits <- base::inherits
[17:45:34.934]                       invokeRestart <- base::invokeRestart
[17:45:34.934]                       is.null <- base::is.null
[17:45:34.934]                       muffled <- FALSE
[17:45:34.934]                       if (inherits(cond, "message")) {
[17:45:34.934]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:34.934]                         if (muffled) 
[17:45:34.934]                           invokeRestart("muffleMessage")
[17:45:34.934]                       }
[17:45:34.934]                       else if (inherits(cond, "warning")) {
[17:45:34.934]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:34.934]                         if (muffled) 
[17:45:34.934]                           invokeRestart("muffleWarning")
[17:45:34.934]                       }
[17:45:34.934]                       else if (inherits(cond, "condition")) {
[17:45:34.934]                         if (!is.null(pattern)) {
[17:45:34.934]                           computeRestarts <- base::computeRestarts
[17:45:34.934]                           grepl <- base::grepl
[17:45:34.934]                           restarts <- computeRestarts(cond)
[17:45:34.934]                           for (restart in restarts) {
[17:45:34.934]                             name <- restart$name
[17:45:34.934]                             if (is.null(name)) 
[17:45:34.934]                               next
[17:45:34.934]                             if (!grepl(pattern, name)) 
[17:45:34.934]                               next
[17:45:34.934]                             invokeRestart(restart)
[17:45:34.934]                             muffled <- TRUE
[17:45:34.934]                             break
[17:45:34.934]                           }
[17:45:34.934]                         }
[17:45:34.934]                       }
[17:45:34.934]                       invisible(muffled)
[17:45:34.934]                     }
[17:45:34.934]                     muffleCondition(cond, pattern = "^muffle")
[17:45:34.934]                   }
[17:45:34.934]                 }
[17:45:34.934]             }
[17:45:34.934]         }))
[17:45:34.934]     }, error = function(ex) {
[17:45:34.934]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:34.934]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:34.934]                 ...future.rng), started = ...future.startTime, 
[17:45:34.934]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:34.934]             version = "1.8"), class = "FutureResult")
[17:45:34.934]     }, finally = {
[17:45:34.934]         if (!identical(...future.workdir, getwd())) 
[17:45:34.934]             setwd(...future.workdir)
[17:45:34.934]         {
[17:45:34.934]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:34.934]                 ...future.oldOptions$nwarnings <- NULL
[17:45:34.934]             }
[17:45:34.934]             base::options(...future.oldOptions)
[17:45:34.934]             if (.Platform$OS.type == "windows") {
[17:45:34.934]                 old_names <- names(...future.oldEnvVars)
[17:45:34.934]                 envs <- base::Sys.getenv()
[17:45:34.934]                 names <- names(envs)
[17:45:34.934]                 common <- intersect(names, old_names)
[17:45:34.934]                 added <- setdiff(names, old_names)
[17:45:34.934]                 removed <- setdiff(old_names, names)
[17:45:34.934]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:34.934]                   envs[common]]
[17:45:34.934]                 NAMES <- toupper(changed)
[17:45:34.934]                 args <- list()
[17:45:34.934]                 for (kk in seq_along(NAMES)) {
[17:45:34.934]                   name <- changed[[kk]]
[17:45:34.934]                   NAME <- NAMES[[kk]]
[17:45:34.934]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:34.934]                     next
[17:45:34.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:34.934]                 }
[17:45:34.934]                 NAMES <- toupper(added)
[17:45:34.934]                 for (kk in seq_along(NAMES)) {
[17:45:34.934]                   name <- added[[kk]]
[17:45:34.934]                   NAME <- NAMES[[kk]]
[17:45:34.934]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:34.934]                     next
[17:45:34.934]                   args[[name]] <- ""
[17:45:34.934]                 }
[17:45:34.934]                 NAMES <- toupper(removed)
[17:45:34.934]                 for (kk in seq_along(NAMES)) {
[17:45:34.934]                   name <- removed[[kk]]
[17:45:34.934]                   NAME <- NAMES[[kk]]
[17:45:34.934]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:34.934]                     next
[17:45:34.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:34.934]                 }
[17:45:34.934]                 if (length(args) > 0) 
[17:45:34.934]                   base::do.call(base::Sys.setenv, args = args)
[17:45:34.934]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:34.934]             }
[17:45:34.934]             else {
[17:45:34.934]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:34.934]             }
[17:45:34.934]             {
[17:45:34.934]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:34.934]                   0L) {
[17:45:34.934]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:34.934]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:34.934]                   base::options(opts)
[17:45:34.934]                 }
[17:45:34.934]                 {
[17:45:34.934]                   {
[17:45:34.934]                     NULL
[17:45:34.934]                     RNGkind("Mersenne-Twister")
[17:45:34.934]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:34.934]                       inherits = FALSE)
[17:45:34.934]                   }
[17:45:34.934]                   options(future.plan = NULL)
[17:45:34.934]                   if (is.na(NA_character_)) 
[17:45:34.934]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:34.934]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:34.934]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:34.934]                     .init = FALSE)
[17:45:34.934]                 }
[17:45:34.934]             }
[17:45:34.934]         }
[17:45:34.934]     })
[17:45:34.934]     if (TRUE) {
[17:45:34.934]         base::sink(type = "output", split = FALSE)
[17:45:34.934]         if (FALSE) {
[17:45:34.934]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:34.934]         }
[17:45:34.934]         else {
[17:45:34.934]             ...future.result["stdout"] <- base::list(NULL)
[17:45:34.934]         }
[17:45:34.934]         base::close(...future.stdout)
[17:45:34.934]         ...future.stdout <- NULL
[17:45:34.934]     }
[17:45:34.934]     ...future.result$conditions <- ...future.conditions
[17:45:34.934]     ...future.result$finished <- base::Sys.time()
[17:45:34.934]     ...future.result
[17:45:34.934] }
[17:45:34.935] assign_globals() ...
[17:45:34.935] List of 5
[17:45:34.935]  $ ...future.FUN            :function (x)  
[17:45:34.935]  $ future.call.arguments    : list()
[17:45:34.935]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:34.935]  $ ...future.elements_ii    :List of 2
[17:45:34.935]   ..$ : int 1
[17:45:34.935]   ..$ : int 0
[17:45:34.935]  $ ...future.seeds_ii       : NULL
[17:45:34.935]  $ ...future.globals.maxSize: NULL
[17:45:34.935]  - attr(*, "where")=List of 5
[17:45:34.935]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:34.935]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:34.935]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:34.935]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:34.935]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:34.935]  - attr(*, "resolved")= logi FALSE
[17:45:34.935]  - attr(*, "total_size")= num 4720
[17:45:34.935]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:34.935]  - attr(*, "already-done")= logi TRUE
[17:45:34.942] - reassign environment for ‘...future.FUN’
[17:45:34.942] - copied ‘...future.FUN’ to environment
[17:45:34.942] - copied ‘future.call.arguments’ to environment
[17:45:34.942] - copied ‘...future.elements_ii’ to environment
[17:45:34.942] - copied ‘...future.seeds_ii’ to environment
[17:45:34.942] - copied ‘...future.globals.maxSize’ to environment
[17:45:34.942] assign_globals() ... done
[17:45:34.943] plan(): Setting new future strategy stack:
[17:45:34.943] List of future strategies:
[17:45:34.943] 1. sequential:
[17:45:34.943]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:34.943]    - tweaked: FALSE
[17:45:34.943]    - call: NULL
[17:45:34.943] plan(): nbrOfWorkers() = 1
[17:45:35.445] plan(): Setting new future strategy stack:
[17:45:35.445] List of future strategies:
[17:45:35.445] 1. multicore:
[17:45:35.445]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:35.445]    - tweaked: FALSE
[17:45:35.445]    - call: plan(strategy)
[17:45:35.449] plan(): nbrOfWorkers() = 1
[17:45:35.450] SequentialFuture started (and completed)
[17:45:35.450] - Launch lazy future ... done
[17:45:35.450] run() for ‘SequentialFuture’ ... done
[17:45:35.450] Created future:
[17:45:35.450] SequentialFuture:
[17:45:35.450] Label: ‘future_lapply-1’
[17:45:35.450] Expression:
[17:45:35.450] {
[17:45:35.450]     do.call(function(...) {
[17:45:35.450]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:35.450]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:35.450]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:35.450]             on.exit(options(oopts), add = TRUE)
[17:45:35.450]         }
[17:45:35.450]         {
[17:45:35.450]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:35.450]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:35.450]                 ...future.FUN(...future.X_jj, ...)
[17:45:35.450]             })
[17:45:35.450]         }
[17:45:35.450]     }, args = future.call.arguments)
[17:45:35.450] }
[17:45:35.450] Lazy evaluation: FALSE
[17:45:35.450] Asynchronous evaluation: FALSE
[17:45:35.450] Local evaluation: TRUE
[17:45:35.450] Environment: R_GlobalEnv
[17:45:35.450] Capture standard output: FALSE
[17:45:35.450] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:35.450] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:35.450] Packages: <none>
[17:45:35.450] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:35.450] Resolved: TRUE
[17:45:35.450] Value: 112 bytes of class ‘list’
[17:45:35.450] Early signaling: FALSE
[17:45:35.450] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:35.450] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:35.451] Chunk #1 of 1 ... DONE
[17:45:35.452] Launching 1 futures (chunks) ... DONE
[17:45:35.452] Resolving 1 futures (chunks) ...
[17:45:35.452] resolve() on list ...
[17:45:35.452]  recursive: 0
[17:45:35.452]  length: 1
[17:45:35.452] 
[17:45:35.452] resolved() for ‘SequentialFuture’ ...
[17:45:35.452] - state: ‘finished’
[17:45:35.452] - run: TRUE
[17:45:35.452] - result: ‘FutureResult’
[17:45:35.453] resolved() for ‘SequentialFuture’ ... done
[17:45:35.453] Future #1
[17:45:35.453] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:35.453] - nx: 1
[17:45:35.453] - relay: TRUE
[17:45:35.453] - stdout: TRUE
[17:45:35.453] - signal: TRUE
[17:45:35.453] - resignal: FALSE
[17:45:35.453] - force: TRUE
[17:45:35.453] - relayed: [n=1] FALSE
[17:45:35.453] - queued futures: [n=1] FALSE
[17:45:35.454]  - until=1
[17:45:35.454]  - relaying element #1
[17:45:35.454] - relayed: [n=1] TRUE
[17:45:35.454] - queued futures: [n=1] TRUE
[17:45:35.454] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:35.454]  length: 0 (resolved future 1)
[17:45:35.454] Relaying remaining futures
[17:45:35.454] signalConditionsASAP(NULL, pos=0) ...
[17:45:35.454] - nx: 1
[17:45:35.454] - relay: TRUE
[17:45:35.454] - stdout: TRUE
[17:45:35.455] - signal: TRUE
[17:45:35.455] - resignal: FALSE
[17:45:35.455] - force: TRUE
[17:45:35.455] - relayed: [n=1] TRUE
[17:45:35.455] - queued futures: [n=1] TRUE
 - flush all
[17:45:35.455] - relayed: [n=1] TRUE
[17:45:35.455] - queued futures: [n=1] TRUE
[17:45:35.455] signalConditionsASAP(NULL, pos=0) ... done
[17:45:35.455] resolve() on list ... DONE
[17:45:35.455]  - Number of value chunks collected: 1
[17:45:35.456] Resolving 1 futures (chunks) ... DONE
[17:45:35.456] Reducing values from 1 chunks ...
[17:45:35.456]  - Number of values collected after concatenation: 2
[17:45:35.456]  - Number of values expected: 2
[17:45:35.456] Reducing values from 1 chunks ... DONE
[17:45:35.456] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:45:35.456] future_lapply() ...
[17:45:35.460] Number of chunks: 1
[17:45:35.460] getGlobalsAndPackagesXApply() ...
[17:45:35.460]  - future.globals: TRUE
[17:45:35.461] getGlobalsAndPackages() ...
[17:45:35.461] Searching for globals...
[17:45:35.462] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:35.462] Searching for globals ... DONE
[17:45:35.462] Resolving globals: FALSE
[17:45:35.463] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:35.463] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:35.463] - globals: [1] ‘FUN’
[17:45:35.463] 
[17:45:35.463] getGlobalsAndPackages() ... DONE
[17:45:35.463]  - globals found/used: [n=1] ‘FUN’
[17:45:35.463]  - needed namespaces: [n=0] 
[17:45:35.464] Finding globals ... DONE
[17:45:35.464]  - use_args: TRUE
[17:45:35.464]  - Getting '...' globals ...
[17:45:35.464] resolve() on list ...
[17:45:35.464]  recursive: 0
[17:45:35.464]  length: 1
[17:45:35.464]  elements: ‘...’
[17:45:35.464]  length: 0 (resolved future 1)
[17:45:35.465] resolve() on list ... DONE
[17:45:35.465]    - '...' content: [n=0] 
[17:45:35.465] List of 1
[17:45:35.465]  $ ...: list()
[17:45:35.465]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:35.465]  - attr(*, "where")=List of 1
[17:45:35.465]   ..$ ...:<environment: 0x55f6c6b8cb60> 
[17:45:35.465]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:35.465]  - attr(*, "resolved")= logi TRUE
[17:45:35.465]  - attr(*, "total_size")= num NA
[17:45:35.467]  - Getting '...' globals ... DONE
[17:45:35.467] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:35.467] List of 2
[17:45:35.467]  $ ...future.FUN:function (x)  
[17:45:35.467]  $ ...          : list()
[17:45:35.467]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:35.467]  - attr(*, "where")=List of 2
[17:45:35.467]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:35.467]   ..$ ...          :<environment: 0x55f6c6b8cb60> 
[17:45:35.467]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:35.467]  - attr(*, "resolved")= logi FALSE
[17:45:35.467]  - attr(*, "total_size")= num 4720
[17:45:35.472] Packages to be attached in all futures: [n=0] 
[17:45:35.472] getGlobalsAndPackagesXApply() ... DONE
[17:45:35.472] Number of futures (= number of chunks): 1
[17:45:35.472] Launching 1 futures (chunks) ...
[17:45:35.472] Chunk #1 of 1 ...
[17:45:35.473]  - Finding globals in 'X' for chunk #1 ...
[17:45:35.473] getGlobalsAndPackages() ...
[17:45:35.473] Searching for globals...
[17:45:35.473] 
[17:45:35.473] Searching for globals ... DONE
[17:45:35.473] - globals: [0] <none>
[17:45:35.473] getGlobalsAndPackages() ... DONE
[17:45:35.473]    + additional globals found: [n=0] 
[17:45:35.473]    + additional namespaces needed: [n=0] 
[17:45:35.474]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:35.474]  - seeds: <none>
[17:45:35.474]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:35.474] getGlobalsAndPackages() ...
[17:45:35.474] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:35.474] Resolving globals: FALSE
[17:45:35.474] Tweak future expression to call with '...' arguments ...
[17:45:35.474] {
[17:45:35.474]     do.call(function(...) {
[17:45:35.474]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:35.474]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:35.474]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:35.474]             on.exit(options(oopts), add = TRUE)
[17:45:35.474]         }
[17:45:35.474]         {
[17:45:35.474]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:35.474]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:35.474]                 ...future.FUN(...future.X_jj, ...)
[17:45:35.474]             })
[17:45:35.474]         }
[17:45:35.474]     }, args = future.call.arguments)
[17:45:35.474] }
[17:45:35.474] Tweak future expression to call with '...' arguments ... DONE
[17:45:35.475] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:35.475] 
[17:45:35.475] getGlobalsAndPackages() ... DONE
[17:45:35.475] run() for ‘Future’ ...
[17:45:35.475] - state: ‘created’
[17:45:35.476] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:35.479] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:35.479] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:35.479]   - Field: ‘label’
[17:45:35.479]   - Field: ‘local’
[17:45:35.479]   - Field: ‘owner’
[17:45:35.480]   - Field: ‘envir’
[17:45:35.480]   - Field: ‘packages’
[17:45:35.480]   - Field: ‘gc’
[17:45:35.480]   - Field: ‘conditions’
[17:45:35.480]   - Field: ‘expr’
[17:45:35.480]   - Field: ‘uuid’
[17:45:35.480]   - Field: ‘seed’
[17:45:35.480]   - Field: ‘version’
[17:45:35.480]   - Field: ‘result’
[17:45:35.480]   - Field: ‘asynchronous’
[17:45:35.481]   - Field: ‘calls’
[17:45:35.481]   - Field: ‘globals’
[17:45:35.481]   - Field: ‘stdout’
[17:45:35.481]   - Field: ‘earlySignal’
[17:45:35.481]   - Field: ‘lazy’
[17:45:35.481]   - Field: ‘state’
[17:45:35.481] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:35.481] - Launch lazy future ...
[17:45:35.481] Packages needed by the future expression (n = 0): <none>
[17:45:35.482] Packages needed by future strategies (n = 0): <none>
[17:45:35.482] {
[17:45:35.482]     {
[17:45:35.482]         {
[17:45:35.482]             ...future.startTime <- base::Sys.time()
[17:45:35.482]             {
[17:45:35.482]                 {
[17:45:35.482]                   {
[17:45:35.482]                     base::local({
[17:45:35.482]                       has_future <- base::requireNamespace("future", 
[17:45:35.482]                         quietly = TRUE)
[17:45:35.482]                       if (has_future) {
[17:45:35.482]                         ns <- base::getNamespace("future")
[17:45:35.482]                         version <- ns[[".package"]][["version"]]
[17:45:35.482]                         if (is.null(version)) 
[17:45:35.482]                           version <- utils::packageVersion("future")
[17:45:35.482]                       }
[17:45:35.482]                       else {
[17:45:35.482]                         version <- NULL
[17:45:35.482]                       }
[17:45:35.482]                       if (!has_future || version < "1.8.0") {
[17:45:35.482]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:35.482]                           "", base::R.version$version.string), 
[17:45:35.482]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:35.482]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:35.482]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:35.482]                             "release", "version")], collapse = " "), 
[17:45:35.482]                           hostname = base::Sys.info()[["nodename"]])
[17:45:35.482]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:35.482]                           info)
[17:45:35.482]                         info <- base::paste(info, collapse = "; ")
[17:45:35.482]                         if (!has_future) {
[17:45:35.482]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:35.482]                             info)
[17:45:35.482]                         }
[17:45:35.482]                         else {
[17:45:35.482]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:35.482]                             info, version)
[17:45:35.482]                         }
[17:45:35.482]                         base::stop(msg)
[17:45:35.482]                       }
[17:45:35.482]                     })
[17:45:35.482]                   }
[17:45:35.482]                   ...future.strategy.old <- future::plan("list")
[17:45:35.482]                   options(future.plan = NULL)
[17:45:35.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:35.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:35.482]                 }
[17:45:35.482]                 ...future.workdir <- getwd()
[17:45:35.482]             }
[17:45:35.482]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:35.482]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:35.482]         }
[17:45:35.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:35.482]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:35.482]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:35.482]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:35.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:35.482]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:35.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:35.482]             base::names(...future.oldOptions))
[17:45:35.482]     }
[17:45:35.482]     if (FALSE) {
[17:45:35.482]     }
[17:45:35.482]     else {
[17:45:35.482]         if (TRUE) {
[17:45:35.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:35.482]                 open = "w")
[17:45:35.482]         }
[17:45:35.482]         else {
[17:45:35.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:35.482]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:35.482]         }
[17:45:35.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:35.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:35.482]             base::sink(type = "output", split = FALSE)
[17:45:35.482]             base::close(...future.stdout)
[17:45:35.482]         }, add = TRUE)
[17:45:35.482]     }
[17:45:35.482]     ...future.frame <- base::sys.nframe()
[17:45:35.482]     ...future.conditions <- base::list()
[17:45:35.482]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:35.482]     if (FALSE) {
[17:45:35.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:35.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:35.482]     }
[17:45:35.482]     ...future.result <- base::tryCatch({
[17:45:35.482]         base::withCallingHandlers({
[17:45:35.482]             ...future.value <- base::withVisible(base::local({
[17:45:35.482]                 do.call(function(...) {
[17:45:35.482]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:35.482]                   if (!identical(...future.globals.maxSize.org, 
[17:45:35.482]                     ...future.globals.maxSize)) {
[17:45:35.482]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:35.482]                     on.exit(options(oopts), add = TRUE)
[17:45:35.482]                   }
[17:45:35.482]                   {
[17:45:35.482]                     lapply(seq_along(...future.elements_ii), 
[17:45:35.482]                       FUN = function(jj) {
[17:45:35.482]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:35.482]                         ...future.FUN(...future.X_jj, ...)
[17:45:35.482]                       })
[17:45:35.482]                   }
[17:45:35.482]                 }, args = future.call.arguments)
[17:45:35.482]             }))
[17:45:35.482]             future::FutureResult(value = ...future.value$value, 
[17:45:35.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:35.482]                   ...future.rng), globalenv = if (FALSE) 
[17:45:35.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:35.482]                     ...future.globalenv.names))
[17:45:35.482]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:35.482]         }, condition = base::local({
[17:45:35.482]             c <- base::c
[17:45:35.482]             inherits <- base::inherits
[17:45:35.482]             invokeRestart <- base::invokeRestart
[17:45:35.482]             length <- base::length
[17:45:35.482]             list <- base::list
[17:45:35.482]             seq.int <- base::seq.int
[17:45:35.482]             signalCondition <- base::signalCondition
[17:45:35.482]             sys.calls <- base::sys.calls
[17:45:35.482]             `[[` <- base::`[[`
[17:45:35.482]             `+` <- base::`+`
[17:45:35.482]             `<<-` <- base::`<<-`
[17:45:35.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:35.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:35.482]                   3L)]
[17:45:35.482]             }
[17:45:35.482]             function(cond) {
[17:45:35.482]                 is_error <- inherits(cond, "error")
[17:45:35.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:35.482]                   NULL)
[17:45:35.482]                 if (is_error) {
[17:45:35.482]                   sessionInformation <- function() {
[17:45:35.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:35.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:35.482]                       search = base::search(), system = base::Sys.info())
[17:45:35.482]                   }
[17:45:35.482]                   ...future.conditions[[length(...future.conditions) + 
[17:45:35.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:35.482]                     cond$call), session = sessionInformation(), 
[17:45:35.482]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:35.482]                   signalCondition(cond)
[17:45:35.482]                 }
[17:45:35.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:35.482]                 "immediateCondition"))) {
[17:45:35.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:35.482]                   ...future.conditions[[length(...future.conditions) + 
[17:45:35.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:35.482]                   if (TRUE && !signal) {
[17:45:35.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:35.482]                     {
[17:45:35.482]                       inherits <- base::inherits
[17:45:35.482]                       invokeRestart <- base::invokeRestart
[17:45:35.482]                       is.null <- base::is.null
[17:45:35.482]                       muffled <- FALSE
[17:45:35.482]                       if (inherits(cond, "message")) {
[17:45:35.482]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:35.482]                         if (muffled) 
[17:45:35.482]                           invokeRestart("muffleMessage")
[17:45:35.482]                       }
[17:45:35.482]                       else if (inherits(cond, "warning")) {
[17:45:35.482]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:35.482]                         if (muffled) 
[17:45:35.482]                           invokeRestart("muffleWarning")
[17:45:35.482]                       }
[17:45:35.482]                       else if (inherits(cond, "condition")) {
[17:45:35.482]                         if (!is.null(pattern)) {
[17:45:35.482]                           computeRestarts <- base::computeRestarts
[17:45:35.482]                           grepl <- base::grepl
[17:45:35.482]                           restarts <- computeRestarts(cond)
[17:45:35.482]                           for (restart in restarts) {
[17:45:35.482]                             name <- restart$name
[17:45:35.482]                             if (is.null(name)) 
[17:45:35.482]                               next
[17:45:35.482]                             if (!grepl(pattern, name)) 
[17:45:35.482]                               next
[17:45:35.482]                             invokeRestart(restart)
[17:45:35.482]                             muffled <- TRUE
[17:45:35.482]                             break
[17:45:35.482]                           }
[17:45:35.482]                         }
[17:45:35.482]                       }
[17:45:35.482]                       invisible(muffled)
[17:45:35.482]                     }
[17:45:35.482]                     muffleCondition(cond, pattern = "^muffle")
[17:45:35.482]                   }
[17:45:35.482]                 }
[17:45:35.482]                 else {
[17:45:35.482]                   if (TRUE) {
[17:45:35.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:35.482]                     {
[17:45:35.482]                       inherits <- base::inherits
[17:45:35.482]                       invokeRestart <- base::invokeRestart
[17:45:35.482]                       is.null <- base::is.null
[17:45:35.482]                       muffled <- FALSE
[17:45:35.482]                       if (inherits(cond, "message")) {
[17:45:35.482]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:35.482]                         if (muffled) 
[17:45:35.482]                           invokeRestart("muffleMessage")
[17:45:35.482]                       }
[17:45:35.482]                       else if (inherits(cond, "warning")) {
[17:45:35.482]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:35.482]                         if (muffled) 
[17:45:35.482]                           invokeRestart("muffleWarning")
[17:45:35.482]                       }
[17:45:35.482]                       else if (inherits(cond, "condition")) {
[17:45:35.482]                         if (!is.null(pattern)) {
[17:45:35.482]                           computeRestarts <- base::computeRestarts
[17:45:35.482]                           grepl <- base::grepl
[17:45:35.482]                           restarts <- computeRestarts(cond)
[17:45:35.482]                           for (restart in restarts) {
[17:45:35.482]                             name <- restart$name
[17:45:35.482]                             if (is.null(name)) 
[17:45:35.482]                               next
[17:45:35.482]                             if (!grepl(pattern, name)) 
[17:45:35.482]                               next
[17:45:35.482]                             invokeRestart(restart)
[17:45:35.482]                             muffled <- TRUE
[17:45:35.482]                             break
[17:45:35.482]                           }
[17:45:35.482]                         }
[17:45:35.482]                       }
[17:45:35.482]                       invisible(muffled)
[17:45:35.482]                     }
[17:45:35.482]                     muffleCondition(cond, pattern = "^muffle")
[17:45:35.482]                   }
[17:45:35.482]                 }
[17:45:35.482]             }
[17:45:35.482]         }))
[17:45:35.482]     }, error = function(ex) {
[17:45:35.482]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:35.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:35.482]                 ...future.rng), started = ...future.startTime, 
[17:45:35.482]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:35.482]             version = "1.8"), class = "FutureResult")
[17:45:35.482]     }, finally = {
[17:45:35.482]         if (!identical(...future.workdir, getwd())) 
[17:45:35.482]             setwd(...future.workdir)
[17:45:35.482]         {
[17:45:35.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:35.482]                 ...future.oldOptions$nwarnings <- NULL
[17:45:35.482]             }
[17:45:35.482]             base::options(...future.oldOptions)
[17:45:35.482]             if (.Platform$OS.type == "windows") {
[17:45:35.482]                 old_names <- names(...future.oldEnvVars)
[17:45:35.482]                 envs <- base::Sys.getenv()
[17:45:35.482]                 names <- names(envs)
[17:45:35.482]                 common <- intersect(names, old_names)
[17:45:35.482]                 added <- setdiff(names, old_names)
[17:45:35.482]                 removed <- setdiff(old_names, names)
[17:45:35.482]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:35.482]                   envs[common]]
[17:45:35.482]                 NAMES <- toupper(changed)
[17:45:35.482]                 args <- list()
[17:45:35.482]                 for (kk in seq_along(NAMES)) {
[17:45:35.482]                   name <- changed[[kk]]
[17:45:35.482]                   NAME <- NAMES[[kk]]
[17:45:35.482]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:35.482]                     next
[17:45:35.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:35.482]                 }
[17:45:35.482]                 NAMES <- toupper(added)
[17:45:35.482]                 for (kk in seq_along(NAMES)) {
[17:45:35.482]                   name <- added[[kk]]
[17:45:35.482]                   NAME <- NAMES[[kk]]
[17:45:35.482]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:35.482]                     next
[17:45:35.482]                   args[[name]] <- ""
[17:45:35.482]                 }
[17:45:35.482]                 NAMES <- toupper(removed)
[17:45:35.482]                 for (kk in seq_along(NAMES)) {
[17:45:35.482]                   name <- removed[[kk]]
[17:45:35.482]                   NAME <- NAMES[[kk]]
[17:45:35.482]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:35.482]                     next
[17:45:35.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:35.482]                 }
[17:45:35.482]                 if (length(args) > 0) 
[17:45:35.482]                   base::do.call(base::Sys.setenv, args = args)
[17:45:35.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:35.482]             }
[17:45:35.482]             else {
[17:45:35.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:35.482]             }
[17:45:35.482]             {
[17:45:35.482]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:35.482]                   0L) {
[17:45:35.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:35.482]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:35.482]                   base::options(opts)
[17:45:35.482]                 }
[17:45:35.482]                 {
[17:45:35.482]                   {
[17:45:35.482]                     NULL
[17:45:35.482]                     RNGkind("Mersenne-Twister")
[17:45:35.482]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:35.482]                       inherits = FALSE)
[17:45:35.482]                   }
[17:45:35.482]                   options(future.plan = NULL)
[17:45:35.482]                   if (is.na(NA_character_)) 
[17:45:35.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:35.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:35.482]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:35.482]                     .init = FALSE)
[17:45:35.482]                 }
[17:45:35.482]             }
[17:45:35.482]         }
[17:45:35.482]     })
[17:45:35.482]     if (TRUE) {
[17:45:35.482]         base::sink(type = "output", split = FALSE)
[17:45:35.482]         if (TRUE) {
[17:45:35.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:35.482]         }
[17:45:35.482]         else {
[17:45:35.482]             ...future.result["stdout"] <- base::list(NULL)
[17:45:35.482]         }
[17:45:35.482]         base::close(...future.stdout)
[17:45:35.482]         ...future.stdout <- NULL
[17:45:35.482]     }
[17:45:35.482]     ...future.result$conditions <- ...future.conditions
[17:45:35.482]     ...future.result$finished <- base::Sys.time()
[17:45:35.482]     ...future.result
[17:45:35.482] }
[17:45:35.484] assign_globals() ...
[17:45:35.484] List of 5
[17:45:35.484]  $ ...future.FUN            :function (x)  
[17:45:35.484]  $ future.call.arguments    : list()
[17:45:35.484]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:35.484]  $ ...future.elements_ii    :List of 2
[17:45:35.484]   ..$ : int 1
[17:45:35.484]   ..$ : int 0
[17:45:35.484]  $ ...future.seeds_ii       : NULL
[17:45:35.484]  $ ...future.globals.maxSize: NULL
[17:45:35.484]  - attr(*, "where")=List of 5
[17:45:35.484]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:35.484]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:35.484]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:35.484]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:35.484]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:35.484]  - attr(*, "resolved")= logi FALSE
[17:45:35.484]  - attr(*, "total_size")= num 4720
[17:45:35.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:35.484]  - attr(*, "already-done")= logi TRUE
[17:45:35.488] - reassign environment for ‘...future.FUN’
[17:45:35.488] - copied ‘...future.FUN’ to environment
[17:45:35.489] - copied ‘future.call.arguments’ to environment
[17:45:35.489] - copied ‘...future.elements_ii’ to environment
[17:45:35.489] - copied ‘...future.seeds_ii’ to environment
[17:45:35.489] - copied ‘...future.globals.maxSize’ to environment
[17:45:35.489] assign_globals() ... done
[17:45:35.489] plan(): Setting new future strategy stack:
[17:45:35.489] List of future strategies:
[17:45:35.489] 1. sequential:
[17:45:35.489]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:35.489]    - tweaked: FALSE
[17:45:35.489]    - call: NULL
[17:45:35.490] plan(): nbrOfWorkers() = 1
[17:45:35.991] plan(): Setting new future strategy stack:
[17:45:35.992] List of future strategies:
[17:45:35.992] 1. multicore:
[17:45:35.992]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:35.992]    - tweaked: FALSE
[17:45:35.992]    - call: plan(strategy)
[17:45:35.996] plan(): nbrOfWorkers() = 1
[17:45:35.996] SequentialFuture started (and completed)
[17:45:35.996] - Launch lazy future ... done
[17:45:35.996] run() for ‘SequentialFuture’ ... done
[17:45:35.997] Created future:
[17:45:35.997] SequentialFuture:
[17:45:35.997] Label: ‘future_lapply-1’
[17:45:35.997] Expression:
[17:45:35.997] {
[17:45:35.997]     do.call(function(...) {
[17:45:35.997]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:35.997]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:35.997]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:35.997]             on.exit(options(oopts), add = TRUE)
[17:45:35.997]         }
[17:45:35.997]         {
[17:45:35.997]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:35.997]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:35.997]                 ...future.FUN(...future.X_jj, ...)
[17:45:35.997]             })
[17:45:35.997]         }
[17:45:35.997]     }, args = future.call.arguments)
[17:45:35.997] }
[17:45:35.997] Lazy evaluation: FALSE
[17:45:35.997] Asynchronous evaluation: FALSE
[17:45:35.997] Local evaluation: TRUE
[17:45:35.997] Environment: R_GlobalEnv
[17:45:35.997] Capture standard output: TRUE
[17:45:35.997] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:35.997] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:35.997] Packages: <none>
[17:45:35.997] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:35.997] Resolved: TRUE
[17:45:35.997] Value: 112 bytes of class ‘list’
[17:45:35.997] Early signaling: FALSE
[17:45:35.997] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:35.997] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:35.998] Chunk #1 of 1 ... DONE
[17:45:35.998] Launching 1 futures (chunks) ... DONE
[17:45:35.998] Resolving 1 futures (chunks) ...
[17:45:35.998] resolve() on list ...
[17:45:35.998]  recursive: 0
[17:45:35.998]  length: 1
[17:45:35.998] 
[17:45:35.999] resolved() for ‘SequentialFuture’ ...
[17:45:35.999] - state: ‘finished’
[17:45:35.999] - run: TRUE
[17:45:35.999] - result: ‘FutureResult’
[17:45:35.999] resolved() for ‘SequentialFuture’ ... done
[17:45:35.999] Future #1
[17:45:35.999] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:35.999] - nx: 1
[17:45:35.999] - relay: TRUE
[17:45:36.000] - stdout: TRUE
[17:45:36.000] - signal: TRUE
[17:45:36.000] - resignal: FALSE
[17:45:36.000] - force: TRUE
[17:45:36.000] - relayed: [n=1] FALSE
[17:45:36.000] - queued futures: [n=1] FALSE
[17:45:36.000]  - until=1
[17:45:36.000]  - relaying element #1
[17:45:36.000] - relayed: [n=1] TRUE
[17:45:36.000] - queued futures: [n=1] TRUE
[17:45:36.000] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:36.001]  length: 0 (resolved future 1)
[17:45:36.001] Relaying remaining futures
[17:45:36.001] signalConditionsASAP(NULL, pos=0) ...
[17:45:36.001] - nx: 1
[17:45:36.001] - relay: TRUE
[17:45:36.001] - stdout: TRUE
[17:45:36.001] - signal: TRUE
[17:45:36.001] - resignal: FALSE
[17:45:36.001] - force: TRUE
[17:45:36.001] - relayed: [n=1] TRUE
[17:45:36.001] - queued futures: [n=1] TRUE
 - flush all
[17:45:36.002] - relayed: [n=1] TRUE
[17:45:36.002] - queued futures: [n=1] TRUE
[17:45:36.002] signalConditionsASAP(NULL, pos=0) ... done
[17:45:36.002] resolve() on list ... DONE
[17:45:36.002]  - Number of value chunks collected: 1
[17:45:36.002] Resolving 1 futures (chunks) ... DONE
[17:45:36.002] Reducing values from 1 chunks ...
[17:45:36.002]  - Number of values collected after concatenation: 2
[17:45:36.002]  - Number of values expected: 2
[17:45:36.002] Reducing values from 1 chunks ... DONE
[17:45:36.002] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:45:36.003] future_lapply() ...
[17:45:36.008] Number of chunks: 1
[17:45:36.008] getGlobalsAndPackagesXApply() ...
[17:45:36.009]  - future.globals: TRUE
[17:45:36.009] getGlobalsAndPackages() ...
[17:45:36.009] Searching for globals...
[17:45:36.010] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:36.010] Searching for globals ... DONE
[17:45:36.010] Resolving globals: FALSE
[17:45:36.011] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:36.011] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:36.011] - globals: [1] ‘FUN’
[17:45:36.011] 
[17:45:36.011] getGlobalsAndPackages() ... DONE
[17:45:36.011]  - globals found/used: [n=1] ‘FUN’
[17:45:36.012]  - needed namespaces: [n=0] 
[17:45:36.012] Finding globals ... DONE
[17:45:36.012]  - use_args: TRUE
[17:45:36.012]  - Getting '...' globals ...
[17:45:36.012] resolve() on list ...
[17:45:36.012]  recursive: 0
[17:45:36.012]  length: 1
[17:45:36.012]  elements: ‘...’
[17:45:36.012]  length: 0 (resolved future 1)
[17:45:36.013] resolve() on list ... DONE
[17:45:36.013]    - '...' content: [n=0] 
[17:45:36.013] List of 1
[17:45:36.013]  $ ...: list()
[17:45:36.013]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:36.013]  - attr(*, "where")=List of 1
[17:45:36.013]   ..$ ...:<environment: 0x55f6c7b6d1f0> 
[17:45:36.013]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:36.013]  - attr(*, "resolved")= logi TRUE
[17:45:36.013]  - attr(*, "total_size")= num NA
[17:45:36.015]  - Getting '...' globals ... DONE
[17:45:36.015] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:36.016] List of 2
[17:45:36.016]  $ ...future.FUN:function (x)  
[17:45:36.016]  $ ...          : list()
[17:45:36.016]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:36.016]  - attr(*, "where")=List of 2
[17:45:36.016]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:36.016]   ..$ ...          :<environment: 0x55f6c7b6d1f0> 
[17:45:36.016]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:36.016]  - attr(*, "resolved")= logi FALSE
[17:45:36.016]  - attr(*, "total_size")= num 4720
[17:45:36.018] Packages to be attached in all futures: [n=0] 
[17:45:36.018] getGlobalsAndPackagesXApply() ... DONE
[17:45:36.018] Number of futures (= number of chunks): 1
[17:45:36.018] Launching 1 futures (chunks) ...
[17:45:36.019] Chunk #1 of 1 ...
[17:45:36.019]  - Finding globals in 'X' for chunk #1 ...
[17:45:36.019] getGlobalsAndPackages() ...
[17:45:36.019] Searching for globals...
[17:45:36.019] 
[17:45:36.019] Searching for globals ... DONE
[17:45:36.019] - globals: [0] <none>
[17:45:36.019] getGlobalsAndPackages() ... DONE
[17:45:36.019]    + additional globals found: [n=0] 
[17:45:36.020]    + additional namespaces needed: [n=0] 
[17:45:36.020]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:36.020]  - seeds: <none>
[17:45:36.020]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:36.020] getGlobalsAndPackages() ...
[17:45:36.020] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:36.020] Resolving globals: FALSE
[17:45:36.020] Tweak future expression to call with '...' arguments ...
[17:45:36.020] {
[17:45:36.020]     do.call(function(...) {
[17:45:36.020]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:36.020]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:36.020]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:36.020]             on.exit(options(oopts), add = TRUE)
[17:45:36.020]         }
[17:45:36.020]         {
[17:45:36.020]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:36.020]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:36.020]                 ...future.FUN(...future.X_jj, ...)
[17:45:36.020]             })
[17:45:36.020]         }
[17:45:36.020]     }, args = future.call.arguments)
[17:45:36.020] }
[17:45:36.021] Tweak future expression to call with '...' arguments ... DONE
[17:45:36.021] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:36.021] 
[17:45:36.021] getGlobalsAndPackages() ... DONE
[17:45:36.021] run() for ‘Future’ ...
[17:45:36.022] - state: ‘created’
[17:45:36.022] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:36.025] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:36.025] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:36.025]   - Field: ‘label’
[17:45:36.025]   - Field: ‘local’
[17:45:36.026]   - Field: ‘owner’
[17:45:36.026]   - Field: ‘envir’
[17:45:36.026]   - Field: ‘packages’
[17:45:36.026]   - Field: ‘gc’
[17:45:36.026]   - Field: ‘conditions’
[17:45:36.026]   - Field: ‘expr’
[17:45:36.026]   - Field: ‘uuid’
[17:45:36.026]   - Field: ‘seed’
[17:45:36.026]   - Field: ‘version’
[17:45:36.026]   - Field: ‘result’
[17:45:36.027]   - Field: ‘asynchronous’
[17:45:36.027]   - Field: ‘calls’
[17:45:36.027]   - Field: ‘globals’
[17:45:36.027]   - Field: ‘stdout’
[17:45:36.027]   - Field: ‘earlySignal’
[17:45:36.027]   - Field: ‘lazy’
[17:45:36.027]   - Field: ‘state’
[17:45:36.027] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:36.027] - Launch lazy future ...
[17:45:36.028] Packages needed by the future expression (n = 0): <none>
[17:45:36.028] Packages needed by future strategies (n = 0): <none>
[17:45:36.028] {
[17:45:36.028]     {
[17:45:36.028]         {
[17:45:36.028]             ...future.startTime <- base::Sys.time()
[17:45:36.028]             {
[17:45:36.028]                 {
[17:45:36.028]                   {
[17:45:36.028]                     base::local({
[17:45:36.028]                       has_future <- base::requireNamespace("future", 
[17:45:36.028]                         quietly = TRUE)
[17:45:36.028]                       if (has_future) {
[17:45:36.028]                         ns <- base::getNamespace("future")
[17:45:36.028]                         version <- ns[[".package"]][["version"]]
[17:45:36.028]                         if (is.null(version)) 
[17:45:36.028]                           version <- utils::packageVersion("future")
[17:45:36.028]                       }
[17:45:36.028]                       else {
[17:45:36.028]                         version <- NULL
[17:45:36.028]                       }
[17:45:36.028]                       if (!has_future || version < "1.8.0") {
[17:45:36.028]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:36.028]                           "", base::R.version$version.string), 
[17:45:36.028]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:36.028]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:36.028]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:36.028]                             "release", "version")], collapse = " "), 
[17:45:36.028]                           hostname = base::Sys.info()[["nodename"]])
[17:45:36.028]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:36.028]                           info)
[17:45:36.028]                         info <- base::paste(info, collapse = "; ")
[17:45:36.028]                         if (!has_future) {
[17:45:36.028]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:36.028]                             info)
[17:45:36.028]                         }
[17:45:36.028]                         else {
[17:45:36.028]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:36.028]                             info, version)
[17:45:36.028]                         }
[17:45:36.028]                         base::stop(msg)
[17:45:36.028]                       }
[17:45:36.028]                     })
[17:45:36.028]                   }
[17:45:36.028]                   ...future.strategy.old <- future::plan("list")
[17:45:36.028]                   options(future.plan = NULL)
[17:45:36.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:36.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:36.028]                 }
[17:45:36.028]                 ...future.workdir <- getwd()
[17:45:36.028]             }
[17:45:36.028]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:36.028]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:36.028]         }
[17:45:36.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:36.028]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:36.028]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:36.028]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:36.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:36.028]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:36.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:36.028]             base::names(...future.oldOptions))
[17:45:36.028]     }
[17:45:36.028]     if (TRUE) {
[17:45:36.028]     }
[17:45:36.028]     else {
[17:45:36.028]         if (NA) {
[17:45:36.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:36.028]                 open = "w")
[17:45:36.028]         }
[17:45:36.028]         else {
[17:45:36.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:36.028]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:36.028]         }
[17:45:36.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:36.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:36.028]             base::sink(type = "output", split = FALSE)
[17:45:36.028]             base::close(...future.stdout)
[17:45:36.028]         }, add = TRUE)
[17:45:36.028]     }
[17:45:36.028]     ...future.frame <- base::sys.nframe()
[17:45:36.028]     ...future.conditions <- base::list()
[17:45:36.028]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:36.028]     if (FALSE) {
[17:45:36.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:36.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:36.028]     }
[17:45:36.028]     ...future.result <- base::tryCatch({
[17:45:36.028]         base::withCallingHandlers({
[17:45:36.028]             ...future.value <- base::withVisible(base::local({
[17:45:36.028]                 do.call(function(...) {
[17:45:36.028]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:36.028]                   if (!identical(...future.globals.maxSize.org, 
[17:45:36.028]                     ...future.globals.maxSize)) {
[17:45:36.028]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:36.028]                     on.exit(options(oopts), add = TRUE)
[17:45:36.028]                   }
[17:45:36.028]                   {
[17:45:36.028]                     lapply(seq_along(...future.elements_ii), 
[17:45:36.028]                       FUN = function(jj) {
[17:45:36.028]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:36.028]                         ...future.FUN(...future.X_jj, ...)
[17:45:36.028]                       })
[17:45:36.028]                   }
[17:45:36.028]                 }, args = future.call.arguments)
[17:45:36.028]             }))
[17:45:36.028]             future::FutureResult(value = ...future.value$value, 
[17:45:36.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:36.028]                   ...future.rng), globalenv = if (FALSE) 
[17:45:36.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:36.028]                     ...future.globalenv.names))
[17:45:36.028]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:36.028]         }, condition = base::local({
[17:45:36.028]             c <- base::c
[17:45:36.028]             inherits <- base::inherits
[17:45:36.028]             invokeRestart <- base::invokeRestart
[17:45:36.028]             length <- base::length
[17:45:36.028]             list <- base::list
[17:45:36.028]             seq.int <- base::seq.int
[17:45:36.028]             signalCondition <- base::signalCondition
[17:45:36.028]             sys.calls <- base::sys.calls
[17:45:36.028]             `[[` <- base::`[[`
[17:45:36.028]             `+` <- base::`+`
[17:45:36.028]             `<<-` <- base::`<<-`
[17:45:36.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:36.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:36.028]                   3L)]
[17:45:36.028]             }
[17:45:36.028]             function(cond) {
[17:45:36.028]                 is_error <- inherits(cond, "error")
[17:45:36.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:36.028]                   NULL)
[17:45:36.028]                 if (is_error) {
[17:45:36.028]                   sessionInformation <- function() {
[17:45:36.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:36.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:36.028]                       search = base::search(), system = base::Sys.info())
[17:45:36.028]                   }
[17:45:36.028]                   ...future.conditions[[length(...future.conditions) + 
[17:45:36.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:36.028]                     cond$call), session = sessionInformation(), 
[17:45:36.028]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:36.028]                   signalCondition(cond)
[17:45:36.028]                 }
[17:45:36.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:36.028]                 "immediateCondition"))) {
[17:45:36.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:36.028]                   ...future.conditions[[length(...future.conditions) + 
[17:45:36.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:36.028]                   if (TRUE && !signal) {
[17:45:36.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:36.028]                     {
[17:45:36.028]                       inherits <- base::inherits
[17:45:36.028]                       invokeRestart <- base::invokeRestart
[17:45:36.028]                       is.null <- base::is.null
[17:45:36.028]                       muffled <- FALSE
[17:45:36.028]                       if (inherits(cond, "message")) {
[17:45:36.028]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:36.028]                         if (muffled) 
[17:45:36.028]                           invokeRestart("muffleMessage")
[17:45:36.028]                       }
[17:45:36.028]                       else if (inherits(cond, "warning")) {
[17:45:36.028]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:36.028]                         if (muffled) 
[17:45:36.028]                           invokeRestart("muffleWarning")
[17:45:36.028]                       }
[17:45:36.028]                       else if (inherits(cond, "condition")) {
[17:45:36.028]                         if (!is.null(pattern)) {
[17:45:36.028]                           computeRestarts <- base::computeRestarts
[17:45:36.028]                           grepl <- base::grepl
[17:45:36.028]                           restarts <- computeRestarts(cond)
[17:45:36.028]                           for (restart in restarts) {
[17:45:36.028]                             name <- restart$name
[17:45:36.028]                             if (is.null(name)) 
[17:45:36.028]                               next
[17:45:36.028]                             if (!grepl(pattern, name)) 
[17:45:36.028]                               next
[17:45:36.028]                             invokeRestart(restart)
[17:45:36.028]                             muffled <- TRUE
[17:45:36.028]                             break
[17:45:36.028]                           }
[17:45:36.028]                         }
[17:45:36.028]                       }
[17:45:36.028]                       invisible(muffled)
[17:45:36.028]                     }
[17:45:36.028]                     muffleCondition(cond, pattern = "^muffle")
[17:45:36.028]                   }
[17:45:36.028]                 }
[17:45:36.028]                 else {
[17:45:36.028]                   if (TRUE) {
[17:45:36.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:36.028]                     {
[17:45:36.028]                       inherits <- base::inherits
[17:45:36.028]                       invokeRestart <- base::invokeRestart
[17:45:36.028]                       is.null <- base::is.null
[17:45:36.028]                       muffled <- FALSE
[17:45:36.028]                       if (inherits(cond, "message")) {
[17:45:36.028]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:36.028]                         if (muffled) 
[17:45:36.028]                           invokeRestart("muffleMessage")
[17:45:36.028]                       }
[17:45:36.028]                       else if (inherits(cond, "warning")) {
[17:45:36.028]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:36.028]                         if (muffled) 
[17:45:36.028]                           invokeRestart("muffleWarning")
[17:45:36.028]                       }
[17:45:36.028]                       else if (inherits(cond, "condition")) {
[17:45:36.028]                         if (!is.null(pattern)) {
[17:45:36.028]                           computeRestarts <- base::computeRestarts
[17:45:36.028]                           grepl <- base::grepl
[17:45:36.028]                           restarts <- computeRestarts(cond)
[17:45:36.028]                           for (restart in restarts) {
[17:45:36.028]                             name <- restart$name
[17:45:36.028]                             if (is.null(name)) 
[17:45:36.028]                               next
[17:45:36.028]                             if (!grepl(pattern, name)) 
[17:45:36.028]                               next
[17:45:36.028]                             invokeRestart(restart)
[17:45:36.028]                             muffled <- TRUE
[17:45:36.028]                             break
[17:45:36.028]                           }
[17:45:36.028]                         }
[17:45:36.028]                       }
[17:45:36.028]                       invisible(muffled)
[17:45:36.028]                     }
[17:45:36.028]                     muffleCondition(cond, pattern = "^muffle")
[17:45:36.028]                   }
[17:45:36.028]                 }
[17:45:36.028]             }
[17:45:36.028]         }))
[17:45:36.028]     }, error = function(ex) {
[17:45:36.028]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:36.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:36.028]                 ...future.rng), started = ...future.startTime, 
[17:45:36.028]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:36.028]             version = "1.8"), class = "FutureResult")
[17:45:36.028]     }, finally = {
[17:45:36.028]         if (!identical(...future.workdir, getwd())) 
[17:45:36.028]             setwd(...future.workdir)
[17:45:36.028]         {
[17:45:36.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:36.028]                 ...future.oldOptions$nwarnings <- NULL
[17:45:36.028]             }
[17:45:36.028]             base::options(...future.oldOptions)
[17:45:36.028]             if (.Platform$OS.type == "windows") {
[17:45:36.028]                 old_names <- names(...future.oldEnvVars)
[17:45:36.028]                 envs <- base::Sys.getenv()
[17:45:36.028]                 names <- names(envs)
[17:45:36.028]                 common <- intersect(names, old_names)
[17:45:36.028]                 added <- setdiff(names, old_names)
[17:45:36.028]                 removed <- setdiff(old_names, names)
[17:45:36.028]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:36.028]                   envs[common]]
[17:45:36.028]                 NAMES <- toupper(changed)
[17:45:36.028]                 args <- list()
[17:45:36.028]                 for (kk in seq_along(NAMES)) {
[17:45:36.028]                   name <- changed[[kk]]
[17:45:36.028]                   NAME <- NAMES[[kk]]
[17:45:36.028]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:36.028]                     next
[17:45:36.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:36.028]                 }
[17:45:36.028]                 NAMES <- toupper(added)
[17:45:36.028]                 for (kk in seq_along(NAMES)) {
[17:45:36.028]                   name <- added[[kk]]
[17:45:36.028]                   NAME <- NAMES[[kk]]
[17:45:36.028]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:36.028]                     next
[17:45:36.028]                   args[[name]] <- ""
[17:45:36.028]                 }
[17:45:36.028]                 NAMES <- toupper(removed)
[17:45:36.028]                 for (kk in seq_along(NAMES)) {
[17:45:36.028]                   name <- removed[[kk]]
[17:45:36.028]                   NAME <- NAMES[[kk]]
[17:45:36.028]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:36.028]                     next
[17:45:36.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:36.028]                 }
[17:45:36.028]                 if (length(args) > 0) 
[17:45:36.028]                   base::do.call(base::Sys.setenv, args = args)
[17:45:36.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:36.028]             }
[17:45:36.028]             else {
[17:45:36.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:36.028]             }
[17:45:36.028]             {
[17:45:36.028]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:36.028]                   0L) {
[17:45:36.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:36.028]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:36.028]                   base::options(opts)
[17:45:36.028]                 }
[17:45:36.028]                 {
[17:45:36.028]                   {
[17:45:36.028]                     NULL
[17:45:36.028]                     RNGkind("Mersenne-Twister")
[17:45:36.028]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:36.028]                       inherits = FALSE)
[17:45:36.028]                   }
[17:45:36.028]                   options(future.plan = NULL)
[17:45:36.028]                   if (is.na(NA_character_)) 
[17:45:36.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:36.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:36.028]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:36.028]                     .init = FALSE)
[17:45:36.028]                 }
[17:45:36.028]             }
[17:45:36.028]         }
[17:45:36.028]     })
[17:45:36.028]     if (FALSE) {
[17:45:36.028]         base::sink(type = "output", split = FALSE)
[17:45:36.028]         if (NA) {
[17:45:36.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:36.028]         }
[17:45:36.028]         else {
[17:45:36.028]             ...future.result["stdout"] <- base::list(NULL)
[17:45:36.028]         }
[17:45:36.028]         base::close(...future.stdout)
[17:45:36.028]         ...future.stdout <- NULL
[17:45:36.028]     }
[17:45:36.028]     ...future.result$conditions <- ...future.conditions
[17:45:36.028]     ...future.result$finished <- base::Sys.time()
[17:45:36.028]     ...future.result
[17:45:36.028] }
[17:45:36.030] assign_globals() ...
[17:45:36.030] List of 5
[17:45:36.030]  $ ...future.FUN            :function (x)  
[17:45:36.030]  $ future.call.arguments    : list()
[17:45:36.030]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:36.030]  $ ...future.elements_ii    :List of 2
[17:45:36.030]   ..$ : int 1
[17:45:36.030]   ..$ : int 0
[17:45:36.030]  $ ...future.seeds_ii       : NULL
[17:45:36.030]  $ ...future.globals.maxSize: NULL
[17:45:36.030]  - attr(*, "where")=List of 5
[17:45:36.030]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:36.030]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:36.030]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:36.030]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:36.030]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:36.030]  - attr(*, "resolved")= logi FALSE
[17:45:36.030]  - attr(*, "total_size")= num 4720
[17:45:36.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:36.030]  - attr(*, "already-done")= logi TRUE
[17:45:36.036] - reassign environment for ‘...future.FUN’
[17:45:36.036] - copied ‘...future.FUN’ to environment
[17:45:36.036] - copied ‘future.call.arguments’ to environment
[17:45:36.036] - copied ‘...future.elements_ii’ to environment
[17:45:36.036] - copied ‘...future.seeds_ii’ to environment
[17:45:36.036] - copied ‘...future.globals.maxSize’ to environment
[17:45:36.037] assign_globals() ... done
[17:45:36.037] plan(): Setting new future strategy stack:
[17:45:36.037] List of future strategies:
[17:45:36.037] 1. sequential:
[17:45:36.037]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:36.037]    - tweaked: FALSE
[17:45:36.037]    - call: NULL
[17:45:36.037] plan(): nbrOfWorkers() = 1
[17:45:36.539] plan(): Setting new future strategy stack:
[17:45:36.539] List of future strategies:
[17:45:36.539] 1. multicore:
[17:45:36.539]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:36.539]    - tweaked: FALSE
[17:45:36.539]    - call: plan(strategy)
[17:45:36.543] plan(): nbrOfWorkers() = 1
[17:45:36.543] SequentialFuture started (and completed)
[17:45:36.543] - Launch lazy future ... done
[17:45:36.543] run() for ‘SequentialFuture’ ... done
[17:45:36.544] Created future:
[17:45:36.544] SequentialFuture:
[17:45:36.544] Label: ‘future_lapply-1’
[17:45:36.544] Expression:
[17:45:36.544] {
[17:45:36.544]     do.call(function(...) {
[17:45:36.544]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:36.544]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:36.544]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:36.544]             on.exit(options(oopts), add = TRUE)
[17:45:36.544]         }
[17:45:36.544]         {
[17:45:36.544]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:36.544]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:36.544]                 ...future.FUN(...future.X_jj, ...)
[17:45:36.544]             })
[17:45:36.544]         }
[17:45:36.544]     }, args = future.call.arguments)
[17:45:36.544] }
[17:45:36.544] Lazy evaluation: FALSE
[17:45:36.544] Asynchronous evaluation: FALSE
[17:45:36.544] Local evaluation: TRUE
[17:45:36.544] Environment: R_GlobalEnv
[17:45:36.544] Capture standard output: NA
[17:45:36.544] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:36.544] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:36.544] Packages: <none>
[17:45:36.544] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:36.544] Resolved: TRUE
[17:45:36.544] Value: 112 bytes of class ‘list’
[17:45:36.544] Early signaling: FALSE
[17:45:36.544] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:36.544] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:36.545] Chunk #1 of 1 ... DONE
[17:45:36.545] Launching 1 futures (chunks) ... DONE
[17:45:36.545] Resolving 1 futures (chunks) ...
[17:45:36.545] resolve() on list ...
[17:45:36.545]  recursive: 0
[17:45:36.545]  length: 1
[17:45:36.545] 
[17:45:36.545] resolved() for ‘SequentialFuture’ ...
[17:45:36.546] - state: ‘finished’
[17:45:36.546] - run: TRUE
[17:45:36.546] - result: ‘FutureResult’
[17:45:36.546] resolved() for ‘SequentialFuture’ ... done
[17:45:36.546] Future #1
[17:45:36.546] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:36.546] - nx: 1
[17:45:36.546] - relay: TRUE
[17:45:36.546] - stdout: TRUE
[17:45:36.546] - signal: TRUE
[17:45:36.546] - resignal: FALSE
[17:45:36.547] - force: TRUE
[17:45:36.547] - relayed: [n=1] FALSE
[17:45:36.547] - queued futures: [n=1] FALSE
[17:45:36.547]  - until=1
[17:45:36.547]  - relaying element #1
[17:45:36.547] - relayed: [n=1] TRUE
[17:45:36.547] - queued futures: [n=1] TRUE
[17:45:36.547] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:36.547]  length: 0 (resolved future 1)
[17:45:36.547] Relaying remaining futures
[17:45:36.548] signalConditionsASAP(NULL, pos=0) ...
[17:45:36.548] - nx: 1
[17:45:36.548] - relay: TRUE
[17:45:36.548] - stdout: TRUE
[17:45:36.548] - signal: TRUE
[17:45:36.548] - resignal: FALSE
[17:45:36.548] - force: TRUE
[17:45:36.548] - relayed: [n=1] TRUE
[17:45:36.548] - queued futures: [n=1] TRUE
 - flush all
[17:45:36.548] - relayed: [n=1] TRUE
[17:45:36.548] - queued futures: [n=1] TRUE
[17:45:36.548] signalConditionsASAP(NULL, pos=0) ... done
[17:45:36.549] resolve() on list ... DONE
[17:45:36.549]  - Number of value chunks collected: 1
[17:45:36.549] Resolving 1 futures (chunks) ... DONE
[17:45:36.549] Reducing values from 1 chunks ...
[17:45:36.549]  - Number of values collected after concatenation: 2
[17:45:36.549]  - Number of values expected: 2
[17:45:36.549] Reducing values from 1 chunks ... DONE
[17:45:36.549] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:45:36.550] future_mapply() ...
[17:45:36.553] Number of chunks: 1
[17:45:36.553] getGlobalsAndPackagesXApply() ...
[17:45:36.553]  - future.globals: TRUE
[17:45:36.553] getGlobalsAndPackages() ...
[17:45:36.553] Searching for globals...
[17:45:36.555] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:36.555] Searching for globals ... DONE
[17:45:36.555] Resolving globals: FALSE
[17:45:36.556] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:36.556] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:36.556] - globals: [1] ‘FUN’
[17:45:36.556] 
[17:45:36.556] getGlobalsAndPackages() ... DONE
[17:45:36.556]  - globals found/used: [n=1] ‘FUN’
[17:45:36.556]  - needed namespaces: [n=0] 
[17:45:36.556] Finding globals ... DONE
[17:45:36.557] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:36.557] List of 2
[17:45:36.557]  $ ...future.FUN:function (x, y)  
[17:45:36.557]  $ MoreArgs     : NULL
[17:45:36.557]  - attr(*, "where")=List of 2
[17:45:36.557]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:36.557]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:36.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:36.557]  - attr(*, "resolved")= logi FALSE
[17:45:36.557]  - attr(*, "total_size")= num NA
[17:45:36.559] Packages to be attached in all futures: [n=0] 
[17:45:36.559] getGlobalsAndPackagesXApply() ... DONE
[17:45:36.559] Number of futures (= number of chunks): 1
[17:45:36.560] Launching 1 futures (chunks) ...
[17:45:36.560] Chunk #1 of 1 ...
[17:45:36.560]  - Finding globals in '...' for chunk #1 ...
[17:45:36.560] getGlobalsAndPackages() ...
[17:45:36.560] Searching for globals...
[17:45:36.560] 
[17:45:36.560] Searching for globals ... DONE
[17:45:36.560] - globals: [0] <none>
[17:45:36.561] getGlobalsAndPackages() ... DONE
[17:45:36.561]    + additional globals found: [n=0] 
[17:45:36.561]    + additional namespaces needed: [n=0] 
[17:45:36.561]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:36.561]  - seeds: <none>
[17:45:36.561]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:36.561] getGlobalsAndPackages() ...
[17:45:36.561] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:36.561] Resolving globals: FALSE
[17:45:36.562] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:45:36.562] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:36.562] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:36.562] 
[17:45:36.562] getGlobalsAndPackages() ... DONE
[17:45:36.563] run() for ‘Future’ ...
[17:45:36.563] - state: ‘created’
[17:45:36.563] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:36.568] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:36.568] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:36.568]   - Field: ‘label’
[17:45:36.568]   - Field: ‘local’
[17:45:36.569]   - Field: ‘owner’
[17:45:36.569]   - Field: ‘envir’
[17:45:36.569]   - Field: ‘packages’
[17:45:36.569]   - Field: ‘gc’
[17:45:36.569]   - Field: ‘conditions’
[17:45:36.569]   - Field: ‘expr’
[17:45:36.569]   - Field: ‘uuid’
[17:45:36.569]   - Field: ‘seed’
[17:45:36.569]   - Field: ‘version’
[17:45:36.569]   - Field: ‘result’
[17:45:36.570]   - Field: ‘asynchronous’
[17:45:36.570]   - Field: ‘calls’
[17:45:36.570]   - Field: ‘globals’
[17:45:36.570]   - Field: ‘stdout’
[17:45:36.570]   - Field: ‘earlySignal’
[17:45:36.570]   - Field: ‘lazy’
[17:45:36.570]   - Field: ‘state’
[17:45:36.570] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:36.570] - Launch lazy future ...
[17:45:36.571] Packages needed by the future expression (n = 0): <none>
[17:45:36.571] Packages needed by future strategies (n = 0): <none>
[17:45:36.571] {
[17:45:36.571]     {
[17:45:36.571]         {
[17:45:36.571]             ...future.startTime <- base::Sys.time()
[17:45:36.571]             {
[17:45:36.571]                 {
[17:45:36.571]                   {
[17:45:36.571]                     base::local({
[17:45:36.571]                       has_future <- base::requireNamespace("future", 
[17:45:36.571]                         quietly = TRUE)
[17:45:36.571]                       if (has_future) {
[17:45:36.571]                         ns <- base::getNamespace("future")
[17:45:36.571]                         version <- ns[[".package"]][["version"]]
[17:45:36.571]                         if (is.null(version)) 
[17:45:36.571]                           version <- utils::packageVersion("future")
[17:45:36.571]                       }
[17:45:36.571]                       else {
[17:45:36.571]                         version <- NULL
[17:45:36.571]                       }
[17:45:36.571]                       if (!has_future || version < "1.8.0") {
[17:45:36.571]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:36.571]                           "", base::R.version$version.string), 
[17:45:36.571]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:36.571]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:36.571]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:36.571]                             "release", "version")], collapse = " "), 
[17:45:36.571]                           hostname = base::Sys.info()[["nodename"]])
[17:45:36.571]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:36.571]                           info)
[17:45:36.571]                         info <- base::paste(info, collapse = "; ")
[17:45:36.571]                         if (!has_future) {
[17:45:36.571]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:36.571]                             info)
[17:45:36.571]                         }
[17:45:36.571]                         else {
[17:45:36.571]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:36.571]                             info, version)
[17:45:36.571]                         }
[17:45:36.571]                         base::stop(msg)
[17:45:36.571]                       }
[17:45:36.571]                     })
[17:45:36.571]                   }
[17:45:36.571]                   ...future.strategy.old <- future::plan("list")
[17:45:36.571]                   options(future.plan = NULL)
[17:45:36.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:36.571]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:36.571]                 }
[17:45:36.571]                 ...future.workdir <- getwd()
[17:45:36.571]             }
[17:45:36.571]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:36.571]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:36.571]         }
[17:45:36.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:36.571]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:36.571]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:36.571]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:36.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:36.571]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:36.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:36.571]             base::names(...future.oldOptions))
[17:45:36.571]     }
[17:45:36.571]     if (FALSE) {
[17:45:36.571]     }
[17:45:36.571]     else {
[17:45:36.571]         if (FALSE) {
[17:45:36.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:36.571]                 open = "w")
[17:45:36.571]         }
[17:45:36.571]         else {
[17:45:36.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:36.571]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:36.571]         }
[17:45:36.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:36.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:36.571]             base::sink(type = "output", split = FALSE)
[17:45:36.571]             base::close(...future.stdout)
[17:45:36.571]         }, add = TRUE)
[17:45:36.571]     }
[17:45:36.571]     ...future.frame <- base::sys.nframe()
[17:45:36.571]     ...future.conditions <- base::list()
[17:45:36.571]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:36.571]     if (FALSE) {
[17:45:36.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:36.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:36.571]     }
[17:45:36.571]     ...future.result <- base::tryCatch({
[17:45:36.571]         base::withCallingHandlers({
[17:45:36.571]             ...future.value <- base::withVisible(base::local({
[17:45:36.571]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:36.571]                 if (!identical(...future.globals.maxSize.org, 
[17:45:36.571]                   ...future.globals.maxSize)) {
[17:45:36.571]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:36.571]                   on.exit(options(oopts), add = TRUE)
[17:45:36.571]                 }
[17:45:36.571]                 {
[17:45:36.571]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:36.571]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:36.571]                     USE.NAMES = FALSE)
[17:45:36.571]                   do.call(mapply, args = args)
[17:45:36.571]                 }
[17:45:36.571]             }))
[17:45:36.571]             future::FutureResult(value = ...future.value$value, 
[17:45:36.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:36.571]                   ...future.rng), globalenv = if (FALSE) 
[17:45:36.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:36.571]                     ...future.globalenv.names))
[17:45:36.571]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:36.571]         }, condition = base::local({
[17:45:36.571]             c <- base::c
[17:45:36.571]             inherits <- base::inherits
[17:45:36.571]             invokeRestart <- base::invokeRestart
[17:45:36.571]             length <- base::length
[17:45:36.571]             list <- base::list
[17:45:36.571]             seq.int <- base::seq.int
[17:45:36.571]             signalCondition <- base::signalCondition
[17:45:36.571]             sys.calls <- base::sys.calls
[17:45:36.571]             `[[` <- base::`[[`
[17:45:36.571]             `+` <- base::`+`
[17:45:36.571]             `<<-` <- base::`<<-`
[17:45:36.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:36.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:36.571]                   3L)]
[17:45:36.571]             }
[17:45:36.571]             function(cond) {
[17:45:36.571]                 is_error <- inherits(cond, "error")
[17:45:36.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:36.571]                   NULL)
[17:45:36.571]                 if (is_error) {
[17:45:36.571]                   sessionInformation <- function() {
[17:45:36.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:36.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:36.571]                       search = base::search(), system = base::Sys.info())
[17:45:36.571]                   }
[17:45:36.571]                   ...future.conditions[[length(...future.conditions) + 
[17:45:36.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:36.571]                     cond$call), session = sessionInformation(), 
[17:45:36.571]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:36.571]                   signalCondition(cond)
[17:45:36.571]                 }
[17:45:36.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:36.571]                 "immediateCondition"))) {
[17:45:36.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:36.571]                   ...future.conditions[[length(...future.conditions) + 
[17:45:36.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:36.571]                   if (TRUE && !signal) {
[17:45:36.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:36.571]                     {
[17:45:36.571]                       inherits <- base::inherits
[17:45:36.571]                       invokeRestart <- base::invokeRestart
[17:45:36.571]                       is.null <- base::is.null
[17:45:36.571]                       muffled <- FALSE
[17:45:36.571]                       if (inherits(cond, "message")) {
[17:45:36.571]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:36.571]                         if (muffled) 
[17:45:36.571]                           invokeRestart("muffleMessage")
[17:45:36.571]                       }
[17:45:36.571]                       else if (inherits(cond, "warning")) {
[17:45:36.571]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:36.571]                         if (muffled) 
[17:45:36.571]                           invokeRestart("muffleWarning")
[17:45:36.571]                       }
[17:45:36.571]                       else if (inherits(cond, "condition")) {
[17:45:36.571]                         if (!is.null(pattern)) {
[17:45:36.571]                           computeRestarts <- base::computeRestarts
[17:45:36.571]                           grepl <- base::grepl
[17:45:36.571]                           restarts <- computeRestarts(cond)
[17:45:36.571]                           for (restart in restarts) {
[17:45:36.571]                             name <- restart$name
[17:45:36.571]                             if (is.null(name)) 
[17:45:36.571]                               next
[17:45:36.571]                             if (!grepl(pattern, name)) 
[17:45:36.571]                               next
[17:45:36.571]                             invokeRestart(restart)
[17:45:36.571]                             muffled <- TRUE
[17:45:36.571]                             break
[17:45:36.571]                           }
[17:45:36.571]                         }
[17:45:36.571]                       }
[17:45:36.571]                       invisible(muffled)
[17:45:36.571]                     }
[17:45:36.571]                     muffleCondition(cond, pattern = "^muffle")
[17:45:36.571]                   }
[17:45:36.571]                 }
[17:45:36.571]                 else {
[17:45:36.571]                   if (TRUE) {
[17:45:36.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:36.571]                     {
[17:45:36.571]                       inherits <- base::inherits
[17:45:36.571]                       invokeRestart <- base::invokeRestart
[17:45:36.571]                       is.null <- base::is.null
[17:45:36.571]                       muffled <- FALSE
[17:45:36.571]                       if (inherits(cond, "message")) {
[17:45:36.571]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:36.571]                         if (muffled) 
[17:45:36.571]                           invokeRestart("muffleMessage")
[17:45:36.571]                       }
[17:45:36.571]                       else if (inherits(cond, "warning")) {
[17:45:36.571]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:36.571]                         if (muffled) 
[17:45:36.571]                           invokeRestart("muffleWarning")
[17:45:36.571]                       }
[17:45:36.571]                       else if (inherits(cond, "condition")) {
[17:45:36.571]                         if (!is.null(pattern)) {
[17:45:36.571]                           computeRestarts <- base::computeRestarts
[17:45:36.571]                           grepl <- base::grepl
[17:45:36.571]                           restarts <- computeRestarts(cond)
[17:45:36.571]                           for (restart in restarts) {
[17:45:36.571]                             name <- restart$name
[17:45:36.571]                             if (is.null(name)) 
[17:45:36.571]                               next
[17:45:36.571]                             if (!grepl(pattern, name)) 
[17:45:36.571]                               next
[17:45:36.571]                             invokeRestart(restart)
[17:45:36.571]                             muffled <- TRUE
[17:45:36.571]                             break
[17:45:36.571]                           }
[17:45:36.571]                         }
[17:45:36.571]                       }
[17:45:36.571]                       invisible(muffled)
[17:45:36.571]                     }
[17:45:36.571]                     muffleCondition(cond, pattern = "^muffle")
[17:45:36.571]                   }
[17:45:36.571]                 }
[17:45:36.571]             }
[17:45:36.571]         }))
[17:45:36.571]     }, error = function(ex) {
[17:45:36.571]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:36.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:36.571]                 ...future.rng), started = ...future.startTime, 
[17:45:36.571]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:36.571]             version = "1.8"), class = "FutureResult")
[17:45:36.571]     }, finally = {
[17:45:36.571]         if (!identical(...future.workdir, getwd())) 
[17:45:36.571]             setwd(...future.workdir)
[17:45:36.571]         {
[17:45:36.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:36.571]                 ...future.oldOptions$nwarnings <- NULL
[17:45:36.571]             }
[17:45:36.571]             base::options(...future.oldOptions)
[17:45:36.571]             if (.Platform$OS.type == "windows") {
[17:45:36.571]                 old_names <- names(...future.oldEnvVars)
[17:45:36.571]                 envs <- base::Sys.getenv()
[17:45:36.571]                 names <- names(envs)
[17:45:36.571]                 common <- intersect(names, old_names)
[17:45:36.571]                 added <- setdiff(names, old_names)
[17:45:36.571]                 removed <- setdiff(old_names, names)
[17:45:36.571]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:36.571]                   envs[common]]
[17:45:36.571]                 NAMES <- toupper(changed)
[17:45:36.571]                 args <- list()
[17:45:36.571]                 for (kk in seq_along(NAMES)) {
[17:45:36.571]                   name <- changed[[kk]]
[17:45:36.571]                   NAME <- NAMES[[kk]]
[17:45:36.571]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:36.571]                     next
[17:45:36.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:36.571]                 }
[17:45:36.571]                 NAMES <- toupper(added)
[17:45:36.571]                 for (kk in seq_along(NAMES)) {
[17:45:36.571]                   name <- added[[kk]]
[17:45:36.571]                   NAME <- NAMES[[kk]]
[17:45:36.571]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:36.571]                     next
[17:45:36.571]                   args[[name]] <- ""
[17:45:36.571]                 }
[17:45:36.571]                 NAMES <- toupper(removed)
[17:45:36.571]                 for (kk in seq_along(NAMES)) {
[17:45:36.571]                   name <- removed[[kk]]
[17:45:36.571]                   NAME <- NAMES[[kk]]
[17:45:36.571]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:36.571]                     next
[17:45:36.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:36.571]                 }
[17:45:36.571]                 if (length(args) > 0) 
[17:45:36.571]                   base::do.call(base::Sys.setenv, args = args)
[17:45:36.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:36.571]             }
[17:45:36.571]             else {
[17:45:36.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:36.571]             }
[17:45:36.571]             {
[17:45:36.571]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:36.571]                   0L) {
[17:45:36.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:36.571]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:36.571]                   base::options(opts)
[17:45:36.571]                 }
[17:45:36.571]                 {
[17:45:36.571]                   {
[17:45:36.571]                     NULL
[17:45:36.571]                     RNGkind("Mersenne-Twister")
[17:45:36.571]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:36.571]                       inherits = FALSE)
[17:45:36.571]                   }
[17:45:36.571]                   options(future.plan = NULL)
[17:45:36.571]                   if (is.na(NA_character_)) 
[17:45:36.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:36.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:36.571]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:36.571]                     .init = FALSE)
[17:45:36.571]                 }
[17:45:36.571]             }
[17:45:36.571]         }
[17:45:36.571]     })
[17:45:36.571]     if (TRUE) {
[17:45:36.571]         base::sink(type = "output", split = FALSE)
[17:45:36.571]         if (FALSE) {
[17:45:36.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:36.571]         }
[17:45:36.571]         else {
[17:45:36.571]             ...future.result["stdout"] <- base::list(NULL)
[17:45:36.571]         }
[17:45:36.571]         base::close(...future.stdout)
[17:45:36.571]         ...future.stdout <- NULL
[17:45:36.571]     }
[17:45:36.571]     ...future.result$conditions <- ...future.conditions
[17:45:36.571]     ...future.result$finished <- base::Sys.time()
[17:45:36.571]     ...future.result
[17:45:36.571] }
[17:45:36.573] assign_globals() ...
[17:45:36.573] List of 5
[17:45:36.573]  $ ...future.FUN            :function (x, y)  
[17:45:36.573]  $ MoreArgs                 : NULL
[17:45:36.573]  $ ...future.elements_ii    :List of 2
[17:45:36.573]   ..$ :List of 2
[17:45:36.573]   .. ..$ : int 1
[17:45:36.573]   .. ..$ : int 0
[17:45:36.573]   ..$ :List of 2
[17:45:36.573]   .. ..$ : int 0
[17:45:36.573]   .. ..$ : int 1
[17:45:36.573]  $ ...future.seeds_ii       : NULL
[17:45:36.573]  $ ...future.globals.maxSize: NULL
[17:45:36.573]  - attr(*, "where")=List of 5
[17:45:36.573]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:36.573]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:36.573]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:36.573]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:36.573]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:36.573]  - attr(*, "resolved")= logi FALSE
[17:45:36.573]  - attr(*, "total_size")= num 6480
[17:45:36.573]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:36.573]  - attr(*, "already-done")= logi TRUE
[17:45:36.578] - reassign environment for ‘...future.FUN’
[17:45:36.578] - copied ‘...future.FUN’ to environment
[17:45:36.579] - copied ‘MoreArgs’ to environment
[17:45:36.579] - copied ‘...future.elements_ii’ to environment
[17:45:36.579] - copied ‘...future.seeds_ii’ to environment
[17:45:36.579] - copied ‘...future.globals.maxSize’ to environment
[17:45:36.579] assign_globals() ... done
[17:45:36.579] plan(): Setting new future strategy stack:
[17:45:36.579] List of future strategies:
[17:45:36.579] 1. sequential:
[17:45:36.579]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:36.579]    - tweaked: FALSE
[17:45:36.579]    - call: NULL
[17:45:36.580] plan(): nbrOfWorkers() = 1
[17:45:37.082] plan(): Setting new future strategy stack:
[17:45:37.082] List of future strategies:
[17:45:37.082] 1. multicore:
[17:45:37.082]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:37.082]    - tweaked: FALSE
[17:45:37.082]    - call: plan(strategy)
[17:45:37.086] plan(): nbrOfWorkers() = 1
[17:45:37.086] SequentialFuture started (and completed)
[17:45:37.086] - Launch lazy future ... done
[17:45:37.086] run() for ‘SequentialFuture’ ... done
[17:45:37.086] Created future:
[17:45:37.086] SequentialFuture:
[17:45:37.086] Label: ‘future_mapply-1’
[17:45:37.086] Expression:
[17:45:37.086] {
[17:45:37.086]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:37.086]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:37.086]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:37.086]         on.exit(options(oopts), add = TRUE)
[17:45:37.086]     }
[17:45:37.086]     {
[17:45:37.086]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:37.086]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:37.086]         do.call(mapply, args = args)
[17:45:37.086]     }
[17:45:37.086] }
[17:45:37.086] Lazy evaluation: FALSE
[17:45:37.086] Asynchronous evaluation: FALSE
[17:45:37.086] Local evaluation: TRUE
[17:45:37.086] Environment: R_GlobalEnv
[17:45:37.086] Capture standard output: FALSE
[17:45:37.086] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:37.086] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:37.086] Packages: <none>
[17:45:37.086] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:37.086] Resolved: TRUE
[17:45:37.086] Value: 224 bytes of class ‘list’
[17:45:37.086] Early signaling: FALSE
[17:45:37.086] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:37.086] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:37.087] Chunk #1 of 1 ... DONE
[17:45:37.088] Launching 1 futures (chunks) ... DONE
[17:45:37.088] Resolving 1 futures (chunks) ...
[17:45:37.088] resolve() on list ...
[17:45:37.088]  recursive: 0
[17:45:37.088]  length: 1
[17:45:37.088] 
[17:45:37.088] resolved() for ‘SequentialFuture’ ...
[17:45:37.088] - state: ‘finished’
[17:45:37.088] - run: TRUE
[17:45:37.088] - result: ‘FutureResult’
[17:45:37.089] resolved() for ‘SequentialFuture’ ... done
[17:45:37.089] Future #1
[17:45:37.089] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:37.089] - nx: 1
[17:45:37.089] - relay: TRUE
[17:45:37.089] - stdout: TRUE
[17:45:37.089] - signal: TRUE
[17:45:37.089] - resignal: FALSE
[17:45:37.089] - force: TRUE
[17:45:37.089] - relayed: [n=1] FALSE
[17:45:37.089] - queued futures: [n=1] FALSE
[17:45:37.090]  - until=1
[17:45:37.090]  - relaying element #1
[17:45:37.090] - relayed: [n=1] TRUE
[17:45:37.090] - queued futures: [n=1] TRUE
[17:45:37.090] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:37.090]  length: 0 (resolved future 1)
[17:45:37.090] Relaying remaining futures
[17:45:37.090] signalConditionsASAP(NULL, pos=0) ...
[17:45:37.090] - nx: 1
[17:45:37.090] - relay: TRUE
[17:45:37.090] - stdout: TRUE
[17:45:37.091] - signal: TRUE
[17:45:37.091] - resignal: FALSE
[17:45:37.091] - force: TRUE
[17:45:37.091] - relayed: [n=1] TRUE
[17:45:37.091] - queued futures: [n=1] TRUE
 - flush all
[17:45:37.091] - relayed: [n=1] TRUE
[17:45:37.091] - queued futures: [n=1] TRUE
[17:45:37.091] signalConditionsASAP(NULL, pos=0) ... done
[17:45:37.091] resolve() on list ... DONE
[17:45:37.091]  - Number of value chunks collected: 1
[17:45:37.092] Resolving 1 futures (chunks) ... DONE
[17:45:37.092] Reducing values from 1 chunks ...
[17:45:37.092]  - Number of values collected after concatenation: 2
[17:45:37.092]  - Number of values expected: 2
[17:45:37.092] Reducing values from 1 chunks ... DONE
[17:45:37.092] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:45:37.092] future_mapply() ...
[17:45:37.096] Number of chunks: 1
[17:45:37.096] getGlobalsAndPackagesXApply() ...
[17:45:37.096]  - future.globals: TRUE
[17:45:37.096] getGlobalsAndPackages() ...
[17:45:37.096] Searching for globals...
[17:45:37.098] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:37.098] Searching for globals ... DONE
[17:45:37.098] Resolving globals: FALSE
[17:45:37.098] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:37.100] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:37.100] - globals: [1] ‘FUN’
[17:45:37.101] 
[17:45:37.101] getGlobalsAndPackages() ... DONE
[17:45:37.101]  - globals found/used: [n=1] ‘FUN’
[17:45:37.101]  - needed namespaces: [n=0] 
[17:45:37.101] Finding globals ... DONE
[17:45:37.101] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:37.101] List of 2
[17:45:37.101]  $ ...future.FUN:function (x, y)  
[17:45:37.101]  $ MoreArgs     : NULL
[17:45:37.101]  - attr(*, "where")=List of 2
[17:45:37.101]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:37.101]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:37.101]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:37.101]  - attr(*, "resolved")= logi FALSE
[17:45:37.101]  - attr(*, "total_size")= num NA
[17:45:37.104] Packages to be attached in all futures: [n=0] 
[17:45:37.104] getGlobalsAndPackagesXApply() ... DONE
[17:45:37.104] Number of futures (= number of chunks): 1
[17:45:37.104] Launching 1 futures (chunks) ...
[17:45:37.104] Chunk #1 of 1 ...
[17:45:37.104]  - Finding globals in '...' for chunk #1 ...
[17:45:37.104] getGlobalsAndPackages() ...
[17:45:37.105] Searching for globals...
[17:45:37.105] 
[17:45:37.105] Searching for globals ... DONE
[17:45:37.105] - globals: [0] <none>
[17:45:37.105] getGlobalsAndPackages() ... DONE
[17:45:37.105]    + additional globals found: [n=0] 
[17:45:37.105]    + additional namespaces needed: [n=0] 
[17:45:37.105]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:37.105]  - seeds: <none>
[17:45:37.106]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:37.106] getGlobalsAndPackages() ...
[17:45:37.106] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:37.106] Resolving globals: FALSE
[17:45:37.106] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:45:37.107] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:37.107] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:37.107] 
[17:45:37.107] getGlobalsAndPackages() ... DONE
[17:45:37.107] run() for ‘Future’ ...
[17:45:37.107] - state: ‘created’
[17:45:37.108] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:37.111] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:37.111] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:37.111]   - Field: ‘label’
[17:45:37.111]   - Field: ‘local’
[17:45:37.111]   - Field: ‘owner’
[17:45:37.112]   - Field: ‘envir’
[17:45:37.112]   - Field: ‘packages’
[17:45:37.112]   - Field: ‘gc’
[17:45:37.112]   - Field: ‘conditions’
[17:45:37.112]   - Field: ‘expr’
[17:45:37.112]   - Field: ‘uuid’
[17:45:37.112]   - Field: ‘seed’
[17:45:37.112]   - Field: ‘version’
[17:45:37.112]   - Field: ‘result’
[17:45:37.112]   - Field: ‘asynchronous’
[17:45:37.113]   - Field: ‘calls’
[17:45:37.113]   - Field: ‘globals’
[17:45:37.113]   - Field: ‘stdout’
[17:45:37.113]   - Field: ‘earlySignal’
[17:45:37.113]   - Field: ‘lazy’
[17:45:37.113]   - Field: ‘state’
[17:45:37.113] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:37.113] - Launch lazy future ...
[17:45:37.113] Packages needed by the future expression (n = 0): <none>
[17:45:37.113] Packages needed by future strategies (n = 0): <none>
[17:45:37.114] {
[17:45:37.114]     {
[17:45:37.114]         {
[17:45:37.114]             ...future.startTime <- base::Sys.time()
[17:45:37.114]             {
[17:45:37.114]                 {
[17:45:37.114]                   {
[17:45:37.114]                     base::local({
[17:45:37.114]                       has_future <- base::requireNamespace("future", 
[17:45:37.114]                         quietly = TRUE)
[17:45:37.114]                       if (has_future) {
[17:45:37.114]                         ns <- base::getNamespace("future")
[17:45:37.114]                         version <- ns[[".package"]][["version"]]
[17:45:37.114]                         if (is.null(version)) 
[17:45:37.114]                           version <- utils::packageVersion("future")
[17:45:37.114]                       }
[17:45:37.114]                       else {
[17:45:37.114]                         version <- NULL
[17:45:37.114]                       }
[17:45:37.114]                       if (!has_future || version < "1.8.0") {
[17:45:37.114]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:37.114]                           "", base::R.version$version.string), 
[17:45:37.114]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:37.114]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:37.114]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:37.114]                             "release", "version")], collapse = " "), 
[17:45:37.114]                           hostname = base::Sys.info()[["nodename"]])
[17:45:37.114]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:37.114]                           info)
[17:45:37.114]                         info <- base::paste(info, collapse = "; ")
[17:45:37.114]                         if (!has_future) {
[17:45:37.114]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:37.114]                             info)
[17:45:37.114]                         }
[17:45:37.114]                         else {
[17:45:37.114]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:37.114]                             info, version)
[17:45:37.114]                         }
[17:45:37.114]                         base::stop(msg)
[17:45:37.114]                       }
[17:45:37.114]                     })
[17:45:37.114]                   }
[17:45:37.114]                   ...future.strategy.old <- future::plan("list")
[17:45:37.114]                   options(future.plan = NULL)
[17:45:37.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:37.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:37.114]                 }
[17:45:37.114]                 ...future.workdir <- getwd()
[17:45:37.114]             }
[17:45:37.114]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:37.114]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:37.114]         }
[17:45:37.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:37.114]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:37.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:37.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:37.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:37.114]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:37.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:37.114]             base::names(...future.oldOptions))
[17:45:37.114]     }
[17:45:37.114]     if (FALSE) {
[17:45:37.114]     }
[17:45:37.114]     else {
[17:45:37.114]         if (TRUE) {
[17:45:37.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:37.114]                 open = "w")
[17:45:37.114]         }
[17:45:37.114]         else {
[17:45:37.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:37.114]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:37.114]         }
[17:45:37.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:37.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:37.114]             base::sink(type = "output", split = FALSE)
[17:45:37.114]             base::close(...future.stdout)
[17:45:37.114]         }, add = TRUE)
[17:45:37.114]     }
[17:45:37.114]     ...future.frame <- base::sys.nframe()
[17:45:37.114]     ...future.conditions <- base::list()
[17:45:37.114]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:37.114]     if (FALSE) {
[17:45:37.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:37.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:37.114]     }
[17:45:37.114]     ...future.result <- base::tryCatch({
[17:45:37.114]         base::withCallingHandlers({
[17:45:37.114]             ...future.value <- base::withVisible(base::local({
[17:45:37.114]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:37.114]                 if (!identical(...future.globals.maxSize.org, 
[17:45:37.114]                   ...future.globals.maxSize)) {
[17:45:37.114]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:37.114]                   on.exit(options(oopts), add = TRUE)
[17:45:37.114]                 }
[17:45:37.114]                 {
[17:45:37.114]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:37.114]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:37.114]                     USE.NAMES = FALSE)
[17:45:37.114]                   do.call(mapply, args = args)
[17:45:37.114]                 }
[17:45:37.114]             }))
[17:45:37.114]             future::FutureResult(value = ...future.value$value, 
[17:45:37.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:37.114]                   ...future.rng), globalenv = if (FALSE) 
[17:45:37.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:37.114]                     ...future.globalenv.names))
[17:45:37.114]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:37.114]         }, condition = base::local({
[17:45:37.114]             c <- base::c
[17:45:37.114]             inherits <- base::inherits
[17:45:37.114]             invokeRestart <- base::invokeRestart
[17:45:37.114]             length <- base::length
[17:45:37.114]             list <- base::list
[17:45:37.114]             seq.int <- base::seq.int
[17:45:37.114]             signalCondition <- base::signalCondition
[17:45:37.114]             sys.calls <- base::sys.calls
[17:45:37.114]             `[[` <- base::`[[`
[17:45:37.114]             `+` <- base::`+`
[17:45:37.114]             `<<-` <- base::`<<-`
[17:45:37.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:37.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:37.114]                   3L)]
[17:45:37.114]             }
[17:45:37.114]             function(cond) {
[17:45:37.114]                 is_error <- inherits(cond, "error")
[17:45:37.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:37.114]                   NULL)
[17:45:37.114]                 if (is_error) {
[17:45:37.114]                   sessionInformation <- function() {
[17:45:37.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:37.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:37.114]                       search = base::search(), system = base::Sys.info())
[17:45:37.114]                   }
[17:45:37.114]                   ...future.conditions[[length(...future.conditions) + 
[17:45:37.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:37.114]                     cond$call), session = sessionInformation(), 
[17:45:37.114]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:37.114]                   signalCondition(cond)
[17:45:37.114]                 }
[17:45:37.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:37.114]                 "immediateCondition"))) {
[17:45:37.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:37.114]                   ...future.conditions[[length(...future.conditions) + 
[17:45:37.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:37.114]                   if (TRUE && !signal) {
[17:45:37.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:37.114]                     {
[17:45:37.114]                       inherits <- base::inherits
[17:45:37.114]                       invokeRestart <- base::invokeRestart
[17:45:37.114]                       is.null <- base::is.null
[17:45:37.114]                       muffled <- FALSE
[17:45:37.114]                       if (inherits(cond, "message")) {
[17:45:37.114]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:37.114]                         if (muffled) 
[17:45:37.114]                           invokeRestart("muffleMessage")
[17:45:37.114]                       }
[17:45:37.114]                       else if (inherits(cond, "warning")) {
[17:45:37.114]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:37.114]                         if (muffled) 
[17:45:37.114]                           invokeRestart("muffleWarning")
[17:45:37.114]                       }
[17:45:37.114]                       else if (inherits(cond, "condition")) {
[17:45:37.114]                         if (!is.null(pattern)) {
[17:45:37.114]                           computeRestarts <- base::computeRestarts
[17:45:37.114]                           grepl <- base::grepl
[17:45:37.114]                           restarts <- computeRestarts(cond)
[17:45:37.114]                           for (restart in restarts) {
[17:45:37.114]                             name <- restart$name
[17:45:37.114]                             if (is.null(name)) 
[17:45:37.114]                               next
[17:45:37.114]                             if (!grepl(pattern, name)) 
[17:45:37.114]                               next
[17:45:37.114]                             invokeRestart(restart)
[17:45:37.114]                             muffled <- TRUE
[17:45:37.114]                             break
[17:45:37.114]                           }
[17:45:37.114]                         }
[17:45:37.114]                       }
[17:45:37.114]                       invisible(muffled)
[17:45:37.114]                     }
[17:45:37.114]                     muffleCondition(cond, pattern = "^muffle")
[17:45:37.114]                   }
[17:45:37.114]                 }
[17:45:37.114]                 else {
[17:45:37.114]                   if (TRUE) {
[17:45:37.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:37.114]                     {
[17:45:37.114]                       inherits <- base::inherits
[17:45:37.114]                       invokeRestart <- base::invokeRestart
[17:45:37.114]                       is.null <- base::is.null
[17:45:37.114]                       muffled <- FALSE
[17:45:37.114]                       if (inherits(cond, "message")) {
[17:45:37.114]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:37.114]                         if (muffled) 
[17:45:37.114]                           invokeRestart("muffleMessage")
[17:45:37.114]                       }
[17:45:37.114]                       else if (inherits(cond, "warning")) {
[17:45:37.114]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:37.114]                         if (muffled) 
[17:45:37.114]                           invokeRestart("muffleWarning")
[17:45:37.114]                       }
[17:45:37.114]                       else if (inherits(cond, "condition")) {
[17:45:37.114]                         if (!is.null(pattern)) {
[17:45:37.114]                           computeRestarts <- base::computeRestarts
[17:45:37.114]                           grepl <- base::grepl
[17:45:37.114]                           restarts <- computeRestarts(cond)
[17:45:37.114]                           for (restart in restarts) {
[17:45:37.114]                             name <- restart$name
[17:45:37.114]                             if (is.null(name)) 
[17:45:37.114]                               next
[17:45:37.114]                             if (!grepl(pattern, name)) 
[17:45:37.114]                               next
[17:45:37.114]                             invokeRestart(restart)
[17:45:37.114]                             muffled <- TRUE
[17:45:37.114]                             break
[17:45:37.114]                           }
[17:45:37.114]                         }
[17:45:37.114]                       }
[17:45:37.114]                       invisible(muffled)
[17:45:37.114]                     }
[17:45:37.114]                     muffleCondition(cond, pattern = "^muffle")
[17:45:37.114]                   }
[17:45:37.114]                 }
[17:45:37.114]             }
[17:45:37.114]         }))
[17:45:37.114]     }, error = function(ex) {
[17:45:37.114]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:37.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:37.114]                 ...future.rng), started = ...future.startTime, 
[17:45:37.114]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:37.114]             version = "1.8"), class = "FutureResult")
[17:45:37.114]     }, finally = {
[17:45:37.114]         if (!identical(...future.workdir, getwd())) 
[17:45:37.114]             setwd(...future.workdir)
[17:45:37.114]         {
[17:45:37.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:37.114]                 ...future.oldOptions$nwarnings <- NULL
[17:45:37.114]             }
[17:45:37.114]             base::options(...future.oldOptions)
[17:45:37.114]             if (.Platform$OS.type == "windows") {
[17:45:37.114]                 old_names <- names(...future.oldEnvVars)
[17:45:37.114]                 envs <- base::Sys.getenv()
[17:45:37.114]                 names <- names(envs)
[17:45:37.114]                 common <- intersect(names, old_names)
[17:45:37.114]                 added <- setdiff(names, old_names)
[17:45:37.114]                 removed <- setdiff(old_names, names)
[17:45:37.114]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:37.114]                   envs[common]]
[17:45:37.114]                 NAMES <- toupper(changed)
[17:45:37.114]                 args <- list()
[17:45:37.114]                 for (kk in seq_along(NAMES)) {
[17:45:37.114]                   name <- changed[[kk]]
[17:45:37.114]                   NAME <- NAMES[[kk]]
[17:45:37.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:37.114]                     next
[17:45:37.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:37.114]                 }
[17:45:37.114]                 NAMES <- toupper(added)
[17:45:37.114]                 for (kk in seq_along(NAMES)) {
[17:45:37.114]                   name <- added[[kk]]
[17:45:37.114]                   NAME <- NAMES[[kk]]
[17:45:37.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:37.114]                     next
[17:45:37.114]                   args[[name]] <- ""
[17:45:37.114]                 }
[17:45:37.114]                 NAMES <- toupper(removed)
[17:45:37.114]                 for (kk in seq_along(NAMES)) {
[17:45:37.114]                   name <- removed[[kk]]
[17:45:37.114]                   NAME <- NAMES[[kk]]
[17:45:37.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:37.114]                     next
[17:45:37.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:37.114]                 }
[17:45:37.114]                 if (length(args) > 0) 
[17:45:37.114]                   base::do.call(base::Sys.setenv, args = args)
[17:45:37.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:37.114]             }
[17:45:37.114]             else {
[17:45:37.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:37.114]             }
[17:45:37.114]             {
[17:45:37.114]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:37.114]                   0L) {
[17:45:37.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:37.114]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:37.114]                   base::options(opts)
[17:45:37.114]                 }
[17:45:37.114]                 {
[17:45:37.114]                   {
[17:45:37.114]                     NULL
[17:45:37.114]                     RNGkind("Mersenne-Twister")
[17:45:37.114]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:37.114]                       inherits = FALSE)
[17:45:37.114]                   }
[17:45:37.114]                   options(future.plan = NULL)
[17:45:37.114]                   if (is.na(NA_character_)) 
[17:45:37.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:37.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:37.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:37.114]                     .init = FALSE)
[17:45:37.114]                 }
[17:45:37.114]             }
[17:45:37.114]         }
[17:45:37.114]     })
[17:45:37.114]     if (TRUE) {
[17:45:37.114]         base::sink(type = "output", split = FALSE)
[17:45:37.114]         if (TRUE) {
[17:45:37.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:37.114]         }
[17:45:37.114]         else {
[17:45:37.114]             ...future.result["stdout"] <- base::list(NULL)
[17:45:37.114]         }
[17:45:37.114]         base::close(...future.stdout)
[17:45:37.114]         ...future.stdout <- NULL
[17:45:37.114]     }
[17:45:37.114]     ...future.result$conditions <- ...future.conditions
[17:45:37.114]     ...future.result$finished <- base::Sys.time()
[17:45:37.114]     ...future.result
[17:45:37.114] }
[17:45:37.116] assign_globals() ...
[17:45:37.116] List of 5
[17:45:37.116]  $ ...future.FUN            :function (x, y)  
[17:45:37.116]  $ MoreArgs                 : NULL
[17:45:37.116]  $ ...future.elements_ii    :List of 2
[17:45:37.116]   ..$ :List of 2
[17:45:37.116]   .. ..$ : int 1
[17:45:37.116]   .. ..$ : int 0
[17:45:37.116]   ..$ :List of 2
[17:45:37.116]   .. ..$ : int 0
[17:45:37.116]   .. ..$ : int 1
[17:45:37.116]  $ ...future.seeds_ii       : NULL
[17:45:37.116]  $ ...future.globals.maxSize: NULL
[17:45:37.116]  - attr(*, "where")=List of 5
[17:45:37.116]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:37.116]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:37.116]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:37.116]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:37.116]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:37.116]  - attr(*, "resolved")= logi FALSE
[17:45:37.116]  - attr(*, "total_size")= num 6480
[17:45:37.116]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:37.116]  - attr(*, "already-done")= logi TRUE
[17:45:37.121] - reassign environment for ‘...future.FUN’
[17:45:37.121] - copied ‘...future.FUN’ to environment
[17:45:37.121] - copied ‘MoreArgs’ to environment
[17:45:37.121] - copied ‘...future.elements_ii’ to environment
[17:45:37.121] - copied ‘...future.seeds_ii’ to environment
[17:45:37.121] - copied ‘...future.globals.maxSize’ to environment
[17:45:37.122] assign_globals() ... done
[17:45:37.122] plan(): Setting new future strategy stack:
[17:45:37.122] List of future strategies:
[17:45:37.122] 1. sequential:
[17:45:37.122]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:37.122]    - tweaked: FALSE
[17:45:37.122]    - call: NULL
[17:45:37.122] plan(): nbrOfWorkers() = 1
[17:45:37.624] plan(): Setting new future strategy stack:
[17:45:37.624] List of future strategies:
[17:45:37.624] 1. multicore:
[17:45:37.624]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:37.624]    - tweaked: FALSE
[17:45:37.624]    - call: plan(strategy)
[17:45:37.628] plan(): nbrOfWorkers() = 1
[17:45:37.628] SequentialFuture started (and completed)
[17:45:37.628] - Launch lazy future ... done
[17:45:37.628] run() for ‘SequentialFuture’ ... done
[17:45:37.629] Created future:
[17:45:37.629] SequentialFuture:
[17:45:37.629] Label: ‘future_mapply-1’
[17:45:37.629] Expression:
[17:45:37.629] {
[17:45:37.629]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:37.629]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:37.629]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:37.629]         on.exit(options(oopts), add = TRUE)
[17:45:37.629]     }
[17:45:37.629]     {
[17:45:37.629]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:37.629]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:37.629]         do.call(mapply, args = args)
[17:45:37.629]     }
[17:45:37.629] }
[17:45:37.629] Lazy evaluation: FALSE
[17:45:37.629] Asynchronous evaluation: FALSE
[17:45:37.629] Local evaluation: TRUE
[17:45:37.629] Environment: R_GlobalEnv
[17:45:37.629] Capture standard output: TRUE
[17:45:37.629] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:37.629] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:37.629] Packages: <none>
[17:45:37.629] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:37.629] Resolved: TRUE
[17:45:37.629] Value: 224 bytes of class ‘list’
[17:45:37.629] Early signaling: FALSE
[17:45:37.629] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:37.629] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:37.630] Chunk #1 of 1 ... DONE
[17:45:37.630] Launching 1 futures (chunks) ... DONE
[17:45:37.630] Resolving 1 futures (chunks) ...
[17:45:37.630] resolve() on list ...
[17:45:37.630]  recursive: 0
[17:45:37.630]  length: 1
[17:45:37.632] 
[17:45:37.632] resolved() for ‘SequentialFuture’ ...
[17:45:37.632] - state: ‘finished’
[17:45:37.632] - run: TRUE
[17:45:37.632] - result: ‘FutureResult’
[17:45:37.633] resolved() for ‘SequentialFuture’ ... done
[17:45:37.633] Future #1
[17:45:37.633] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:37.633] - nx: 1
[17:45:37.633] - relay: TRUE
[17:45:37.633] - stdout: TRUE
[17:45:37.633] - signal: TRUE
[17:45:37.633] - resignal: FALSE
[17:45:37.633] - force: TRUE
[17:45:37.633] - relayed: [n=1] FALSE
[17:45:37.633] - queued futures: [n=1] FALSE
[17:45:37.634]  - until=1
[17:45:37.634]  - relaying element #1
[17:45:37.634] - relayed: [n=1] TRUE
[17:45:37.634] - queued futures: [n=1] TRUE
[17:45:37.634] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:37.634]  length: 0 (resolved future 1)
[17:45:37.634] Relaying remaining futures
[17:45:37.634] signalConditionsASAP(NULL, pos=0) ...
[17:45:37.634] - nx: 1
[17:45:37.634] - relay: TRUE
[17:45:37.635] - stdout: TRUE
[17:45:37.635] - signal: TRUE
[17:45:37.635] - resignal: FALSE
[17:45:37.635] - force: TRUE
[17:45:37.635] - relayed: [n=1] TRUE
[17:45:37.635] - queued futures: [n=1] TRUE
 - flush all
[17:45:37.635] - relayed: [n=1] TRUE
[17:45:37.635] - queued futures: [n=1] TRUE
[17:45:37.635] signalConditionsASAP(NULL, pos=0) ... done
[17:45:37.635] resolve() on list ... DONE
[17:45:37.636]  - Number of value chunks collected: 1
[17:45:37.636] Resolving 1 futures (chunks) ... DONE
[17:45:37.636] Reducing values from 1 chunks ...
[17:45:37.636]  - Number of values collected after concatenation: 2
[17:45:37.636]  - Number of values expected: 2
[17:45:37.636] Reducing values from 1 chunks ... DONE
[17:45:37.636] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:45:37.636] future_mapply() ...
[17:45:37.640] Number of chunks: 1
[17:45:37.640] getGlobalsAndPackagesXApply() ...
[17:45:37.640]  - future.globals: TRUE
[17:45:37.640] getGlobalsAndPackages() ...
[17:45:37.640] Searching for globals...
[17:45:37.642] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:37.642] Searching for globals ... DONE
[17:45:37.642] Resolving globals: FALSE
[17:45:37.642] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:37.643] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:37.643] - globals: [1] ‘FUN’
[17:45:37.643] 
[17:45:37.643] getGlobalsAndPackages() ... DONE
[17:45:37.643]  - globals found/used: [n=1] ‘FUN’
[17:45:37.643]  - needed namespaces: [n=0] 
[17:45:37.643] Finding globals ... DONE
[17:45:37.643] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:37.644] List of 2
[17:45:37.644]  $ ...future.FUN:function (x, y)  
[17:45:37.644]  $ MoreArgs     : NULL
[17:45:37.644]  - attr(*, "where")=List of 2
[17:45:37.644]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:37.644]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:37.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:37.644]  - attr(*, "resolved")= logi FALSE
[17:45:37.644]  - attr(*, "total_size")= num NA
[17:45:37.646] Packages to be attached in all futures: [n=0] 
[17:45:37.646] getGlobalsAndPackagesXApply() ... DONE
[17:45:37.646] Number of futures (= number of chunks): 1
[17:45:37.646] Launching 1 futures (chunks) ...
[17:45:37.646] Chunk #1 of 1 ...
[17:45:37.646]  - Finding globals in '...' for chunk #1 ...
[17:45:37.647] getGlobalsAndPackages() ...
[17:45:37.647] Searching for globals...
[17:45:37.647] 
[17:45:37.647] Searching for globals ... DONE
[17:45:37.647] - globals: [0] <none>
[17:45:37.647] getGlobalsAndPackages() ... DONE
[17:45:37.647]    + additional globals found: [n=0] 
[17:45:37.647]    + additional namespaces needed: [n=0] 
[17:45:37.648]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:37.648]  - seeds: <none>
[17:45:37.648]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:37.648] getGlobalsAndPackages() ...
[17:45:37.648] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:37.648] Resolving globals: FALSE
[17:45:37.648] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:45:37.649] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:37.649] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:37.649] 
[17:45:37.649] getGlobalsAndPackages() ... DONE
[17:45:37.650] run() for ‘Future’ ...
[17:45:37.650] - state: ‘created’
[17:45:37.650] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:37.653] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:37.653] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:37.653]   - Field: ‘label’
[17:45:37.654]   - Field: ‘local’
[17:45:37.654]   - Field: ‘owner’
[17:45:37.654]   - Field: ‘envir’
[17:45:37.654]   - Field: ‘packages’
[17:45:37.654]   - Field: ‘gc’
[17:45:37.654]   - Field: ‘conditions’
[17:45:37.654]   - Field: ‘expr’
[17:45:37.654]   - Field: ‘uuid’
[17:45:37.654]   - Field: ‘seed’
[17:45:37.654]   - Field: ‘version’
[17:45:37.655]   - Field: ‘result’
[17:45:37.655]   - Field: ‘asynchronous’
[17:45:37.655]   - Field: ‘calls’
[17:45:37.655]   - Field: ‘globals’
[17:45:37.655]   - Field: ‘stdout’
[17:45:37.655]   - Field: ‘earlySignal’
[17:45:37.655]   - Field: ‘lazy’
[17:45:37.655]   - Field: ‘state’
[17:45:37.655] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:37.655] - Launch lazy future ...
[17:45:37.656] Packages needed by the future expression (n = 0): <none>
[17:45:37.656] Packages needed by future strategies (n = 0): <none>
[17:45:37.656] {
[17:45:37.656]     {
[17:45:37.656]         {
[17:45:37.656]             ...future.startTime <- base::Sys.time()
[17:45:37.656]             {
[17:45:37.656]                 {
[17:45:37.656]                   {
[17:45:37.656]                     base::local({
[17:45:37.656]                       has_future <- base::requireNamespace("future", 
[17:45:37.656]                         quietly = TRUE)
[17:45:37.656]                       if (has_future) {
[17:45:37.656]                         ns <- base::getNamespace("future")
[17:45:37.656]                         version <- ns[[".package"]][["version"]]
[17:45:37.656]                         if (is.null(version)) 
[17:45:37.656]                           version <- utils::packageVersion("future")
[17:45:37.656]                       }
[17:45:37.656]                       else {
[17:45:37.656]                         version <- NULL
[17:45:37.656]                       }
[17:45:37.656]                       if (!has_future || version < "1.8.0") {
[17:45:37.656]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:37.656]                           "", base::R.version$version.string), 
[17:45:37.656]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:37.656]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:37.656]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:37.656]                             "release", "version")], collapse = " "), 
[17:45:37.656]                           hostname = base::Sys.info()[["nodename"]])
[17:45:37.656]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:37.656]                           info)
[17:45:37.656]                         info <- base::paste(info, collapse = "; ")
[17:45:37.656]                         if (!has_future) {
[17:45:37.656]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:37.656]                             info)
[17:45:37.656]                         }
[17:45:37.656]                         else {
[17:45:37.656]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:37.656]                             info, version)
[17:45:37.656]                         }
[17:45:37.656]                         base::stop(msg)
[17:45:37.656]                       }
[17:45:37.656]                     })
[17:45:37.656]                   }
[17:45:37.656]                   ...future.strategy.old <- future::plan("list")
[17:45:37.656]                   options(future.plan = NULL)
[17:45:37.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:37.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:37.656]                 }
[17:45:37.656]                 ...future.workdir <- getwd()
[17:45:37.656]             }
[17:45:37.656]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:37.656]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:37.656]         }
[17:45:37.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:37.656]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:37.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:37.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:37.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:37.656]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:37.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:37.656]             base::names(...future.oldOptions))
[17:45:37.656]     }
[17:45:37.656]     if (TRUE) {
[17:45:37.656]     }
[17:45:37.656]     else {
[17:45:37.656]         if (NA) {
[17:45:37.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:37.656]                 open = "w")
[17:45:37.656]         }
[17:45:37.656]         else {
[17:45:37.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:37.656]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:37.656]         }
[17:45:37.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:37.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:37.656]             base::sink(type = "output", split = FALSE)
[17:45:37.656]             base::close(...future.stdout)
[17:45:37.656]         }, add = TRUE)
[17:45:37.656]     }
[17:45:37.656]     ...future.frame <- base::sys.nframe()
[17:45:37.656]     ...future.conditions <- base::list()
[17:45:37.656]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:37.656]     if (FALSE) {
[17:45:37.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:37.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:37.656]     }
[17:45:37.656]     ...future.result <- base::tryCatch({
[17:45:37.656]         base::withCallingHandlers({
[17:45:37.656]             ...future.value <- base::withVisible(base::local({
[17:45:37.656]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:37.656]                 if (!identical(...future.globals.maxSize.org, 
[17:45:37.656]                   ...future.globals.maxSize)) {
[17:45:37.656]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:37.656]                   on.exit(options(oopts), add = TRUE)
[17:45:37.656]                 }
[17:45:37.656]                 {
[17:45:37.656]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:37.656]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:37.656]                     USE.NAMES = FALSE)
[17:45:37.656]                   do.call(mapply, args = args)
[17:45:37.656]                 }
[17:45:37.656]             }))
[17:45:37.656]             future::FutureResult(value = ...future.value$value, 
[17:45:37.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:37.656]                   ...future.rng), globalenv = if (FALSE) 
[17:45:37.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:37.656]                     ...future.globalenv.names))
[17:45:37.656]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:37.656]         }, condition = base::local({
[17:45:37.656]             c <- base::c
[17:45:37.656]             inherits <- base::inherits
[17:45:37.656]             invokeRestart <- base::invokeRestart
[17:45:37.656]             length <- base::length
[17:45:37.656]             list <- base::list
[17:45:37.656]             seq.int <- base::seq.int
[17:45:37.656]             signalCondition <- base::signalCondition
[17:45:37.656]             sys.calls <- base::sys.calls
[17:45:37.656]             `[[` <- base::`[[`
[17:45:37.656]             `+` <- base::`+`
[17:45:37.656]             `<<-` <- base::`<<-`
[17:45:37.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:37.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:37.656]                   3L)]
[17:45:37.656]             }
[17:45:37.656]             function(cond) {
[17:45:37.656]                 is_error <- inherits(cond, "error")
[17:45:37.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:37.656]                   NULL)
[17:45:37.656]                 if (is_error) {
[17:45:37.656]                   sessionInformation <- function() {
[17:45:37.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:37.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:37.656]                       search = base::search(), system = base::Sys.info())
[17:45:37.656]                   }
[17:45:37.656]                   ...future.conditions[[length(...future.conditions) + 
[17:45:37.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:37.656]                     cond$call), session = sessionInformation(), 
[17:45:37.656]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:37.656]                   signalCondition(cond)
[17:45:37.656]                 }
[17:45:37.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:37.656]                 "immediateCondition"))) {
[17:45:37.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:37.656]                   ...future.conditions[[length(...future.conditions) + 
[17:45:37.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:37.656]                   if (TRUE && !signal) {
[17:45:37.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:37.656]                     {
[17:45:37.656]                       inherits <- base::inherits
[17:45:37.656]                       invokeRestart <- base::invokeRestart
[17:45:37.656]                       is.null <- base::is.null
[17:45:37.656]                       muffled <- FALSE
[17:45:37.656]                       if (inherits(cond, "message")) {
[17:45:37.656]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:37.656]                         if (muffled) 
[17:45:37.656]                           invokeRestart("muffleMessage")
[17:45:37.656]                       }
[17:45:37.656]                       else if (inherits(cond, "warning")) {
[17:45:37.656]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:37.656]                         if (muffled) 
[17:45:37.656]                           invokeRestart("muffleWarning")
[17:45:37.656]                       }
[17:45:37.656]                       else if (inherits(cond, "condition")) {
[17:45:37.656]                         if (!is.null(pattern)) {
[17:45:37.656]                           computeRestarts <- base::computeRestarts
[17:45:37.656]                           grepl <- base::grepl
[17:45:37.656]                           restarts <- computeRestarts(cond)
[17:45:37.656]                           for (restart in restarts) {
[17:45:37.656]                             name <- restart$name
[17:45:37.656]                             if (is.null(name)) 
[17:45:37.656]                               next
[17:45:37.656]                             if (!grepl(pattern, name)) 
[17:45:37.656]                               next
[17:45:37.656]                             invokeRestart(restart)
[17:45:37.656]                             muffled <- TRUE
[17:45:37.656]                             break
[17:45:37.656]                           }
[17:45:37.656]                         }
[17:45:37.656]                       }
[17:45:37.656]                       invisible(muffled)
[17:45:37.656]                     }
[17:45:37.656]                     muffleCondition(cond, pattern = "^muffle")
[17:45:37.656]                   }
[17:45:37.656]                 }
[17:45:37.656]                 else {
[17:45:37.656]                   if (TRUE) {
[17:45:37.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:37.656]                     {
[17:45:37.656]                       inherits <- base::inherits
[17:45:37.656]                       invokeRestart <- base::invokeRestart
[17:45:37.656]                       is.null <- base::is.null
[17:45:37.656]                       muffled <- FALSE
[17:45:37.656]                       if (inherits(cond, "message")) {
[17:45:37.656]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:37.656]                         if (muffled) 
[17:45:37.656]                           invokeRestart("muffleMessage")
[17:45:37.656]                       }
[17:45:37.656]                       else if (inherits(cond, "warning")) {
[17:45:37.656]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:37.656]                         if (muffled) 
[17:45:37.656]                           invokeRestart("muffleWarning")
[17:45:37.656]                       }
[17:45:37.656]                       else if (inherits(cond, "condition")) {
[17:45:37.656]                         if (!is.null(pattern)) {
[17:45:37.656]                           computeRestarts <- base::computeRestarts
[17:45:37.656]                           grepl <- base::grepl
[17:45:37.656]                           restarts <- computeRestarts(cond)
[17:45:37.656]                           for (restart in restarts) {
[17:45:37.656]                             name <- restart$name
[17:45:37.656]                             if (is.null(name)) 
[17:45:37.656]                               next
[17:45:37.656]                             if (!grepl(pattern, name)) 
[17:45:37.656]                               next
[17:45:37.656]                             invokeRestart(restart)
[17:45:37.656]                             muffled <- TRUE
[17:45:37.656]                             break
[17:45:37.656]                           }
[17:45:37.656]                         }
[17:45:37.656]                       }
[17:45:37.656]                       invisible(muffled)
[17:45:37.656]                     }
[17:45:37.656]                     muffleCondition(cond, pattern = "^muffle")
[17:45:37.656]                   }
[17:45:37.656]                 }
[17:45:37.656]             }
[17:45:37.656]         }))
[17:45:37.656]     }, error = function(ex) {
[17:45:37.656]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:37.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:37.656]                 ...future.rng), started = ...future.startTime, 
[17:45:37.656]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:37.656]             version = "1.8"), class = "FutureResult")
[17:45:37.656]     }, finally = {
[17:45:37.656]         if (!identical(...future.workdir, getwd())) 
[17:45:37.656]             setwd(...future.workdir)
[17:45:37.656]         {
[17:45:37.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:37.656]                 ...future.oldOptions$nwarnings <- NULL
[17:45:37.656]             }
[17:45:37.656]             base::options(...future.oldOptions)
[17:45:37.656]             if (.Platform$OS.type == "windows") {
[17:45:37.656]                 old_names <- names(...future.oldEnvVars)
[17:45:37.656]                 envs <- base::Sys.getenv()
[17:45:37.656]                 names <- names(envs)
[17:45:37.656]                 common <- intersect(names, old_names)
[17:45:37.656]                 added <- setdiff(names, old_names)
[17:45:37.656]                 removed <- setdiff(old_names, names)
[17:45:37.656]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:37.656]                   envs[common]]
[17:45:37.656]                 NAMES <- toupper(changed)
[17:45:37.656]                 args <- list()
[17:45:37.656]                 for (kk in seq_along(NAMES)) {
[17:45:37.656]                   name <- changed[[kk]]
[17:45:37.656]                   NAME <- NAMES[[kk]]
[17:45:37.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:37.656]                     next
[17:45:37.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:37.656]                 }
[17:45:37.656]                 NAMES <- toupper(added)
[17:45:37.656]                 for (kk in seq_along(NAMES)) {
[17:45:37.656]                   name <- added[[kk]]
[17:45:37.656]                   NAME <- NAMES[[kk]]
[17:45:37.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:37.656]                     next
[17:45:37.656]                   args[[name]] <- ""
[17:45:37.656]                 }
[17:45:37.656]                 NAMES <- toupper(removed)
[17:45:37.656]                 for (kk in seq_along(NAMES)) {
[17:45:37.656]                   name <- removed[[kk]]
[17:45:37.656]                   NAME <- NAMES[[kk]]
[17:45:37.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:37.656]                     next
[17:45:37.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:37.656]                 }
[17:45:37.656]                 if (length(args) > 0) 
[17:45:37.656]                   base::do.call(base::Sys.setenv, args = args)
[17:45:37.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:37.656]             }
[17:45:37.656]             else {
[17:45:37.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:37.656]             }
[17:45:37.656]             {
[17:45:37.656]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:37.656]                   0L) {
[17:45:37.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:37.656]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:37.656]                   base::options(opts)
[17:45:37.656]                 }
[17:45:37.656]                 {
[17:45:37.656]                   {
[17:45:37.656]                     NULL
[17:45:37.656]                     RNGkind("Mersenne-Twister")
[17:45:37.656]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:37.656]                       inherits = FALSE)
[17:45:37.656]                   }
[17:45:37.656]                   options(future.plan = NULL)
[17:45:37.656]                   if (is.na(NA_character_)) 
[17:45:37.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:37.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:37.656]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:37.656]                     .init = FALSE)
[17:45:37.656]                 }
[17:45:37.656]             }
[17:45:37.656]         }
[17:45:37.656]     })
[17:45:37.656]     if (FALSE) {
[17:45:37.656]         base::sink(type = "output", split = FALSE)
[17:45:37.656]         if (NA) {
[17:45:37.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:37.656]         }
[17:45:37.656]         else {
[17:45:37.656]             ...future.result["stdout"] <- base::list(NULL)
[17:45:37.656]         }
[17:45:37.656]         base::close(...future.stdout)
[17:45:37.656]         ...future.stdout <- NULL
[17:45:37.656]     }
[17:45:37.656]     ...future.result$conditions <- ...future.conditions
[17:45:37.656]     ...future.result$finished <- base::Sys.time()
[17:45:37.656]     ...future.result
[17:45:37.656] }
[17:45:37.658] assign_globals() ...
[17:45:37.658] List of 5
[17:45:37.658]  $ ...future.FUN            :function (x, y)  
[17:45:37.658]  $ MoreArgs                 : NULL
[17:45:37.658]  $ ...future.elements_ii    :List of 2
[17:45:37.658]   ..$ :List of 2
[17:45:37.658]   .. ..$ : int 1
[17:45:37.658]   .. ..$ : int 0
[17:45:37.658]   ..$ :List of 2
[17:45:37.658]   .. ..$ : int 0
[17:45:37.658]   .. ..$ : int 1
[17:45:37.658]  $ ...future.seeds_ii       : NULL
[17:45:37.658]  $ ...future.globals.maxSize: NULL
[17:45:37.658]  - attr(*, "where")=List of 5
[17:45:37.658]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:37.658]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:37.658]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:37.658]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:37.658]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:37.658]  - attr(*, "resolved")= logi FALSE
[17:45:37.658]  - attr(*, "total_size")= num 6480
[17:45:37.658]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:37.658]  - attr(*, "already-done")= logi TRUE
[17:45:37.665] - reassign environment for ‘...future.FUN’
[17:45:37.665] - copied ‘...future.FUN’ to environment
[17:45:37.665] - copied ‘MoreArgs’ to environment
[17:45:37.665] - copied ‘...future.elements_ii’ to environment
[17:45:37.665] - copied ‘...future.seeds_ii’ to environment
[17:45:37.665] - copied ‘...future.globals.maxSize’ to environment
[17:45:37.665] assign_globals() ... done
[17:45:37.666] plan(): Setting new future strategy stack:
[17:45:37.666] List of future strategies:
[17:45:37.666] 1. sequential:
[17:45:37.666]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:37.666]    - tweaked: FALSE
[17:45:37.666]    - call: NULL
[17:45:37.666] plan(): nbrOfWorkers() = 1
[17:45:38.168] plan(): Setting new future strategy stack:
[17:45:38.168] List of future strategies:
[17:45:38.168] 1. multicore:
[17:45:38.168]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:38.168]    - tweaked: FALSE
[17:45:38.168]    - call: plan(strategy)
[17:45:38.172] plan(): nbrOfWorkers() = 1
[17:45:38.172] SequentialFuture started (and completed)
[17:45:38.172] - Launch lazy future ... done
[17:45:38.172] run() for ‘SequentialFuture’ ... done
[17:45:38.173] Created future:
[17:45:38.173] SequentialFuture:
[17:45:38.173] Label: ‘future_mapply-1’
[17:45:38.173] Expression:
[17:45:38.173] {
[17:45:38.173]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:38.173]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:38.173]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:38.173]         on.exit(options(oopts), add = TRUE)
[17:45:38.173]     }
[17:45:38.173]     {
[17:45:38.173]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:38.173]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:38.173]         do.call(mapply, args = args)
[17:45:38.173]     }
[17:45:38.173] }
[17:45:38.173] Lazy evaluation: FALSE
[17:45:38.173] Asynchronous evaluation: FALSE
[17:45:38.173] Local evaluation: TRUE
[17:45:38.173] Environment: R_GlobalEnv
[17:45:38.173] Capture standard output: NA
[17:45:38.173] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:38.173] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:38.173] Packages: <none>
[17:45:38.173] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:38.173] Resolved: TRUE
[17:45:38.173] Value: 224 bytes of class ‘list’
[17:45:38.173] Early signaling: FALSE
[17:45:38.173] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:38.173] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:38.174] Chunk #1 of 1 ... DONE
[17:45:38.174] Launching 1 futures (chunks) ... DONE
[17:45:38.174] Resolving 1 futures (chunks) ...
[17:45:38.174] resolve() on list ...
[17:45:38.174]  recursive: 0
[17:45:38.174]  length: 1
[17:45:38.174] 
[17:45:38.174] resolved() for ‘SequentialFuture’ ...
[17:45:38.174] - state: ‘finished’
[17:45:38.174] - run: TRUE
[17:45:38.175] - result: ‘FutureResult’
[17:45:38.175] resolved() for ‘SequentialFuture’ ... done
[17:45:38.175] Future #1
[17:45:38.175] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:38.175] - nx: 1
[17:45:38.175] - relay: TRUE
[17:45:38.175] - stdout: TRUE
[17:45:38.175] - signal: TRUE
[17:45:38.175] - resignal: FALSE
[17:45:38.175] - force: TRUE
[17:45:38.176] - relayed: [n=1] FALSE
[17:45:38.176] - queued futures: [n=1] FALSE
[17:45:38.176]  - until=1
[17:45:38.176]  - relaying element #1
[17:45:38.176] - relayed: [n=1] TRUE
[17:45:38.176] - queued futures: [n=1] TRUE
[17:45:38.176] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:38.176]  length: 0 (resolved future 1)
[17:45:38.176] Relaying remaining futures
[17:45:38.176] signalConditionsASAP(NULL, pos=0) ...
[17:45:38.176] - nx: 1
[17:45:38.177] - relay: TRUE
[17:45:38.177] - stdout: TRUE
[17:45:38.177] - signal: TRUE
[17:45:38.177] - resignal: FALSE
[17:45:38.177] - force: TRUE
[17:45:38.177] - relayed: [n=1] TRUE
[17:45:38.177] - queued futures: [n=1] TRUE
 - flush all
[17:45:38.177] - relayed: [n=1] TRUE
[17:45:38.177] - queued futures: [n=1] TRUE
[17:45:38.177] signalConditionsASAP(NULL, pos=0) ... done
[17:45:38.177] resolve() on list ... DONE
[17:45:38.178]  - Number of value chunks collected: 1
[17:45:38.178] Resolving 1 futures (chunks) ... DONE
[17:45:38.178] Reducing values from 1 chunks ...
[17:45:38.178]  - Number of values collected after concatenation: 2
[17:45:38.178]  - Number of values expected: 2
[17:45:38.178] Reducing values from 1 chunks ... DONE
[17:45:38.178] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[17:45:38.179] plan(): Setting new future strategy stack:
[17:45:38.179] List of future strategies:
[17:45:38.179] 1. multisession:
[17:45:38.179]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:45:38.179]    - tweaked: FALSE
[17:45:38.179]    - call: plan(strategy)
[17:45:38.179] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:45:38.179] multisession:
[17:45:38.179] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:45:38.179] - tweaked: FALSE
[17:45:38.179] - call: plan(strategy)
[17:45:38.182] getGlobalsAndPackages() ...
[17:45:38.183] Not searching for globals
[17:45:38.183] - globals: [0] <none>
[17:45:38.183] getGlobalsAndPackages() ... DONE
[17:45:38.183] Packages needed by the future expression (n = 0): <none>
[17:45:38.183] Packages needed by future strategies (n = 0): <none>
[17:45:38.184] {
[17:45:38.184]     {
[17:45:38.184]         {
[17:45:38.184]             ...future.startTime <- base::Sys.time()
[17:45:38.184]             {
[17:45:38.184]                 {
[17:45:38.184]                   {
[17:45:38.184]                     base::local({
[17:45:38.184]                       has_future <- base::requireNamespace("future", 
[17:45:38.184]                         quietly = TRUE)
[17:45:38.184]                       if (has_future) {
[17:45:38.184]                         ns <- base::getNamespace("future")
[17:45:38.184]                         version <- ns[[".package"]][["version"]]
[17:45:38.184]                         if (is.null(version)) 
[17:45:38.184]                           version <- utils::packageVersion("future")
[17:45:38.184]                       }
[17:45:38.184]                       else {
[17:45:38.184]                         version <- NULL
[17:45:38.184]                       }
[17:45:38.184]                       if (!has_future || version < "1.8.0") {
[17:45:38.184]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:38.184]                           "", base::R.version$version.string), 
[17:45:38.184]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:38.184]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:38.184]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:38.184]                             "release", "version")], collapse = " "), 
[17:45:38.184]                           hostname = base::Sys.info()[["nodename"]])
[17:45:38.184]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:38.184]                           info)
[17:45:38.184]                         info <- base::paste(info, collapse = "; ")
[17:45:38.184]                         if (!has_future) {
[17:45:38.184]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:38.184]                             info)
[17:45:38.184]                         }
[17:45:38.184]                         else {
[17:45:38.184]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:38.184]                             info, version)
[17:45:38.184]                         }
[17:45:38.184]                         base::stop(msg)
[17:45:38.184]                       }
[17:45:38.184]                     })
[17:45:38.184]                   }
[17:45:38.184]                   ...future.strategy.old <- future::plan("list")
[17:45:38.184]                   options(future.plan = NULL)
[17:45:38.184]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:38.184]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:38.184]                 }
[17:45:38.184]                 ...future.workdir <- getwd()
[17:45:38.184]             }
[17:45:38.184]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:38.184]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:38.184]         }
[17:45:38.184]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:38.184]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:38.184]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:38.184]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:38.184]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:38.184]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:38.184]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:38.184]             base::names(...future.oldOptions))
[17:45:38.184]     }
[17:45:38.184]     if (FALSE) {
[17:45:38.184]     }
[17:45:38.184]     else {
[17:45:38.184]         if (TRUE) {
[17:45:38.184]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:38.184]                 open = "w")
[17:45:38.184]         }
[17:45:38.184]         else {
[17:45:38.184]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:38.184]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:38.184]         }
[17:45:38.184]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:38.184]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:38.184]             base::sink(type = "output", split = FALSE)
[17:45:38.184]             base::close(...future.stdout)
[17:45:38.184]         }, add = TRUE)
[17:45:38.184]     }
[17:45:38.184]     ...future.frame <- base::sys.nframe()
[17:45:38.184]     ...future.conditions <- base::list()
[17:45:38.184]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:38.184]     if (FALSE) {
[17:45:38.184]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:38.184]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:38.184]     }
[17:45:38.184]     ...future.result <- base::tryCatch({
[17:45:38.184]         base::withCallingHandlers({
[17:45:38.184]             ...future.value <- base::withVisible(base::local(NA))
[17:45:38.184]             future::FutureResult(value = ...future.value$value, 
[17:45:38.184]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:38.184]                   ...future.rng), globalenv = if (FALSE) 
[17:45:38.184]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:38.184]                     ...future.globalenv.names))
[17:45:38.184]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:38.184]         }, condition = base::local({
[17:45:38.184]             c <- base::c
[17:45:38.184]             inherits <- base::inherits
[17:45:38.184]             invokeRestart <- base::invokeRestart
[17:45:38.184]             length <- base::length
[17:45:38.184]             list <- base::list
[17:45:38.184]             seq.int <- base::seq.int
[17:45:38.184]             signalCondition <- base::signalCondition
[17:45:38.184]             sys.calls <- base::sys.calls
[17:45:38.184]             `[[` <- base::`[[`
[17:45:38.184]             `+` <- base::`+`
[17:45:38.184]             `<<-` <- base::`<<-`
[17:45:38.184]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:38.184]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:38.184]                   3L)]
[17:45:38.184]             }
[17:45:38.184]             function(cond) {
[17:45:38.184]                 is_error <- inherits(cond, "error")
[17:45:38.184]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:38.184]                   NULL)
[17:45:38.184]                 if (is_error) {
[17:45:38.184]                   sessionInformation <- function() {
[17:45:38.184]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:38.184]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:38.184]                       search = base::search(), system = base::Sys.info())
[17:45:38.184]                   }
[17:45:38.184]                   ...future.conditions[[length(...future.conditions) + 
[17:45:38.184]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:38.184]                     cond$call), session = sessionInformation(), 
[17:45:38.184]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:38.184]                   signalCondition(cond)
[17:45:38.184]                 }
[17:45:38.184]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:38.184]                 "immediateCondition"))) {
[17:45:38.184]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:38.184]                   ...future.conditions[[length(...future.conditions) + 
[17:45:38.184]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:38.184]                   if (TRUE && !signal) {
[17:45:38.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:38.184]                     {
[17:45:38.184]                       inherits <- base::inherits
[17:45:38.184]                       invokeRestart <- base::invokeRestart
[17:45:38.184]                       is.null <- base::is.null
[17:45:38.184]                       muffled <- FALSE
[17:45:38.184]                       if (inherits(cond, "message")) {
[17:45:38.184]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:38.184]                         if (muffled) 
[17:45:38.184]                           invokeRestart("muffleMessage")
[17:45:38.184]                       }
[17:45:38.184]                       else if (inherits(cond, "warning")) {
[17:45:38.184]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:38.184]                         if (muffled) 
[17:45:38.184]                           invokeRestart("muffleWarning")
[17:45:38.184]                       }
[17:45:38.184]                       else if (inherits(cond, "condition")) {
[17:45:38.184]                         if (!is.null(pattern)) {
[17:45:38.184]                           computeRestarts <- base::computeRestarts
[17:45:38.184]                           grepl <- base::grepl
[17:45:38.184]                           restarts <- computeRestarts(cond)
[17:45:38.184]                           for (restart in restarts) {
[17:45:38.184]                             name <- restart$name
[17:45:38.184]                             if (is.null(name)) 
[17:45:38.184]                               next
[17:45:38.184]                             if (!grepl(pattern, name)) 
[17:45:38.184]                               next
[17:45:38.184]                             invokeRestart(restart)
[17:45:38.184]                             muffled <- TRUE
[17:45:38.184]                             break
[17:45:38.184]                           }
[17:45:38.184]                         }
[17:45:38.184]                       }
[17:45:38.184]                       invisible(muffled)
[17:45:38.184]                     }
[17:45:38.184]                     muffleCondition(cond, pattern = "^muffle")
[17:45:38.184]                   }
[17:45:38.184]                 }
[17:45:38.184]                 else {
[17:45:38.184]                   if (TRUE) {
[17:45:38.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:38.184]                     {
[17:45:38.184]                       inherits <- base::inherits
[17:45:38.184]                       invokeRestart <- base::invokeRestart
[17:45:38.184]                       is.null <- base::is.null
[17:45:38.184]                       muffled <- FALSE
[17:45:38.184]                       if (inherits(cond, "message")) {
[17:45:38.184]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:38.184]                         if (muffled) 
[17:45:38.184]                           invokeRestart("muffleMessage")
[17:45:38.184]                       }
[17:45:38.184]                       else if (inherits(cond, "warning")) {
[17:45:38.184]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:38.184]                         if (muffled) 
[17:45:38.184]                           invokeRestart("muffleWarning")
[17:45:38.184]                       }
[17:45:38.184]                       else if (inherits(cond, "condition")) {
[17:45:38.184]                         if (!is.null(pattern)) {
[17:45:38.184]                           computeRestarts <- base::computeRestarts
[17:45:38.184]                           grepl <- base::grepl
[17:45:38.184]                           restarts <- computeRestarts(cond)
[17:45:38.184]                           for (restart in restarts) {
[17:45:38.184]                             name <- restart$name
[17:45:38.184]                             if (is.null(name)) 
[17:45:38.184]                               next
[17:45:38.184]                             if (!grepl(pattern, name)) 
[17:45:38.184]                               next
[17:45:38.184]                             invokeRestart(restart)
[17:45:38.184]                             muffled <- TRUE
[17:45:38.184]                             break
[17:45:38.184]                           }
[17:45:38.184]                         }
[17:45:38.184]                       }
[17:45:38.184]                       invisible(muffled)
[17:45:38.184]                     }
[17:45:38.184]                     muffleCondition(cond, pattern = "^muffle")
[17:45:38.184]                   }
[17:45:38.184]                 }
[17:45:38.184]             }
[17:45:38.184]         }))
[17:45:38.184]     }, error = function(ex) {
[17:45:38.184]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:38.184]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:38.184]                 ...future.rng), started = ...future.startTime, 
[17:45:38.184]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:38.184]             version = "1.8"), class = "FutureResult")
[17:45:38.184]     }, finally = {
[17:45:38.184]         if (!identical(...future.workdir, getwd())) 
[17:45:38.184]             setwd(...future.workdir)
[17:45:38.184]         {
[17:45:38.184]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:38.184]                 ...future.oldOptions$nwarnings <- NULL
[17:45:38.184]             }
[17:45:38.184]             base::options(...future.oldOptions)
[17:45:38.184]             if (.Platform$OS.type == "windows") {
[17:45:38.184]                 old_names <- names(...future.oldEnvVars)
[17:45:38.184]                 envs <- base::Sys.getenv()
[17:45:38.184]                 names <- names(envs)
[17:45:38.184]                 common <- intersect(names, old_names)
[17:45:38.184]                 added <- setdiff(names, old_names)
[17:45:38.184]                 removed <- setdiff(old_names, names)
[17:45:38.184]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:38.184]                   envs[common]]
[17:45:38.184]                 NAMES <- toupper(changed)
[17:45:38.184]                 args <- list()
[17:45:38.184]                 for (kk in seq_along(NAMES)) {
[17:45:38.184]                   name <- changed[[kk]]
[17:45:38.184]                   NAME <- NAMES[[kk]]
[17:45:38.184]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:38.184]                     next
[17:45:38.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:38.184]                 }
[17:45:38.184]                 NAMES <- toupper(added)
[17:45:38.184]                 for (kk in seq_along(NAMES)) {
[17:45:38.184]                   name <- added[[kk]]
[17:45:38.184]                   NAME <- NAMES[[kk]]
[17:45:38.184]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:38.184]                     next
[17:45:38.184]                   args[[name]] <- ""
[17:45:38.184]                 }
[17:45:38.184]                 NAMES <- toupper(removed)
[17:45:38.184]                 for (kk in seq_along(NAMES)) {
[17:45:38.184]                   name <- removed[[kk]]
[17:45:38.184]                   NAME <- NAMES[[kk]]
[17:45:38.184]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:38.184]                     next
[17:45:38.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:38.184]                 }
[17:45:38.184]                 if (length(args) > 0) 
[17:45:38.184]                   base::do.call(base::Sys.setenv, args = args)
[17:45:38.184]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:38.184]             }
[17:45:38.184]             else {
[17:45:38.184]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:38.184]             }
[17:45:38.184]             {
[17:45:38.184]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:38.184]                   0L) {
[17:45:38.184]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:38.184]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:38.184]                   base::options(opts)
[17:45:38.184]                 }
[17:45:38.184]                 {
[17:45:38.184]                   {
[17:45:38.184]                     NULL
[17:45:38.184]                     RNGkind("Mersenne-Twister")
[17:45:38.184]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:38.184]                       inherits = FALSE)
[17:45:38.184]                   }
[17:45:38.184]                   options(future.plan = NULL)
[17:45:38.184]                   if (is.na(NA_character_)) 
[17:45:38.184]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:38.184]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:38.184]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:38.184]                     .init = FALSE)
[17:45:38.184]                 }
[17:45:38.184]             }
[17:45:38.184]         }
[17:45:38.184]     })
[17:45:38.184]     if (TRUE) {
[17:45:38.184]         base::sink(type = "output", split = FALSE)
[17:45:38.184]         if (TRUE) {
[17:45:38.184]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:38.184]         }
[17:45:38.184]         else {
[17:45:38.184]             ...future.result["stdout"] <- base::list(NULL)
[17:45:38.184]         }
[17:45:38.184]         base::close(...future.stdout)
[17:45:38.184]         ...future.stdout <- NULL
[17:45:38.184]     }
[17:45:38.184]     ...future.result$conditions <- ...future.conditions
[17:45:38.184]     ...future.result$finished <- base::Sys.time()
[17:45:38.184]     ...future.result
[17:45:38.184] }
[17:45:38.186] plan(): Setting new future strategy stack:
[17:45:38.186] List of future strategies:
[17:45:38.186] 1. sequential:
[17:45:38.186]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:38.186]    - tweaked: FALSE
[17:45:38.186]    - call: NULL
[17:45:38.186] plan(): nbrOfWorkers() = 1
[17:45:38.187] plan(): Setting new future strategy stack:
[17:45:38.187] List of future strategies:
[17:45:38.187] 1. multisession:
[17:45:38.187]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:45:38.187]    - tweaked: FALSE
[17:45:38.187]    - call: plan(strategy)
[17:45:38.190] plan(): nbrOfWorkers() = 1
[17:45:38.190] SequentialFuture started (and completed)
[17:45:38.191] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:45:38.194] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:45:38.194] future_lapply() ...
[17:45:38.198] Number of chunks: 1
[17:45:38.198] getGlobalsAndPackagesXApply() ...
[17:45:38.198]  - future.globals: TRUE
[17:45:38.198] getGlobalsAndPackages() ...
[17:45:38.198] Searching for globals...
[17:45:38.201] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:38.201] Searching for globals ... DONE
[17:45:38.202] Resolving globals: FALSE
[17:45:38.202] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:38.202] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:38.202] - globals: [1] ‘FUN’
[17:45:38.202] 
[17:45:38.203] getGlobalsAndPackages() ... DONE
[17:45:38.203]  - globals found/used: [n=1] ‘FUN’
[17:45:38.203]  - needed namespaces: [n=0] 
[17:45:38.203] Finding globals ... DONE
[17:45:38.203]  - use_args: TRUE
[17:45:38.203]  - Getting '...' globals ...
[17:45:38.203] resolve() on list ...
[17:45:38.204]  recursive: 0
[17:45:38.204]  length: 1
[17:45:38.204]  elements: ‘...’
[17:45:38.204]  length: 0 (resolved future 1)
[17:45:38.204] resolve() on list ... DONE
[17:45:38.204]    - '...' content: [n=0] 
[17:45:38.204] List of 1
[17:45:38.204]  $ ...: list()
[17:45:38.204]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:38.204]  - attr(*, "where")=List of 1
[17:45:38.204]   ..$ ...:<environment: 0x55f6c7765b80> 
[17:45:38.204]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:38.204]  - attr(*, "resolved")= logi TRUE
[17:45:38.204]  - attr(*, "total_size")= num NA
[17:45:38.207]  - Getting '...' globals ... DONE
[17:45:38.207] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:38.207] List of 2
[17:45:38.207]  $ ...future.FUN:function (x)  
[17:45:38.207]  $ ...          : list()
[17:45:38.207]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:38.207]  - attr(*, "where")=List of 2
[17:45:38.207]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:38.207]   ..$ ...          :<environment: 0x55f6c7765b80> 
[17:45:38.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:38.207]  - attr(*, "resolved")= logi FALSE
[17:45:38.207]  - attr(*, "total_size")= num 4720
[17:45:38.209] Packages to be attached in all futures: [n=0] 
[17:45:38.209] getGlobalsAndPackagesXApply() ... DONE
[17:45:38.210] Number of futures (= number of chunks): 1
[17:45:38.210] Launching 1 futures (chunks) ...
[17:45:38.210] Chunk #1 of 1 ...
[17:45:38.210]  - Finding globals in 'X' for chunk #1 ...
[17:45:38.210] getGlobalsAndPackages() ...
[17:45:38.210] Searching for globals...
[17:45:38.210] 
[17:45:38.210] Searching for globals ... DONE
[17:45:38.211] - globals: [0] <none>
[17:45:38.211] getGlobalsAndPackages() ... DONE
[17:45:38.211]    + additional globals found: [n=0] 
[17:45:38.211]    + additional namespaces needed: [n=0] 
[17:45:38.211]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:38.211]  - seeds: <none>
[17:45:38.211]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:38.211] getGlobalsAndPackages() ...
[17:45:38.211] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:38.211] Resolving globals: FALSE
[17:45:38.211] Tweak future expression to call with '...' arguments ...
[17:45:38.212] {
[17:45:38.212]     do.call(function(...) {
[17:45:38.212]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:38.212]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:38.212]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:38.212]             on.exit(options(oopts), add = TRUE)
[17:45:38.212]         }
[17:45:38.212]         {
[17:45:38.212]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:38.212]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:38.212]                 ...future.FUN(...future.X_jj, ...)
[17:45:38.212]             })
[17:45:38.212]         }
[17:45:38.212]     }, args = future.call.arguments)
[17:45:38.212] }
[17:45:38.212] Tweak future expression to call with '...' arguments ... DONE
[17:45:38.212] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:38.212] 
[17:45:38.212] getGlobalsAndPackages() ... DONE
[17:45:38.213] run() for ‘Future’ ...
[17:45:38.213] - state: ‘created’
[17:45:38.213] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:38.216] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:38.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:38.216]   - Field: ‘label’
[17:45:38.217]   - Field: ‘local’
[17:45:38.217]   - Field: ‘owner’
[17:45:38.217]   - Field: ‘envir’
[17:45:38.217]   - Field: ‘packages’
[17:45:38.217]   - Field: ‘gc’
[17:45:38.217]   - Field: ‘conditions’
[17:45:38.217]   - Field: ‘expr’
[17:45:38.217]   - Field: ‘uuid’
[17:45:38.217]   - Field: ‘seed’
[17:45:38.217]   - Field: ‘version’
[17:45:38.217]   - Field: ‘result’
[17:45:38.218]   - Field: ‘asynchronous’
[17:45:38.218]   - Field: ‘calls’
[17:45:38.218]   - Field: ‘globals’
[17:45:38.218]   - Field: ‘stdout’
[17:45:38.218]   - Field: ‘earlySignal’
[17:45:38.218]   - Field: ‘lazy’
[17:45:38.218]   - Field: ‘state’
[17:45:38.218] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:38.218] - Launch lazy future ...
[17:45:38.219] Packages needed by the future expression (n = 0): <none>
[17:45:38.219] Packages needed by future strategies (n = 0): <none>
[17:45:38.219] {
[17:45:38.219]     {
[17:45:38.219]         {
[17:45:38.219]             ...future.startTime <- base::Sys.time()
[17:45:38.219]             {
[17:45:38.219]                 {
[17:45:38.219]                   {
[17:45:38.219]                     base::local({
[17:45:38.219]                       has_future <- base::requireNamespace("future", 
[17:45:38.219]                         quietly = TRUE)
[17:45:38.219]                       if (has_future) {
[17:45:38.219]                         ns <- base::getNamespace("future")
[17:45:38.219]                         version <- ns[[".package"]][["version"]]
[17:45:38.219]                         if (is.null(version)) 
[17:45:38.219]                           version <- utils::packageVersion("future")
[17:45:38.219]                       }
[17:45:38.219]                       else {
[17:45:38.219]                         version <- NULL
[17:45:38.219]                       }
[17:45:38.219]                       if (!has_future || version < "1.8.0") {
[17:45:38.219]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:38.219]                           "", base::R.version$version.string), 
[17:45:38.219]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:38.219]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:38.219]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:38.219]                             "release", "version")], collapse = " "), 
[17:45:38.219]                           hostname = base::Sys.info()[["nodename"]])
[17:45:38.219]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:38.219]                           info)
[17:45:38.219]                         info <- base::paste(info, collapse = "; ")
[17:45:38.219]                         if (!has_future) {
[17:45:38.219]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:38.219]                             info)
[17:45:38.219]                         }
[17:45:38.219]                         else {
[17:45:38.219]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:38.219]                             info, version)
[17:45:38.219]                         }
[17:45:38.219]                         base::stop(msg)
[17:45:38.219]                       }
[17:45:38.219]                     })
[17:45:38.219]                   }
[17:45:38.219]                   ...future.strategy.old <- future::plan("list")
[17:45:38.219]                   options(future.plan = NULL)
[17:45:38.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:38.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:38.219]                 }
[17:45:38.219]                 ...future.workdir <- getwd()
[17:45:38.219]             }
[17:45:38.219]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:38.219]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:38.219]         }
[17:45:38.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:38.219]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:38.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:38.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:38.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:38.219]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:38.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:38.219]             base::names(...future.oldOptions))
[17:45:38.219]     }
[17:45:38.219]     if (FALSE) {
[17:45:38.219]     }
[17:45:38.219]     else {
[17:45:38.219]         if (FALSE) {
[17:45:38.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:38.219]                 open = "w")
[17:45:38.219]         }
[17:45:38.219]         else {
[17:45:38.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:38.219]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:38.219]         }
[17:45:38.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:38.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:38.219]             base::sink(type = "output", split = FALSE)
[17:45:38.219]             base::close(...future.stdout)
[17:45:38.219]         }, add = TRUE)
[17:45:38.219]     }
[17:45:38.219]     ...future.frame <- base::sys.nframe()
[17:45:38.219]     ...future.conditions <- base::list()
[17:45:38.219]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:38.219]     if (FALSE) {
[17:45:38.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:38.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:38.219]     }
[17:45:38.219]     ...future.result <- base::tryCatch({
[17:45:38.219]         base::withCallingHandlers({
[17:45:38.219]             ...future.value <- base::withVisible(base::local({
[17:45:38.219]                 do.call(function(...) {
[17:45:38.219]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:38.219]                   if (!identical(...future.globals.maxSize.org, 
[17:45:38.219]                     ...future.globals.maxSize)) {
[17:45:38.219]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:38.219]                     on.exit(options(oopts), add = TRUE)
[17:45:38.219]                   }
[17:45:38.219]                   {
[17:45:38.219]                     lapply(seq_along(...future.elements_ii), 
[17:45:38.219]                       FUN = function(jj) {
[17:45:38.219]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:38.219]                         ...future.FUN(...future.X_jj, ...)
[17:45:38.219]                       })
[17:45:38.219]                   }
[17:45:38.219]                 }, args = future.call.arguments)
[17:45:38.219]             }))
[17:45:38.219]             future::FutureResult(value = ...future.value$value, 
[17:45:38.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:38.219]                   ...future.rng), globalenv = if (FALSE) 
[17:45:38.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:38.219]                     ...future.globalenv.names))
[17:45:38.219]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:38.219]         }, condition = base::local({
[17:45:38.219]             c <- base::c
[17:45:38.219]             inherits <- base::inherits
[17:45:38.219]             invokeRestart <- base::invokeRestart
[17:45:38.219]             length <- base::length
[17:45:38.219]             list <- base::list
[17:45:38.219]             seq.int <- base::seq.int
[17:45:38.219]             signalCondition <- base::signalCondition
[17:45:38.219]             sys.calls <- base::sys.calls
[17:45:38.219]             `[[` <- base::`[[`
[17:45:38.219]             `+` <- base::`+`
[17:45:38.219]             `<<-` <- base::`<<-`
[17:45:38.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:38.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:38.219]                   3L)]
[17:45:38.219]             }
[17:45:38.219]             function(cond) {
[17:45:38.219]                 is_error <- inherits(cond, "error")
[17:45:38.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:38.219]                   NULL)
[17:45:38.219]                 if (is_error) {
[17:45:38.219]                   sessionInformation <- function() {
[17:45:38.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:38.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:38.219]                       search = base::search(), system = base::Sys.info())
[17:45:38.219]                   }
[17:45:38.219]                   ...future.conditions[[length(...future.conditions) + 
[17:45:38.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:38.219]                     cond$call), session = sessionInformation(), 
[17:45:38.219]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:38.219]                   signalCondition(cond)
[17:45:38.219]                 }
[17:45:38.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:38.219]                 "immediateCondition"))) {
[17:45:38.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:38.219]                   ...future.conditions[[length(...future.conditions) + 
[17:45:38.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:38.219]                   if (TRUE && !signal) {
[17:45:38.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:38.219]                     {
[17:45:38.219]                       inherits <- base::inherits
[17:45:38.219]                       invokeRestart <- base::invokeRestart
[17:45:38.219]                       is.null <- base::is.null
[17:45:38.219]                       muffled <- FALSE
[17:45:38.219]                       if (inherits(cond, "message")) {
[17:45:38.219]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:38.219]                         if (muffled) 
[17:45:38.219]                           invokeRestart("muffleMessage")
[17:45:38.219]                       }
[17:45:38.219]                       else if (inherits(cond, "warning")) {
[17:45:38.219]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:38.219]                         if (muffled) 
[17:45:38.219]                           invokeRestart("muffleWarning")
[17:45:38.219]                       }
[17:45:38.219]                       else if (inherits(cond, "condition")) {
[17:45:38.219]                         if (!is.null(pattern)) {
[17:45:38.219]                           computeRestarts <- base::computeRestarts
[17:45:38.219]                           grepl <- base::grepl
[17:45:38.219]                           restarts <- computeRestarts(cond)
[17:45:38.219]                           for (restart in restarts) {
[17:45:38.219]                             name <- restart$name
[17:45:38.219]                             if (is.null(name)) 
[17:45:38.219]                               next
[17:45:38.219]                             if (!grepl(pattern, name)) 
[17:45:38.219]                               next
[17:45:38.219]                             invokeRestart(restart)
[17:45:38.219]                             muffled <- TRUE
[17:45:38.219]                             break
[17:45:38.219]                           }
[17:45:38.219]                         }
[17:45:38.219]                       }
[17:45:38.219]                       invisible(muffled)
[17:45:38.219]                     }
[17:45:38.219]                     muffleCondition(cond, pattern = "^muffle")
[17:45:38.219]                   }
[17:45:38.219]                 }
[17:45:38.219]                 else {
[17:45:38.219]                   if (TRUE) {
[17:45:38.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:38.219]                     {
[17:45:38.219]                       inherits <- base::inherits
[17:45:38.219]                       invokeRestart <- base::invokeRestart
[17:45:38.219]                       is.null <- base::is.null
[17:45:38.219]                       muffled <- FALSE
[17:45:38.219]                       if (inherits(cond, "message")) {
[17:45:38.219]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:38.219]                         if (muffled) 
[17:45:38.219]                           invokeRestart("muffleMessage")
[17:45:38.219]                       }
[17:45:38.219]                       else if (inherits(cond, "warning")) {
[17:45:38.219]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:38.219]                         if (muffled) 
[17:45:38.219]                           invokeRestart("muffleWarning")
[17:45:38.219]                       }
[17:45:38.219]                       else if (inherits(cond, "condition")) {
[17:45:38.219]                         if (!is.null(pattern)) {
[17:45:38.219]                           computeRestarts <- base::computeRestarts
[17:45:38.219]                           grepl <- base::grepl
[17:45:38.219]                           restarts <- computeRestarts(cond)
[17:45:38.219]                           for (restart in restarts) {
[17:45:38.219]                             name <- restart$name
[17:45:38.219]                             if (is.null(name)) 
[17:45:38.219]                               next
[17:45:38.219]                             if (!grepl(pattern, name)) 
[17:45:38.219]                               next
[17:45:38.219]                             invokeRestart(restart)
[17:45:38.219]                             muffled <- TRUE
[17:45:38.219]                             break
[17:45:38.219]                           }
[17:45:38.219]                         }
[17:45:38.219]                       }
[17:45:38.219]                       invisible(muffled)
[17:45:38.219]                     }
[17:45:38.219]                     muffleCondition(cond, pattern = "^muffle")
[17:45:38.219]                   }
[17:45:38.219]                 }
[17:45:38.219]             }
[17:45:38.219]         }))
[17:45:38.219]     }, error = function(ex) {
[17:45:38.219]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:38.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:38.219]                 ...future.rng), started = ...future.startTime, 
[17:45:38.219]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:38.219]             version = "1.8"), class = "FutureResult")
[17:45:38.219]     }, finally = {
[17:45:38.219]         if (!identical(...future.workdir, getwd())) 
[17:45:38.219]             setwd(...future.workdir)
[17:45:38.219]         {
[17:45:38.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:38.219]                 ...future.oldOptions$nwarnings <- NULL
[17:45:38.219]             }
[17:45:38.219]             base::options(...future.oldOptions)
[17:45:38.219]             if (.Platform$OS.type == "windows") {
[17:45:38.219]                 old_names <- names(...future.oldEnvVars)
[17:45:38.219]                 envs <- base::Sys.getenv()
[17:45:38.219]                 names <- names(envs)
[17:45:38.219]                 common <- intersect(names, old_names)
[17:45:38.219]                 added <- setdiff(names, old_names)
[17:45:38.219]                 removed <- setdiff(old_names, names)
[17:45:38.219]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:38.219]                   envs[common]]
[17:45:38.219]                 NAMES <- toupper(changed)
[17:45:38.219]                 args <- list()
[17:45:38.219]                 for (kk in seq_along(NAMES)) {
[17:45:38.219]                   name <- changed[[kk]]
[17:45:38.219]                   NAME <- NAMES[[kk]]
[17:45:38.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:38.219]                     next
[17:45:38.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:38.219]                 }
[17:45:38.219]                 NAMES <- toupper(added)
[17:45:38.219]                 for (kk in seq_along(NAMES)) {
[17:45:38.219]                   name <- added[[kk]]
[17:45:38.219]                   NAME <- NAMES[[kk]]
[17:45:38.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:38.219]                     next
[17:45:38.219]                   args[[name]] <- ""
[17:45:38.219]                 }
[17:45:38.219]                 NAMES <- toupper(removed)
[17:45:38.219]                 for (kk in seq_along(NAMES)) {
[17:45:38.219]                   name <- removed[[kk]]
[17:45:38.219]                   NAME <- NAMES[[kk]]
[17:45:38.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:38.219]                     next
[17:45:38.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:38.219]                 }
[17:45:38.219]                 if (length(args) > 0) 
[17:45:38.219]                   base::do.call(base::Sys.setenv, args = args)
[17:45:38.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:38.219]             }
[17:45:38.219]             else {
[17:45:38.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:38.219]             }
[17:45:38.219]             {
[17:45:38.219]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:38.219]                   0L) {
[17:45:38.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:38.219]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:38.219]                   base::options(opts)
[17:45:38.219]                 }
[17:45:38.219]                 {
[17:45:38.219]                   {
[17:45:38.219]                     NULL
[17:45:38.219]                     RNGkind("Mersenne-Twister")
[17:45:38.219]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:38.219]                       inherits = FALSE)
[17:45:38.219]                   }
[17:45:38.219]                   options(future.plan = NULL)
[17:45:38.219]                   if (is.na(NA_character_)) 
[17:45:38.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:38.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:38.219]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:38.219]                     .init = FALSE)
[17:45:38.219]                 }
[17:45:38.219]             }
[17:45:38.219]         }
[17:45:38.219]     })
[17:45:38.219]     if (TRUE) {
[17:45:38.219]         base::sink(type = "output", split = FALSE)
[17:45:38.219]         if (FALSE) {
[17:45:38.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:38.219]         }
[17:45:38.219]         else {
[17:45:38.219]             ...future.result["stdout"] <- base::list(NULL)
[17:45:38.219]         }
[17:45:38.219]         base::close(...future.stdout)
[17:45:38.219]         ...future.stdout <- NULL
[17:45:38.219]     }
[17:45:38.219]     ...future.result$conditions <- ...future.conditions
[17:45:38.219]     ...future.result$finished <- base::Sys.time()
[17:45:38.219]     ...future.result
[17:45:38.219] }
[17:45:38.221] assign_globals() ...
[17:45:38.221] List of 5
[17:45:38.221]  $ ...future.FUN            :function (x)  
[17:45:38.221]  $ future.call.arguments    : list()
[17:45:38.221]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:38.221]  $ ...future.elements_ii    :List of 2
[17:45:38.221]   ..$ : int 1
[17:45:38.221]   ..$ : int 0
[17:45:38.221]  $ ...future.seeds_ii       : NULL
[17:45:38.221]  $ ...future.globals.maxSize: NULL
[17:45:38.221]  - attr(*, "where")=List of 5
[17:45:38.221]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:38.221]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:38.221]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:38.221]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:38.221]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:38.221]  - attr(*, "resolved")= logi FALSE
[17:45:38.221]  - attr(*, "total_size")= num 4720
[17:45:38.221]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:38.221]  - attr(*, "already-done")= logi TRUE
[17:45:38.251] - reassign environment for ‘...future.FUN’
[17:45:38.251] - copied ‘...future.FUN’ to environment
[17:45:38.251] - copied ‘future.call.arguments’ to environment
[17:45:38.251] - copied ‘...future.elements_ii’ to environment
[17:45:38.251] - copied ‘...future.seeds_ii’ to environment
[17:45:38.251] - copied ‘...future.globals.maxSize’ to environment
[17:45:38.252] assign_globals() ... done
[17:45:38.252] plan(): Setting new future strategy stack:
[17:45:38.252] List of future strategies:
[17:45:38.252] 1. sequential:
[17:45:38.252]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:38.252]    - tweaked: FALSE
[17:45:38.252]    - call: NULL
[17:45:38.252] plan(): nbrOfWorkers() = 1
[17:45:38.754] plan(): Setting new future strategy stack:
[17:45:38.754] List of future strategies:
[17:45:38.754] 1. multisession:
[17:45:38.754]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:45:38.754]    - tweaked: FALSE
[17:45:38.754]    - call: plan(strategy)
[17:45:38.758] plan(): nbrOfWorkers() = 1
[17:45:38.758] SequentialFuture started (and completed)
[17:45:38.758] - Launch lazy future ... done
[17:45:38.759] run() for ‘SequentialFuture’ ... done
[17:45:38.759] Created future:
[17:45:38.759] SequentialFuture:
[17:45:38.759] Label: ‘future_lapply-1’
[17:45:38.759] Expression:
[17:45:38.759] {
[17:45:38.759]     do.call(function(...) {
[17:45:38.759]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:38.759]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:38.759]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:38.759]             on.exit(options(oopts), add = TRUE)
[17:45:38.759]         }
[17:45:38.759]         {
[17:45:38.759]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:38.759]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:38.759]                 ...future.FUN(...future.X_jj, ...)
[17:45:38.759]             })
[17:45:38.759]         }
[17:45:38.759]     }, args = future.call.arguments)
[17:45:38.759] }
[17:45:38.759] Lazy evaluation: FALSE
[17:45:38.759] Asynchronous evaluation: FALSE
[17:45:38.759] Local evaluation: TRUE
[17:45:38.759] Environment: R_GlobalEnv
[17:45:38.759] Capture standard output: FALSE
[17:45:38.759] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:38.759] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:38.759] Packages: <none>
[17:45:38.759] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:38.759] Resolved: TRUE
[17:45:38.759] Value: 112 bytes of class ‘list’
[17:45:38.759] Early signaling: FALSE
[17:45:38.759] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:38.759] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:38.760] Chunk #1 of 1 ... DONE
[17:45:38.760] Launching 1 futures (chunks) ... DONE
[17:45:38.760] Resolving 1 futures (chunks) ...
[17:45:38.760] resolve() on list ...
[17:45:38.760]  recursive: 0
[17:45:38.760]  length: 1
[17:45:38.761] 
[17:45:38.761] resolved() for ‘SequentialFuture’ ...
[17:45:38.761] - state: ‘finished’
[17:45:38.761] - run: TRUE
[17:45:38.761] - result: ‘FutureResult’
[17:45:38.761] resolved() for ‘SequentialFuture’ ... done
[17:45:38.761] Future #1
[17:45:38.761] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:38.761] - nx: 1
[17:45:38.761] - relay: TRUE
[17:45:38.762] - stdout: TRUE
[17:45:38.762] - signal: TRUE
[17:45:38.762] - resignal: FALSE
[17:45:38.762] - force: TRUE
[17:45:38.762] - relayed: [n=1] FALSE
[17:45:38.762] - queued futures: [n=1] FALSE
[17:45:38.762]  - until=1
[17:45:38.762]  - relaying element #1
[17:45:38.762] - relayed: [n=1] TRUE
[17:45:38.762] - queued futures: [n=1] TRUE
[17:45:38.762] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:38.763]  length: 0 (resolved future 1)
[17:45:38.763] Relaying remaining futures
[17:45:38.763] signalConditionsASAP(NULL, pos=0) ...
[17:45:38.763] - nx: 1
[17:45:38.763] - relay: TRUE
[17:45:38.763] - stdout: TRUE
[17:45:38.763] - signal: TRUE
[17:45:38.763] - resignal: FALSE
[17:45:38.763] - force: TRUE
[17:45:38.763] - relayed: [n=1] TRUE
[17:45:38.763] - queued futures: [n=1] TRUE
 - flush all
[17:45:38.764] - relayed: [n=1] TRUE
[17:45:38.764] - queued futures: [n=1] TRUE
[17:45:38.764] signalConditionsASAP(NULL, pos=0) ... done
[17:45:38.764] resolve() on list ... DONE
[17:45:38.764]  - Number of value chunks collected: 1
[17:45:38.764] Resolving 1 futures (chunks) ... DONE
[17:45:38.764] Reducing values from 1 chunks ...
[17:45:38.764]  - Number of values collected after concatenation: 2
[17:45:38.764]  - Number of values expected: 2
[17:45:38.764] Reducing values from 1 chunks ... DONE
[17:45:38.765] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:45:38.765] future_lapply() ...
[17:45:38.769] Number of chunks: 1
[17:45:38.769] getGlobalsAndPackagesXApply() ...
[17:45:38.769]  - future.globals: TRUE
[17:45:38.769] getGlobalsAndPackages() ...
[17:45:38.769] Searching for globals...
[17:45:38.770] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:38.771] Searching for globals ... DONE
[17:45:38.771] Resolving globals: FALSE
[17:45:38.771] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:38.771] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:38.772] - globals: [1] ‘FUN’
[17:45:38.772] 
[17:45:38.772] getGlobalsAndPackages() ... DONE
[17:45:38.772]  - globals found/used: [n=1] ‘FUN’
[17:45:38.772]  - needed namespaces: [n=0] 
[17:45:38.772] Finding globals ... DONE
[17:45:38.772]  - use_args: TRUE
[17:45:38.772]  - Getting '...' globals ...
[17:45:38.773] resolve() on list ...
[17:45:38.773]  recursive: 0
[17:45:38.773]  length: 1
[17:45:38.773]  elements: ‘...’
[17:45:38.773]  length: 0 (resolved future 1)
[17:45:38.773] resolve() on list ... DONE
[17:45:38.773]    - '...' content: [n=0] 
[17:45:38.773] List of 1
[17:45:38.773]  $ ...: list()
[17:45:38.773]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:38.773]  - attr(*, "where")=List of 1
[17:45:38.773]   ..$ ...:<environment: 0x55f6c60024f8> 
[17:45:38.773]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:38.773]  - attr(*, "resolved")= logi TRUE
[17:45:38.773]  - attr(*, "total_size")= num NA
[17:45:38.776]  - Getting '...' globals ... DONE
[17:45:38.776] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:38.776] List of 2
[17:45:38.776]  $ ...future.FUN:function (x)  
[17:45:38.776]  $ ...          : list()
[17:45:38.776]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:38.776]  - attr(*, "where")=List of 2
[17:45:38.776]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:38.776]   ..$ ...          :<environment: 0x55f6c60024f8> 
[17:45:38.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:38.776]  - attr(*, "resolved")= logi FALSE
[17:45:38.776]  - attr(*, "total_size")= num 4720
[17:45:38.779] Packages to be attached in all futures: [n=0] 
[17:45:38.779] getGlobalsAndPackagesXApply() ... DONE
[17:45:38.779] Number of futures (= number of chunks): 1
[17:45:38.779] Launching 1 futures (chunks) ...
[17:45:38.779] Chunk #1 of 1 ...
[17:45:38.779]  - Finding globals in 'X' for chunk #1 ...
[17:45:38.779] getGlobalsAndPackages() ...
[17:45:38.779] Searching for globals...
[17:45:38.780] 
[17:45:38.780] Searching for globals ... DONE
[17:45:38.780] - globals: [0] <none>
[17:45:38.780] getGlobalsAndPackages() ... DONE
[17:45:38.780]    + additional globals found: [n=0] 
[17:45:38.780]    + additional namespaces needed: [n=0] 
[17:45:38.780]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:38.780]  - seeds: <none>
[17:45:38.780]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:38.781] getGlobalsAndPackages() ...
[17:45:38.781] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:38.781] Resolving globals: FALSE
[17:45:38.781] Tweak future expression to call with '...' arguments ...
[17:45:38.781] {
[17:45:38.781]     do.call(function(...) {
[17:45:38.781]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:38.781]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:38.781]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:38.781]             on.exit(options(oopts), add = TRUE)
[17:45:38.781]         }
[17:45:38.781]         {
[17:45:38.781]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:38.781]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:38.781]                 ...future.FUN(...future.X_jj, ...)
[17:45:38.781]             })
[17:45:38.781]         }
[17:45:38.781]     }, args = future.call.arguments)
[17:45:38.781] }
[17:45:38.781] Tweak future expression to call with '...' arguments ... DONE
[17:45:38.782] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:38.782] 
[17:45:38.782] getGlobalsAndPackages() ... DONE
[17:45:38.782] run() for ‘Future’ ...
[17:45:38.782] - state: ‘created’
[17:45:38.782] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:38.787] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:38.787] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:38.788]   - Field: ‘label’
[17:45:38.788]   - Field: ‘local’
[17:45:38.788]   - Field: ‘owner’
[17:45:38.788]   - Field: ‘envir’
[17:45:38.788]   - Field: ‘packages’
[17:45:38.788]   - Field: ‘gc’
[17:45:38.788]   - Field: ‘conditions’
[17:45:38.788]   - Field: ‘expr’
[17:45:38.788]   - Field: ‘uuid’
[17:45:38.789]   - Field: ‘seed’
[17:45:38.789]   - Field: ‘version’
[17:45:38.789]   - Field: ‘result’
[17:45:38.789]   - Field: ‘asynchronous’
[17:45:38.789]   - Field: ‘calls’
[17:45:38.789]   - Field: ‘globals’
[17:45:38.789]   - Field: ‘stdout’
[17:45:38.789]   - Field: ‘earlySignal’
[17:45:38.789]   - Field: ‘lazy’
[17:45:38.789]   - Field: ‘state’
[17:45:38.790] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:38.790] - Launch lazy future ...
[17:45:38.790] Packages needed by the future expression (n = 0): <none>
[17:45:38.790] Packages needed by future strategies (n = 0): <none>
[17:45:38.790] {
[17:45:38.790]     {
[17:45:38.790]         {
[17:45:38.790]             ...future.startTime <- base::Sys.time()
[17:45:38.790]             {
[17:45:38.790]                 {
[17:45:38.790]                   {
[17:45:38.790]                     base::local({
[17:45:38.790]                       has_future <- base::requireNamespace("future", 
[17:45:38.790]                         quietly = TRUE)
[17:45:38.790]                       if (has_future) {
[17:45:38.790]                         ns <- base::getNamespace("future")
[17:45:38.790]                         version <- ns[[".package"]][["version"]]
[17:45:38.790]                         if (is.null(version)) 
[17:45:38.790]                           version <- utils::packageVersion("future")
[17:45:38.790]                       }
[17:45:38.790]                       else {
[17:45:38.790]                         version <- NULL
[17:45:38.790]                       }
[17:45:38.790]                       if (!has_future || version < "1.8.0") {
[17:45:38.790]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:38.790]                           "", base::R.version$version.string), 
[17:45:38.790]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:38.790]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:38.790]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:38.790]                             "release", "version")], collapse = " "), 
[17:45:38.790]                           hostname = base::Sys.info()[["nodename"]])
[17:45:38.790]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:38.790]                           info)
[17:45:38.790]                         info <- base::paste(info, collapse = "; ")
[17:45:38.790]                         if (!has_future) {
[17:45:38.790]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:38.790]                             info)
[17:45:38.790]                         }
[17:45:38.790]                         else {
[17:45:38.790]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:38.790]                             info, version)
[17:45:38.790]                         }
[17:45:38.790]                         base::stop(msg)
[17:45:38.790]                       }
[17:45:38.790]                     })
[17:45:38.790]                   }
[17:45:38.790]                   ...future.strategy.old <- future::plan("list")
[17:45:38.790]                   options(future.plan = NULL)
[17:45:38.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:38.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:38.790]                 }
[17:45:38.790]                 ...future.workdir <- getwd()
[17:45:38.790]             }
[17:45:38.790]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:38.790]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:38.790]         }
[17:45:38.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:38.790]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:38.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:38.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:38.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:38.790]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:38.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:38.790]             base::names(...future.oldOptions))
[17:45:38.790]     }
[17:45:38.790]     if (FALSE) {
[17:45:38.790]     }
[17:45:38.790]     else {
[17:45:38.790]         if (TRUE) {
[17:45:38.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:38.790]                 open = "w")
[17:45:38.790]         }
[17:45:38.790]         else {
[17:45:38.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:38.790]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:38.790]         }
[17:45:38.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:38.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:38.790]             base::sink(type = "output", split = FALSE)
[17:45:38.790]             base::close(...future.stdout)
[17:45:38.790]         }, add = TRUE)
[17:45:38.790]     }
[17:45:38.790]     ...future.frame <- base::sys.nframe()
[17:45:38.790]     ...future.conditions <- base::list()
[17:45:38.790]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:38.790]     if (FALSE) {
[17:45:38.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:38.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:38.790]     }
[17:45:38.790]     ...future.result <- base::tryCatch({
[17:45:38.790]         base::withCallingHandlers({
[17:45:38.790]             ...future.value <- base::withVisible(base::local({
[17:45:38.790]                 do.call(function(...) {
[17:45:38.790]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:38.790]                   if (!identical(...future.globals.maxSize.org, 
[17:45:38.790]                     ...future.globals.maxSize)) {
[17:45:38.790]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:38.790]                     on.exit(options(oopts), add = TRUE)
[17:45:38.790]                   }
[17:45:38.790]                   {
[17:45:38.790]                     lapply(seq_along(...future.elements_ii), 
[17:45:38.790]                       FUN = function(jj) {
[17:45:38.790]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:38.790]                         ...future.FUN(...future.X_jj, ...)
[17:45:38.790]                       })
[17:45:38.790]                   }
[17:45:38.790]                 }, args = future.call.arguments)
[17:45:38.790]             }))
[17:45:38.790]             future::FutureResult(value = ...future.value$value, 
[17:45:38.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:38.790]                   ...future.rng), globalenv = if (FALSE) 
[17:45:38.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:38.790]                     ...future.globalenv.names))
[17:45:38.790]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:38.790]         }, condition = base::local({
[17:45:38.790]             c <- base::c
[17:45:38.790]             inherits <- base::inherits
[17:45:38.790]             invokeRestart <- base::invokeRestart
[17:45:38.790]             length <- base::length
[17:45:38.790]             list <- base::list
[17:45:38.790]             seq.int <- base::seq.int
[17:45:38.790]             signalCondition <- base::signalCondition
[17:45:38.790]             sys.calls <- base::sys.calls
[17:45:38.790]             `[[` <- base::`[[`
[17:45:38.790]             `+` <- base::`+`
[17:45:38.790]             `<<-` <- base::`<<-`
[17:45:38.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:38.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:38.790]                   3L)]
[17:45:38.790]             }
[17:45:38.790]             function(cond) {
[17:45:38.790]                 is_error <- inherits(cond, "error")
[17:45:38.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:38.790]                   NULL)
[17:45:38.790]                 if (is_error) {
[17:45:38.790]                   sessionInformation <- function() {
[17:45:38.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:38.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:38.790]                       search = base::search(), system = base::Sys.info())
[17:45:38.790]                   }
[17:45:38.790]                   ...future.conditions[[length(...future.conditions) + 
[17:45:38.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:38.790]                     cond$call), session = sessionInformation(), 
[17:45:38.790]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:38.790]                   signalCondition(cond)
[17:45:38.790]                 }
[17:45:38.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:38.790]                 "immediateCondition"))) {
[17:45:38.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:38.790]                   ...future.conditions[[length(...future.conditions) + 
[17:45:38.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:38.790]                   if (TRUE && !signal) {
[17:45:38.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:38.790]                     {
[17:45:38.790]                       inherits <- base::inherits
[17:45:38.790]                       invokeRestart <- base::invokeRestart
[17:45:38.790]                       is.null <- base::is.null
[17:45:38.790]                       muffled <- FALSE
[17:45:38.790]                       if (inherits(cond, "message")) {
[17:45:38.790]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:38.790]                         if (muffled) 
[17:45:38.790]                           invokeRestart("muffleMessage")
[17:45:38.790]                       }
[17:45:38.790]                       else if (inherits(cond, "warning")) {
[17:45:38.790]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:38.790]                         if (muffled) 
[17:45:38.790]                           invokeRestart("muffleWarning")
[17:45:38.790]                       }
[17:45:38.790]                       else if (inherits(cond, "condition")) {
[17:45:38.790]                         if (!is.null(pattern)) {
[17:45:38.790]                           computeRestarts <- base::computeRestarts
[17:45:38.790]                           grepl <- base::grepl
[17:45:38.790]                           restarts <- computeRestarts(cond)
[17:45:38.790]                           for (restart in restarts) {
[17:45:38.790]                             name <- restart$name
[17:45:38.790]                             if (is.null(name)) 
[17:45:38.790]                               next
[17:45:38.790]                             if (!grepl(pattern, name)) 
[17:45:38.790]                               next
[17:45:38.790]                             invokeRestart(restart)
[17:45:38.790]                             muffled <- TRUE
[17:45:38.790]                             break
[17:45:38.790]                           }
[17:45:38.790]                         }
[17:45:38.790]                       }
[17:45:38.790]                       invisible(muffled)
[17:45:38.790]                     }
[17:45:38.790]                     muffleCondition(cond, pattern = "^muffle")
[17:45:38.790]                   }
[17:45:38.790]                 }
[17:45:38.790]                 else {
[17:45:38.790]                   if (TRUE) {
[17:45:38.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:38.790]                     {
[17:45:38.790]                       inherits <- base::inherits
[17:45:38.790]                       invokeRestart <- base::invokeRestart
[17:45:38.790]                       is.null <- base::is.null
[17:45:38.790]                       muffled <- FALSE
[17:45:38.790]                       if (inherits(cond, "message")) {
[17:45:38.790]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:38.790]                         if (muffled) 
[17:45:38.790]                           invokeRestart("muffleMessage")
[17:45:38.790]                       }
[17:45:38.790]                       else if (inherits(cond, "warning")) {
[17:45:38.790]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:38.790]                         if (muffled) 
[17:45:38.790]                           invokeRestart("muffleWarning")
[17:45:38.790]                       }
[17:45:38.790]                       else if (inherits(cond, "condition")) {
[17:45:38.790]                         if (!is.null(pattern)) {
[17:45:38.790]                           computeRestarts <- base::computeRestarts
[17:45:38.790]                           grepl <- base::grepl
[17:45:38.790]                           restarts <- computeRestarts(cond)
[17:45:38.790]                           for (restart in restarts) {
[17:45:38.790]                             name <- restart$name
[17:45:38.790]                             if (is.null(name)) 
[17:45:38.790]                               next
[17:45:38.790]                             if (!grepl(pattern, name)) 
[17:45:38.790]                               next
[17:45:38.790]                             invokeRestart(restart)
[17:45:38.790]                             muffled <- TRUE
[17:45:38.790]                             break
[17:45:38.790]                           }
[17:45:38.790]                         }
[17:45:38.790]                       }
[17:45:38.790]                       invisible(muffled)
[17:45:38.790]                     }
[17:45:38.790]                     muffleCondition(cond, pattern = "^muffle")
[17:45:38.790]                   }
[17:45:38.790]                 }
[17:45:38.790]             }
[17:45:38.790]         }))
[17:45:38.790]     }, error = function(ex) {
[17:45:38.790]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:38.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:38.790]                 ...future.rng), started = ...future.startTime, 
[17:45:38.790]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:38.790]             version = "1.8"), class = "FutureResult")
[17:45:38.790]     }, finally = {
[17:45:38.790]         if (!identical(...future.workdir, getwd())) 
[17:45:38.790]             setwd(...future.workdir)
[17:45:38.790]         {
[17:45:38.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:38.790]                 ...future.oldOptions$nwarnings <- NULL
[17:45:38.790]             }
[17:45:38.790]             base::options(...future.oldOptions)
[17:45:38.790]             if (.Platform$OS.type == "windows") {
[17:45:38.790]                 old_names <- names(...future.oldEnvVars)
[17:45:38.790]                 envs <- base::Sys.getenv()
[17:45:38.790]                 names <- names(envs)
[17:45:38.790]                 common <- intersect(names, old_names)
[17:45:38.790]                 added <- setdiff(names, old_names)
[17:45:38.790]                 removed <- setdiff(old_names, names)
[17:45:38.790]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:38.790]                   envs[common]]
[17:45:38.790]                 NAMES <- toupper(changed)
[17:45:38.790]                 args <- list()
[17:45:38.790]                 for (kk in seq_along(NAMES)) {
[17:45:38.790]                   name <- changed[[kk]]
[17:45:38.790]                   NAME <- NAMES[[kk]]
[17:45:38.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:38.790]                     next
[17:45:38.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:38.790]                 }
[17:45:38.790]                 NAMES <- toupper(added)
[17:45:38.790]                 for (kk in seq_along(NAMES)) {
[17:45:38.790]                   name <- added[[kk]]
[17:45:38.790]                   NAME <- NAMES[[kk]]
[17:45:38.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:38.790]                     next
[17:45:38.790]                   args[[name]] <- ""
[17:45:38.790]                 }
[17:45:38.790]                 NAMES <- toupper(removed)
[17:45:38.790]                 for (kk in seq_along(NAMES)) {
[17:45:38.790]                   name <- removed[[kk]]
[17:45:38.790]                   NAME <- NAMES[[kk]]
[17:45:38.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:38.790]                     next
[17:45:38.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:38.790]                 }
[17:45:38.790]                 if (length(args) > 0) 
[17:45:38.790]                   base::do.call(base::Sys.setenv, args = args)
[17:45:38.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:38.790]             }
[17:45:38.790]             else {
[17:45:38.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:38.790]             }
[17:45:38.790]             {
[17:45:38.790]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:38.790]                   0L) {
[17:45:38.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:38.790]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:38.790]                   base::options(opts)
[17:45:38.790]                 }
[17:45:38.790]                 {
[17:45:38.790]                   {
[17:45:38.790]                     NULL
[17:45:38.790]                     RNGkind("Mersenne-Twister")
[17:45:38.790]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:38.790]                       inherits = FALSE)
[17:45:38.790]                   }
[17:45:38.790]                   options(future.plan = NULL)
[17:45:38.790]                   if (is.na(NA_character_)) 
[17:45:38.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:38.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:38.790]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:38.790]                     .init = FALSE)
[17:45:38.790]                 }
[17:45:38.790]             }
[17:45:38.790]         }
[17:45:38.790]     })
[17:45:38.790]     if (TRUE) {
[17:45:38.790]         base::sink(type = "output", split = FALSE)
[17:45:38.790]         if (TRUE) {
[17:45:38.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:38.790]         }
[17:45:38.790]         else {
[17:45:38.790]             ...future.result["stdout"] <- base::list(NULL)
[17:45:38.790]         }
[17:45:38.790]         base::close(...future.stdout)
[17:45:38.790]         ...future.stdout <- NULL
[17:45:38.790]     }
[17:45:38.790]     ...future.result$conditions <- ...future.conditions
[17:45:38.790]     ...future.result$finished <- base::Sys.time()
[17:45:38.790]     ...future.result
[17:45:38.790] }
[17:45:38.792] assign_globals() ...
[17:45:38.792] List of 5
[17:45:38.792]  $ ...future.FUN            :function (x)  
[17:45:38.792]  $ future.call.arguments    : list()
[17:45:38.792]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:38.792]  $ ...future.elements_ii    :List of 2
[17:45:38.792]   ..$ : int 1
[17:45:38.792]   ..$ : int 0
[17:45:38.792]  $ ...future.seeds_ii       : NULL
[17:45:38.792]  $ ...future.globals.maxSize: NULL
[17:45:38.792]  - attr(*, "where")=List of 5
[17:45:38.792]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:38.792]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:38.792]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:38.792]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:38.792]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:38.792]  - attr(*, "resolved")= logi FALSE
[17:45:38.792]  - attr(*, "total_size")= num 4720
[17:45:38.792]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:38.792]  - attr(*, "already-done")= logi TRUE
[17:45:38.797] - reassign environment for ‘...future.FUN’
[17:45:38.797] - copied ‘...future.FUN’ to environment
[17:45:38.797] - copied ‘future.call.arguments’ to environment
[17:45:38.797] - copied ‘...future.elements_ii’ to environment
[17:45:38.797] - copied ‘...future.seeds_ii’ to environment
[17:45:38.797] - copied ‘...future.globals.maxSize’ to environment
[17:45:38.797] assign_globals() ... done
[17:45:38.798] plan(): Setting new future strategy stack:
[17:45:38.798] List of future strategies:
[17:45:38.798] 1. sequential:
[17:45:38.798]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:38.798]    - tweaked: FALSE
[17:45:38.798]    - call: NULL
[17:45:38.798] plan(): nbrOfWorkers() = 1
[17:45:39.300] plan(): Setting new future strategy stack:
[17:45:39.300] List of future strategies:
[17:45:39.300] 1. multisession:
[17:45:39.300]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:45:39.300]    - tweaked: FALSE
[17:45:39.300]    - call: plan(strategy)
[17:45:39.304] plan(): nbrOfWorkers() = 1
[17:45:39.304] SequentialFuture started (and completed)
[17:45:39.304] - Launch lazy future ... done
[17:45:39.304] run() for ‘SequentialFuture’ ... done
[17:45:39.305] Created future:
[17:45:39.305] SequentialFuture:
[17:45:39.305] Label: ‘future_lapply-1’
[17:45:39.305] Expression:
[17:45:39.305] {
[17:45:39.305]     do.call(function(...) {
[17:45:39.305]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:39.305]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:39.305]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:39.305]             on.exit(options(oopts), add = TRUE)
[17:45:39.305]         }
[17:45:39.305]         {
[17:45:39.305]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:39.305]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:39.305]                 ...future.FUN(...future.X_jj, ...)
[17:45:39.305]             })
[17:45:39.305]         }
[17:45:39.305]     }, args = future.call.arguments)
[17:45:39.305] }
[17:45:39.305] Lazy evaluation: FALSE
[17:45:39.305] Asynchronous evaluation: FALSE
[17:45:39.305] Local evaluation: TRUE
[17:45:39.305] Environment: R_GlobalEnv
[17:45:39.305] Capture standard output: TRUE
[17:45:39.305] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:39.305] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:39.305] Packages: <none>
[17:45:39.305] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:39.305] Resolved: TRUE
[17:45:39.305] Value: 112 bytes of class ‘list’
[17:45:39.305] Early signaling: FALSE
[17:45:39.305] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:39.305] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:39.306] Chunk #1 of 1 ... DONE
[17:45:39.306] Launching 1 futures (chunks) ... DONE
[17:45:39.306] Resolving 1 futures (chunks) ...
[17:45:39.306] resolve() on list ...
[17:45:39.306]  recursive: 0
[17:45:39.306]  length: 1
[17:45:39.306] 
[17:45:39.306] resolved() for ‘SequentialFuture’ ...
[17:45:39.306] - state: ‘finished’
[17:45:39.307] - run: TRUE
[17:45:39.307] - result: ‘FutureResult’
[17:45:39.307] resolved() for ‘SequentialFuture’ ... done
[17:45:39.307] Future #1
[17:45:39.307] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:39.307] - nx: 1
[17:45:39.307] - relay: TRUE
[17:45:39.307] - stdout: TRUE
[17:45:39.307] - signal: TRUE
[17:45:39.307] - resignal: FALSE
[17:45:39.307] - force: TRUE
[17:45:39.308] - relayed: [n=1] FALSE
[17:45:39.308] - queued futures: [n=1] FALSE
[17:45:39.308]  - until=1
[17:45:39.308]  - relaying element #1
[17:45:39.308] - relayed: [n=1] TRUE
[17:45:39.308] - queued futures: [n=1] TRUE
[17:45:39.308] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:39.308]  length: 0 (resolved future 1)
[17:45:39.308] Relaying remaining futures
[17:45:39.309] signalConditionsASAP(NULL, pos=0) ...
[17:45:39.309] - nx: 1
[17:45:39.309] - relay: TRUE
[17:45:39.309] - stdout: TRUE
[17:45:39.309] - signal: TRUE
[17:45:39.309] - resignal: FALSE
[17:45:39.309] - force: TRUE
[17:45:39.309] - relayed: [n=1] TRUE
[17:45:39.309] - queued futures: [n=1] TRUE
 - flush all
[17:45:39.309] - relayed: [n=1] TRUE
[17:45:39.309] - queued futures: [n=1] TRUE
[17:45:39.310] signalConditionsASAP(NULL, pos=0) ... done
[17:45:39.310] resolve() on list ... DONE
[17:45:39.310]  - Number of value chunks collected: 1
[17:45:39.310] Resolving 1 futures (chunks) ... DONE
[17:45:39.310] Reducing values from 1 chunks ...
[17:45:39.310]  - Number of values collected after concatenation: 2
[17:45:39.310]  - Number of values expected: 2
[17:45:39.310] Reducing values from 1 chunks ... DONE
[17:45:39.310] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:45:39.311] future_lapply() ...
[17:45:39.314] Number of chunks: 1
[17:45:39.314] getGlobalsAndPackagesXApply() ...
[17:45:39.314]  - future.globals: TRUE
[17:45:39.315] getGlobalsAndPackages() ...
[17:45:39.315] Searching for globals...
[17:45:39.316] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:39.316] Searching for globals ... DONE
[17:45:39.316] Resolving globals: FALSE
[17:45:39.317] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:39.317] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:39.317] - globals: [1] ‘FUN’
[17:45:39.317] 
[17:45:39.317] getGlobalsAndPackages() ... DONE
[17:45:39.317]  - globals found/used: [n=1] ‘FUN’
[17:45:39.318]  - needed namespaces: [n=0] 
[17:45:39.318] Finding globals ... DONE
[17:45:39.318]  - use_args: TRUE
[17:45:39.318]  - Getting '...' globals ...
[17:45:39.318] resolve() on list ...
[17:45:39.318]  recursive: 0
[17:45:39.318]  length: 1
[17:45:39.318]  elements: ‘...’
[17:45:39.319]  length: 0 (resolved future 1)
[17:45:39.319] resolve() on list ... DONE
[17:45:39.320]    - '...' content: [n=0] 
[17:45:39.320] List of 1
[17:45:39.320]  $ ...: list()
[17:45:39.320]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:39.320]  - attr(*, "where")=List of 1
[17:45:39.320]   ..$ ...:<environment: 0x55f6c74d9690> 
[17:45:39.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:39.320]  - attr(*, "resolved")= logi TRUE
[17:45:39.320]  - attr(*, "total_size")= num NA
[17:45:39.323]  - Getting '...' globals ... DONE
[17:45:39.323] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:39.323] List of 2
[17:45:39.323]  $ ...future.FUN:function (x)  
[17:45:39.323]  $ ...          : list()
[17:45:39.323]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:39.323]  - attr(*, "where")=List of 2
[17:45:39.323]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:39.323]   ..$ ...          :<environment: 0x55f6c74d9690> 
[17:45:39.323]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:39.323]  - attr(*, "resolved")= logi FALSE
[17:45:39.323]  - attr(*, "total_size")= num 4720
[17:45:39.326] Packages to be attached in all futures: [n=0] 
[17:45:39.326] getGlobalsAndPackagesXApply() ... DONE
[17:45:39.326] Number of futures (= number of chunks): 1
[17:45:39.326] Launching 1 futures (chunks) ...
[17:45:39.327] Chunk #1 of 1 ...
[17:45:39.327]  - Finding globals in 'X' for chunk #1 ...
[17:45:39.327] getGlobalsAndPackages() ...
[17:45:39.327] Searching for globals...
[17:45:39.327] 
[17:45:39.327] Searching for globals ... DONE
[17:45:39.327] - globals: [0] <none>
[17:45:39.327] getGlobalsAndPackages() ... DONE
[17:45:39.328]    + additional globals found: [n=0] 
[17:45:39.328]    + additional namespaces needed: [n=0] 
[17:45:39.328]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:39.328]  - seeds: <none>
[17:45:39.328]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:39.328] getGlobalsAndPackages() ...
[17:45:39.328] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:39.328] Resolving globals: FALSE
[17:45:39.328] Tweak future expression to call with '...' arguments ...
[17:45:39.328] {
[17:45:39.328]     do.call(function(...) {
[17:45:39.328]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:39.328]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:39.328]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:39.328]             on.exit(options(oopts), add = TRUE)
[17:45:39.328]         }
[17:45:39.328]         {
[17:45:39.328]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:39.328]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:39.328]                 ...future.FUN(...future.X_jj, ...)
[17:45:39.328]             })
[17:45:39.328]         }
[17:45:39.328]     }, args = future.call.arguments)
[17:45:39.328] }
[17:45:39.329] Tweak future expression to call with '...' arguments ... DONE
[17:45:39.329] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:39.329] 
[17:45:39.329] getGlobalsAndPackages() ... DONE
[17:45:39.330] run() for ‘Future’ ...
[17:45:39.330] - state: ‘created’
[17:45:39.330] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:39.333] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:39.333] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:39.333]   - Field: ‘label’
[17:45:39.334]   - Field: ‘local’
[17:45:39.334]   - Field: ‘owner’
[17:45:39.334]   - Field: ‘envir’
[17:45:39.334]   - Field: ‘packages’
[17:45:39.334]   - Field: ‘gc’
[17:45:39.334]   - Field: ‘conditions’
[17:45:39.334]   - Field: ‘expr’
[17:45:39.334]   - Field: ‘uuid’
[17:45:39.334]   - Field: ‘seed’
[17:45:39.334]   - Field: ‘version’
[17:45:39.335]   - Field: ‘result’
[17:45:39.335]   - Field: ‘asynchronous’
[17:45:39.335]   - Field: ‘calls’
[17:45:39.335]   - Field: ‘globals’
[17:45:39.335]   - Field: ‘stdout’
[17:45:39.335]   - Field: ‘earlySignal’
[17:45:39.335]   - Field: ‘lazy’
[17:45:39.335]   - Field: ‘state’
[17:45:39.335] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:39.336] - Launch lazy future ...
[17:45:39.336] Packages needed by the future expression (n = 0): <none>
[17:45:39.336] Packages needed by future strategies (n = 0): <none>
[17:45:39.336] {
[17:45:39.336]     {
[17:45:39.336]         {
[17:45:39.336]             ...future.startTime <- base::Sys.time()
[17:45:39.336]             {
[17:45:39.336]                 {
[17:45:39.336]                   {
[17:45:39.336]                     base::local({
[17:45:39.336]                       has_future <- base::requireNamespace("future", 
[17:45:39.336]                         quietly = TRUE)
[17:45:39.336]                       if (has_future) {
[17:45:39.336]                         ns <- base::getNamespace("future")
[17:45:39.336]                         version <- ns[[".package"]][["version"]]
[17:45:39.336]                         if (is.null(version)) 
[17:45:39.336]                           version <- utils::packageVersion("future")
[17:45:39.336]                       }
[17:45:39.336]                       else {
[17:45:39.336]                         version <- NULL
[17:45:39.336]                       }
[17:45:39.336]                       if (!has_future || version < "1.8.0") {
[17:45:39.336]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:39.336]                           "", base::R.version$version.string), 
[17:45:39.336]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:39.336]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:39.336]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:39.336]                             "release", "version")], collapse = " "), 
[17:45:39.336]                           hostname = base::Sys.info()[["nodename"]])
[17:45:39.336]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:39.336]                           info)
[17:45:39.336]                         info <- base::paste(info, collapse = "; ")
[17:45:39.336]                         if (!has_future) {
[17:45:39.336]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:39.336]                             info)
[17:45:39.336]                         }
[17:45:39.336]                         else {
[17:45:39.336]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:39.336]                             info, version)
[17:45:39.336]                         }
[17:45:39.336]                         base::stop(msg)
[17:45:39.336]                       }
[17:45:39.336]                     })
[17:45:39.336]                   }
[17:45:39.336]                   ...future.strategy.old <- future::plan("list")
[17:45:39.336]                   options(future.plan = NULL)
[17:45:39.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:39.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:39.336]                 }
[17:45:39.336]                 ...future.workdir <- getwd()
[17:45:39.336]             }
[17:45:39.336]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:39.336]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:39.336]         }
[17:45:39.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:39.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:39.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:39.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:39.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:39.336]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:39.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:39.336]             base::names(...future.oldOptions))
[17:45:39.336]     }
[17:45:39.336]     if (TRUE) {
[17:45:39.336]     }
[17:45:39.336]     else {
[17:45:39.336]         if (NA) {
[17:45:39.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:39.336]                 open = "w")
[17:45:39.336]         }
[17:45:39.336]         else {
[17:45:39.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:39.336]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:39.336]         }
[17:45:39.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:39.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:39.336]             base::sink(type = "output", split = FALSE)
[17:45:39.336]             base::close(...future.stdout)
[17:45:39.336]         }, add = TRUE)
[17:45:39.336]     }
[17:45:39.336]     ...future.frame <- base::sys.nframe()
[17:45:39.336]     ...future.conditions <- base::list()
[17:45:39.336]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:39.336]     if (FALSE) {
[17:45:39.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:39.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:39.336]     }
[17:45:39.336]     ...future.result <- base::tryCatch({
[17:45:39.336]         base::withCallingHandlers({
[17:45:39.336]             ...future.value <- base::withVisible(base::local({
[17:45:39.336]                 do.call(function(...) {
[17:45:39.336]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:39.336]                   if (!identical(...future.globals.maxSize.org, 
[17:45:39.336]                     ...future.globals.maxSize)) {
[17:45:39.336]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:39.336]                     on.exit(options(oopts), add = TRUE)
[17:45:39.336]                   }
[17:45:39.336]                   {
[17:45:39.336]                     lapply(seq_along(...future.elements_ii), 
[17:45:39.336]                       FUN = function(jj) {
[17:45:39.336]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:39.336]                         ...future.FUN(...future.X_jj, ...)
[17:45:39.336]                       })
[17:45:39.336]                   }
[17:45:39.336]                 }, args = future.call.arguments)
[17:45:39.336]             }))
[17:45:39.336]             future::FutureResult(value = ...future.value$value, 
[17:45:39.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:39.336]                   ...future.rng), globalenv = if (FALSE) 
[17:45:39.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:39.336]                     ...future.globalenv.names))
[17:45:39.336]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:39.336]         }, condition = base::local({
[17:45:39.336]             c <- base::c
[17:45:39.336]             inherits <- base::inherits
[17:45:39.336]             invokeRestart <- base::invokeRestart
[17:45:39.336]             length <- base::length
[17:45:39.336]             list <- base::list
[17:45:39.336]             seq.int <- base::seq.int
[17:45:39.336]             signalCondition <- base::signalCondition
[17:45:39.336]             sys.calls <- base::sys.calls
[17:45:39.336]             `[[` <- base::`[[`
[17:45:39.336]             `+` <- base::`+`
[17:45:39.336]             `<<-` <- base::`<<-`
[17:45:39.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:39.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:39.336]                   3L)]
[17:45:39.336]             }
[17:45:39.336]             function(cond) {
[17:45:39.336]                 is_error <- inherits(cond, "error")
[17:45:39.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:39.336]                   NULL)
[17:45:39.336]                 if (is_error) {
[17:45:39.336]                   sessionInformation <- function() {
[17:45:39.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:39.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:39.336]                       search = base::search(), system = base::Sys.info())
[17:45:39.336]                   }
[17:45:39.336]                   ...future.conditions[[length(...future.conditions) + 
[17:45:39.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:39.336]                     cond$call), session = sessionInformation(), 
[17:45:39.336]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:39.336]                   signalCondition(cond)
[17:45:39.336]                 }
[17:45:39.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:39.336]                 "immediateCondition"))) {
[17:45:39.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:39.336]                   ...future.conditions[[length(...future.conditions) + 
[17:45:39.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:39.336]                   if (TRUE && !signal) {
[17:45:39.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:39.336]                     {
[17:45:39.336]                       inherits <- base::inherits
[17:45:39.336]                       invokeRestart <- base::invokeRestart
[17:45:39.336]                       is.null <- base::is.null
[17:45:39.336]                       muffled <- FALSE
[17:45:39.336]                       if (inherits(cond, "message")) {
[17:45:39.336]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:39.336]                         if (muffled) 
[17:45:39.336]                           invokeRestart("muffleMessage")
[17:45:39.336]                       }
[17:45:39.336]                       else if (inherits(cond, "warning")) {
[17:45:39.336]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:39.336]                         if (muffled) 
[17:45:39.336]                           invokeRestart("muffleWarning")
[17:45:39.336]                       }
[17:45:39.336]                       else if (inherits(cond, "condition")) {
[17:45:39.336]                         if (!is.null(pattern)) {
[17:45:39.336]                           computeRestarts <- base::computeRestarts
[17:45:39.336]                           grepl <- base::grepl
[17:45:39.336]                           restarts <- computeRestarts(cond)
[17:45:39.336]                           for (restart in restarts) {
[17:45:39.336]                             name <- restart$name
[17:45:39.336]                             if (is.null(name)) 
[17:45:39.336]                               next
[17:45:39.336]                             if (!grepl(pattern, name)) 
[17:45:39.336]                               next
[17:45:39.336]                             invokeRestart(restart)
[17:45:39.336]                             muffled <- TRUE
[17:45:39.336]                             break
[17:45:39.336]                           }
[17:45:39.336]                         }
[17:45:39.336]                       }
[17:45:39.336]                       invisible(muffled)
[17:45:39.336]                     }
[17:45:39.336]                     muffleCondition(cond, pattern = "^muffle")
[17:45:39.336]                   }
[17:45:39.336]                 }
[17:45:39.336]                 else {
[17:45:39.336]                   if (TRUE) {
[17:45:39.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:39.336]                     {
[17:45:39.336]                       inherits <- base::inherits
[17:45:39.336]                       invokeRestart <- base::invokeRestart
[17:45:39.336]                       is.null <- base::is.null
[17:45:39.336]                       muffled <- FALSE
[17:45:39.336]                       if (inherits(cond, "message")) {
[17:45:39.336]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:39.336]                         if (muffled) 
[17:45:39.336]                           invokeRestart("muffleMessage")
[17:45:39.336]                       }
[17:45:39.336]                       else if (inherits(cond, "warning")) {
[17:45:39.336]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:39.336]                         if (muffled) 
[17:45:39.336]                           invokeRestart("muffleWarning")
[17:45:39.336]                       }
[17:45:39.336]                       else if (inherits(cond, "condition")) {
[17:45:39.336]                         if (!is.null(pattern)) {
[17:45:39.336]                           computeRestarts <- base::computeRestarts
[17:45:39.336]                           grepl <- base::grepl
[17:45:39.336]                           restarts <- computeRestarts(cond)
[17:45:39.336]                           for (restart in restarts) {
[17:45:39.336]                             name <- restart$name
[17:45:39.336]                             if (is.null(name)) 
[17:45:39.336]                               next
[17:45:39.336]                             if (!grepl(pattern, name)) 
[17:45:39.336]                               next
[17:45:39.336]                             invokeRestart(restart)
[17:45:39.336]                             muffled <- TRUE
[17:45:39.336]                             break
[17:45:39.336]                           }
[17:45:39.336]                         }
[17:45:39.336]                       }
[17:45:39.336]                       invisible(muffled)
[17:45:39.336]                     }
[17:45:39.336]                     muffleCondition(cond, pattern = "^muffle")
[17:45:39.336]                   }
[17:45:39.336]                 }
[17:45:39.336]             }
[17:45:39.336]         }))
[17:45:39.336]     }, error = function(ex) {
[17:45:39.336]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:39.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:39.336]                 ...future.rng), started = ...future.startTime, 
[17:45:39.336]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:39.336]             version = "1.8"), class = "FutureResult")
[17:45:39.336]     }, finally = {
[17:45:39.336]         if (!identical(...future.workdir, getwd())) 
[17:45:39.336]             setwd(...future.workdir)
[17:45:39.336]         {
[17:45:39.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:39.336]                 ...future.oldOptions$nwarnings <- NULL
[17:45:39.336]             }
[17:45:39.336]             base::options(...future.oldOptions)
[17:45:39.336]             if (.Platform$OS.type == "windows") {
[17:45:39.336]                 old_names <- names(...future.oldEnvVars)
[17:45:39.336]                 envs <- base::Sys.getenv()
[17:45:39.336]                 names <- names(envs)
[17:45:39.336]                 common <- intersect(names, old_names)
[17:45:39.336]                 added <- setdiff(names, old_names)
[17:45:39.336]                 removed <- setdiff(old_names, names)
[17:45:39.336]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:39.336]                   envs[common]]
[17:45:39.336]                 NAMES <- toupper(changed)
[17:45:39.336]                 args <- list()
[17:45:39.336]                 for (kk in seq_along(NAMES)) {
[17:45:39.336]                   name <- changed[[kk]]
[17:45:39.336]                   NAME <- NAMES[[kk]]
[17:45:39.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:39.336]                     next
[17:45:39.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:39.336]                 }
[17:45:39.336]                 NAMES <- toupper(added)
[17:45:39.336]                 for (kk in seq_along(NAMES)) {
[17:45:39.336]                   name <- added[[kk]]
[17:45:39.336]                   NAME <- NAMES[[kk]]
[17:45:39.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:39.336]                     next
[17:45:39.336]                   args[[name]] <- ""
[17:45:39.336]                 }
[17:45:39.336]                 NAMES <- toupper(removed)
[17:45:39.336]                 for (kk in seq_along(NAMES)) {
[17:45:39.336]                   name <- removed[[kk]]
[17:45:39.336]                   NAME <- NAMES[[kk]]
[17:45:39.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:39.336]                     next
[17:45:39.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:39.336]                 }
[17:45:39.336]                 if (length(args) > 0) 
[17:45:39.336]                   base::do.call(base::Sys.setenv, args = args)
[17:45:39.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:39.336]             }
[17:45:39.336]             else {
[17:45:39.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:39.336]             }
[17:45:39.336]             {
[17:45:39.336]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:39.336]                   0L) {
[17:45:39.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:39.336]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:39.336]                   base::options(opts)
[17:45:39.336]                 }
[17:45:39.336]                 {
[17:45:39.336]                   {
[17:45:39.336]                     NULL
[17:45:39.336]                     RNGkind("Mersenne-Twister")
[17:45:39.336]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:39.336]                       inherits = FALSE)
[17:45:39.336]                   }
[17:45:39.336]                   options(future.plan = NULL)
[17:45:39.336]                   if (is.na(NA_character_)) 
[17:45:39.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:39.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:39.336]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:39.336]                     .init = FALSE)
[17:45:39.336]                 }
[17:45:39.336]             }
[17:45:39.336]         }
[17:45:39.336]     })
[17:45:39.336]     if (FALSE) {
[17:45:39.336]         base::sink(type = "output", split = FALSE)
[17:45:39.336]         if (NA) {
[17:45:39.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:39.336]         }
[17:45:39.336]         else {
[17:45:39.336]             ...future.result["stdout"] <- base::list(NULL)
[17:45:39.336]         }
[17:45:39.336]         base::close(...future.stdout)
[17:45:39.336]         ...future.stdout <- NULL
[17:45:39.336]     }
[17:45:39.336]     ...future.result$conditions <- ...future.conditions
[17:45:39.336]     ...future.result$finished <- base::Sys.time()
[17:45:39.336]     ...future.result
[17:45:39.336] }
[17:45:39.338] assign_globals() ...
[17:45:39.338] List of 5
[17:45:39.338]  $ ...future.FUN            :function (x)  
[17:45:39.338]  $ future.call.arguments    : list()
[17:45:39.338]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:39.338]  $ ...future.elements_ii    :List of 2
[17:45:39.338]   ..$ : int 1
[17:45:39.338]   ..$ : int 0
[17:45:39.338]  $ ...future.seeds_ii       : NULL
[17:45:39.338]  $ ...future.globals.maxSize: NULL
[17:45:39.338]  - attr(*, "where")=List of 5
[17:45:39.338]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:39.338]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:39.338]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:39.338]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:39.338]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:39.338]  - attr(*, "resolved")= logi FALSE
[17:45:39.338]  - attr(*, "total_size")= num 4720
[17:45:39.338]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:39.338]  - attr(*, "already-done")= logi TRUE
[17:45:39.343] - reassign environment for ‘...future.FUN’
[17:45:39.343] - copied ‘...future.FUN’ to environment
[17:45:39.343] - copied ‘future.call.arguments’ to environment
[17:45:39.343] - copied ‘...future.elements_ii’ to environment
[17:45:39.343] - copied ‘...future.seeds_ii’ to environment
[17:45:39.343] - copied ‘...future.globals.maxSize’ to environment
[17:45:39.343] assign_globals() ... done
[17:45:39.344] plan(): Setting new future strategy stack:
[17:45:39.344] List of future strategies:
[17:45:39.344] 1. sequential:
[17:45:39.344]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:39.344]    - tweaked: FALSE
[17:45:39.344]    - call: NULL
[17:45:39.344] plan(): nbrOfWorkers() = 1
[17:45:39.846] plan(): Setting new future strategy stack:
[17:45:39.846] List of future strategies:
[17:45:39.846] 1. multisession:
[17:45:39.846]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:45:39.846]    - tweaked: FALSE
[17:45:39.846]    - call: plan(strategy)
[17:45:39.850] plan(): nbrOfWorkers() = 1
[17:45:39.850] SequentialFuture started (and completed)
[17:45:39.850] - Launch lazy future ... done
[17:45:39.850] run() for ‘SequentialFuture’ ... done
[17:45:39.850] Created future:
[17:45:39.850] SequentialFuture:
[17:45:39.850] Label: ‘future_lapply-1’
[17:45:39.850] Expression:
[17:45:39.850] {
[17:45:39.850]     do.call(function(...) {
[17:45:39.850]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:39.850]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:39.850]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:39.850]             on.exit(options(oopts), add = TRUE)
[17:45:39.850]         }
[17:45:39.850]         {
[17:45:39.850]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:39.850]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:39.850]                 ...future.FUN(...future.X_jj, ...)
[17:45:39.850]             })
[17:45:39.850]         }
[17:45:39.850]     }, args = future.call.arguments)
[17:45:39.850] }
[17:45:39.850] Lazy evaluation: FALSE
[17:45:39.850] Asynchronous evaluation: FALSE
[17:45:39.850] Local evaluation: TRUE
[17:45:39.850] Environment: R_GlobalEnv
[17:45:39.850] Capture standard output: NA
[17:45:39.850] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:39.850] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:39.850] Packages: <none>
[17:45:39.850] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:39.850] Resolved: TRUE
[17:45:39.850] Value: 112 bytes of class ‘list’
[17:45:39.850] Early signaling: FALSE
[17:45:39.850] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:39.850] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:39.852] Chunk #1 of 1 ... DONE
[17:45:39.852] Launching 1 futures (chunks) ... DONE
[17:45:39.852] Resolving 1 futures (chunks) ...
[17:45:39.852] resolve() on list ...
[17:45:39.852]  recursive: 0
[17:45:39.852]  length: 1
[17:45:39.852] 
[17:45:39.852] resolved() for ‘SequentialFuture’ ...
[17:45:39.852] - state: ‘finished’
[17:45:39.852] - run: TRUE
[17:45:39.853] - result: ‘FutureResult’
[17:45:39.853] resolved() for ‘SequentialFuture’ ... done
[17:45:39.853] Future #1
[17:45:39.853] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:39.853] - nx: 1
[17:45:39.853] - relay: TRUE
[17:45:39.853] - stdout: TRUE
[17:45:39.853] - signal: TRUE
[17:45:39.853] - resignal: FALSE
[17:45:39.855] - force: TRUE
[17:45:39.855] - relayed: [n=1] FALSE
[17:45:39.855] - queued futures: [n=1] FALSE
[17:45:39.855]  - until=1
[17:45:39.855]  - relaying element #1
[17:45:39.855] - relayed: [n=1] TRUE
[17:45:39.856] - queued futures: [n=1] TRUE
[17:45:39.856] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:39.856]  length: 0 (resolved future 1)
[17:45:39.856] Relaying remaining futures
[17:45:39.856] signalConditionsASAP(NULL, pos=0) ...
[17:45:39.856] - nx: 1
[17:45:39.856] - relay: TRUE
[17:45:39.856] - stdout: TRUE
[17:45:39.856] - signal: TRUE
[17:45:39.856] - resignal: FALSE
[17:45:39.857] - force: TRUE
[17:45:39.857] - relayed: [n=1] TRUE
[17:45:39.857] - queued futures: [n=1] TRUE
 - flush all
[17:45:39.857] - relayed: [n=1] TRUE
[17:45:39.857] - queued futures: [n=1] TRUE
[17:45:39.857] signalConditionsASAP(NULL, pos=0) ... done
[17:45:39.857] resolve() on list ... DONE
[17:45:39.857]  - Number of value chunks collected: 1
[17:45:39.857] Resolving 1 futures (chunks) ... DONE
[17:45:39.858] Reducing values from 1 chunks ...
[17:45:39.858]  - Number of values collected after concatenation: 2
[17:45:39.858]  - Number of values expected: 2
[17:45:39.858] Reducing values from 1 chunks ... DONE
[17:45:39.858] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:45:39.858] future_mapply() ...
[17:45:39.861] Number of chunks: 1
[17:45:39.862] getGlobalsAndPackagesXApply() ...
[17:45:39.862]  - future.globals: TRUE
[17:45:39.862] getGlobalsAndPackages() ...
[17:45:39.862] Searching for globals...
[17:45:39.863] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:39.864] Searching for globals ... DONE
[17:45:39.864] Resolving globals: FALSE
[17:45:39.864] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:39.864] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:39.865] - globals: [1] ‘FUN’
[17:45:39.865] 
[17:45:39.865] getGlobalsAndPackages() ... DONE
[17:45:39.865]  - globals found/used: [n=1] ‘FUN’
[17:45:39.865]  - needed namespaces: [n=0] 
[17:45:39.865] Finding globals ... DONE
[17:45:39.865] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:39.865] List of 2
[17:45:39.865]  $ ...future.FUN:function (x, y)  
[17:45:39.865]  $ MoreArgs     : NULL
[17:45:39.865]  - attr(*, "where")=List of 2
[17:45:39.865]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:39.865]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:39.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:39.865]  - attr(*, "resolved")= logi FALSE
[17:45:39.865]  - attr(*, "total_size")= num NA
[17:45:39.868] Packages to be attached in all futures: [n=0] 
[17:45:39.868] getGlobalsAndPackagesXApply() ... DONE
[17:45:39.868] Number of futures (= number of chunks): 1
[17:45:39.868] Launching 1 futures (chunks) ...
[17:45:39.868] Chunk #1 of 1 ...
[17:45:39.868]  - Finding globals in '...' for chunk #1 ...
[17:45:39.869] getGlobalsAndPackages() ...
[17:45:39.869] Searching for globals...
[17:45:39.869] 
[17:45:39.869] Searching for globals ... DONE
[17:45:39.869] - globals: [0] <none>
[17:45:39.869] getGlobalsAndPackages() ... DONE
[17:45:39.869]    + additional globals found: [n=0] 
[17:45:39.869]    + additional namespaces needed: [n=0] 
[17:45:39.869]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:39.870]  - seeds: <none>
[17:45:39.870]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:39.870] getGlobalsAndPackages() ...
[17:45:39.870] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:39.870] Resolving globals: FALSE
[17:45:39.870] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:45:39.871] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:39.871] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:39.871] 
[17:45:39.871] getGlobalsAndPackages() ... DONE
[17:45:39.871] run() for ‘Future’ ...
[17:45:39.872] - state: ‘created’
[17:45:39.872] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:39.875] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:39.875] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:39.875]   - Field: ‘label’
[17:45:39.875]   - Field: ‘local’
[17:45:39.876]   - Field: ‘owner’
[17:45:39.876]   - Field: ‘envir’
[17:45:39.876]   - Field: ‘packages’
[17:45:39.876]   - Field: ‘gc’
[17:45:39.876]   - Field: ‘conditions’
[17:45:39.876]   - Field: ‘expr’
[17:45:39.876]   - Field: ‘uuid’
[17:45:39.876]   - Field: ‘seed’
[17:45:39.876]   - Field: ‘version’
[17:45:39.877]   - Field: ‘result’
[17:45:39.877]   - Field: ‘asynchronous’
[17:45:39.877]   - Field: ‘calls’
[17:45:39.877]   - Field: ‘globals’
[17:45:39.877]   - Field: ‘stdout’
[17:45:39.877]   - Field: ‘earlySignal’
[17:45:39.877]   - Field: ‘lazy’
[17:45:39.877]   - Field: ‘state’
[17:45:39.877] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:39.877] - Launch lazy future ...
[17:45:39.878] Packages needed by the future expression (n = 0): <none>
[17:45:39.878] Packages needed by future strategies (n = 0): <none>
[17:45:39.878] {
[17:45:39.878]     {
[17:45:39.878]         {
[17:45:39.878]             ...future.startTime <- base::Sys.time()
[17:45:39.878]             {
[17:45:39.878]                 {
[17:45:39.878]                   {
[17:45:39.878]                     base::local({
[17:45:39.878]                       has_future <- base::requireNamespace("future", 
[17:45:39.878]                         quietly = TRUE)
[17:45:39.878]                       if (has_future) {
[17:45:39.878]                         ns <- base::getNamespace("future")
[17:45:39.878]                         version <- ns[[".package"]][["version"]]
[17:45:39.878]                         if (is.null(version)) 
[17:45:39.878]                           version <- utils::packageVersion("future")
[17:45:39.878]                       }
[17:45:39.878]                       else {
[17:45:39.878]                         version <- NULL
[17:45:39.878]                       }
[17:45:39.878]                       if (!has_future || version < "1.8.0") {
[17:45:39.878]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:39.878]                           "", base::R.version$version.string), 
[17:45:39.878]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:39.878]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:39.878]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:39.878]                             "release", "version")], collapse = " "), 
[17:45:39.878]                           hostname = base::Sys.info()[["nodename"]])
[17:45:39.878]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:39.878]                           info)
[17:45:39.878]                         info <- base::paste(info, collapse = "; ")
[17:45:39.878]                         if (!has_future) {
[17:45:39.878]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:39.878]                             info)
[17:45:39.878]                         }
[17:45:39.878]                         else {
[17:45:39.878]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:39.878]                             info, version)
[17:45:39.878]                         }
[17:45:39.878]                         base::stop(msg)
[17:45:39.878]                       }
[17:45:39.878]                     })
[17:45:39.878]                   }
[17:45:39.878]                   ...future.strategy.old <- future::plan("list")
[17:45:39.878]                   options(future.plan = NULL)
[17:45:39.878]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:39.878]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:39.878]                 }
[17:45:39.878]                 ...future.workdir <- getwd()
[17:45:39.878]             }
[17:45:39.878]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:39.878]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:39.878]         }
[17:45:39.878]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:39.878]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:39.878]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:39.878]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:39.878]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:39.878]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:39.878]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:39.878]             base::names(...future.oldOptions))
[17:45:39.878]     }
[17:45:39.878]     if (FALSE) {
[17:45:39.878]     }
[17:45:39.878]     else {
[17:45:39.878]         if (FALSE) {
[17:45:39.878]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:39.878]                 open = "w")
[17:45:39.878]         }
[17:45:39.878]         else {
[17:45:39.878]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:39.878]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:39.878]         }
[17:45:39.878]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:39.878]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:39.878]             base::sink(type = "output", split = FALSE)
[17:45:39.878]             base::close(...future.stdout)
[17:45:39.878]         }, add = TRUE)
[17:45:39.878]     }
[17:45:39.878]     ...future.frame <- base::sys.nframe()
[17:45:39.878]     ...future.conditions <- base::list()
[17:45:39.878]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:39.878]     if (FALSE) {
[17:45:39.878]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:39.878]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:39.878]     }
[17:45:39.878]     ...future.result <- base::tryCatch({
[17:45:39.878]         base::withCallingHandlers({
[17:45:39.878]             ...future.value <- base::withVisible(base::local({
[17:45:39.878]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:39.878]                 if (!identical(...future.globals.maxSize.org, 
[17:45:39.878]                   ...future.globals.maxSize)) {
[17:45:39.878]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:39.878]                   on.exit(options(oopts), add = TRUE)
[17:45:39.878]                 }
[17:45:39.878]                 {
[17:45:39.878]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:39.878]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:39.878]                     USE.NAMES = FALSE)
[17:45:39.878]                   do.call(mapply, args = args)
[17:45:39.878]                 }
[17:45:39.878]             }))
[17:45:39.878]             future::FutureResult(value = ...future.value$value, 
[17:45:39.878]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:39.878]                   ...future.rng), globalenv = if (FALSE) 
[17:45:39.878]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:39.878]                     ...future.globalenv.names))
[17:45:39.878]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:39.878]         }, condition = base::local({
[17:45:39.878]             c <- base::c
[17:45:39.878]             inherits <- base::inherits
[17:45:39.878]             invokeRestart <- base::invokeRestart
[17:45:39.878]             length <- base::length
[17:45:39.878]             list <- base::list
[17:45:39.878]             seq.int <- base::seq.int
[17:45:39.878]             signalCondition <- base::signalCondition
[17:45:39.878]             sys.calls <- base::sys.calls
[17:45:39.878]             `[[` <- base::`[[`
[17:45:39.878]             `+` <- base::`+`
[17:45:39.878]             `<<-` <- base::`<<-`
[17:45:39.878]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:39.878]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:39.878]                   3L)]
[17:45:39.878]             }
[17:45:39.878]             function(cond) {
[17:45:39.878]                 is_error <- inherits(cond, "error")
[17:45:39.878]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:39.878]                   NULL)
[17:45:39.878]                 if (is_error) {
[17:45:39.878]                   sessionInformation <- function() {
[17:45:39.878]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:39.878]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:39.878]                       search = base::search(), system = base::Sys.info())
[17:45:39.878]                   }
[17:45:39.878]                   ...future.conditions[[length(...future.conditions) + 
[17:45:39.878]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:39.878]                     cond$call), session = sessionInformation(), 
[17:45:39.878]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:39.878]                   signalCondition(cond)
[17:45:39.878]                 }
[17:45:39.878]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:39.878]                 "immediateCondition"))) {
[17:45:39.878]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:39.878]                   ...future.conditions[[length(...future.conditions) + 
[17:45:39.878]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:39.878]                   if (TRUE && !signal) {
[17:45:39.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:39.878]                     {
[17:45:39.878]                       inherits <- base::inherits
[17:45:39.878]                       invokeRestart <- base::invokeRestart
[17:45:39.878]                       is.null <- base::is.null
[17:45:39.878]                       muffled <- FALSE
[17:45:39.878]                       if (inherits(cond, "message")) {
[17:45:39.878]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:39.878]                         if (muffled) 
[17:45:39.878]                           invokeRestart("muffleMessage")
[17:45:39.878]                       }
[17:45:39.878]                       else if (inherits(cond, "warning")) {
[17:45:39.878]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:39.878]                         if (muffled) 
[17:45:39.878]                           invokeRestart("muffleWarning")
[17:45:39.878]                       }
[17:45:39.878]                       else if (inherits(cond, "condition")) {
[17:45:39.878]                         if (!is.null(pattern)) {
[17:45:39.878]                           computeRestarts <- base::computeRestarts
[17:45:39.878]                           grepl <- base::grepl
[17:45:39.878]                           restarts <- computeRestarts(cond)
[17:45:39.878]                           for (restart in restarts) {
[17:45:39.878]                             name <- restart$name
[17:45:39.878]                             if (is.null(name)) 
[17:45:39.878]                               next
[17:45:39.878]                             if (!grepl(pattern, name)) 
[17:45:39.878]                               next
[17:45:39.878]                             invokeRestart(restart)
[17:45:39.878]                             muffled <- TRUE
[17:45:39.878]                             break
[17:45:39.878]                           }
[17:45:39.878]                         }
[17:45:39.878]                       }
[17:45:39.878]                       invisible(muffled)
[17:45:39.878]                     }
[17:45:39.878]                     muffleCondition(cond, pattern = "^muffle")
[17:45:39.878]                   }
[17:45:39.878]                 }
[17:45:39.878]                 else {
[17:45:39.878]                   if (TRUE) {
[17:45:39.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:39.878]                     {
[17:45:39.878]                       inherits <- base::inherits
[17:45:39.878]                       invokeRestart <- base::invokeRestart
[17:45:39.878]                       is.null <- base::is.null
[17:45:39.878]                       muffled <- FALSE
[17:45:39.878]                       if (inherits(cond, "message")) {
[17:45:39.878]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:39.878]                         if (muffled) 
[17:45:39.878]                           invokeRestart("muffleMessage")
[17:45:39.878]                       }
[17:45:39.878]                       else if (inherits(cond, "warning")) {
[17:45:39.878]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:39.878]                         if (muffled) 
[17:45:39.878]                           invokeRestart("muffleWarning")
[17:45:39.878]                       }
[17:45:39.878]                       else if (inherits(cond, "condition")) {
[17:45:39.878]                         if (!is.null(pattern)) {
[17:45:39.878]                           computeRestarts <- base::computeRestarts
[17:45:39.878]                           grepl <- base::grepl
[17:45:39.878]                           restarts <- computeRestarts(cond)
[17:45:39.878]                           for (restart in restarts) {
[17:45:39.878]                             name <- restart$name
[17:45:39.878]                             if (is.null(name)) 
[17:45:39.878]                               next
[17:45:39.878]                             if (!grepl(pattern, name)) 
[17:45:39.878]                               next
[17:45:39.878]                             invokeRestart(restart)
[17:45:39.878]                             muffled <- TRUE
[17:45:39.878]                             break
[17:45:39.878]                           }
[17:45:39.878]                         }
[17:45:39.878]                       }
[17:45:39.878]                       invisible(muffled)
[17:45:39.878]                     }
[17:45:39.878]                     muffleCondition(cond, pattern = "^muffle")
[17:45:39.878]                   }
[17:45:39.878]                 }
[17:45:39.878]             }
[17:45:39.878]         }))
[17:45:39.878]     }, error = function(ex) {
[17:45:39.878]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:39.878]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:39.878]                 ...future.rng), started = ...future.startTime, 
[17:45:39.878]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:39.878]             version = "1.8"), class = "FutureResult")
[17:45:39.878]     }, finally = {
[17:45:39.878]         if (!identical(...future.workdir, getwd())) 
[17:45:39.878]             setwd(...future.workdir)
[17:45:39.878]         {
[17:45:39.878]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:39.878]                 ...future.oldOptions$nwarnings <- NULL
[17:45:39.878]             }
[17:45:39.878]             base::options(...future.oldOptions)
[17:45:39.878]             if (.Platform$OS.type == "windows") {
[17:45:39.878]                 old_names <- names(...future.oldEnvVars)
[17:45:39.878]                 envs <- base::Sys.getenv()
[17:45:39.878]                 names <- names(envs)
[17:45:39.878]                 common <- intersect(names, old_names)
[17:45:39.878]                 added <- setdiff(names, old_names)
[17:45:39.878]                 removed <- setdiff(old_names, names)
[17:45:39.878]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:39.878]                   envs[common]]
[17:45:39.878]                 NAMES <- toupper(changed)
[17:45:39.878]                 args <- list()
[17:45:39.878]                 for (kk in seq_along(NAMES)) {
[17:45:39.878]                   name <- changed[[kk]]
[17:45:39.878]                   NAME <- NAMES[[kk]]
[17:45:39.878]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:39.878]                     next
[17:45:39.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:39.878]                 }
[17:45:39.878]                 NAMES <- toupper(added)
[17:45:39.878]                 for (kk in seq_along(NAMES)) {
[17:45:39.878]                   name <- added[[kk]]
[17:45:39.878]                   NAME <- NAMES[[kk]]
[17:45:39.878]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:39.878]                     next
[17:45:39.878]                   args[[name]] <- ""
[17:45:39.878]                 }
[17:45:39.878]                 NAMES <- toupper(removed)
[17:45:39.878]                 for (kk in seq_along(NAMES)) {
[17:45:39.878]                   name <- removed[[kk]]
[17:45:39.878]                   NAME <- NAMES[[kk]]
[17:45:39.878]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:39.878]                     next
[17:45:39.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:39.878]                 }
[17:45:39.878]                 if (length(args) > 0) 
[17:45:39.878]                   base::do.call(base::Sys.setenv, args = args)
[17:45:39.878]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:39.878]             }
[17:45:39.878]             else {
[17:45:39.878]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:39.878]             }
[17:45:39.878]             {
[17:45:39.878]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:39.878]                   0L) {
[17:45:39.878]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:39.878]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:39.878]                   base::options(opts)
[17:45:39.878]                 }
[17:45:39.878]                 {
[17:45:39.878]                   {
[17:45:39.878]                     NULL
[17:45:39.878]                     RNGkind("Mersenne-Twister")
[17:45:39.878]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:39.878]                       inherits = FALSE)
[17:45:39.878]                   }
[17:45:39.878]                   options(future.plan = NULL)
[17:45:39.878]                   if (is.na(NA_character_)) 
[17:45:39.878]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:39.878]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:39.878]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:39.878]                     .init = FALSE)
[17:45:39.878]                 }
[17:45:39.878]             }
[17:45:39.878]         }
[17:45:39.878]     })
[17:45:39.878]     if (TRUE) {
[17:45:39.878]         base::sink(type = "output", split = FALSE)
[17:45:39.878]         if (FALSE) {
[17:45:39.878]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:39.878]         }
[17:45:39.878]         else {
[17:45:39.878]             ...future.result["stdout"] <- base::list(NULL)
[17:45:39.878]         }
[17:45:39.878]         base::close(...future.stdout)
[17:45:39.878]         ...future.stdout <- NULL
[17:45:39.878]     }
[17:45:39.878]     ...future.result$conditions <- ...future.conditions
[17:45:39.878]     ...future.result$finished <- base::Sys.time()
[17:45:39.878]     ...future.result
[17:45:39.878] }
[17:45:39.880] assign_globals() ...
[17:45:39.880] List of 5
[17:45:39.880]  $ ...future.FUN            :function (x, y)  
[17:45:39.880]  $ MoreArgs                 : NULL
[17:45:39.880]  $ ...future.elements_ii    :List of 2
[17:45:39.880]   ..$ :List of 2
[17:45:39.880]   .. ..$ : int 1
[17:45:39.880]   .. ..$ : int 0
[17:45:39.880]   ..$ :List of 2
[17:45:39.880]   .. ..$ : int 0
[17:45:39.880]   .. ..$ : int 1
[17:45:39.880]  $ ...future.seeds_ii       : NULL
[17:45:39.880]  $ ...future.globals.maxSize: NULL
[17:45:39.880]  - attr(*, "where")=List of 5
[17:45:39.880]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:39.880]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:39.880]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:39.880]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:39.880]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:39.880]  - attr(*, "resolved")= logi FALSE
[17:45:39.880]  - attr(*, "total_size")= num 6480
[17:45:39.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:39.880]  - attr(*, "already-done")= logi TRUE
[17:45:39.885] - reassign environment for ‘...future.FUN’
[17:45:39.887] - copied ‘...future.FUN’ to environment
[17:45:39.887] - copied ‘MoreArgs’ to environment
[17:45:39.887] - copied ‘...future.elements_ii’ to environment
[17:45:39.888] - copied ‘...future.seeds_ii’ to environment
[17:45:39.888] - copied ‘...future.globals.maxSize’ to environment
[17:45:39.888] assign_globals() ... done
[17:45:39.888] plan(): Setting new future strategy stack:
[17:45:39.888] List of future strategies:
[17:45:39.888] 1. sequential:
[17:45:39.888]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:39.888]    - tweaked: FALSE
[17:45:39.888]    - call: NULL
[17:45:39.889] plan(): nbrOfWorkers() = 1
[17:45:40.390] plan(): Setting new future strategy stack:
[17:45:40.391] List of future strategies:
[17:45:40.391] 1. multisession:
[17:45:40.391]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:45:40.391]    - tweaked: FALSE
[17:45:40.391]    - call: plan(strategy)
[17:45:40.394] plan(): nbrOfWorkers() = 1
[17:45:40.395] SequentialFuture started (and completed)
[17:45:40.395] - Launch lazy future ... done
[17:45:40.395] run() for ‘SequentialFuture’ ... done
[17:45:40.395] Created future:
[17:45:40.395] SequentialFuture:
[17:45:40.395] Label: ‘future_mapply-1’
[17:45:40.395] Expression:
[17:45:40.395] {
[17:45:40.395]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:40.395]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:40.395]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:40.395]         on.exit(options(oopts), add = TRUE)
[17:45:40.395]     }
[17:45:40.395]     {
[17:45:40.395]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:40.395]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:40.395]         do.call(mapply, args = args)
[17:45:40.395]     }
[17:45:40.395] }
[17:45:40.395] Lazy evaluation: FALSE
[17:45:40.395] Asynchronous evaluation: FALSE
[17:45:40.395] Local evaluation: TRUE
[17:45:40.395] Environment: R_GlobalEnv
[17:45:40.395] Capture standard output: FALSE
[17:45:40.395] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:40.395] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:40.395] Packages: <none>
[17:45:40.395] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:40.395] Resolved: TRUE
[17:45:40.395] Value: 224 bytes of class ‘list’
[17:45:40.395] Early signaling: FALSE
[17:45:40.395] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:40.395] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:40.396] Chunk #1 of 1 ... DONE
[17:45:40.396] Launching 1 futures (chunks) ... DONE
[17:45:40.396] Resolving 1 futures (chunks) ...
[17:45:40.397] resolve() on list ...
[17:45:40.397]  recursive: 0
[17:45:40.397]  length: 1
[17:45:40.397] 
[17:45:40.397] resolved() for ‘SequentialFuture’ ...
[17:45:40.397] - state: ‘finished’
[17:45:40.397] - run: TRUE
[17:45:40.397] - result: ‘FutureResult’
[17:45:40.397] resolved() for ‘SequentialFuture’ ... done
[17:45:40.397] Future #1
[17:45:40.398] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:40.398] - nx: 1
[17:45:40.398] - relay: TRUE
[17:45:40.398] - stdout: TRUE
[17:45:40.398] - signal: TRUE
[17:45:40.398] - resignal: FALSE
[17:45:40.398] - force: TRUE
[17:45:40.398] - relayed: [n=1] FALSE
[17:45:40.398] - queued futures: [n=1] FALSE
[17:45:40.398]  - until=1
[17:45:40.398]  - relaying element #1
[17:45:40.399] - relayed: [n=1] TRUE
[17:45:40.399] - queued futures: [n=1] TRUE
[17:45:40.399] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:40.399]  length: 0 (resolved future 1)
[17:45:40.399] Relaying remaining futures
[17:45:40.399] signalConditionsASAP(NULL, pos=0) ...
[17:45:40.399] - nx: 1
[17:45:40.399] - relay: TRUE
[17:45:40.399] - stdout: TRUE
[17:45:40.399] - signal: TRUE
[17:45:40.399] - resignal: FALSE
[17:45:40.400] - force: TRUE
[17:45:40.400] - relayed: [n=1] TRUE
[17:45:40.400] - queued futures: [n=1] TRUE
 - flush all
[17:45:40.400] - relayed: [n=1] TRUE
[17:45:40.400] - queued futures: [n=1] TRUE
[17:45:40.400] signalConditionsASAP(NULL, pos=0) ... done
[17:45:40.400] resolve() on list ... DONE
[17:45:40.400]  - Number of value chunks collected: 1
[17:45:40.400] Resolving 1 futures (chunks) ... DONE
[17:45:40.400] Reducing values from 1 chunks ...
[17:45:40.401]  - Number of values collected after concatenation: 2
[17:45:40.401]  - Number of values expected: 2
[17:45:40.401] Reducing values from 1 chunks ... DONE
[17:45:40.401] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:45:40.401] future_mapply() ...
[17:45:40.404] Number of chunks: 1
[17:45:40.404] getGlobalsAndPackagesXApply() ...
[17:45:40.405]  - future.globals: TRUE
[17:45:40.405] getGlobalsAndPackages() ...
[17:45:40.405] Searching for globals...
[17:45:40.406] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:40.406] Searching for globals ... DONE
[17:45:40.406] Resolving globals: FALSE
[17:45:40.407] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:40.407] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:40.407] - globals: [1] ‘FUN’
[17:45:40.407] 
[17:45:40.408] getGlobalsAndPackages() ... DONE
[17:45:40.408]  - globals found/used: [n=1] ‘FUN’
[17:45:40.408]  - needed namespaces: [n=0] 
[17:45:40.408] Finding globals ... DONE
[17:45:40.408] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:40.408] List of 2
[17:45:40.408]  $ ...future.FUN:function (x, y)  
[17:45:40.408]  $ MoreArgs     : NULL
[17:45:40.408]  - attr(*, "where")=List of 2
[17:45:40.408]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:40.408]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:40.408]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:40.408]  - attr(*, "resolved")= logi FALSE
[17:45:40.408]  - attr(*, "total_size")= num NA
[17:45:40.411] Packages to be attached in all futures: [n=0] 
[17:45:40.411] getGlobalsAndPackagesXApply() ... DONE
[17:45:40.411] Number of futures (= number of chunks): 1
[17:45:40.411] Launching 1 futures (chunks) ...
[17:45:40.411] Chunk #1 of 1 ...
[17:45:40.411]  - Finding globals in '...' for chunk #1 ...
[17:45:40.411] getGlobalsAndPackages() ...
[17:45:40.411] Searching for globals...
[17:45:40.412] 
[17:45:40.412] Searching for globals ... DONE
[17:45:40.412] - globals: [0] <none>
[17:45:40.412] getGlobalsAndPackages() ... DONE
[17:45:40.412]    + additional globals found: [n=0] 
[17:45:40.412]    + additional namespaces needed: [n=0] 
[17:45:40.412]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:40.412]  - seeds: <none>
[17:45:40.412]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:40.413] getGlobalsAndPackages() ...
[17:45:40.413] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:40.413] Resolving globals: FALSE
[17:45:40.413] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:45:40.414] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:40.414] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:40.414] 
[17:45:40.414] getGlobalsAndPackages() ... DONE
[17:45:40.414] run() for ‘Future’ ...
[17:45:40.414] - state: ‘created’
[17:45:40.415] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:40.418] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:40.418] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:40.418]   - Field: ‘label’
[17:45:40.418]   - Field: ‘local’
[17:45:40.418]   - Field: ‘owner’
[17:45:40.418]   - Field: ‘envir’
[17:45:40.419]   - Field: ‘packages’
[17:45:40.419]   - Field: ‘gc’
[17:45:40.419]   - Field: ‘conditions’
[17:45:40.419]   - Field: ‘expr’
[17:45:40.419]   - Field: ‘uuid’
[17:45:40.419]   - Field: ‘seed’
[17:45:40.419]   - Field: ‘version’
[17:45:40.419]   - Field: ‘result’
[17:45:40.419]   - Field: ‘asynchronous’
[17:45:40.419]   - Field: ‘calls’
[17:45:40.420]   - Field: ‘globals’
[17:45:40.420]   - Field: ‘stdout’
[17:45:40.420]   - Field: ‘earlySignal’
[17:45:40.420]   - Field: ‘lazy’
[17:45:40.420]   - Field: ‘state’
[17:45:40.420] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:40.420] - Launch lazy future ...
[17:45:40.420] Packages needed by the future expression (n = 0): <none>
[17:45:40.421] Packages needed by future strategies (n = 0): <none>
[17:45:40.421] {
[17:45:40.421]     {
[17:45:40.421]         {
[17:45:40.421]             ...future.startTime <- base::Sys.time()
[17:45:40.421]             {
[17:45:40.421]                 {
[17:45:40.421]                   {
[17:45:40.421]                     base::local({
[17:45:40.421]                       has_future <- base::requireNamespace("future", 
[17:45:40.421]                         quietly = TRUE)
[17:45:40.421]                       if (has_future) {
[17:45:40.421]                         ns <- base::getNamespace("future")
[17:45:40.421]                         version <- ns[[".package"]][["version"]]
[17:45:40.421]                         if (is.null(version)) 
[17:45:40.421]                           version <- utils::packageVersion("future")
[17:45:40.421]                       }
[17:45:40.421]                       else {
[17:45:40.421]                         version <- NULL
[17:45:40.421]                       }
[17:45:40.421]                       if (!has_future || version < "1.8.0") {
[17:45:40.421]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:40.421]                           "", base::R.version$version.string), 
[17:45:40.421]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:40.421]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:40.421]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:40.421]                             "release", "version")], collapse = " "), 
[17:45:40.421]                           hostname = base::Sys.info()[["nodename"]])
[17:45:40.421]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:40.421]                           info)
[17:45:40.421]                         info <- base::paste(info, collapse = "; ")
[17:45:40.421]                         if (!has_future) {
[17:45:40.421]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:40.421]                             info)
[17:45:40.421]                         }
[17:45:40.421]                         else {
[17:45:40.421]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:40.421]                             info, version)
[17:45:40.421]                         }
[17:45:40.421]                         base::stop(msg)
[17:45:40.421]                       }
[17:45:40.421]                     })
[17:45:40.421]                   }
[17:45:40.421]                   ...future.strategy.old <- future::plan("list")
[17:45:40.421]                   options(future.plan = NULL)
[17:45:40.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:40.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:40.421]                 }
[17:45:40.421]                 ...future.workdir <- getwd()
[17:45:40.421]             }
[17:45:40.421]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:40.421]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:40.421]         }
[17:45:40.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:40.421]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:40.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:40.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:40.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:40.421]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:40.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:40.421]             base::names(...future.oldOptions))
[17:45:40.421]     }
[17:45:40.421]     if (FALSE) {
[17:45:40.421]     }
[17:45:40.421]     else {
[17:45:40.421]         if (TRUE) {
[17:45:40.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:40.421]                 open = "w")
[17:45:40.421]         }
[17:45:40.421]         else {
[17:45:40.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:40.421]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:40.421]         }
[17:45:40.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:40.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:40.421]             base::sink(type = "output", split = FALSE)
[17:45:40.421]             base::close(...future.stdout)
[17:45:40.421]         }, add = TRUE)
[17:45:40.421]     }
[17:45:40.421]     ...future.frame <- base::sys.nframe()
[17:45:40.421]     ...future.conditions <- base::list()
[17:45:40.421]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:40.421]     if (FALSE) {
[17:45:40.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:40.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:40.421]     }
[17:45:40.421]     ...future.result <- base::tryCatch({
[17:45:40.421]         base::withCallingHandlers({
[17:45:40.421]             ...future.value <- base::withVisible(base::local({
[17:45:40.421]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:40.421]                 if (!identical(...future.globals.maxSize.org, 
[17:45:40.421]                   ...future.globals.maxSize)) {
[17:45:40.421]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:40.421]                   on.exit(options(oopts), add = TRUE)
[17:45:40.421]                 }
[17:45:40.421]                 {
[17:45:40.421]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:40.421]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:40.421]                     USE.NAMES = FALSE)
[17:45:40.421]                   do.call(mapply, args = args)
[17:45:40.421]                 }
[17:45:40.421]             }))
[17:45:40.421]             future::FutureResult(value = ...future.value$value, 
[17:45:40.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:40.421]                   ...future.rng), globalenv = if (FALSE) 
[17:45:40.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:40.421]                     ...future.globalenv.names))
[17:45:40.421]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:40.421]         }, condition = base::local({
[17:45:40.421]             c <- base::c
[17:45:40.421]             inherits <- base::inherits
[17:45:40.421]             invokeRestart <- base::invokeRestart
[17:45:40.421]             length <- base::length
[17:45:40.421]             list <- base::list
[17:45:40.421]             seq.int <- base::seq.int
[17:45:40.421]             signalCondition <- base::signalCondition
[17:45:40.421]             sys.calls <- base::sys.calls
[17:45:40.421]             `[[` <- base::`[[`
[17:45:40.421]             `+` <- base::`+`
[17:45:40.421]             `<<-` <- base::`<<-`
[17:45:40.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:40.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:40.421]                   3L)]
[17:45:40.421]             }
[17:45:40.421]             function(cond) {
[17:45:40.421]                 is_error <- inherits(cond, "error")
[17:45:40.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:40.421]                   NULL)
[17:45:40.421]                 if (is_error) {
[17:45:40.421]                   sessionInformation <- function() {
[17:45:40.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:40.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:40.421]                       search = base::search(), system = base::Sys.info())
[17:45:40.421]                   }
[17:45:40.421]                   ...future.conditions[[length(...future.conditions) + 
[17:45:40.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:40.421]                     cond$call), session = sessionInformation(), 
[17:45:40.421]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:40.421]                   signalCondition(cond)
[17:45:40.421]                 }
[17:45:40.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:40.421]                 "immediateCondition"))) {
[17:45:40.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:40.421]                   ...future.conditions[[length(...future.conditions) + 
[17:45:40.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:40.421]                   if (TRUE && !signal) {
[17:45:40.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:40.421]                     {
[17:45:40.421]                       inherits <- base::inherits
[17:45:40.421]                       invokeRestart <- base::invokeRestart
[17:45:40.421]                       is.null <- base::is.null
[17:45:40.421]                       muffled <- FALSE
[17:45:40.421]                       if (inherits(cond, "message")) {
[17:45:40.421]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:40.421]                         if (muffled) 
[17:45:40.421]                           invokeRestart("muffleMessage")
[17:45:40.421]                       }
[17:45:40.421]                       else if (inherits(cond, "warning")) {
[17:45:40.421]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:40.421]                         if (muffled) 
[17:45:40.421]                           invokeRestart("muffleWarning")
[17:45:40.421]                       }
[17:45:40.421]                       else if (inherits(cond, "condition")) {
[17:45:40.421]                         if (!is.null(pattern)) {
[17:45:40.421]                           computeRestarts <- base::computeRestarts
[17:45:40.421]                           grepl <- base::grepl
[17:45:40.421]                           restarts <- computeRestarts(cond)
[17:45:40.421]                           for (restart in restarts) {
[17:45:40.421]                             name <- restart$name
[17:45:40.421]                             if (is.null(name)) 
[17:45:40.421]                               next
[17:45:40.421]                             if (!grepl(pattern, name)) 
[17:45:40.421]                               next
[17:45:40.421]                             invokeRestart(restart)
[17:45:40.421]                             muffled <- TRUE
[17:45:40.421]                             break
[17:45:40.421]                           }
[17:45:40.421]                         }
[17:45:40.421]                       }
[17:45:40.421]                       invisible(muffled)
[17:45:40.421]                     }
[17:45:40.421]                     muffleCondition(cond, pattern = "^muffle")
[17:45:40.421]                   }
[17:45:40.421]                 }
[17:45:40.421]                 else {
[17:45:40.421]                   if (TRUE) {
[17:45:40.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:40.421]                     {
[17:45:40.421]                       inherits <- base::inherits
[17:45:40.421]                       invokeRestart <- base::invokeRestart
[17:45:40.421]                       is.null <- base::is.null
[17:45:40.421]                       muffled <- FALSE
[17:45:40.421]                       if (inherits(cond, "message")) {
[17:45:40.421]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:40.421]                         if (muffled) 
[17:45:40.421]                           invokeRestart("muffleMessage")
[17:45:40.421]                       }
[17:45:40.421]                       else if (inherits(cond, "warning")) {
[17:45:40.421]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:40.421]                         if (muffled) 
[17:45:40.421]                           invokeRestart("muffleWarning")
[17:45:40.421]                       }
[17:45:40.421]                       else if (inherits(cond, "condition")) {
[17:45:40.421]                         if (!is.null(pattern)) {
[17:45:40.421]                           computeRestarts <- base::computeRestarts
[17:45:40.421]                           grepl <- base::grepl
[17:45:40.421]                           restarts <- computeRestarts(cond)
[17:45:40.421]                           for (restart in restarts) {
[17:45:40.421]                             name <- restart$name
[17:45:40.421]                             if (is.null(name)) 
[17:45:40.421]                               next
[17:45:40.421]                             if (!grepl(pattern, name)) 
[17:45:40.421]                               next
[17:45:40.421]                             invokeRestart(restart)
[17:45:40.421]                             muffled <- TRUE
[17:45:40.421]                             break
[17:45:40.421]                           }
[17:45:40.421]                         }
[17:45:40.421]                       }
[17:45:40.421]                       invisible(muffled)
[17:45:40.421]                     }
[17:45:40.421]                     muffleCondition(cond, pattern = "^muffle")
[17:45:40.421]                   }
[17:45:40.421]                 }
[17:45:40.421]             }
[17:45:40.421]         }))
[17:45:40.421]     }, error = function(ex) {
[17:45:40.421]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:40.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:40.421]                 ...future.rng), started = ...future.startTime, 
[17:45:40.421]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:40.421]             version = "1.8"), class = "FutureResult")
[17:45:40.421]     }, finally = {
[17:45:40.421]         if (!identical(...future.workdir, getwd())) 
[17:45:40.421]             setwd(...future.workdir)
[17:45:40.421]         {
[17:45:40.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:40.421]                 ...future.oldOptions$nwarnings <- NULL
[17:45:40.421]             }
[17:45:40.421]             base::options(...future.oldOptions)
[17:45:40.421]             if (.Platform$OS.type == "windows") {
[17:45:40.421]                 old_names <- names(...future.oldEnvVars)
[17:45:40.421]                 envs <- base::Sys.getenv()
[17:45:40.421]                 names <- names(envs)
[17:45:40.421]                 common <- intersect(names, old_names)
[17:45:40.421]                 added <- setdiff(names, old_names)
[17:45:40.421]                 removed <- setdiff(old_names, names)
[17:45:40.421]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:40.421]                   envs[common]]
[17:45:40.421]                 NAMES <- toupper(changed)
[17:45:40.421]                 args <- list()
[17:45:40.421]                 for (kk in seq_along(NAMES)) {
[17:45:40.421]                   name <- changed[[kk]]
[17:45:40.421]                   NAME <- NAMES[[kk]]
[17:45:40.421]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:40.421]                     next
[17:45:40.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:40.421]                 }
[17:45:40.421]                 NAMES <- toupper(added)
[17:45:40.421]                 for (kk in seq_along(NAMES)) {
[17:45:40.421]                   name <- added[[kk]]
[17:45:40.421]                   NAME <- NAMES[[kk]]
[17:45:40.421]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:40.421]                     next
[17:45:40.421]                   args[[name]] <- ""
[17:45:40.421]                 }
[17:45:40.421]                 NAMES <- toupper(removed)
[17:45:40.421]                 for (kk in seq_along(NAMES)) {
[17:45:40.421]                   name <- removed[[kk]]
[17:45:40.421]                   NAME <- NAMES[[kk]]
[17:45:40.421]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:40.421]                     next
[17:45:40.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:40.421]                 }
[17:45:40.421]                 if (length(args) > 0) 
[17:45:40.421]                   base::do.call(base::Sys.setenv, args = args)
[17:45:40.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:40.421]             }
[17:45:40.421]             else {
[17:45:40.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:40.421]             }
[17:45:40.421]             {
[17:45:40.421]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:40.421]                   0L) {
[17:45:40.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:40.421]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:40.421]                   base::options(opts)
[17:45:40.421]                 }
[17:45:40.421]                 {
[17:45:40.421]                   {
[17:45:40.421]                     NULL
[17:45:40.421]                     RNGkind("Mersenne-Twister")
[17:45:40.421]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:40.421]                       inherits = FALSE)
[17:45:40.421]                   }
[17:45:40.421]                   options(future.plan = NULL)
[17:45:40.421]                   if (is.na(NA_character_)) 
[17:45:40.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:40.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:40.421]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:40.421]                     .init = FALSE)
[17:45:40.421]                 }
[17:45:40.421]             }
[17:45:40.421]         }
[17:45:40.421]     })
[17:45:40.421]     if (TRUE) {
[17:45:40.421]         base::sink(type = "output", split = FALSE)
[17:45:40.421]         if (TRUE) {
[17:45:40.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:40.421]         }
[17:45:40.421]         else {
[17:45:40.421]             ...future.result["stdout"] <- base::list(NULL)
[17:45:40.421]         }
[17:45:40.421]         base::close(...future.stdout)
[17:45:40.421]         ...future.stdout <- NULL
[17:45:40.421]     }
[17:45:40.421]     ...future.result$conditions <- ...future.conditions
[17:45:40.421]     ...future.result$finished <- base::Sys.time()
[17:45:40.421]     ...future.result
[17:45:40.421] }
[17:45:40.424] assign_globals() ...
[17:45:40.424] List of 5
[17:45:40.424]  $ ...future.FUN            :function (x, y)  
[17:45:40.424]  $ MoreArgs                 : NULL
[17:45:40.424]  $ ...future.elements_ii    :List of 2
[17:45:40.424]   ..$ :List of 2
[17:45:40.424]   .. ..$ : int 1
[17:45:40.424]   .. ..$ : int 0
[17:45:40.424]   ..$ :List of 2
[17:45:40.424]   .. ..$ : int 0
[17:45:40.424]   .. ..$ : int 1
[17:45:40.424]  $ ...future.seeds_ii       : NULL
[17:45:40.424]  $ ...future.globals.maxSize: NULL
[17:45:40.424]  - attr(*, "where")=List of 5
[17:45:40.424]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:40.424]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:40.424]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:40.424]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:40.424]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:40.424]  - attr(*, "resolved")= logi FALSE
[17:45:40.424]  - attr(*, "total_size")= num 6480
[17:45:40.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:40.424]  - attr(*, "already-done")= logi TRUE
[17:45:40.430] - reassign environment for ‘...future.FUN’
[17:45:40.430] - copied ‘...future.FUN’ to environment
[17:45:40.430] - copied ‘MoreArgs’ to environment
[17:45:40.430] - copied ‘...future.elements_ii’ to environment
[17:45:40.430] - copied ‘...future.seeds_ii’ to environment
[17:45:40.430] - copied ‘...future.globals.maxSize’ to environment
[17:45:40.431] assign_globals() ... done
[17:45:40.431] plan(): Setting new future strategy stack:
[17:45:40.431] List of future strategies:
[17:45:40.431] 1. sequential:
[17:45:40.431]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:40.431]    - tweaked: FALSE
[17:45:40.431]    - call: NULL
[17:45:40.431] plan(): nbrOfWorkers() = 1
[17:45:40.933] plan(): Setting new future strategy stack:
[17:45:40.933] List of future strategies:
[17:45:40.933] 1. multisession:
[17:45:40.933]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:45:40.933]    - tweaked: FALSE
[17:45:40.933]    - call: plan(strategy)
[17:45:40.937] plan(): nbrOfWorkers() = 1
[17:45:40.937] SequentialFuture started (and completed)
[17:45:40.937] - Launch lazy future ... done
[17:45:40.938] run() for ‘SequentialFuture’ ... done
[17:45:40.938] Created future:
[17:45:40.938] SequentialFuture:
[17:45:40.938] Label: ‘future_mapply-1’
[17:45:40.938] Expression:
[17:45:40.938] {
[17:45:40.938]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:40.938]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:40.938]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:40.938]         on.exit(options(oopts), add = TRUE)
[17:45:40.938]     }
[17:45:40.938]     {
[17:45:40.938]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:40.938]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:40.938]         do.call(mapply, args = args)
[17:45:40.938]     }
[17:45:40.938] }
[17:45:40.938] Lazy evaluation: FALSE
[17:45:40.938] Asynchronous evaluation: FALSE
[17:45:40.938] Local evaluation: TRUE
[17:45:40.938] Environment: R_GlobalEnv
[17:45:40.938] Capture standard output: TRUE
[17:45:40.938] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:40.938] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:40.938] Packages: <none>
[17:45:40.938] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:40.938] Resolved: TRUE
[17:45:40.938] Value: 224 bytes of class ‘list’
[17:45:40.938] Early signaling: FALSE
[17:45:40.938] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:40.938] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:40.939] Chunk #1 of 1 ... DONE
[17:45:40.939] Launching 1 futures (chunks) ... DONE
[17:45:40.939] Resolving 1 futures (chunks) ...
[17:45:40.939] resolve() on list ...
[17:45:40.939]  recursive: 0
[17:45:40.939]  length: 1
[17:45:40.939] 
[17:45:40.939] resolved() for ‘SequentialFuture’ ...
[17:45:40.940] - state: ‘finished’
[17:45:40.940] - run: TRUE
[17:45:40.940] - result: ‘FutureResult’
[17:45:40.940] resolved() for ‘SequentialFuture’ ... done
[17:45:40.940] Future #1
[17:45:40.940] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:40.940] - nx: 1
[17:45:40.940] - relay: TRUE
[17:45:40.940] - stdout: TRUE
[17:45:40.940] - signal: TRUE
[17:45:40.940] - resignal: FALSE
[17:45:40.941] - force: TRUE
[17:45:40.941] - relayed: [n=1] FALSE
[17:45:40.941] - queued futures: [n=1] FALSE
[17:45:40.941]  - until=1
[17:45:40.941]  - relaying element #1
[17:45:40.941] - relayed: [n=1] TRUE
[17:45:40.941] - queued futures: [n=1] TRUE
[17:45:40.941] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:40.941]  length: 0 (resolved future 1)
[17:45:40.941] Relaying remaining futures
[17:45:40.942] signalConditionsASAP(NULL, pos=0) ...
[17:45:40.942] - nx: 1
[17:45:40.942] - relay: TRUE
[17:45:40.942] - stdout: TRUE
[17:45:40.942] - signal: TRUE
[17:45:40.942] - resignal: FALSE
[17:45:40.942] - force: TRUE
[17:45:40.942] - relayed: [n=1] TRUE
[17:45:40.942] - queued futures: [n=1] TRUE
 - flush all
[17:45:40.942] - relayed: [n=1] TRUE
[17:45:40.942] - queued futures: [n=1] TRUE
[17:45:40.942] signalConditionsASAP(NULL, pos=0) ... done
[17:45:40.943] resolve() on list ... DONE
[17:45:40.943]  - Number of value chunks collected: 1
[17:45:40.943] Resolving 1 futures (chunks) ... DONE
[17:45:40.943] Reducing values from 1 chunks ...
[17:45:40.943]  - Number of values collected after concatenation: 2
[17:45:40.943]  - Number of values expected: 2
[17:45:40.943] Reducing values from 1 chunks ... DONE
[17:45:40.943] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:45:40.944] future_mapply() ...
[17:45:40.947] Number of chunks: 1
[17:45:40.947] getGlobalsAndPackagesXApply() ...
[17:45:40.947]  - future.globals: TRUE
[17:45:40.947] getGlobalsAndPackages() ...
[17:45:40.947] Searching for globals...
[17:45:40.949] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:40.949] Searching for globals ... DONE
[17:45:40.949] Resolving globals: FALSE
[17:45:40.949] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:40.950] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:40.950] - globals: [1] ‘FUN’
[17:45:40.950] 
[17:45:40.950] getGlobalsAndPackages() ... DONE
[17:45:40.950]  - globals found/used: [n=1] ‘FUN’
[17:45:40.950]  - needed namespaces: [n=0] 
[17:45:40.950] Finding globals ... DONE
[17:45:40.950] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:40.951] List of 2
[17:45:40.951]  $ ...future.FUN:function (x, y)  
[17:45:40.951]  $ MoreArgs     : NULL
[17:45:40.951]  - attr(*, "where")=List of 2
[17:45:40.951]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:40.951]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:40.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:40.951]  - attr(*, "resolved")= logi FALSE
[17:45:40.951]  - attr(*, "total_size")= num NA
[17:45:40.953] Packages to be attached in all futures: [n=0] 
[17:45:40.953] getGlobalsAndPackagesXApply() ... DONE
[17:45:40.953] Number of futures (= number of chunks): 1
[17:45:40.953] Launching 1 futures (chunks) ...
[17:45:40.954] Chunk #1 of 1 ...
[17:45:40.954]  - Finding globals in '...' for chunk #1 ...
[17:45:40.954] getGlobalsAndPackages() ...
[17:45:40.954] Searching for globals...
[17:45:40.954] 
[17:45:40.954] Searching for globals ... DONE
[17:45:40.956] - globals: [0] <none>
[17:45:40.956] getGlobalsAndPackages() ... DONE
[17:45:40.956]    + additional globals found: [n=0] 
[17:45:40.956]    + additional namespaces needed: [n=0] 
[17:45:40.956]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:40.957]  - seeds: <none>
[17:45:40.957]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:40.957] getGlobalsAndPackages() ...
[17:45:40.957] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:40.957] Resolving globals: FALSE
[17:45:40.958] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[17:45:40.958] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:40.958] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:40.958] 
[17:45:40.958] getGlobalsAndPackages() ... DONE
[17:45:40.959] run() for ‘Future’ ...
[17:45:40.959] - state: ‘created’
[17:45:40.959] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:40.962] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:40.962] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:40.963]   - Field: ‘label’
[17:45:40.963]   - Field: ‘local’
[17:45:40.963]   - Field: ‘owner’
[17:45:40.963]   - Field: ‘envir’
[17:45:40.963]   - Field: ‘packages’
[17:45:40.963]   - Field: ‘gc’
[17:45:40.963]   - Field: ‘conditions’
[17:45:40.963]   - Field: ‘expr’
[17:45:40.963]   - Field: ‘uuid’
[17:45:40.964]   - Field: ‘seed’
[17:45:40.964]   - Field: ‘version’
[17:45:40.964]   - Field: ‘result’
[17:45:40.964]   - Field: ‘asynchronous’
[17:45:40.964]   - Field: ‘calls’
[17:45:40.964]   - Field: ‘globals’
[17:45:40.964]   - Field: ‘stdout’
[17:45:40.964]   - Field: ‘earlySignal’
[17:45:40.964]   - Field: ‘lazy’
[17:45:40.964]   - Field: ‘state’
[17:45:40.965] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:40.965] - Launch lazy future ...
[17:45:40.965] Packages needed by the future expression (n = 0): <none>
[17:45:40.965] Packages needed by future strategies (n = 0): <none>
[17:45:40.965] {
[17:45:40.965]     {
[17:45:40.965]         {
[17:45:40.965]             ...future.startTime <- base::Sys.time()
[17:45:40.965]             {
[17:45:40.965]                 {
[17:45:40.965]                   {
[17:45:40.965]                     base::local({
[17:45:40.965]                       has_future <- base::requireNamespace("future", 
[17:45:40.965]                         quietly = TRUE)
[17:45:40.965]                       if (has_future) {
[17:45:40.965]                         ns <- base::getNamespace("future")
[17:45:40.965]                         version <- ns[[".package"]][["version"]]
[17:45:40.965]                         if (is.null(version)) 
[17:45:40.965]                           version <- utils::packageVersion("future")
[17:45:40.965]                       }
[17:45:40.965]                       else {
[17:45:40.965]                         version <- NULL
[17:45:40.965]                       }
[17:45:40.965]                       if (!has_future || version < "1.8.0") {
[17:45:40.965]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:40.965]                           "", base::R.version$version.string), 
[17:45:40.965]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:40.965]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:40.965]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:40.965]                             "release", "version")], collapse = " "), 
[17:45:40.965]                           hostname = base::Sys.info()[["nodename"]])
[17:45:40.965]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:40.965]                           info)
[17:45:40.965]                         info <- base::paste(info, collapse = "; ")
[17:45:40.965]                         if (!has_future) {
[17:45:40.965]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:40.965]                             info)
[17:45:40.965]                         }
[17:45:40.965]                         else {
[17:45:40.965]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:40.965]                             info, version)
[17:45:40.965]                         }
[17:45:40.965]                         base::stop(msg)
[17:45:40.965]                       }
[17:45:40.965]                     })
[17:45:40.965]                   }
[17:45:40.965]                   ...future.strategy.old <- future::plan("list")
[17:45:40.965]                   options(future.plan = NULL)
[17:45:40.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:40.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:40.965]                 }
[17:45:40.965]                 ...future.workdir <- getwd()
[17:45:40.965]             }
[17:45:40.965]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:40.965]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:40.965]         }
[17:45:40.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:40.965]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:40.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:40.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:40.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:40.965]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:40.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:40.965]             base::names(...future.oldOptions))
[17:45:40.965]     }
[17:45:40.965]     if (TRUE) {
[17:45:40.965]     }
[17:45:40.965]     else {
[17:45:40.965]         if (NA) {
[17:45:40.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:40.965]                 open = "w")
[17:45:40.965]         }
[17:45:40.965]         else {
[17:45:40.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:40.965]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:40.965]         }
[17:45:40.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:40.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:40.965]             base::sink(type = "output", split = FALSE)
[17:45:40.965]             base::close(...future.stdout)
[17:45:40.965]         }, add = TRUE)
[17:45:40.965]     }
[17:45:40.965]     ...future.frame <- base::sys.nframe()
[17:45:40.965]     ...future.conditions <- base::list()
[17:45:40.965]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:40.965]     if (FALSE) {
[17:45:40.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:40.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:40.965]     }
[17:45:40.965]     ...future.result <- base::tryCatch({
[17:45:40.965]         base::withCallingHandlers({
[17:45:40.965]             ...future.value <- base::withVisible(base::local({
[17:45:40.965]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:40.965]                 if (!identical(...future.globals.maxSize.org, 
[17:45:40.965]                   ...future.globals.maxSize)) {
[17:45:40.965]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:40.965]                   on.exit(options(oopts), add = TRUE)
[17:45:40.965]                 }
[17:45:40.965]                 {
[17:45:40.965]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:40.965]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:40.965]                     USE.NAMES = FALSE)
[17:45:40.965]                   do.call(mapply, args = args)
[17:45:40.965]                 }
[17:45:40.965]             }))
[17:45:40.965]             future::FutureResult(value = ...future.value$value, 
[17:45:40.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:40.965]                   ...future.rng), globalenv = if (FALSE) 
[17:45:40.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:40.965]                     ...future.globalenv.names))
[17:45:40.965]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:40.965]         }, condition = base::local({
[17:45:40.965]             c <- base::c
[17:45:40.965]             inherits <- base::inherits
[17:45:40.965]             invokeRestart <- base::invokeRestart
[17:45:40.965]             length <- base::length
[17:45:40.965]             list <- base::list
[17:45:40.965]             seq.int <- base::seq.int
[17:45:40.965]             signalCondition <- base::signalCondition
[17:45:40.965]             sys.calls <- base::sys.calls
[17:45:40.965]             `[[` <- base::`[[`
[17:45:40.965]             `+` <- base::`+`
[17:45:40.965]             `<<-` <- base::`<<-`
[17:45:40.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:40.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:40.965]                   3L)]
[17:45:40.965]             }
[17:45:40.965]             function(cond) {
[17:45:40.965]                 is_error <- inherits(cond, "error")
[17:45:40.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:40.965]                   NULL)
[17:45:40.965]                 if (is_error) {
[17:45:40.965]                   sessionInformation <- function() {
[17:45:40.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:40.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:40.965]                       search = base::search(), system = base::Sys.info())
[17:45:40.965]                   }
[17:45:40.965]                   ...future.conditions[[length(...future.conditions) + 
[17:45:40.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:40.965]                     cond$call), session = sessionInformation(), 
[17:45:40.965]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:40.965]                   signalCondition(cond)
[17:45:40.965]                 }
[17:45:40.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:40.965]                 "immediateCondition"))) {
[17:45:40.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:40.965]                   ...future.conditions[[length(...future.conditions) + 
[17:45:40.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:40.965]                   if (TRUE && !signal) {
[17:45:40.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:40.965]                     {
[17:45:40.965]                       inherits <- base::inherits
[17:45:40.965]                       invokeRestart <- base::invokeRestart
[17:45:40.965]                       is.null <- base::is.null
[17:45:40.965]                       muffled <- FALSE
[17:45:40.965]                       if (inherits(cond, "message")) {
[17:45:40.965]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:40.965]                         if (muffled) 
[17:45:40.965]                           invokeRestart("muffleMessage")
[17:45:40.965]                       }
[17:45:40.965]                       else if (inherits(cond, "warning")) {
[17:45:40.965]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:40.965]                         if (muffled) 
[17:45:40.965]                           invokeRestart("muffleWarning")
[17:45:40.965]                       }
[17:45:40.965]                       else if (inherits(cond, "condition")) {
[17:45:40.965]                         if (!is.null(pattern)) {
[17:45:40.965]                           computeRestarts <- base::computeRestarts
[17:45:40.965]                           grepl <- base::grepl
[17:45:40.965]                           restarts <- computeRestarts(cond)
[17:45:40.965]                           for (restart in restarts) {
[17:45:40.965]                             name <- restart$name
[17:45:40.965]                             if (is.null(name)) 
[17:45:40.965]                               next
[17:45:40.965]                             if (!grepl(pattern, name)) 
[17:45:40.965]                               next
[17:45:40.965]                             invokeRestart(restart)
[17:45:40.965]                             muffled <- TRUE
[17:45:40.965]                             break
[17:45:40.965]                           }
[17:45:40.965]                         }
[17:45:40.965]                       }
[17:45:40.965]                       invisible(muffled)
[17:45:40.965]                     }
[17:45:40.965]                     muffleCondition(cond, pattern = "^muffle")
[17:45:40.965]                   }
[17:45:40.965]                 }
[17:45:40.965]                 else {
[17:45:40.965]                   if (TRUE) {
[17:45:40.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:40.965]                     {
[17:45:40.965]                       inherits <- base::inherits
[17:45:40.965]                       invokeRestart <- base::invokeRestart
[17:45:40.965]                       is.null <- base::is.null
[17:45:40.965]                       muffled <- FALSE
[17:45:40.965]                       if (inherits(cond, "message")) {
[17:45:40.965]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:40.965]                         if (muffled) 
[17:45:40.965]                           invokeRestart("muffleMessage")
[17:45:40.965]                       }
[17:45:40.965]                       else if (inherits(cond, "warning")) {
[17:45:40.965]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:40.965]                         if (muffled) 
[17:45:40.965]                           invokeRestart("muffleWarning")
[17:45:40.965]                       }
[17:45:40.965]                       else if (inherits(cond, "condition")) {
[17:45:40.965]                         if (!is.null(pattern)) {
[17:45:40.965]                           computeRestarts <- base::computeRestarts
[17:45:40.965]                           grepl <- base::grepl
[17:45:40.965]                           restarts <- computeRestarts(cond)
[17:45:40.965]                           for (restart in restarts) {
[17:45:40.965]                             name <- restart$name
[17:45:40.965]                             if (is.null(name)) 
[17:45:40.965]                               next
[17:45:40.965]                             if (!grepl(pattern, name)) 
[17:45:40.965]                               next
[17:45:40.965]                             invokeRestart(restart)
[17:45:40.965]                             muffled <- TRUE
[17:45:40.965]                             break
[17:45:40.965]                           }
[17:45:40.965]                         }
[17:45:40.965]                       }
[17:45:40.965]                       invisible(muffled)
[17:45:40.965]                     }
[17:45:40.965]                     muffleCondition(cond, pattern = "^muffle")
[17:45:40.965]                   }
[17:45:40.965]                 }
[17:45:40.965]             }
[17:45:40.965]         }))
[17:45:40.965]     }, error = function(ex) {
[17:45:40.965]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:40.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:40.965]                 ...future.rng), started = ...future.startTime, 
[17:45:40.965]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:40.965]             version = "1.8"), class = "FutureResult")
[17:45:40.965]     }, finally = {
[17:45:40.965]         if (!identical(...future.workdir, getwd())) 
[17:45:40.965]             setwd(...future.workdir)
[17:45:40.965]         {
[17:45:40.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:40.965]                 ...future.oldOptions$nwarnings <- NULL
[17:45:40.965]             }
[17:45:40.965]             base::options(...future.oldOptions)
[17:45:40.965]             if (.Platform$OS.type == "windows") {
[17:45:40.965]                 old_names <- names(...future.oldEnvVars)
[17:45:40.965]                 envs <- base::Sys.getenv()
[17:45:40.965]                 names <- names(envs)
[17:45:40.965]                 common <- intersect(names, old_names)
[17:45:40.965]                 added <- setdiff(names, old_names)
[17:45:40.965]                 removed <- setdiff(old_names, names)
[17:45:40.965]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:40.965]                   envs[common]]
[17:45:40.965]                 NAMES <- toupper(changed)
[17:45:40.965]                 args <- list()
[17:45:40.965]                 for (kk in seq_along(NAMES)) {
[17:45:40.965]                   name <- changed[[kk]]
[17:45:40.965]                   NAME <- NAMES[[kk]]
[17:45:40.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:40.965]                     next
[17:45:40.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:40.965]                 }
[17:45:40.965]                 NAMES <- toupper(added)
[17:45:40.965]                 for (kk in seq_along(NAMES)) {
[17:45:40.965]                   name <- added[[kk]]
[17:45:40.965]                   NAME <- NAMES[[kk]]
[17:45:40.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:40.965]                     next
[17:45:40.965]                   args[[name]] <- ""
[17:45:40.965]                 }
[17:45:40.965]                 NAMES <- toupper(removed)
[17:45:40.965]                 for (kk in seq_along(NAMES)) {
[17:45:40.965]                   name <- removed[[kk]]
[17:45:40.965]                   NAME <- NAMES[[kk]]
[17:45:40.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:40.965]                     next
[17:45:40.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:40.965]                 }
[17:45:40.965]                 if (length(args) > 0) 
[17:45:40.965]                   base::do.call(base::Sys.setenv, args = args)
[17:45:40.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:40.965]             }
[17:45:40.965]             else {
[17:45:40.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:40.965]             }
[17:45:40.965]             {
[17:45:40.965]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:40.965]                   0L) {
[17:45:40.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:40.965]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:40.965]                   base::options(opts)
[17:45:40.965]                 }
[17:45:40.965]                 {
[17:45:40.965]                   {
[17:45:40.965]                     NULL
[17:45:40.965]                     RNGkind("Mersenne-Twister")
[17:45:40.965]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:40.965]                       inherits = FALSE)
[17:45:40.965]                   }
[17:45:40.965]                   options(future.plan = NULL)
[17:45:40.965]                   if (is.na(NA_character_)) 
[17:45:40.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:40.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:40.965]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:40.965]                     .init = FALSE)
[17:45:40.965]                 }
[17:45:40.965]             }
[17:45:40.965]         }
[17:45:40.965]     })
[17:45:40.965]     if (FALSE) {
[17:45:40.965]         base::sink(type = "output", split = FALSE)
[17:45:40.965]         if (NA) {
[17:45:40.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:40.965]         }
[17:45:40.965]         else {
[17:45:40.965]             ...future.result["stdout"] <- base::list(NULL)
[17:45:40.965]         }
[17:45:40.965]         base::close(...future.stdout)
[17:45:40.965]         ...future.stdout <- NULL
[17:45:40.965]     }
[17:45:40.965]     ...future.result$conditions <- ...future.conditions
[17:45:40.965]     ...future.result$finished <- base::Sys.time()
[17:45:40.965]     ...future.result
[17:45:40.965] }
[17:45:40.967] assign_globals() ...
[17:45:40.967] List of 5
[17:45:40.967]  $ ...future.FUN            :function (x, y)  
[17:45:40.967]  $ MoreArgs                 : NULL
[17:45:40.967]  $ ...future.elements_ii    :List of 2
[17:45:40.967]   ..$ :List of 2
[17:45:40.967]   .. ..$ : int 1
[17:45:40.967]   .. ..$ : int 0
[17:45:40.967]   ..$ :List of 2
[17:45:40.967]   .. ..$ : int 0
[17:45:40.967]   .. ..$ : int 1
[17:45:40.967]  $ ...future.seeds_ii       : NULL
[17:45:40.967]  $ ...future.globals.maxSize: NULL
[17:45:40.967]  - attr(*, "where")=List of 5
[17:45:40.967]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:40.967]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:40.967]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:40.967]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:40.967]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:40.967]  - attr(*, "resolved")= logi FALSE
[17:45:40.967]  - attr(*, "total_size")= num 6480
[17:45:40.967]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:40.967]  - attr(*, "already-done")= logi TRUE
[17:45:40.973] - reassign environment for ‘...future.FUN’
[17:45:40.973] - copied ‘...future.FUN’ to environment
[17:45:40.973] - copied ‘MoreArgs’ to environment
[17:45:40.973] - copied ‘...future.elements_ii’ to environment
[17:45:40.973] - copied ‘...future.seeds_ii’ to environment
[17:45:40.973] - copied ‘...future.globals.maxSize’ to environment
[17:45:40.973] assign_globals() ... done
[17:45:40.973] plan(): Setting new future strategy stack:
[17:45:40.973] List of future strategies:
[17:45:40.973] 1. sequential:
[17:45:40.973]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:40.973]    - tweaked: FALSE
[17:45:40.973]    - call: NULL
[17:45:40.974] plan(): nbrOfWorkers() = 1
[17:45:41.475] plan(): Setting new future strategy stack:
[17:45:41.476] List of future strategies:
[17:45:41.476] 1. multisession:
[17:45:41.476]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:45:41.476]    - tweaked: FALSE
[17:45:41.476]    - call: plan(strategy)
[17:45:41.479] plan(): nbrOfWorkers() = 1
[17:45:41.480] SequentialFuture started (and completed)
[17:45:41.480] - Launch lazy future ... done
[17:45:41.480] run() for ‘SequentialFuture’ ... done
[17:45:41.480] Created future:
[17:45:41.480] SequentialFuture:
[17:45:41.480] Label: ‘future_mapply-1’
[17:45:41.480] Expression:
[17:45:41.480] {
[17:45:41.480]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:41.480]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:41.480]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:41.480]         on.exit(options(oopts), add = TRUE)
[17:45:41.480]     }
[17:45:41.480]     {
[17:45:41.480]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:41.480]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:41.480]         do.call(mapply, args = args)
[17:45:41.480]     }
[17:45:41.480] }
[17:45:41.480] Lazy evaluation: FALSE
[17:45:41.480] Asynchronous evaluation: FALSE
[17:45:41.480] Local evaluation: TRUE
[17:45:41.480] Environment: R_GlobalEnv
[17:45:41.480] Capture standard output: NA
[17:45:41.480] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:41.480] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:41.480] Packages: <none>
[17:45:41.480] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:41.480] Resolved: TRUE
[17:45:41.480] Value: 224 bytes of class ‘list’
[17:45:41.480] Early signaling: FALSE
[17:45:41.480] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:41.480] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:41.481] Chunk #1 of 1 ... DONE
[17:45:41.481] Launching 1 futures (chunks) ... DONE
[17:45:41.481] Resolving 1 futures (chunks) ...
[17:45:41.481] resolve() on list ...
[17:45:41.481]  recursive: 0
[17:45:41.481]  length: 1
[17:45:41.482] 
[17:45:41.482] resolved() for ‘SequentialFuture’ ...
[17:45:41.482] - state: ‘finished’
[17:45:41.482] - run: TRUE
[17:45:41.482] - result: ‘FutureResult’
[17:45:41.482] resolved() for ‘SequentialFuture’ ... done
[17:45:41.482] Future #1
[17:45:41.482] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:41.482] - nx: 1
[17:45:41.482] - relay: TRUE
[17:45:41.483] - stdout: TRUE
[17:45:41.483] - signal: TRUE
[17:45:41.483] - resignal: FALSE
[17:45:41.483] - force: TRUE
[17:45:41.483] - relayed: [n=1] FALSE
[17:45:41.483] - queued futures: [n=1] FALSE
[17:45:41.483]  - until=1
[17:45:41.483]  - relaying element #1
[17:45:41.483] - relayed: [n=1] TRUE
[17:45:41.483] - queued futures: [n=1] TRUE
[17:45:41.484] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:41.484]  length: 0 (resolved future 1)
[17:45:41.484] Relaying remaining futures
[17:45:41.484] signalConditionsASAP(NULL, pos=0) ...
[17:45:41.484] - nx: 1
[17:45:41.484] - relay: TRUE
[17:45:41.484] - stdout: TRUE
[17:45:41.484] - signal: TRUE
[17:45:41.484] - resignal: FALSE
[17:45:41.484] - force: TRUE
[17:45:41.484] - relayed: [n=1] TRUE
[17:45:41.484] - queued futures: [n=1] TRUE
 - flush all
[17:45:41.485] - relayed: [n=1] TRUE
[17:45:41.485] - queued futures: [n=1] TRUE
[17:45:41.485] signalConditionsASAP(NULL, pos=0) ... done
[17:45:41.485] resolve() on list ... DONE
[17:45:41.485]  - Number of value chunks collected: 1
[17:45:41.485] Resolving 1 futures (chunks) ... DONE
[17:45:41.485] Reducing values from 1 chunks ...
[17:45:41.485]  - Number of values collected after concatenation: 2
[17:45:41.485]  - Number of values expected: 2
[17:45:41.485] Reducing values from 1 chunks ... DONE
[17:45:41.486] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[17:45:41.491] plan(): Setting new future strategy stack:
[17:45:41.491] List of future strategies:
[17:45:41.491] 1. multicore:
[17:45:41.491]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:41.491]    - tweaked: FALSE
[17:45:41.491]    - call: plan(strategy)
[17:45:41.495] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:45:41.495] future_lapply() ...
[17:45:41.500] Number of chunks: 2
[17:45:41.500] getGlobalsAndPackagesXApply() ...
[17:45:41.501]  - future.globals: TRUE
[17:45:41.501] getGlobalsAndPackages() ...
[17:45:41.501] Searching for globals...
[17:45:41.502] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:41.502] Searching for globals ... DONE
[17:45:41.502] Resolving globals: FALSE
[17:45:41.503] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:41.503] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:41.503] - globals: [1] ‘FUN’
[17:45:41.503] 
[17:45:41.503] getGlobalsAndPackages() ... DONE
[17:45:41.503]  - globals found/used: [n=1] ‘FUN’
[17:45:41.504]  - needed namespaces: [n=0] 
[17:45:41.504] Finding globals ... DONE
[17:45:41.504]  - use_args: TRUE
[17:45:41.504]  - Getting '...' globals ...
[17:45:41.504] resolve() on list ...
[17:45:41.504]  recursive: 0
[17:45:41.504]  length: 1
[17:45:41.504]  elements: ‘...’
[17:45:41.505]  length: 0 (resolved future 1)
[17:45:41.505] resolve() on list ... DONE
[17:45:41.505]    - '...' content: [n=0] 
[17:45:41.505] List of 1
[17:45:41.505]  $ ...: list()
[17:45:41.505]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:41.505]  - attr(*, "where")=List of 1
[17:45:41.505]   ..$ ...:<environment: 0x55f6c6022a80> 
[17:45:41.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:41.505]  - attr(*, "resolved")= logi TRUE
[17:45:41.505]  - attr(*, "total_size")= num NA
[17:45:41.507]  - Getting '...' globals ... DONE
[17:45:41.507] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:41.508] List of 2
[17:45:41.508]  $ ...future.FUN:function (x)  
[17:45:41.508]  $ ...          : list()
[17:45:41.508]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:41.508]  - attr(*, "where")=List of 2
[17:45:41.508]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:41.508]   ..$ ...          :<environment: 0x55f6c6022a80> 
[17:45:41.508]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:41.508]  - attr(*, "resolved")= logi FALSE
[17:45:41.508]  - attr(*, "total_size")= num 4720
[17:45:41.510] Packages to be attached in all futures: [n=0] 
[17:45:41.510] getGlobalsAndPackagesXApply() ... DONE
[17:45:41.510] Number of futures (= number of chunks): 2
[17:45:41.511] Launching 2 futures (chunks) ...
[17:45:41.511] Chunk #1 of 2 ...
[17:45:41.511]  - Finding globals in 'X' for chunk #1 ...
[17:45:41.511] getGlobalsAndPackages() ...
[17:45:41.511] Searching for globals...
[17:45:41.511] 
[17:45:41.511] Searching for globals ... DONE
[17:45:41.511] - globals: [0] <none>
[17:45:41.511] getGlobalsAndPackages() ... DONE
[17:45:41.512]    + additional globals found: [n=0] 
[17:45:41.512]    + additional namespaces needed: [n=0] 
[17:45:41.512]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:41.512]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:41.512]  - seeds: <none>
[17:45:41.512]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:41.512] getGlobalsAndPackages() ...
[17:45:41.512] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:41.512] Resolving globals: FALSE
[17:45:41.512] Tweak future expression to call with '...' arguments ...
[17:45:41.513] {
[17:45:41.513]     do.call(function(...) {
[17:45:41.513]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:41.513]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:41.513]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:41.513]             on.exit(options(oopts), add = TRUE)
[17:45:41.513]         }
[17:45:41.513]         {
[17:45:41.513]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:41.513]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:41.513]                 ...future.FUN(...future.X_jj, ...)
[17:45:41.513]             })
[17:45:41.513]         }
[17:45:41.513]     }, args = future.call.arguments)
[17:45:41.513] }
[17:45:41.513] Tweak future expression to call with '...' arguments ... DONE
[17:45:41.513] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:41.513] 
[17:45:41.513] getGlobalsAndPackages() ... DONE
[17:45:41.514] run() for ‘Future’ ...
[17:45:41.514] - state: ‘created’
[17:45:41.514] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:41.517] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:41.518] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:41.518]   - Field: ‘label’
[17:45:41.518]   - Field: ‘local’
[17:45:41.518]   - Field: ‘owner’
[17:45:41.518]   - Field: ‘envir’
[17:45:41.518]   - Field: ‘workers’
[17:45:41.518]   - Field: ‘packages’
[17:45:41.518]   - Field: ‘gc’
[17:45:41.518]   - Field: ‘job’
[17:45:41.518]   - Field: ‘conditions’
[17:45:41.519]   - Field: ‘expr’
[17:45:41.519]   - Field: ‘uuid’
[17:45:41.519]   - Field: ‘seed’
[17:45:41.519]   - Field: ‘version’
[17:45:41.519]   - Field: ‘result’
[17:45:41.519]   - Field: ‘asynchronous’
[17:45:41.519]   - Field: ‘calls’
[17:45:41.519]   - Field: ‘globals’
[17:45:41.519]   - Field: ‘stdout’
[17:45:41.520]   - Field: ‘earlySignal’
[17:45:41.520]   - Field: ‘lazy’
[17:45:41.520]   - Field: ‘state’
[17:45:41.520] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:41.520] - Launch lazy future ...
[17:45:41.521] Packages needed by the future expression (n = 0): <none>
[17:45:41.521] Packages needed by future strategies (n = 0): <none>
[17:45:41.523] {
[17:45:41.523]     {
[17:45:41.523]         {
[17:45:41.523]             ...future.startTime <- base::Sys.time()
[17:45:41.523]             {
[17:45:41.523]                 {
[17:45:41.523]                   {
[17:45:41.523]                     {
[17:45:41.523]                       base::local({
[17:45:41.523]                         has_future <- base::requireNamespace("future", 
[17:45:41.523]                           quietly = TRUE)
[17:45:41.523]                         if (has_future) {
[17:45:41.523]                           ns <- base::getNamespace("future")
[17:45:41.523]                           version <- ns[[".package"]][["version"]]
[17:45:41.523]                           if (is.null(version)) 
[17:45:41.523]                             version <- utils::packageVersion("future")
[17:45:41.523]                         }
[17:45:41.523]                         else {
[17:45:41.523]                           version <- NULL
[17:45:41.523]                         }
[17:45:41.523]                         if (!has_future || version < "1.8.0") {
[17:45:41.523]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:41.523]                             "", base::R.version$version.string), 
[17:45:41.523]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:41.523]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:41.523]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:41.523]                               "release", "version")], collapse = " "), 
[17:45:41.523]                             hostname = base::Sys.info()[["nodename"]])
[17:45:41.523]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:41.523]                             info)
[17:45:41.523]                           info <- base::paste(info, collapse = "; ")
[17:45:41.523]                           if (!has_future) {
[17:45:41.523]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:41.523]                               info)
[17:45:41.523]                           }
[17:45:41.523]                           else {
[17:45:41.523]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:41.523]                               info, version)
[17:45:41.523]                           }
[17:45:41.523]                           base::stop(msg)
[17:45:41.523]                         }
[17:45:41.523]                       })
[17:45:41.523]                     }
[17:45:41.523]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:41.523]                     base::options(mc.cores = 1L)
[17:45:41.523]                   }
[17:45:41.523]                   ...future.strategy.old <- future::plan("list")
[17:45:41.523]                   options(future.plan = NULL)
[17:45:41.523]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:41.523]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:41.523]                 }
[17:45:41.523]                 ...future.workdir <- getwd()
[17:45:41.523]             }
[17:45:41.523]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:41.523]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:41.523]         }
[17:45:41.523]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:41.523]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:41.523]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:41.523]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:41.523]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:41.523]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:41.523]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:41.523]             base::names(...future.oldOptions))
[17:45:41.523]     }
[17:45:41.523]     if (FALSE) {
[17:45:41.523]     }
[17:45:41.523]     else {
[17:45:41.523]         if (FALSE) {
[17:45:41.523]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:41.523]                 open = "w")
[17:45:41.523]         }
[17:45:41.523]         else {
[17:45:41.523]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:41.523]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:41.523]         }
[17:45:41.523]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:41.523]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:41.523]             base::sink(type = "output", split = FALSE)
[17:45:41.523]             base::close(...future.stdout)
[17:45:41.523]         }, add = TRUE)
[17:45:41.523]     }
[17:45:41.523]     ...future.frame <- base::sys.nframe()
[17:45:41.523]     ...future.conditions <- base::list()
[17:45:41.523]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:41.523]     if (FALSE) {
[17:45:41.523]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:41.523]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:41.523]     }
[17:45:41.523]     ...future.result <- base::tryCatch({
[17:45:41.523]         base::withCallingHandlers({
[17:45:41.523]             ...future.value <- base::withVisible(base::local({
[17:45:41.523]                 withCallingHandlers({
[17:45:41.523]                   {
[17:45:41.523]                     do.call(function(...) {
[17:45:41.523]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:41.523]                       if (!identical(...future.globals.maxSize.org, 
[17:45:41.523]                         ...future.globals.maxSize)) {
[17:45:41.523]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:41.523]                         on.exit(options(oopts), add = TRUE)
[17:45:41.523]                       }
[17:45:41.523]                       {
[17:45:41.523]                         lapply(seq_along(...future.elements_ii), 
[17:45:41.523]                           FUN = function(jj) {
[17:45:41.523]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:41.523]                             ...future.FUN(...future.X_jj, ...)
[17:45:41.523]                           })
[17:45:41.523]                       }
[17:45:41.523]                     }, args = future.call.arguments)
[17:45:41.523]                   }
[17:45:41.523]                 }, immediateCondition = function(cond) {
[17:45:41.523]                   save_rds <- function (object, pathname, ...) 
[17:45:41.523]                   {
[17:45:41.523]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:41.523]                     if (file_test("-f", pathname_tmp)) {
[17:45:41.523]                       fi_tmp <- file.info(pathname_tmp)
[17:45:41.523]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:41.523]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:41.523]                         fi_tmp[["mtime"]])
[17:45:41.523]                     }
[17:45:41.523]                     tryCatch({
[17:45:41.523]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:41.523]                     }, error = function(ex) {
[17:45:41.523]                       msg <- conditionMessage(ex)
[17:45:41.523]                       fi_tmp <- file.info(pathname_tmp)
[17:45:41.523]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:41.523]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:41.523]                         fi_tmp[["mtime"]], msg)
[17:45:41.523]                       ex$message <- msg
[17:45:41.523]                       stop(ex)
[17:45:41.523]                     })
[17:45:41.523]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:41.523]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:41.523]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:41.523]                       fi_tmp <- file.info(pathname_tmp)
[17:45:41.523]                       fi <- file.info(pathname)
[17:45:41.523]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:41.523]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:41.523]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:41.523]                         fi[["size"]], fi[["mtime"]])
[17:45:41.523]                       stop(msg)
[17:45:41.523]                     }
[17:45:41.523]                     invisible(pathname)
[17:45:41.523]                   }
[17:45:41.523]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:41.523]                     rootPath = tempdir()) 
[17:45:41.523]                   {
[17:45:41.523]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:41.523]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:41.523]                       tmpdir = path, fileext = ".rds")
[17:45:41.523]                     save_rds(obj, file)
[17:45:41.523]                   }
[17:45:41.523]                   saveImmediateCondition(cond, path = "/tmp/RtmpnHaLG7/.future/immediateConditions")
[17:45:41.523]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:41.523]                   {
[17:45:41.523]                     inherits <- base::inherits
[17:45:41.523]                     invokeRestart <- base::invokeRestart
[17:45:41.523]                     is.null <- base::is.null
[17:45:41.523]                     muffled <- FALSE
[17:45:41.523]                     if (inherits(cond, "message")) {
[17:45:41.523]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:41.523]                       if (muffled) 
[17:45:41.523]                         invokeRestart("muffleMessage")
[17:45:41.523]                     }
[17:45:41.523]                     else if (inherits(cond, "warning")) {
[17:45:41.523]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:41.523]                       if (muffled) 
[17:45:41.523]                         invokeRestart("muffleWarning")
[17:45:41.523]                     }
[17:45:41.523]                     else if (inherits(cond, "condition")) {
[17:45:41.523]                       if (!is.null(pattern)) {
[17:45:41.523]                         computeRestarts <- base::computeRestarts
[17:45:41.523]                         grepl <- base::grepl
[17:45:41.523]                         restarts <- computeRestarts(cond)
[17:45:41.523]                         for (restart in restarts) {
[17:45:41.523]                           name <- restart$name
[17:45:41.523]                           if (is.null(name)) 
[17:45:41.523]                             next
[17:45:41.523]                           if (!grepl(pattern, name)) 
[17:45:41.523]                             next
[17:45:41.523]                           invokeRestart(restart)
[17:45:41.523]                           muffled <- TRUE
[17:45:41.523]                           break
[17:45:41.523]                         }
[17:45:41.523]                       }
[17:45:41.523]                     }
[17:45:41.523]                     invisible(muffled)
[17:45:41.523]                   }
[17:45:41.523]                   muffleCondition(cond)
[17:45:41.523]                 })
[17:45:41.523]             }))
[17:45:41.523]             future::FutureResult(value = ...future.value$value, 
[17:45:41.523]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:41.523]                   ...future.rng), globalenv = if (FALSE) 
[17:45:41.523]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:41.523]                     ...future.globalenv.names))
[17:45:41.523]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:41.523]         }, condition = base::local({
[17:45:41.523]             c <- base::c
[17:45:41.523]             inherits <- base::inherits
[17:45:41.523]             invokeRestart <- base::invokeRestart
[17:45:41.523]             length <- base::length
[17:45:41.523]             list <- base::list
[17:45:41.523]             seq.int <- base::seq.int
[17:45:41.523]             signalCondition <- base::signalCondition
[17:45:41.523]             sys.calls <- base::sys.calls
[17:45:41.523]             `[[` <- base::`[[`
[17:45:41.523]             `+` <- base::`+`
[17:45:41.523]             `<<-` <- base::`<<-`
[17:45:41.523]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:41.523]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:41.523]                   3L)]
[17:45:41.523]             }
[17:45:41.523]             function(cond) {
[17:45:41.523]                 is_error <- inherits(cond, "error")
[17:45:41.523]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:41.523]                   NULL)
[17:45:41.523]                 if (is_error) {
[17:45:41.523]                   sessionInformation <- function() {
[17:45:41.523]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:41.523]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:41.523]                       search = base::search(), system = base::Sys.info())
[17:45:41.523]                   }
[17:45:41.523]                   ...future.conditions[[length(...future.conditions) + 
[17:45:41.523]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:41.523]                     cond$call), session = sessionInformation(), 
[17:45:41.523]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:41.523]                   signalCondition(cond)
[17:45:41.523]                 }
[17:45:41.523]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:41.523]                 "immediateCondition"))) {
[17:45:41.523]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:41.523]                   ...future.conditions[[length(...future.conditions) + 
[17:45:41.523]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:41.523]                   if (TRUE && !signal) {
[17:45:41.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:41.523]                     {
[17:45:41.523]                       inherits <- base::inherits
[17:45:41.523]                       invokeRestart <- base::invokeRestart
[17:45:41.523]                       is.null <- base::is.null
[17:45:41.523]                       muffled <- FALSE
[17:45:41.523]                       if (inherits(cond, "message")) {
[17:45:41.523]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:41.523]                         if (muffled) 
[17:45:41.523]                           invokeRestart("muffleMessage")
[17:45:41.523]                       }
[17:45:41.523]                       else if (inherits(cond, "warning")) {
[17:45:41.523]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:41.523]                         if (muffled) 
[17:45:41.523]                           invokeRestart("muffleWarning")
[17:45:41.523]                       }
[17:45:41.523]                       else if (inherits(cond, "condition")) {
[17:45:41.523]                         if (!is.null(pattern)) {
[17:45:41.523]                           computeRestarts <- base::computeRestarts
[17:45:41.523]                           grepl <- base::grepl
[17:45:41.523]                           restarts <- computeRestarts(cond)
[17:45:41.523]                           for (restart in restarts) {
[17:45:41.523]                             name <- restart$name
[17:45:41.523]                             if (is.null(name)) 
[17:45:41.523]                               next
[17:45:41.523]                             if (!grepl(pattern, name)) 
[17:45:41.523]                               next
[17:45:41.523]                             invokeRestart(restart)
[17:45:41.523]                             muffled <- TRUE
[17:45:41.523]                             break
[17:45:41.523]                           }
[17:45:41.523]                         }
[17:45:41.523]                       }
[17:45:41.523]                       invisible(muffled)
[17:45:41.523]                     }
[17:45:41.523]                     muffleCondition(cond, pattern = "^muffle")
[17:45:41.523]                   }
[17:45:41.523]                 }
[17:45:41.523]                 else {
[17:45:41.523]                   if (TRUE) {
[17:45:41.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:41.523]                     {
[17:45:41.523]                       inherits <- base::inherits
[17:45:41.523]                       invokeRestart <- base::invokeRestart
[17:45:41.523]                       is.null <- base::is.null
[17:45:41.523]                       muffled <- FALSE
[17:45:41.523]                       if (inherits(cond, "message")) {
[17:45:41.523]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:41.523]                         if (muffled) 
[17:45:41.523]                           invokeRestart("muffleMessage")
[17:45:41.523]                       }
[17:45:41.523]                       else if (inherits(cond, "warning")) {
[17:45:41.523]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:41.523]                         if (muffled) 
[17:45:41.523]                           invokeRestart("muffleWarning")
[17:45:41.523]                       }
[17:45:41.523]                       else if (inherits(cond, "condition")) {
[17:45:41.523]                         if (!is.null(pattern)) {
[17:45:41.523]                           computeRestarts <- base::computeRestarts
[17:45:41.523]                           grepl <- base::grepl
[17:45:41.523]                           restarts <- computeRestarts(cond)
[17:45:41.523]                           for (restart in restarts) {
[17:45:41.523]                             name <- restart$name
[17:45:41.523]                             if (is.null(name)) 
[17:45:41.523]                               next
[17:45:41.523]                             if (!grepl(pattern, name)) 
[17:45:41.523]                               next
[17:45:41.523]                             invokeRestart(restart)
[17:45:41.523]                             muffled <- TRUE
[17:45:41.523]                             break
[17:45:41.523]                           }
[17:45:41.523]                         }
[17:45:41.523]                       }
[17:45:41.523]                       invisible(muffled)
[17:45:41.523]                     }
[17:45:41.523]                     muffleCondition(cond, pattern = "^muffle")
[17:45:41.523]                   }
[17:45:41.523]                 }
[17:45:41.523]             }
[17:45:41.523]         }))
[17:45:41.523]     }, error = function(ex) {
[17:45:41.523]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:41.523]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:41.523]                 ...future.rng), started = ...future.startTime, 
[17:45:41.523]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:41.523]             version = "1.8"), class = "FutureResult")
[17:45:41.523]     }, finally = {
[17:45:41.523]         if (!identical(...future.workdir, getwd())) 
[17:45:41.523]             setwd(...future.workdir)
[17:45:41.523]         {
[17:45:41.523]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:41.523]                 ...future.oldOptions$nwarnings <- NULL
[17:45:41.523]             }
[17:45:41.523]             base::options(...future.oldOptions)
[17:45:41.523]             if (.Platform$OS.type == "windows") {
[17:45:41.523]                 old_names <- names(...future.oldEnvVars)
[17:45:41.523]                 envs <- base::Sys.getenv()
[17:45:41.523]                 names <- names(envs)
[17:45:41.523]                 common <- intersect(names, old_names)
[17:45:41.523]                 added <- setdiff(names, old_names)
[17:45:41.523]                 removed <- setdiff(old_names, names)
[17:45:41.523]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:41.523]                   envs[common]]
[17:45:41.523]                 NAMES <- toupper(changed)
[17:45:41.523]                 args <- list()
[17:45:41.523]                 for (kk in seq_along(NAMES)) {
[17:45:41.523]                   name <- changed[[kk]]
[17:45:41.523]                   NAME <- NAMES[[kk]]
[17:45:41.523]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:41.523]                     next
[17:45:41.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:41.523]                 }
[17:45:41.523]                 NAMES <- toupper(added)
[17:45:41.523]                 for (kk in seq_along(NAMES)) {
[17:45:41.523]                   name <- added[[kk]]
[17:45:41.523]                   NAME <- NAMES[[kk]]
[17:45:41.523]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:41.523]                     next
[17:45:41.523]                   args[[name]] <- ""
[17:45:41.523]                 }
[17:45:41.523]                 NAMES <- toupper(removed)
[17:45:41.523]                 for (kk in seq_along(NAMES)) {
[17:45:41.523]                   name <- removed[[kk]]
[17:45:41.523]                   NAME <- NAMES[[kk]]
[17:45:41.523]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:41.523]                     next
[17:45:41.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:41.523]                 }
[17:45:41.523]                 if (length(args) > 0) 
[17:45:41.523]                   base::do.call(base::Sys.setenv, args = args)
[17:45:41.523]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:41.523]             }
[17:45:41.523]             else {
[17:45:41.523]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:41.523]             }
[17:45:41.523]             {
[17:45:41.523]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:41.523]                   0L) {
[17:45:41.523]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:41.523]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:41.523]                   base::options(opts)
[17:45:41.523]                 }
[17:45:41.523]                 {
[17:45:41.523]                   {
[17:45:41.523]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:41.523]                     NULL
[17:45:41.523]                   }
[17:45:41.523]                   options(future.plan = NULL)
[17:45:41.523]                   if (is.na(NA_character_)) 
[17:45:41.523]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:41.523]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:41.523]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:41.523]                     .init = FALSE)
[17:45:41.523]                 }
[17:45:41.523]             }
[17:45:41.523]         }
[17:45:41.523]     })
[17:45:41.523]     if (TRUE) {
[17:45:41.523]         base::sink(type = "output", split = FALSE)
[17:45:41.523]         if (FALSE) {
[17:45:41.523]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:41.523]         }
[17:45:41.523]         else {
[17:45:41.523]             ...future.result["stdout"] <- base::list(NULL)
[17:45:41.523]         }
[17:45:41.523]         base::close(...future.stdout)
[17:45:41.523]         ...future.stdout <- NULL
[17:45:41.523]     }
[17:45:41.523]     ...future.result$conditions <- ...future.conditions
[17:45:41.523]     ...future.result$finished <- base::Sys.time()
[17:45:41.523]     ...future.result
[17:45:41.523] }
[17:45:41.526] assign_globals() ...
[17:45:41.526] List of 5
[17:45:41.526]  $ ...future.FUN            :function (x)  
[17:45:41.526]  $ future.call.arguments    : list()
[17:45:41.526]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:41.526]  $ ...future.elements_ii    :List of 1
[17:45:41.526]   ..$ : int 1
[17:45:41.526]  $ ...future.seeds_ii       : NULL
[17:45:41.526]  $ ...future.globals.maxSize: NULL
[17:45:41.526]  - attr(*, "where")=List of 5
[17:45:41.526]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:41.526]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:41.526]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:41.526]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:41.526]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:41.526]  - attr(*, "resolved")= logi FALSE
[17:45:41.526]  - attr(*, "total_size")= num 4720
[17:45:41.526]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:41.526]  - attr(*, "already-done")= logi TRUE
[17:45:41.530] - reassign environment for ‘...future.FUN’
[17:45:41.530] - copied ‘...future.FUN’ to environment
[17:45:41.530] - copied ‘future.call.arguments’ to environment
[17:45:41.531] - copied ‘...future.elements_ii’ to environment
[17:45:41.531] - copied ‘...future.seeds_ii’ to environment
[17:45:41.531] - copied ‘...future.globals.maxSize’ to environment
[17:45:41.531] assign_globals() ... done
[17:45:41.531] requestCore(): workers = 2
[17:45:41.534] MulticoreFuture started
[17:45:41.535] - Launch lazy future ... done
[17:45:41.535] plan(): Setting new future strategy stack:
[17:45:41.535] run() for ‘MulticoreFuture’ ... done
[17:45:41.535] Created future:
[17:45:41.535] List of future strategies:
[17:45:41.535] 1. sequential:
[17:45:41.535]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:41.535]    - tweaked: FALSE
[17:45:41.535]    - call: NULL
[17:45:41.536] plan(): nbrOfWorkers() = 1
[17:45:41.536] MulticoreFuture:
[17:45:41.536] Label: ‘future_lapply-1’
[17:45:41.536] Expression:
[17:45:41.536] {
[17:45:41.536]     do.call(function(...) {
[17:45:41.536]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:41.536]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:41.536]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:41.536]             on.exit(options(oopts), add = TRUE)
[17:45:41.536]         }
[17:45:41.536]         {
[17:45:41.536]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:41.536]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:41.536]                 ...future.FUN(...future.X_jj, ...)
[17:45:41.536]             })
[17:45:41.536]         }
[17:45:41.536]     }, args = future.call.arguments)
[17:45:41.536] }
[17:45:41.536] Lazy evaluation: FALSE
[17:45:41.536] Asynchronous evaluation: TRUE
[17:45:41.536] Local evaluation: TRUE
[17:45:41.536] Environment: R_GlobalEnv
[17:45:41.536] Capture standard output: FALSE
[17:45:41.536] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:41.536] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:41.536] Packages: <none>
[17:45:41.536] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:41.536] Resolved: FALSE
[17:45:41.536] Value: <not collected>
[17:45:41.536] Conditions captured: <none>
[17:45:41.536] Early signaling: FALSE
[17:45:41.536] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:41.536] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:41.551] Chunk #1 of 2 ... DONE
[17:45:41.551] Chunk #2 of 2 ...
[17:45:41.551]  - Finding globals in 'X' for chunk #2 ...
[17:45:41.551] getGlobalsAndPackages() ...
[17:45:41.551] Searching for globals...
[17:45:41.552] 
[17:45:41.552] Searching for globals ... DONE
[17:45:41.552] - globals: [0] <none>
[17:45:41.552] getGlobalsAndPackages() ... DONE
[17:45:41.553]    + additional globals found: [n=0] 
[17:45:41.553]    + additional namespaces needed: [n=0] 
[17:45:41.553]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:41.553]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:41.553]  - seeds: <none>
[17:45:41.553]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:41.554] getGlobalsAndPackages() ...
[17:45:41.554] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:41.554] Resolving globals: FALSE
[17:45:41.554] Tweak future expression to call with '...' arguments ...
[17:45:41.554] {
[17:45:41.554]     do.call(function(...) {
[17:45:41.554]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:41.554]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:41.554]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:41.554]             on.exit(options(oopts), add = TRUE)
[17:45:41.554]         }
[17:45:41.554]         {
[17:45:41.554]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:41.554]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:41.554]                 ...future.FUN(...future.X_jj, ...)
[17:45:41.554]             })
[17:45:41.554]         }
[17:45:41.554]     }, args = future.call.arguments)
[17:45:41.554] }
[17:45:41.555] Tweak future expression to call with '...' arguments ... DONE
[17:45:41.555] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:41.556] 
[17:45:41.556] getGlobalsAndPackages() ... DONE
[17:45:41.556] run() for ‘Future’ ...
[17:45:41.556] - state: ‘created’
[17:45:41.557] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:41.561] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:41.562] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:41.562]   - Field: ‘label’
[17:45:41.562]   - Field: ‘local’
[17:45:41.562]   - Field: ‘owner’
[17:45:41.562]   - Field: ‘envir’
[17:45:41.562]   - Field: ‘workers’
[17:45:41.562]   - Field: ‘packages’
[17:45:41.563]   - Field: ‘gc’
[17:45:41.563]   - Field: ‘job’
[17:45:41.563]   - Field: ‘conditions’
[17:45:41.563]   - Field: ‘expr’
[17:45:41.563]   - Field: ‘uuid’
[17:45:41.563]   - Field: ‘seed’
[17:45:41.564]   - Field: ‘version’
[17:45:41.564]   - Field: ‘result’
[17:45:41.564]   - Field: ‘asynchronous’
[17:45:41.564]   - Field: ‘calls’
[17:45:41.564]   - Field: ‘globals’
[17:45:41.564]   - Field: ‘stdout’
[17:45:41.564]   - Field: ‘earlySignal’
[17:45:41.565]   - Field: ‘lazy’
[17:45:41.565]   - Field: ‘state’
[17:45:41.565] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:41.565] - Launch lazy future ...
[17:45:41.566] Packages needed by the future expression (n = 0): <none>
[17:45:41.566] Packages needed by future strategies (n = 0): <none>
[17:45:41.567] {
[17:45:41.567]     {
[17:45:41.567]         {
[17:45:41.567]             ...future.startTime <- base::Sys.time()
[17:45:41.567]             {
[17:45:41.567]                 {
[17:45:41.567]                   {
[17:45:41.567]                     {
[17:45:41.567]                       base::local({
[17:45:41.567]                         has_future <- base::requireNamespace("future", 
[17:45:41.567]                           quietly = TRUE)
[17:45:41.567]                         if (has_future) {
[17:45:41.567]                           ns <- base::getNamespace("future")
[17:45:41.567]                           version <- ns[[".package"]][["version"]]
[17:45:41.567]                           if (is.null(version)) 
[17:45:41.567]                             version <- utils::packageVersion("future")
[17:45:41.567]                         }
[17:45:41.567]                         else {
[17:45:41.567]                           version <- NULL
[17:45:41.567]                         }
[17:45:41.567]                         if (!has_future || version < "1.8.0") {
[17:45:41.567]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:41.567]                             "", base::R.version$version.string), 
[17:45:41.567]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:41.567]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:41.567]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:41.567]                               "release", "version")], collapse = " "), 
[17:45:41.567]                             hostname = base::Sys.info()[["nodename"]])
[17:45:41.567]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:41.567]                             info)
[17:45:41.567]                           info <- base::paste(info, collapse = "; ")
[17:45:41.567]                           if (!has_future) {
[17:45:41.567]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:41.567]                               info)
[17:45:41.567]                           }
[17:45:41.567]                           else {
[17:45:41.567]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:41.567]                               info, version)
[17:45:41.567]                           }
[17:45:41.567]                           base::stop(msg)
[17:45:41.567]                         }
[17:45:41.567]                       })
[17:45:41.567]                     }
[17:45:41.567]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:41.567]                     base::options(mc.cores = 1L)
[17:45:41.567]                   }
[17:45:41.567]                   ...future.strategy.old <- future::plan("list")
[17:45:41.567]                   options(future.plan = NULL)
[17:45:41.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:41.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:41.567]                 }
[17:45:41.567]                 ...future.workdir <- getwd()
[17:45:41.567]             }
[17:45:41.567]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:41.567]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:41.567]         }
[17:45:41.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:41.567]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:41.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:41.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:41.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:41.567]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:41.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:41.567]             base::names(...future.oldOptions))
[17:45:41.567]     }
[17:45:41.567]     if (FALSE) {
[17:45:41.567]     }
[17:45:41.567]     else {
[17:45:41.567]         if (FALSE) {
[17:45:41.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:41.567]                 open = "w")
[17:45:41.567]         }
[17:45:41.567]         else {
[17:45:41.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:41.567]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:41.567]         }
[17:45:41.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:41.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:41.567]             base::sink(type = "output", split = FALSE)
[17:45:41.567]             base::close(...future.stdout)
[17:45:41.567]         }, add = TRUE)
[17:45:41.567]     }
[17:45:41.567]     ...future.frame <- base::sys.nframe()
[17:45:41.567]     ...future.conditions <- base::list()
[17:45:41.567]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:41.567]     if (FALSE) {
[17:45:41.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:41.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:41.567]     }
[17:45:41.567]     ...future.result <- base::tryCatch({
[17:45:41.567]         base::withCallingHandlers({
[17:45:41.567]             ...future.value <- base::withVisible(base::local({
[17:45:41.567]                 withCallingHandlers({
[17:45:41.567]                   {
[17:45:41.567]                     do.call(function(...) {
[17:45:41.567]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:41.567]                       if (!identical(...future.globals.maxSize.org, 
[17:45:41.567]                         ...future.globals.maxSize)) {
[17:45:41.567]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:41.567]                         on.exit(options(oopts), add = TRUE)
[17:45:41.567]                       }
[17:45:41.567]                       {
[17:45:41.567]                         lapply(seq_along(...future.elements_ii), 
[17:45:41.567]                           FUN = function(jj) {
[17:45:41.567]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:41.567]                             ...future.FUN(...future.X_jj, ...)
[17:45:41.567]                           })
[17:45:41.567]                       }
[17:45:41.567]                     }, args = future.call.arguments)
[17:45:41.567]                   }
[17:45:41.567]                 }, immediateCondition = function(cond) {
[17:45:41.567]                   save_rds <- function (object, pathname, ...) 
[17:45:41.567]                   {
[17:45:41.567]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:41.567]                     if (file_test("-f", pathname_tmp)) {
[17:45:41.567]                       fi_tmp <- file.info(pathname_tmp)
[17:45:41.567]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:41.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:41.567]                         fi_tmp[["mtime"]])
[17:45:41.567]                     }
[17:45:41.567]                     tryCatch({
[17:45:41.567]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:41.567]                     }, error = function(ex) {
[17:45:41.567]                       msg <- conditionMessage(ex)
[17:45:41.567]                       fi_tmp <- file.info(pathname_tmp)
[17:45:41.567]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:41.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:41.567]                         fi_tmp[["mtime"]], msg)
[17:45:41.567]                       ex$message <- msg
[17:45:41.567]                       stop(ex)
[17:45:41.567]                     })
[17:45:41.567]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:41.567]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:41.567]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:41.567]                       fi_tmp <- file.info(pathname_tmp)
[17:45:41.567]                       fi <- file.info(pathname)
[17:45:41.567]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:41.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:41.567]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:41.567]                         fi[["size"]], fi[["mtime"]])
[17:45:41.567]                       stop(msg)
[17:45:41.567]                     }
[17:45:41.567]                     invisible(pathname)
[17:45:41.567]                   }
[17:45:41.567]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:41.567]                     rootPath = tempdir()) 
[17:45:41.567]                   {
[17:45:41.567]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:41.567]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:41.567]                       tmpdir = path, fileext = ".rds")
[17:45:41.567]                     save_rds(obj, file)
[17:45:41.567]                   }
[17:45:41.567]                   saveImmediateCondition(cond, path = "/tmp/RtmpnHaLG7/.future/immediateConditions")
[17:45:41.567]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:41.567]                   {
[17:45:41.567]                     inherits <- base::inherits
[17:45:41.567]                     invokeRestart <- base::invokeRestart
[17:45:41.567]                     is.null <- base::is.null
[17:45:41.567]                     muffled <- FALSE
[17:45:41.567]                     if (inherits(cond, "message")) {
[17:45:41.567]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:41.567]                       if (muffled) 
[17:45:41.567]                         invokeRestart("muffleMessage")
[17:45:41.567]                     }
[17:45:41.567]                     else if (inherits(cond, "warning")) {
[17:45:41.567]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:41.567]                       if (muffled) 
[17:45:41.567]                         invokeRestart("muffleWarning")
[17:45:41.567]                     }
[17:45:41.567]                     else if (inherits(cond, "condition")) {
[17:45:41.567]                       if (!is.null(pattern)) {
[17:45:41.567]                         computeRestarts <- base::computeRestarts
[17:45:41.567]                         grepl <- base::grepl
[17:45:41.567]                         restarts <- computeRestarts(cond)
[17:45:41.567]                         for (restart in restarts) {
[17:45:41.567]                           name <- restart$name
[17:45:41.567]                           if (is.null(name)) 
[17:45:41.567]                             next
[17:45:41.567]                           if (!grepl(pattern, name)) 
[17:45:41.567]                             next
[17:45:41.567]                           invokeRestart(restart)
[17:45:41.567]                           muffled <- TRUE
[17:45:41.567]                           break
[17:45:41.567]                         }
[17:45:41.567]                       }
[17:45:41.567]                     }
[17:45:41.567]                     invisible(muffled)
[17:45:41.567]                   }
[17:45:41.567]                   muffleCondition(cond)
[17:45:41.567]                 })
[17:45:41.567]             }))
[17:45:41.567]             future::FutureResult(value = ...future.value$value, 
[17:45:41.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:41.567]                   ...future.rng), globalenv = if (FALSE) 
[17:45:41.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:41.567]                     ...future.globalenv.names))
[17:45:41.567]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:41.567]         }, condition = base::local({
[17:45:41.567]             c <- base::c
[17:45:41.567]             inherits <- base::inherits
[17:45:41.567]             invokeRestart <- base::invokeRestart
[17:45:41.567]             length <- base::length
[17:45:41.567]             list <- base::list
[17:45:41.567]             seq.int <- base::seq.int
[17:45:41.567]             signalCondition <- base::signalCondition
[17:45:41.567]             sys.calls <- base::sys.calls
[17:45:41.567]             `[[` <- base::`[[`
[17:45:41.567]             `+` <- base::`+`
[17:45:41.567]             `<<-` <- base::`<<-`
[17:45:41.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:41.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:41.567]                   3L)]
[17:45:41.567]             }
[17:45:41.567]             function(cond) {
[17:45:41.567]                 is_error <- inherits(cond, "error")
[17:45:41.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:41.567]                   NULL)
[17:45:41.567]                 if (is_error) {
[17:45:41.567]                   sessionInformation <- function() {
[17:45:41.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:41.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:41.567]                       search = base::search(), system = base::Sys.info())
[17:45:41.567]                   }
[17:45:41.567]                   ...future.conditions[[length(...future.conditions) + 
[17:45:41.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:41.567]                     cond$call), session = sessionInformation(), 
[17:45:41.567]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:41.567]                   signalCondition(cond)
[17:45:41.567]                 }
[17:45:41.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:41.567]                 "immediateCondition"))) {
[17:45:41.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:41.567]                   ...future.conditions[[length(...future.conditions) + 
[17:45:41.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:41.567]                   if (TRUE && !signal) {
[17:45:41.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:41.567]                     {
[17:45:41.567]                       inherits <- base::inherits
[17:45:41.567]                       invokeRestart <- base::invokeRestart
[17:45:41.567]                       is.null <- base::is.null
[17:45:41.567]                       muffled <- FALSE
[17:45:41.567]                       if (inherits(cond, "message")) {
[17:45:41.567]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:41.567]                         if (muffled) 
[17:45:41.567]                           invokeRestart("muffleMessage")
[17:45:41.567]                       }
[17:45:41.567]                       else if (inherits(cond, "warning")) {
[17:45:41.567]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:41.567]                         if (muffled) 
[17:45:41.567]                           invokeRestart("muffleWarning")
[17:45:41.567]                       }
[17:45:41.567]                       else if (inherits(cond, "condition")) {
[17:45:41.567]                         if (!is.null(pattern)) {
[17:45:41.567]                           computeRestarts <- base::computeRestarts
[17:45:41.567]                           grepl <- base::grepl
[17:45:41.567]                           restarts <- computeRestarts(cond)
[17:45:41.567]                           for (restart in restarts) {
[17:45:41.567]                             name <- restart$name
[17:45:41.567]                             if (is.null(name)) 
[17:45:41.567]                               next
[17:45:41.567]                             if (!grepl(pattern, name)) 
[17:45:41.567]                               next
[17:45:41.567]                             invokeRestart(restart)
[17:45:41.567]                             muffled <- TRUE
[17:45:41.567]                             break
[17:45:41.567]                           }
[17:45:41.567]                         }
[17:45:41.567]                       }
[17:45:41.567]                       invisible(muffled)
[17:45:41.567]                     }
[17:45:41.567]                     muffleCondition(cond, pattern = "^muffle")
[17:45:41.567]                   }
[17:45:41.567]                 }
[17:45:41.567]                 else {
[17:45:41.567]                   if (TRUE) {
[17:45:41.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:41.567]                     {
[17:45:41.567]                       inherits <- base::inherits
[17:45:41.567]                       invokeRestart <- base::invokeRestart
[17:45:41.567]                       is.null <- base::is.null
[17:45:41.567]                       muffled <- FALSE
[17:45:41.567]                       if (inherits(cond, "message")) {
[17:45:41.567]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:41.567]                         if (muffled) 
[17:45:41.567]                           invokeRestart("muffleMessage")
[17:45:41.567]                       }
[17:45:41.567]                       else if (inherits(cond, "warning")) {
[17:45:41.567]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:41.567]                         if (muffled) 
[17:45:41.567]                           invokeRestart("muffleWarning")
[17:45:41.567]                       }
[17:45:41.567]                       else if (inherits(cond, "condition")) {
[17:45:41.567]                         if (!is.null(pattern)) {
[17:45:41.567]                           computeRestarts <- base::computeRestarts
[17:45:41.567]                           grepl <- base::grepl
[17:45:41.567]                           restarts <- computeRestarts(cond)
[17:45:41.567]                           for (restart in restarts) {
[17:45:41.567]                             name <- restart$name
[17:45:41.567]                             if (is.null(name)) 
[17:45:41.567]                               next
[17:45:41.567]                             if (!grepl(pattern, name)) 
[17:45:41.567]                               next
[17:45:41.567]                             invokeRestart(restart)
[17:45:41.567]                             muffled <- TRUE
[17:45:41.567]                             break
[17:45:41.567]                           }
[17:45:41.567]                         }
[17:45:41.567]                       }
[17:45:41.567]                       invisible(muffled)
[17:45:41.567]                     }
[17:45:41.567]                     muffleCondition(cond, pattern = "^muffle")
[17:45:41.567]                   }
[17:45:41.567]                 }
[17:45:41.567]             }
[17:45:41.567]         }))
[17:45:41.567]     }, error = function(ex) {
[17:45:41.567]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:41.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:41.567]                 ...future.rng), started = ...future.startTime, 
[17:45:41.567]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:41.567]             version = "1.8"), class = "FutureResult")
[17:45:41.567]     }, finally = {
[17:45:41.567]         if (!identical(...future.workdir, getwd())) 
[17:45:41.567]             setwd(...future.workdir)
[17:45:41.567]         {
[17:45:41.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:41.567]                 ...future.oldOptions$nwarnings <- NULL
[17:45:41.567]             }
[17:45:41.567]             base::options(...future.oldOptions)
[17:45:41.567]             if (.Platform$OS.type == "windows") {
[17:45:41.567]                 old_names <- names(...future.oldEnvVars)
[17:45:41.567]                 envs <- base::Sys.getenv()
[17:45:41.567]                 names <- names(envs)
[17:45:41.567]                 common <- intersect(names, old_names)
[17:45:41.567]                 added <- setdiff(names, old_names)
[17:45:41.567]                 removed <- setdiff(old_names, names)
[17:45:41.567]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:41.567]                   envs[common]]
[17:45:41.567]                 NAMES <- toupper(changed)
[17:45:41.567]                 args <- list()
[17:45:41.567]                 for (kk in seq_along(NAMES)) {
[17:45:41.567]                   name <- changed[[kk]]
[17:45:41.567]                   NAME <- NAMES[[kk]]
[17:45:41.567]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:41.567]                     next
[17:45:41.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:41.567]                 }
[17:45:41.567]                 NAMES <- toupper(added)
[17:45:41.567]                 for (kk in seq_along(NAMES)) {
[17:45:41.567]                   name <- added[[kk]]
[17:45:41.567]                   NAME <- NAMES[[kk]]
[17:45:41.567]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:41.567]                     next
[17:45:41.567]                   args[[name]] <- ""
[17:45:41.567]                 }
[17:45:41.567]                 NAMES <- toupper(removed)
[17:45:41.567]                 for (kk in seq_along(NAMES)) {
[17:45:41.567]                   name <- removed[[kk]]
[17:45:41.567]                   NAME <- NAMES[[kk]]
[17:45:41.567]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:41.567]                     next
[17:45:41.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:41.567]                 }
[17:45:41.567]                 if (length(args) > 0) 
[17:45:41.567]                   base::do.call(base::Sys.setenv, args = args)
[17:45:41.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:41.567]             }
[17:45:41.567]             else {
[17:45:41.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:41.567]             }
[17:45:41.567]             {
[17:45:41.567]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:41.567]                   0L) {
[17:45:41.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:41.567]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:41.567]                   base::options(opts)
[17:45:41.567]                 }
[17:45:41.567]                 {
[17:45:41.567]                   {
[17:45:41.567]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:41.567]                     NULL
[17:45:41.567]                   }
[17:45:41.567]                   options(future.plan = NULL)
[17:45:41.567]                   if (is.na(NA_character_)) 
[17:45:41.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:41.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:41.567]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:41.567]                     .init = FALSE)
[17:45:41.567]                 }
[17:45:41.567]             }
[17:45:41.567]         }
[17:45:41.567]     })
[17:45:41.567]     if (TRUE) {
[17:45:41.567]         base::sink(type = "output", split = FALSE)
[17:45:41.567]         if (FALSE) {
[17:45:41.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:41.567]         }
[17:45:41.567]         else {
[17:45:41.567]             ...future.result["stdout"] <- base::list(NULL)
[17:45:41.567]         }
[17:45:41.567]         base::close(...future.stdout)
[17:45:41.567]         ...future.stdout <- NULL
[17:45:41.567]     }
[17:45:41.567]     ...future.result$conditions <- ...future.conditions
[17:45:41.567]     ...future.result$finished <- base::Sys.time()
[17:45:41.567]     ...future.result
[17:45:41.567] }
[17:45:41.570] assign_globals() ...
[17:45:41.570] List of 5
[17:45:41.570]  $ ...future.FUN            :function (x)  
[17:45:41.570]  $ future.call.arguments    : list()
[17:45:41.570]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:41.570]  $ ...future.elements_ii    :List of 1
[17:45:41.570]   ..$ : int 0
[17:45:41.570]  $ ...future.seeds_ii       : NULL
[17:45:41.570]  $ ...future.globals.maxSize: NULL
[17:45:41.570]  - attr(*, "where")=List of 5
[17:45:41.570]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:41.570]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:41.570]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:41.570]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:41.570]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:41.570]  - attr(*, "resolved")= logi FALSE
[17:45:41.570]  - attr(*, "total_size")= num 4720
[17:45:41.570]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:41.570]  - attr(*, "already-done")= logi TRUE
[17:45:41.577] - reassign environment for ‘...future.FUN’
[17:45:41.577] - copied ‘...future.FUN’ to environment
[17:45:41.577] - copied ‘future.call.arguments’ to environment
[17:45:41.577] - copied ‘...future.elements_ii’ to environment
[17:45:41.577] - copied ‘...future.seeds_ii’ to environment
[17:45:41.578] - copied ‘...future.globals.maxSize’ to environment
[17:45:41.578] assign_globals() ... done
[17:45:41.578] requestCore(): workers = 2
[17:45:41.588] MulticoreFuture started
[17:45:41.588] - Launch lazy future ... done
[17:45:41.589] plan(): Setting new future strategy stack:
[17:45:41.589] run() for ‘MulticoreFuture’ ... done
[17:45:41.589] Created future:
[17:45:41.589] List of future strategies:
[17:45:41.589] 1. sequential:
[17:45:41.589]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:41.589]    - tweaked: FALSE
[17:45:41.589]    - call: NULL
[17:45:41.591] plan(): nbrOfWorkers() = 1
[17:45:41.593] plan(): Setting new future strategy stack:
[17:45:41.593] List of future strategies:
[17:45:41.593] 1. multicore:
[17:45:41.593]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:41.593]    - tweaked: FALSE
[17:45:41.593]    - call: plan(strategy)
[17:45:41.599] plan(): nbrOfWorkers() = 2
[17:45:41.590] MulticoreFuture:
[17:45:41.590] Label: ‘future_lapply-2’
[17:45:41.590] Expression:
[17:45:41.590] {
[17:45:41.590]     do.call(function(...) {
[17:45:41.590]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:41.590]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:41.590]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:41.590]             on.exit(options(oopts), add = TRUE)
[17:45:41.590]         }
[17:45:41.590]         {
[17:45:41.590]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:41.590]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:41.590]                 ...future.FUN(...future.X_jj, ...)
[17:45:41.590]             })
[17:45:41.590]         }
[17:45:41.590]     }, args = future.call.arguments)
[17:45:41.590] }
[17:45:41.590] Lazy evaluation: FALSE
[17:45:41.590] Asynchronous evaluation: TRUE
[17:45:41.590] Local evaluation: TRUE
[17:45:41.590] Environment: R_GlobalEnv
[17:45:41.590] Capture standard output: FALSE
[17:45:41.590] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:41.590] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:41.590] Packages: <none>
[17:45:41.590] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:41.590] Resolved: TRUE
[17:45:41.590] Value: <not collected>
[17:45:41.590] Conditions captured: <none>
[17:45:41.590] Early signaling: FALSE
[17:45:41.590] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:41.590] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:41.600] Chunk #2 of 2 ... DONE
[17:45:41.600] Launching 2 futures (chunks) ... DONE
[17:45:41.600] Resolving 2 futures (chunks) ...
[17:45:41.601] resolve() on list ...
[17:45:41.601]  recursive: 0
[17:45:41.601]  length: 2
[17:45:41.601] 
[17:45:41.612] Future #2
[17:45:41.613] result() for MulticoreFuture ...
[17:45:41.615] result() for MulticoreFuture ...
[17:45:41.615] result() for MulticoreFuture ... done
[17:45:41.615] result() for MulticoreFuture ... done
[17:45:41.616] result() for MulticoreFuture ...
[17:45:41.616] result() for MulticoreFuture ... done
[17:45:41.616] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:41.616] - nx: 2
[17:45:41.616] - relay: TRUE
[17:45:41.616] - stdout: TRUE
[17:45:41.616] - signal: TRUE
[17:45:41.617] - resignal: FALSE
[17:45:41.617] - force: TRUE
[17:45:41.617] - relayed: [n=2] FALSE, FALSE
[17:45:41.617] - queued futures: [n=2] FALSE, FALSE
[17:45:41.617]  - until=1
[17:45:41.617]  - relaying element #1
[17:45:41.617] - relayed: [n=2] FALSE, FALSE
[17:45:41.617] - queued futures: [n=2] FALSE, TRUE
[17:45:41.618] signalConditionsASAP(NULL, pos=2) ... done
[17:45:41.618]  length: 1 (resolved future 2)
[17:45:42.039] plan(): Setting new future strategy stack:
[17:45:42.039] List of future strategies:
[17:45:42.039] 1. multicore:
[17:45:42.039]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:42.039]    - tweaked: FALSE
[17:45:42.039]    - call: plan(strategy)
[17:45:42.044] plan(): nbrOfWorkers() = 2
[17:45:42.044] Future #1
[17:45:42.044] result() for MulticoreFuture ...
[17:45:42.045] result() for MulticoreFuture ...
[17:45:42.045] result() for MulticoreFuture ... done
[17:45:42.045] result() for MulticoreFuture ... done
[17:45:42.046] result() for MulticoreFuture ...
[17:45:42.046] result() for MulticoreFuture ... done
[17:45:42.046] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:42.046] - nx: 2
[17:45:42.046] - relay: TRUE
[17:45:42.046] - stdout: TRUE
[17:45:42.047] - signal: TRUE
[17:45:42.047] - resignal: FALSE
[17:45:42.047] - force: TRUE
[17:45:42.047] - relayed: [n=2] FALSE, FALSE
[17:45:42.047] - queued futures: [n=2] FALSE, TRUE
[17:45:42.047]  - until=1
[17:45:42.047]  - relaying element #1
[17:45:42.048] result() for MulticoreFuture ...
[17:45:42.048] result() for MulticoreFuture ... done
[17:45:42.048] result() for MulticoreFuture ...
[17:45:42.048] result() for MulticoreFuture ... done
[17:45:42.048] result() for MulticoreFuture ...
[17:45:42.048] result() for MulticoreFuture ... done
[17:45:42.049] result() for MulticoreFuture ...
[17:45:42.049] result() for MulticoreFuture ... done
[17:45:42.049] - relayed: [n=2] TRUE, FALSE
[17:45:42.049] - queued futures: [n=2] TRUE, TRUE
[17:45:42.049] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:42.049]  length: 0 (resolved future 1)
[17:45:42.049] Relaying remaining futures
[17:45:42.050] signalConditionsASAP(NULL, pos=0) ...
[17:45:42.050] - nx: 2
[17:45:42.050] - relay: TRUE
[17:45:42.050] - stdout: TRUE
[17:45:42.050] - signal: TRUE
[17:45:42.050] - resignal: FALSE
[17:45:42.050] - force: TRUE
[17:45:42.050] - relayed: [n=2] TRUE, FALSE
[17:45:42.050] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:42.051]  - relaying element #2
[17:45:42.051] result() for MulticoreFuture ...
[17:45:42.051] result() for MulticoreFuture ... done
[17:45:42.051] result() for MulticoreFuture ...
[17:45:42.051] result() for MulticoreFuture ... done
[17:45:42.051] result() for MulticoreFuture ...
[17:45:42.051] result() for MulticoreFuture ... done
[17:45:42.051] result() for MulticoreFuture ...
[17:45:42.052] result() for MulticoreFuture ... done
[17:45:42.052] - relayed: [n=2] TRUE, TRUE
[17:45:42.052] - queued futures: [n=2] TRUE, TRUE
[17:45:42.052] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:45:42.052] resolve() on list ... DONE
[17:45:42.052] result() for MulticoreFuture ...
[17:45:42.052] result() for MulticoreFuture ... done
[17:45:42.052] result() for MulticoreFuture ...
[17:45:42.052] result() for MulticoreFuture ... done
[17:45:42.053] result() for MulticoreFuture ...
[17:45:42.053] result() for MulticoreFuture ... done
[17:45:42.053] result() for MulticoreFuture ...
[17:45:42.053] result() for MulticoreFuture ... done
[17:45:42.053]  - Number of value chunks collected: 2
[17:45:42.053] Resolving 2 futures (chunks) ... DONE
[17:45:42.053] Reducing values from 2 chunks ...
[17:45:42.053]  - Number of values collected after concatenation: 2
[17:45:42.053]  - Number of values expected: 2
[17:45:42.054] Reducing values from 2 chunks ... DONE
[17:45:42.054] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:45:42.054] future_lapply() ...
[17:45:42.059] Number of chunks: 2
[17:45:42.059] getGlobalsAndPackagesXApply() ...
[17:45:42.059]  - future.globals: TRUE
[17:45:42.059] getGlobalsAndPackages() ...
[17:45:42.059] Searching for globals...
[17:45:42.061] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:42.061] Searching for globals ... DONE
[17:45:42.061] Resolving globals: FALSE
[17:45:42.062] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:42.062] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:42.062] - globals: [1] ‘FUN’
[17:45:42.063] 
[17:45:42.063] getGlobalsAndPackages() ... DONE
[17:45:42.063]  - globals found/used: [n=1] ‘FUN’
[17:45:42.063]  - needed namespaces: [n=0] 
[17:45:42.063] Finding globals ... DONE
[17:45:42.063]  - use_args: TRUE
[17:45:42.063]  - Getting '...' globals ...
[17:45:42.064] resolve() on list ...
[17:45:42.064]  recursive: 0
[17:45:42.064]  length: 1
[17:45:42.064]  elements: ‘...’
[17:45:42.064]  length: 0 (resolved future 1)
[17:45:42.064] resolve() on list ... DONE
[17:45:42.064]    - '...' content: [n=0] 
[17:45:42.064] List of 1
[17:45:42.064]  $ ...: list()
[17:45:42.064]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:42.064]  - attr(*, "where")=List of 1
[17:45:42.064]   ..$ ...:<environment: 0x55f6c71457c8> 
[17:45:42.064]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:42.064]  - attr(*, "resolved")= logi TRUE
[17:45:42.064]  - attr(*, "total_size")= num NA
[17:45:42.069]  - Getting '...' globals ... DONE
[17:45:42.070] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:42.070] List of 2
[17:45:42.070]  $ ...future.FUN:function (x)  
[17:45:42.070]  $ ...          : list()
[17:45:42.070]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:42.070]  - attr(*, "where")=List of 2
[17:45:42.070]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:42.070]   ..$ ...          :<environment: 0x55f6c71457c8> 
[17:45:42.070]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:42.070]  - attr(*, "resolved")= logi FALSE
[17:45:42.070]  - attr(*, "total_size")= num 4720
[17:45:42.072] Packages to be attached in all futures: [n=0] 
[17:45:42.073] getGlobalsAndPackagesXApply() ... DONE
[17:45:42.073] Number of futures (= number of chunks): 2
[17:45:42.073] Launching 2 futures (chunks) ...
[17:45:42.073] Chunk #1 of 2 ...
[17:45:42.073]  - Finding globals in 'X' for chunk #1 ...
[17:45:42.073] getGlobalsAndPackages() ...
[17:45:42.073] Searching for globals...
[17:45:42.074] 
[17:45:42.074] Searching for globals ... DONE
[17:45:42.074] - globals: [0] <none>
[17:45:42.074] getGlobalsAndPackages() ... DONE
[17:45:42.074]    + additional globals found: [n=0] 
[17:45:42.074]    + additional namespaces needed: [n=0] 
[17:45:42.074]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:42.074]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:42.074]  - seeds: <none>
[17:45:42.074]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:42.074] getGlobalsAndPackages() ...
[17:45:42.075] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:42.075] Resolving globals: FALSE
[17:45:42.075] Tweak future expression to call with '...' arguments ...
[17:45:42.075] {
[17:45:42.075]     do.call(function(...) {
[17:45:42.075]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:42.075]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:42.075]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:42.075]             on.exit(options(oopts), add = TRUE)
[17:45:42.075]         }
[17:45:42.075]         {
[17:45:42.075]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:42.075]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:42.075]                 ...future.FUN(...future.X_jj, ...)
[17:45:42.075]             })
[17:45:42.075]         }
[17:45:42.075]     }, args = future.call.arguments)
[17:45:42.075] }
[17:45:42.075] Tweak future expression to call with '...' arguments ... DONE
[17:45:42.076] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:42.076] 
[17:45:42.076] getGlobalsAndPackages() ... DONE
[17:45:42.076] run() for ‘Future’ ...
[17:45:42.076] - state: ‘created’
[17:45:42.076] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:42.080] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:42.080] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:42.080]   - Field: ‘label’
[17:45:42.080]   - Field: ‘local’
[17:45:42.080]   - Field: ‘owner’
[17:45:42.080]   - Field: ‘envir’
[17:45:42.081]   - Field: ‘workers’
[17:45:42.081]   - Field: ‘packages’
[17:45:42.081]   - Field: ‘gc’
[17:45:42.081]   - Field: ‘job’
[17:45:42.081]   - Field: ‘conditions’
[17:45:42.081]   - Field: ‘expr’
[17:45:42.081]   - Field: ‘uuid’
[17:45:42.081]   - Field: ‘seed’
[17:45:42.081]   - Field: ‘version’
[17:45:42.081]   - Field: ‘result’
[17:45:42.081]   - Field: ‘asynchronous’
[17:45:42.082]   - Field: ‘calls’
[17:45:42.082]   - Field: ‘globals’
[17:45:42.082]   - Field: ‘stdout’
[17:45:42.082]   - Field: ‘earlySignal’
[17:45:42.082]   - Field: ‘lazy’
[17:45:42.082]   - Field: ‘state’
[17:45:42.082] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:42.082] - Launch lazy future ...
[17:45:42.082] Packages needed by the future expression (n = 0): <none>
[17:45:42.083] Packages needed by future strategies (n = 0): <none>
[17:45:42.083] {
[17:45:42.083]     {
[17:45:42.083]         {
[17:45:42.083]             ...future.startTime <- base::Sys.time()
[17:45:42.083]             {
[17:45:42.083]                 {
[17:45:42.083]                   {
[17:45:42.083]                     {
[17:45:42.083]                       base::local({
[17:45:42.083]                         has_future <- base::requireNamespace("future", 
[17:45:42.083]                           quietly = TRUE)
[17:45:42.083]                         if (has_future) {
[17:45:42.083]                           ns <- base::getNamespace("future")
[17:45:42.083]                           version <- ns[[".package"]][["version"]]
[17:45:42.083]                           if (is.null(version)) 
[17:45:42.083]                             version <- utils::packageVersion("future")
[17:45:42.083]                         }
[17:45:42.083]                         else {
[17:45:42.083]                           version <- NULL
[17:45:42.083]                         }
[17:45:42.083]                         if (!has_future || version < "1.8.0") {
[17:45:42.083]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:42.083]                             "", base::R.version$version.string), 
[17:45:42.083]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:42.083]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:42.083]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:42.083]                               "release", "version")], collapse = " "), 
[17:45:42.083]                             hostname = base::Sys.info()[["nodename"]])
[17:45:42.083]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:42.083]                             info)
[17:45:42.083]                           info <- base::paste(info, collapse = "; ")
[17:45:42.083]                           if (!has_future) {
[17:45:42.083]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:42.083]                               info)
[17:45:42.083]                           }
[17:45:42.083]                           else {
[17:45:42.083]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:42.083]                               info, version)
[17:45:42.083]                           }
[17:45:42.083]                           base::stop(msg)
[17:45:42.083]                         }
[17:45:42.083]                       })
[17:45:42.083]                     }
[17:45:42.083]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:42.083]                     base::options(mc.cores = 1L)
[17:45:42.083]                   }
[17:45:42.083]                   ...future.strategy.old <- future::plan("list")
[17:45:42.083]                   options(future.plan = NULL)
[17:45:42.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:42.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:42.083]                 }
[17:45:42.083]                 ...future.workdir <- getwd()
[17:45:42.083]             }
[17:45:42.083]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:42.083]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:42.083]         }
[17:45:42.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:42.083]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:42.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:42.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:42.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:42.083]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:42.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:42.083]             base::names(...future.oldOptions))
[17:45:42.083]     }
[17:45:42.083]     if (FALSE) {
[17:45:42.083]     }
[17:45:42.083]     else {
[17:45:42.083]         if (TRUE) {
[17:45:42.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:42.083]                 open = "w")
[17:45:42.083]         }
[17:45:42.083]         else {
[17:45:42.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:42.083]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:42.083]         }
[17:45:42.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:42.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:42.083]             base::sink(type = "output", split = FALSE)
[17:45:42.083]             base::close(...future.stdout)
[17:45:42.083]         }, add = TRUE)
[17:45:42.083]     }
[17:45:42.083]     ...future.frame <- base::sys.nframe()
[17:45:42.083]     ...future.conditions <- base::list()
[17:45:42.083]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:42.083]     if (FALSE) {
[17:45:42.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:42.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:42.083]     }
[17:45:42.083]     ...future.result <- base::tryCatch({
[17:45:42.083]         base::withCallingHandlers({
[17:45:42.083]             ...future.value <- base::withVisible(base::local({
[17:45:42.083]                 withCallingHandlers({
[17:45:42.083]                   {
[17:45:42.083]                     do.call(function(...) {
[17:45:42.083]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:42.083]                       if (!identical(...future.globals.maxSize.org, 
[17:45:42.083]                         ...future.globals.maxSize)) {
[17:45:42.083]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:42.083]                         on.exit(options(oopts), add = TRUE)
[17:45:42.083]                       }
[17:45:42.083]                       {
[17:45:42.083]                         lapply(seq_along(...future.elements_ii), 
[17:45:42.083]                           FUN = function(jj) {
[17:45:42.083]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:42.083]                             ...future.FUN(...future.X_jj, ...)
[17:45:42.083]                           })
[17:45:42.083]                       }
[17:45:42.083]                     }, args = future.call.arguments)
[17:45:42.083]                   }
[17:45:42.083]                 }, immediateCondition = function(cond) {
[17:45:42.083]                   save_rds <- function (object, pathname, ...) 
[17:45:42.083]                   {
[17:45:42.083]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:42.083]                     if (file_test("-f", pathname_tmp)) {
[17:45:42.083]                       fi_tmp <- file.info(pathname_tmp)
[17:45:42.083]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:42.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:42.083]                         fi_tmp[["mtime"]])
[17:45:42.083]                     }
[17:45:42.083]                     tryCatch({
[17:45:42.083]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:42.083]                     }, error = function(ex) {
[17:45:42.083]                       msg <- conditionMessage(ex)
[17:45:42.083]                       fi_tmp <- file.info(pathname_tmp)
[17:45:42.083]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:42.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:42.083]                         fi_tmp[["mtime"]], msg)
[17:45:42.083]                       ex$message <- msg
[17:45:42.083]                       stop(ex)
[17:45:42.083]                     })
[17:45:42.083]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:42.083]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:42.083]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:42.083]                       fi_tmp <- file.info(pathname_tmp)
[17:45:42.083]                       fi <- file.info(pathname)
[17:45:42.083]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:42.083]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:42.083]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:42.083]                         fi[["size"]], fi[["mtime"]])
[17:45:42.083]                       stop(msg)
[17:45:42.083]                     }
[17:45:42.083]                     invisible(pathname)
[17:45:42.083]                   }
[17:45:42.083]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:42.083]                     rootPath = tempdir()) 
[17:45:42.083]                   {
[17:45:42.083]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:42.083]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:42.083]                       tmpdir = path, fileext = ".rds")
[17:45:42.083]                     save_rds(obj, file)
[17:45:42.083]                   }
[17:45:42.083]                   saveImmediateCondition(cond, path = "/tmp/RtmpnHaLG7/.future/immediateConditions")
[17:45:42.083]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:42.083]                   {
[17:45:42.083]                     inherits <- base::inherits
[17:45:42.083]                     invokeRestart <- base::invokeRestart
[17:45:42.083]                     is.null <- base::is.null
[17:45:42.083]                     muffled <- FALSE
[17:45:42.083]                     if (inherits(cond, "message")) {
[17:45:42.083]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:42.083]                       if (muffled) 
[17:45:42.083]                         invokeRestart("muffleMessage")
[17:45:42.083]                     }
[17:45:42.083]                     else if (inherits(cond, "warning")) {
[17:45:42.083]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:42.083]                       if (muffled) 
[17:45:42.083]                         invokeRestart("muffleWarning")
[17:45:42.083]                     }
[17:45:42.083]                     else if (inherits(cond, "condition")) {
[17:45:42.083]                       if (!is.null(pattern)) {
[17:45:42.083]                         computeRestarts <- base::computeRestarts
[17:45:42.083]                         grepl <- base::grepl
[17:45:42.083]                         restarts <- computeRestarts(cond)
[17:45:42.083]                         for (restart in restarts) {
[17:45:42.083]                           name <- restart$name
[17:45:42.083]                           if (is.null(name)) 
[17:45:42.083]                             next
[17:45:42.083]                           if (!grepl(pattern, name)) 
[17:45:42.083]                             next
[17:45:42.083]                           invokeRestart(restart)
[17:45:42.083]                           muffled <- TRUE
[17:45:42.083]                           break
[17:45:42.083]                         }
[17:45:42.083]                       }
[17:45:42.083]                     }
[17:45:42.083]                     invisible(muffled)
[17:45:42.083]                   }
[17:45:42.083]                   muffleCondition(cond)
[17:45:42.083]                 })
[17:45:42.083]             }))
[17:45:42.083]             future::FutureResult(value = ...future.value$value, 
[17:45:42.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:42.083]                   ...future.rng), globalenv = if (FALSE) 
[17:45:42.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:42.083]                     ...future.globalenv.names))
[17:45:42.083]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:42.083]         }, condition = base::local({
[17:45:42.083]             c <- base::c
[17:45:42.083]             inherits <- base::inherits
[17:45:42.083]             invokeRestart <- base::invokeRestart
[17:45:42.083]             length <- base::length
[17:45:42.083]             list <- base::list
[17:45:42.083]             seq.int <- base::seq.int
[17:45:42.083]             signalCondition <- base::signalCondition
[17:45:42.083]             sys.calls <- base::sys.calls
[17:45:42.083]             `[[` <- base::`[[`
[17:45:42.083]             `+` <- base::`+`
[17:45:42.083]             `<<-` <- base::`<<-`
[17:45:42.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:42.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:42.083]                   3L)]
[17:45:42.083]             }
[17:45:42.083]             function(cond) {
[17:45:42.083]                 is_error <- inherits(cond, "error")
[17:45:42.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:42.083]                   NULL)
[17:45:42.083]                 if (is_error) {
[17:45:42.083]                   sessionInformation <- function() {
[17:45:42.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:42.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:42.083]                       search = base::search(), system = base::Sys.info())
[17:45:42.083]                   }
[17:45:42.083]                   ...future.conditions[[length(...future.conditions) + 
[17:45:42.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:42.083]                     cond$call), session = sessionInformation(), 
[17:45:42.083]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:42.083]                   signalCondition(cond)
[17:45:42.083]                 }
[17:45:42.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:42.083]                 "immediateCondition"))) {
[17:45:42.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:42.083]                   ...future.conditions[[length(...future.conditions) + 
[17:45:42.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:42.083]                   if (TRUE && !signal) {
[17:45:42.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:42.083]                     {
[17:45:42.083]                       inherits <- base::inherits
[17:45:42.083]                       invokeRestart <- base::invokeRestart
[17:45:42.083]                       is.null <- base::is.null
[17:45:42.083]                       muffled <- FALSE
[17:45:42.083]                       if (inherits(cond, "message")) {
[17:45:42.083]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:42.083]                         if (muffled) 
[17:45:42.083]                           invokeRestart("muffleMessage")
[17:45:42.083]                       }
[17:45:42.083]                       else if (inherits(cond, "warning")) {
[17:45:42.083]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:42.083]                         if (muffled) 
[17:45:42.083]                           invokeRestart("muffleWarning")
[17:45:42.083]                       }
[17:45:42.083]                       else if (inherits(cond, "condition")) {
[17:45:42.083]                         if (!is.null(pattern)) {
[17:45:42.083]                           computeRestarts <- base::computeRestarts
[17:45:42.083]                           grepl <- base::grepl
[17:45:42.083]                           restarts <- computeRestarts(cond)
[17:45:42.083]                           for (restart in restarts) {
[17:45:42.083]                             name <- restart$name
[17:45:42.083]                             if (is.null(name)) 
[17:45:42.083]                               next
[17:45:42.083]                             if (!grepl(pattern, name)) 
[17:45:42.083]                               next
[17:45:42.083]                             invokeRestart(restart)
[17:45:42.083]                             muffled <- TRUE
[17:45:42.083]                             break
[17:45:42.083]                           }
[17:45:42.083]                         }
[17:45:42.083]                       }
[17:45:42.083]                       invisible(muffled)
[17:45:42.083]                     }
[17:45:42.083]                     muffleCondition(cond, pattern = "^muffle")
[17:45:42.083]                   }
[17:45:42.083]                 }
[17:45:42.083]                 else {
[17:45:42.083]                   if (TRUE) {
[17:45:42.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:42.083]                     {
[17:45:42.083]                       inherits <- base::inherits
[17:45:42.083]                       invokeRestart <- base::invokeRestart
[17:45:42.083]                       is.null <- base::is.null
[17:45:42.083]                       muffled <- FALSE
[17:45:42.083]                       if (inherits(cond, "message")) {
[17:45:42.083]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:42.083]                         if (muffled) 
[17:45:42.083]                           invokeRestart("muffleMessage")
[17:45:42.083]                       }
[17:45:42.083]                       else if (inherits(cond, "warning")) {
[17:45:42.083]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:42.083]                         if (muffled) 
[17:45:42.083]                           invokeRestart("muffleWarning")
[17:45:42.083]                       }
[17:45:42.083]                       else if (inherits(cond, "condition")) {
[17:45:42.083]                         if (!is.null(pattern)) {
[17:45:42.083]                           computeRestarts <- base::computeRestarts
[17:45:42.083]                           grepl <- base::grepl
[17:45:42.083]                           restarts <- computeRestarts(cond)
[17:45:42.083]                           for (restart in restarts) {
[17:45:42.083]                             name <- restart$name
[17:45:42.083]                             if (is.null(name)) 
[17:45:42.083]                               next
[17:45:42.083]                             if (!grepl(pattern, name)) 
[17:45:42.083]                               next
[17:45:42.083]                             invokeRestart(restart)
[17:45:42.083]                             muffled <- TRUE
[17:45:42.083]                             break
[17:45:42.083]                           }
[17:45:42.083]                         }
[17:45:42.083]                       }
[17:45:42.083]                       invisible(muffled)
[17:45:42.083]                     }
[17:45:42.083]                     muffleCondition(cond, pattern = "^muffle")
[17:45:42.083]                   }
[17:45:42.083]                 }
[17:45:42.083]             }
[17:45:42.083]         }))
[17:45:42.083]     }, error = function(ex) {
[17:45:42.083]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:42.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:42.083]                 ...future.rng), started = ...future.startTime, 
[17:45:42.083]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:42.083]             version = "1.8"), class = "FutureResult")
[17:45:42.083]     }, finally = {
[17:45:42.083]         if (!identical(...future.workdir, getwd())) 
[17:45:42.083]             setwd(...future.workdir)
[17:45:42.083]         {
[17:45:42.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:42.083]                 ...future.oldOptions$nwarnings <- NULL
[17:45:42.083]             }
[17:45:42.083]             base::options(...future.oldOptions)
[17:45:42.083]             if (.Platform$OS.type == "windows") {
[17:45:42.083]                 old_names <- names(...future.oldEnvVars)
[17:45:42.083]                 envs <- base::Sys.getenv()
[17:45:42.083]                 names <- names(envs)
[17:45:42.083]                 common <- intersect(names, old_names)
[17:45:42.083]                 added <- setdiff(names, old_names)
[17:45:42.083]                 removed <- setdiff(old_names, names)
[17:45:42.083]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:42.083]                   envs[common]]
[17:45:42.083]                 NAMES <- toupper(changed)
[17:45:42.083]                 args <- list()
[17:45:42.083]                 for (kk in seq_along(NAMES)) {
[17:45:42.083]                   name <- changed[[kk]]
[17:45:42.083]                   NAME <- NAMES[[kk]]
[17:45:42.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:42.083]                     next
[17:45:42.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:42.083]                 }
[17:45:42.083]                 NAMES <- toupper(added)
[17:45:42.083]                 for (kk in seq_along(NAMES)) {
[17:45:42.083]                   name <- added[[kk]]
[17:45:42.083]                   NAME <- NAMES[[kk]]
[17:45:42.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:42.083]                     next
[17:45:42.083]                   args[[name]] <- ""
[17:45:42.083]                 }
[17:45:42.083]                 NAMES <- toupper(removed)
[17:45:42.083]                 for (kk in seq_along(NAMES)) {
[17:45:42.083]                   name <- removed[[kk]]
[17:45:42.083]                   NAME <- NAMES[[kk]]
[17:45:42.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:42.083]                     next
[17:45:42.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:42.083]                 }
[17:45:42.083]                 if (length(args) > 0) 
[17:45:42.083]                   base::do.call(base::Sys.setenv, args = args)
[17:45:42.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:42.083]             }
[17:45:42.083]             else {
[17:45:42.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:42.083]             }
[17:45:42.083]             {
[17:45:42.083]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:42.083]                   0L) {
[17:45:42.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:42.083]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:42.083]                   base::options(opts)
[17:45:42.083]                 }
[17:45:42.083]                 {
[17:45:42.083]                   {
[17:45:42.083]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:42.083]                     NULL
[17:45:42.083]                   }
[17:45:42.083]                   options(future.plan = NULL)
[17:45:42.083]                   if (is.na(NA_character_)) 
[17:45:42.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:42.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:42.083]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:42.083]                     .init = FALSE)
[17:45:42.083]                 }
[17:45:42.083]             }
[17:45:42.083]         }
[17:45:42.083]     })
[17:45:42.083]     if (TRUE) {
[17:45:42.083]         base::sink(type = "output", split = FALSE)
[17:45:42.083]         if (TRUE) {
[17:45:42.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:42.083]         }
[17:45:42.083]         else {
[17:45:42.083]             ...future.result["stdout"] <- base::list(NULL)
[17:45:42.083]         }
[17:45:42.083]         base::close(...future.stdout)
[17:45:42.083]         ...future.stdout <- NULL
[17:45:42.083]     }
[17:45:42.083]     ...future.result$conditions <- ...future.conditions
[17:45:42.083]     ...future.result$finished <- base::Sys.time()
[17:45:42.083]     ...future.result
[17:45:42.083] }
[17:45:42.085] assign_globals() ...
[17:45:42.086] List of 5
[17:45:42.086]  $ ...future.FUN            :function (x)  
[17:45:42.086]  $ future.call.arguments    : list()
[17:45:42.086]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:42.086]  $ ...future.elements_ii    :List of 1
[17:45:42.086]   ..$ : int 1
[17:45:42.086]  $ ...future.seeds_ii       : NULL
[17:45:42.086]  $ ...future.globals.maxSize: NULL
[17:45:42.086]  - attr(*, "where")=List of 5
[17:45:42.086]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:42.086]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:42.086]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:42.086]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:42.086]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:42.086]  - attr(*, "resolved")= logi FALSE
[17:45:42.086]  - attr(*, "total_size")= num 4720
[17:45:42.086]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:42.086]  - attr(*, "already-done")= logi TRUE
[17:45:42.090] - reassign environment for ‘...future.FUN’
[17:45:42.090] - copied ‘...future.FUN’ to environment
[17:45:42.090] - copied ‘future.call.arguments’ to environment
[17:45:42.090] - copied ‘...future.elements_ii’ to environment
[17:45:42.090] - copied ‘...future.seeds_ii’ to environment
[17:45:42.091] - copied ‘...future.globals.maxSize’ to environment
[17:45:42.091] assign_globals() ... done
[17:45:42.091] requestCore(): workers = 2
[17:45:42.093] MulticoreFuture started
[17:45:42.093] - Launch lazy future ... done
[17:45:42.093] run() for ‘MulticoreFuture’ ... done
[17:45:42.094] Created future:
[17:45:42.094] plan(): Setting new future strategy stack:
[17:45:42.094] List of future strategies:
[17:45:42.094] 1. sequential:
[17:45:42.094]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:42.094]    - tweaked: FALSE
[17:45:42.094]    - call: NULL
[17:45:42.095] plan(): nbrOfWorkers() = 1
[17:45:42.094] MulticoreFuture:
[17:45:42.094] Label: ‘future_lapply-1’
[17:45:42.094] Expression:
[17:45:42.094] {
[17:45:42.094]     do.call(function(...) {
[17:45:42.094]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:42.094]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:42.094]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:42.094]             on.exit(options(oopts), add = TRUE)
[17:45:42.094]         }
[17:45:42.094]         {
[17:45:42.094]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:42.094]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:42.094]                 ...future.FUN(...future.X_jj, ...)
[17:45:42.094]             })
[17:45:42.094]         }
[17:45:42.094]     }, args = future.call.arguments)
[17:45:42.094] }
[17:45:42.094] Lazy evaluation: FALSE
[17:45:42.094] Asynchronous evaluation: TRUE
[17:45:42.094] Local evaluation: TRUE
[17:45:42.094] Environment: R_GlobalEnv
[17:45:42.094] Capture standard output: TRUE
[17:45:42.094] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:42.094] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:42.094] Packages: <none>
[17:45:42.094] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:42.094] Resolved: FALSE
[17:45:42.094] Value: <not collected>
[17:45:42.094] Conditions captured: <none>
[17:45:42.094] Early signaling: FALSE
[17:45:42.094] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:42.094] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:42.107] Chunk #1 of 2 ... DONE
[17:45:42.107] Chunk #2 of 2 ...
[17:45:42.108]  - Finding globals in 'X' for chunk #2 ...
[17:45:42.108] getGlobalsAndPackages() ...
[17:45:42.108] Searching for globals...
[17:45:42.109] 
[17:45:42.109] Searching for globals ... DONE
[17:45:42.109] - globals: [0] <none>
[17:45:42.109] getGlobalsAndPackages() ... DONE
[17:45:42.109]    + additional globals found: [n=0] 
[17:45:42.109]    + additional namespaces needed: [n=0] 
[17:45:42.109]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:42.110]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:42.110]  - seeds: <none>
[17:45:42.110]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:42.110] getGlobalsAndPackages() ...
[17:45:42.110] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:42.110] Resolving globals: FALSE
[17:45:42.111] Tweak future expression to call with '...' arguments ...
[17:45:42.111] {
[17:45:42.111]     do.call(function(...) {
[17:45:42.111]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:42.111]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:42.111]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:42.111]             on.exit(options(oopts), add = TRUE)
[17:45:42.111]         }
[17:45:42.111]         {
[17:45:42.111]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:42.111]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:42.111]                 ...future.FUN(...future.X_jj, ...)
[17:45:42.111]             })
[17:45:42.111]         }
[17:45:42.111]     }, args = future.call.arguments)
[17:45:42.111] }
[17:45:42.111] Tweak future expression to call with '...' arguments ... DONE
[17:45:42.115] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:42.116] 
[17:45:42.116] getGlobalsAndPackages() ... DONE
[17:45:42.117] run() for ‘Future’ ...
[17:45:42.117] - state: ‘created’
[17:45:42.118] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:42.124] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:42.125] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:42.125]   - Field: ‘label’
[17:45:42.125]   - Field: ‘local’
[17:45:42.125]   - Field: ‘owner’
[17:45:42.125]   - Field: ‘envir’
[17:45:42.125]   - Field: ‘workers’
[17:45:42.126]   - Field: ‘packages’
[17:45:42.126]   - Field: ‘gc’
[17:45:42.126]   - Field: ‘job’
[17:45:42.126]   - Field: ‘conditions’
[17:45:42.126]   - Field: ‘expr’
[17:45:42.126]   - Field: ‘uuid’
[17:45:42.126]   - Field: ‘seed’
[17:45:42.127]   - Field: ‘version’
[17:45:42.127]   - Field: ‘result’
[17:45:42.127]   - Field: ‘asynchronous’
[17:45:42.127]   - Field: ‘calls’
[17:45:42.127]   - Field: ‘globals’
[17:45:42.128]   - Field: ‘stdout’
[17:45:42.128]   - Field: ‘earlySignal’
[17:45:42.128]   - Field: ‘lazy’
[17:45:42.128]   - Field: ‘state’
[17:45:42.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:42.128] - Launch lazy future ...
[17:45:42.129] Packages needed by the future expression (n = 0): <none>
[17:45:42.129] Packages needed by future strategies (n = 0): <none>
[17:45:42.130] {
[17:45:42.130]     {
[17:45:42.130]         {
[17:45:42.130]             ...future.startTime <- base::Sys.time()
[17:45:42.130]             {
[17:45:42.130]                 {
[17:45:42.130]                   {
[17:45:42.130]                     {
[17:45:42.130]                       base::local({
[17:45:42.130]                         has_future <- base::requireNamespace("future", 
[17:45:42.130]                           quietly = TRUE)
[17:45:42.130]                         if (has_future) {
[17:45:42.130]                           ns <- base::getNamespace("future")
[17:45:42.130]                           version <- ns[[".package"]][["version"]]
[17:45:42.130]                           if (is.null(version)) 
[17:45:42.130]                             version <- utils::packageVersion("future")
[17:45:42.130]                         }
[17:45:42.130]                         else {
[17:45:42.130]                           version <- NULL
[17:45:42.130]                         }
[17:45:42.130]                         if (!has_future || version < "1.8.0") {
[17:45:42.130]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:42.130]                             "", base::R.version$version.string), 
[17:45:42.130]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:42.130]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:42.130]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:42.130]                               "release", "version")], collapse = " "), 
[17:45:42.130]                             hostname = base::Sys.info()[["nodename"]])
[17:45:42.130]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:42.130]                             info)
[17:45:42.130]                           info <- base::paste(info, collapse = "; ")
[17:45:42.130]                           if (!has_future) {
[17:45:42.130]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:42.130]                               info)
[17:45:42.130]                           }
[17:45:42.130]                           else {
[17:45:42.130]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:42.130]                               info, version)
[17:45:42.130]                           }
[17:45:42.130]                           base::stop(msg)
[17:45:42.130]                         }
[17:45:42.130]                       })
[17:45:42.130]                     }
[17:45:42.130]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:42.130]                     base::options(mc.cores = 1L)
[17:45:42.130]                   }
[17:45:42.130]                   ...future.strategy.old <- future::plan("list")
[17:45:42.130]                   options(future.plan = NULL)
[17:45:42.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:42.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:42.130]                 }
[17:45:42.130]                 ...future.workdir <- getwd()
[17:45:42.130]             }
[17:45:42.130]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:42.130]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:42.130]         }
[17:45:42.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:42.130]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:42.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:42.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:42.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:42.130]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:42.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:42.130]             base::names(...future.oldOptions))
[17:45:42.130]     }
[17:45:42.130]     if (FALSE) {
[17:45:42.130]     }
[17:45:42.130]     else {
[17:45:42.130]         if (TRUE) {
[17:45:42.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:42.130]                 open = "w")
[17:45:42.130]         }
[17:45:42.130]         else {
[17:45:42.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:42.130]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:42.130]         }
[17:45:42.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:42.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:42.130]             base::sink(type = "output", split = FALSE)
[17:45:42.130]             base::close(...future.stdout)
[17:45:42.130]         }, add = TRUE)
[17:45:42.130]     }
[17:45:42.130]     ...future.frame <- base::sys.nframe()
[17:45:42.130]     ...future.conditions <- base::list()
[17:45:42.130]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:42.130]     if (FALSE) {
[17:45:42.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:42.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:42.130]     }
[17:45:42.130]     ...future.result <- base::tryCatch({
[17:45:42.130]         base::withCallingHandlers({
[17:45:42.130]             ...future.value <- base::withVisible(base::local({
[17:45:42.130]                 withCallingHandlers({
[17:45:42.130]                   {
[17:45:42.130]                     do.call(function(...) {
[17:45:42.130]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:42.130]                       if (!identical(...future.globals.maxSize.org, 
[17:45:42.130]                         ...future.globals.maxSize)) {
[17:45:42.130]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:42.130]                         on.exit(options(oopts), add = TRUE)
[17:45:42.130]                       }
[17:45:42.130]                       {
[17:45:42.130]                         lapply(seq_along(...future.elements_ii), 
[17:45:42.130]                           FUN = function(jj) {
[17:45:42.130]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:42.130]                             ...future.FUN(...future.X_jj, ...)
[17:45:42.130]                           })
[17:45:42.130]                       }
[17:45:42.130]                     }, args = future.call.arguments)
[17:45:42.130]                   }
[17:45:42.130]                 }, immediateCondition = function(cond) {
[17:45:42.130]                   save_rds <- function (object, pathname, ...) 
[17:45:42.130]                   {
[17:45:42.130]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:42.130]                     if (file_test("-f", pathname_tmp)) {
[17:45:42.130]                       fi_tmp <- file.info(pathname_tmp)
[17:45:42.130]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:42.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:42.130]                         fi_tmp[["mtime"]])
[17:45:42.130]                     }
[17:45:42.130]                     tryCatch({
[17:45:42.130]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:42.130]                     }, error = function(ex) {
[17:45:42.130]                       msg <- conditionMessage(ex)
[17:45:42.130]                       fi_tmp <- file.info(pathname_tmp)
[17:45:42.130]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:42.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:42.130]                         fi_tmp[["mtime"]], msg)
[17:45:42.130]                       ex$message <- msg
[17:45:42.130]                       stop(ex)
[17:45:42.130]                     })
[17:45:42.130]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:42.130]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:42.130]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:42.130]                       fi_tmp <- file.info(pathname_tmp)
[17:45:42.130]                       fi <- file.info(pathname)
[17:45:42.130]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:42.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:42.130]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:42.130]                         fi[["size"]], fi[["mtime"]])
[17:45:42.130]                       stop(msg)
[17:45:42.130]                     }
[17:45:42.130]                     invisible(pathname)
[17:45:42.130]                   }
[17:45:42.130]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:42.130]                     rootPath = tempdir()) 
[17:45:42.130]                   {
[17:45:42.130]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:42.130]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:42.130]                       tmpdir = path, fileext = ".rds")
[17:45:42.130]                     save_rds(obj, file)
[17:45:42.130]                   }
[17:45:42.130]                   saveImmediateCondition(cond, path = "/tmp/RtmpnHaLG7/.future/immediateConditions")
[17:45:42.130]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:42.130]                   {
[17:45:42.130]                     inherits <- base::inherits
[17:45:42.130]                     invokeRestart <- base::invokeRestart
[17:45:42.130]                     is.null <- base::is.null
[17:45:42.130]                     muffled <- FALSE
[17:45:42.130]                     if (inherits(cond, "message")) {
[17:45:42.130]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:42.130]                       if (muffled) 
[17:45:42.130]                         invokeRestart("muffleMessage")
[17:45:42.130]                     }
[17:45:42.130]                     else if (inherits(cond, "warning")) {
[17:45:42.130]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:42.130]                       if (muffled) 
[17:45:42.130]                         invokeRestart("muffleWarning")
[17:45:42.130]                     }
[17:45:42.130]                     else if (inherits(cond, "condition")) {
[17:45:42.130]                       if (!is.null(pattern)) {
[17:45:42.130]                         computeRestarts <- base::computeRestarts
[17:45:42.130]                         grepl <- base::grepl
[17:45:42.130]                         restarts <- computeRestarts(cond)
[17:45:42.130]                         for (restart in restarts) {
[17:45:42.130]                           name <- restart$name
[17:45:42.130]                           if (is.null(name)) 
[17:45:42.130]                             next
[17:45:42.130]                           if (!grepl(pattern, name)) 
[17:45:42.130]                             next
[17:45:42.130]                           invokeRestart(restart)
[17:45:42.130]                           muffled <- TRUE
[17:45:42.130]                           break
[17:45:42.130]                         }
[17:45:42.130]                       }
[17:45:42.130]                     }
[17:45:42.130]                     invisible(muffled)
[17:45:42.130]                   }
[17:45:42.130]                   muffleCondition(cond)
[17:45:42.130]                 })
[17:45:42.130]             }))
[17:45:42.130]             future::FutureResult(value = ...future.value$value, 
[17:45:42.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:42.130]                   ...future.rng), globalenv = if (FALSE) 
[17:45:42.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:42.130]                     ...future.globalenv.names))
[17:45:42.130]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:42.130]         }, condition = base::local({
[17:45:42.130]             c <- base::c
[17:45:42.130]             inherits <- base::inherits
[17:45:42.130]             invokeRestart <- base::invokeRestart
[17:45:42.130]             length <- base::length
[17:45:42.130]             list <- base::list
[17:45:42.130]             seq.int <- base::seq.int
[17:45:42.130]             signalCondition <- base::signalCondition
[17:45:42.130]             sys.calls <- base::sys.calls
[17:45:42.130]             `[[` <- base::`[[`
[17:45:42.130]             `+` <- base::`+`
[17:45:42.130]             `<<-` <- base::`<<-`
[17:45:42.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:42.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:42.130]                   3L)]
[17:45:42.130]             }
[17:45:42.130]             function(cond) {
[17:45:42.130]                 is_error <- inherits(cond, "error")
[17:45:42.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:42.130]                   NULL)
[17:45:42.130]                 if (is_error) {
[17:45:42.130]                   sessionInformation <- function() {
[17:45:42.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:42.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:42.130]                       search = base::search(), system = base::Sys.info())
[17:45:42.130]                   }
[17:45:42.130]                   ...future.conditions[[length(...future.conditions) + 
[17:45:42.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:42.130]                     cond$call), session = sessionInformation(), 
[17:45:42.130]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:42.130]                   signalCondition(cond)
[17:45:42.130]                 }
[17:45:42.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:42.130]                 "immediateCondition"))) {
[17:45:42.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:42.130]                   ...future.conditions[[length(...future.conditions) + 
[17:45:42.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:42.130]                   if (TRUE && !signal) {
[17:45:42.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:42.130]                     {
[17:45:42.130]                       inherits <- base::inherits
[17:45:42.130]                       invokeRestart <- base::invokeRestart
[17:45:42.130]                       is.null <- base::is.null
[17:45:42.130]                       muffled <- FALSE
[17:45:42.130]                       if (inherits(cond, "message")) {
[17:45:42.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:42.130]                         if (muffled) 
[17:45:42.130]                           invokeRestart("muffleMessage")
[17:45:42.130]                       }
[17:45:42.130]                       else if (inherits(cond, "warning")) {
[17:45:42.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:42.130]                         if (muffled) 
[17:45:42.130]                           invokeRestart("muffleWarning")
[17:45:42.130]                       }
[17:45:42.130]                       else if (inherits(cond, "condition")) {
[17:45:42.130]                         if (!is.null(pattern)) {
[17:45:42.130]                           computeRestarts <- base::computeRestarts
[17:45:42.130]                           grepl <- base::grepl
[17:45:42.130]                           restarts <- computeRestarts(cond)
[17:45:42.130]                           for (restart in restarts) {
[17:45:42.130]                             name <- restart$name
[17:45:42.130]                             if (is.null(name)) 
[17:45:42.130]                               next
[17:45:42.130]                             if (!grepl(pattern, name)) 
[17:45:42.130]                               next
[17:45:42.130]                             invokeRestart(restart)
[17:45:42.130]                             muffled <- TRUE
[17:45:42.130]                             break
[17:45:42.130]                           }
[17:45:42.130]                         }
[17:45:42.130]                       }
[17:45:42.130]                       invisible(muffled)
[17:45:42.130]                     }
[17:45:42.130]                     muffleCondition(cond, pattern = "^muffle")
[17:45:42.130]                   }
[17:45:42.130]                 }
[17:45:42.130]                 else {
[17:45:42.130]                   if (TRUE) {
[17:45:42.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:42.130]                     {
[17:45:42.130]                       inherits <- base::inherits
[17:45:42.130]                       invokeRestart <- base::invokeRestart
[17:45:42.130]                       is.null <- base::is.null
[17:45:42.130]                       muffled <- FALSE
[17:45:42.130]                       if (inherits(cond, "message")) {
[17:45:42.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:42.130]                         if (muffled) 
[17:45:42.130]                           invokeRestart("muffleMessage")
[17:45:42.130]                       }
[17:45:42.130]                       else if (inherits(cond, "warning")) {
[17:45:42.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:42.130]                         if (muffled) 
[17:45:42.130]                           invokeRestart("muffleWarning")
[17:45:42.130]                       }
[17:45:42.130]                       else if (inherits(cond, "condition")) {
[17:45:42.130]                         if (!is.null(pattern)) {
[17:45:42.130]                           computeRestarts <- base::computeRestarts
[17:45:42.130]                           grepl <- base::grepl
[17:45:42.130]                           restarts <- computeRestarts(cond)
[17:45:42.130]                           for (restart in restarts) {
[17:45:42.130]                             name <- restart$name
[17:45:42.130]                             if (is.null(name)) 
[17:45:42.130]                               next
[17:45:42.130]                             if (!grepl(pattern, name)) 
[17:45:42.130]                               next
[17:45:42.130]                             invokeRestart(restart)
[17:45:42.130]                             muffled <- TRUE
[17:45:42.130]                             break
[17:45:42.130]                           }
[17:45:42.130]                         }
[17:45:42.130]                       }
[17:45:42.130]                       invisible(muffled)
[17:45:42.130]                     }
[17:45:42.130]                     muffleCondition(cond, pattern = "^muffle")
[17:45:42.130]                   }
[17:45:42.130]                 }
[17:45:42.130]             }
[17:45:42.130]         }))
[17:45:42.130]     }, error = function(ex) {
[17:45:42.130]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:42.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:42.130]                 ...future.rng), started = ...future.startTime, 
[17:45:42.130]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:42.130]             version = "1.8"), class = "FutureResult")
[17:45:42.130]     }, finally = {
[17:45:42.130]         if (!identical(...future.workdir, getwd())) 
[17:45:42.130]             setwd(...future.workdir)
[17:45:42.130]         {
[17:45:42.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:42.130]                 ...future.oldOptions$nwarnings <- NULL
[17:45:42.130]             }
[17:45:42.130]             base::options(...future.oldOptions)
[17:45:42.130]             if (.Platform$OS.type == "windows") {
[17:45:42.130]                 old_names <- names(...future.oldEnvVars)
[17:45:42.130]                 envs <- base::Sys.getenv()
[17:45:42.130]                 names <- names(envs)
[17:45:42.130]                 common <- intersect(names, old_names)
[17:45:42.130]                 added <- setdiff(names, old_names)
[17:45:42.130]                 removed <- setdiff(old_names, names)
[17:45:42.130]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:42.130]                   envs[common]]
[17:45:42.130]                 NAMES <- toupper(changed)
[17:45:42.130]                 args <- list()
[17:45:42.130]                 for (kk in seq_along(NAMES)) {
[17:45:42.130]                   name <- changed[[kk]]
[17:45:42.130]                   NAME <- NAMES[[kk]]
[17:45:42.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:42.130]                     next
[17:45:42.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:42.130]                 }
[17:45:42.130]                 NAMES <- toupper(added)
[17:45:42.130]                 for (kk in seq_along(NAMES)) {
[17:45:42.130]                   name <- added[[kk]]
[17:45:42.130]                   NAME <- NAMES[[kk]]
[17:45:42.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:42.130]                     next
[17:45:42.130]                   args[[name]] <- ""
[17:45:42.130]                 }
[17:45:42.130]                 NAMES <- toupper(removed)
[17:45:42.130]                 for (kk in seq_along(NAMES)) {
[17:45:42.130]                   name <- removed[[kk]]
[17:45:42.130]                   NAME <- NAMES[[kk]]
[17:45:42.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:42.130]                     next
[17:45:42.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:42.130]                 }
[17:45:42.130]                 if (length(args) > 0) 
[17:45:42.130]                   base::do.call(base::Sys.setenv, args = args)
[17:45:42.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:42.130]             }
[17:45:42.130]             else {
[17:45:42.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:42.130]             }
[17:45:42.130]             {
[17:45:42.130]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:42.130]                   0L) {
[17:45:42.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:42.130]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:42.130]                   base::options(opts)
[17:45:42.130]                 }
[17:45:42.130]                 {
[17:45:42.130]                   {
[17:45:42.130]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:42.130]                     NULL
[17:45:42.130]                   }
[17:45:42.130]                   options(future.plan = NULL)
[17:45:42.130]                   if (is.na(NA_character_)) 
[17:45:42.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:42.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:42.130]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:42.130]                     .init = FALSE)
[17:45:42.130]                 }
[17:45:42.130]             }
[17:45:42.130]         }
[17:45:42.130]     })
[17:45:42.130]     if (TRUE) {
[17:45:42.130]         base::sink(type = "output", split = FALSE)
[17:45:42.130]         if (TRUE) {
[17:45:42.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:42.130]         }
[17:45:42.130]         else {
[17:45:42.130]             ...future.result["stdout"] <- base::list(NULL)
[17:45:42.130]         }
[17:45:42.130]         base::close(...future.stdout)
[17:45:42.130]         ...future.stdout <- NULL
[17:45:42.130]     }
[17:45:42.130]     ...future.result$conditions <- ...future.conditions
[17:45:42.130]     ...future.result$finished <- base::Sys.time()
[17:45:42.130]     ...future.result
[17:45:42.130] }
[17:45:42.132] assign_globals() ...
[17:45:42.132] List of 5
[17:45:42.132]  $ ...future.FUN            :function (x)  
[17:45:42.132]  $ future.call.arguments    : list()
[17:45:42.132]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:42.132]  $ ...future.elements_ii    :List of 1
[17:45:42.132]   ..$ : int 0
[17:45:42.132]  $ ...future.seeds_ii       : NULL
[17:45:42.132]  $ ...future.globals.maxSize: NULL
[17:45:42.132]  - attr(*, "where")=List of 5
[17:45:42.132]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:42.132]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:42.132]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:42.132]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:42.132]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:42.132]  - attr(*, "resolved")= logi FALSE
[17:45:42.132]  - attr(*, "total_size")= num 4720
[17:45:42.132]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:42.132]  - attr(*, "already-done")= logi TRUE
[17:45:42.139] - reassign environment for ‘...future.FUN’
[17:45:42.139] - copied ‘...future.FUN’ to environment
[17:45:42.139] - copied ‘future.call.arguments’ to environment
[17:45:42.139] - copied ‘...future.elements_ii’ to environment
[17:45:42.139] - copied ‘...future.seeds_ii’ to environment
[17:45:42.139] - copied ‘...future.globals.maxSize’ to environment
[17:45:42.139] assign_globals() ... done
[17:45:42.140] requestCore(): workers = 2
[17:45:42.142] MulticoreFuture started
[17:45:42.142] - Launch lazy future ... done
[17:45:42.142] run() for ‘MulticoreFuture’ ... done
[17:45:42.143] Created future:
[17:45:42.143] plan(): Setting new future strategy stack:
[17:45:42.143] List of future strategies:
[17:45:42.143] 1. sequential:
[17:45:42.143]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:42.143]    - tweaked: FALSE
[17:45:42.143]    - call: NULL
[17:45:42.144] plan(): nbrOfWorkers() = 1
[17:45:42.146] plan(): Setting new future strategy stack:
[17:45:42.146] List of future strategies:
[17:45:42.146] 1. multicore:
[17:45:42.146]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:42.146]    - tweaked: FALSE
[17:45:42.146]    - call: plan(strategy)
[17:45:42.151] plan(): nbrOfWorkers() = 2
[17:45:42.143] MulticoreFuture:
[17:45:42.143] Label: ‘future_lapply-2’
[17:45:42.143] Expression:
[17:45:42.143] {
[17:45:42.143]     do.call(function(...) {
[17:45:42.143]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:42.143]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:42.143]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:42.143]             on.exit(options(oopts), add = TRUE)
[17:45:42.143]         }
[17:45:42.143]         {
[17:45:42.143]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:42.143]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:42.143]                 ...future.FUN(...future.X_jj, ...)
[17:45:42.143]             })
[17:45:42.143]         }
[17:45:42.143]     }, args = future.call.arguments)
[17:45:42.143] }
[17:45:42.143] Lazy evaluation: FALSE
[17:45:42.143] Asynchronous evaluation: TRUE
[17:45:42.143] Local evaluation: TRUE
[17:45:42.143] Environment: R_GlobalEnv
[17:45:42.143] Capture standard output: TRUE
[17:45:42.143] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:42.143] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:42.143] Packages: <none>
[17:45:42.143] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:42.143] Resolved: TRUE
[17:45:42.143] Value: <not collected>
[17:45:42.143] Conditions captured: <none>
[17:45:42.143] Early signaling: FALSE
[17:45:42.143] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:42.143] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:42.153] Chunk #2 of 2 ... DONE
[17:45:42.153] Launching 2 futures (chunks) ... DONE
[17:45:42.153] Resolving 2 futures (chunks) ...
[17:45:42.153] resolve() on list ...
[17:45:42.153]  recursive: 0
[17:45:42.153]  length: 2
[17:45:42.153] 
[17:45:42.164] Future #2
[17:45:42.164] result() for MulticoreFuture ...
[17:45:42.165] result() for MulticoreFuture ...
[17:45:42.166] result() for MulticoreFuture ... done
[17:45:42.166] result() for MulticoreFuture ... done
[17:45:42.166] result() for MulticoreFuture ...
[17:45:42.166] result() for MulticoreFuture ... done
[17:45:42.166] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:42.166] - nx: 2
[17:45:42.167] - relay: TRUE
[17:45:42.167] - stdout: TRUE
[17:45:42.167] - signal: TRUE
[17:45:42.167] - resignal: FALSE
[17:45:42.167] - force: TRUE
[17:45:42.167] - relayed: [n=2] FALSE, FALSE
[17:45:42.167] - queued futures: [n=2] FALSE, FALSE
[17:45:42.168]  - until=1
[17:45:42.168]  - relaying element #1
[17:45:42.168] - relayed: [n=2] FALSE, FALSE
[17:45:42.168] - queued futures: [n=2] FALSE, TRUE
[17:45:42.168] signalConditionsASAP(NULL, pos=2) ... done
[17:45:42.168]  length: 1 (resolved future 2)
[17:45:42.598] plan(): Setting new future strategy stack:
[17:45:42.598] List of future strategies:
[17:45:42.598] 1. multicore:
[17:45:42.598]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:42.598]    - tweaked: FALSE
[17:45:42.598]    - call: plan(strategy)
[17:45:42.603] plan(): nbrOfWorkers() = 2
[17:45:42.607] Future #1
[17:45:42.607] result() for MulticoreFuture ...
[17:45:42.608] result() for MulticoreFuture ...
[17:45:42.608] result() for MulticoreFuture ... done
[17:45:42.608] result() for MulticoreFuture ... done
[17:45:42.608] result() for MulticoreFuture ...
[17:45:42.608] result() for MulticoreFuture ... done
[17:45:42.608] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:42.608] - nx: 2
[17:45:42.609] - relay: TRUE
[17:45:42.609] - stdout: TRUE
[17:45:42.609] - signal: TRUE
[17:45:42.609] - resignal: FALSE
[17:45:42.609] - force: TRUE
[17:45:42.609] - relayed: [n=2] FALSE, FALSE
[17:45:42.609] - queued futures: [n=2] FALSE, TRUE
[17:45:42.609]  - until=1
[17:45:42.609]  - relaying element #1
[17:45:42.610] result() for MulticoreFuture ...
[17:45:42.610] result() for MulticoreFuture ... done
[17:45:42.610] result() for MulticoreFuture ...
[17:45:42.610] result() for MulticoreFuture ... done
[17:45:42.610] result() for MulticoreFuture ...
[17:45:42.610] result() for MulticoreFuture ... done
[17:45:42.610] result() for MulticoreFuture ...
[17:45:42.610] result() for MulticoreFuture ... done
[17:45:42.610] - relayed: [n=2] TRUE, FALSE
[17:45:42.611] - queued futures: [n=2] TRUE, TRUE
[17:45:42.611] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:42.611]  length: 0 (resolved future 1)
[17:45:42.611] Relaying remaining futures
[17:45:42.611] signalConditionsASAP(NULL, pos=0) ...
[17:45:42.611] - nx: 2
[17:45:42.611] - relay: TRUE
[17:45:42.611] - stdout: TRUE
[17:45:42.612] - signal: TRUE
[17:45:42.612] - resignal: FALSE
[17:45:42.612] - force: TRUE
[17:45:42.612] - relayed: [n=2] TRUE, FALSE
[17:45:42.612] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:42.612]  - relaying element #2
[17:45:42.612] result() for MulticoreFuture ...
[17:45:42.612] result() for MulticoreFuture ... done
[17:45:42.612] result() for MulticoreFuture ...
[17:45:42.613] result() for MulticoreFuture ... done
[17:45:42.613] result() for MulticoreFuture ...
[17:45:42.613] result() for MulticoreFuture ... done
[17:45:42.613] result() for MulticoreFuture ...
[17:45:42.615] result() for MulticoreFuture ... done
[17:45:42.616] - relayed: [n=2] TRUE, TRUE
[17:45:42.616] - queued futures: [n=2] TRUE, TRUE
[17:45:42.616] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:45:42.616] resolve() on list ... DONE
[17:45:42.616] result() for MulticoreFuture ...
[17:45:42.617] result() for MulticoreFuture ... done
[17:45:42.617] result() for MulticoreFuture ...
[17:45:42.617] result() for MulticoreFuture ... done
[17:45:42.617] result() for MulticoreFuture ...
[17:45:42.617] result() for MulticoreFuture ... done
[17:45:42.618] result() for MulticoreFuture ...
[17:45:42.618] result() for MulticoreFuture ... done
[17:45:42.618]  - Number of value chunks collected: 2
[17:45:42.618] Resolving 2 futures (chunks) ... DONE
[17:45:42.618] Reducing values from 2 chunks ...
[17:45:42.618]  - Number of values collected after concatenation: 2
[17:45:42.619]  - Number of values expected: 2
[17:45:42.619] Reducing values from 2 chunks ... DONE
[17:45:42.619] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:45:42.619] future_lapply() ...
[17:45:42.624] Number of chunks: 2
[17:45:42.625] getGlobalsAndPackagesXApply() ...
[17:45:42.625]  - future.globals: TRUE
[17:45:42.625] getGlobalsAndPackages() ...
[17:45:42.625] Searching for globals...
[17:45:42.627] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:42.627] Searching for globals ... DONE
[17:45:42.627] Resolving globals: FALSE
[17:45:42.628] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:42.628] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:42.628] - globals: [1] ‘FUN’
[17:45:42.628] 
[17:45:42.628] getGlobalsAndPackages() ... DONE
[17:45:42.629]  - globals found/used: [n=1] ‘FUN’
[17:45:42.629]  - needed namespaces: [n=0] 
[17:45:42.629] Finding globals ... DONE
[17:45:42.629]  - use_args: TRUE
[17:45:42.629]  - Getting '...' globals ...
[17:45:42.629] resolve() on list ...
[17:45:42.629]  recursive: 0
[17:45:42.630]  length: 1
[17:45:42.630]  elements: ‘...’
[17:45:42.630]  length: 0 (resolved future 1)
[17:45:42.630] resolve() on list ... DONE
[17:45:42.630]    - '...' content: [n=0] 
[17:45:42.630] List of 1
[17:45:42.630]  $ ...: list()
[17:45:42.630]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:42.630]  - attr(*, "where")=List of 1
[17:45:42.630]   ..$ ...:<environment: 0x55f6c67f0398> 
[17:45:42.630]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:42.630]  - attr(*, "resolved")= logi TRUE
[17:45:42.630]  - attr(*, "total_size")= num NA
[17:45:42.633]  - Getting '...' globals ... DONE
[17:45:42.633] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:42.633] List of 2
[17:45:42.633]  $ ...future.FUN:function (x)  
[17:45:42.633]  $ ...          : list()
[17:45:42.633]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:42.633]  - attr(*, "where")=List of 2
[17:45:42.633]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:42.633]   ..$ ...          :<environment: 0x55f6c67f0398> 
[17:45:42.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:42.633]  - attr(*, "resolved")= logi FALSE
[17:45:42.633]  - attr(*, "total_size")= num 4720
[17:45:42.636] Packages to be attached in all futures: [n=0] 
[17:45:42.636] getGlobalsAndPackagesXApply() ... DONE
[17:45:42.636] Number of futures (= number of chunks): 2
[17:45:42.636] Launching 2 futures (chunks) ...
[17:45:42.636] Chunk #1 of 2 ...
[17:45:42.637]  - Finding globals in 'X' for chunk #1 ...
[17:45:42.637] getGlobalsAndPackages() ...
[17:45:42.637] Searching for globals...
[17:45:42.637] 
[17:45:42.637] Searching for globals ... DONE
[17:45:42.637] - globals: [0] <none>
[17:45:42.637] getGlobalsAndPackages() ... DONE
[17:45:42.637]    + additional globals found: [n=0] 
[17:45:42.637]    + additional namespaces needed: [n=0] 
[17:45:42.638]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:42.638]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:42.638]  - seeds: <none>
[17:45:42.638]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:42.638] getGlobalsAndPackages() ...
[17:45:42.638] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:42.638] Resolving globals: FALSE
[17:45:42.638] Tweak future expression to call with '...' arguments ...
[17:45:42.638] {
[17:45:42.638]     do.call(function(...) {
[17:45:42.638]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:42.638]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:42.638]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:42.638]             on.exit(options(oopts), add = TRUE)
[17:45:42.638]         }
[17:45:42.638]         {
[17:45:42.638]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:42.638]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:42.638]                 ...future.FUN(...future.X_jj, ...)
[17:45:42.638]             })
[17:45:42.638]         }
[17:45:42.638]     }, args = future.call.arguments)
[17:45:42.638] }
[17:45:42.639] Tweak future expression to call with '...' arguments ... DONE
[17:45:42.639] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:42.639] 
[17:45:42.639] getGlobalsAndPackages() ... DONE
[17:45:42.640] run() for ‘Future’ ...
[17:45:42.640] - state: ‘created’
[17:45:42.640] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:42.643] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:42.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:42.643]   - Field: ‘label’
[17:45:42.644]   - Field: ‘local’
[17:45:42.644]   - Field: ‘owner’
[17:45:42.644]   - Field: ‘envir’
[17:45:42.644]   - Field: ‘workers’
[17:45:42.644]   - Field: ‘packages’
[17:45:42.644]   - Field: ‘gc’
[17:45:42.644]   - Field: ‘job’
[17:45:42.644]   - Field: ‘conditions’
[17:45:42.644]   - Field: ‘expr’
[17:45:42.644]   - Field: ‘uuid’
[17:45:42.645]   - Field: ‘seed’
[17:45:42.645]   - Field: ‘version’
[17:45:42.645]   - Field: ‘result’
[17:45:42.645]   - Field: ‘asynchronous’
[17:45:42.645]   - Field: ‘calls’
[17:45:42.645]   - Field: ‘globals’
[17:45:42.645]   - Field: ‘stdout’
[17:45:42.645]   - Field: ‘earlySignal’
[17:45:42.645]   - Field: ‘lazy’
[17:45:42.645]   - Field: ‘state’
[17:45:42.646] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:42.646] - Launch lazy future ...
[17:45:42.646] Packages needed by the future expression (n = 0): <none>
[17:45:42.646] Packages needed by future strategies (n = 0): <none>
[17:45:42.648] {
[17:45:42.648]     {
[17:45:42.648]         {
[17:45:42.648]             ...future.startTime <- base::Sys.time()
[17:45:42.648]             {
[17:45:42.648]                 {
[17:45:42.648]                   {
[17:45:42.648]                     {
[17:45:42.648]                       base::local({
[17:45:42.648]                         has_future <- base::requireNamespace("future", 
[17:45:42.648]                           quietly = TRUE)
[17:45:42.648]                         if (has_future) {
[17:45:42.648]                           ns <- base::getNamespace("future")
[17:45:42.648]                           version <- ns[[".package"]][["version"]]
[17:45:42.648]                           if (is.null(version)) 
[17:45:42.648]                             version <- utils::packageVersion("future")
[17:45:42.648]                         }
[17:45:42.648]                         else {
[17:45:42.648]                           version <- NULL
[17:45:42.648]                         }
[17:45:42.648]                         if (!has_future || version < "1.8.0") {
[17:45:42.648]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:42.648]                             "", base::R.version$version.string), 
[17:45:42.648]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:42.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:42.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:42.648]                               "release", "version")], collapse = " "), 
[17:45:42.648]                             hostname = base::Sys.info()[["nodename"]])
[17:45:42.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:42.648]                             info)
[17:45:42.648]                           info <- base::paste(info, collapse = "; ")
[17:45:42.648]                           if (!has_future) {
[17:45:42.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:42.648]                               info)
[17:45:42.648]                           }
[17:45:42.648]                           else {
[17:45:42.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:42.648]                               info, version)
[17:45:42.648]                           }
[17:45:42.648]                           base::stop(msg)
[17:45:42.648]                         }
[17:45:42.648]                       })
[17:45:42.648]                     }
[17:45:42.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:42.648]                     base::options(mc.cores = 1L)
[17:45:42.648]                   }
[17:45:42.648]                   ...future.strategy.old <- future::plan("list")
[17:45:42.648]                   options(future.plan = NULL)
[17:45:42.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:42.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:42.648]                 }
[17:45:42.648]                 ...future.workdir <- getwd()
[17:45:42.648]             }
[17:45:42.648]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:42.648]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:42.648]         }
[17:45:42.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:42.648]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:42.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:42.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:42.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:42.648]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:42.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:42.648]             base::names(...future.oldOptions))
[17:45:42.648]     }
[17:45:42.648]     if (TRUE) {
[17:45:42.648]     }
[17:45:42.648]     else {
[17:45:42.648]         if (NA) {
[17:45:42.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:42.648]                 open = "w")
[17:45:42.648]         }
[17:45:42.648]         else {
[17:45:42.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:42.648]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:42.648]         }
[17:45:42.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:42.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:42.648]             base::sink(type = "output", split = FALSE)
[17:45:42.648]             base::close(...future.stdout)
[17:45:42.648]         }, add = TRUE)
[17:45:42.648]     }
[17:45:42.648]     ...future.frame <- base::sys.nframe()
[17:45:42.648]     ...future.conditions <- base::list()
[17:45:42.648]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:42.648]     if (FALSE) {
[17:45:42.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:42.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:42.648]     }
[17:45:42.648]     ...future.result <- base::tryCatch({
[17:45:42.648]         base::withCallingHandlers({
[17:45:42.648]             ...future.value <- base::withVisible(base::local({
[17:45:42.648]                 withCallingHandlers({
[17:45:42.648]                   {
[17:45:42.648]                     do.call(function(...) {
[17:45:42.648]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:42.648]                       if (!identical(...future.globals.maxSize.org, 
[17:45:42.648]                         ...future.globals.maxSize)) {
[17:45:42.648]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:42.648]                         on.exit(options(oopts), add = TRUE)
[17:45:42.648]                       }
[17:45:42.648]                       {
[17:45:42.648]                         lapply(seq_along(...future.elements_ii), 
[17:45:42.648]                           FUN = function(jj) {
[17:45:42.648]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:42.648]                             ...future.FUN(...future.X_jj, ...)
[17:45:42.648]                           })
[17:45:42.648]                       }
[17:45:42.648]                     }, args = future.call.arguments)
[17:45:42.648]                   }
[17:45:42.648]                 }, immediateCondition = function(cond) {
[17:45:42.648]                   save_rds <- function (object, pathname, ...) 
[17:45:42.648]                   {
[17:45:42.648]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:42.648]                     if (file_test("-f", pathname_tmp)) {
[17:45:42.648]                       fi_tmp <- file.info(pathname_tmp)
[17:45:42.648]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:42.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:42.648]                         fi_tmp[["mtime"]])
[17:45:42.648]                     }
[17:45:42.648]                     tryCatch({
[17:45:42.648]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:42.648]                     }, error = function(ex) {
[17:45:42.648]                       msg <- conditionMessage(ex)
[17:45:42.648]                       fi_tmp <- file.info(pathname_tmp)
[17:45:42.648]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:42.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:42.648]                         fi_tmp[["mtime"]], msg)
[17:45:42.648]                       ex$message <- msg
[17:45:42.648]                       stop(ex)
[17:45:42.648]                     })
[17:45:42.648]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:42.648]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:42.648]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:42.648]                       fi_tmp <- file.info(pathname_tmp)
[17:45:42.648]                       fi <- file.info(pathname)
[17:45:42.648]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:42.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:42.648]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:42.648]                         fi[["size"]], fi[["mtime"]])
[17:45:42.648]                       stop(msg)
[17:45:42.648]                     }
[17:45:42.648]                     invisible(pathname)
[17:45:42.648]                   }
[17:45:42.648]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:42.648]                     rootPath = tempdir()) 
[17:45:42.648]                   {
[17:45:42.648]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:42.648]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:42.648]                       tmpdir = path, fileext = ".rds")
[17:45:42.648]                     save_rds(obj, file)
[17:45:42.648]                   }
[17:45:42.648]                   saveImmediateCondition(cond, path = "/tmp/RtmpnHaLG7/.future/immediateConditions")
[17:45:42.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:42.648]                   {
[17:45:42.648]                     inherits <- base::inherits
[17:45:42.648]                     invokeRestart <- base::invokeRestart
[17:45:42.648]                     is.null <- base::is.null
[17:45:42.648]                     muffled <- FALSE
[17:45:42.648]                     if (inherits(cond, "message")) {
[17:45:42.648]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:42.648]                       if (muffled) 
[17:45:42.648]                         invokeRestart("muffleMessage")
[17:45:42.648]                     }
[17:45:42.648]                     else if (inherits(cond, "warning")) {
[17:45:42.648]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:42.648]                       if (muffled) 
[17:45:42.648]                         invokeRestart("muffleWarning")
[17:45:42.648]                     }
[17:45:42.648]                     else if (inherits(cond, "condition")) {
[17:45:42.648]                       if (!is.null(pattern)) {
[17:45:42.648]                         computeRestarts <- base::computeRestarts
[17:45:42.648]                         grepl <- base::grepl
[17:45:42.648]                         restarts <- computeRestarts(cond)
[17:45:42.648]                         for (restart in restarts) {
[17:45:42.648]                           name <- restart$name
[17:45:42.648]                           if (is.null(name)) 
[17:45:42.648]                             next
[17:45:42.648]                           if (!grepl(pattern, name)) 
[17:45:42.648]                             next
[17:45:42.648]                           invokeRestart(restart)
[17:45:42.648]                           muffled <- TRUE
[17:45:42.648]                           break
[17:45:42.648]                         }
[17:45:42.648]                       }
[17:45:42.648]                     }
[17:45:42.648]                     invisible(muffled)
[17:45:42.648]                   }
[17:45:42.648]                   muffleCondition(cond)
[17:45:42.648]                 })
[17:45:42.648]             }))
[17:45:42.648]             future::FutureResult(value = ...future.value$value, 
[17:45:42.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:42.648]                   ...future.rng), globalenv = if (FALSE) 
[17:45:42.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:42.648]                     ...future.globalenv.names))
[17:45:42.648]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:42.648]         }, condition = base::local({
[17:45:42.648]             c <- base::c
[17:45:42.648]             inherits <- base::inherits
[17:45:42.648]             invokeRestart <- base::invokeRestart
[17:45:42.648]             length <- base::length
[17:45:42.648]             list <- base::list
[17:45:42.648]             seq.int <- base::seq.int
[17:45:42.648]             signalCondition <- base::signalCondition
[17:45:42.648]             sys.calls <- base::sys.calls
[17:45:42.648]             `[[` <- base::`[[`
[17:45:42.648]             `+` <- base::`+`
[17:45:42.648]             `<<-` <- base::`<<-`
[17:45:42.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:42.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:42.648]                   3L)]
[17:45:42.648]             }
[17:45:42.648]             function(cond) {
[17:45:42.648]                 is_error <- inherits(cond, "error")
[17:45:42.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:42.648]                   NULL)
[17:45:42.648]                 if (is_error) {
[17:45:42.648]                   sessionInformation <- function() {
[17:45:42.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:42.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:42.648]                       search = base::search(), system = base::Sys.info())
[17:45:42.648]                   }
[17:45:42.648]                   ...future.conditions[[length(...future.conditions) + 
[17:45:42.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:42.648]                     cond$call), session = sessionInformation(), 
[17:45:42.648]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:42.648]                   signalCondition(cond)
[17:45:42.648]                 }
[17:45:42.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:42.648]                 "immediateCondition"))) {
[17:45:42.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:42.648]                   ...future.conditions[[length(...future.conditions) + 
[17:45:42.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:42.648]                   if (TRUE && !signal) {
[17:45:42.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:42.648]                     {
[17:45:42.648]                       inherits <- base::inherits
[17:45:42.648]                       invokeRestart <- base::invokeRestart
[17:45:42.648]                       is.null <- base::is.null
[17:45:42.648]                       muffled <- FALSE
[17:45:42.648]                       if (inherits(cond, "message")) {
[17:45:42.648]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:42.648]                         if (muffled) 
[17:45:42.648]                           invokeRestart("muffleMessage")
[17:45:42.648]                       }
[17:45:42.648]                       else if (inherits(cond, "warning")) {
[17:45:42.648]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:42.648]                         if (muffled) 
[17:45:42.648]                           invokeRestart("muffleWarning")
[17:45:42.648]                       }
[17:45:42.648]                       else if (inherits(cond, "condition")) {
[17:45:42.648]                         if (!is.null(pattern)) {
[17:45:42.648]                           computeRestarts <- base::computeRestarts
[17:45:42.648]                           grepl <- base::grepl
[17:45:42.648]                           restarts <- computeRestarts(cond)
[17:45:42.648]                           for (restart in restarts) {
[17:45:42.648]                             name <- restart$name
[17:45:42.648]                             if (is.null(name)) 
[17:45:42.648]                               next
[17:45:42.648]                             if (!grepl(pattern, name)) 
[17:45:42.648]                               next
[17:45:42.648]                             invokeRestart(restart)
[17:45:42.648]                             muffled <- TRUE
[17:45:42.648]                             break
[17:45:42.648]                           }
[17:45:42.648]                         }
[17:45:42.648]                       }
[17:45:42.648]                       invisible(muffled)
[17:45:42.648]                     }
[17:45:42.648]                     muffleCondition(cond, pattern = "^muffle")
[17:45:42.648]                   }
[17:45:42.648]                 }
[17:45:42.648]                 else {
[17:45:42.648]                   if (TRUE) {
[17:45:42.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:42.648]                     {
[17:45:42.648]                       inherits <- base::inherits
[17:45:42.648]                       invokeRestart <- base::invokeRestart
[17:45:42.648]                       is.null <- base::is.null
[17:45:42.648]                       muffled <- FALSE
[17:45:42.648]                       if (inherits(cond, "message")) {
[17:45:42.648]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:42.648]                         if (muffled) 
[17:45:42.648]                           invokeRestart("muffleMessage")
[17:45:42.648]                       }
[17:45:42.648]                       else if (inherits(cond, "warning")) {
[17:45:42.648]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:42.648]                         if (muffled) 
[17:45:42.648]                           invokeRestart("muffleWarning")
[17:45:42.648]                       }
[17:45:42.648]                       else if (inherits(cond, "condition")) {
[17:45:42.648]                         if (!is.null(pattern)) {
[17:45:42.648]                           computeRestarts <- base::computeRestarts
[17:45:42.648]                           grepl <- base::grepl
[17:45:42.648]                           restarts <- computeRestarts(cond)
[17:45:42.648]                           for (restart in restarts) {
[17:45:42.648]                             name <- restart$name
[17:45:42.648]                             if (is.null(name)) 
[17:45:42.648]                               next
[17:45:42.648]                             if (!grepl(pattern, name)) 
[17:45:42.648]                               next
[17:45:42.648]                             invokeRestart(restart)
[17:45:42.648]                             muffled <- TRUE
[17:45:42.648]                             break
[17:45:42.648]                           }
[17:45:42.648]                         }
[17:45:42.648]                       }
[17:45:42.648]                       invisible(muffled)
[17:45:42.648]                     }
[17:45:42.648]                     muffleCondition(cond, pattern = "^muffle")
[17:45:42.648]                   }
[17:45:42.648]                 }
[17:45:42.648]             }
[17:45:42.648]         }))
[17:45:42.648]     }, error = function(ex) {
[17:45:42.648]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:42.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:42.648]                 ...future.rng), started = ...future.startTime, 
[17:45:42.648]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:42.648]             version = "1.8"), class = "FutureResult")
[17:45:42.648]     }, finally = {
[17:45:42.648]         if (!identical(...future.workdir, getwd())) 
[17:45:42.648]             setwd(...future.workdir)
[17:45:42.648]         {
[17:45:42.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:42.648]                 ...future.oldOptions$nwarnings <- NULL
[17:45:42.648]             }
[17:45:42.648]             base::options(...future.oldOptions)
[17:45:42.648]             if (.Platform$OS.type == "windows") {
[17:45:42.648]                 old_names <- names(...future.oldEnvVars)
[17:45:42.648]                 envs <- base::Sys.getenv()
[17:45:42.648]                 names <- names(envs)
[17:45:42.648]                 common <- intersect(names, old_names)
[17:45:42.648]                 added <- setdiff(names, old_names)
[17:45:42.648]                 removed <- setdiff(old_names, names)
[17:45:42.648]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:42.648]                   envs[common]]
[17:45:42.648]                 NAMES <- toupper(changed)
[17:45:42.648]                 args <- list()
[17:45:42.648]                 for (kk in seq_along(NAMES)) {
[17:45:42.648]                   name <- changed[[kk]]
[17:45:42.648]                   NAME <- NAMES[[kk]]
[17:45:42.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:42.648]                     next
[17:45:42.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:42.648]                 }
[17:45:42.648]                 NAMES <- toupper(added)
[17:45:42.648]                 for (kk in seq_along(NAMES)) {
[17:45:42.648]                   name <- added[[kk]]
[17:45:42.648]                   NAME <- NAMES[[kk]]
[17:45:42.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:42.648]                     next
[17:45:42.648]                   args[[name]] <- ""
[17:45:42.648]                 }
[17:45:42.648]                 NAMES <- toupper(removed)
[17:45:42.648]                 for (kk in seq_along(NAMES)) {
[17:45:42.648]                   name <- removed[[kk]]
[17:45:42.648]                   NAME <- NAMES[[kk]]
[17:45:42.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:42.648]                     next
[17:45:42.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:42.648]                 }
[17:45:42.648]                 if (length(args) > 0) 
[17:45:42.648]                   base::do.call(base::Sys.setenv, args = args)
[17:45:42.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:42.648]             }
[17:45:42.648]             else {
[17:45:42.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:42.648]             }
[17:45:42.648]             {
[17:45:42.648]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:42.648]                   0L) {
[17:45:42.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:42.648]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:42.648]                   base::options(opts)
[17:45:42.648]                 }
[17:45:42.648]                 {
[17:45:42.648]                   {
[17:45:42.648]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:42.648]                     NULL
[17:45:42.648]                   }
[17:45:42.648]                   options(future.plan = NULL)
[17:45:42.648]                   if (is.na(NA_character_)) 
[17:45:42.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:42.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:42.648]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:42.648]                     .init = FALSE)
[17:45:42.648]                 }
[17:45:42.648]             }
[17:45:42.648]         }
[17:45:42.648]     })
[17:45:42.648]     if (FALSE) {
[17:45:42.648]         base::sink(type = "output", split = FALSE)
[17:45:42.648]         if (NA) {
[17:45:42.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:42.648]         }
[17:45:42.648]         else {
[17:45:42.648]             ...future.result["stdout"] <- base::list(NULL)
[17:45:42.648]         }
[17:45:42.648]         base::close(...future.stdout)
[17:45:42.648]         ...future.stdout <- NULL
[17:45:42.648]     }
[17:45:42.648]     ...future.result$conditions <- ...future.conditions
[17:45:42.648]     ...future.result$finished <- base::Sys.time()
[17:45:42.648]     ...future.result
[17:45:42.648] }
[17:45:42.650] assign_globals() ...
[17:45:42.650] List of 5
[17:45:42.650]  $ ...future.FUN            :function (x)  
[17:45:42.650]  $ future.call.arguments    : list()
[17:45:42.650]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:42.650]  $ ...future.elements_ii    :List of 1
[17:45:42.650]   ..$ : int 1
[17:45:42.650]  $ ...future.seeds_ii       : NULL
[17:45:42.650]  $ ...future.globals.maxSize: NULL
[17:45:42.650]  - attr(*, "where")=List of 5
[17:45:42.650]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:42.650]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:42.650]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:42.650]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:42.650]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:42.650]  - attr(*, "resolved")= logi FALSE
[17:45:42.650]  - attr(*, "total_size")= num 4720
[17:45:42.650]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:42.650]  - attr(*, "already-done")= logi TRUE
[17:45:42.655] - reassign environment for ‘...future.FUN’
[17:45:42.655] - copied ‘...future.FUN’ to environment
[17:45:42.655] - copied ‘future.call.arguments’ to environment
[17:45:42.655] - copied ‘...future.elements_ii’ to environment
[17:45:42.655] - copied ‘...future.seeds_ii’ to environment
[17:45:42.655] - copied ‘...future.globals.maxSize’ to environment
[17:45:42.656] assign_globals() ... done
[17:45:42.656] requestCore(): workers = 2
[17:45:42.658] MulticoreFuture started
[17:45:42.658] - Launch lazy future ... done
[17:45:42.658] run() for ‘MulticoreFuture’ ... done
[17:45:42.659] Created future:
[17:45:42.659] plan(): Setting new future strategy stack:
[17:45:42.659] List of future strategies:
[17:45:42.659] 1. sequential:
[17:45:42.659]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:42.659]    - tweaked: FALSE
[17:45:42.659]    - call: NULL
[17:45:42.660] plan(): nbrOfWorkers() = 1
[17:45:42.659] MulticoreFuture:
[17:45:42.659] Label: ‘future_lapply-1’
[17:45:42.659] Expression:
[17:45:42.659] {
[17:45:42.659]     do.call(function(...) {
[17:45:42.659]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:42.659]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:42.659]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:42.659]             on.exit(options(oopts), add = TRUE)
[17:45:42.659]         }
[17:45:42.659]         {
[17:45:42.659]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:42.659]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:42.659]                 ...future.FUN(...future.X_jj, ...)
[17:45:42.659]             })
[17:45:42.659]         }
[17:45:42.659]     }, args = future.call.arguments)
[17:45:42.659] }
[17:45:42.659] Lazy evaluation: FALSE
[17:45:42.659] Asynchronous evaluation: TRUE
[17:45:42.659] Local evaluation: TRUE
[17:45:42.659] Environment: R_GlobalEnv
[17:45:42.659] Capture standard output: NA
[17:45:42.659] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:42.659] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:42.659] Packages: <none>
[17:45:42.659] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:42.659] Resolved: FALSE
[17:45:42.659] Value: <not collected>
[17:45:42.659] Conditions captured: <none>
[17:45:42.659] Early signaling: FALSE
[17:45:42.659] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:42.659] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:42.672] Chunk #1 of 2 ... DONE
[17:45:42.672] Chunk #2 of 2 ...
[17:45:42.672]  - Finding globals in 'X' for chunk #2 ...
[17:45:42.673] getGlobalsAndPackages() ...
[17:45:42.673] Searching for globals...
[17:45:42.673] 
[17:45:42.673] Searching for globals ... DONE
[17:45:42.674] - globals: [0] <none>
[17:45:42.674] getGlobalsAndPackages() ... DONE
[17:45:42.674]    + additional globals found: [n=0] 
[17:45:42.674]    + additional namespaces needed: [n=0] 
[17:45:42.674]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:42.674]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:42.675]  - seeds: <none>
[17:45:42.675]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:42.675] getGlobalsAndPackages() ...
[17:45:42.675] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:42.675] Resolving globals: FALSE
[17:45:42.675] Tweak future expression to call with '...' arguments ...
[17:45:42.676] {
[17:45:42.676]     do.call(function(...) {
[17:45:42.676]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:42.676]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:42.676]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:42.676]             on.exit(options(oopts), add = TRUE)
[17:45:42.676]         }
[17:45:42.676]         {
[17:45:42.676]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:42.676]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:42.676]                 ...future.FUN(...future.X_jj, ...)
[17:45:42.676]             })
[17:45:42.676]         }
[17:45:42.676]     }, args = future.call.arguments)
[17:45:42.676] }
[17:45:42.676] Tweak future expression to call with '...' arguments ... DONE
[17:45:42.677] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:42.677] 
[17:45:42.677] getGlobalsAndPackages() ... DONE
[17:45:42.678] run() for ‘Future’ ...
[17:45:42.678] - state: ‘created’
[17:45:42.678] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:42.683] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:42.684] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:42.684]   - Field: ‘label’
[17:45:42.684]   - Field: ‘local’
[17:45:42.684]   - Field: ‘owner’
[17:45:42.684]   - Field: ‘envir’
[17:45:42.684]   - Field: ‘workers’
[17:45:42.685]   - Field: ‘packages’
[17:45:42.685]   - Field: ‘gc’
[17:45:42.685]   - Field: ‘job’
[17:45:42.685]   - Field: ‘conditions’
[17:45:42.685]   - Field: ‘expr’
[17:45:42.685]   - Field: ‘uuid’
[17:45:42.686]   - Field: ‘seed’
[17:45:42.686]   - Field: ‘version’
[17:45:42.686]   - Field: ‘result’
[17:45:42.686]   - Field: ‘asynchronous’
[17:45:42.686]   - Field: ‘calls’
[17:45:42.686]   - Field: ‘globals’
[17:45:42.687]   - Field: ‘stdout’
[17:45:42.687]   - Field: ‘earlySignal’
[17:45:42.687]   - Field: ‘lazy’
[17:45:42.687]   - Field: ‘state’
[17:45:42.687] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:42.687] - Launch lazy future ...
[17:45:42.688] Packages needed by the future expression (n = 0): <none>
[17:45:42.688] Packages needed by future strategies (n = 0): <none>
[17:45:42.689] {
[17:45:42.689]     {
[17:45:42.689]         {
[17:45:42.689]             ...future.startTime <- base::Sys.time()
[17:45:42.689]             {
[17:45:42.689]                 {
[17:45:42.689]                   {
[17:45:42.689]                     {
[17:45:42.689]                       base::local({
[17:45:42.689]                         has_future <- base::requireNamespace("future", 
[17:45:42.689]                           quietly = TRUE)
[17:45:42.689]                         if (has_future) {
[17:45:42.689]                           ns <- base::getNamespace("future")
[17:45:42.689]                           version <- ns[[".package"]][["version"]]
[17:45:42.689]                           if (is.null(version)) 
[17:45:42.689]                             version <- utils::packageVersion("future")
[17:45:42.689]                         }
[17:45:42.689]                         else {
[17:45:42.689]                           version <- NULL
[17:45:42.689]                         }
[17:45:42.689]                         if (!has_future || version < "1.8.0") {
[17:45:42.689]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:42.689]                             "", base::R.version$version.string), 
[17:45:42.689]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:42.689]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:42.689]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:42.689]                               "release", "version")], collapse = " "), 
[17:45:42.689]                             hostname = base::Sys.info()[["nodename"]])
[17:45:42.689]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:42.689]                             info)
[17:45:42.689]                           info <- base::paste(info, collapse = "; ")
[17:45:42.689]                           if (!has_future) {
[17:45:42.689]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:42.689]                               info)
[17:45:42.689]                           }
[17:45:42.689]                           else {
[17:45:42.689]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:42.689]                               info, version)
[17:45:42.689]                           }
[17:45:42.689]                           base::stop(msg)
[17:45:42.689]                         }
[17:45:42.689]                       })
[17:45:42.689]                     }
[17:45:42.689]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:42.689]                     base::options(mc.cores = 1L)
[17:45:42.689]                   }
[17:45:42.689]                   ...future.strategy.old <- future::plan("list")
[17:45:42.689]                   options(future.plan = NULL)
[17:45:42.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:42.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:42.689]                 }
[17:45:42.689]                 ...future.workdir <- getwd()
[17:45:42.689]             }
[17:45:42.689]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:42.689]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:42.689]         }
[17:45:42.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:42.689]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:42.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:42.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:42.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:42.689]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:42.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:42.689]             base::names(...future.oldOptions))
[17:45:42.689]     }
[17:45:42.689]     if (TRUE) {
[17:45:42.689]     }
[17:45:42.689]     else {
[17:45:42.689]         if (NA) {
[17:45:42.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:42.689]                 open = "w")
[17:45:42.689]         }
[17:45:42.689]         else {
[17:45:42.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:42.689]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:42.689]         }
[17:45:42.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:42.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:42.689]             base::sink(type = "output", split = FALSE)
[17:45:42.689]             base::close(...future.stdout)
[17:45:42.689]         }, add = TRUE)
[17:45:42.689]     }
[17:45:42.689]     ...future.frame <- base::sys.nframe()
[17:45:42.689]     ...future.conditions <- base::list()
[17:45:42.689]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:42.689]     if (FALSE) {
[17:45:42.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:42.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:42.689]     }
[17:45:42.689]     ...future.result <- base::tryCatch({
[17:45:42.689]         base::withCallingHandlers({
[17:45:42.689]             ...future.value <- base::withVisible(base::local({
[17:45:42.689]                 withCallingHandlers({
[17:45:42.689]                   {
[17:45:42.689]                     do.call(function(...) {
[17:45:42.689]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:42.689]                       if (!identical(...future.globals.maxSize.org, 
[17:45:42.689]                         ...future.globals.maxSize)) {
[17:45:42.689]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:42.689]                         on.exit(options(oopts), add = TRUE)
[17:45:42.689]                       }
[17:45:42.689]                       {
[17:45:42.689]                         lapply(seq_along(...future.elements_ii), 
[17:45:42.689]                           FUN = function(jj) {
[17:45:42.689]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:42.689]                             ...future.FUN(...future.X_jj, ...)
[17:45:42.689]                           })
[17:45:42.689]                       }
[17:45:42.689]                     }, args = future.call.arguments)
[17:45:42.689]                   }
[17:45:42.689]                 }, immediateCondition = function(cond) {
[17:45:42.689]                   save_rds <- function (object, pathname, ...) 
[17:45:42.689]                   {
[17:45:42.689]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:42.689]                     if (file_test("-f", pathname_tmp)) {
[17:45:42.689]                       fi_tmp <- file.info(pathname_tmp)
[17:45:42.689]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:42.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:42.689]                         fi_tmp[["mtime"]])
[17:45:42.689]                     }
[17:45:42.689]                     tryCatch({
[17:45:42.689]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:42.689]                     }, error = function(ex) {
[17:45:42.689]                       msg <- conditionMessage(ex)
[17:45:42.689]                       fi_tmp <- file.info(pathname_tmp)
[17:45:42.689]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:42.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:42.689]                         fi_tmp[["mtime"]], msg)
[17:45:42.689]                       ex$message <- msg
[17:45:42.689]                       stop(ex)
[17:45:42.689]                     })
[17:45:42.689]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:42.689]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:42.689]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:42.689]                       fi_tmp <- file.info(pathname_tmp)
[17:45:42.689]                       fi <- file.info(pathname)
[17:45:42.689]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:42.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:42.689]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:42.689]                         fi[["size"]], fi[["mtime"]])
[17:45:42.689]                       stop(msg)
[17:45:42.689]                     }
[17:45:42.689]                     invisible(pathname)
[17:45:42.689]                   }
[17:45:42.689]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:42.689]                     rootPath = tempdir()) 
[17:45:42.689]                   {
[17:45:42.689]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:42.689]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:42.689]                       tmpdir = path, fileext = ".rds")
[17:45:42.689]                     save_rds(obj, file)
[17:45:42.689]                   }
[17:45:42.689]                   saveImmediateCondition(cond, path = "/tmp/RtmpnHaLG7/.future/immediateConditions")
[17:45:42.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:42.689]                   {
[17:45:42.689]                     inherits <- base::inherits
[17:45:42.689]                     invokeRestart <- base::invokeRestart
[17:45:42.689]                     is.null <- base::is.null
[17:45:42.689]                     muffled <- FALSE
[17:45:42.689]                     if (inherits(cond, "message")) {
[17:45:42.689]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:42.689]                       if (muffled) 
[17:45:42.689]                         invokeRestart("muffleMessage")
[17:45:42.689]                     }
[17:45:42.689]                     else if (inherits(cond, "warning")) {
[17:45:42.689]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:42.689]                       if (muffled) 
[17:45:42.689]                         invokeRestart("muffleWarning")
[17:45:42.689]                     }
[17:45:42.689]                     else if (inherits(cond, "condition")) {
[17:45:42.689]                       if (!is.null(pattern)) {
[17:45:42.689]                         computeRestarts <- base::computeRestarts
[17:45:42.689]                         grepl <- base::grepl
[17:45:42.689]                         restarts <- computeRestarts(cond)
[17:45:42.689]                         for (restart in restarts) {
[17:45:42.689]                           name <- restart$name
[17:45:42.689]                           if (is.null(name)) 
[17:45:42.689]                             next
[17:45:42.689]                           if (!grepl(pattern, name)) 
[17:45:42.689]                             next
[17:45:42.689]                           invokeRestart(restart)
[17:45:42.689]                           muffled <- TRUE
[17:45:42.689]                           break
[17:45:42.689]                         }
[17:45:42.689]                       }
[17:45:42.689]                     }
[17:45:42.689]                     invisible(muffled)
[17:45:42.689]                   }
[17:45:42.689]                   muffleCondition(cond)
[17:45:42.689]                 })
[17:45:42.689]             }))
[17:45:42.689]             future::FutureResult(value = ...future.value$value, 
[17:45:42.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:42.689]                   ...future.rng), globalenv = if (FALSE) 
[17:45:42.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:42.689]                     ...future.globalenv.names))
[17:45:42.689]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:42.689]         }, condition = base::local({
[17:45:42.689]             c <- base::c
[17:45:42.689]             inherits <- base::inherits
[17:45:42.689]             invokeRestart <- base::invokeRestart
[17:45:42.689]             length <- base::length
[17:45:42.689]             list <- base::list
[17:45:42.689]             seq.int <- base::seq.int
[17:45:42.689]             signalCondition <- base::signalCondition
[17:45:42.689]             sys.calls <- base::sys.calls
[17:45:42.689]             `[[` <- base::`[[`
[17:45:42.689]             `+` <- base::`+`
[17:45:42.689]             `<<-` <- base::`<<-`
[17:45:42.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:42.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:42.689]                   3L)]
[17:45:42.689]             }
[17:45:42.689]             function(cond) {
[17:45:42.689]                 is_error <- inherits(cond, "error")
[17:45:42.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:42.689]                   NULL)
[17:45:42.689]                 if (is_error) {
[17:45:42.689]                   sessionInformation <- function() {
[17:45:42.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:42.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:42.689]                       search = base::search(), system = base::Sys.info())
[17:45:42.689]                   }
[17:45:42.689]                   ...future.conditions[[length(...future.conditions) + 
[17:45:42.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:42.689]                     cond$call), session = sessionInformation(), 
[17:45:42.689]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:42.689]                   signalCondition(cond)
[17:45:42.689]                 }
[17:45:42.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:42.689]                 "immediateCondition"))) {
[17:45:42.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:42.689]                   ...future.conditions[[length(...future.conditions) + 
[17:45:42.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:42.689]                   if (TRUE && !signal) {
[17:45:42.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:42.689]                     {
[17:45:42.689]                       inherits <- base::inherits
[17:45:42.689]                       invokeRestart <- base::invokeRestart
[17:45:42.689]                       is.null <- base::is.null
[17:45:42.689]                       muffled <- FALSE
[17:45:42.689]                       if (inherits(cond, "message")) {
[17:45:42.689]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:42.689]                         if (muffled) 
[17:45:42.689]                           invokeRestart("muffleMessage")
[17:45:42.689]                       }
[17:45:42.689]                       else if (inherits(cond, "warning")) {
[17:45:42.689]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:42.689]                         if (muffled) 
[17:45:42.689]                           invokeRestart("muffleWarning")
[17:45:42.689]                       }
[17:45:42.689]                       else if (inherits(cond, "condition")) {
[17:45:42.689]                         if (!is.null(pattern)) {
[17:45:42.689]                           computeRestarts <- base::computeRestarts
[17:45:42.689]                           grepl <- base::grepl
[17:45:42.689]                           restarts <- computeRestarts(cond)
[17:45:42.689]                           for (restart in restarts) {
[17:45:42.689]                             name <- restart$name
[17:45:42.689]                             if (is.null(name)) 
[17:45:42.689]                               next
[17:45:42.689]                             if (!grepl(pattern, name)) 
[17:45:42.689]                               next
[17:45:42.689]                             invokeRestart(restart)
[17:45:42.689]                             muffled <- TRUE
[17:45:42.689]                             break
[17:45:42.689]                           }
[17:45:42.689]                         }
[17:45:42.689]                       }
[17:45:42.689]                       invisible(muffled)
[17:45:42.689]                     }
[17:45:42.689]                     muffleCondition(cond, pattern = "^muffle")
[17:45:42.689]                   }
[17:45:42.689]                 }
[17:45:42.689]                 else {
[17:45:42.689]                   if (TRUE) {
[17:45:42.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:42.689]                     {
[17:45:42.689]                       inherits <- base::inherits
[17:45:42.689]                       invokeRestart <- base::invokeRestart
[17:45:42.689]                       is.null <- base::is.null
[17:45:42.689]                       muffled <- FALSE
[17:45:42.689]                       if (inherits(cond, "message")) {
[17:45:42.689]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:42.689]                         if (muffled) 
[17:45:42.689]                           invokeRestart("muffleMessage")
[17:45:42.689]                       }
[17:45:42.689]                       else if (inherits(cond, "warning")) {
[17:45:42.689]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:42.689]                         if (muffled) 
[17:45:42.689]                           invokeRestart("muffleWarning")
[17:45:42.689]                       }
[17:45:42.689]                       else if (inherits(cond, "condition")) {
[17:45:42.689]                         if (!is.null(pattern)) {
[17:45:42.689]                           computeRestarts <- base::computeRestarts
[17:45:42.689]                           grepl <- base::grepl
[17:45:42.689]                           restarts <- computeRestarts(cond)
[17:45:42.689]                           for (restart in restarts) {
[17:45:42.689]                             name <- restart$name
[17:45:42.689]                             if (is.null(name)) 
[17:45:42.689]                               next
[17:45:42.689]                             if (!grepl(pattern, name)) 
[17:45:42.689]                               next
[17:45:42.689]                             invokeRestart(restart)
[17:45:42.689]                             muffled <- TRUE
[17:45:42.689]                             break
[17:45:42.689]                           }
[17:45:42.689]                         }
[17:45:42.689]                       }
[17:45:42.689]                       invisible(muffled)
[17:45:42.689]                     }
[17:45:42.689]                     muffleCondition(cond, pattern = "^muffle")
[17:45:42.689]                   }
[17:45:42.689]                 }
[17:45:42.689]             }
[17:45:42.689]         }))
[17:45:42.689]     }, error = function(ex) {
[17:45:42.689]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:42.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:42.689]                 ...future.rng), started = ...future.startTime, 
[17:45:42.689]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:42.689]             version = "1.8"), class = "FutureResult")
[17:45:42.689]     }, finally = {
[17:45:42.689]         if (!identical(...future.workdir, getwd())) 
[17:45:42.689]             setwd(...future.workdir)
[17:45:42.689]         {
[17:45:42.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:42.689]                 ...future.oldOptions$nwarnings <- NULL
[17:45:42.689]             }
[17:45:42.689]             base::options(...future.oldOptions)
[17:45:42.689]             if (.Platform$OS.type == "windows") {
[17:45:42.689]                 old_names <- names(...future.oldEnvVars)
[17:45:42.689]                 envs <- base::Sys.getenv()
[17:45:42.689]                 names <- names(envs)
[17:45:42.689]                 common <- intersect(names, old_names)
[17:45:42.689]                 added <- setdiff(names, old_names)
[17:45:42.689]                 removed <- setdiff(old_names, names)
[17:45:42.689]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:42.689]                   envs[common]]
[17:45:42.689]                 NAMES <- toupper(changed)
[17:45:42.689]                 args <- list()
[17:45:42.689]                 for (kk in seq_along(NAMES)) {
[17:45:42.689]                   name <- changed[[kk]]
[17:45:42.689]                   NAME <- NAMES[[kk]]
[17:45:42.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:42.689]                     next
[17:45:42.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:42.689]                 }
[17:45:42.689]                 NAMES <- toupper(added)
[17:45:42.689]                 for (kk in seq_along(NAMES)) {
[17:45:42.689]                   name <- added[[kk]]
[17:45:42.689]                   NAME <- NAMES[[kk]]
[17:45:42.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:42.689]                     next
[17:45:42.689]                   args[[name]] <- ""
[17:45:42.689]                 }
[17:45:42.689]                 NAMES <- toupper(removed)
[17:45:42.689]                 for (kk in seq_along(NAMES)) {
[17:45:42.689]                   name <- removed[[kk]]
[17:45:42.689]                   NAME <- NAMES[[kk]]
[17:45:42.689]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:42.689]                     next
[17:45:42.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:42.689]                 }
[17:45:42.689]                 if (length(args) > 0) 
[17:45:42.689]                   base::do.call(base::Sys.setenv, args = args)
[17:45:42.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:42.689]             }
[17:45:42.689]             else {
[17:45:42.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:42.689]             }
[17:45:42.689]             {
[17:45:42.689]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:42.689]                   0L) {
[17:45:42.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:42.689]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:42.689]                   base::options(opts)
[17:45:42.689]                 }
[17:45:42.689]                 {
[17:45:42.689]                   {
[17:45:42.689]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:42.689]                     NULL
[17:45:42.689]                   }
[17:45:42.689]                   options(future.plan = NULL)
[17:45:42.689]                   if (is.na(NA_character_)) 
[17:45:42.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:42.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:42.689]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:42.689]                     .init = FALSE)
[17:45:42.689]                 }
[17:45:42.689]             }
[17:45:42.689]         }
[17:45:42.689]     })
[17:45:42.689]     if (FALSE) {
[17:45:42.689]         base::sink(type = "output", split = FALSE)
[17:45:42.689]         if (NA) {
[17:45:42.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:42.689]         }
[17:45:42.689]         else {
[17:45:42.689]             ...future.result["stdout"] <- base::list(NULL)
[17:45:42.689]         }
[17:45:42.689]         base::close(...future.stdout)
[17:45:42.689]         ...future.stdout <- NULL
[17:45:42.689]     }
[17:45:42.689]     ...future.result$conditions <- ...future.conditions
[17:45:42.689]     ...future.result$finished <- base::Sys.time()
[17:45:42.689]     ...future.result
[17:45:42.689] }
[17:45:42.692] assign_globals() ...
[17:45:42.692] List of 5
[17:45:42.692]  $ ...future.FUN            :function (x)  
[17:45:42.692]  $ future.call.arguments    : list()
[17:45:42.692]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:42.692]  $ ...future.elements_ii    :List of 1
[17:45:42.692]   ..$ : int 0
[17:45:42.692]  $ ...future.seeds_ii       : NULL
[17:45:42.692]  $ ...future.globals.maxSize: NULL
[17:45:42.692]  - attr(*, "where")=List of 5
[17:45:42.692]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:42.692]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:42.692]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:42.692]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:42.692]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:42.692]  - attr(*, "resolved")= logi FALSE
[17:45:42.692]  - attr(*, "total_size")= num 4720
[17:45:42.692]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:42.692]  - attr(*, "already-done")= logi TRUE
[17:45:42.699] - reassign environment for ‘...future.FUN’
[17:45:42.699] - copied ‘...future.FUN’ to environment
[17:45:42.699] - copied ‘future.call.arguments’ to environment
[17:45:42.700] - copied ‘...future.elements_ii’ to environment
[17:45:42.700] - copied ‘...future.seeds_ii’ to environment
[17:45:42.700] - copied ‘...future.globals.maxSize’ to environment
[17:45:42.700] assign_globals() ... done
[17:45:42.700] requestCore(): workers = 2
[17:45:42.702] MulticoreFuture started
[17:45:42.703] - Launch lazy future ... done
[17:45:42.703] plan(): Setting new future strategy stack:
[17:45:42.703] run() for ‘MulticoreFuture’ ... done
[17:45:42.708] Created future:
[17:45:42.704] List of future strategies:
[17:45:42.704] 1. sequential:
[17:45:42.704]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:42.704]    - tweaked: FALSE
[17:45:42.704]    - call: NULL
[17:45:42.709] plan(): nbrOfWorkers() = 1
[17:45:42.712] plan(): Setting new future strategy stack:
[17:45:42.712] List of future strategies:
[17:45:42.712] 1. multicore:
[17:45:42.712]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:42.712]    - tweaked: FALSE
[17:45:42.712]    - call: plan(strategy)
[17:45:42.718] plan(): nbrOfWorkers() = 2
[17:45:42.708] MulticoreFuture:
[17:45:42.708] Label: ‘future_lapply-2’
[17:45:42.708] Expression:
[17:45:42.708] {
[17:45:42.708]     do.call(function(...) {
[17:45:42.708]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:42.708]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:42.708]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:42.708]             on.exit(options(oopts), add = TRUE)
[17:45:42.708]         }
[17:45:42.708]         {
[17:45:42.708]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:42.708]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:42.708]                 ...future.FUN(...future.X_jj, ...)
[17:45:42.708]             })
[17:45:42.708]         }
[17:45:42.708]     }, args = future.call.arguments)
[17:45:42.708] }
[17:45:42.708] Lazy evaluation: FALSE
[17:45:42.708] Asynchronous evaluation: TRUE
[17:45:42.708] Local evaluation: TRUE
[17:45:42.708] Environment: R_GlobalEnv
[17:45:42.708] Capture standard output: NA
[17:45:42.708] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:42.708] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:42.708] Packages: <none>
[17:45:42.708] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:42.708] Resolved: TRUE
[17:45:42.708] Value: <not collected>
[17:45:42.708] Conditions captured: <none>
[17:45:42.708] Early signaling: FALSE
[17:45:42.708] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:42.708] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:42.720] Chunk #2 of 2 ... DONE
[17:45:42.720] Launching 2 futures (chunks) ... DONE
[17:45:42.720] Resolving 2 futures (chunks) ...
[17:45:42.720] resolve() on list ...
[17:45:42.720]  recursive: 0
[17:45:42.721]  length: 2
[17:45:42.721] 
[17:45:42.732] Future #2
[17:45:42.732] result() for MulticoreFuture ...
[17:45:42.733] result() for MulticoreFuture ...
[17:45:42.733] result() for MulticoreFuture ... done
[17:45:42.733] result() for MulticoreFuture ... done
[17:45:42.734] result() for MulticoreFuture ...
[17:45:42.734] result() for MulticoreFuture ... done
[17:45:42.734] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:42.734] - nx: 2
[17:45:42.734] - relay: TRUE
[17:45:42.734] - stdout: TRUE
[17:45:42.734] - signal: TRUE
[17:45:42.734] - resignal: FALSE
[17:45:42.735] - force: TRUE
[17:45:42.735] - relayed: [n=2] FALSE, FALSE
[17:45:42.735] - queued futures: [n=2] FALSE, FALSE
[17:45:42.735]  - until=1
[17:45:42.735]  - relaying element #1
[17:45:42.735] - relayed: [n=2] FALSE, FALSE
[17:45:42.736] - queued futures: [n=2] FALSE, TRUE
[17:45:42.736] signalConditionsASAP(NULL, pos=2) ... done
[17:45:42.736]  length: 1 (resolved future 2)
[17:45:43.163] plan(): Setting new future strategy stack:
[17:45:43.163] List of future strategies:
[17:45:43.163] 1. multicore:
[17:45:43.163]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:43.163]    - tweaked: FALSE
[17:45:43.163]    - call: plan(strategy)
[17:45:43.167] plan(): nbrOfWorkers() = 2
[17:45:43.175] Future #1
[17:45:43.175] result() for MulticoreFuture ...
[17:45:43.176] result() for MulticoreFuture ...
[17:45:43.176] result() for MulticoreFuture ... done
[17:45:43.176] result() for MulticoreFuture ... done
[17:45:43.176] result() for MulticoreFuture ...
[17:45:43.176] result() for MulticoreFuture ... done
[17:45:43.176] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:43.176] - nx: 2
[17:45:43.177] - relay: TRUE
[17:45:43.177] - stdout: TRUE
[17:45:43.177] - signal: TRUE
[17:45:43.177] - resignal: FALSE
[17:45:43.177] - force: TRUE
[17:45:43.177] - relayed: [n=2] FALSE, FALSE
[17:45:43.177] - queued futures: [n=2] FALSE, TRUE
[17:45:43.177]  - until=1
[17:45:43.177]  - relaying element #1
[17:45:43.178] result() for MulticoreFuture ...
[17:45:43.178] result() for MulticoreFuture ... done
[17:45:43.178] result() for MulticoreFuture ...
[17:45:43.178] result() for MulticoreFuture ... done
[17:45:43.178] result() for MulticoreFuture ...
[17:45:43.178] result() for MulticoreFuture ... done
[17:45:43.178] result() for MulticoreFuture ...
[17:45:43.178] result() for MulticoreFuture ... done
[17:45:43.178] - relayed: [n=2] TRUE, FALSE
[17:45:43.178] - queued futures: [n=2] TRUE, TRUE
[17:45:43.179] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:43.179]  length: 0 (resolved future 1)
[17:45:43.179] Relaying remaining futures
[17:45:43.179] signalConditionsASAP(NULL, pos=0) ...
[17:45:43.179] - nx: 2
[17:45:43.179] - relay: TRUE
[17:45:43.179] - stdout: TRUE
[17:45:43.179] - signal: TRUE
[17:45:43.179] - resignal: FALSE
[17:45:43.180] - force: TRUE
[17:45:43.180] - relayed: [n=2] TRUE, FALSE
[17:45:43.180] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:43.180]  - relaying element #2
[17:45:43.180] result() for MulticoreFuture ...
[17:45:43.180] result() for MulticoreFuture ... done
[17:45:43.180] result() for MulticoreFuture ...
[17:45:43.180] result() for MulticoreFuture ... done
[17:45:43.180] result() for MulticoreFuture ...
[17:45:43.181] result() for MulticoreFuture ... done
[17:45:43.181] result() for MulticoreFuture ...
[17:45:43.181] result() for MulticoreFuture ... done
[17:45:43.181] - relayed: [n=2] TRUE, TRUE
[17:45:43.181] - queued futures: [n=2] TRUE, TRUE
[17:45:43.181] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:45:43.181] resolve() on list ... DONE
[17:45:43.181] result() for MulticoreFuture ...
[17:45:43.181] result() for MulticoreFuture ... done
[17:45:43.181] result() for MulticoreFuture ...
[17:45:43.182] result() for MulticoreFuture ... done
[17:45:43.182] result() for MulticoreFuture ...
[17:45:43.182] result() for MulticoreFuture ... done
[17:45:43.182] result() for MulticoreFuture ...
[17:45:43.182] result() for MulticoreFuture ... done
[17:45:43.182]  - Number of value chunks collected: 2
[17:45:43.182] Resolving 2 futures (chunks) ... DONE
[17:45:43.182] Reducing values from 2 chunks ...
[17:45:43.182]  - Number of values collected after concatenation: 2
[17:45:43.182]  - Number of values expected: 2
[17:45:43.183] Reducing values from 2 chunks ... DONE
[17:45:43.183] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:45:43.183] future_mapply() ...
[17:45:43.187] Number of chunks: 2
[17:45:43.187] getGlobalsAndPackagesXApply() ...
[17:45:43.188]  - future.globals: TRUE
[17:45:43.188] getGlobalsAndPackages() ...
[17:45:43.188] Searching for globals...
[17:45:43.190] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:43.190] Searching for globals ... DONE
[17:45:43.190] Resolving globals: FALSE
[17:45:43.190] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:43.191] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:43.191] - globals: [1] ‘FUN’
[17:45:43.191] 
[17:45:43.191] getGlobalsAndPackages() ... DONE
[17:45:43.191]  - globals found/used: [n=1] ‘FUN’
[17:45:43.191]  - needed namespaces: [n=0] 
[17:45:43.191] Finding globals ... DONE
[17:45:43.192] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:43.192] List of 2
[17:45:43.192]  $ ...future.FUN:function (x, y)  
[17:45:43.192]  $ MoreArgs     : NULL
[17:45:43.192]  - attr(*, "where")=List of 2
[17:45:43.192]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:43.192]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:43.192]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:43.192]  - attr(*, "resolved")= logi FALSE
[17:45:43.192]  - attr(*, "total_size")= num NA
[17:45:43.194] Packages to be attached in all futures: [n=0] 
[17:45:43.195] getGlobalsAndPackagesXApply() ... DONE
[17:45:43.195] Number of futures (= number of chunks): 2
[17:45:43.195] Launching 2 futures (chunks) ...
[17:45:43.195] Chunk #1 of 2 ...
[17:45:43.195]  - Finding globals in '...' for chunk #1 ...
[17:45:43.195] getGlobalsAndPackages() ...
[17:45:43.195] Searching for globals...
[17:45:43.196] 
[17:45:43.196] Searching for globals ... DONE
[17:45:43.196] - globals: [0] <none>
[17:45:43.196] getGlobalsAndPackages() ... DONE
[17:45:43.196]    + additional globals found: [n=0] 
[17:45:43.198]    + additional namespaces needed: [n=0] 
[17:45:43.198]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:43.198]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:43.198]  - seeds: <none>
[17:45:43.198]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:43.198] getGlobalsAndPackages() ...
[17:45:43.198] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:43.199] Resolving globals: FALSE
[17:45:43.199] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:45:43.200] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:43.200] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:43.200] 
[17:45:43.200] getGlobalsAndPackages() ... DONE
[17:45:43.200] run() for ‘Future’ ...
[17:45:43.200] - state: ‘created’
[17:45:43.201] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:43.204] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:43.204] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:43.204]   - Field: ‘label’
[17:45:43.205]   - Field: ‘local’
[17:45:43.205]   - Field: ‘owner’
[17:45:43.205]   - Field: ‘envir’
[17:45:43.205]   - Field: ‘workers’
[17:45:43.205]   - Field: ‘packages’
[17:45:43.205]   - Field: ‘gc’
[17:45:43.205]   - Field: ‘job’
[17:45:43.205]   - Field: ‘conditions’
[17:45:43.205]   - Field: ‘expr’
[17:45:43.205]   - Field: ‘uuid’
[17:45:43.205]   - Field: ‘seed’
[17:45:43.206]   - Field: ‘version’
[17:45:43.206]   - Field: ‘result’
[17:45:43.206]   - Field: ‘asynchronous’
[17:45:43.206]   - Field: ‘calls’
[17:45:43.206]   - Field: ‘globals’
[17:45:43.206]   - Field: ‘stdout’
[17:45:43.206]   - Field: ‘earlySignal’
[17:45:43.206]   - Field: ‘lazy’
[17:45:43.206]   - Field: ‘state’
[17:45:43.206] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:43.207] - Launch lazy future ...
[17:45:43.207] Packages needed by the future expression (n = 0): <none>
[17:45:43.207] Packages needed by future strategies (n = 0): <none>
[17:45:43.207] {
[17:45:43.207]     {
[17:45:43.207]         {
[17:45:43.207]             ...future.startTime <- base::Sys.time()
[17:45:43.207]             {
[17:45:43.207]                 {
[17:45:43.207]                   {
[17:45:43.207]                     {
[17:45:43.207]                       base::local({
[17:45:43.207]                         has_future <- base::requireNamespace("future", 
[17:45:43.207]                           quietly = TRUE)
[17:45:43.207]                         if (has_future) {
[17:45:43.207]                           ns <- base::getNamespace("future")
[17:45:43.207]                           version <- ns[[".package"]][["version"]]
[17:45:43.207]                           if (is.null(version)) 
[17:45:43.207]                             version <- utils::packageVersion("future")
[17:45:43.207]                         }
[17:45:43.207]                         else {
[17:45:43.207]                           version <- NULL
[17:45:43.207]                         }
[17:45:43.207]                         if (!has_future || version < "1.8.0") {
[17:45:43.207]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:43.207]                             "", base::R.version$version.string), 
[17:45:43.207]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:43.207]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:43.207]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:43.207]                               "release", "version")], collapse = " "), 
[17:45:43.207]                             hostname = base::Sys.info()[["nodename"]])
[17:45:43.207]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:43.207]                             info)
[17:45:43.207]                           info <- base::paste(info, collapse = "; ")
[17:45:43.207]                           if (!has_future) {
[17:45:43.207]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:43.207]                               info)
[17:45:43.207]                           }
[17:45:43.207]                           else {
[17:45:43.207]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:43.207]                               info, version)
[17:45:43.207]                           }
[17:45:43.207]                           base::stop(msg)
[17:45:43.207]                         }
[17:45:43.207]                       })
[17:45:43.207]                     }
[17:45:43.207]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:43.207]                     base::options(mc.cores = 1L)
[17:45:43.207]                   }
[17:45:43.207]                   ...future.strategy.old <- future::plan("list")
[17:45:43.207]                   options(future.plan = NULL)
[17:45:43.207]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:43.207]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:43.207]                 }
[17:45:43.207]                 ...future.workdir <- getwd()
[17:45:43.207]             }
[17:45:43.207]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:43.207]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:43.207]         }
[17:45:43.207]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:43.207]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:43.207]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:43.207]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:43.207]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:43.207]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:43.207]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:43.207]             base::names(...future.oldOptions))
[17:45:43.207]     }
[17:45:43.207]     if (FALSE) {
[17:45:43.207]     }
[17:45:43.207]     else {
[17:45:43.207]         if (FALSE) {
[17:45:43.207]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:43.207]                 open = "w")
[17:45:43.207]         }
[17:45:43.207]         else {
[17:45:43.207]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:43.207]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:43.207]         }
[17:45:43.207]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:43.207]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:43.207]             base::sink(type = "output", split = FALSE)
[17:45:43.207]             base::close(...future.stdout)
[17:45:43.207]         }, add = TRUE)
[17:45:43.207]     }
[17:45:43.207]     ...future.frame <- base::sys.nframe()
[17:45:43.207]     ...future.conditions <- base::list()
[17:45:43.207]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:43.207]     if (FALSE) {
[17:45:43.207]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:43.207]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:43.207]     }
[17:45:43.207]     ...future.result <- base::tryCatch({
[17:45:43.207]         base::withCallingHandlers({
[17:45:43.207]             ...future.value <- base::withVisible(base::local({
[17:45:43.207]                 withCallingHandlers({
[17:45:43.207]                   {
[17:45:43.207]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:43.207]                     if (!identical(...future.globals.maxSize.org, 
[17:45:43.207]                       ...future.globals.maxSize)) {
[17:45:43.207]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:43.207]                       on.exit(options(oopts), add = TRUE)
[17:45:43.207]                     }
[17:45:43.207]                     {
[17:45:43.207]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:43.207]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:43.207]                         USE.NAMES = FALSE)
[17:45:43.207]                       do.call(mapply, args = args)
[17:45:43.207]                     }
[17:45:43.207]                   }
[17:45:43.207]                 }, immediateCondition = function(cond) {
[17:45:43.207]                   save_rds <- function (object, pathname, ...) 
[17:45:43.207]                   {
[17:45:43.207]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:43.207]                     if (file_test("-f", pathname_tmp)) {
[17:45:43.207]                       fi_tmp <- file.info(pathname_tmp)
[17:45:43.207]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:43.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:43.207]                         fi_tmp[["mtime"]])
[17:45:43.207]                     }
[17:45:43.207]                     tryCatch({
[17:45:43.207]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:43.207]                     }, error = function(ex) {
[17:45:43.207]                       msg <- conditionMessage(ex)
[17:45:43.207]                       fi_tmp <- file.info(pathname_tmp)
[17:45:43.207]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:43.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:43.207]                         fi_tmp[["mtime"]], msg)
[17:45:43.207]                       ex$message <- msg
[17:45:43.207]                       stop(ex)
[17:45:43.207]                     })
[17:45:43.207]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:43.207]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:43.207]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:43.207]                       fi_tmp <- file.info(pathname_tmp)
[17:45:43.207]                       fi <- file.info(pathname)
[17:45:43.207]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:43.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:43.207]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:43.207]                         fi[["size"]], fi[["mtime"]])
[17:45:43.207]                       stop(msg)
[17:45:43.207]                     }
[17:45:43.207]                     invisible(pathname)
[17:45:43.207]                   }
[17:45:43.207]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:43.207]                     rootPath = tempdir()) 
[17:45:43.207]                   {
[17:45:43.207]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:43.207]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:43.207]                       tmpdir = path, fileext = ".rds")
[17:45:43.207]                     save_rds(obj, file)
[17:45:43.207]                   }
[17:45:43.207]                   saveImmediateCondition(cond, path = "/tmp/RtmpnHaLG7/.future/immediateConditions")
[17:45:43.207]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:43.207]                   {
[17:45:43.207]                     inherits <- base::inherits
[17:45:43.207]                     invokeRestart <- base::invokeRestart
[17:45:43.207]                     is.null <- base::is.null
[17:45:43.207]                     muffled <- FALSE
[17:45:43.207]                     if (inherits(cond, "message")) {
[17:45:43.207]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:43.207]                       if (muffled) 
[17:45:43.207]                         invokeRestart("muffleMessage")
[17:45:43.207]                     }
[17:45:43.207]                     else if (inherits(cond, "warning")) {
[17:45:43.207]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:43.207]                       if (muffled) 
[17:45:43.207]                         invokeRestart("muffleWarning")
[17:45:43.207]                     }
[17:45:43.207]                     else if (inherits(cond, "condition")) {
[17:45:43.207]                       if (!is.null(pattern)) {
[17:45:43.207]                         computeRestarts <- base::computeRestarts
[17:45:43.207]                         grepl <- base::grepl
[17:45:43.207]                         restarts <- computeRestarts(cond)
[17:45:43.207]                         for (restart in restarts) {
[17:45:43.207]                           name <- restart$name
[17:45:43.207]                           if (is.null(name)) 
[17:45:43.207]                             next
[17:45:43.207]                           if (!grepl(pattern, name)) 
[17:45:43.207]                             next
[17:45:43.207]                           invokeRestart(restart)
[17:45:43.207]                           muffled <- TRUE
[17:45:43.207]                           break
[17:45:43.207]                         }
[17:45:43.207]                       }
[17:45:43.207]                     }
[17:45:43.207]                     invisible(muffled)
[17:45:43.207]                   }
[17:45:43.207]                   muffleCondition(cond)
[17:45:43.207]                 })
[17:45:43.207]             }))
[17:45:43.207]             future::FutureResult(value = ...future.value$value, 
[17:45:43.207]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:43.207]                   ...future.rng), globalenv = if (FALSE) 
[17:45:43.207]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:43.207]                     ...future.globalenv.names))
[17:45:43.207]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:43.207]         }, condition = base::local({
[17:45:43.207]             c <- base::c
[17:45:43.207]             inherits <- base::inherits
[17:45:43.207]             invokeRestart <- base::invokeRestart
[17:45:43.207]             length <- base::length
[17:45:43.207]             list <- base::list
[17:45:43.207]             seq.int <- base::seq.int
[17:45:43.207]             signalCondition <- base::signalCondition
[17:45:43.207]             sys.calls <- base::sys.calls
[17:45:43.207]             `[[` <- base::`[[`
[17:45:43.207]             `+` <- base::`+`
[17:45:43.207]             `<<-` <- base::`<<-`
[17:45:43.207]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:43.207]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:43.207]                   3L)]
[17:45:43.207]             }
[17:45:43.207]             function(cond) {
[17:45:43.207]                 is_error <- inherits(cond, "error")
[17:45:43.207]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:43.207]                   NULL)
[17:45:43.207]                 if (is_error) {
[17:45:43.207]                   sessionInformation <- function() {
[17:45:43.207]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:43.207]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:43.207]                       search = base::search(), system = base::Sys.info())
[17:45:43.207]                   }
[17:45:43.207]                   ...future.conditions[[length(...future.conditions) + 
[17:45:43.207]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:43.207]                     cond$call), session = sessionInformation(), 
[17:45:43.207]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:43.207]                   signalCondition(cond)
[17:45:43.207]                 }
[17:45:43.207]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:43.207]                 "immediateCondition"))) {
[17:45:43.207]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:43.207]                   ...future.conditions[[length(...future.conditions) + 
[17:45:43.207]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:43.207]                   if (TRUE && !signal) {
[17:45:43.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:43.207]                     {
[17:45:43.207]                       inherits <- base::inherits
[17:45:43.207]                       invokeRestart <- base::invokeRestart
[17:45:43.207]                       is.null <- base::is.null
[17:45:43.207]                       muffled <- FALSE
[17:45:43.207]                       if (inherits(cond, "message")) {
[17:45:43.207]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:43.207]                         if (muffled) 
[17:45:43.207]                           invokeRestart("muffleMessage")
[17:45:43.207]                       }
[17:45:43.207]                       else if (inherits(cond, "warning")) {
[17:45:43.207]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:43.207]                         if (muffled) 
[17:45:43.207]                           invokeRestart("muffleWarning")
[17:45:43.207]                       }
[17:45:43.207]                       else if (inherits(cond, "condition")) {
[17:45:43.207]                         if (!is.null(pattern)) {
[17:45:43.207]                           computeRestarts <- base::computeRestarts
[17:45:43.207]                           grepl <- base::grepl
[17:45:43.207]                           restarts <- computeRestarts(cond)
[17:45:43.207]                           for (restart in restarts) {
[17:45:43.207]                             name <- restart$name
[17:45:43.207]                             if (is.null(name)) 
[17:45:43.207]                               next
[17:45:43.207]                             if (!grepl(pattern, name)) 
[17:45:43.207]                               next
[17:45:43.207]                             invokeRestart(restart)
[17:45:43.207]                             muffled <- TRUE
[17:45:43.207]                             break
[17:45:43.207]                           }
[17:45:43.207]                         }
[17:45:43.207]                       }
[17:45:43.207]                       invisible(muffled)
[17:45:43.207]                     }
[17:45:43.207]                     muffleCondition(cond, pattern = "^muffle")
[17:45:43.207]                   }
[17:45:43.207]                 }
[17:45:43.207]                 else {
[17:45:43.207]                   if (TRUE) {
[17:45:43.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:43.207]                     {
[17:45:43.207]                       inherits <- base::inherits
[17:45:43.207]                       invokeRestart <- base::invokeRestart
[17:45:43.207]                       is.null <- base::is.null
[17:45:43.207]                       muffled <- FALSE
[17:45:43.207]                       if (inherits(cond, "message")) {
[17:45:43.207]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:43.207]                         if (muffled) 
[17:45:43.207]                           invokeRestart("muffleMessage")
[17:45:43.207]                       }
[17:45:43.207]                       else if (inherits(cond, "warning")) {
[17:45:43.207]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:43.207]                         if (muffled) 
[17:45:43.207]                           invokeRestart("muffleWarning")
[17:45:43.207]                       }
[17:45:43.207]                       else if (inherits(cond, "condition")) {
[17:45:43.207]                         if (!is.null(pattern)) {
[17:45:43.207]                           computeRestarts <- base::computeRestarts
[17:45:43.207]                           grepl <- base::grepl
[17:45:43.207]                           restarts <- computeRestarts(cond)
[17:45:43.207]                           for (restart in restarts) {
[17:45:43.207]                             name <- restart$name
[17:45:43.207]                             if (is.null(name)) 
[17:45:43.207]                               next
[17:45:43.207]                             if (!grepl(pattern, name)) 
[17:45:43.207]                               next
[17:45:43.207]                             invokeRestart(restart)
[17:45:43.207]                             muffled <- TRUE
[17:45:43.207]                             break
[17:45:43.207]                           }
[17:45:43.207]                         }
[17:45:43.207]                       }
[17:45:43.207]                       invisible(muffled)
[17:45:43.207]                     }
[17:45:43.207]                     muffleCondition(cond, pattern = "^muffle")
[17:45:43.207]                   }
[17:45:43.207]                 }
[17:45:43.207]             }
[17:45:43.207]         }))
[17:45:43.207]     }, error = function(ex) {
[17:45:43.207]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:43.207]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:43.207]                 ...future.rng), started = ...future.startTime, 
[17:45:43.207]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:43.207]             version = "1.8"), class = "FutureResult")
[17:45:43.207]     }, finally = {
[17:45:43.207]         if (!identical(...future.workdir, getwd())) 
[17:45:43.207]             setwd(...future.workdir)
[17:45:43.207]         {
[17:45:43.207]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:43.207]                 ...future.oldOptions$nwarnings <- NULL
[17:45:43.207]             }
[17:45:43.207]             base::options(...future.oldOptions)
[17:45:43.207]             if (.Platform$OS.type == "windows") {
[17:45:43.207]                 old_names <- names(...future.oldEnvVars)
[17:45:43.207]                 envs <- base::Sys.getenv()
[17:45:43.207]                 names <- names(envs)
[17:45:43.207]                 common <- intersect(names, old_names)
[17:45:43.207]                 added <- setdiff(names, old_names)
[17:45:43.207]                 removed <- setdiff(old_names, names)
[17:45:43.207]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:43.207]                   envs[common]]
[17:45:43.207]                 NAMES <- toupper(changed)
[17:45:43.207]                 args <- list()
[17:45:43.207]                 for (kk in seq_along(NAMES)) {
[17:45:43.207]                   name <- changed[[kk]]
[17:45:43.207]                   NAME <- NAMES[[kk]]
[17:45:43.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:43.207]                     next
[17:45:43.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:43.207]                 }
[17:45:43.207]                 NAMES <- toupper(added)
[17:45:43.207]                 for (kk in seq_along(NAMES)) {
[17:45:43.207]                   name <- added[[kk]]
[17:45:43.207]                   NAME <- NAMES[[kk]]
[17:45:43.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:43.207]                     next
[17:45:43.207]                   args[[name]] <- ""
[17:45:43.207]                 }
[17:45:43.207]                 NAMES <- toupper(removed)
[17:45:43.207]                 for (kk in seq_along(NAMES)) {
[17:45:43.207]                   name <- removed[[kk]]
[17:45:43.207]                   NAME <- NAMES[[kk]]
[17:45:43.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:43.207]                     next
[17:45:43.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:43.207]                 }
[17:45:43.207]                 if (length(args) > 0) 
[17:45:43.207]                   base::do.call(base::Sys.setenv, args = args)
[17:45:43.207]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:43.207]             }
[17:45:43.207]             else {
[17:45:43.207]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:43.207]             }
[17:45:43.207]             {
[17:45:43.207]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:43.207]                   0L) {
[17:45:43.207]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:43.207]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:43.207]                   base::options(opts)
[17:45:43.207]                 }
[17:45:43.207]                 {
[17:45:43.207]                   {
[17:45:43.207]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:43.207]                     NULL
[17:45:43.207]                   }
[17:45:43.207]                   options(future.plan = NULL)
[17:45:43.207]                   if (is.na(NA_character_)) 
[17:45:43.207]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:43.207]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:43.207]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:43.207]                     .init = FALSE)
[17:45:43.207]                 }
[17:45:43.207]             }
[17:45:43.207]         }
[17:45:43.207]     })
[17:45:43.207]     if (TRUE) {
[17:45:43.207]         base::sink(type = "output", split = FALSE)
[17:45:43.207]         if (FALSE) {
[17:45:43.207]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:43.207]         }
[17:45:43.207]         else {
[17:45:43.207]             ...future.result["stdout"] <- base::list(NULL)
[17:45:43.207]         }
[17:45:43.207]         base::close(...future.stdout)
[17:45:43.207]         ...future.stdout <- NULL
[17:45:43.207]     }
[17:45:43.207]     ...future.result$conditions <- ...future.conditions
[17:45:43.207]     ...future.result$finished <- base::Sys.time()
[17:45:43.207]     ...future.result
[17:45:43.207] }
[17:45:43.210] assign_globals() ...
[17:45:43.210] List of 5
[17:45:43.210]  $ ...future.FUN            :function (x, y)  
[17:45:43.210]  $ MoreArgs                 : NULL
[17:45:43.210]  $ ...future.elements_ii    :List of 2
[17:45:43.210]   ..$ :List of 1
[17:45:43.210]   .. ..$ : int 1
[17:45:43.210]   ..$ :List of 1
[17:45:43.210]   .. ..$ : int 0
[17:45:43.210]  $ ...future.seeds_ii       : NULL
[17:45:43.210]  $ ...future.globals.maxSize: NULL
[17:45:43.210]  - attr(*, "where")=List of 5
[17:45:43.210]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:43.210]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:43.210]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:43.210]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:43.210]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:43.210]  - attr(*, "resolved")= logi FALSE
[17:45:43.210]  - attr(*, "total_size")= num 6368
[17:45:43.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:43.210]  - attr(*, "already-done")= logi TRUE
[17:45:43.215] - reassign environment for ‘...future.FUN’
[17:45:43.215] - copied ‘...future.FUN’ to environment
[17:45:43.215] - copied ‘MoreArgs’ to environment
[17:45:43.215] - copied ‘...future.elements_ii’ to environment
[17:45:43.215] - copied ‘...future.seeds_ii’ to environment
[17:45:43.215] - copied ‘...future.globals.maxSize’ to environment
[17:45:43.215] assign_globals() ... done
[17:45:43.215] requestCore(): workers = 2
[17:45:43.218] MulticoreFuture started
[17:45:43.218] - Launch lazy future ... done
[17:45:43.218] run() for ‘MulticoreFuture’ ... done
[17:45:43.218] Created future:
[17:45:43.219] plan(): Setting new future strategy stack:
[17:45:43.219] List of future strategies:
[17:45:43.219] 1. sequential:
[17:45:43.219]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:43.219]    - tweaked: FALSE
[17:45:43.219]    - call: NULL
[17:45:43.220] plan(): nbrOfWorkers() = 1
[17:45:43.219] MulticoreFuture:
[17:45:43.219] Label: ‘future_mapply-1’
[17:45:43.219] Expression:
[17:45:43.219] {
[17:45:43.219]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:43.219]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:43.219]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:43.219]         on.exit(options(oopts), add = TRUE)
[17:45:43.219]     }
[17:45:43.219]     {
[17:45:43.219]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:43.219]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:43.219]         do.call(mapply, args = args)
[17:45:43.219]     }
[17:45:43.219] }
[17:45:43.219] Lazy evaluation: FALSE
[17:45:43.219] Asynchronous evaluation: TRUE
[17:45:43.219] Local evaluation: TRUE
[17:45:43.219] Environment: R_GlobalEnv
[17:45:43.219] Capture standard output: FALSE
[17:45:43.219] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:43.219] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:43.219] Packages: <none>
[17:45:43.219] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:43.219] Resolved: FALSE
[17:45:43.219] Value: <not collected>
[17:45:43.219] Conditions captured: <none>
[17:45:43.219] Early signaling: FALSE
[17:45:43.219] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:43.219] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:43.231] Chunk #1 of 2 ... DONE
[17:45:43.232] Chunk #2 of 2 ...
[17:45:43.232]  - Finding globals in '...' for chunk #2 ...
[17:45:43.232] getGlobalsAndPackages() ...
[17:45:43.232] Searching for globals...
[17:45:43.233] 
[17:45:43.233] Searching for globals ... DONE
[17:45:43.233] - globals: [0] <none>
[17:45:43.233] getGlobalsAndPackages() ... DONE
[17:45:43.234]    + additional globals found: [n=0] 
[17:45:43.234]    + additional namespaces needed: [n=0] 
[17:45:43.234]  - Finding globals in '...' for chunk #2 ... DONE
[17:45:43.234]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:43.234]  - seeds: <none>
[17:45:43.234]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:43.235] getGlobalsAndPackages() ...
[17:45:43.235] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:43.235] Resolving globals: FALSE
[17:45:43.236] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:45:43.237] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:43.237] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:43.237] 
[17:45:43.237] getGlobalsAndPackages() ... DONE
[17:45:43.238] run() for ‘Future’ ...
[17:45:43.238] - state: ‘created’
[17:45:43.238] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:43.243] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:43.243] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:43.244]   - Field: ‘label’
[17:45:43.244]   - Field: ‘local’
[17:45:43.244]   - Field: ‘owner’
[17:45:43.244]   - Field: ‘envir’
[17:45:43.244]   - Field: ‘workers’
[17:45:43.244]   - Field: ‘packages’
[17:45:43.245]   - Field: ‘gc’
[17:45:43.245]   - Field: ‘job’
[17:45:43.245]   - Field: ‘conditions’
[17:45:43.245]   - Field: ‘expr’
[17:45:43.245]   - Field: ‘uuid’
[17:45:43.245]   - Field: ‘seed’
[17:45:43.245]   - Field: ‘version’
[17:45:43.246]   - Field: ‘result’
[17:45:43.246]   - Field: ‘asynchronous’
[17:45:43.246]   - Field: ‘calls’
[17:45:43.246]   - Field: ‘globals’
[17:45:43.246]   - Field: ‘stdout’
[17:45:43.246]   - Field: ‘earlySignal’
[17:45:43.246]   - Field: ‘lazy’
[17:45:43.247]   - Field: ‘state’
[17:45:43.250] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:43.250] - Launch lazy future ...
[17:45:43.251] Packages needed by the future expression (n = 0): <none>
[17:45:43.252] Packages needed by future strategies (n = 0): <none>
[17:45:43.253] {
[17:45:43.253]     {
[17:45:43.253]         {
[17:45:43.253]             ...future.startTime <- base::Sys.time()
[17:45:43.253]             {
[17:45:43.253]                 {
[17:45:43.253]                   {
[17:45:43.253]                     {
[17:45:43.253]                       base::local({
[17:45:43.253]                         has_future <- base::requireNamespace("future", 
[17:45:43.253]                           quietly = TRUE)
[17:45:43.253]                         if (has_future) {
[17:45:43.253]                           ns <- base::getNamespace("future")
[17:45:43.253]                           version <- ns[[".package"]][["version"]]
[17:45:43.253]                           if (is.null(version)) 
[17:45:43.253]                             version <- utils::packageVersion("future")
[17:45:43.253]                         }
[17:45:43.253]                         else {
[17:45:43.253]                           version <- NULL
[17:45:43.253]                         }
[17:45:43.253]                         if (!has_future || version < "1.8.0") {
[17:45:43.253]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:43.253]                             "", base::R.version$version.string), 
[17:45:43.253]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:43.253]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:43.253]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:43.253]                               "release", "version")], collapse = " "), 
[17:45:43.253]                             hostname = base::Sys.info()[["nodename"]])
[17:45:43.253]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:43.253]                             info)
[17:45:43.253]                           info <- base::paste(info, collapse = "; ")
[17:45:43.253]                           if (!has_future) {
[17:45:43.253]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:43.253]                               info)
[17:45:43.253]                           }
[17:45:43.253]                           else {
[17:45:43.253]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:43.253]                               info, version)
[17:45:43.253]                           }
[17:45:43.253]                           base::stop(msg)
[17:45:43.253]                         }
[17:45:43.253]                       })
[17:45:43.253]                     }
[17:45:43.253]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:43.253]                     base::options(mc.cores = 1L)
[17:45:43.253]                   }
[17:45:43.253]                   ...future.strategy.old <- future::plan("list")
[17:45:43.253]                   options(future.plan = NULL)
[17:45:43.253]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:43.253]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:43.253]                 }
[17:45:43.253]                 ...future.workdir <- getwd()
[17:45:43.253]             }
[17:45:43.253]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:43.253]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:43.253]         }
[17:45:43.253]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:43.253]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:43.253]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:43.253]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:43.253]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:43.253]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:43.253]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:43.253]             base::names(...future.oldOptions))
[17:45:43.253]     }
[17:45:43.253]     if (FALSE) {
[17:45:43.253]     }
[17:45:43.253]     else {
[17:45:43.253]         if (FALSE) {
[17:45:43.253]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:43.253]                 open = "w")
[17:45:43.253]         }
[17:45:43.253]         else {
[17:45:43.253]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:43.253]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:43.253]         }
[17:45:43.253]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:43.253]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:43.253]             base::sink(type = "output", split = FALSE)
[17:45:43.253]             base::close(...future.stdout)
[17:45:43.253]         }, add = TRUE)
[17:45:43.253]     }
[17:45:43.253]     ...future.frame <- base::sys.nframe()
[17:45:43.253]     ...future.conditions <- base::list()
[17:45:43.253]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:43.253]     if (FALSE) {
[17:45:43.253]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:43.253]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:43.253]     }
[17:45:43.253]     ...future.result <- base::tryCatch({
[17:45:43.253]         base::withCallingHandlers({
[17:45:43.253]             ...future.value <- base::withVisible(base::local({
[17:45:43.253]                 withCallingHandlers({
[17:45:43.253]                   {
[17:45:43.253]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:43.253]                     if (!identical(...future.globals.maxSize.org, 
[17:45:43.253]                       ...future.globals.maxSize)) {
[17:45:43.253]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:43.253]                       on.exit(options(oopts), add = TRUE)
[17:45:43.253]                     }
[17:45:43.253]                     {
[17:45:43.253]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:43.253]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:43.253]                         USE.NAMES = FALSE)
[17:45:43.253]                       do.call(mapply, args = args)
[17:45:43.253]                     }
[17:45:43.253]                   }
[17:45:43.253]                 }, immediateCondition = function(cond) {
[17:45:43.253]                   save_rds <- function (object, pathname, ...) 
[17:45:43.253]                   {
[17:45:43.253]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:43.253]                     if (file_test("-f", pathname_tmp)) {
[17:45:43.253]                       fi_tmp <- file.info(pathname_tmp)
[17:45:43.253]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:43.253]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:43.253]                         fi_tmp[["mtime"]])
[17:45:43.253]                     }
[17:45:43.253]                     tryCatch({
[17:45:43.253]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:43.253]                     }, error = function(ex) {
[17:45:43.253]                       msg <- conditionMessage(ex)
[17:45:43.253]                       fi_tmp <- file.info(pathname_tmp)
[17:45:43.253]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:43.253]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:43.253]                         fi_tmp[["mtime"]], msg)
[17:45:43.253]                       ex$message <- msg
[17:45:43.253]                       stop(ex)
[17:45:43.253]                     })
[17:45:43.253]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:43.253]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:43.253]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:43.253]                       fi_tmp <- file.info(pathname_tmp)
[17:45:43.253]                       fi <- file.info(pathname)
[17:45:43.253]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:43.253]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:43.253]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:43.253]                         fi[["size"]], fi[["mtime"]])
[17:45:43.253]                       stop(msg)
[17:45:43.253]                     }
[17:45:43.253]                     invisible(pathname)
[17:45:43.253]                   }
[17:45:43.253]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:43.253]                     rootPath = tempdir()) 
[17:45:43.253]                   {
[17:45:43.253]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:43.253]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:43.253]                       tmpdir = path, fileext = ".rds")
[17:45:43.253]                     save_rds(obj, file)
[17:45:43.253]                   }
[17:45:43.253]                   saveImmediateCondition(cond, path = "/tmp/RtmpnHaLG7/.future/immediateConditions")
[17:45:43.253]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:43.253]                   {
[17:45:43.253]                     inherits <- base::inherits
[17:45:43.253]                     invokeRestart <- base::invokeRestart
[17:45:43.253]                     is.null <- base::is.null
[17:45:43.253]                     muffled <- FALSE
[17:45:43.253]                     if (inherits(cond, "message")) {
[17:45:43.253]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:43.253]                       if (muffled) 
[17:45:43.253]                         invokeRestart("muffleMessage")
[17:45:43.253]                     }
[17:45:43.253]                     else if (inherits(cond, "warning")) {
[17:45:43.253]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:43.253]                       if (muffled) 
[17:45:43.253]                         invokeRestart("muffleWarning")
[17:45:43.253]                     }
[17:45:43.253]                     else if (inherits(cond, "condition")) {
[17:45:43.253]                       if (!is.null(pattern)) {
[17:45:43.253]                         computeRestarts <- base::computeRestarts
[17:45:43.253]                         grepl <- base::grepl
[17:45:43.253]                         restarts <- computeRestarts(cond)
[17:45:43.253]                         for (restart in restarts) {
[17:45:43.253]                           name <- restart$name
[17:45:43.253]                           if (is.null(name)) 
[17:45:43.253]                             next
[17:45:43.253]                           if (!grepl(pattern, name)) 
[17:45:43.253]                             next
[17:45:43.253]                           invokeRestart(restart)
[17:45:43.253]                           muffled <- TRUE
[17:45:43.253]                           break
[17:45:43.253]                         }
[17:45:43.253]                       }
[17:45:43.253]                     }
[17:45:43.253]                     invisible(muffled)
[17:45:43.253]                   }
[17:45:43.253]                   muffleCondition(cond)
[17:45:43.253]                 })
[17:45:43.253]             }))
[17:45:43.253]             future::FutureResult(value = ...future.value$value, 
[17:45:43.253]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:43.253]                   ...future.rng), globalenv = if (FALSE) 
[17:45:43.253]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:43.253]                     ...future.globalenv.names))
[17:45:43.253]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:43.253]         }, condition = base::local({
[17:45:43.253]             c <- base::c
[17:45:43.253]             inherits <- base::inherits
[17:45:43.253]             invokeRestart <- base::invokeRestart
[17:45:43.253]             length <- base::length
[17:45:43.253]             list <- base::list
[17:45:43.253]             seq.int <- base::seq.int
[17:45:43.253]             signalCondition <- base::signalCondition
[17:45:43.253]             sys.calls <- base::sys.calls
[17:45:43.253]             `[[` <- base::`[[`
[17:45:43.253]             `+` <- base::`+`
[17:45:43.253]             `<<-` <- base::`<<-`
[17:45:43.253]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:43.253]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:43.253]                   3L)]
[17:45:43.253]             }
[17:45:43.253]             function(cond) {
[17:45:43.253]                 is_error <- inherits(cond, "error")
[17:45:43.253]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:43.253]                   NULL)
[17:45:43.253]                 if (is_error) {
[17:45:43.253]                   sessionInformation <- function() {
[17:45:43.253]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:43.253]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:43.253]                       search = base::search(), system = base::Sys.info())
[17:45:43.253]                   }
[17:45:43.253]                   ...future.conditions[[length(...future.conditions) + 
[17:45:43.253]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:43.253]                     cond$call), session = sessionInformation(), 
[17:45:43.253]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:43.253]                   signalCondition(cond)
[17:45:43.253]                 }
[17:45:43.253]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:43.253]                 "immediateCondition"))) {
[17:45:43.253]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:43.253]                   ...future.conditions[[length(...future.conditions) + 
[17:45:43.253]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:43.253]                   if (TRUE && !signal) {
[17:45:43.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:43.253]                     {
[17:45:43.253]                       inherits <- base::inherits
[17:45:43.253]                       invokeRestart <- base::invokeRestart
[17:45:43.253]                       is.null <- base::is.null
[17:45:43.253]                       muffled <- FALSE
[17:45:43.253]                       if (inherits(cond, "message")) {
[17:45:43.253]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:43.253]                         if (muffled) 
[17:45:43.253]                           invokeRestart("muffleMessage")
[17:45:43.253]                       }
[17:45:43.253]                       else if (inherits(cond, "warning")) {
[17:45:43.253]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:43.253]                         if (muffled) 
[17:45:43.253]                           invokeRestart("muffleWarning")
[17:45:43.253]                       }
[17:45:43.253]                       else if (inherits(cond, "condition")) {
[17:45:43.253]                         if (!is.null(pattern)) {
[17:45:43.253]                           computeRestarts <- base::computeRestarts
[17:45:43.253]                           grepl <- base::grepl
[17:45:43.253]                           restarts <- computeRestarts(cond)
[17:45:43.253]                           for (restart in restarts) {
[17:45:43.253]                             name <- restart$name
[17:45:43.253]                             if (is.null(name)) 
[17:45:43.253]                               next
[17:45:43.253]                             if (!grepl(pattern, name)) 
[17:45:43.253]                               next
[17:45:43.253]                             invokeRestart(restart)
[17:45:43.253]                             muffled <- TRUE
[17:45:43.253]                             break
[17:45:43.253]                           }
[17:45:43.253]                         }
[17:45:43.253]                       }
[17:45:43.253]                       invisible(muffled)
[17:45:43.253]                     }
[17:45:43.253]                     muffleCondition(cond, pattern = "^muffle")
[17:45:43.253]                   }
[17:45:43.253]                 }
[17:45:43.253]                 else {
[17:45:43.253]                   if (TRUE) {
[17:45:43.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:43.253]                     {
[17:45:43.253]                       inherits <- base::inherits
[17:45:43.253]                       invokeRestart <- base::invokeRestart
[17:45:43.253]                       is.null <- base::is.null
[17:45:43.253]                       muffled <- FALSE
[17:45:43.253]                       if (inherits(cond, "message")) {
[17:45:43.253]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:43.253]                         if (muffled) 
[17:45:43.253]                           invokeRestart("muffleMessage")
[17:45:43.253]                       }
[17:45:43.253]                       else if (inherits(cond, "warning")) {
[17:45:43.253]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:43.253]                         if (muffled) 
[17:45:43.253]                           invokeRestart("muffleWarning")
[17:45:43.253]                       }
[17:45:43.253]                       else if (inherits(cond, "condition")) {
[17:45:43.253]                         if (!is.null(pattern)) {
[17:45:43.253]                           computeRestarts <- base::computeRestarts
[17:45:43.253]                           grepl <- base::grepl
[17:45:43.253]                           restarts <- computeRestarts(cond)
[17:45:43.253]                           for (restart in restarts) {
[17:45:43.253]                             name <- restart$name
[17:45:43.253]                             if (is.null(name)) 
[17:45:43.253]                               next
[17:45:43.253]                             if (!grepl(pattern, name)) 
[17:45:43.253]                               next
[17:45:43.253]                             invokeRestart(restart)
[17:45:43.253]                             muffled <- TRUE
[17:45:43.253]                             break
[17:45:43.253]                           }
[17:45:43.253]                         }
[17:45:43.253]                       }
[17:45:43.253]                       invisible(muffled)
[17:45:43.253]                     }
[17:45:43.253]                     muffleCondition(cond, pattern = "^muffle")
[17:45:43.253]                   }
[17:45:43.253]                 }
[17:45:43.253]             }
[17:45:43.253]         }))
[17:45:43.253]     }, error = function(ex) {
[17:45:43.253]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:43.253]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:43.253]                 ...future.rng), started = ...future.startTime, 
[17:45:43.253]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:43.253]             version = "1.8"), class = "FutureResult")
[17:45:43.253]     }, finally = {
[17:45:43.253]         if (!identical(...future.workdir, getwd())) 
[17:45:43.253]             setwd(...future.workdir)
[17:45:43.253]         {
[17:45:43.253]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:43.253]                 ...future.oldOptions$nwarnings <- NULL
[17:45:43.253]             }
[17:45:43.253]             base::options(...future.oldOptions)
[17:45:43.253]             if (.Platform$OS.type == "windows") {
[17:45:43.253]                 old_names <- names(...future.oldEnvVars)
[17:45:43.253]                 envs <- base::Sys.getenv()
[17:45:43.253]                 names <- names(envs)
[17:45:43.253]                 common <- intersect(names, old_names)
[17:45:43.253]                 added <- setdiff(names, old_names)
[17:45:43.253]                 removed <- setdiff(old_names, names)
[17:45:43.253]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:43.253]                   envs[common]]
[17:45:43.253]                 NAMES <- toupper(changed)
[17:45:43.253]                 args <- list()
[17:45:43.253]                 for (kk in seq_along(NAMES)) {
[17:45:43.253]                   name <- changed[[kk]]
[17:45:43.253]                   NAME <- NAMES[[kk]]
[17:45:43.253]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:43.253]                     next
[17:45:43.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:43.253]                 }
[17:45:43.253]                 NAMES <- toupper(added)
[17:45:43.253]                 for (kk in seq_along(NAMES)) {
[17:45:43.253]                   name <- added[[kk]]
[17:45:43.253]                   NAME <- NAMES[[kk]]
[17:45:43.253]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:43.253]                     next
[17:45:43.253]                   args[[name]] <- ""
[17:45:43.253]                 }
[17:45:43.253]                 NAMES <- toupper(removed)
[17:45:43.253]                 for (kk in seq_along(NAMES)) {
[17:45:43.253]                   name <- removed[[kk]]
[17:45:43.253]                   NAME <- NAMES[[kk]]
[17:45:43.253]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:43.253]                     next
[17:45:43.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:43.253]                 }
[17:45:43.253]                 if (length(args) > 0) 
[17:45:43.253]                   base::do.call(base::Sys.setenv, args = args)
[17:45:43.253]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:43.253]             }
[17:45:43.253]             else {
[17:45:43.253]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:43.253]             }
[17:45:43.253]             {
[17:45:43.253]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:43.253]                   0L) {
[17:45:43.253]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:43.253]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:43.253]                   base::options(opts)
[17:45:43.253]                 }
[17:45:43.253]                 {
[17:45:43.253]                   {
[17:45:43.253]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:43.253]                     NULL
[17:45:43.253]                   }
[17:45:43.253]                   options(future.plan = NULL)
[17:45:43.253]                   if (is.na(NA_character_)) 
[17:45:43.253]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:43.253]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:43.253]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:43.253]                     .init = FALSE)
[17:45:43.253]                 }
[17:45:43.253]             }
[17:45:43.253]         }
[17:45:43.253]     })
[17:45:43.253]     if (TRUE) {
[17:45:43.253]         base::sink(type = "output", split = FALSE)
[17:45:43.253]         if (FALSE) {
[17:45:43.253]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:43.253]         }
[17:45:43.253]         else {
[17:45:43.253]             ...future.result["stdout"] <- base::list(NULL)
[17:45:43.253]         }
[17:45:43.253]         base::close(...future.stdout)
[17:45:43.253]         ...future.stdout <- NULL
[17:45:43.253]     }
[17:45:43.253]     ...future.result$conditions <- ...future.conditions
[17:45:43.253]     ...future.result$finished <- base::Sys.time()
[17:45:43.253]     ...future.result
[17:45:43.253] }
[17:45:43.256] assign_globals() ...
[17:45:43.256] List of 5
[17:45:43.256]  $ ...future.FUN            :function (x, y)  
[17:45:43.256]  $ MoreArgs                 : NULL
[17:45:43.256]  $ ...future.elements_ii    :List of 2
[17:45:43.256]   ..$ :List of 1
[17:45:43.256]   .. ..$ : int 0
[17:45:43.256]   ..$ :List of 1
[17:45:43.256]   .. ..$ : int 1
[17:45:43.256]  $ ...future.seeds_ii       : NULL
[17:45:43.256]  $ ...future.globals.maxSize: NULL
[17:45:43.256]  - attr(*, "where")=List of 5
[17:45:43.256]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:43.256]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:43.256]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:43.256]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:43.256]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:43.256]  - attr(*, "resolved")= logi FALSE
[17:45:43.256]  - attr(*, "total_size")= num 6368
[17:45:43.256]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:43.256]  - attr(*, "already-done")= logi TRUE
[17:45:43.265] - reassign environment for ‘...future.FUN’
[17:45:43.265] - copied ‘...future.FUN’ to environment
[17:45:43.265] - copied ‘MoreArgs’ to environment
[17:45:43.265] - copied ‘...future.elements_ii’ to environment
[17:45:43.265] - copied ‘...future.seeds_ii’ to environment
[17:45:43.265] - copied ‘...future.globals.maxSize’ to environment
[17:45:43.265] assign_globals() ... done
[17:45:43.266] requestCore(): workers = 2
[17:45:43.268] MulticoreFuture started
[17:45:43.268] - Launch lazy future ... done
[17:45:43.268] run() for ‘MulticoreFuture’ ... done
[17:45:43.269] Created future:
[17:45:43.269] plan(): Setting new future strategy stack:
[17:45:43.269] List of future strategies:
[17:45:43.269] 1. sequential:
[17:45:43.269]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:43.269]    - tweaked: FALSE
[17:45:43.269]    - call: NULL
[17:45:43.270] plan(): nbrOfWorkers() = 1
[17:45:43.273] plan(): Setting new future strategy stack:
[17:45:43.273] List of future strategies:
[17:45:43.273] 1. multicore:
[17:45:43.273]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:43.273]    - tweaked: FALSE
[17:45:43.273]    - call: plan(strategy)
[17:45:43.278] plan(): nbrOfWorkers() = 2
[17:45:43.269] MulticoreFuture:
[17:45:43.269] Label: ‘future_mapply-2’
[17:45:43.269] Expression:
[17:45:43.269] {
[17:45:43.269]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:43.269]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:43.269]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:43.269]         on.exit(options(oopts), add = TRUE)
[17:45:43.269]     }
[17:45:43.269]     {
[17:45:43.269]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:43.269]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:43.269]         do.call(mapply, args = args)
[17:45:43.269]     }
[17:45:43.269] }
[17:45:43.269] Lazy evaluation: FALSE
[17:45:43.269] Asynchronous evaluation: TRUE
[17:45:43.269] Local evaluation: TRUE
[17:45:43.269] Environment: R_GlobalEnv
[17:45:43.269] Capture standard output: FALSE
[17:45:43.269] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:43.269] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:43.269] Packages: <none>
[17:45:43.269] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:43.269] Resolved: TRUE
[17:45:43.269] Value: <not collected>
[17:45:43.269] Conditions captured: <none>
[17:45:43.269] Early signaling: FALSE
[17:45:43.269] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:43.269] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:43.279] Chunk #2 of 2 ... DONE
[17:45:43.279] Launching 2 futures (chunks) ... DONE
[17:45:43.279] Resolving 2 futures (chunks) ...
[17:45:43.279] resolve() on list ...
[17:45:43.279]  recursive: 0
[17:45:43.280]  length: 2
[17:45:43.280] 
[17:45:43.290] Future #2
[17:45:43.291] result() for MulticoreFuture ...
[17:45:43.292] result() for MulticoreFuture ...
[17:45:43.292] result() for MulticoreFuture ... done
[17:45:43.292] result() for MulticoreFuture ... done
[17:45:43.292] result() for MulticoreFuture ...
[17:45:43.292] result() for MulticoreFuture ... done
[17:45:43.292] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:43.292] - nx: 2
[17:45:43.293] - relay: TRUE
[17:45:43.293] - stdout: TRUE
[17:45:43.293] - signal: TRUE
[17:45:43.293] - resignal: FALSE
[17:45:43.293] - force: TRUE
[17:45:43.293] - relayed: [n=2] FALSE, FALSE
[17:45:43.293] - queued futures: [n=2] FALSE, FALSE
[17:45:43.293]  - until=1
[17:45:43.294]  - relaying element #1
[17:45:43.294] - relayed: [n=2] FALSE, FALSE
[17:45:43.294] - queued futures: [n=2] FALSE, TRUE
[17:45:43.294] signalConditionsASAP(NULL, pos=2) ... done
[17:45:43.294]  length: 1 (resolved future 2)
[17:45:43.723] plan(): Setting new future strategy stack:
[17:45:43.723] List of future strategies:
[17:45:43.723] 1. multicore:
[17:45:43.723]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:43.723]    - tweaked: FALSE
[17:45:43.723]    - call: plan(strategy)
[17:45:43.727] plan(): nbrOfWorkers() = 2
[17:45:43.733] Future #1
[17:45:43.733] result() for MulticoreFuture ...
[17:45:43.733] result() for MulticoreFuture ...
[17:45:43.734] result() for MulticoreFuture ... done
[17:45:43.734] result() for MulticoreFuture ... done
[17:45:43.734] result() for MulticoreFuture ...
[17:45:43.734] result() for MulticoreFuture ... done
[17:45:43.734] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:43.734] - nx: 2
[17:45:43.734] - relay: TRUE
[17:45:43.734] - stdout: TRUE
[17:45:43.735] - signal: TRUE
[17:45:43.735] - resignal: FALSE
[17:45:43.735] - force: TRUE
[17:45:43.735] - relayed: [n=2] FALSE, FALSE
[17:45:43.735] - queued futures: [n=2] FALSE, TRUE
[17:45:43.735]  - until=1
[17:45:43.735]  - relaying element #1
[17:45:43.735] result() for MulticoreFuture ...
[17:45:43.736] result() for MulticoreFuture ... done
[17:45:43.736] result() for MulticoreFuture ...
[17:45:43.736] result() for MulticoreFuture ... done
[17:45:43.736] result() for MulticoreFuture ...
[17:45:43.736] result() for MulticoreFuture ... done
[17:45:43.736] result() for MulticoreFuture ...
[17:45:43.736] result() for MulticoreFuture ... done
[17:45:43.736] - relayed: [n=2] TRUE, FALSE
[17:45:43.736] - queued futures: [n=2] TRUE, TRUE
[17:45:43.737] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:43.737]  length: 0 (resolved future 1)
[17:45:43.737] Relaying remaining futures
[17:45:43.737] signalConditionsASAP(NULL, pos=0) ...
[17:45:43.737] - nx: 2
[17:45:43.737] - relay: TRUE
[17:45:43.737] - stdout: TRUE
[17:45:43.737] - signal: TRUE
[17:45:43.737] - resignal: FALSE
[17:45:43.738] - force: TRUE
[17:45:43.738] - relayed: [n=2] TRUE, FALSE
[17:45:43.738] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:43.738]  - relaying element #2
[17:45:43.738] result() for MulticoreFuture ...
[17:45:43.738] result() for MulticoreFuture ... done
[17:45:43.738] result() for MulticoreFuture ...
[17:45:43.738] result() for MulticoreFuture ... done
[17:45:43.739] result() for MulticoreFuture ...
[17:45:43.739] result() for MulticoreFuture ... done
[17:45:43.739] result() for MulticoreFuture ...
[17:45:43.739] result() for MulticoreFuture ... done
[17:45:43.739] - relayed: [n=2] TRUE, TRUE
[17:45:43.739] - queued futures: [n=2] TRUE, TRUE
[17:45:43.739] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:45:43.739] resolve() on list ... DONE
[17:45:43.739] result() for MulticoreFuture ...
[17:45:43.740] result() for MulticoreFuture ... done
[17:45:43.740] result() for MulticoreFuture ...
[17:45:43.740] result() for MulticoreFuture ... done
[17:45:43.740] result() for MulticoreFuture ...
[17:45:43.740] result() for MulticoreFuture ... done
[17:45:43.740] result() for MulticoreFuture ...
[17:45:43.740] result() for MulticoreFuture ... done
[17:45:43.740]  - Number of value chunks collected: 2
[17:45:43.740] Resolving 2 futures (chunks) ... DONE
[17:45:43.741] Reducing values from 2 chunks ...
[17:45:43.741]  - Number of values collected after concatenation: 2
[17:45:43.741]  - Number of values expected: 2
[17:45:43.741] Reducing values from 2 chunks ... DONE
[17:45:43.741] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:45:43.741] future_mapply() ...
[17:45:43.748] Number of chunks: 2
[17:45:43.748] getGlobalsAndPackagesXApply() ...
[17:45:43.749]  - future.globals: TRUE
[17:45:43.749] getGlobalsAndPackages() ...
[17:45:43.749] Searching for globals...
[17:45:43.751] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:43.751] Searching for globals ... DONE
[17:45:43.751] Resolving globals: FALSE
[17:45:43.752] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:43.752] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:43.752] - globals: [1] ‘FUN’
[17:45:43.753] 
[17:45:43.753] getGlobalsAndPackages() ... DONE
[17:45:43.753]  - globals found/used: [n=1] ‘FUN’
[17:45:43.753]  - needed namespaces: [n=0] 
[17:45:43.753] Finding globals ... DONE
[17:45:43.753] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:43.753] List of 2
[17:45:43.753]  $ ...future.FUN:function (x, y)  
[17:45:43.753]  $ MoreArgs     : NULL
[17:45:43.753]  - attr(*, "where")=List of 2
[17:45:43.753]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:43.753]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:43.753]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:43.753]  - attr(*, "resolved")= logi FALSE
[17:45:43.753]  - attr(*, "total_size")= num NA
[17:45:43.756] Packages to be attached in all futures: [n=0] 
[17:45:43.756] getGlobalsAndPackagesXApply() ... DONE
[17:45:43.757] Number of futures (= number of chunks): 2
[17:45:43.757] Launching 2 futures (chunks) ...
[17:45:43.757] Chunk #1 of 2 ...
[17:45:43.757]  - Finding globals in '...' for chunk #1 ...
[17:45:43.757] getGlobalsAndPackages() ...
[17:45:43.757] Searching for globals...
[17:45:43.758] 
[17:45:43.758] Searching for globals ... DONE
[17:45:43.758] - globals: [0] <none>
[17:45:43.758] getGlobalsAndPackages() ... DONE
[17:45:43.758]    + additional globals found: [n=0] 
[17:45:43.758]    + additional namespaces needed: [n=0] 
[17:45:43.758]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:43.758]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:43.758]  - seeds: <none>
[17:45:43.758]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:43.759] getGlobalsAndPackages() ...
[17:45:43.759] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:43.759] Resolving globals: FALSE
[17:45:43.759] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:45:43.760] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:43.760] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:43.760] 
[17:45:43.760] getGlobalsAndPackages() ... DONE
[17:45:43.760] run() for ‘Future’ ...
[17:45:43.760] - state: ‘created’
[17:45:43.761] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:43.764] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:43.764] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:43.764]   - Field: ‘label’
[17:45:43.765]   - Field: ‘local’
[17:45:43.765]   - Field: ‘owner’
[17:45:43.765]   - Field: ‘envir’
[17:45:43.765]   - Field: ‘workers’
[17:45:43.765]   - Field: ‘packages’
[17:45:43.765]   - Field: ‘gc’
[17:45:43.765]   - Field: ‘job’
[17:45:43.765]   - Field: ‘conditions’
[17:45:43.765]   - Field: ‘expr’
[17:45:43.765]   - Field: ‘uuid’
[17:45:43.765]   - Field: ‘seed’
[17:45:43.766]   - Field: ‘version’
[17:45:43.766]   - Field: ‘result’
[17:45:43.766]   - Field: ‘asynchronous’
[17:45:43.766]   - Field: ‘calls’
[17:45:43.766]   - Field: ‘globals’
[17:45:43.766]   - Field: ‘stdout’
[17:45:43.766]   - Field: ‘earlySignal’
[17:45:43.766]   - Field: ‘lazy’
[17:45:43.766]   - Field: ‘state’
[17:45:43.766] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:43.767] - Launch lazy future ...
[17:45:43.767] Packages needed by the future expression (n = 0): <none>
[17:45:43.767] Packages needed by future strategies (n = 0): <none>
[17:45:43.767] {
[17:45:43.767]     {
[17:45:43.767]         {
[17:45:43.767]             ...future.startTime <- base::Sys.time()
[17:45:43.767]             {
[17:45:43.767]                 {
[17:45:43.767]                   {
[17:45:43.767]                     {
[17:45:43.767]                       base::local({
[17:45:43.767]                         has_future <- base::requireNamespace("future", 
[17:45:43.767]                           quietly = TRUE)
[17:45:43.767]                         if (has_future) {
[17:45:43.767]                           ns <- base::getNamespace("future")
[17:45:43.767]                           version <- ns[[".package"]][["version"]]
[17:45:43.767]                           if (is.null(version)) 
[17:45:43.767]                             version <- utils::packageVersion("future")
[17:45:43.767]                         }
[17:45:43.767]                         else {
[17:45:43.767]                           version <- NULL
[17:45:43.767]                         }
[17:45:43.767]                         if (!has_future || version < "1.8.0") {
[17:45:43.767]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:43.767]                             "", base::R.version$version.string), 
[17:45:43.767]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:43.767]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:43.767]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:43.767]                               "release", "version")], collapse = " "), 
[17:45:43.767]                             hostname = base::Sys.info()[["nodename"]])
[17:45:43.767]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:43.767]                             info)
[17:45:43.767]                           info <- base::paste(info, collapse = "; ")
[17:45:43.767]                           if (!has_future) {
[17:45:43.767]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:43.767]                               info)
[17:45:43.767]                           }
[17:45:43.767]                           else {
[17:45:43.767]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:43.767]                               info, version)
[17:45:43.767]                           }
[17:45:43.767]                           base::stop(msg)
[17:45:43.767]                         }
[17:45:43.767]                       })
[17:45:43.767]                     }
[17:45:43.767]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:43.767]                     base::options(mc.cores = 1L)
[17:45:43.767]                   }
[17:45:43.767]                   ...future.strategy.old <- future::plan("list")
[17:45:43.767]                   options(future.plan = NULL)
[17:45:43.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:43.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:43.767]                 }
[17:45:43.767]                 ...future.workdir <- getwd()
[17:45:43.767]             }
[17:45:43.767]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:43.767]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:43.767]         }
[17:45:43.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:43.767]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:43.767]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:43.767]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:43.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:43.767]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:43.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:43.767]             base::names(...future.oldOptions))
[17:45:43.767]     }
[17:45:43.767]     if (FALSE) {
[17:45:43.767]     }
[17:45:43.767]     else {
[17:45:43.767]         if (TRUE) {
[17:45:43.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:43.767]                 open = "w")
[17:45:43.767]         }
[17:45:43.767]         else {
[17:45:43.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:43.767]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:43.767]         }
[17:45:43.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:43.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:43.767]             base::sink(type = "output", split = FALSE)
[17:45:43.767]             base::close(...future.stdout)
[17:45:43.767]         }, add = TRUE)
[17:45:43.767]     }
[17:45:43.767]     ...future.frame <- base::sys.nframe()
[17:45:43.767]     ...future.conditions <- base::list()
[17:45:43.767]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:43.767]     if (FALSE) {
[17:45:43.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:43.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:43.767]     }
[17:45:43.767]     ...future.result <- base::tryCatch({
[17:45:43.767]         base::withCallingHandlers({
[17:45:43.767]             ...future.value <- base::withVisible(base::local({
[17:45:43.767]                 withCallingHandlers({
[17:45:43.767]                   {
[17:45:43.767]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:43.767]                     if (!identical(...future.globals.maxSize.org, 
[17:45:43.767]                       ...future.globals.maxSize)) {
[17:45:43.767]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:43.767]                       on.exit(options(oopts), add = TRUE)
[17:45:43.767]                     }
[17:45:43.767]                     {
[17:45:43.767]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:43.767]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:43.767]                         USE.NAMES = FALSE)
[17:45:43.767]                       do.call(mapply, args = args)
[17:45:43.767]                     }
[17:45:43.767]                   }
[17:45:43.767]                 }, immediateCondition = function(cond) {
[17:45:43.767]                   save_rds <- function (object, pathname, ...) 
[17:45:43.767]                   {
[17:45:43.767]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:43.767]                     if (file_test("-f", pathname_tmp)) {
[17:45:43.767]                       fi_tmp <- file.info(pathname_tmp)
[17:45:43.767]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:43.767]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:43.767]                         fi_tmp[["mtime"]])
[17:45:43.767]                     }
[17:45:43.767]                     tryCatch({
[17:45:43.767]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:43.767]                     }, error = function(ex) {
[17:45:43.767]                       msg <- conditionMessage(ex)
[17:45:43.767]                       fi_tmp <- file.info(pathname_tmp)
[17:45:43.767]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:43.767]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:43.767]                         fi_tmp[["mtime"]], msg)
[17:45:43.767]                       ex$message <- msg
[17:45:43.767]                       stop(ex)
[17:45:43.767]                     })
[17:45:43.767]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:43.767]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:43.767]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:43.767]                       fi_tmp <- file.info(pathname_tmp)
[17:45:43.767]                       fi <- file.info(pathname)
[17:45:43.767]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:43.767]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:43.767]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:43.767]                         fi[["size"]], fi[["mtime"]])
[17:45:43.767]                       stop(msg)
[17:45:43.767]                     }
[17:45:43.767]                     invisible(pathname)
[17:45:43.767]                   }
[17:45:43.767]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:43.767]                     rootPath = tempdir()) 
[17:45:43.767]                   {
[17:45:43.767]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:43.767]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:43.767]                       tmpdir = path, fileext = ".rds")
[17:45:43.767]                     save_rds(obj, file)
[17:45:43.767]                   }
[17:45:43.767]                   saveImmediateCondition(cond, path = "/tmp/RtmpnHaLG7/.future/immediateConditions")
[17:45:43.767]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:43.767]                   {
[17:45:43.767]                     inherits <- base::inherits
[17:45:43.767]                     invokeRestart <- base::invokeRestart
[17:45:43.767]                     is.null <- base::is.null
[17:45:43.767]                     muffled <- FALSE
[17:45:43.767]                     if (inherits(cond, "message")) {
[17:45:43.767]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:43.767]                       if (muffled) 
[17:45:43.767]                         invokeRestart("muffleMessage")
[17:45:43.767]                     }
[17:45:43.767]                     else if (inherits(cond, "warning")) {
[17:45:43.767]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:43.767]                       if (muffled) 
[17:45:43.767]                         invokeRestart("muffleWarning")
[17:45:43.767]                     }
[17:45:43.767]                     else if (inherits(cond, "condition")) {
[17:45:43.767]                       if (!is.null(pattern)) {
[17:45:43.767]                         computeRestarts <- base::computeRestarts
[17:45:43.767]                         grepl <- base::grepl
[17:45:43.767]                         restarts <- computeRestarts(cond)
[17:45:43.767]                         for (restart in restarts) {
[17:45:43.767]                           name <- restart$name
[17:45:43.767]                           if (is.null(name)) 
[17:45:43.767]                             next
[17:45:43.767]                           if (!grepl(pattern, name)) 
[17:45:43.767]                             next
[17:45:43.767]                           invokeRestart(restart)
[17:45:43.767]                           muffled <- TRUE
[17:45:43.767]                           break
[17:45:43.767]                         }
[17:45:43.767]                       }
[17:45:43.767]                     }
[17:45:43.767]                     invisible(muffled)
[17:45:43.767]                   }
[17:45:43.767]                   muffleCondition(cond)
[17:45:43.767]                 })
[17:45:43.767]             }))
[17:45:43.767]             future::FutureResult(value = ...future.value$value, 
[17:45:43.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:43.767]                   ...future.rng), globalenv = if (FALSE) 
[17:45:43.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:43.767]                     ...future.globalenv.names))
[17:45:43.767]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:43.767]         }, condition = base::local({
[17:45:43.767]             c <- base::c
[17:45:43.767]             inherits <- base::inherits
[17:45:43.767]             invokeRestart <- base::invokeRestart
[17:45:43.767]             length <- base::length
[17:45:43.767]             list <- base::list
[17:45:43.767]             seq.int <- base::seq.int
[17:45:43.767]             signalCondition <- base::signalCondition
[17:45:43.767]             sys.calls <- base::sys.calls
[17:45:43.767]             `[[` <- base::`[[`
[17:45:43.767]             `+` <- base::`+`
[17:45:43.767]             `<<-` <- base::`<<-`
[17:45:43.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:43.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:43.767]                   3L)]
[17:45:43.767]             }
[17:45:43.767]             function(cond) {
[17:45:43.767]                 is_error <- inherits(cond, "error")
[17:45:43.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:43.767]                   NULL)
[17:45:43.767]                 if (is_error) {
[17:45:43.767]                   sessionInformation <- function() {
[17:45:43.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:43.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:43.767]                       search = base::search(), system = base::Sys.info())
[17:45:43.767]                   }
[17:45:43.767]                   ...future.conditions[[length(...future.conditions) + 
[17:45:43.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:43.767]                     cond$call), session = sessionInformation(), 
[17:45:43.767]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:43.767]                   signalCondition(cond)
[17:45:43.767]                 }
[17:45:43.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:43.767]                 "immediateCondition"))) {
[17:45:43.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:43.767]                   ...future.conditions[[length(...future.conditions) + 
[17:45:43.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:43.767]                   if (TRUE && !signal) {
[17:45:43.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:43.767]                     {
[17:45:43.767]                       inherits <- base::inherits
[17:45:43.767]                       invokeRestart <- base::invokeRestart
[17:45:43.767]                       is.null <- base::is.null
[17:45:43.767]                       muffled <- FALSE
[17:45:43.767]                       if (inherits(cond, "message")) {
[17:45:43.767]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:43.767]                         if (muffled) 
[17:45:43.767]                           invokeRestart("muffleMessage")
[17:45:43.767]                       }
[17:45:43.767]                       else if (inherits(cond, "warning")) {
[17:45:43.767]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:43.767]                         if (muffled) 
[17:45:43.767]                           invokeRestart("muffleWarning")
[17:45:43.767]                       }
[17:45:43.767]                       else if (inherits(cond, "condition")) {
[17:45:43.767]                         if (!is.null(pattern)) {
[17:45:43.767]                           computeRestarts <- base::computeRestarts
[17:45:43.767]                           grepl <- base::grepl
[17:45:43.767]                           restarts <- computeRestarts(cond)
[17:45:43.767]                           for (restart in restarts) {
[17:45:43.767]                             name <- restart$name
[17:45:43.767]                             if (is.null(name)) 
[17:45:43.767]                               next
[17:45:43.767]                             if (!grepl(pattern, name)) 
[17:45:43.767]                               next
[17:45:43.767]                             invokeRestart(restart)
[17:45:43.767]                             muffled <- TRUE
[17:45:43.767]                             break
[17:45:43.767]                           }
[17:45:43.767]                         }
[17:45:43.767]                       }
[17:45:43.767]                       invisible(muffled)
[17:45:43.767]                     }
[17:45:43.767]                     muffleCondition(cond, pattern = "^muffle")
[17:45:43.767]                   }
[17:45:43.767]                 }
[17:45:43.767]                 else {
[17:45:43.767]                   if (TRUE) {
[17:45:43.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:43.767]                     {
[17:45:43.767]                       inherits <- base::inherits
[17:45:43.767]                       invokeRestart <- base::invokeRestart
[17:45:43.767]                       is.null <- base::is.null
[17:45:43.767]                       muffled <- FALSE
[17:45:43.767]                       if (inherits(cond, "message")) {
[17:45:43.767]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:43.767]                         if (muffled) 
[17:45:43.767]                           invokeRestart("muffleMessage")
[17:45:43.767]                       }
[17:45:43.767]                       else if (inherits(cond, "warning")) {
[17:45:43.767]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:43.767]                         if (muffled) 
[17:45:43.767]                           invokeRestart("muffleWarning")
[17:45:43.767]                       }
[17:45:43.767]                       else if (inherits(cond, "condition")) {
[17:45:43.767]                         if (!is.null(pattern)) {
[17:45:43.767]                           computeRestarts <- base::computeRestarts
[17:45:43.767]                           grepl <- base::grepl
[17:45:43.767]                           restarts <- computeRestarts(cond)
[17:45:43.767]                           for (restart in restarts) {
[17:45:43.767]                             name <- restart$name
[17:45:43.767]                             if (is.null(name)) 
[17:45:43.767]                               next
[17:45:43.767]                             if (!grepl(pattern, name)) 
[17:45:43.767]                               next
[17:45:43.767]                             invokeRestart(restart)
[17:45:43.767]                             muffled <- TRUE
[17:45:43.767]                             break
[17:45:43.767]                           }
[17:45:43.767]                         }
[17:45:43.767]                       }
[17:45:43.767]                       invisible(muffled)
[17:45:43.767]                     }
[17:45:43.767]                     muffleCondition(cond, pattern = "^muffle")
[17:45:43.767]                   }
[17:45:43.767]                 }
[17:45:43.767]             }
[17:45:43.767]         }))
[17:45:43.767]     }, error = function(ex) {
[17:45:43.767]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:43.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:43.767]                 ...future.rng), started = ...future.startTime, 
[17:45:43.767]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:43.767]             version = "1.8"), class = "FutureResult")
[17:45:43.767]     }, finally = {
[17:45:43.767]         if (!identical(...future.workdir, getwd())) 
[17:45:43.767]             setwd(...future.workdir)
[17:45:43.767]         {
[17:45:43.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:43.767]                 ...future.oldOptions$nwarnings <- NULL
[17:45:43.767]             }
[17:45:43.767]             base::options(...future.oldOptions)
[17:45:43.767]             if (.Platform$OS.type == "windows") {
[17:45:43.767]                 old_names <- names(...future.oldEnvVars)
[17:45:43.767]                 envs <- base::Sys.getenv()
[17:45:43.767]                 names <- names(envs)
[17:45:43.767]                 common <- intersect(names, old_names)
[17:45:43.767]                 added <- setdiff(names, old_names)
[17:45:43.767]                 removed <- setdiff(old_names, names)
[17:45:43.767]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:43.767]                   envs[common]]
[17:45:43.767]                 NAMES <- toupper(changed)
[17:45:43.767]                 args <- list()
[17:45:43.767]                 for (kk in seq_along(NAMES)) {
[17:45:43.767]                   name <- changed[[kk]]
[17:45:43.767]                   NAME <- NAMES[[kk]]
[17:45:43.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:43.767]                     next
[17:45:43.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:43.767]                 }
[17:45:43.767]                 NAMES <- toupper(added)
[17:45:43.767]                 for (kk in seq_along(NAMES)) {
[17:45:43.767]                   name <- added[[kk]]
[17:45:43.767]                   NAME <- NAMES[[kk]]
[17:45:43.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:43.767]                     next
[17:45:43.767]                   args[[name]] <- ""
[17:45:43.767]                 }
[17:45:43.767]                 NAMES <- toupper(removed)
[17:45:43.767]                 for (kk in seq_along(NAMES)) {
[17:45:43.767]                   name <- removed[[kk]]
[17:45:43.767]                   NAME <- NAMES[[kk]]
[17:45:43.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:43.767]                     next
[17:45:43.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:43.767]                 }
[17:45:43.767]                 if (length(args) > 0) 
[17:45:43.767]                   base::do.call(base::Sys.setenv, args = args)
[17:45:43.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:43.767]             }
[17:45:43.767]             else {
[17:45:43.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:43.767]             }
[17:45:43.767]             {
[17:45:43.767]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:43.767]                   0L) {
[17:45:43.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:43.767]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:43.767]                   base::options(opts)
[17:45:43.767]                 }
[17:45:43.767]                 {
[17:45:43.767]                   {
[17:45:43.767]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:43.767]                     NULL
[17:45:43.767]                   }
[17:45:43.767]                   options(future.plan = NULL)
[17:45:43.767]                   if (is.na(NA_character_)) 
[17:45:43.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:43.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:43.767]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:43.767]                     .init = FALSE)
[17:45:43.767]                 }
[17:45:43.767]             }
[17:45:43.767]         }
[17:45:43.767]     })
[17:45:43.767]     if (TRUE) {
[17:45:43.767]         base::sink(type = "output", split = FALSE)
[17:45:43.767]         if (TRUE) {
[17:45:43.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:43.767]         }
[17:45:43.767]         else {
[17:45:43.767]             ...future.result["stdout"] <- base::list(NULL)
[17:45:43.767]         }
[17:45:43.767]         base::close(...future.stdout)
[17:45:43.767]         ...future.stdout <- NULL
[17:45:43.767]     }
[17:45:43.767]     ...future.result$conditions <- ...future.conditions
[17:45:43.767]     ...future.result$finished <- base::Sys.time()
[17:45:43.767]     ...future.result
[17:45:43.767] }
[17:45:43.770] assign_globals() ...
[17:45:43.770] List of 5
[17:45:43.770]  $ ...future.FUN            :function (x, y)  
[17:45:43.770]  $ MoreArgs                 : NULL
[17:45:43.770]  $ ...future.elements_ii    :List of 2
[17:45:43.770]   ..$ :List of 1
[17:45:43.770]   .. ..$ : int 1
[17:45:43.770]   ..$ :List of 1
[17:45:43.770]   .. ..$ : int 0
[17:45:43.770]  $ ...future.seeds_ii       : NULL
[17:45:43.770]  $ ...future.globals.maxSize: NULL
[17:45:43.770]  - attr(*, "where")=List of 5
[17:45:43.770]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:43.770]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:43.770]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:43.770]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:43.770]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:43.770]  - attr(*, "resolved")= logi FALSE
[17:45:43.770]  - attr(*, "total_size")= num 6368
[17:45:43.770]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:43.770]  - attr(*, "already-done")= logi TRUE
[17:45:43.775] - reassign environment for ‘...future.FUN’
[17:45:43.775] - copied ‘...future.FUN’ to environment
[17:45:43.775] - copied ‘MoreArgs’ to environment
[17:45:43.775] - copied ‘...future.elements_ii’ to environment
[17:45:43.775] - copied ‘...future.seeds_ii’ to environment
[17:45:43.775] - copied ‘...future.globals.maxSize’ to environment
[17:45:43.777] assign_globals() ... done
[17:45:43.777] requestCore(): workers = 2
[17:45:43.779] MulticoreFuture started
[17:45:43.780] - Launch lazy future ... done
[17:45:43.780] run() for ‘MulticoreFuture’ ... done
[17:45:43.781] plan(): Setting new future strategy stack:
[17:45:43.781] Created future:
[17:45:43.781] List of future strategies:
[17:45:43.781] 1. sequential:
[17:45:43.781]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:43.781]    - tweaked: FALSE
[17:45:43.781]    - call: NULL
[17:45:43.783] plan(): nbrOfWorkers() = 1
[17:45:43.781] MulticoreFuture:
[17:45:43.781] Label: ‘future_mapply-1’
[17:45:43.781] Expression:
[17:45:43.781] {
[17:45:43.781]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:43.781]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:43.781]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:43.781]         on.exit(options(oopts), add = TRUE)
[17:45:43.781]     }
[17:45:43.781]     {
[17:45:43.781]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:43.781]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:43.781]         do.call(mapply, args = args)
[17:45:43.781]     }
[17:45:43.781] }
[17:45:43.781] Lazy evaluation: FALSE
[17:45:43.781] Asynchronous evaluation: TRUE
[17:45:43.781] Local evaluation: TRUE
[17:45:43.781] Environment: R_GlobalEnv
[17:45:43.781] Capture standard output: TRUE
[17:45:43.781] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:43.781] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:43.781] Packages: <none>
[17:45:43.781] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:43.781] Resolved: FALSE
[17:45:43.781] Value: <not collected>
[17:45:43.781] Conditions captured: <none>
[17:45:43.781] Early signaling: FALSE
[17:45:43.781] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:43.781] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:43.795] Chunk #1 of 2 ... DONE
[17:45:43.795] Chunk #2 of 2 ...
[17:45:43.796]  - Finding globals in '...' for chunk #2 ...
[17:45:43.796] getGlobalsAndPackages() ...
[17:45:43.796] Searching for globals...
[17:45:43.797] 
[17:45:43.797] Searching for globals ... DONE
[17:45:43.798] - globals: [0] <none>
[17:45:43.798] getGlobalsAndPackages() ... DONE
[17:45:43.798]    + additional globals found: [n=0] 
[17:45:43.798]    + additional namespaces needed: [n=0] 
[17:45:43.798]  - Finding globals in '...' for chunk #2 ... DONE
[17:45:43.798]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:43.799]  - seeds: <none>
[17:45:43.799]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:43.799] getGlobalsAndPackages() ...
[17:45:43.799] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:43.799] Resolving globals: FALSE
[17:45:43.800] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:45:43.801] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:43.801] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:43.802] 
[17:45:43.802] getGlobalsAndPackages() ... DONE
[17:45:43.802] run() for ‘Future’ ...
[17:45:43.803] - state: ‘created’
[17:45:43.803] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:43.808] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:43.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:43.808]   - Field: ‘label’
[17:45:43.808]   - Field: ‘local’
[17:45:43.808]   - Field: ‘owner’
[17:45:43.808]   - Field: ‘envir’
[17:45:43.809]   - Field: ‘workers’
[17:45:43.809]   - Field: ‘packages’
[17:45:43.809]   - Field: ‘gc’
[17:45:43.809]   - Field: ‘job’
[17:45:43.809]   - Field: ‘conditions’
[17:45:43.809]   - Field: ‘expr’
[17:45:43.809]   - Field: ‘uuid’
[17:45:43.810]   - Field: ‘seed’
[17:45:43.810]   - Field: ‘version’
[17:45:43.810]   - Field: ‘result’
[17:45:43.810]   - Field: ‘asynchronous’
[17:45:43.810]   - Field: ‘calls’
[17:45:43.810]   - Field: ‘globals’
[17:45:43.810]   - Field: ‘stdout’
[17:45:43.810]   - Field: ‘earlySignal’
[17:45:43.811]   - Field: ‘lazy’
[17:45:43.811]   - Field: ‘state’
[17:45:43.811] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:43.811] - Launch lazy future ...
[17:45:43.811] Packages needed by the future expression (n = 0): <none>
[17:45:43.812] Packages needed by future strategies (n = 0): <none>
[17:45:43.812] {
[17:45:43.812]     {
[17:45:43.812]         {
[17:45:43.812]             ...future.startTime <- base::Sys.time()
[17:45:43.812]             {
[17:45:43.812]                 {
[17:45:43.812]                   {
[17:45:43.812]                     {
[17:45:43.812]                       base::local({
[17:45:43.812]                         has_future <- base::requireNamespace("future", 
[17:45:43.812]                           quietly = TRUE)
[17:45:43.812]                         if (has_future) {
[17:45:43.812]                           ns <- base::getNamespace("future")
[17:45:43.812]                           version <- ns[[".package"]][["version"]]
[17:45:43.812]                           if (is.null(version)) 
[17:45:43.812]                             version <- utils::packageVersion("future")
[17:45:43.812]                         }
[17:45:43.812]                         else {
[17:45:43.812]                           version <- NULL
[17:45:43.812]                         }
[17:45:43.812]                         if (!has_future || version < "1.8.0") {
[17:45:43.812]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:43.812]                             "", base::R.version$version.string), 
[17:45:43.812]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:43.812]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:43.812]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:43.812]                               "release", "version")], collapse = " "), 
[17:45:43.812]                             hostname = base::Sys.info()[["nodename"]])
[17:45:43.812]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:43.812]                             info)
[17:45:43.812]                           info <- base::paste(info, collapse = "; ")
[17:45:43.812]                           if (!has_future) {
[17:45:43.812]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:43.812]                               info)
[17:45:43.812]                           }
[17:45:43.812]                           else {
[17:45:43.812]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:43.812]                               info, version)
[17:45:43.812]                           }
[17:45:43.812]                           base::stop(msg)
[17:45:43.812]                         }
[17:45:43.812]                       })
[17:45:43.812]                     }
[17:45:43.812]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:43.812]                     base::options(mc.cores = 1L)
[17:45:43.812]                   }
[17:45:43.812]                   ...future.strategy.old <- future::plan("list")
[17:45:43.812]                   options(future.plan = NULL)
[17:45:43.812]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:43.812]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:43.812]                 }
[17:45:43.812]                 ...future.workdir <- getwd()
[17:45:43.812]             }
[17:45:43.812]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:43.812]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:43.812]         }
[17:45:43.812]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:43.812]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:43.812]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:43.812]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:43.812]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:43.812]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:43.812]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:43.812]             base::names(...future.oldOptions))
[17:45:43.812]     }
[17:45:43.812]     if (FALSE) {
[17:45:43.812]     }
[17:45:43.812]     else {
[17:45:43.812]         if (TRUE) {
[17:45:43.812]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:43.812]                 open = "w")
[17:45:43.812]         }
[17:45:43.812]         else {
[17:45:43.812]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:43.812]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:43.812]         }
[17:45:43.812]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:43.812]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:43.812]             base::sink(type = "output", split = FALSE)
[17:45:43.812]             base::close(...future.stdout)
[17:45:43.812]         }, add = TRUE)
[17:45:43.812]     }
[17:45:43.812]     ...future.frame <- base::sys.nframe()
[17:45:43.812]     ...future.conditions <- base::list()
[17:45:43.812]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:43.812]     if (FALSE) {
[17:45:43.812]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:43.812]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:43.812]     }
[17:45:43.812]     ...future.result <- base::tryCatch({
[17:45:43.812]         base::withCallingHandlers({
[17:45:43.812]             ...future.value <- base::withVisible(base::local({
[17:45:43.812]                 withCallingHandlers({
[17:45:43.812]                   {
[17:45:43.812]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:43.812]                     if (!identical(...future.globals.maxSize.org, 
[17:45:43.812]                       ...future.globals.maxSize)) {
[17:45:43.812]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:43.812]                       on.exit(options(oopts), add = TRUE)
[17:45:43.812]                     }
[17:45:43.812]                     {
[17:45:43.812]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:43.812]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:43.812]                         USE.NAMES = FALSE)
[17:45:43.812]                       do.call(mapply, args = args)
[17:45:43.812]                     }
[17:45:43.812]                   }
[17:45:43.812]                 }, immediateCondition = function(cond) {
[17:45:43.812]                   save_rds <- function (object, pathname, ...) 
[17:45:43.812]                   {
[17:45:43.812]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:43.812]                     if (file_test("-f", pathname_tmp)) {
[17:45:43.812]                       fi_tmp <- file.info(pathname_tmp)
[17:45:43.812]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:43.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:43.812]                         fi_tmp[["mtime"]])
[17:45:43.812]                     }
[17:45:43.812]                     tryCatch({
[17:45:43.812]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:43.812]                     }, error = function(ex) {
[17:45:43.812]                       msg <- conditionMessage(ex)
[17:45:43.812]                       fi_tmp <- file.info(pathname_tmp)
[17:45:43.812]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:43.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:43.812]                         fi_tmp[["mtime"]], msg)
[17:45:43.812]                       ex$message <- msg
[17:45:43.812]                       stop(ex)
[17:45:43.812]                     })
[17:45:43.812]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:43.812]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:43.812]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:43.812]                       fi_tmp <- file.info(pathname_tmp)
[17:45:43.812]                       fi <- file.info(pathname)
[17:45:43.812]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:43.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:43.812]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:43.812]                         fi[["size"]], fi[["mtime"]])
[17:45:43.812]                       stop(msg)
[17:45:43.812]                     }
[17:45:43.812]                     invisible(pathname)
[17:45:43.812]                   }
[17:45:43.812]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:43.812]                     rootPath = tempdir()) 
[17:45:43.812]                   {
[17:45:43.812]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:43.812]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:43.812]                       tmpdir = path, fileext = ".rds")
[17:45:43.812]                     save_rds(obj, file)
[17:45:43.812]                   }
[17:45:43.812]                   saveImmediateCondition(cond, path = "/tmp/RtmpnHaLG7/.future/immediateConditions")
[17:45:43.812]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:43.812]                   {
[17:45:43.812]                     inherits <- base::inherits
[17:45:43.812]                     invokeRestart <- base::invokeRestart
[17:45:43.812]                     is.null <- base::is.null
[17:45:43.812]                     muffled <- FALSE
[17:45:43.812]                     if (inherits(cond, "message")) {
[17:45:43.812]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:43.812]                       if (muffled) 
[17:45:43.812]                         invokeRestart("muffleMessage")
[17:45:43.812]                     }
[17:45:43.812]                     else if (inherits(cond, "warning")) {
[17:45:43.812]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:43.812]                       if (muffled) 
[17:45:43.812]                         invokeRestart("muffleWarning")
[17:45:43.812]                     }
[17:45:43.812]                     else if (inherits(cond, "condition")) {
[17:45:43.812]                       if (!is.null(pattern)) {
[17:45:43.812]                         computeRestarts <- base::computeRestarts
[17:45:43.812]                         grepl <- base::grepl
[17:45:43.812]                         restarts <- computeRestarts(cond)
[17:45:43.812]                         for (restart in restarts) {
[17:45:43.812]                           name <- restart$name
[17:45:43.812]                           if (is.null(name)) 
[17:45:43.812]                             next
[17:45:43.812]                           if (!grepl(pattern, name)) 
[17:45:43.812]                             next
[17:45:43.812]                           invokeRestart(restart)
[17:45:43.812]                           muffled <- TRUE
[17:45:43.812]                           break
[17:45:43.812]                         }
[17:45:43.812]                       }
[17:45:43.812]                     }
[17:45:43.812]                     invisible(muffled)
[17:45:43.812]                   }
[17:45:43.812]                   muffleCondition(cond)
[17:45:43.812]                 })
[17:45:43.812]             }))
[17:45:43.812]             future::FutureResult(value = ...future.value$value, 
[17:45:43.812]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:43.812]                   ...future.rng), globalenv = if (FALSE) 
[17:45:43.812]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:43.812]                     ...future.globalenv.names))
[17:45:43.812]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:43.812]         }, condition = base::local({
[17:45:43.812]             c <- base::c
[17:45:43.812]             inherits <- base::inherits
[17:45:43.812]             invokeRestart <- base::invokeRestart
[17:45:43.812]             length <- base::length
[17:45:43.812]             list <- base::list
[17:45:43.812]             seq.int <- base::seq.int
[17:45:43.812]             signalCondition <- base::signalCondition
[17:45:43.812]             sys.calls <- base::sys.calls
[17:45:43.812]             `[[` <- base::`[[`
[17:45:43.812]             `+` <- base::`+`
[17:45:43.812]             `<<-` <- base::`<<-`
[17:45:43.812]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:43.812]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:43.812]                   3L)]
[17:45:43.812]             }
[17:45:43.812]             function(cond) {
[17:45:43.812]                 is_error <- inherits(cond, "error")
[17:45:43.812]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:43.812]                   NULL)
[17:45:43.812]                 if (is_error) {
[17:45:43.812]                   sessionInformation <- function() {
[17:45:43.812]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:43.812]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:43.812]                       search = base::search(), system = base::Sys.info())
[17:45:43.812]                   }
[17:45:43.812]                   ...future.conditions[[length(...future.conditions) + 
[17:45:43.812]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:43.812]                     cond$call), session = sessionInformation(), 
[17:45:43.812]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:43.812]                   signalCondition(cond)
[17:45:43.812]                 }
[17:45:43.812]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:43.812]                 "immediateCondition"))) {
[17:45:43.812]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:43.812]                   ...future.conditions[[length(...future.conditions) + 
[17:45:43.812]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:43.812]                   if (TRUE && !signal) {
[17:45:43.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:43.812]                     {
[17:45:43.812]                       inherits <- base::inherits
[17:45:43.812]                       invokeRestart <- base::invokeRestart
[17:45:43.812]                       is.null <- base::is.null
[17:45:43.812]                       muffled <- FALSE
[17:45:43.812]                       if (inherits(cond, "message")) {
[17:45:43.812]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:43.812]                         if (muffled) 
[17:45:43.812]                           invokeRestart("muffleMessage")
[17:45:43.812]                       }
[17:45:43.812]                       else if (inherits(cond, "warning")) {
[17:45:43.812]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:43.812]                         if (muffled) 
[17:45:43.812]                           invokeRestart("muffleWarning")
[17:45:43.812]                       }
[17:45:43.812]                       else if (inherits(cond, "condition")) {
[17:45:43.812]                         if (!is.null(pattern)) {
[17:45:43.812]                           computeRestarts <- base::computeRestarts
[17:45:43.812]                           grepl <- base::grepl
[17:45:43.812]                           restarts <- computeRestarts(cond)
[17:45:43.812]                           for (restart in restarts) {
[17:45:43.812]                             name <- restart$name
[17:45:43.812]                             if (is.null(name)) 
[17:45:43.812]                               next
[17:45:43.812]                             if (!grepl(pattern, name)) 
[17:45:43.812]                               next
[17:45:43.812]                             invokeRestart(restart)
[17:45:43.812]                             muffled <- TRUE
[17:45:43.812]                             break
[17:45:43.812]                           }
[17:45:43.812]                         }
[17:45:43.812]                       }
[17:45:43.812]                       invisible(muffled)
[17:45:43.812]                     }
[17:45:43.812]                     muffleCondition(cond, pattern = "^muffle")
[17:45:43.812]                   }
[17:45:43.812]                 }
[17:45:43.812]                 else {
[17:45:43.812]                   if (TRUE) {
[17:45:43.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:43.812]                     {
[17:45:43.812]                       inherits <- base::inherits
[17:45:43.812]                       invokeRestart <- base::invokeRestart
[17:45:43.812]                       is.null <- base::is.null
[17:45:43.812]                       muffled <- FALSE
[17:45:43.812]                       if (inherits(cond, "message")) {
[17:45:43.812]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:43.812]                         if (muffled) 
[17:45:43.812]                           invokeRestart("muffleMessage")
[17:45:43.812]                       }
[17:45:43.812]                       else if (inherits(cond, "warning")) {
[17:45:43.812]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:43.812]                         if (muffled) 
[17:45:43.812]                           invokeRestart("muffleWarning")
[17:45:43.812]                       }
[17:45:43.812]                       else if (inherits(cond, "condition")) {
[17:45:43.812]                         if (!is.null(pattern)) {
[17:45:43.812]                           computeRestarts <- base::computeRestarts
[17:45:43.812]                           grepl <- base::grepl
[17:45:43.812]                           restarts <- computeRestarts(cond)
[17:45:43.812]                           for (restart in restarts) {
[17:45:43.812]                             name <- restart$name
[17:45:43.812]                             if (is.null(name)) 
[17:45:43.812]                               next
[17:45:43.812]                             if (!grepl(pattern, name)) 
[17:45:43.812]                               next
[17:45:43.812]                             invokeRestart(restart)
[17:45:43.812]                             muffled <- TRUE
[17:45:43.812]                             break
[17:45:43.812]                           }
[17:45:43.812]                         }
[17:45:43.812]                       }
[17:45:43.812]                       invisible(muffled)
[17:45:43.812]                     }
[17:45:43.812]                     muffleCondition(cond, pattern = "^muffle")
[17:45:43.812]                   }
[17:45:43.812]                 }
[17:45:43.812]             }
[17:45:43.812]         }))
[17:45:43.812]     }, error = function(ex) {
[17:45:43.812]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:43.812]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:43.812]                 ...future.rng), started = ...future.startTime, 
[17:45:43.812]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:43.812]             version = "1.8"), class = "FutureResult")
[17:45:43.812]     }, finally = {
[17:45:43.812]         if (!identical(...future.workdir, getwd())) 
[17:45:43.812]             setwd(...future.workdir)
[17:45:43.812]         {
[17:45:43.812]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:43.812]                 ...future.oldOptions$nwarnings <- NULL
[17:45:43.812]             }
[17:45:43.812]             base::options(...future.oldOptions)
[17:45:43.812]             if (.Platform$OS.type == "windows") {
[17:45:43.812]                 old_names <- names(...future.oldEnvVars)
[17:45:43.812]                 envs <- base::Sys.getenv()
[17:45:43.812]                 names <- names(envs)
[17:45:43.812]                 common <- intersect(names, old_names)
[17:45:43.812]                 added <- setdiff(names, old_names)
[17:45:43.812]                 removed <- setdiff(old_names, names)
[17:45:43.812]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:43.812]                   envs[common]]
[17:45:43.812]                 NAMES <- toupper(changed)
[17:45:43.812]                 args <- list()
[17:45:43.812]                 for (kk in seq_along(NAMES)) {
[17:45:43.812]                   name <- changed[[kk]]
[17:45:43.812]                   NAME <- NAMES[[kk]]
[17:45:43.812]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:43.812]                     next
[17:45:43.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:43.812]                 }
[17:45:43.812]                 NAMES <- toupper(added)
[17:45:43.812]                 for (kk in seq_along(NAMES)) {
[17:45:43.812]                   name <- added[[kk]]
[17:45:43.812]                   NAME <- NAMES[[kk]]
[17:45:43.812]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:43.812]                     next
[17:45:43.812]                   args[[name]] <- ""
[17:45:43.812]                 }
[17:45:43.812]                 NAMES <- toupper(removed)
[17:45:43.812]                 for (kk in seq_along(NAMES)) {
[17:45:43.812]                   name <- removed[[kk]]
[17:45:43.812]                   NAME <- NAMES[[kk]]
[17:45:43.812]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:43.812]                     next
[17:45:43.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:43.812]                 }
[17:45:43.812]                 if (length(args) > 0) 
[17:45:43.812]                   base::do.call(base::Sys.setenv, args = args)
[17:45:43.812]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:43.812]             }
[17:45:43.812]             else {
[17:45:43.812]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:43.812]             }
[17:45:43.812]             {
[17:45:43.812]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:43.812]                   0L) {
[17:45:43.812]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:43.812]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:43.812]                   base::options(opts)
[17:45:43.812]                 }
[17:45:43.812]                 {
[17:45:43.812]                   {
[17:45:43.812]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:43.812]                     NULL
[17:45:43.812]                   }
[17:45:43.812]                   options(future.plan = NULL)
[17:45:43.812]                   if (is.na(NA_character_)) 
[17:45:43.812]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:43.812]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:43.812]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:43.812]                     .init = FALSE)
[17:45:43.812]                 }
[17:45:43.812]             }
[17:45:43.812]         }
[17:45:43.812]     })
[17:45:43.812]     if (TRUE) {
[17:45:43.812]         base::sink(type = "output", split = FALSE)
[17:45:43.812]         if (TRUE) {
[17:45:43.812]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:43.812]         }
[17:45:43.812]         else {
[17:45:43.812]             ...future.result["stdout"] <- base::list(NULL)
[17:45:43.812]         }
[17:45:43.812]         base::close(...future.stdout)
[17:45:43.812]         ...future.stdout <- NULL
[17:45:43.812]     }
[17:45:43.812]     ...future.result$conditions <- ...future.conditions
[17:45:43.812]     ...future.result$finished <- base::Sys.time()
[17:45:43.812]     ...future.result
[17:45:43.812] }
[17:45:43.815] assign_globals() ...
[17:45:43.816] List of 5
[17:45:43.816]  $ ...future.FUN            :function (x, y)  
[17:45:43.816]  $ MoreArgs                 : NULL
[17:45:43.816]  $ ...future.elements_ii    :List of 2
[17:45:43.816]   ..$ :List of 1
[17:45:43.816]   .. ..$ : int 0
[17:45:43.816]   ..$ :List of 1
[17:45:43.816]   .. ..$ : int 1
[17:45:43.816]  $ ...future.seeds_ii       : NULL
[17:45:43.816]  $ ...future.globals.maxSize: NULL
[17:45:43.816]  - attr(*, "where")=List of 5
[17:45:43.816]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:43.816]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:43.816]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:43.816]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:43.816]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:43.816]  - attr(*, "resolved")= logi FALSE
[17:45:43.816]  - attr(*, "total_size")= num 6368
[17:45:43.816]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:43.816]  - attr(*, "already-done")= logi TRUE
[17:45:43.823] - reassign environment for ‘...future.FUN’
[17:45:43.823] - copied ‘...future.FUN’ to environment
[17:45:43.823] - copied ‘MoreArgs’ to environment
[17:45:43.823] - copied ‘...future.elements_ii’ to environment
[17:45:43.823] - copied ‘...future.seeds_ii’ to environment
[17:45:43.823] - copied ‘...future.globals.maxSize’ to environment
[17:45:43.823] assign_globals() ... done
[17:45:43.824] requestCore(): workers = 2
[17:45:43.826] MulticoreFuture started
[17:45:43.826] - Launch lazy future ... done
[17:45:43.826] run() for ‘MulticoreFuture’ ... done
[17:45:43.826] Created future:
[17:45:43.827] plan(): Setting new future strategy stack:
[17:45:43.827] List of future strategies:
[17:45:43.827] 1. sequential:
[17:45:43.827]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:43.827]    - tweaked: FALSE
[17:45:43.827]    - call: NULL
[17:45:43.828] plan(): nbrOfWorkers() = 1
[17:45:43.830] plan(): Setting new future strategy stack:
[17:45:43.830] List of future strategies:
[17:45:43.830] 1. multicore:
[17:45:43.830]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:43.830]    - tweaked: FALSE
[17:45:43.830]    - call: plan(strategy)
[17:45:43.836] plan(): nbrOfWorkers() = 2
[17:45:43.827] MulticoreFuture:
[17:45:43.827] Label: ‘future_mapply-2’
[17:45:43.827] Expression:
[17:45:43.827] {
[17:45:43.827]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:43.827]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:43.827]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:43.827]         on.exit(options(oopts), add = TRUE)
[17:45:43.827]     }
[17:45:43.827]     {
[17:45:43.827]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:43.827]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:43.827]         do.call(mapply, args = args)
[17:45:43.827]     }
[17:45:43.827] }
[17:45:43.827] Lazy evaluation: FALSE
[17:45:43.827] Asynchronous evaluation: TRUE
[17:45:43.827] Local evaluation: TRUE
[17:45:43.827] Environment: R_GlobalEnv
[17:45:43.827] Capture standard output: TRUE
[17:45:43.827] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:43.827] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:43.827] Packages: <none>
[17:45:43.827] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:43.827] Resolved: TRUE
[17:45:43.827] Value: <not collected>
[17:45:43.827] Conditions captured: <none>
[17:45:43.827] Early signaling: FALSE
[17:45:43.827] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:43.827] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:43.837] Chunk #2 of 2 ... DONE
[17:45:43.837] Launching 2 futures (chunks) ... DONE
[17:45:43.837] Resolving 2 futures (chunks) ...
[17:45:43.837] resolve() on list ...
[17:45:43.837]  recursive: 0
[17:45:43.837]  length: 2
[17:45:43.838] 
[17:45:43.848] Future #2
[17:45:43.848] result() for MulticoreFuture ...
[17:45:43.849] result() for MulticoreFuture ...
[17:45:43.849] result() for MulticoreFuture ... done
[17:45:43.850] result() for MulticoreFuture ... done
[17:45:43.850] result() for MulticoreFuture ...
[17:45:43.850] result() for MulticoreFuture ... done
[17:45:43.850] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:43.850] - nx: 2
[17:45:43.850] - relay: TRUE
[17:45:43.850] - stdout: TRUE
[17:45:43.851] - signal: TRUE
[17:45:43.851] - resignal: FALSE
[17:45:43.851] - force: TRUE
[17:45:43.851] - relayed: [n=2] FALSE, FALSE
[17:45:43.851] - queued futures: [n=2] FALSE, FALSE
[17:45:43.851]  - until=1
[17:45:43.851]  - relaying element #1
[17:45:43.852] - relayed: [n=2] FALSE, FALSE
[17:45:43.852] - queued futures: [n=2] FALSE, TRUE
[17:45:43.852] signalConditionsASAP(NULL, pos=2) ... done
[17:45:43.852]  length: 1 (resolved future 2)
[17:45:44.286] plan(): Setting new future strategy stack:
[17:45:44.286] List of future strategies:
[17:45:44.286] 1. multicore:
[17:45:44.286]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:44.286]    - tweaked: FALSE
[17:45:44.286]    - call: plan(strategy)
[17:45:44.291] plan(): nbrOfWorkers() = 2
[17:45:44.294] Future #1
[17:45:44.294] result() for MulticoreFuture ...
[17:45:44.295] result() for MulticoreFuture ...
[17:45:44.295] result() for MulticoreFuture ... done
[17:45:44.295] result() for MulticoreFuture ... done
[17:45:44.296] result() for MulticoreFuture ...
[17:45:44.296] result() for MulticoreFuture ... done
[17:45:44.296] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:44.296] - nx: 2
[17:45:44.296] - relay: TRUE
[17:45:44.296] - stdout: TRUE
[17:45:44.297] - signal: TRUE
[17:45:44.297] - resignal: FALSE
[17:45:44.297] - force: TRUE
[17:45:44.297] - relayed: [n=2] FALSE, FALSE
[17:45:44.297] - queued futures: [n=2] FALSE, TRUE
[17:45:44.297]  - until=1
[17:45:44.297]  - relaying element #1
[17:45:44.297] result() for MulticoreFuture ...
[17:45:44.298] result() for MulticoreFuture ... done
[17:45:44.298] result() for MulticoreFuture ...
[17:45:44.298] result() for MulticoreFuture ... done
[17:45:44.298] result() for MulticoreFuture ...
[17:45:44.298] result() for MulticoreFuture ... done
[17:45:44.298] result() for MulticoreFuture ...
[17:45:44.298] result() for MulticoreFuture ... done
[17:45:44.298] - relayed: [n=2] TRUE, FALSE
[17:45:44.299] - queued futures: [n=2] TRUE, TRUE
[17:45:44.299] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:44.299]  length: 0 (resolved future 1)
[17:45:44.299] Relaying remaining futures
[17:45:44.299] signalConditionsASAP(NULL, pos=0) ...
[17:45:44.299] - nx: 2
[17:45:44.299] - relay: TRUE
[17:45:44.299] - stdout: TRUE
[17:45:44.299] - signal: TRUE
[17:45:44.300] - resignal: FALSE
[17:45:44.300] - force: TRUE
[17:45:44.300] - relayed: [n=2] TRUE, FALSE
[17:45:44.300] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:44.300]  - relaying element #2
[17:45:44.300] result() for MulticoreFuture ...
[17:45:44.300] result() for MulticoreFuture ... done
[17:45:44.300] result() for MulticoreFuture ...
[17:45:44.300] result() for MulticoreFuture ... done
[17:45:44.301] result() for MulticoreFuture ...
[17:45:44.301] result() for MulticoreFuture ... done
[17:45:44.301] result() for MulticoreFuture ...
[17:45:44.301] result() for MulticoreFuture ... done
[17:45:44.301] - relayed: [n=2] TRUE, TRUE
[17:45:44.301] - queued futures: [n=2] TRUE, TRUE
[17:45:44.301] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:45:44.301] resolve() on list ... DONE
[17:45:44.301] result() for MulticoreFuture ...
[17:45:44.302] result() for MulticoreFuture ... done
[17:45:44.302] result() for MulticoreFuture ...
[17:45:44.302] result() for MulticoreFuture ... done
[17:45:44.302] result() for MulticoreFuture ...
[17:45:44.302] result() for MulticoreFuture ... done
[17:45:44.302] result() for MulticoreFuture ...
[17:45:44.302] result() for MulticoreFuture ... done
[17:45:44.302]  - Number of value chunks collected: 2
[17:45:44.302] Resolving 2 futures (chunks) ... DONE
[17:45:44.303] Reducing values from 2 chunks ...
[17:45:44.303]  - Number of values collected after concatenation: 2
[17:45:44.303]  - Number of values expected: 2
[17:45:44.303] Reducing values from 2 chunks ... DONE
[17:45:44.303] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:45:44.303] future_mapply() ...
[17:45:44.307] Number of chunks: 2
[17:45:44.307] getGlobalsAndPackagesXApply() ...
[17:45:44.308]  - future.globals: TRUE
[17:45:44.308] getGlobalsAndPackages() ...
[17:45:44.308] Searching for globals...
[17:45:44.310] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:44.310] Searching for globals ... DONE
[17:45:44.310] Resolving globals: FALSE
[17:45:44.310] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:44.311] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:44.311] - globals: [1] ‘FUN’
[17:45:44.311] 
[17:45:44.311] getGlobalsAndPackages() ... DONE
[17:45:44.311]  - globals found/used: [n=1] ‘FUN’
[17:45:44.311]  - needed namespaces: [n=0] 
[17:45:44.312] Finding globals ... DONE
[17:45:44.312] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:44.312] List of 2
[17:45:44.312]  $ ...future.FUN:function (x, y)  
[17:45:44.312]  $ MoreArgs     : NULL
[17:45:44.312]  - attr(*, "where")=List of 2
[17:45:44.312]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:44.312]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:44.312]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:44.312]  - attr(*, "resolved")= logi FALSE
[17:45:44.312]  - attr(*, "total_size")= num NA
[17:45:44.315] Packages to be attached in all futures: [n=0] 
[17:45:44.315] getGlobalsAndPackagesXApply() ... DONE
[17:45:44.315] Number of futures (= number of chunks): 2
[17:45:44.315] Launching 2 futures (chunks) ...
[17:45:44.315] Chunk #1 of 2 ...
[17:45:44.315]  - Finding globals in '...' for chunk #1 ...
[17:45:44.316] getGlobalsAndPackages() ...
[17:45:44.316] Searching for globals...
[17:45:44.316] 
[17:45:44.316] Searching for globals ... DONE
[17:45:44.316] - globals: [0] <none>
[17:45:44.316] getGlobalsAndPackages() ... DONE
[17:45:44.316]    + additional globals found: [n=0] 
[17:45:44.316]    + additional namespaces needed: [n=0] 
[17:45:44.316]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:44.317]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:44.317]  - seeds: <none>
[17:45:44.317]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:44.317] getGlobalsAndPackages() ...
[17:45:44.317] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:44.317] Resolving globals: FALSE
[17:45:44.318] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:45:44.318] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:44.318] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:44.318] 
[17:45:44.318] getGlobalsAndPackages() ... DONE
[17:45:44.319] run() for ‘Future’ ...
[17:45:44.319] - state: ‘created’
[17:45:44.319] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:44.322] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:44.323] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:44.323]   - Field: ‘label’
[17:45:44.323]   - Field: ‘local’
[17:45:44.323]   - Field: ‘owner’
[17:45:44.323]   - Field: ‘envir’
[17:45:44.323]   - Field: ‘workers’
[17:45:44.325]   - Field: ‘packages’
[17:45:44.325]   - Field: ‘gc’
[17:45:44.325]   - Field: ‘job’
[17:45:44.326]   - Field: ‘conditions’
[17:45:44.326]   - Field: ‘expr’
[17:45:44.326]   - Field: ‘uuid’
[17:45:44.326]   - Field: ‘seed’
[17:45:44.326]   - Field: ‘version’
[17:45:44.326]   - Field: ‘result’
[17:45:44.326]   - Field: ‘asynchronous’
[17:45:44.326]   - Field: ‘calls’
[17:45:44.326]   - Field: ‘globals’
[17:45:44.327]   - Field: ‘stdout’
[17:45:44.327]   - Field: ‘earlySignal’
[17:45:44.327]   - Field: ‘lazy’
[17:45:44.327]   - Field: ‘state’
[17:45:44.327] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:44.327] - Launch lazy future ...
[17:45:44.327] Packages needed by the future expression (n = 0): <none>
[17:45:44.328] Packages needed by future strategies (n = 0): <none>
[17:45:44.328] {
[17:45:44.328]     {
[17:45:44.328]         {
[17:45:44.328]             ...future.startTime <- base::Sys.time()
[17:45:44.328]             {
[17:45:44.328]                 {
[17:45:44.328]                   {
[17:45:44.328]                     {
[17:45:44.328]                       base::local({
[17:45:44.328]                         has_future <- base::requireNamespace("future", 
[17:45:44.328]                           quietly = TRUE)
[17:45:44.328]                         if (has_future) {
[17:45:44.328]                           ns <- base::getNamespace("future")
[17:45:44.328]                           version <- ns[[".package"]][["version"]]
[17:45:44.328]                           if (is.null(version)) 
[17:45:44.328]                             version <- utils::packageVersion("future")
[17:45:44.328]                         }
[17:45:44.328]                         else {
[17:45:44.328]                           version <- NULL
[17:45:44.328]                         }
[17:45:44.328]                         if (!has_future || version < "1.8.0") {
[17:45:44.328]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:44.328]                             "", base::R.version$version.string), 
[17:45:44.328]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:44.328]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:44.328]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:44.328]                               "release", "version")], collapse = " "), 
[17:45:44.328]                             hostname = base::Sys.info()[["nodename"]])
[17:45:44.328]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:44.328]                             info)
[17:45:44.328]                           info <- base::paste(info, collapse = "; ")
[17:45:44.328]                           if (!has_future) {
[17:45:44.328]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:44.328]                               info)
[17:45:44.328]                           }
[17:45:44.328]                           else {
[17:45:44.328]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:44.328]                               info, version)
[17:45:44.328]                           }
[17:45:44.328]                           base::stop(msg)
[17:45:44.328]                         }
[17:45:44.328]                       })
[17:45:44.328]                     }
[17:45:44.328]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:44.328]                     base::options(mc.cores = 1L)
[17:45:44.328]                   }
[17:45:44.328]                   ...future.strategy.old <- future::plan("list")
[17:45:44.328]                   options(future.plan = NULL)
[17:45:44.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:44.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:44.328]                 }
[17:45:44.328]                 ...future.workdir <- getwd()
[17:45:44.328]             }
[17:45:44.328]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:44.328]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:44.328]         }
[17:45:44.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:44.328]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:44.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:44.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:44.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:44.328]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:44.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:44.328]             base::names(...future.oldOptions))
[17:45:44.328]     }
[17:45:44.328]     if (TRUE) {
[17:45:44.328]     }
[17:45:44.328]     else {
[17:45:44.328]         if (NA) {
[17:45:44.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:44.328]                 open = "w")
[17:45:44.328]         }
[17:45:44.328]         else {
[17:45:44.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:44.328]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:44.328]         }
[17:45:44.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:44.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:44.328]             base::sink(type = "output", split = FALSE)
[17:45:44.328]             base::close(...future.stdout)
[17:45:44.328]         }, add = TRUE)
[17:45:44.328]     }
[17:45:44.328]     ...future.frame <- base::sys.nframe()
[17:45:44.328]     ...future.conditions <- base::list()
[17:45:44.328]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:44.328]     if (FALSE) {
[17:45:44.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:44.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:44.328]     }
[17:45:44.328]     ...future.result <- base::tryCatch({
[17:45:44.328]         base::withCallingHandlers({
[17:45:44.328]             ...future.value <- base::withVisible(base::local({
[17:45:44.328]                 withCallingHandlers({
[17:45:44.328]                   {
[17:45:44.328]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:44.328]                     if (!identical(...future.globals.maxSize.org, 
[17:45:44.328]                       ...future.globals.maxSize)) {
[17:45:44.328]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:44.328]                       on.exit(options(oopts), add = TRUE)
[17:45:44.328]                     }
[17:45:44.328]                     {
[17:45:44.328]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:44.328]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:44.328]                         USE.NAMES = FALSE)
[17:45:44.328]                       do.call(mapply, args = args)
[17:45:44.328]                     }
[17:45:44.328]                   }
[17:45:44.328]                 }, immediateCondition = function(cond) {
[17:45:44.328]                   save_rds <- function (object, pathname, ...) 
[17:45:44.328]                   {
[17:45:44.328]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:44.328]                     if (file_test("-f", pathname_tmp)) {
[17:45:44.328]                       fi_tmp <- file.info(pathname_tmp)
[17:45:44.328]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:44.328]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:44.328]                         fi_tmp[["mtime"]])
[17:45:44.328]                     }
[17:45:44.328]                     tryCatch({
[17:45:44.328]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:44.328]                     }, error = function(ex) {
[17:45:44.328]                       msg <- conditionMessage(ex)
[17:45:44.328]                       fi_tmp <- file.info(pathname_tmp)
[17:45:44.328]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:44.328]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:44.328]                         fi_tmp[["mtime"]], msg)
[17:45:44.328]                       ex$message <- msg
[17:45:44.328]                       stop(ex)
[17:45:44.328]                     })
[17:45:44.328]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:44.328]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:44.328]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:44.328]                       fi_tmp <- file.info(pathname_tmp)
[17:45:44.328]                       fi <- file.info(pathname)
[17:45:44.328]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:44.328]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:44.328]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:44.328]                         fi[["size"]], fi[["mtime"]])
[17:45:44.328]                       stop(msg)
[17:45:44.328]                     }
[17:45:44.328]                     invisible(pathname)
[17:45:44.328]                   }
[17:45:44.328]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:44.328]                     rootPath = tempdir()) 
[17:45:44.328]                   {
[17:45:44.328]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:44.328]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:44.328]                       tmpdir = path, fileext = ".rds")
[17:45:44.328]                     save_rds(obj, file)
[17:45:44.328]                   }
[17:45:44.328]                   saveImmediateCondition(cond, path = "/tmp/RtmpnHaLG7/.future/immediateConditions")
[17:45:44.328]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:44.328]                   {
[17:45:44.328]                     inherits <- base::inherits
[17:45:44.328]                     invokeRestart <- base::invokeRestart
[17:45:44.328]                     is.null <- base::is.null
[17:45:44.328]                     muffled <- FALSE
[17:45:44.328]                     if (inherits(cond, "message")) {
[17:45:44.328]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:44.328]                       if (muffled) 
[17:45:44.328]                         invokeRestart("muffleMessage")
[17:45:44.328]                     }
[17:45:44.328]                     else if (inherits(cond, "warning")) {
[17:45:44.328]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:44.328]                       if (muffled) 
[17:45:44.328]                         invokeRestart("muffleWarning")
[17:45:44.328]                     }
[17:45:44.328]                     else if (inherits(cond, "condition")) {
[17:45:44.328]                       if (!is.null(pattern)) {
[17:45:44.328]                         computeRestarts <- base::computeRestarts
[17:45:44.328]                         grepl <- base::grepl
[17:45:44.328]                         restarts <- computeRestarts(cond)
[17:45:44.328]                         for (restart in restarts) {
[17:45:44.328]                           name <- restart$name
[17:45:44.328]                           if (is.null(name)) 
[17:45:44.328]                             next
[17:45:44.328]                           if (!grepl(pattern, name)) 
[17:45:44.328]                             next
[17:45:44.328]                           invokeRestart(restart)
[17:45:44.328]                           muffled <- TRUE
[17:45:44.328]                           break
[17:45:44.328]                         }
[17:45:44.328]                       }
[17:45:44.328]                     }
[17:45:44.328]                     invisible(muffled)
[17:45:44.328]                   }
[17:45:44.328]                   muffleCondition(cond)
[17:45:44.328]                 })
[17:45:44.328]             }))
[17:45:44.328]             future::FutureResult(value = ...future.value$value, 
[17:45:44.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:44.328]                   ...future.rng), globalenv = if (FALSE) 
[17:45:44.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:44.328]                     ...future.globalenv.names))
[17:45:44.328]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:44.328]         }, condition = base::local({
[17:45:44.328]             c <- base::c
[17:45:44.328]             inherits <- base::inherits
[17:45:44.328]             invokeRestart <- base::invokeRestart
[17:45:44.328]             length <- base::length
[17:45:44.328]             list <- base::list
[17:45:44.328]             seq.int <- base::seq.int
[17:45:44.328]             signalCondition <- base::signalCondition
[17:45:44.328]             sys.calls <- base::sys.calls
[17:45:44.328]             `[[` <- base::`[[`
[17:45:44.328]             `+` <- base::`+`
[17:45:44.328]             `<<-` <- base::`<<-`
[17:45:44.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:44.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:44.328]                   3L)]
[17:45:44.328]             }
[17:45:44.328]             function(cond) {
[17:45:44.328]                 is_error <- inherits(cond, "error")
[17:45:44.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:44.328]                   NULL)
[17:45:44.328]                 if (is_error) {
[17:45:44.328]                   sessionInformation <- function() {
[17:45:44.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:44.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:44.328]                       search = base::search(), system = base::Sys.info())
[17:45:44.328]                   }
[17:45:44.328]                   ...future.conditions[[length(...future.conditions) + 
[17:45:44.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:44.328]                     cond$call), session = sessionInformation(), 
[17:45:44.328]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:44.328]                   signalCondition(cond)
[17:45:44.328]                 }
[17:45:44.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:44.328]                 "immediateCondition"))) {
[17:45:44.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:44.328]                   ...future.conditions[[length(...future.conditions) + 
[17:45:44.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:44.328]                   if (TRUE && !signal) {
[17:45:44.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:44.328]                     {
[17:45:44.328]                       inherits <- base::inherits
[17:45:44.328]                       invokeRestart <- base::invokeRestart
[17:45:44.328]                       is.null <- base::is.null
[17:45:44.328]                       muffled <- FALSE
[17:45:44.328]                       if (inherits(cond, "message")) {
[17:45:44.328]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:44.328]                         if (muffled) 
[17:45:44.328]                           invokeRestart("muffleMessage")
[17:45:44.328]                       }
[17:45:44.328]                       else if (inherits(cond, "warning")) {
[17:45:44.328]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:44.328]                         if (muffled) 
[17:45:44.328]                           invokeRestart("muffleWarning")
[17:45:44.328]                       }
[17:45:44.328]                       else if (inherits(cond, "condition")) {
[17:45:44.328]                         if (!is.null(pattern)) {
[17:45:44.328]                           computeRestarts <- base::computeRestarts
[17:45:44.328]                           grepl <- base::grepl
[17:45:44.328]                           restarts <- computeRestarts(cond)
[17:45:44.328]                           for (restart in restarts) {
[17:45:44.328]                             name <- restart$name
[17:45:44.328]                             if (is.null(name)) 
[17:45:44.328]                               next
[17:45:44.328]                             if (!grepl(pattern, name)) 
[17:45:44.328]                               next
[17:45:44.328]                             invokeRestart(restart)
[17:45:44.328]                             muffled <- TRUE
[17:45:44.328]                             break
[17:45:44.328]                           }
[17:45:44.328]                         }
[17:45:44.328]                       }
[17:45:44.328]                       invisible(muffled)
[17:45:44.328]                     }
[17:45:44.328]                     muffleCondition(cond, pattern = "^muffle")
[17:45:44.328]                   }
[17:45:44.328]                 }
[17:45:44.328]                 else {
[17:45:44.328]                   if (TRUE) {
[17:45:44.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:44.328]                     {
[17:45:44.328]                       inherits <- base::inherits
[17:45:44.328]                       invokeRestart <- base::invokeRestart
[17:45:44.328]                       is.null <- base::is.null
[17:45:44.328]                       muffled <- FALSE
[17:45:44.328]                       if (inherits(cond, "message")) {
[17:45:44.328]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:44.328]                         if (muffled) 
[17:45:44.328]                           invokeRestart("muffleMessage")
[17:45:44.328]                       }
[17:45:44.328]                       else if (inherits(cond, "warning")) {
[17:45:44.328]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:44.328]                         if (muffled) 
[17:45:44.328]                           invokeRestart("muffleWarning")
[17:45:44.328]                       }
[17:45:44.328]                       else if (inherits(cond, "condition")) {
[17:45:44.328]                         if (!is.null(pattern)) {
[17:45:44.328]                           computeRestarts <- base::computeRestarts
[17:45:44.328]                           grepl <- base::grepl
[17:45:44.328]                           restarts <- computeRestarts(cond)
[17:45:44.328]                           for (restart in restarts) {
[17:45:44.328]                             name <- restart$name
[17:45:44.328]                             if (is.null(name)) 
[17:45:44.328]                               next
[17:45:44.328]                             if (!grepl(pattern, name)) 
[17:45:44.328]                               next
[17:45:44.328]                             invokeRestart(restart)
[17:45:44.328]                             muffled <- TRUE
[17:45:44.328]                             break
[17:45:44.328]                           }
[17:45:44.328]                         }
[17:45:44.328]                       }
[17:45:44.328]                       invisible(muffled)
[17:45:44.328]                     }
[17:45:44.328]                     muffleCondition(cond, pattern = "^muffle")
[17:45:44.328]                   }
[17:45:44.328]                 }
[17:45:44.328]             }
[17:45:44.328]         }))
[17:45:44.328]     }, error = function(ex) {
[17:45:44.328]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:44.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:44.328]                 ...future.rng), started = ...future.startTime, 
[17:45:44.328]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:44.328]             version = "1.8"), class = "FutureResult")
[17:45:44.328]     }, finally = {
[17:45:44.328]         if (!identical(...future.workdir, getwd())) 
[17:45:44.328]             setwd(...future.workdir)
[17:45:44.328]         {
[17:45:44.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:44.328]                 ...future.oldOptions$nwarnings <- NULL
[17:45:44.328]             }
[17:45:44.328]             base::options(...future.oldOptions)
[17:45:44.328]             if (.Platform$OS.type == "windows") {
[17:45:44.328]                 old_names <- names(...future.oldEnvVars)
[17:45:44.328]                 envs <- base::Sys.getenv()
[17:45:44.328]                 names <- names(envs)
[17:45:44.328]                 common <- intersect(names, old_names)
[17:45:44.328]                 added <- setdiff(names, old_names)
[17:45:44.328]                 removed <- setdiff(old_names, names)
[17:45:44.328]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:44.328]                   envs[common]]
[17:45:44.328]                 NAMES <- toupper(changed)
[17:45:44.328]                 args <- list()
[17:45:44.328]                 for (kk in seq_along(NAMES)) {
[17:45:44.328]                   name <- changed[[kk]]
[17:45:44.328]                   NAME <- NAMES[[kk]]
[17:45:44.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:44.328]                     next
[17:45:44.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:44.328]                 }
[17:45:44.328]                 NAMES <- toupper(added)
[17:45:44.328]                 for (kk in seq_along(NAMES)) {
[17:45:44.328]                   name <- added[[kk]]
[17:45:44.328]                   NAME <- NAMES[[kk]]
[17:45:44.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:44.328]                     next
[17:45:44.328]                   args[[name]] <- ""
[17:45:44.328]                 }
[17:45:44.328]                 NAMES <- toupper(removed)
[17:45:44.328]                 for (kk in seq_along(NAMES)) {
[17:45:44.328]                   name <- removed[[kk]]
[17:45:44.328]                   NAME <- NAMES[[kk]]
[17:45:44.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:44.328]                     next
[17:45:44.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:44.328]                 }
[17:45:44.328]                 if (length(args) > 0) 
[17:45:44.328]                   base::do.call(base::Sys.setenv, args = args)
[17:45:44.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:44.328]             }
[17:45:44.328]             else {
[17:45:44.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:44.328]             }
[17:45:44.328]             {
[17:45:44.328]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:44.328]                   0L) {
[17:45:44.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:44.328]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:44.328]                   base::options(opts)
[17:45:44.328]                 }
[17:45:44.328]                 {
[17:45:44.328]                   {
[17:45:44.328]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:44.328]                     NULL
[17:45:44.328]                   }
[17:45:44.328]                   options(future.plan = NULL)
[17:45:44.328]                   if (is.na(NA_character_)) 
[17:45:44.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:44.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:44.328]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:44.328]                     .init = FALSE)
[17:45:44.328]                 }
[17:45:44.328]             }
[17:45:44.328]         }
[17:45:44.328]     })
[17:45:44.328]     if (FALSE) {
[17:45:44.328]         base::sink(type = "output", split = FALSE)
[17:45:44.328]         if (NA) {
[17:45:44.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:44.328]         }
[17:45:44.328]         else {
[17:45:44.328]             ...future.result["stdout"] <- base::list(NULL)
[17:45:44.328]         }
[17:45:44.328]         base::close(...future.stdout)
[17:45:44.328]         ...future.stdout <- NULL
[17:45:44.328]     }
[17:45:44.328]     ...future.result$conditions <- ...future.conditions
[17:45:44.328]     ...future.result$finished <- base::Sys.time()
[17:45:44.328]     ...future.result
[17:45:44.328] }
[17:45:44.330] assign_globals() ...
[17:45:44.330] List of 5
[17:45:44.330]  $ ...future.FUN            :function (x, y)  
[17:45:44.330]  $ MoreArgs                 : NULL
[17:45:44.330]  $ ...future.elements_ii    :List of 2
[17:45:44.330]   ..$ :List of 1
[17:45:44.330]   .. ..$ : int 1
[17:45:44.330]   ..$ :List of 1
[17:45:44.330]   .. ..$ : int 0
[17:45:44.330]  $ ...future.seeds_ii       : NULL
[17:45:44.330]  $ ...future.globals.maxSize: NULL
[17:45:44.330]  - attr(*, "where")=List of 5
[17:45:44.330]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:44.330]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:44.330]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:44.330]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:44.330]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:44.330]  - attr(*, "resolved")= logi FALSE
[17:45:44.330]  - attr(*, "total_size")= num 6368
[17:45:44.330]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:44.330]  - attr(*, "already-done")= logi TRUE
[17:45:44.335] - reassign environment for ‘...future.FUN’
[17:45:44.335] - copied ‘...future.FUN’ to environment
[17:45:44.335] - copied ‘MoreArgs’ to environment
[17:45:44.336] - copied ‘...future.elements_ii’ to environment
[17:45:44.336] - copied ‘...future.seeds_ii’ to environment
[17:45:44.336] - copied ‘...future.globals.maxSize’ to environment
[17:45:44.336] assign_globals() ... done
[17:45:44.336] requestCore(): workers = 2
[17:45:44.338] MulticoreFuture started
[17:45:44.338] - Launch lazy future ... done
[17:45:44.338] run() for ‘MulticoreFuture’ ... done
[17:45:44.339] Created future:
[17:45:44.339] plan(): Setting new future strategy stack:
[17:45:44.339] List of future strategies:
[17:45:44.339] 1. sequential:
[17:45:44.339]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:44.339]    - tweaked: FALSE
[17:45:44.339]    - call: NULL
[17:45:44.340] plan(): nbrOfWorkers() = 1
[17:45:44.339] MulticoreFuture:
[17:45:44.339] Label: ‘future_mapply-1’
[17:45:44.339] Expression:
[17:45:44.339] {
[17:45:44.339]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:44.339]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:44.339]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:44.339]         on.exit(options(oopts), add = TRUE)
[17:45:44.339]     }
[17:45:44.339]     {
[17:45:44.339]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:44.339]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:44.339]         do.call(mapply, args = args)
[17:45:44.339]     }
[17:45:44.339] }
[17:45:44.339] Lazy evaluation: FALSE
[17:45:44.339] Asynchronous evaluation: TRUE
[17:45:44.339] Local evaluation: TRUE
[17:45:44.339] Environment: R_GlobalEnv
[17:45:44.339] Capture standard output: NA
[17:45:44.339] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:44.339] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:44.339] Packages: <none>
[17:45:44.339] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:44.339] Resolved: FALSE
[17:45:44.339] Value: <not collected>
[17:45:44.339] Conditions captured: <none>
[17:45:44.339] Early signaling: FALSE
[17:45:44.339] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:44.339] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:44.352] Chunk #1 of 2 ... DONE
[17:45:44.352] Chunk #2 of 2 ...
[17:45:44.352]  - Finding globals in '...' for chunk #2 ...
[17:45:44.352] getGlobalsAndPackages() ...
[17:45:44.352] Searching for globals...
[17:45:44.353] 
[17:45:44.353] Searching for globals ... DONE
[17:45:44.353] - globals: [0] <none>
[17:45:44.353] getGlobalsAndPackages() ... DONE
[17:45:44.354]    + additional globals found: [n=0] 
[17:45:44.354]    + additional namespaces needed: [n=0] 
[17:45:44.354]  - Finding globals in '...' for chunk #2 ... DONE
[17:45:44.354]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:44.354]  - seeds: <none>
[17:45:44.354]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:44.355] getGlobalsAndPackages() ...
[17:45:44.355] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:44.355] Resolving globals: FALSE
[17:45:44.356] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:45:44.357] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:44.357] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:44.357] 
[17:45:44.357] getGlobalsAndPackages() ... DONE
[17:45:44.358] run() for ‘Future’ ...
[17:45:44.358] - state: ‘created’
[17:45:44.358] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:44.363] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:44.364] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:44.364]   - Field: ‘label’
[17:45:44.364]   - Field: ‘local’
[17:45:44.364]   - Field: ‘owner’
[17:45:44.364]   - Field: ‘envir’
[17:45:44.364]   - Field: ‘workers’
[17:45:44.365]   - Field: ‘packages’
[17:45:44.365]   - Field: ‘gc’
[17:45:44.365]   - Field: ‘job’
[17:45:44.365]   - Field: ‘conditions’
[17:45:44.365]   - Field: ‘expr’
[17:45:44.365]   - Field: ‘uuid’
[17:45:44.365]   - Field: ‘seed’
[17:45:44.366]   - Field: ‘version’
[17:45:44.366]   - Field: ‘result’
[17:45:44.366]   - Field: ‘asynchronous’
[17:45:44.366]   - Field: ‘calls’
[17:45:44.366]   - Field: ‘globals’
[17:45:44.366]   - Field: ‘stdout’
[17:45:44.366]   - Field: ‘earlySignal’
[17:45:44.367]   - Field: ‘lazy’
[17:45:44.367]   - Field: ‘state’
[17:45:44.367] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:44.367] - Launch lazy future ...
[17:45:44.368] Packages needed by the future expression (n = 0): <none>
[17:45:44.368] Packages needed by future strategies (n = 0): <none>
[17:45:44.368] {
[17:45:44.368]     {
[17:45:44.368]         {
[17:45:44.368]             ...future.startTime <- base::Sys.time()
[17:45:44.368]             {
[17:45:44.368]                 {
[17:45:44.368]                   {
[17:45:44.368]                     {
[17:45:44.368]                       base::local({
[17:45:44.368]                         has_future <- base::requireNamespace("future", 
[17:45:44.368]                           quietly = TRUE)
[17:45:44.368]                         if (has_future) {
[17:45:44.368]                           ns <- base::getNamespace("future")
[17:45:44.368]                           version <- ns[[".package"]][["version"]]
[17:45:44.368]                           if (is.null(version)) 
[17:45:44.368]                             version <- utils::packageVersion("future")
[17:45:44.368]                         }
[17:45:44.368]                         else {
[17:45:44.368]                           version <- NULL
[17:45:44.368]                         }
[17:45:44.368]                         if (!has_future || version < "1.8.0") {
[17:45:44.368]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:44.368]                             "", base::R.version$version.string), 
[17:45:44.368]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:44.368]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:44.368]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:44.368]                               "release", "version")], collapse = " "), 
[17:45:44.368]                             hostname = base::Sys.info()[["nodename"]])
[17:45:44.368]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:44.368]                             info)
[17:45:44.368]                           info <- base::paste(info, collapse = "; ")
[17:45:44.368]                           if (!has_future) {
[17:45:44.368]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:44.368]                               info)
[17:45:44.368]                           }
[17:45:44.368]                           else {
[17:45:44.368]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:44.368]                               info, version)
[17:45:44.368]                           }
[17:45:44.368]                           base::stop(msg)
[17:45:44.368]                         }
[17:45:44.368]                       })
[17:45:44.368]                     }
[17:45:44.368]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:44.368]                     base::options(mc.cores = 1L)
[17:45:44.368]                   }
[17:45:44.368]                   ...future.strategy.old <- future::plan("list")
[17:45:44.368]                   options(future.plan = NULL)
[17:45:44.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:44.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:44.368]                 }
[17:45:44.368]                 ...future.workdir <- getwd()
[17:45:44.368]             }
[17:45:44.368]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:44.368]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:44.368]         }
[17:45:44.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:44.368]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:44.368]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:44.368]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:44.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:44.368]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:44.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:44.368]             base::names(...future.oldOptions))
[17:45:44.368]     }
[17:45:44.368]     if (TRUE) {
[17:45:44.368]     }
[17:45:44.368]     else {
[17:45:44.368]         if (NA) {
[17:45:44.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:44.368]                 open = "w")
[17:45:44.368]         }
[17:45:44.368]         else {
[17:45:44.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:44.368]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:44.368]         }
[17:45:44.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:44.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:44.368]             base::sink(type = "output", split = FALSE)
[17:45:44.368]             base::close(...future.stdout)
[17:45:44.368]         }, add = TRUE)
[17:45:44.368]     }
[17:45:44.368]     ...future.frame <- base::sys.nframe()
[17:45:44.368]     ...future.conditions <- base::list()
[17:45:44.368]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:44.368]     if (FALSE) {
[17:45:44.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:44.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:44.368]     }
[17:45:44.368]     ...future.result <- base::tryCatch({
[17:45:44.368]         base::withCallingHandlers({
[17:45:44.368]             ...future.value <- base::withVisible(base::local({
[17:45:44.368]                 withCallingHandlers({
[17:45:44.368]                   {
[17:45:44.368]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:44.368]                     if (!identical(...future.globals.maxSize.org, 
[17:45:44.368]                       ...future.globals.maxSize)) {
[17:45:44.368]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:44.368]                       on.exit(options(oopts), add = TRUE)
[17:45:44.368]                     }
[17:45:44.368]                     {
[17:45:44.368]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:44.368]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:44.368]                         USE.NAMES = FALSE)
[17:45:44.368]                       do.call(mapply, args = args)
[17:45:44.368]                     }
[17:45:44.368]                   }
[17:45:44.368]                 }, immediateCondition = function(cond) {
[17:45:44.368]                   save_rds <- function (object, pathname, ...) 
[17:45:44.368]                   {
[17:45:44.368]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:44.368]                     if (file_test("-f", pathname_tmp)) {
[17:45:44.368]                       fi_tmp <- file.info(pathname_tmp)
[17:45:44.368]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:44.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:44.368]                         fi_tmp[["mtime"]])
[17:45:44.368]                     }
[17:45:44.368]                     tryCatch({
[17:45:44.368]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:44.368]                     }, error = function(ex) {
[17:45:44.368]                       msg <- conditionMessage(ex)
[17:45:44.368]                       fi_tmp <- file.info(pathname_tmp)
[17:45:44.368]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:44.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:44.368]                         fi_tmp[["mtime"]], msg)
[17:45:44.368]                       ex$message <- msg
[17:45:44.368]                       stop(ex)
[17:45:44.368]                     })
[17:45:44.368]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:44.368]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:44.368]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:44.368]                       fi_tmp <- file.info(pathname_tmp)
[17:45:44.368]                       fi <- file.info(pathname)
[17:45:44.368]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:44.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:44.368]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:44.368]                         fi[["size"]], fi[["mtime"]])
[17:45:44.368]                       stop(msg)
[17:45:44.368]                     }
[17:45:44.368]                     invisible(pathname)
[17:45:44.368]                   }
[17:45:44.368]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:44.368]                     rootPath = tempdir()) 
[17:45:44.368]                   {
[17:45:44.368]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:44.368]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:44.368]                       tmpdir = path, fileext = ".rds")
[17:45:44.368]                     save_rds(obj, file)
[17:45:44.368]                   }
[17:45:44.368]                   saveImmediateCondition(cond, path = "/tmp/RtmpnHaLG7/.future/immediateConditions")
[17:45:44.368]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:44.368]                   {
[17:45:44.368]                     inherits <- base::inherits
[17:45:44.368]                     invokeRestart <- base::invokeRestart
[17:45:44.368]                     is.null <- base::is.null
[17:45:44.368]                     muffled <- FALSE
[17:45:44.368]                     if (inherits(cond, "message")) {
[17:45:44.368]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:44.368]                       if (muffled) 
[17:45:44.368]                         invokeRestart("muffleMessage")
[17:45:44.368]                     }
[17:45:44.368]                     else if (inherits(cond, "warning")) {
[17:45:44.368]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:44.368]                       if (muffled) 
[17:45:44.368]                         invokeRestart("muffleWarning")
[17:45:44.368]                     }
[17:45:44.368]                     else if (inherits(cond, "condition")) {
[17:45:44.368]                       if (!is.null(pattern)) {
[17:45:44.368]                         computeRestarts <- base::computeRestarts
[17:45:44.368]                         grepl <- base::grepl
[17:45:44.368]                         restarts <- computeRestarts(cond)
[17:45:44.368]                         for (restart in restarts) {
[17:45:44.368]                           name <- restart$name
[17:45:44.368]                           if (is.null(name)) 
[17:45:44.368]                             next
[17:45:44.368]                           if (!grepl(pattern, name)) 
[17:45:44.368]                             next
[17:45:44.368]                           invokeRestart(restart)
[17:45:44.368]                           muffled <- TRUE
[17:45:44.368]                           break
[17:45:44.368]                         }
[17:45:44.368]                       }
[17:45:44.368]                     }
[17:45:44.368]                     invisible(muffled)
[17:45:44.368]                   }
[17:45:44.368]                   muffleCondition(cond)
[17:45:44.368]                 })
[17:45:44.368]             }))
[17:45:44.368]             future::FutureResult(value = ...future.value$value, 
[17:45:44.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:44.368]                   ...future.rng), globalenv = if (FALSE) 
[17:45:44.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:44.368]                     ...future.globalenv.names))
[17:45:44.368]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:44.368]         }, condition = base::local({
[17:45:44.368]             c <- base::c
[17:45:44.368]             inherits <- base::inherits
[17:45:44.368]             invokeRestart <- base::invokeRestart
[17:45:44.368]             length <- base::length
[17:45:44.368]             list <- base::list
[17:45:44.368]             seq.int <- base::seq.int
[17:45:44.368]             signalCondition <- base::signalCondition
[17:45:44.368]             sys.calls <- base::sys.calls
[17:45:44.368]             `[[` <- base::`[[`
[17:45:44.368]             `+` <- base::`+`
[17:45:44.368]             `<<-` <- base::`<<-`
[17:45:44.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:44.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:44.368]                   3L)]
[17:45:44.368]             }
[17:45:44.368]             function(cond) {
[17:45:44.368]                 is_error <- inherits(cond, "error")
[17:45:44.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:44.368]                   NULL)
[17:45:44.368]                 if (is_error) {
[17:45:44.368]                   sessionInformation <- function() {
[17:45:44.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:44.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:44.368]                       search = base::search(), system = base::Sys.info())
[17:45:44.368]                   }
[17:45:44.368]                   ...future.conditions[[length(...future.conditions) + 
[17:45:44.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:44.368]                     cond$call), session = sessionInformation(), 
[17:45:44.368]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:44.368]                   signalCondition(cond)
[17:45:44.368]                 }
[17:45:44.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:44.368]                 "immediateCondition"))) {
[17:45:44.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:44.368]                   ...future.conditions[[length(...future.conditions) + 
[17:45:44.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:44.368]                   if (TRUE && !signal) {
[17:45:44.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:44.368]                     {
[17:45:44.368]                       inherits <- base::inherits
[17:45:44.368]                       invokeRestart <- base::invokeRestart
[17:45:44.368]                       is.null <- base::is.null
[17:45:44.368]                       muffled <- FALSE
[17:45:44.368]                       if (inherits(cond, "message")) {
[17:45:44.368]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:44.368]                         if (muffled) 
[17:45:44.368]                           invokeRestart("muffleMessage")
[17:45:44.368]                       }
[17:45:44.368]                       else if (inherits(cond, "warning")) {
[17:45:44.368]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:44.368]                         if (muffled) 
[17:45:44.368]                           invokeRestart("muffleWarning")
[17:45:44.368]                       }
[17:45:44.368]                       else if (inherits(cond, "condition")) {
[17:45:44.368]                         if (!is.null(pattern)) {
[17:45:44.368]                           computeRestarts <- base::computeRestarts
[17:45:44.368]                           grepl <- base::grepl
[17:45:44.368]                           restarts <- computeRestarts(cond)
[17:45:44.368]                           for (restart in restarts) {
[17:45:44.368]                             name <- restart$name
[17:45:44.368]                             if (is.null(name)) 
[17:45:44.368]                               next
[17:45:44.368]                             if (!grepl(pattern, name)) 
[17:45:44.368]                               next
[17:45:44.368]                             invokeRestart(restart)
[17:45:44.368]                             muffled <- TRUE
[17:45:44.368]                             break
[17:45:44.368]                           }
[17:45:44.368]                         }
[17:45:44.368]                       }
[17:45:44.368]                       invisible(muffled)
[17:45:44.368]                     }
[17:45:44.368]                     muffleCondition(cond, pattern = "^muffle")
[17:45:44.368]                   }
[17:45:44.368]                 }
[17:45:44.368]                 else {
[17:45:44.368]                   if (TRUE) {
[17:45:44.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:44.368]                     {
[17:45:44.368]                       inherits <- base::inherits
[17:45:44.368]                       invokeRestart <- base::invokeRestart
[17:45:44.368]                       is.null <- base::is.null
[17:45:44.368]                       muffled <- FALSE
[17:45:44.368]                       if (inherits(cond, "message")) {
[17:45:44.368]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:44.368]                         if (muffled) 
[17:45:44.368]                           invokeRestart("muffleMessage")
[17:45:44.368]                       }
[17:45:44.368]                       else if (inherits(cond, "warning")) {
[17:45:44.368]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:44.368]                         if (muffled) 
[17:45:44.368]                           invokeRestart("muffleWarning")
[17:45:44.368]                       }
[17:45:44.368]                       else if (inherits(cond, "condition")) {
[17:45:44.368]                         if (!is.null(pattern)) {
[17:45:44.368]                           computeRestarts <- base::computeRestarts
[17:45:44.368]                           grepl <- base::grepl
[17:45:44.368]                           restarts <- computeRestarts(cond)
[17:45:44.368]                           for (restart in restarts) {
[17:45:44.368]                             name <- restart$name
[17:45:44.368]                             if (is.null(name)) 
[17:45:44.368]                               next
[17:45:44.368]                             if (!grepl(pattern, name)) 
[17:45:44.368]                               next
[17:45:44.368]                             invokeRestart(restart)
[17:45:44.368]                             muffled <- TRUE
[17:45:44.368]                             break
[17:45:44.368]                           }
[17:45:44.368]                         }
[17:45:44.368]                       }
[17:45:44.368]                       invisible(muffled)
[17:45:44.368]                     }
[17:45:44.368]                     muffleCondition(cond, pattern = "^muffle")
[17:45:44.368]                   }
[17:45:44.368]                 }
[17:45:44.368]             }
[17:45:44.368]         }))
[17:45:44.368]     }, error = function(ex) {
[17:45:44.368]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:44.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:44.368]                 ...future.rng), started = ...future.startTime, 
[17:45:44.368]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:44.368]             version = "1.8"), class = "FutureResult")
[17:45:44.368]     }, finally = {
[17:45:44.368]         if (!identical(...future.workdir, getwd())) 
[17:45:44.368]             setwd(...future.workdir)
[17:45:44.368]         {
[17:45:44.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:44.368]                 ...future.oldOptions$nwarnings <- NULL
[17:45:44.368]             }
[17:45:44.368]             base::options(...future.oldOptions)
[17:45:44.368]             if (.Platform$OS.type == "windows") {
[17:45:44.368]                 old_names <- names(...future.oldEnvVars)
[17:45:44.368]                 envs <- base::Sys.getenv()
[17:45:44.368]                 names <- names(envs)
[17:45:44.368]                 common <- intersect(names, old_names)
[17:45:44.368]                 added <- setdiff(names, old_names)
[17:45:44.368]                 removed <- setdiff(old_names, names)
[17:45:44.368]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:44.368]                   envs[common]]
[17:45:44.368]                 NAMES <- toupper(changed)
[17:45:44.368]                 args <- list()
[17:45:44.368]                 for (kk in seq_along(NAMES)) {
[17:45:44.368]                   name <- changed[[kk]]
[17:45:44.368]                   NAME <- NAMES[[kk]]
[17:45:44.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:44.368]                     next
[17:45:44.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:44.368]                 }
[17:45:44.368]                 NAMES <- toupper(added)
[17:45:44.368]                 for (kk in seq_along(NAMES)) {
[17:45:44.368]                   name <- added[[kk]]
[17:45:44.368]                   NAME <- NAMES[[kk]]
[17:45:44.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:44.368]                     next
[17:45:44.368]                   args[[name]] <- ""
[17:45:44.368]                 }
[17:45:44.368]                 NAMES <- toupper(removed)
[17:45:44.368]                 for (kk in seq_along(NAMES)) {
[17:45:44.368]                   name <- removed[[kk]]
[17:45:44.368]                   NAME <- NAMES[[kk]]
[17:45:44.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:44.368]                     next
[17:45:44.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:44.368]                 }
[17:45:44.368]                 if (length(args) > 0) 
[17:45:44.368]                   base::do.call(base::Sys.setenv, args = args)
[17:45:44.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:44.368]             }
[17:45:44.368]             else {
[17:45:44.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:44.368]             }
[17:45:44.368]             {
[17:45:44.368]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:44.368]                   0L) {
[17:45:44.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:44.368]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:44.368]                   base::options(opts)
[17:45:44.368]                 }
[17:45:44.368]                 {
[17:45:44.368]                   {
[17:45:44.368]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:44.368]                     NULL
[17:45:44.368]                   }
[17:45:44.368]                   options(future.plan = NULL)
[17:45:44.368]                   if (is.na(NA_character_)) 
[17:45:44.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:44.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:44.368]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:44.368]                     .init = FALSE)
[17:45:44.368]                 }
[17:45:44.368]             }
[17:45:44.368]         }
[17:45:44.368]     })
[17:45:44.368]     if (FALSE) {
[17:45:44.368]         base::sink(type = "output", split = FALSE)
[17:45:44.368]         if (NA) {
[17:45:44.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:44.368]         }
[17:45:44.368]         else {
[17:45:44.368]             ...future.result["stdout"] <- base::list(NULL)
[17:45:44.368]         }
[17:45:44.368]         base::close(...future.stdout)
[17:45:44.368]         ...future.stdout <- NULL
[17:45:44.368]     }
[17:45:44.368]     ...future.result$conditions <- ...future.conditions
[17:45:44.368]     ...future.result$finished <- base::Sys.time()
[17:45:44.368]     ...future.result
[17:45:44.368] }
[17:45:44.372] assign_globals() ...
[17:45:44.372] List of 5
[17:45:44.372]  $ ...future.FUN            :function (x, y)  
[17:45:44.372]  $ MoreArgs                 : NULL
[17:45:44.372]  $ ...future.elements_ii    :List of 2
[17:45:44.372]   ..$ :List of 1
[17:45:44.372]   .. ..$ : int 0
[17:45:44.372]   ..$ :List of 1
[17:45:44.372]   .. ..$ : int 1
[17:45:44.372]  $ ...future.seeds_ii       : NULL
[17:45:44.372]  $ ...future.globals.maxSize: NULL
[17:45:44.372]  - attr(*, "where")=List of 5
[17:45:44.372]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:44.372]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:45:44.372]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:44.372]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:44.372]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:44.372]  - attr(*, "resolved")= logi FALSE
[17:45:44.372]  - attr(*, "total_size")= num 6368
[17:45:44.372]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:44.372]  - attr(*, "already-done")= logi TRUE
[17:45:44.389] - reassign environment for ‘...future.FUN’
[17:45:44.389] - copied ‘...future.FUN’ to environment
[17:45:44.389] - copied ‘MoreArgs’ to environment
[17:45:44.389] - copied ‘...future.elements_ii’ to environment
[17:45:44.389] - copied ‘...future.seeds_ii’ to environment
[17:45:44.389] - copied ‘...future.globals.maxSize’ to environment
[17:45:44.390] assign_globals() ... done
[17:45:44.390] requestCore(): workers = 2
[17:45:44.392] MulticoreFuture started
[17:45:44.392] - Launch lazy future ... done
[17:45:44.393] run() for ‘MulticoreFuture’ ... done
[17:45:44.393] Created future:
[17:45:44.393] plan(): Setting new future strategy stack:
[17:45:44.394] List of future strategies:
[17:45:44.394] 1. sequential:
[17:45:44.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:44.394]    - tweaked: FALSE
[17:45:44.394]    - call: NULL
[17:45:44.395] plan(): nbrOfWorkers() = 1
[17:45:44.397] plan(): Setting new future strategy stack:
[17:45:44.397] List of future strategies:
[17:45:44.397] 1. multicore:
[17:45:44.397]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:44.397]    - tweaked: FALSE
[17:45:44.397]    - call: plan(strategy)
[17:45:44.403] plan(): nbrOfWorkers() = 2
[17:45:44.393] MulticoreFuture:
[17:45:44.393] Label: ‘future_mapply-2’
[17:45:44.393] Expression:
[17:45:44.393] {
[17:45:44.393]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:44.393]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:44.393]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:44.393]         on.exit(options(oopts), add = TRUE)
[17:45:44.393]     }
[17:45:44.393]     {
[17:45:44.393]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:44.393]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:44.393]         do.call(mapply, args = args)
[17:45:44.393]     }
[17:45:44.393] }
[17:45:44.393] Lazy evaluation: FALSE
[17:45:44.393] Asynchronous evaluation: TRUE
[17:45:44.393] Local evaluation: TRUE
[17:45:44.393] Environment: R_GlobalEnv
[17:45:44.393] Capture standard output: NA
[17:45:44.393] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:44.393] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:44.393] Packages: <none>
[17:45:44.393] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:44.393] Resolved: TRUE
[17:45:44.393] Value: <not collected>
[17:45:44.393] Conditions captured: <none>
[17:45:44.393] Early signaling: FALSE
[17:45:44.393] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:44.393] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:44.404] Chunk #2 of 2 ... DONE
[17:45:44.404] Launching 2 futures (chunks) ... DONE
[17:45:44.404] Resolving 2 futures (chunks) ...
[17:45:44.404] resolve() on list ...
[17:45:44.405]  recursive: 0
[17:45:44.405]  length: 2
[17:45:44.405] 
[17:45:44.416] Future #2
[17:45:44.416] result() for MulticoreFuture ...
[17:45:44.417] result() for MulticoreFuture ...
[17:45:44.417] result() for MulticoreFuture ... done
[17:45:44.417] result() for MulticoreFuture ... done
[17:45:44.417] result() for MulticoreFuture ...
[17:45:44.417] result() for MulticoreFuture ... done
[17:45:44.418] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:44.418] - nx: 2
[17:45:44.418] - relay: TRUE
[17:45:44.418] - stdout: TRUE
[17:45:44.418] - signal: TRUE
[17:45:44.418] - resignal: FALSE
[17:45:44.418] - force: TRUE
[17:45:44.419] - relayed: [n=2] FALSE, FALSE
[17:45:44.419] - queued futures: [n=2] FALSE, FALSE
[17:45:44.419]  - until=1
[17:45:44.419]  - relaying element #1
[17:45:44.419] - relayed: [n=2] FALSE, FALSE
[17:45:44.419] - queued futures: [n=2] FALSE, TRUE
[17:45:44.419] signalConditionsASAP(NULL, pos=2) ... done
[17:45:44.420]  length: 1 (resolved future 2)
[17:45:44.843] plan(): Setting new future strategy stack:
[17:45:44.843] List of future strategies:
[17:45:44.843] 1. multicore:
[17:45:44.843]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:44.843]    - tweaked: FALSE
[17:45:44.843]    - call: plan(strategy)
[17:45:44.848] plan(): nbrOfWorkers() = 2
[17:45:44.858] Future #1
[17:45:44.858] result() for MulticoreFuture ...
[17:45:44.859] result() for MulticoreFuture ...
[17:45:44.859] result() for MulticoreFuture ... done
[17:45:44.859] result() for MulticoreFuture ... done
[17:45:44.859] result() for MulticoreFuture ...
[17:45:44.859] result() for MulticoreFuture ... done
[17:45:44.860] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:44.860] - nx: 2
[17:45:44.860] - relay: TRUE
[17:45:44.860] - stdout: TRUE
[17:45:44.860] - signal: TRUE
[17:45:44.860] - resignal: FALSE
[17:45:44.860] - force: TRUE
[17:45:44.860] - relayed: [n=2] FALSE, FALSE
[17:45:44.860] - queued futures: [n=2] FALSE, TRUE
[17:45:44.861]  - until=1
[17:45:44.861]  - relaying element #1
[17:45:44.861] result() for MulticoreFuture ...
[17:45:44.861] result() for MulticoreFuture ... done
[17:45:44.861] result() for MulticoreFuture ...
[17:45:44.861] result() for MulticoreFuture ... done
[17:45:44.861] result() for MulticoreFuture ...
[17:45:44.861] result() for MulticoreFuture ... done
[17:45:44.862] result() for MulticoreFuture ...
[17:45:44.862] result() for MulticoreFuture ... done
[17:45:44.862] - relayed: [n=2] TRUE, FALSE
[17:45:44.862] - queued futures: [n=2] TRUE, TRUE
[17:45:44.862] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:44.862]  length: 0 (resolved future 1)
[17:45:44.862] Relaying remaining futures
[17:45:44.862] signalConditionsASAP(NULL, pos=0) ...
[17:45:44.862] - nx: 2
[17:45:44.863] - relay: TRUE
[17:45:44.863] - stdout: TRUE
[17:45:44.863] - signal: TRUE
[17:45:44.863] - resignal: FALSE
[17:45:44.863] - force: TRUE
[17:45:44.863] - relayed: [n=2] TRUE, FALSE
[17:45:44.863] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:44.863]  - relaying element #2
[17:45:44.863] result() for MulticoreFuture ...
[17:45:44.864] result() for MulticoreFuture ... done
[17:45:44.864] result() for MulticoreFuture ...
[17:45:44.864] result() for MulticoreFuture ... done
[17:45:44.864] result() for MulticoreFuture ...
[17:45:44.864] result() for MulticoreFuture ... done
[17:45:44.864] result() for MulticoreFuture ...
[17:45:44.864] result() for MulticoreFuture ... done
[17:45:44.864] - relayed: [n=2] TRUE, TRUE
[17:45:44.865] - queued futures: [n=2] TRUE, TRUE
[17:45:44.865] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[17:45:44.865] resolve() on list ... DONE
[17:45:44.865] result() for MulticoreFuture ...
[17:45:44.865] result() for MulticoreFuture ... done
[17:45:44.865] result() for MulticoreFuture ...
[17:45:44.865] result() for MulticoreFuture ... done
[17:45:44.865] result() for MulticoreFuture ...
[17:45:44.866] result() for MulticoreFuture ... done
[17:45:44.866] result() for MulticoreFuture ...
[17:45:44.866] result() for MulticoreFuture ... done
[17:45:44.866]  - Number of value chunks collected: 2
[17:45:44.866] Resolving 2 futures (chunks) ... DONE
[17:45:44.866] Reducing values from 2 chunks ...
[17:45:44.866]  - Number of values collected after concatenation: 2
[17:45:44.866]  - Number of values expected: 2
[17:45:44.867] Reducing values from 2 chunks ... DONE
[17:45:44.867] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[17:45:44.867] plan(): Setting new future strategy stack:
[17:45:44.868] List of future strategies:
[17:45:44.868] 1. multisession:
[17:45:44.868]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:45:44.868]    - tweaked: FALSE
[17:45:44.868]    - call: plan(strategy)
[17:45:44.868] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:45:44.868] multisession:
[17:45:44.868] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:45:44.868] - tweaked: FALSE
[17:45:44.868] - call: plan(strategy)
[17:45:44.874] getGlobalsAndPackages() ...
[17:45:44.874] Not searching for globals
[17:45:44.875] - globals: [0] <none>
[17:45:44.875] getGlobalsAndPackages() ... DONE
[17:45:44.875] [local output] makeClusterPSOCK() ...
[17:45:44.918] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:45:44.920] [local output] Base port: 11587
[17:45:44.920] [local output] Getting setup options for 2 cluster nodes ...
[17:45:44.920] [local output]  - Node 1 of 2 ...
[17:45:44.920] [local output] localMachine=TRUE => revtunnel=FALSE

[17:45:44.921] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpnHaLG7/worker.rank=1.parallelly.parent=37815.93b74bbc3646.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpnHaLG7/worker.rank=1.parallelly.parent=37815.93b74bbc3646.pid")'’
[17:45:45.109] - Possible to infer worker's PID: TRUE
[17:45:45.109] [local output] Rscript port: 11587

[17:45:45.109] [local output]  - Node 2 of 2 ...
[17:45:45.110] [local output] localMachine=TRUE => revtunnel=FALSE

[17:45:45.110] [local output] Rscript port: 11587

[17:45:45.110] [local output] Getting setup options for 2 cluster nodes ... done
[17:45:45.111] [local output]  - Parallel setup requested for some PSOCK nodes
[17:45:45.111] [local output] Setting up PSOCK nodes in parallel
[17:45:45.111] List of 36
[17:45:45.111]  $ worker          : chr "localhost"
[17:45:45.111]   ..- attr(*, "localhost")= logi TRUE
[17:45:45.111]  $ master          : chr "localhost"
[17:45:45.111]  $ port            : int 11587
[17:45:45.111]  $ connectTimeout  : num 120
[17:45:45.111]  $ timeout         : num 2592000
[17:45:45.111]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:45:45.111]  $ homogeneous     : logi TRUE
[17:45:45.111]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:45:45.111]  $ rscript_envs    : NULL
[17:45:45.111]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:45:45.111]  $ rscript_startup : NULL
[17:45:45.111]  $ rscript_sh      : chr "sh"
[17:45:45.111]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:45:45.111]  $ methods         : logi TRUE
[17:45:45.111]  $ socketOptions   : chr "no-delay"
[17:45:45.111]  $ useXDR          : logi FALSE
[17:45:45.111]  $ outfile         : chr "/dev/null"
[17:45:45.111]  $ renice          : int NA
[17:45:45.111]  $ rshcmd          : NULL
[17:45:45.111]  $ user            : chr(0) 
[17:45:45.111]  $ revtunnel       : logi FALSE
[17:45:45.111]  $ rshlogfile      : NULL
[17:45:45.111]  $ rshopts         : chr(0) 
[17:45:45.111]  $ rank            : int 1
[17:45:45.111]  $ manual          : logi FALSE
[17:45:45.111]  $ dryrun          : logi FALSE
[17:45:45.111]  $ quiet           : logi FALSE
[17:45:45.111]  $ setup_strategy  : chr "parallel"
[17:45:45.111]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:45:45.111]  $ pidfile         : chr "/tmp/RtmpnHaLG7/worker.rank=1.parallelly.parent=37815.93b74bbc3646.pid"
[17:45:45.111]  $ rshcmd_label    : NULL
[17:45:45.111]  $ rsh_call        : NULL
[17:45:45.111]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:45:45.111]  $ localMachine    : logi TRUE
[17:45:45.111]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:45:45.111]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:45:45.111]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:45:45.111]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:45:45.111]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:45:45.111]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:45:45.111]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:45:45.111]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:45:45.111]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:45:45.111]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:45:45.111]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:45:45.111]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:45:45.111]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:45:45.111]  $ arguments       :List of 28
[17:45:45.111]   ..$ worker          : chr "localhost"
[17:45:45.111]   ..$ master          : NULL
[17:45:45.111]   ..$ port            : int 11587
[17:45:45.111]   ..$ connectTimeout  : num 120
[17:45:45.111]   ..$ timeout         : num 2592000
[17:45:45.111]   ..$ rscript         : NULL
[17:45:45.111]   ..$ homogeneous     : NULL
[17:45:45.111]   ..$ rscript_args    : NULL
[17:45:45.111]   ..$ rscript_envs    : NULL
[17:45:45.111]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:45:45.111]   ..$ rscript_startup : NULL
[17:45:45.111]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:45:45.111]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:45:45.111]   ..$ methods         : logi TRUE
[17:45:45.111]   ..$ socketOptions   : chr "no-delay"
[17:45:45.111]   ..$ useXDR          : logi FALSE
[17:45:45.111]   ..$ outfile         : chr "/dev/null"
[17:45:45.111]   ..$ renice          : int NA
[17:45:45.111]   ..$ rshcmd          : NULL
[17:45:45.111]   ..$ user            : NULL
[17:45:45.111]   ..$ revtunnel       : logi NA
[17:45:45.111]   ..$ rshlogfile      : NULL
[17:45:45.111]   ..$ rshopts         : NULL
[17:45:45.111]   ..$ rank            : int 1
[17:45:45.111]   ..$ manual          : logi FALSE
[17:45:45.111]   ..$ dryrun          : logi FALSE
[17:45:45.111]   ..$ quiet           : logi FALSE
[17:45:45.111]   ..$ setup_strategy  : chr "parallel"
[17:45:45.111]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:45:45.128] [local output] System call to launch all workers:
[17:45:45.128] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpnHaLG7/worker.rank=1.parallelly.parent=37815.93b74bbc3646.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11587 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:45:45.128] [local output] Starting PSOCK main server
[17:45:45.133] [local output] Workers launched
[17:45:45.134] [local output] Waiting for workers to connect back
[17:45:45.134]  - [local output] 0 workers out of 2 ready
[17:45:45.373]  - [local output] 0 workers out of 2 ready
[17:45:45.374]  - [local output] 1 workers out of 2 ready
[17:45:45.374]  - [local output] 2 workers out of 2 ready
[17:45:45.374] [local output] Launching of workers completed
[17:45:45.374] [local output] Collecting session information from workers
[17:45:45.375] [local output]  - Worker #1 of 2
[17:45:45.376] [local output]  - Worker #2 of 2
[17:45:45.376] [local output] makeClusterPSOCK() ... done
[17:45:45.387] Packages needed by the future expression (n = 0): <none>
[17:45:45.387] Packages needed by future strategies (n = 0): <none>
[17:45:45.387] {
[17:45:45.387]     {
[17:45:45.387]         {
[17:45:45.387]             ...future.startTime <- base::Sys.time()
[17:45:45.387]             {
[17:45:45.387]                 {
[17:45:45.387]                   {
[17:45:45.387]                     {
[17:45:45.387]                       base::local({
[17:45:45.387]                         has_future <- base::requireNamespace("future", 
[17:45:45.387]                           quietly = TRUE)
[17:45:45.387]                         if (has_future) {
[17:45:45.387]                           ns <- base::getNamespace("future")
[17:45:45.387]                           version <- ns[[".package"]][["version"]]
[17:45:45.387]                           if (is.null(version)) 
[17:45:45.387]                             version <- utils::packageVersion("future")
[17:45:45.387]                         }
[17:45:45.387]                         else {
[17:45:45.387]                           version <- NULL
[17:45:45.387]                         }
[17:45:45.387]                         if (!has_future || version < "1.8.0") {
[17:45:45.387]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:45.387]                             "", base::R.version$version.string), 
[17:45:45.387]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:45.387]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:45.387]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:45.387]                               "release", "version")], collapse = " "), 
[17:45:45.387]                             hostname = base::Sys.info()[["nodename"]])
[17:45:45.387]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:45.387]                             info)
[17:45:45.387]                           info <- base::paste(info, collapse = "; ")
[17:45:45.387]                           if (!has_future) {
[17:45:45.387]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:45.387]                               info)
[17:45:45.387]                           }
[17:45:45.387]                           else {
[17:45:45.387]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:45.387]                               info, version)
[17:45:45.387]                           }
[17:45:45.387]                           base::stop(msg)
[17:45:45.387]                         }
[17:45:45.387]                       })
[17:45:45.387]                     }
[17:45:45.387]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:45.387]                     base::options(mc.cores = 1L)
[17:45:45.387]                   }
[17:45:45.387]                   ...future.strategy.old <- future::plan("list")
[17:45:45.387]                   options(future.plan = NULL)
[17:45:45.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:45.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:45.387]                 }
[17:45:45.387]                 ...future.workdir <- getwd()
[17:45:45.387]             }
[17:45:45.387]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:45.387]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:45.387]         }
[17:45:45.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:45.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:45.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:45.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:45.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:45.387]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:45.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:45.387]             base::names(...future.oldOptions))
[17:45:45.387]     }
[17:45:45.387]     if (FALSE) {
[17:45:45.387]     }
[17:45:45.387]     else {
[17:45:45.387]         if (TRUE) {
[17:45:45.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:45.387]                 open = "w")
[17:45:45.387]         }
[17:45:45.387]         else {
[17:45:45.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:45.387]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:45.387]         }
[17:45:45.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:45.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:45.387]             base::sink(type = "output", split = FALSE)
[17:45:45.387]             base::close(...future.stdout)
[17:45:45.387]         }, add = TRUE)
[17:45:45.387]     }
[17:45:45.387]     ...future.frame <- base::sys.nframe()
[17:45:45.387]     ...future.conditions <- base::list()
[17:45:45.387]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:45.387]     if (FALSE) {
[17:45:45.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:45.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:45.387]     }
[17:45:45.387]     ...future.result <- base::tryCatch({
[17:45:45.387]         base::withCallingHandlers({
[17:45:45.387]             ...future.value <- base::withVisible(base::local({
[17:45:45.387]                 ...future.makeSendCondition <- base::local({
[17:45:45.387]                   sendCondition <- NULL
[17:45:45.387]                   function(frame = 1L) {
[17:45:45.387]                     if (is.function(sendCondition)) 
[17:45:45.387]                       return(sendCondition)
[17:45:45.387]                     ns <- getNamespace("parallel")
[17:45:45.387]                     if (exists("sendData", mode = "function", 
[17:45:45.387]                       envir = ns)) {
[17:45:45.387]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:45.387]                         envir = ns)
[17:45:45.387]                       envir <- sys.frame(frame)
[17:45:45.387]                       master <- NULL
[17:45:45.387]                       while (!identical(envir, .GlobalEnv) && 
[17:45:45.387]                         !identical(envir, emptyenv())) {
[17:45:45.387]                         if (exists("master", mode = "list", envir = envir, 
[17:45:45.387]                           inherits = FALSE)) {
[17:45:45.387]                           master <- get("master", mode = "list", 
[17:45:45.387]                             envir = envir, inherits = FALSE)
[17:45:45.387]                           if (inherits(master, c("SOCKnode", 
[17:45:45.387]                             "SOCK0node"))) {
[17:45:45.387]                             sendCondition <<- function(cond) {
[17:45:45.387]                               data <- list(type = "VALUE", value = cond, 
[17:45:45.387]                                 success = TRUE)
[17:45:45.387]                               parallel_sendData(master, data)
[17:45:45.387]                             }
[17:45:45.387]                             return(sendCondition)
[17:45:45.387]                           }
[17:45:45.387]                         }
[17:45:45.387]                         frame <- frame + 1L
[17:45:45.387]                         envir <- sys.frame(frame)
[17:45:45.387]                       }
[17:45:45.387]                     }
[17:45:45.387]                     sendCondition <<- function(cond) NULL
[17:45:45.387]                   }
[17:45:45.387]                 })
[17:45:45.387]                 withCallingHandlers({
[17:45:45.387]                   NA
[17:45:45.387]                 }, immediateCondition = function(cond) {
[17:45:45.387]                   sendCondition <- ...future.makeSendCondition()
[17:45:45.387]                   sendCondition(cond)
[17:45:45.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:45.387]                   {
[17:45:45.387]                     inherits <- base::inherits
[17:45:45.387]                     invokeRestart <- base::invokeRestart
[17:45:45.387]                     is.null <- base::is.null
[17:45:45.387]                     muffled <- FALSE
[17:45:45.387]                     if (inherits(cond, "message")) {
[17:45:45.387]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:45.387]                       if (muffled) 
[17:45:45.387]                         invokeRestart("muffleMessage")
[17:45:45.387]                     }
[17:45:45.387]                     else if (inherits(cond, "warning")) {
[17:45:45.387]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:45.387]                       if (muffled) 
[17:45:45.387]                         invokeRestart("muffleWarning")
[17:45:45.387]                     }
[17:45:45.387]                     else if (inherits(cond, "condition")) {
[17:45:45.387]                       if (!is.null(pattern)) {
[17:45:45.387]                         computeRestarts <- base::computeRestarts
[17:45:45.387]                         grepl <- base::grepl
[17:45:45.387]                         restarts <- computeRestarts(cond)
[17:45:45.387]                         for (restart in restarts) {
[17:45:45.387]                           name <- restart$name
[17:45:45.387]                           if (is.null(name)) 
[17:45:45.387]                             next
[17:45:45.387]                           if (!grepl(pattern, name)) 
[17:45:45.387]                             next
[17:45:45.387]                           invokeRestart(restart)
[17:45:45.387]                           muffled <- TRUE
[17:45:45.387]                           break
[17:45:45.387]                         }
[17:45:45.387]                       }
[17:45:45.387]                     }
[17:45:45.387]                     invisible(muffled)
[17:45:45.387]                   }
[17:45:45.387]                   muffleCondition(cond)
[17:45:45.387]                 })
[17:45:45.387]             }))
[17:45:45.387]             future::FutureResult(value = ...future.value$value, 
[17:45:45.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:45.387]                   ...future.rng), globalenv = if (FALSE) 
[17:45:45.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:45.387]                     ...future.globalenv.names))
[17:45:45.387]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:45.387]         }, condition = base::local({
[17:45:45.387]             c <- base::c
[17:45:45.387]             inherits <- base::inherits
[17:45:45.387]             invokeRestart <- base::invokeRestart
[17:45:45.387]             length <- base::length
[17:45:45.387]             list <- base::list
[17:45:45.387]             seq.int <- base::seq.int
[17:45:45.387]             signalCondition <- base::signalCondition
[17:45:45.387]             sys.calls <- base::sys.calls
[17:45:45.387]             `[[` <- base::`[[`
[17:45:45.387]             `+` <- base::`+`
[17:45:45.387]             `<<-` <- base::`<<-`
[17:45:45.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:45.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:45.387]                   3L)]
[17:45:45.387]             }
[17:45:45.387]             function(cond) {
[17:45:45.387]                 is_error <- inherits(cond, "error")
[17:45:45.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:45.387]                   NULL)
[17:45:45.387]                 if (is_error) {
[17:45:45.387]                   sessionInformation <- function() {
[17:45:45.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:45.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:45.387]                       search = base::search(), system = base::Sys.info())
[17:45:45.387]                   }
[17:45:45.387]                   ...future.conditions[[length(...future.conditions) + 
[17:45:45.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:45.387]                     cond$call), session = sessionInformation(), 
[17:45:45.387]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:45.387]                   signalCondition(cond)
[17:45:45.387]                 }
[17:45:45.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:45.387]                 "immediateCondition"))) {
[17:45:45.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:45.387]                   ...future.conditions[[length(...future.conditions) + 
[17:45:45.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:45.387]                   if (TRUE && !signal) {
[17:45:45.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:45.387]                     {
[17:45:45.387]                       inherits <- base::inherits
[17:45:45.387]                       invokeRestart <- base::invokeRestart
[17:45:45.387]                       is.null <- base::is.null
[17:45:45.387]                       muffled <- FALSE
[17:45:45.387]                       if (inherits(cond, "message")) {
[17:45:45.387]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:45.387]                         if (muffled) 
[17:45:45.387]                           invokeRestart("muffleMessage")
[17:45:45.387]                       }
[17:45:45.387]                       else if (inherits(cond, "warning")) {
[17:45:45.387]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:45.387]                         if (muffled) 
[17:45:45.387]                           invokeRestart("muffleWarning")
[17:45:45.387]                       }
[17:45:45.387]                       else if (inherits(cond, "condition")) {
[17:45:45.387]                         if (!is.null(pattern)) {
[17:45:45.387]                           computeRestarts <- base::computeRestarts
[17:45:45.387]                           grepl <- base::grepl
[17:45:45.387]                           restarts <- computeRestarts(cond)
[17:45:45.387]                           for (restart in restarts) {
[17:45:45.387]                             name <- restart$name
[17:45:45.387]                             if (is.null(name)) 
[17:45:45.387]                               next
[17:45:45.387]                             if (!grepl(pattern, name)) 
[17:45:45.387]                               next
[17:45:45.387]                             invokeRestart(restart)
[17:45:45.387]                             muffled <- TRUE
[17:45:45.387]                             break
[17:45:45.387]                           }
[17:45:45.387]                         }
[17:45:45.387]                       }
[17:45:45.387]                       invisible(muffled)
[17:45:45.387]                     }
[17:45:45.387]                     muffleCondition(cond, pattern = "^muffle")
[17:45:45.387]                   }
[17:45:45.387]                 }
[17:45:45.387]                 else {
[17:45:45.387]                   if (TRUE) {
[17:45:45.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:45.387]                     {
[17:45:45.387]                       inherits <- base::inherits
[17:45:45.387]                       invokeRestart <- base::invokeRestart
[17:45:45.387]                       is.null <- base::is.null
[17:45:45.387]                       muffled <- FALSE
[17:45:45.387]                       if (inherits(cond, "message")) {
[17:45:45.387]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:45.387]                         if (muffled) 
[17:45:45.387]                           invokeRestart("muffleMessage")
[17:45:45.387]                       }
[17:45:45.387]                       else if (inherits(cond, "warning")) {
[17:45:45.387]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:45.387]                         if (muffled) 
[17:45:45.387]                           invokeRestart("muffleWarning")
[17:45:45.387]                       }
[17:45:45.387]                       else if (inherits(cond, "condition")) {
[17:45:45.387]                         if (!is.null(pattern)) {
[17:45:45.387]                           computeRestarts <- base::computeRestarts
[17:45:45.387]                           grepl <- base::grepl
[17:45:45.387]                           restarts <- computeRestarts(cond)
[17:45:45.387]                           for (restart in restarts) {
[17:45:45.387]                             name <- restart$name
[17:45:45.387]                             if (is.null(name)) 
[17:45:45.387]                               next
[17:45:45.387]                             if (!grepl(pattern, name)) 
[17:45:45.387]                               next
[17:45:45.387]                             invokeRestart(restart)
[17:45:45.387]                             muffled <- TRUE
[17:45:45.387]                             break
[17:45:45.387]                           }
[17:45:45.387]                         }
[17:45:45.387]                       }
[17:45:45.387]                       invisible(muffled)
[17:45:45.387]                     }
[17:45:45.387]                     muffleCondition(cond, pattern = "^muffle")
[17:45:45.387]                   }
[17:45:45.387]                 }
[17:45:45.387]             }
[17:45:45.387]         }))
[17:45:45.387]     }, error = function(ex) {
[17:45:45.387]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:45.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:45.387]                 ...future.rng), started = ...future.startTime, 
[17:45:45.387]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:45.387]             version = "1.8"), class = "FutureResult")
[17:45:45.387]     }, finally = {
[17:45:45.387]         if (!identical(...future.workdir, getwd())) 
[17:45:45.387]             setwd(...future.workdir)
[17:45:45.387]         {
[17:45:45.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:45.387]                 ...future.oldOptions$nwarnings <- NULL
[17:45:45.387]             }
[17:45:45.387]             base::options(...future.oldOptions)
[17:45:45.387]             if (.Platform$OS.type == "windows") {
[17:45:45.387]                 old_names <- names(...future.oldEnvVars)
[17:45:45.387]                 envs <- base::Sys.getenv()
[17:45:45.387]                 names <- names(envs)
[17:45:45.387]                 common <- intersect(names, old_names)
[17:45:45.387]                 added <- setdiff(names, old_names)
[17:45:45.387]                 removed <- setdiff(old_names, names)
[17:45:45.387]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:45.387]                   envs[common]]
[17:45:45.387]                 NAMES <- toupper(changed)
[17:45:45.387]                 args <- list()
[17:45:45.387]                 for (kk in seq_along(NAMES)) {
[17:45:45.387]                   name <- changed[[kk]]
[17:45:45.387]                   NAME <- NAMES[[kk]]
[17:45:45.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:45.387]                     next
[17:45:45.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:45.387]                 }
[17:45:45.387]                 NAMES <- toupper(added)
[17:45:45.387]                 for (kk in seq_along(NAMES)) {
[17:45:45.387]                   name <- added[[kk]]
[17:45:45.387]                   NAME <- NAMES[[kk]]
[17:45:45.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:45.387]                     next
[17:45:45.387]                   args[[name]] <- ""
[17:45:45.387]                 }
[17:45:45.387]                 NAMES <- toupper(removed)
[17:45:45.387]                 for (kk in seq_along(NAMES)) {
[17:45:45.387]                   name <- removed[[kk]]
[17:45:45.387]                   NAME <- NAMES[[kk]]
[17:45:45.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:45.387]                     next
[17:45:45.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:45.387]                 }
[17:45:45.387]                 if (length(args) > 0) 
[17:45:45.387]                   base::do.call(base::Sys.setenv, args = args)
[17:45:45.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:45.387]             }
[17:45:45.387]             else {
[17:45:45.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:45.387]             }
[17:45:45.387]             {
[17:45:45.387]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:45.387]                   0L) {
[17:45:45.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:45.387]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:45.387]                   base::options(opts)
[17:45:45.387]                 }
[17:45:45.387]                 {
[17:45:45.387]                   {
[17:45:45.387]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:45.387]                     NULL
[17:45:45.387]                   }
[17:45:45.387]                   options(future.plan = NULL)
[17:45:45.387]                   if (is.na(NA_character_)) 
[17:45:45.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:45.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:45.387]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:45.387]                     .init = FALSE)
[17:45:45.387]                 }
[17:45:45.387]             }
[17:45:45.387]         }
[17:45:45.387]     })
[17:45:45.387]     if (TRUE) {
[17:45:45.387]         base::sink(type = "output", split = FALSE)
[17:45:45.387]         if (TRUE) {
[17:45:45.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:45.387]         }
[17:45:45.387]         else {
[17:45:45.387]             ...future.result["stdout"] <- base::list(NULL)
[17:45:45.387]         }
[17:45:45.387]         base::close(...future.stdout)
[17:45:45.387]         ...future.stdout <- NULL
[17:45:45.387]     }
[17:45:45.387]     ...future.result$conditions <- ...future.conditions
[17:45:45.387]     ...future.result$finished <- base::Sys.time()
[17:45:45.387]     ...future.result
[17:45:45.387] }
[17:45:45.439] MultisessionFuture started
[17:45:45.440] result() for ClusterFuture ...
[17:45:45.440] receiveMessageFromWorker() for ClusterFuture ...
[17:45:45.440] - Validating connection of MultisessionFuture
[17:45:45.471] - received message: FutureResult
[17:45:45.471] - Received FutureResult
[17:45:45.472] - Erased future from FutureRegistry
[17:45:45.472] result() for ClusterFuture ...
[17:45:45.472] - result already collected: FutureResult
[17:45:45.472] result() for ClusterFuture ... done
[17:45:45.472] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:45.472] result() for ClusterFuture ... done
[17:45:45.472] result() for ClusterFuture ...
[17:45:45.472] - result already collected: FutureResult
[17:45:45.473] result() for ClusterFuture ... done
[17:45:45.473] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:45:45.477] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[17:45:45.477] future_lapply() ...
[17:45:45.481] Number of chunks: 2
[17:45:45.481] getGlobalsAndPackagesXApply() ...
[17:45:45.481]  - future.globals: TRUE
[17:45:45.482] getGlobalsAndPackages() ...
[17:45:45.482] Searching for globals...
[17:45:45.483] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:45.484] Searching for globals ... DONE
[17:45:45.484] Resolving globals: FALSE
[17:45:45.484] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:45.485] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:45.485] - globals: [1] ‘FUN’
[17:45:45.485] 
[17:45:45.485] getGlobalsAndPackages() ... DONE
[17:45:45.485]  - globals found/used: [n=1] ‘FUN’
[17:45:45.485]  - needed namespaces: [n=0] 
[17:45:45.485] Finding globals ... DONE
[17:45:45.486]  - use_args: TRUE
[17:45:45.486]  - Getting '...' globals ...
[17:45:45.486] resolve() on list ...
[17:45:45.486]  recursive: 0
[17:45:45.486]  length: 1
[17:45:45.486]  elements: ‘...’
[17:45:45.487]  length: 0 (resolved future 1)
[17:45:45.487] resolve() on list ... DONE
[17:45:45.487]    - '...' content: [n=0] 
[17:45:45.487] List of 1
[17:45:45.487]  $ ...: list()
[17:45:45.487]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:45.487]  - attr(*, "where")=List of 1
[17:45:45.487]   ..$ ...:<environment: 0x55f6c867f7f8> 
[17:45:45.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:45.487]  - attr(*, "resolved")= logi TRUE
[17:45:45.487]  - attr(*, "total_size")= num NA
[17:45:45.490]  - Getting '...' globals ... DONE
[17:45:45.490] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:45.490] List of 2
[17:45:45.490]  $ ...future.FUN:function (x)  
[17:45:45.490]  $ ...          : list()
[17:45:45.490]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:45.490]  - attr(*, "where")=List of 2
[17:45:45.490]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:45.490]   ..$ ...          :<environment: 0x55f6c867f7f8> 
[17:45:45.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:45.490]  - attr(*, "resolved")= logi FALSE
[17:45:45.490]  - attr(*, "total_size")= num 4720
[17:45:45.494] Packages to be attached in all futures: [n=0] 
[17:45:45.494] getGlobalsAndPackagesXApply() ... DONE
[17:45:45.494] Number of futures (= number of chunks): 2
[17:45:45.494] Launching 2 futures (chunks) ...
[17:45:45.494] Chunk #1 of 2 ...
[17:45:45.494]  - Finding globals in 'X' for chunk #1 ...
[17:45:45.495] getGlobalsAndPackages() ...
[17:45:45.495] Searching for globals...
[17:45:45.495] 
[17:45:45.495] Searching for globals ... DONE
[17:45:45.495] - globals: [0] <none>
[17:45:45.495] getGlobalsAndPackages() ... DONE
[17:45:45.495]    + additional globals found: [n=0] 
[17:45:45.496]    + additional namespaces needed: [n=0] 
[17:45:45.496]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:45.496]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:45.496]  - seeds: <none>
[17:45:45.496]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:45.496] getGlobalsAndPackages() ...
[17:45:45.496] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:45.496] Resolving globals: FALSE
[17:45:45.496] Tweak future expression to call with '...' arguments ...
[17:45:45.497] {
[17:45:45.497]     do.call(function(...) {
[17:45:45.497]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:45.497]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:45.497]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:45.497]             on.exit(options(oopts), add = TRUE)
[17:45:45.497]         }
[17:45:45.497]         {
[17:45:45.497]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:45.497]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:45.497]                 ...future.FUN(...future.X_jj, ...)
[17:45:45.497]             })
[17:45:45.497]         }
[17:45:45.497]     }, args = future.call.arguments)
[17:45:45.497] }
[17:45:45.497] Tweak future expression to call with '...' arguments ... DONE
[17:45:45.497] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:45.497] 
[17:45:45.498] getGlobalsAndPackages() ... DONE
[17:45:45.498] run() for ‘Future’ ...
[17:45:45.498] - state: ‘created’
[17:45:45.498] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:45.512] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:45.513] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:45.513]   - Field: ‘node’
[17:45:45.513]   - Field: ‘label’
[17:45:45.513]   - Field: ‘local’
[17:45:45.513]   - Field: ‘owner’
[17:45:45.513]   - Field: ‘envir’
[17:45:45.513]   - Field: ‘workers’
[17:45:45.513]   - Field: ‘packages’
[17:45:45.513]   - Field: ‘gc’
[17:45:45.513]   - Field: ‘conditions’
[17:45:45.514]   - Field: ‘persistent’
[17:45:45.514]   - Field: ‘expr’
[17:45:45.514]   - Field: ‘uuid’
[17:45:45.514]   - Field: ‘seed’
[17:45:45.514]   - Field: ‘version’
[17:45:45.514]   - Field: ‘result’
[17:45:45.514]   - Field: ‘asynchronous’
[17:45:45.514]   - Field: ‘calls’
[17:45:45.515]   - Field: ‘globals’
[17:45:45.515]   - Field: ‘stdout’
[17:45:45.515]   - Field: ‘earlySignal’
[17:45:45.515]   - Field: ‘lazy’
[17:45:45.515]   - Field: ‘state’
[17:45:45.515] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:45.515] - Launch lazy future ...
[17:45:45.516] Packages needed by the future expression (n = 0): <none>
[17:45:45.516] Packages needed by future strategies (n = 0): <none>
[17:45:45.516] {
[17:45:45.516]     {
[17:45:45.516]         {
[17:45:45.516]             ...future.startTime <- base::Sys.time()
[17:45:45.516]             {
[17:45:45.516]                 {
[17:45:45.516]                   {
[17:45:45.516]                     {
[17:45:45.516]                       base::local({
[17:45:45.516]                         has_future <- base::requireNamespace("future", 
[17:45:45.516]                           quietly = TRUE)
[17:45:45.516]                         if (has_future) {
[17:45:45.516]                           ns <- base::getNamespace("future")
[17:45:45.516]                           version <- ns[[".package"]][["version"]]
[17:45:45.516]                           if (is.null(version)) 
[17:45:45.516]                             version <- utils::packageVersion("future")
[17:45:45.516]                         }
[17:45:45.516]                         else {
[17:45:45.516]                           version <- NULL
[17:45:45.516]                         }
[17:45:45.516]                         if (!has_future || version < "1.8.0") {
[17:45:45.516]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:45.516]                             "", base::R.version$version.string), 
[17:45:45.516]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:45.516]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:45.516]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:45.516]                               "release", "version")], collapse = " "), 
[17:45:45.516]                             hostname = base::Sys.info()[["nodename"]])
[17:45:45.516]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:45.516]                             info)
[17:45:45.516]                           info <- base::paste(info, collapse = "; ")
[17:45:45.516]                           if (!has_future) {
[17:45:45.516]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:45.516]                               info)
[17:45:45.516]                           }
[17:45:45.516]                           else {
[17:45:45.516]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:45.516]                               info, version)
[17:45:45.516]                           }
[17:45:45.516]                           base::stop(msg)
[17:45:45.516]                         }
[17:45:45.516]                       })
[17:45:45.516]                     }
[17:45:45.516]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:45.516]                     base::options(mc.cores = 1L)
[17:45:45.516]                   }
[17:45:45.516]                   ...future.strategy.old <- future::plan("list")
[17:45:45.516]                   options(future.plan = NULL)
[17:45:45.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:45.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:45.516]                 }
[17:45:45.516]                 ...future.workdir <- getwd()
[17:45:45.516]             }
[17:45:45.516]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:45.516]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:45.516]         }
[17:45:45.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:45.516]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:45.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:45.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:45.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:45.516]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:45.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:45.516]             base::names(...future.oldOptions))
[17:45:45.516]     }
[17:45:45.516]     if (FALSE) {
[17:45:45.516]     }
[17:45:45.516]     else {
[17:45:45.516]         if (FALSE) {
[17:45:45.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:45.516]                 open = "w")
[17:45:45.516]         }
[17:45:45.516]         else {
[17:45:45.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:45.516]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:45.516]         }
[17:45:45.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:45.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:45.516]             base::sink(type = "output", split = FALSE)
[17:45:45.516]             base::close(...future.stdout)
[17:45:45.516]         }, add = TRUE)
[17:45:45.516]     }
[17:45:45.516]     ...future.frame <- base::sys.nframe()
[17:45:45.516]     ...future.conditions <- base::list()
[17:45:45.516]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:45.516]     if (FALSE) {
[17:45:45.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:45.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:45.516]     }
[17:45:45.516]     ...future.result <- base::tryCatch({
[17:45:45.516]         base::withCallingHandlers({
[17:45:45.516]             ...future.value <- base::withVisible(base::local({
[17:45:45.516]                 ...future.makeSendCondition <- base::local({
[17:45:45.516]                   sendCondition <- NULL
[17:45:45.516]                   function(frame = 1L) {
[17:45:45.516]                     if (is.function(sendCondition)) 
[17:45:45.516]                       return(sendCondition)
[17:45:45.516]                     ns <- getNamespace("parallel")
[17:45:45.516]                     if (exists("sendData", mode = "function", 
[17:45:45.516]                       envir = ns)) {
[17:45:45.516]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:45.516]                         envir = ns)
[17:45:45.516]                       envir <- sys.frame(frame)
[17:45:45.516]                       master <- NULL
[17:45:45.516]                       while (!identical(envir, .GlobalEnv) && 
[17:45:45.516]                         !identical(envir, emptyenv())) {
[17:45:45.516]                         if (exists("master", mode = "list", envir = envir, 
[17:45:45.516]                           inherits = FALSE)) {
[17:45:45.516]                           master <- get("master", mode = "list", 
[17:45:45.516]                             envir = envir, inherits = FALSE)
[17:45:45.516]                           if (inherits(master, c("SOCKnode", 
[17:45:45.516]                             "SOCK0node"))) {
[17:45:45.516]                             sendCondition <<- function(cond) {
[17:45:45.516]                               data <- list(type = "VALUE", value = cond, 
[17:45:45.516]                                 success = TRUE)
[17:45:45.516]                               parallel_sendData(master, data)
[17:45:45.516]                             }
[17:45:45.516]                             return(sendCondition)
[17:45:45.516]                           }
[17:45:45.516]                         }
[17:45:45.516]                         frame <- frame + 1L
[17:45:45.516]                         envir <- sys.frame(frame)
[17:45:45.516]                       }
[17:45:45.516]                     }
[17:45:45.516]                     sendCondition <<- function(cond) NULL
[17:45:45.516]                   }
[17:45:45.516]                 })
[17:45:45.516]                 withCallingHandlers({
[17:45:45.516]                   {
[17:45:45.516]                     do.call(function(...) {
[17:45:45.516]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:45.516]                       if (!identical(...future.globals.maxSize.org, 
[17:45:45.516]                         ...future.globals.maxSize)) {
[17:45:45.516]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:45.516]                         on.exit(options(oopts), add = TRUE)
[17:45:45.516]                       }
[17:45:45.516]                       {
[17:45:45.516]                         lapply(seq_along(...future.elements_ii), 
[17:45:45.516]                           FUN = function(jj) {
[17:45:45.516]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:45.516]                             ...future.FUN(...future.X_jj, ...)
[17:45:45.516]                           })
[17:45:45.516]                       }
[17:45:45.516]                     }, args = future.call.arguments)
[17:45:45.516]                   }
[17:45:45.516]                 }, immediateCondition = function(cond) {
[17:45:45.516]                   sendCondition <- ...future.makeSendCondition()
[17:45:45.516]                   sendCondition(cond)
[17:45:45.516]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:45.516]                   {
[17:45:45.516]                     inherits <- base::inherits
[17:45:45.516]                     invokeRestart <- base::invokeRestart
[17:45:45.516]                     is.null <- base::is.null
[17:45:45.516]                     muffled <- FALSE
[17:45:45.516]                     if (inherits(cond, "message")) {
[17:45:45.516]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:45.516]                       if (muffled) 
[17:45:45.516]                         invokeRestart("muffleMessage")
[17:45:45.516]                     }
[17:45:45.516]                     else if (inherits(cond, "warning")) {
[17:45:45.516]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:45.516]                       if (muffled) 
[17:45:45.516]                         invokeRestart("muffleWarning")
[17:45:45.516]                     }
[17:45:45.516]                     else if (inherits(cond, "condition")) {
[17:45:45.516]                       if (!is.null(pattern)) {
[17:45:45.516]                         computeRestarts <- base::computeRestarts
[17:45:45.516]                         grepl <- base::grepl
[17:45:45.516]                         restarts <- computeRestarts(cond)
[17:45:45.516]                         for (restart in restarts) {
[17:45:45.516]                           name <- restart$name
[17:45:45.516]                           if (is.null(name)) 
[17:45:45.516]                             next
[17:45:45.516]                           if (!grepl(pattern, name)) 
[17:45:45.516]                             next
[17:45:45.516]                           invokeRestart(restart)
[17:45:45.516]                           muffled <- TRUE
[17:45:45.516]                           break
[17:45:45.516]                         }
[17:45:45.516]                       }
[17:45:45.516]                     }
[17:45:45.516]                     invisible(muffled)
[17:45:45.516]                   }
[17:45:45.516]                   muffleCondition(cond)
[17:45:45.516]                 })
[17:45:45.516]             }))
[17:45:45.516]             future::FutureResult(value = ...future.value$value, 
[17:45:45.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:45.516]                   ...future.rng), globalenv = if (FALSE) 
[17:45:45.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:45.516]                     ...future.globalenv.names))
[17:45:45.516]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:45.516]         }, condition = base::local({
[17:45:45.516]             c <- base::c
[17:45:45.516]             inherits <- base::inherits
[17:45:45.516]             invokeRestart <- base::invokeRestart
[17:45:45.516]             length <- base::length
[17:45:45.516]             list <- base::list
[17:45:45.516]             seq.int <- base::seq.int
[17:45:45.516]             signalCondition <- base::signalCondition
[17:45:45.516]             sys.calls <- base::sys.calls
[17:45:45.516]             `[[` <- base::`[[`
[17:45:45.516]             `+` <- base::`+`
[17:45:45.516]             `<<-` <- base::`<<-`
[17:45:45.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:45.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:45.516]                   3L)]
[17:45:45.516]             }
[17:45:45.516]             function(cond) {
[17:45:45.516]                 is_error <- inherits(cond, "error")
[17:45:45.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:45.516]                   NULL)
[17:45:45.516]                 if (is_error) {
[17:45:45.516]                   sessionInformation <- function() {
[17:45:45.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:45.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:45.516]                       search = base::search(), system = base::Sys.info())
[17:45:45.516]                   }
[17:45:45.516]                   ...future.conditions[[length(...future.conditions) + 
[17:45:45.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:45.516]                     cond$call), session = sessionInformation(), 
[17:45:45.516]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:45.516]                   signalCondition(cond)
[17:45:45.516]                 }
[17:45:45.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:45.516]                 "immediateCondition"))) {
[17:45:45.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:45.516]                   ...future.conditions[[length(...future.conditions) + 
[17:45:45.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:45.516]                   if (TRUE && !signal) {
[17:45:45.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:45.516]                     {
[17:45:45.516]                       inherits <- base::inherits
[17:45:45.516]                       invokeRestart <- base::invokeRestart
[17:45:45.516]                       is.null <- base::is.null
[17:45:45.516]                       muffled <- FALSE
[17:45:45.516]                       if (inherits(cond, "message")) {
[17:45:45.516]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:45.516]                         if (muffled) 
[17:45:45.516]                           invokeRestart("muffleMessage")
[17:45:45.516]                       }
[17:45:45.516]                       else if (inherits(cond, "warning")) {
[17:45:45.516]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:45.516]                         if (muffled) 
[17:45:45.516]                           invokeRestart("muffleWarning")
[17:45:45.516]                       }
[17:45:45.516]                       else if (inherits(cond, "condition")) {
[17:45:45.516]                         if (!is.null(pattern)) {
[17:45:45.516]                           computeRestarts <- base::computeRestarts
[17:45:45.516]                           grepl <- base::grepl
[17:45:45.516]                           restarts <- computeRestarts(cond)
[17:45:45.516]                           for (restart in restarts) {
[17:45:45.516]                             name <- restart$name
[17:45:45.516]                             if (is.null(name)) 
[17:45:45.516]                               next
[17:45:45.516]                             if (!grepl(pattern, name)) 
[17:45:45.516]                               next
[17:45:45.516]                             invokeRestart(restart)
[17:45:45.516]                             muffled <- TRUE
[17:45:45.516]                             break
[17:45:45.516]                           }
[17:45:45.516]                         }
[17:45:45.516]                       }
[17:45:45.516]                       invisible(muffled)
[17:45:45.516]                     }
[17:45:45.516]                     muffleCondition(cond, pattern = "^muffle")
[17:45:45.516]                   }
[17:45:45.516]                 }
[17:45:45.516]                 else {
[17:45:45.516]                   if (TRUE) {
[17:45:45.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:45.516]                     {
[17:45:45.516]                       inherits <- base::inherits
[17:45:45.516]                       invokeRestart <- base::invokeRestart
[17:45:45.516]                       is.null <- base::is.null
[17:45:45.516]                       muffled <- FALSE
[17:45:45.516]                       if (inherits(cond, "message")) {
[17:45:45.516]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:45.516]                         if (muffled) 
[17:45:45.516]                           invokeRestart("muffleMessage")
[17:45:45.516]                       }
[17:45:45.516]                       else if (inherits(cond, "warning")) {
[17:45:45.516]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:45.516]                         if (muffled) 
[17:45:45.516]                           invokeRestart("muffleWarning")
[17:45:45.516]                       }
[17:45:45.516]                       else if (inherits(cond, "condition")) {
[17:45:45.516]                         if (!is.null(pattern)) {
[17:45:45.516]                           computeRestarts <- base::computeRestarts
[17:45:45.516]                           grepl <- base::grepl
[17:45:45.516]                           restarts <- computeRestarts(cond)
[17:45:45.516]                           for (restart in restarts) {
[17:45:45.516]                             name <- restart$name
[17:45:45.516]                             if (is.null(name)) 
[17:45:45.516]                               next
[17:45:45.516]                             if (!grepl(pattern, name)) 
[17:45:45.516]                               next
[17:45:45.516]                             invokeRestart(restart)
[17:45:45.516]                             muffled <- TRUE
[17:45:45.516]                             break
[17:45:45.516]                           }
[17:45:45.516]                         }
[17:45:45.516]                       }
[17:45:45.516]                       invisible(muffled)
[17:45:45.516]                     }
[17:45:45.516]                     muffleCondition(cond, pattern = "^muffle")
[17:45:45.516]                   }
[17:45:45.516]                 }
[17:45:45.516]             }
[17:45:45.516]         }))
[17:45:45.516]     }, error = function(ex) {
[17:45:45.516]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:45.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:45.516]                 ...future.rng), started = ...future.startTime, 
[17:45:45.516]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:45.516]             version = "1.8"), class = "FutureResult")
[17:45:45.516]     }, finally = {
[17:45:45.516]         if (!identical(...future.workdir, getwd())) 
[17:45:45.516]             setwd(...future.workdir)
[17:45:45.516]         {
[17:45:45.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:45.516]                 ...future.oldOptions$nwarnings <- NULL
[17:45:45.516]             }
[17:45:45.516]             base::options(...future.oldOptions)
[17:45:45.516]             if (.Platform$OS.type == "windows") {
[17:45:45.516]                 old_names <- names(...future.oldEnvVars)
[17:45:45.516]                 envs <- base::Sys.getenv()
[17:45:45.516]                 names <- names(envs)
[17:45:45.516]                 common <- intersect(names, old_names)
[17:45:45.516]                 added <- setdiff(names, old_names)
[17:45:45.516]                 removed <- setdiff(old_names, names)
[17:45:45.516]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:45.516]                   envs[common]]
[17:45:45.516]                 NAMES <- toupper(changed)
[17:45:45.516]                 args <- list()
[17:45:45.516]                 for (kk in seq_along(NAMES)) {
[17:45:45.516]                   name <- changed[[kk]]
[17:45:45.516]                   NAME <- NAMES[[kk]]
[17:45:45.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:45.516]                     next
[17:45:45.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:45.516]                 }
[17:45:45.516]                 NAMES <- toupper(added)
[17:45:45.516]                 for (kk in seq_along(NAMES)) {
[17:45:45.516]                   name <- added[[kk]]
[17:45:45.516]                   NAME <- NAMES[[kk]]
[17:45:45.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:45.516]                     next
[17:45:45.516]                   args[[name]] <- ""
[17:45:45.516]                 }
[17:45:45.516]                 NAMES <- toupper(removed)
[17:45:45.516]                 for (kk in seq_along(NAMES)) {
[17:45:45.516]                   name <- removed[[kk]]
[17:45:45.516]                   NAME <- NAMES[[kk]]
[17:45:45.516]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:45.516]                     next
[17:45:45.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:45.516]                 }
[17:45:45.516]                 if (length(args) > 0) 
[17:45:45.516]                   base::do.call(base::Sys.setenv, args = args)
[17:45:45.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:45.516]             }
[17:45:45.516]             else {
[17:45:45.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:45.516]             }
[17:45:45.516]             {
[17:45:45.516]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:45.516]                   0L) {
[17:45:45.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:45.516]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:45.516]                   base::options(opts)
[17:45:45.516]                 }
[17:45:45.516]                 {
[17:45:45.516]                   {
[17:45:45.516]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:45.516]                     NULL
[17:45:45.516]                   }
[17:45:45.516]                   options(future.plan = NULL)
[17:45:45.516]                   if (is.na(NA_character_)) 
[17:45:45.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:45.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:45.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:45.516]                     .init = FALSE)
[17:45:45.516]                 }
[17:45:45.516]             }
[17:45:45.516]         }
[17:45:45.516]     })
[17:45:45.516]     if (TRUE) {
[17:45:45.516]         base::sink(type = "output", split = FALSE)
[17:45:45.516]         if (FALSE) {
[17:45:45.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:45.516]         }
[17:45:45.516]         else {
[17:45:45.516]             ...future.result["stdout"] <- base::list(NULL)
[17:45:45.516]         }
[17:45:45.516]         base::close(...future.stdout)
[17:45:45.516]         ...future.stdout <- NULL
[17:45:45.516]     }
[17:45:45.516]     ...future.result$conditions <- ...future.conditions
[17:45:45.516]     ...future.result$finished <- base::Sys.time()
[17:45:45.516]     ...future.result
[17:45:45.516] }
[17:45:45.519] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[17:45:45.520] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[17:45:45.520] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[17:45:45.520] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:45.521] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:45.521] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:45:45.521] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:45:45.521] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:45.522] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:45.522] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:45.522] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:45.522] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[17:45:45.523] MultisessionFuture started
[17:45:45.523] - Launch lazy future ... done
[17:45:45.523] run() for ‘MultisessionFuture’ ... done
[17:45:45.523] Created future:
[17:45:45.523] MultisessionFuture:
[17:45:45.523] Label: ‘future_lapply-1’
[17:45:45.523] Expression:
[17:45:45.523] {
[17:45:45.523]     do.call(function(...) {
[17:45:45.523]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:45.523]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:45.523]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:45.523]             on.exit(options(oopts), add = TRUE)
[17:45:45.523]         }
[17:45:45.523]         {
[17:45:45.523]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:45.523]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:45.523]                 ...future.FUN(...future.X_jj, ...)
[17:45:45.523]             })
[17:45:45.523]         }
[17:45:45.523]     }, args = future.call.arguments)
[17:45:45.523] }
[17:45:45.523] Lazy evaluation: FALSE
[17:45:45.523] Asynchronous evaluation: TRUE
[17:45:45.523] Local evaluation: TRUE
[17:45:45.523] Environment: R_GlobalEnv
[17:45:45.523] Capture standard output: FALSE
[17:45:45.523] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:45.523] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:45.523] Packages: <none>
[17:45:45.523] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:45.523] Resolved: FALSE
[17:45:45.523] Value: <not collected>
[17:45:45.523] Conditions captured: <none>
[17:45:45.523] Early signaling: FALSE
[17:45:45.523] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:45.523] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:45.535] Chunk #1 of 2 ... DONE
[17:45:45.536] Chunk #2 of 2 ...
[17:45:45.536]  - Finding globals in 'X' for chunk #2 ...
[17:45:45.536] getGlobalsAndPackages() ...
[17:45:45.536] Searching for globals...
[17:45:45.536] 
[17:45:45.537] Searching for globals ... DONE
[17:45:45.537] - globals: [0] <none>
[17:45:45.537] getGlobalsAndPackages() ... DONE
[17:45:45.537]    + additional globals found: [n=0] 
[17:45:45.537]    + additional namespaces needed: [n=0] 
[17:45:45.537]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:45.537]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:45.537]  - seeds: <none>
[17:45:45.537]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:45.538] getGlobalsAndPackages() ...
[17:45:45.538] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:45.538] Resolving globals: FALSE
[17:45:45.538] Tweak future expression to call with '...' arguments ...
[17:45:45.538] {
[17:45:45.538]     do.call(function(...) {
[17:45:45.538]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:45.538]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:45.538]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:45.538]             on.exit(options(oopts), add = TRUE)
[17:45:45.538]         }
[17:45:45.538]         {
[17:45:45.538]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:45.538]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:45.538]                 ...future.FUN(...future.X_jj, ...)
[17:45:45.538]             })
[17:45:45.538]         }
[17:45:45.538]     }, args = future.call.arguments)
[17:45:45.538] }
[17:45:45.538] Tweak future expression to call with '...' arguments ... DONE
[17:45:45.539] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:45.539] 
[17:45:45.539] getGlobalsAndPackages() ... DONE
[17:45:45.539] run() for ‘Future’ ...
[17:45:45.540] - state: ‘created’
[17:45:45.540] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:45.554] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:45.554] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:45.554]   - Field: ‘node’
[17:45:45.554]   - Field: ‘label’
[17:45:45.555]   - Field: ‘local’
[17:45:45.555]   - Field: ‘owner’
[17:45:45.555]   - Field: ‘envir’
[17:45:45.555]   - Field: ‘workers’
[17:45:45.555]   - Field: ‘packages’
[17:45:45.555]   - Field: ‘gc’
[17:45:45.555]   - Field: ‘conditions’
[17:45:45.555]   - Field: ‘persistent’
[17:45:45.555]   - Field: ‘expr’
[17:45:45.556]   - Field: ‘uuid’
[17:45:45.556]   - Field: ‘seed’
[17:45:45.556]   - Field: ‘version’
[17:45:45.556]   - Field: ‘result’
[17:45:45.556]   - Field: ‘asynchronous’
[17:45:45.556]   - Field: ‘calls’
[17:45:45.556]   - Field: ‘globals’
[17:45:45.556]   - Field: ‘stdout’
[17:45:45.557]   - Field: ‘earlySignal’
[17:45:45.557]   - Field: ‘lazy’
[17:45:45.557]   - Field: ‘state’
[17:45:45.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:45.557] - Launch lazy future ...
[17:45:45.557] Packages needed by the future expression (n = 0): <none>
[17:45:45.557] Packages needed by future strategies (n = 0): <none>
[17:45:45.558] {
[17:45:45.558]     {
[17:45:45.558]         {
[17:45:45.558]             ...future.startTime <- base::Sys.time()
[17:45:45.558]             {
[17:45:45.558]                 {
[17:45:45.558]                   {
[17:45:45.558]                     {
[17:45:45.558]                       base::local({
[17:45:45.558]                         has_future <- base::requireNamespace("future", 
[17:45:45.558]                           quietly = TRUE)
[17:45:45.558]                         if (has_future) {
[17:45:45.558]                           ns <- base::getNamespace("future")
[17:45:45.558]                           version <- ns[[".package"]][["version"]]
[17:45:45.558]                           if (is.null(version)) 
[17:45:45.558]                             version <- utils::packageVersion("future")
[17:45:45.558]                         }
[17:45:45.558]                         else {
[17:45:45.558]                           version <- NULL
[17:45:45.558]                         }
[17:45:45.558]                         if (!has_future || version < "1.8.0") {
[17:45:45.558]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:45.558]                             "", base::R.version$version.string), 
[17:45:45.558]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:45.558]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:45.558]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:45.558]                               "release", "version")], collapse = " "), 
[17:45:45.558]                             hostname = base::Sys.info()[["nodename"]])
[17:45:45.558]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:45.558]                             info)
[17:45:45.558]                           info <- base::paste(info, collapse = "; ")
[17:45:45.558]                           if (!has_future) {
[17:45:45.558]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:45.558]                               info)
[17:45:45.558]                           }
[17:45:45.558]                           else {
[17:45:45.558]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:45.558]                               info, version)
[17:45:45.558]                           }
[17:45:45.558]                           base::stop(msg)
[17:45:45.558]                         }
[17:45:45.558]                       })
[17:45:45.558]                     }
[17:45:45.558]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:45.558]                     base::options(mc.cores = 1L)
[17:45:45.558]                   }
[17:45:45.558]                   ...future.strategy.old <- future::plan("list")
[17:45:45.558]                   options(future.plan = NULL)
[17:45:45.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:45.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:45.558]                 }
[17:45:45.558]                 ...future.workdir <- getwd()
[17:45:45.558]             }
[17:45:45.558]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:45.558]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:45.558]         }
[17:45:45.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:45.558]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:45.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:45.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:45.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:45.558]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:45.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:45.558]             base::names(...future.oldOptions))
[17:45:45.558]     }
[17:45:45.558]     if (FALSE) {
[17:45:45.558]     }
[17:45:45.558]     else {
[17:45:45.558]         if (FALSE) {
[17:45:45.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:45.558]                 open = "w")
[17:45:45.558]         }
[17:45:45.558]         else {
[17:45:45.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:45.558]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:45.558]         }
[17:45:45.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:45.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:45.558]             base::sink(type = "output", split = FALSE)
[17:45:45.558]             base::close(...future.stdout)
[17:45:45.558]         }, add = TRUE)
[17:45:45.558]     }
[17:45:45.558]     ...future.frame <- base::sys.nframe()
[17:45:45.558]     ...future.conditions <- base::list()
[17:45:45.558]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:45.558]     if (FALSE) {
[17:45:45.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:45.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:45.558]     }
[17:45:45.558]     ...future.result <- base::tryCatch({
[17:45:45.558]         base::withCallingHandlers({
[17:45:45.558]             ...future.value <- base::withVisible(base::local({
[17:45:45.558]                 ...future.makeSendCondition <- base::local({
[17:45:45.558]                   sendCondition <- NULL
[17:45:45.558]                   function(frame = 1L) {
[17:45:45.558]                     if (is.function(sendCondition)) 
[17:45:45.558]                       return(sendCondition)
[17:45:45.558]                     ns <- getNamespace("parallel")
[17:45:45.558]                     if (exists("sendData", mode = "function", 
[17:45:45.558]                       envir = ns)) {
[17:45:45.558]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:45.558]                         envir = ns)
[17:45:45.558]                       envir <- sys.frame(frame)
[17:45:45.558]                       master <- NULL
[17:45:45.558]                       while (!identical(envir, .GlobalEnv) && 
[17:45:45.558]                         !identical(envir, emptyenv())) {
[17:45:45.558]                         if (exists("master", mode = "list", envir = envir, 
[17:45:45.558]                           inherits = FALSE)) {
[17:45:45.558]                           master <- get("master", mode = "list", 
[17:45:45.558]                             envir = envir, inherits = FALSE)
[17:45:45.558]                           if (inherits(master, c("SOCKnode", 
[17:45:45.558]                             "SOCK0node"))) {
[17:45:45.558]                             sendCondition <<- function(cond) {
[17:45:45.558]                               data <- list(type = "VALUE", value = cond, 
[17:45:45.558]                                 success = TRUE)
[17:45:45.558]                               parallel_sendData(master, data)
[17:45:45.558]                             }
[17:45:45.558]                             return(sendCondition)
[17:45:45.558]                           }
[17:45:45.558]                         }
[17:45:45.558]                         frame <- frame + 1L
[17:45:45.558]                         envir <- sys.frame(frame)
[17:45:45.558]                       }
[17:45:45.558]                     }
[17:45:45.558]                     sendCondition <<- function(cond) NULL
[17:45:45.558]                   }
[17:45:45.558]                 })
[17:45:45.558]                 withCallingHandlers({
[17:45:45.558]                   {
[17:45:45.558]                     do.call(function(...) {
[17:45:45.558]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:45.558]                       if (!identical(...future.globals.maxSize.org, 
[17:45:45.558]                         ...future.globals.maxSize)) {
[17:45:45.558]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:45.558]                         on.exit(options(oopts), add = TRUE)
[17:45:45.558]                       }
[17:45:45.558]                       {
[17:45:45.558]                         lapply(seq_along(...future.elements_ii), 
[17:45:45.558]                           FUN = function(jj) {
[17:45:45.558]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:45.558]                             ...future.FUN(...future.X_jj, ...)
[17:45:45.558]                           })
[17:45:45.558]                       }
[17:45:45.558]                     }, args = future.call.arguments)
[17:45:45.558]                   }
[17:45:45.558]                 }, immediateCondition = function(cond) {
[17:45:45.558]                   sendCondition <- ...future.makeSendCondition()
[17:45:45.558]                   sendCondition(cond)
[17:45:45.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:45.558]                   {
[17:45:45.558]                     inherits <- base::inherits
[17:45:45.558]                     invokeRestart <- base::invokeRestart
[17:45:45.558]                     is.null <- base::is.null
[17:45:45.558]                     muffled <- FALSE
[17:45:45.558]                     if (inherits(cond, "message")) {
[17:45:45.558]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:45.558]                       if (muffled) 
[17:45:45.558]                         invokeRestart("muffleMessage")
[17:45:45.558]                     }
[17:45:45.558]                     else if (inherits(cond, "warning")) {
[17:45:45.558]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:45.558]                       if (muffled) 
[17:45:45.558]                         invokeRestart("muffleWarning")
[17:45:45.558]                     }
[17:45:45.558]                     else if (inherits(cond, "condition")) {
[17:45:45.558]                       if (!is.null(pattern)) {
[17:45:45.558]                         computeRestarts <- base::computeRestarts
[17:45:45.558]                         grepl <- base::grepl
[17:45:45.558]                         restarts <- computeRestarts(cond)
[17:45:45.558]                         for (restart in restarts) {
[17:45:45.558]                           name <- restart$name
[17:45:45.558]                           if (is.null(name)) 
[17:45:45.558]                             next
[17:45:45.558]                           if (!grepl(pattern, name)) 
[17:45:45.558]                             next
[17:45:45.558]                           invokeRestart(restart)
[17:45:45.558]                           muffled <- TRUE
[17:45:45.558]                           break
[17:45:45.558]                         }
[17:45:45.558]                       }
[17:45:45.558]                     }
[17:45:45.558]                     invisible(muffled)
[17:45:45.558]                   }
[17:45:45.558]                   muffleCondition(cond)
[17:45:45.558]                 })
[17:45:45.558]             }))
[17:45:45.558]             future::FutureResult(value = ...future.value$value, 
[17:45:45.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:45.558]                   ...future.rng), globalenv = if (FALSE) 
[17:45:45.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:45.558]                     ...future.globalenv.names))
[17:45:45.558]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:45.558]         }, condition = base::local({
[17:45:45.558]             c <- base::c
[17:45:45.558]             inherits <- base::inherits
[17:45:45.558]             invokeRestart <- base::invokeRestart
[17:45:45.558]             length <- base::length
[17:45:45.558]             list <- base::list
[17:45:45.558]             seq.int <- base::seq.int
[17:45:45.558]             signalCondition <- base::signalCondition
[17:45:45.558]             sys.calls <- base::sys.calls
[17:45:45.558]             `[[` <- base::`[[`
[17:45:45.558]             `+` <- base::`+`
[17:45:45.558]             `<<-` <- base::`<<-`
[17:45:45.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:45.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:45.558]                   3L)]
[17:45:45.558]             }
[17:45:45.558]             function(cond) {
[17:45:45.558]                 is_error <- inherits(cond, "error")
[17:45:45.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:45.558]                   NULL)
[17:45:45.558]                 if (is_error) {
[17:45:45.558]                   sessionInformation <- function() {
[17:45:45.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:45.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:45.558]                       search = base::search(), system = base::Sys.info())
[17:45:45.558]                   }
[17:45:45.558]                   ...future.conditions[[length(...future.conditions) + 
[17:45:45.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:45.558]                     cond$call), session = sessionInformation(), 
[17:45:45.558]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:45.558]                   signalCondition(cond)
[17:45:45.558]                 }
[17:45:45.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:45.558]                 "immediateCondition"))) {
[17:45:45.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:45.558]                   ...future.conditions[[length(...future.conditions) + 
[17:45:45.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:45.558]                   if (TRUE && !signal) {
[17:45:45.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:45.558]                     {
[17:45:45.558]                       inherits <- base::inherits
[17:45:45.558]                       invokeRestart <- base::invokeRestart
[17:45:45.558]                       is.null <- base::is.null
[17:45:45.558]                       muffled <- FALSE
[17:45:45.558]                       if (inherits(cond, "message")) {
[17:45:45.558]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:45.558]                         if (muffled) 
[17:45:45.558]                           invokeRestart("muffleMessage")
[17:45:45.558]                       }
[17:45:45.558]                       else if (inherits(cond, "warning")) {
[17:45:45.558]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:45.558]                         if (muffled) 
[17:45:45.558]                           invokeRestart("muffleWarning")
[17:45:45.558]                       }
[17:45:45.558]                       else if (inherits(cond, "condition")) {
[17:45:45.558]                         if (!is.null(pattern)) {
[17:45:45.558]                           computeRestarts <- base::computeRestarts
[17:45:45.558]                           grepl <- base::grepl
[17:45:45.558]                           restarts <- computeRestarts(cond)
[17:45:45.558]                           for (restart in restarts) {
[17:45:45.558]                             name <- restart$name
[17:45:45.558]                             if (is.null(name)) 
[17:45:45.558]                               next
[17:45:45.558]                             if (!grepl(pattern, name)) 
[17:45:45.558]                               next
[17:45:45.558]                             invokeRestart(restart)
[17:45:45.558]                             muffled <- TRUE
[17:45:45.558]                             break
[17:45:45.558]                           }
[17:45:45.558]                         }
[17:45:45.558]                       }
[17:45:45.558]                       invisible(muffled)
[17:45:45.558]                     }
[17:45:45.558]                     muffleCondition(cond, pattern = "^muffle")
[17:45:45.558]                   }
[17:45:45.558]                 }
[17:45:45.558]                 else {
[17:45:45.558]                   if (TRUE) {
[17:45:45.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:45.558]                     {
[17:45:45.558]                       inherits <- base::inherits
[17:45:45.558]                       invokeRestart <- base::invokeRestart
[17:45:45.558]                       is.null <- base::is.null
[17:45:45.558]                       muffled <- FALSE
[17:45:45.558]                       if (inherits(cond, "message")) {
[17:45:45.558]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:45.558]                         if (muffled) 
[17:45:45.558]                           invokeRestart("muffleMessage")
[17:45:45.558]                       }
[17:45:45.558]                       else if (inherits(cond, "warning")) {
[17:45:45.558]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:45.558]                         if (muffled) 
[17:45:45.558]                           invokeRestart("muffleWarning")
[17:45:45.558]                       }
[17:45:45.558]                       else if (inherits(cond, "condition")) {
[17:45:45.558]                         if (!is.null(pattern)) {
[17:45:45.558]                           computeRestarts <- base::computeRestarts
[17:45:45.558]                           grepl <- base::grepl
[17:45:45.558]                           restarts <- computeRestarts(cond)
[17:45:45.558]                           for (restart in restarts) {
[17:45:45.558]                             name <- restart$name
[17:45:45.558]                             if (is.null(name)) 
[17:45:45.558]                               next
[17:45:45.558]                             if (!grepl(pattern, name)) 
[17:45:45.558]                               next
[17:45:45.558]                             invokeRestart(restart)
[17:45:45.558]                             muffled <- TRUE
[17:45:45.558]                             break
[17:45:45.558]                           }
[17:45:45.558]                         }
[17:45:45.558]                       }
[17:45:45.558]                       invisible(muffled)
[17:45:45.558]                     }
[17:45:45.558]                     muffleCondition(cond, pattern = "^muffle")
[17:45:45.558]                   }
[17:45:45.558]                 }
[17:45:45.558]             }
[17:45:45.558]         }))
[17:45:45.558]     }, error = function(ex) {
[17:45:45.558]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:45.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:45.558]                 ...future.rng), started = ...future.startTime, 
[17:45:45.558]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:45.558]             version = "1.8"), class = "FutureResult")
[17:45:45.558]     }, finally = {
[17:45:45.558]         if (!identical(...future.workdir, getwd())) 
[17:45:45.558]             setwd(...future.workdir)
[17:45:45.558]         {
[17:45:45.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:45.558]                 ...future.oldOptions$nwarnings <- NULL
[17:45:45.558]             }
[17:45:45.558]             base::options(...future.oldOptions)
[17:45:45.558]             if (.Platform$OS.type == "windows") {
[17:45:45.558]                 old_names <- names(...future.oldEnvVars)
[17:45:45.558]                 envs <- base::Sys.getenv()
[17:45:45.558]                 names <- names(envs)
[17:45:45.558]                 common <- intersect(names, old_names)
[17:45:45.558]                 added <- setdiff(names, old_names)
[17:45:45.558]                 removed <- setdiff(old_names, names)
[17:45:45.558]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:45.558]                   envs[common]]
[17:45:45.558]                 NAMES <- toupper(changed)
[17:45:45.558]                 args <- list()
[17:45:45.558]                 for (kk in seq_along(NAMES)) {
[17:45:45.558]                   name <- changed[[kk]]
[17:45:45.558]                   NAME <- NAMES[[kk]]
[17:45:45.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:45.558]                     next
[17:45:45.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:45.558]                 }
[17:45:45.558]                 NAMES <- toupper(added)
[17:45:45.558]                 for (kk in seq_along(NAMES)) {
[17:45:45.558]                   name <- added[[kk]]
[17:45:45.558]                   NAME <- NAMES[[kk]]
[17:45:45.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:45.558]                     next
[17:45:45.558]                   args[[name]] <- ""
[17:45:45.558]                 }
[17:45:45.558]                 NAMES <- toupper(removed)
[17:45:45.558]                 for (kk in seq_along(NAMES)) {
[17:45:45.558]                   name <- removed[[kk]]
[17:45:45.558]                   NAME <- NAMES[[kk]]
[17:45:45.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:45.558]                     next
[17:45:45.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:45.558]                 }
[17:45:45.558]                 if (length(args) > 0) 
[17:45:45.558]                   base::do.call(base::Sys.setenv, args = args)
[17:45:45.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:45.558]             }
[17:45:45.558]             else {
[17:45:45.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:45.558]             }
[17:45:45.558]             {
[17:45:45.558]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:45.558]                   0L) {
[17:45:45.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:45.558]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:45.558]                   base::options(opts)
[17:45:45.558]                 }
[17:45:45.558]                 {
[17:45:45.558]                   {
[17:45:45.558]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:45.558]                     NULL
[17:45:45.558]                   }
[17:45:45.558]                   options(future.plan = NULL)
[17:45:45.558]                   if (is.na(NA_character_)) 
[17:45:45.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:45.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:45.558]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:45.558]                     .init = FALSE)
[17:45:45.558]                 }
[17:45:45.558]             }
[17:45:45.558]         }
[17:45:45.558]     })
[17:45:45.558]     if (TRUE) {
[17:45:45.558]         base::sink(type = "output", split = FALSE)
[17:45:45.558]         if (FALSE) {
[17:45:45.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:45.558]         }
[17:45:45.558]         else {
[17:45:45.558]             ...future.result["stdout"] <- base::list(NULL)
[17:45:45.558]         }
[17:45:45.558]         base::close(...future.stdout)
[17:45:45.558]         ...future.stdout <- NULL
[17:45:45.558]     }
[17:45:45.558]     ...future.result$conditions <- ...future.conditions
[17:45:45.558]     ...future.result$finished <- base::Sys.time()
[17:45:45.558]     ...future.result
[17:45:45.558] }
[17:45:45.609] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[17:45:45.610] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[17:45:45.610] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[17:45:45.610] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:45:45.611] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:45:45.611] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:45:45.611] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:45:45.612] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:45.612] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:45.612] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:45.613] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:45.613] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[17:45:45.613] MultisessionFuture started
[17:45:45.614] - Launch lazy future ... done
[17:45:45.614] run() for ‘MultisessionFuture’ ... done
[17:45:45.614] Created future:
[17:45:45.614] MultisessionFuture:
[17:45:45.614] Label: ‘future_lapply-2’
[17:45:45.614] Expression:
[17:45:45.614] {
[17:45:45.614]     do.call(function(...) {
[17:45:45.614]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:45.614]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:45.614]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:45.614]             on.exit(options(oopts), add = TRUE)
[17:45:45.614]         }
[17:45:45.614]         {
[17:45:45.614]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:45.614]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:45.614]                 ...future.FUN(...future.X_jj, ...)
[17:45:45.614]             })
[17:45:45.614]         }
[17:45:45.614]     }, args = future.call.arguments)
[17:45:45.614] }
[17:45:45.614] Lazy evaluation: FALSE
[17:45:45.614] Asynchronous evaluation: TRUE
[17:45:45.614] Local evaluation: TRUE
[17:45:45.614] Environment: R_GlobalEnv
[17:45:45.614] Capture standard output: FALSE
[17:45:45.614] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:45.614] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:45.614] Packages: <none>
[17:45:45.614] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:45.614] Resolved: FALSE
[17:45:45.614] Value: <not collected>
[17:45:45.614] Conditions captured: <none>
[17:45:45.614] Early signaling: FALSE
[17:45:45.614] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:45.614] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:45.626] Chunk #2 of 2 ... DONE
[17:45:45.626] Launching 2 futures (chunks) ... DONE
[17:45:45.626] Resolving 2 futures (chunks) ...
[17:45:45.626] resolve() on list ...
[17:45:45.626]  recursive: 0
[17:45:45.627]  length: 2
[17:45:45.627] 
[17:45:45.703] receiveMessageFromWorker() for ClusterFuture ...
[17:45:45.703] - Validating connection of MultisessionFuture
[17:45:45.703] - received message: FutureResult
[17:45:45.704] - Received FutureResult
[17:45:45.704] - Erased future from FutureRegistry
[17:45:45.704] result() for ClusterFuture ...
[17:45:45.704] - result already collected: FutureResult
[17:45:45.704] result() for ClusterFuture ... done
[17:45:45.704] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:45.704] Future #2
[17:45:45.704] result() for ClusterFuture ...
[17:45:45.704] - result already collected: FutureResult
[17:45:45.704] result() for ClusterFuture ... done
[17:45:45.705] result() for ClusterFuture ...
[17:45:45.705] - result already collected: FutureResult
[17:45:45.705] result() for ClusterFuture ... done
[17:45:45.705] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:45.705] - nx: 2
[17:45:45.705] - relay: TRUE
[17:45:45.705] - stdout: TRUE
[17:45:45.705] - signal: TRUE
[17:45:45.705] - resignal: FALSE
[17:45:45.705] - force: TRUE
[17:45:45.705] - relayed: [n=2] FALSE, FALSE
[17:45:45.705] - queued futures: [n=2] FALSE, FALSE
[17:45:45.706]  - until=1
[17:45:45.706]  - relaying element #1
[17:45:45.706] - relayed: [n=2] FALSE, FALSE
[17:45:45.706] - queued futures: [n=2] FALSE, TRUE
[17:45:45.706] signalConditionsASAP(NULL, pos=2) ... done
[17:45:45.706]  length: 1 (resolved future 2)
[17:45:46.066] receiveMessageFromWorker() for ClusterFuture ...
[17:45:46.067] - Validating connection of MultisessionFuture
[17:45:46.067] - received message: FutureResult
[17:45:46.067] - Received FutureResult
[17:45:46.067] - Erased future from FutureRegistry
[17:45:46.067] result() for ClusterFuture ...
[17:45:46.067] - result already collected: FutureResult
[17:45:46.068] result() for ClusterFuture ... done
[17:45:46.068] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:46.068] Future #1
[17:45:46.068] result() for ClusterFuture ...
[17:45:46.068] - result already collected: FutureResult
[17:45:46.068] result() for ClusterFuture ... done
[17:45:46.068] result() for ClusterFuture ...
[17:45:46.068] - result already collected: FutureResult
[17:45:46.068] result() for ClusterFuture ... done
[17:45:46.068] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:46.068] - nx: 2
[17:45:46.068] - relay: TRUE
[17:45:46.069] - stdout: TRUE
[17:45:46.069] - signal: TRUE
[17:45:46.069] - resignal: FALSE
[17:45:46.069] - force: TRUE
[17:45:46.069] - relayed: [n=2] FALSE, FALSE
[17:45:46.069] - queued futures: [n=2] FALSE, TRUE
[17:45:46.069]  - until=1
[17:45:46.069]  - relaying element #1
[17:45:46.069] result() for ClusterFuture ...
[17:45:46.069] - result already collected: FutureResult
[17:45:46.069] result() for ClusterFuture ... done
[17:45:46.069] result() for ClusterFuture ...
[17:45:46.070] - result already collected: FutureResult
[17:45:46.070] result() for ClusterFuture ... done
[17:45:46.070] result() for ClusterFuture ...
[17:45:46.070] - result already collected: FutureResult
[17:45:46.070] result() for ClusterFuture ... done
[17:45:46.070] result() for ClusterFuture ...
[17:45:46.070] - result already collected: FutureResult
[17:45:46.070] result() for ClusterFuture ... done
[17:45:46.070] - relayed: [n=2] TRUE, FALSE
[17:45:46.070] - queued futures: [n=2] TRUE, TRUE
[17:45:46.070] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:46.071]  length: 0 (resolved future 1)
[17:45:46.071] Relaying remaining futures
[17:45:46.071] signalConditionsASAP(NULL, pos=0) ...
[17:45:46.071] - nx: 2
[17:45:46.071] - relay: TRUE
[17:45:46.071] - stdout: TRUE
[17:45:46.071] - signal: TRUE
[17:45:46.071] - resignal: FALSE
[17:45:46.071] - force: TRUE
[17:45:46.071] - relayed: [n=2] TRUE, FALSE
[17:45:46.071] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:46.071]  - relaying element #2
[17:45:46.072] result() for ClusterFuture ...
[17:45:46.072] - result already collected: FutureResult
[17:45:46.072] result() for ClusterFuture ... done
[17:45:46.072] result() for ClusterFuture ...
[17:45:46.072] - result already collected: FutureResult
[17:45:46.072] result() for ClusterFuture ... done
[17:45:46.072] result() for ClusterFuture ...
[17:45:46.072] - result already collected: FutureResult
[17:45:46.072] result() for ClusterFuture ... done
[17:45:46.072] result() for ClusterFuture ...
[17:45:46.072] - result already collected: FutureResult
[17:45:46.072] result() for ClusterFuture ... done
[17:45:46.073] - relayed: [n=2] TRUE, TRUE
[17:45:46.073] - queued futures: [n=2] TRUE, TRUE
[17:45:46.073] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:45:46.073] resolve() on list ... DONE
[17:45:46.073] result() for ClusterFuture ...
[17:45:46.073] - result already collected: FutureResult
[17:45:46.073] result() for ClusterFuture ... done
[17:45:46.073] result() for ClusterFuture ...
[17:45:46.073] - result already collected: FutureResult
[17:45:46.073] result() for ClusterFuture ... done
[17:45:46.073] result() for ClusterFuture ...
[17:45:46.073] - result already collected: FutureResult
[17:45:46.074] result() for ClusterFuture ... done
[17:45:46.074] result() for ClusterFuture ...
[17:45:46.074] - result already collected: FutureResult
[17:45:46.074] result() for ClusterFuture ... done
[17:45:46.074]  - Number of value chunks collected: 2
[17:45:46.074] Resolving 2 futures (chunks) ... DONE
[17:45:46.074] Reducing values from 2 chunks ...
[17:45:46.074]  - Number of values collected after concatenation: 2
[17:45:46.074]  - Number of values expected: 2
[17:45:46.074] Reducing values from 2 chunks ... DONE
[17:45:46.074] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[17:45:46.075] future_lapply() ...
[17:45:46.079] Number of chunks: 2
[17:45:46.079] getGlobalsAndPackagesXApply() ...
[17:45:46.079]  - future.globals: TRUE
[17:45:46.079] getGlobalsAndPackages() ...
[17:45:46.079] Searching for globals...
[17:45:46.081] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:46.081] Searching for globals ... DONE
[17:45:46.081] Resolving globals: FALSE
[17:45:46.081] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:46.082] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:46.082] - globals: [1] ‘FUN’
[17:45:46.082] 
[17:45:46.082] getGlobalsAndPackages() ... DONE
[17:45:46.082]  - globals found/used: [n=1] ‘FUN’
[17:45:46.082]  - needed namespaces: [n=0] 
[17:45:46.082] Finding globals ... DONE
[17:45:46.082]  - use_args: TRUE
[17:45:46.082]  - Getting '...' globals ...
[17:45:46.083] resolve() on list ...
[17:45:46.083]  recursive: 0
[17:45:46.083]  length: 1
[17:45:46.083]  elements: ‘...’
[17:45:46.083]  length: 0 (resolved future 1)
[17:45:46.083] resolve() on list ... DONE
[17:45:46.083]    - '...' content: [n=0] 
[17:45:46.084] List of 1
[17:45:46.084]  $ ...: list()
[17:45:46.084]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:46.084]  - attr(*, "where")=List of 1
[17:45:46.084]   ..$ ...:<environment: 0x55f6c657ad68> 
[17:45:46.084]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:46.084]  - attr(*, "resolved")= logi TRUE
[17:45:46.084]  - attr(*, "total_size")= num NA
[17:45:46.086]  - Getting '...' globals ... DONE
[17:45:46.086] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:46.086] List of 2
[17:45:46.086]  $ ...future.FUN:function (x)  
[17:45:46.086]  $ ...          : list()
[17:45:46.086]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:46.086]  - attr(*, "where")=List of 2
[17:45:46.086]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:46.086]   ..$ ...          :<environment: 0x55f6c657ad68> 
[17:45:46.086]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:46.086]  - attr(*, "resolved")= logi FALSE
[17:45:46.086]  - attr(*, "total_size")= num 4720
[17:45:46.089] Packages to be attached in all futures: [n=0] 
[17:45:46.089] getGlobalsAndPackagesXApply() ... DONE
[17:45:46.089] Number of futures (= number of chunks): 2
[17:45:46.089] Launching 2 futures (chunks) ...
[17:45:46.089] Chunk #1 of 2 ...
[17:45:46.089]  - Finding globals in 'X' for chunk #1 ...
[17:45:46.090] getGlobalsAndPackages() ...
[17:45:46.090] Searching for globals...
[17:45:46.090] 
[17:45:46.090] Searching for globals ... DONE
[17:45:46.090] - globals: [0] <none>
[17:45:46.090] getGlobalsAndPackages() ... DONE
[17:45:46.090]    + additional globals found: [n=0] 
[17:45:46.090]    + additional namespaces needed: [n=0] 
[17:45:46.090]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:46.090]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:46.091]  - seeds: <none>
[17:45:46.091]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:46.091] getGlobalsAndPackages() ...
[17:45:46.091] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:46.091] Resolving globals: FALSE
[17:45:46.091] Tweak future expression to call with '...' arguments ...
[17:45:46.091] {
[17:45:46.091]     do.call(function(...) {
[17:45:46.091]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:46.091]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:46.091]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:46.091]             on.exit(options(oopts), add = TRUE)
[17:45:46.091]         }
[17:45:46.091]         {
[17:45:46.091]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:46.091]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:46.091]                 ...future.FUN(...future.X_jj, ...)
[17:45:46.091]             })
[17:45:46.091]         }
[17:45:46.091]     }, args = future.call.arguments)
[17:45:46.091] }
[17:45:46.091] Tweak future expression to call with '...' arguments ... DONE
[17:45:46.092] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:46.092] 
[17:45:46.092] getGlobalsAndPackages() ... DONE
[17:45:46.092] run() for ‘Future’ ...
[17:45:46.092] - state: ‘created’
[17:45:46.093] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:46.106] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:46.106] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:46.106]   - Field: ‘node’
[17:45:46.106]   - Field: ‘label’
[17:45:46.106]   - Field: ‘local’
[17:45:46.107]   - Field: ‘owner’
[17:45:46.107]   - Field: ‘envir’
[17:45:46.107]   - Field: ‘workers’
[17:45:46.107]   - Field: ‘packages’
[17:45:46.107]   - Field: ‘gc’
[17:45:46.107]   - Field: ‘conditions’
[17:45:46.107]   - Field: ‘persistent’
[17:45:46.107]   - Field: ‘expr’
[17:45:46.107]   - Field: ‘uuid’
[17:45:46.107]   - Field: ‘seed’
[17:45:46.108]   - Field: ‘version’
[17:45:46.108]   - Field: ‘result’
[17:45:46.108]   - Field: ‘asynchronous’
[17:45:46.108]   - Field: ‘calls’
[17:45:46.108]   - Field: ‘globals’
[17:45:46.108]   - Field: ‘stdout’
[17:45:46.108]   - Field: ‘earlySignal’
[17:45:46.108]   - Field: ‘lazy’
[17:45:46.108]   - Field: ‘state’
[17:45:46.108] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:46.108] - Launch lazy future ...
[17:45:46.109] Packages needed by the future expression (n = 0): <none>
[17:45:46.109] Packages needed by future strategies (n = 0): <none>
[17:45:46.109] {
[17:45:46.109]     {
[17:45:46.109]         {
[17:45:46.109]             ...future.startTime <- base::Sys.time()
[17:45:46.109]             {
[17:45:46.109]                 {
[17:45:46.109]                   {
[17:45:46.109]                     {
[17:45:46.109]                       base::local({
[17:45:46.109]                         has_future <- base::requireNamespace("future", 
[17:45:46.109]                           quietly = TRUE)
[17:45:46.109]                         if (has_future) {
[17:45:46.109]                           ns <- base::getNamespace("future")
[17:45:46.109]                           version <- ns[[".package"]][["version"]]
[17:45:46.109]                           if (is.null(version)) 
[17:45:46.109]                             version <- utils::packageVersion("future")
[17:45:46.109]                         }
[17:45:46.109]                         else {
[17:45:46.109]                           version <- NULL
[17:45:46.109]                         }
[17:45:46.109]                         if (!has_future || version < "1.8.0") {
[17:45:46.109]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:46.109]                             "", base::R.version$version.string), 
[17:45:46.109]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:46.109]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:46.109]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:46.109]                               "release", "version")], collapse = " "), 
[17:45:46.109]                             hostname = base::Sys.info()[["nodename"]])
[17:45:46.109]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:46.109]                             info)
[17:45:46.109]                           info <- base::paste(info, collapse = "; ")
[17:45:46.109]                           if (!has_future) {
[17:45:46.109]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:46.109]                               info)
[17:45:46.109]                           }
[17:45:46.109]                           else {
[17:45:46.109]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:46.109]                               info, version)
[17:45:46.109]                           }
[17:45:46.109]                           base::stop(msg)
[17:45:46.109]                         }
[17:45:46.109]                       })
[17:45:46.109]                     }
[17:45:46.109]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:46.109]                     base::options(mc.cores = 1L)
[17:45:46.109]                   }
[17:45:46.109]                   ...future.strategy.old <- future::plan("list")
[17:45:46.109]                   options(future.plan = NULL)
[17:45:46.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:46.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:46.109]                 }
[17:45:46.109]                 ...future.workdir <- getwd()
[17:45:46.109]             }
[17:45:46.109]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:46.109]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:46.109]         }
[17:45:46.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:46.109]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:46.109]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:46.109]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:46.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:46.109]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:46.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:46.109]             base::names(...future.oldOptions))
[17:45:46.109]     }
[17:45:46.109]     if (FALSE) {
[17:45:46.109]     }
[17:45:46.109]     else {
[17:45:46.109]         if (TRUE) {
[17:45:46.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:46.109]                 open = "w")
[17:45:46.109]         }
[17:45:46.109]         else {
[17:45:46.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:46.109]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:46.109]         }
[17:45:46.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:46.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:46.109]             base::sink(type = "output", split = FALSE)
[17:45:46.109]             base::close(...future.stdout)
[17:45:46.109]         }, add = TRUE)
[17:45:46.109]     }
[17:45:46.109]     ...future.frame <- base::sys.nframe()
[17:45:46.109]     ...future.conditions <- base::list()
[17:45:46.109]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:46.109]     if (FALSE) {
[17:45:46.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:46.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:46.109]     }
[17:45:46.109]     ...future.result <- base::tryCatch({
[17:45:46.109]         base::withCallingHandlers({
[17:45:46.109]             ...future.value <- base::withVisible(base::local({
[17:45:46.109]                 ...future.makeSendCondition <- base::local({
[17:45:46.109]                   sendCondition <- NULL
[17:45:46.109]                   function(frame = 1L) {
[17:45:46.109]                     if (is.function(sendCondition)) 
[17:45:46.109]                       return(sendCondition)
[17:45:46.109]                     ns <- getNamespace("parallel")
[17:45:46.109]                     if (exists("sendData", mode = "function", 
[17:45:46.109]                       envir = ns)) {
[17:45:46.109]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:46.109]                         envir = ns)
[17:45:46.109]                       envir <- sys.frame(frame)
[17:45:46.109]                       master <- NULL
[17:45:46.109]                       while (!identical(envir, .GlobalEnv) && 
[17:45:46.109]                         !identical(envir, emptyenv())) {
[17:45:46.109]                         if (exists("master", mode = "list", envir = envir, 
[17:45:46.109]                           inherits = FALSE)) {
[17:45:46.109]                           master <- get("master", mode = "list", 
[17:45:46.109]                             envir = envir, inherits = FALSE)
[17:45:46.109]                           if (inherits(master, c("SOCKnode", 
[17:45:46.109]                             "SOCK0node"))) {
[17:45:46.109]                             sendCondition <<- function(cond) {
[17:45:46.109]                               data <- list(type = "VALUE", value = cond, 
[17:45:46.109]                                 success = TRUE)
[17:45:46.109]                               parallel_sendData(master, data)
[17:45:46.109]                             }
[17:45:46.109]                             return(sendCondition)
[17:45:46.109]                           }
[17:45:46.109]                         }
[17:45:46.109]                         frame <- frame + 1L
[17:45:46.109]                         envir <- sys.frame(frame)
[17:45:46.109]                       }
[17:45:46.109]                     }
[17:45:46.109]                     sendCondition <<- function(cond) NULL
[17:45:46.109]                   }
[17:45:46.109]                 })
[17:45:46.109]                 withCallingHandlers({
[17:45:46.109]                   {
[17:45:46.109]                     do.call(function(...) {
[17:45:46.109]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:46.109]                       if (!identical(...future.globals.maxSize.org, 
[17:45:46.109]                         ...future.globals.maxSize)) {
[17:45:46.109]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:46.109]                         on.exit(options(oopts), add = TRUE)
[17:45:46.109]                       }
[17:45:46.109]                       {
[17:45:46.109]                         lapply(seq_along(...future.elements_ii), 
[17:45:46.109]                           FUN = function(jj) {
[17:45:46.109]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:46.109]                             ...future.FUN(...future.X_jj, ...)
[17:45:46.109]                           })
[17:45:46.109]                       }
[17:45:46.109]                     }, args = future.call.arguments)
[17:45:46.109]                   }
[17:45:46.109]                 }, immediateCondition = function(cond) {
[17:45:46.109]                   sendCondition <- ...future.makeSendCondition()
[17:45:46.109]                   sendCondition(cond)
[17:45:46.109]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:46.109]                   {
[17:45:46.109]                     inherits <- base::inherits
[17:45:46.109]                     invokeRestart <- base::invokeRestart
[17:45:46.109]                     is.null <- base::is.null
[17:45:46.109]                     muffled <- FALSE
[17:45:46.109]                     if (inherits(cond, "message")) {
[17:45:46.109]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:46.109]                       if (muffled) 
[17:45:46.109]                         invokeRestart("muffleMessage")
[17:45:46.109]                     }
[17:45:46.109]                     else if (inherits(cond, "warning")) {
[17:45:46.109]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:46.109]                       if (muffled) 
[17:45:46.109]                         invokeRestart("muffleWarning")
[17:45:46.109]                     }
[17:45:46.109]                     else if (inherits(cond, "condition")) {
[17:45:46.109]                       if (!is.null(pattern)) {
[17:45:46.109]                         computeRestarts <- base::computeRestarts
[17:45:46.109]                         grepl <- base::grepl
[17:45:46.109]                         restarts <- computeRestarts(cond)
[17:45:46.109]                         for (restart in restarts) {
[17:45:46.109]                           name <- restart$name
[17:45:46.109]                           if (is.null(name)) 
[17:45:46.109]                             next
[17:45:46.109]                           if (!grepl(pattern, name)) 
[17:45:46.109]                             next
[17:45:46.109]                           invokeRestart(restart)
[17:45:46.109]                           muffled <- TRUE
[17:45:46.109]                           break
[17:45:46.109]                         }
[17:45:46.109]                       }
[17:45:46.109]                     }
[17:45:46.109]                     invisible(muffled)
[17:45:46.109]                   }
[17:45:46.109]                   muffleCondition(cond)
[17:45:46.109]                 })
[17:45:46.109]             }))
[17:45:46.109]             future::FutureResult(value = ...future.value$value, 
[17:45:46.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:46.109]                   ...future.rng), globalenv = if (FALSE) 
[17:45:46.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:46.109]                     ...future.globalenv.names))
[17:45:46.109]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:46.109]         }, condition = base::local({
[17:45:46.109]             c <- base::c
[17:45:46.109]             inherits <- base::inherits
[17:45:46.109]             invokeRestart <- base::invokeRestart
[17:45:46.109]             length <- base::length
[17:45:46.109]             list <- base::list
[17:45:46.109]             seq.int <- base::seq.int
[17:45:46.109]             signalCondition <- base::signalCondition
[17:45:46.109]             sys.calls <- base::sys.calls
[17:45:46.109]             `[[` <- base::`[[`
[17:45:46.109]             `+` <- base::`+`
[17:45:46.109]             `<<-` <- base::`<<-`
[17:45:46.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:46.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:46.109]                   3L)]
[17:45:46.109]             }
[17:45:46.109]             function(cond) {
[17:45:46.109]                 is_error <- inherits(cond, "error")
[17:45:46.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:46.109]                   NULL)
[17:45:46.109]                 if (is_error) {
[17:45:46.109]                   sessionInformation <- function() {
[17:45:46.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:46.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:46.109]                       search = base::search(), system = base::Sys.info())
[17:45:46.109]                   }
[17:45:46.109]                   ...future.conditions[[length(...future.conditions) + 
[17:45:46.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:46.109]                     cond$call), session = sessionInformation(), 
[17:45:46.109]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:46.109]                   signalCondition(cond)
[17:45:46.109]                 }
[17:45:46.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:46.109]                 "immediateCondition"))) {
[17:45:46.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:46.109]                   ...future.conditions[[length(...future.conditions) + 
[17:45:46.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:46.109]                   if (TRUE && !signal) {
[17:45:46.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:46.109]                     {
[17:45:46.109]                       inherits <- base::inherits
[17:45:46.109]                       invokeRestart <- base::invokeRestart
[17:45:46.109]                       is.null <- base::is.null
[17:45:46.109]                       muffled <- FALSE
[17:45:46.109]                       if (inherits(cond, "message")) {
[17:45:46.109]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:46.109]                         if (muffled) 
[17:45:46.109]                           invokeRestart("muffleMessage")
[17:45:46.109]                       }
[17:45:46.109]                       else if (inherits(cond, "warning")) {
[17:45:46.109]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:46.109]                         if (muffled) 
[17:45:46.109]                           invokeRestart("muffleWarning")
[17:45:46.109]                       }
[17:45:46.109]                       else if (inherits(cond, "condition")) {
[17:45:46.109]                         if (!is.null(pattern)) {
[17:45:46.109]                           computeRestarts <- base::computeRestarts
[17:45:46.109]                           grepl <- base::grepl
[17:45:46.109]                           restarts <- computeRestarts(cond)
[17:45:46.109]                           for (restart in restarts) {
[17:45:46.109]                             name <- restart$name
[17:45:46.109]                             if (is.null(name)) 
[17:45:46.109]                               next
[17:45:46.109]                             if (!grepl(pattern, name)) 
[17:45:46.109]                               next
[17:45:46.109]                             invokeRestart(restart)
[17:45:46.109]                             muffled <- TRUE
[17:45:46.109]                             break
[17:45:46.109]                           }
[17:45:46.109]                         }
[17:45:46.109]                       }
[17:45:46.109]                       invisible(muffled)
[17:45:46.109]                     }
[17:45:46.109]                     muffleCondition(cond, pattern = "^muffle")
[17:45:46.109]                   }
[17:45:46.109]                 }
[17:45:46.109]                 else {
[17:45:46.109]                   if (TRUE) {
[17:45:46.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:46.109]                     {
[17:45:46.109]                       inherits <- base::inherits
[17:45:46.109]                       invokeRestart <- base::invokeRestart
[17:45:46.109]                       is.null <- base::is.null
[17:45:46.109]                       muffled <- FALSE
[17:45:46.109]                       if (inherits(cond, "message")) {
[17:45:46.109]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:46.109]                         if (muffled) 
[17:45:46.109]                           invokeRestart("muffleMessage")
[17:45:46.109]                       }
[17:45:46.109]                       else if (inherits(cond, "warning")) {
[17:45:46.109]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:46.109]                         if (muffled) 
[17:45:46.109]                           invokeRestart("muffleWarning")
[17:45:46.109]                       }
[17:45:46.109]                       else if (inherits(cond, "condition")) {
[17:45:46.109]                         if (!is.null(pattern)) {
[17:45:46.109]                           computeRestarts <- base::computeRestarts
[17:45:46.109]                           grepl <- base::grepl
[17:45:46.109]                           restarts <- computeRestarts(cond)
[17:45:46.109]                           for (restart in restarts) {
[17:45:46.109]                             name <- restart$name
[17:45:46.109]                             if (is.null(name)) 
[17:45:46.109]                               next
[17:45:46.109]                             if (!grepl(pattern, name)) 
[17:45:46.109]                               next
[17:45:46.109]                             invokeRestart(restart)
[17:45:46.109]                             muffled <- TRUE
[17:45:46.109]                             break
[17:45:46.109]                           }
[17:45:46.109]                         }
[17:45:46.109]                       }
[17:45:46.109]                       invisible(muffled)
[17:45:46.109]                     }
[17:45:46.109]                     muffleCondition(cond, pattern = "^muffle")
[17:45:46.109]                   }
[17:45:46.109]                 }
[17:45:46.109]             }
[17:45:46.109]         }))
[17:45:46.109]     }, error = function(ex) {
[17:45:46.109]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:46.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:46.109]                 ...future.rng), started = ...future.startTime, 
[17:45:46.109]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:46.109]             version = "1.8"), class = "FutureResult")
[17:45:46.109]     }, finally = {
[17:45:46.109]         if (!identical(...future.workdir, getwd())) 
[17:45:46.109]             setwd(...future.workdir)
[17:45:46.109]         {
[17:45:46.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:46.109]                 ...future.oldOptions$nwarnings <- NULL
[17:45:46.109]             }
[17:45:46.109]             base::options(...future.oldOptions)
[17:45:46.109]             if (.Platform$OS.type == "windows") {
[17:45:46.109]                 old_names <- names(...future.oldEnvVars)
[17:45:46.109]                 envs <- base::Sys.getenv()
[17:45:46.109]                 names <- names(envs)
[17:45:46.109]                 common <- intersect(names, old_names)
[17:45:46.109]                 added <- setdiff(names, old_names)
[17:45:46.109]                 removed <- setdiff(old_names, names)
[17:45:46.109]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:46.109]                   envs[common]]
[17:45:46.109]                 NAMES <- toupper(changed)
[17:45:46.109]                 args <- list()
[17:45:46.109]                 for (kk in seq_along(NAMES)) {
[17:45:46.109]                   name <- changed[[kk]]
[17:45:46.109]                   NAME <- NAMES[[kk]]
[17:45:46.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:46.109]                     next
[17:45:46.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:46.109]                 }
[17:45:46.109]                 NAMES <- toupper(added)
[17:45:46.109]                 for (kk in seq_along(NAMES)) {
[17:45:46.109]                   name <- added[[kk]]
[17:45:46.109]                   NAME <- NAMES[[kk]]
[17:45:46.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:46.109]                     next
[17:45:46.109]                   args[[name]] <- ""
[17:45:46.109]                 }
[17:45:46.109]                 NAMES <- toupper(removed)
[17:45:46.109]                 for (kk in seq_along(NAMES)) {
[17:45:46.109]                   name <- removed[[kk]]
[17:45:46.109]                   NAME <- NAMES[[kk]]
[17:45:46.109]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:46.109]                     next
[17:45:46.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:46.109]                 }
[17:45:46.109]                 if (length(args) > 0) 
[17:45:46.109]                   base::do.call(base::Sys.setenv, args = args)
[17:45:46.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:46.109]             }
[17:45:46.109]             else {
[17:45:46.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:46.109]             }
[17:45:46.109]             {
[17:45:46.109]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:46.109]                   0L) {
[17:45:46.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:46.109]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:46.109]                   base::options(opts)
[17:45:46.109]                 }
[17:45:46.109]                 {
[17:45:46.109]                   {
[17:45:46.109]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:46.109]                     NULL
[17:45:46.109]                   }
[17:45:46.109]                   options(future.plan = NULL)
[17:45:46.109]                   if (is.na(NA_character_)) 
[17:45:46.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:46.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:46.109]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:46.109]                     .init = FALSE)
[17:45:46.109]                 }
[17:45:46.109]             }
[17:45:46.109]         }
[17:45:46.109]     })
[17:45:46.109]     if (TRUE) {
[17:45:46.109]         base::sink(type = "output", split = FALSE)
[17:45:46.109]         if (TRUE) {
[17:45:46.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:46.109]         }
[17:45:46.109]         else {
[17:45:46.109]             ...future.result["stdout"] <- base::list(NULL)
[17:45:46.109]         }
[17:45:46.109]         base::close(...future.stdout)
[17:45:46.109]         ...future.stdout <- NULL
[17:45:46.109]     }
[17:45:46.109]     ...future.result$conditions <- ...future.conditions
[17:45:46.109]     ...future.result$finished <- base::Sys.time()
[17:45:46.109]     ...future.result
[17:45:46.109] }
[17:45:46.112] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[17:45:46.112] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[17:45:46.112] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[17:45:46.113] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:46.113] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:46.113] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:45:46.113] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:45:46.114] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:46.114] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:46.114] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:46.114] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:46.114] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[17:45:46.115] MultisessionFuture started
[17:45:46.115] - Launch lazy future ... done
[17:45:46.115] run() for ‘MultisessionFuture’ ... done
[17:45:46.115] Created future:
[17:45:46.115] MultisessionFuture:
[17:45:46.115] Label: ‘future_lapply-1’
[17:45:46.115] Expression:
[17:45:46.115] {
[17:45:46.115]     do.call(function(...) {
[17:45:46.115]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:46.115]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:46.115]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:46.115]             on.exit(options(oopts), add = TRUE)
[17:45:46.115]         }
[17:45:46.115]         {
[17:45:46.115]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:46.115]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:46.115]                 ...future.FUN(...future.X_jj, ...)
[17:45:46.115]             })
[17:45:46.115]         }
[17:45:46.115]     }, args = future.call.arguments)
[17:45:46.115] }
[17:45:46.115] Lazy evaluation: FALSE
[17:45:46.115] Asynchronous evaluation: TRUE
[17:45:46.115] Local evaluation: TRUE
[17:45:46.115] Environment: R_GlobalEnv
[17:45:46.115] Capture standard output: TRUE
[17:45:46.115] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:46.115] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:46.115] Packages: <none>
[17:45:46.115] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:46.115] Resolved: FALSE
[17:45:46.115] Value: <not collected>
[17:45:46.115] Conditions captured: <none>
[17:45:46.115] Early signaling: FALSE
[17:45:46.115] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:46.115] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:46.127] Chunk #1 of 2 ... DONE
[17:45:46.127] Chunk #2 of 2 ...
[17:45:46.127]  - Finding globals in 'X' for chunk #2 ...
[17:45:46.127] getGlobalsAndPackages() ...
[17:45:46.127] Searching for globals...
[17:45:46.128] 
[17:45:46.128] Searching for globals ... DONE
[17:45:46.128] - globals: [0] <none>
[17:45:46.128] getGlobalsAndPackages() ... DONE
[17:45:46.128]    + additional globals found: [n=0] 
[17:45:46.128]    + additional namespaces needed: [n=0] 
[17:45:46.128]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:46.128]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:46.128]  - seeds: <none>
[17:45:46.128]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:46.128] getGlobalsAndPackages() ...
[17:45:46.129] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:46.129] Resolving globals: FALSE
[17:45:46.129] Tweak future expression to call with '...' arguments ...
[17:45:46.129] {
[17:45:46.129]     do.call(function(...) {
[17:45:46.129]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:46.129]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:46.129]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:46.129]             on.exit(options(oopts), add = TRUE)
[17:45:46.129]         }
[17:45:46.129]         {
[17:45:46.129]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:46.129]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:46.129]                 ...future.FUN(...future.X_jj, ...)
[17:45:46.129]             })
[17:45:46.129]         }
[17:45:46.129]     }, args = future.call.arguments)
[17:45:46.129] }
[17:45:46.129] Tweak future expression to call with '...' arguments ... DONE
[17:45:46.129] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:46.130] 
[17:45:46.130] getGlobalsAndPackages() ... DONE
[17:45:46.130] run() for ‘Future’ ...
[17:45:46.130] - state: ‘created’
[17:45:46.130] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:46.144] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:46.144] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:46.144]   - Field: ‘node’
[17:45:46.144]   - Field: ‘label’
[17:45:46.144]   - Field: ‘local’
[17:45:46.144]   - Field: ‘owner’
[17:45:46.144]   - Field: ‘envir’
[17:45:46.145]   - Field: ‘workers’
[17:45:46.145]   - Field: ‘packages’
[17:45:46.145]   - Field: ‘gc’
[17:45:46.145]   - Field: ‘conditions’
[17:45:46.145]   - Field: ‘persistent’
[17:45:46.145]   - Field: ‘expr’
[17:45:46.145]   - Field: ‘uuid’
[17:45:46.145]   - Field: ‘seed’
[17:45:46.145]   - Field: ‘version’
[17:45:46.145]   - Field: ‘result’
[17:45:46.145]   - Field: ‘asynchronous’
[17:45:46.146]   - Field: ‘calls’
[17:45:46.146]   - Field: ‘globals’
[17:45:46.146]   - Field: ‘stdout’
[17:45:46.146]   - Field: ‘earlySignal’
[17:45:46.146]   - Field: ‘lazy’
[17:45:46.146]   - Field: ‘state’
[17:45:46.146] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:46.146] - Launch lazy future ...
[17:45:46.146] Packages needed by the future expression (n = 0): <none>
[17:45:46.147] Packages needed by future strategies (n = 0): <none>
[17:45:46.147] {
[17:45:46.147]     {
[17:45:46.147]         {
[17:45:46.147]             ...future.startTime <- base::Sys.time()
[17:45:46.147]             {
[17:45:46.147]                 {
[17:45:46.147]                   {
[17:45:46.147]                     {
[17:45:46.147]                       base::local({
[17:45:46.147]                         has_future <- base::requireNamespace("future", 
[17:45:46.147]                           quietly = TRUE)
[17:45:46.147]                         if (has_future) {
[17:45:46.147]                           ns <- base::getNamespace("future")
[17:45:46.147]                           version <- ns[[".package"]][["version"]]
[17:45:46.147]                           if (is.null(version)) 
[17:45:46.147]                             version <- utils::packageVersion("future")
[17:45:46.147]                         }
[17:45:46.147]                         else {
[17:45:46.147]                           version <- NULL
[17:45:46.147]                         }
[17:45:46.147]                         if (!has_future || version < "1.8.0") {
[17:45:46.147]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:46.147]                             "", base::R.version$version.string), 
[17:45:46.147]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:46.147]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:46.147]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:46.147]                               "release", "version")], collapse = " "), 
[17:45:46.147]                             hostname = base::Sys.info()[["nodename"]])
[17:45:46.147]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:46.147]                             info)
[17:45:46.147]                           info <- base::paste(info, collapse = "; ")
[17:45:46.147]                           if (!has_future) {
[17:45:46.147]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:46.147]                               info)
[17:45:46.147]                           }
[17:45:46.147]                           else {
[17:45:46.147]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:46.147]                               info, version)
[17:45:46.147]                           }
[17:45:46.147]                           base::stop(msg)
[17:45:46.147]                         }
[17:45:46.147]                       })
[17:45:46.147]                     }
[17:45:46.147]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:46.147]                     base::options(mc.cores = 1L)
[17:45:46.147]                   }
[17:45:46.147]                   ...future.strategy.old <- future::plan("list")
[17:45:46.147]                   options(future.plan = NULL)
[17:45:46.147]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:46.147]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:46.147]                 }
[17:45:46.147]                 ...future.workdir <- getwd()
[17:45:46.147]             }
[17:45:46.147]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:46.147]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:46.147]         }
[17:45:46.147]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:46.147]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:46.147]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:46.147]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:46.147]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:46.147]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:46.147]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:46.147]             base::names(...future.oldOptions))
[17:45:46.147]     }
[17:45:46.147]     if (FALSE) {
[17:45:46.147]     }
[17:45:46.147]     else {
[17:45:46.147]         if (TRUE) {
[17:45:46.147]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:46.147]                 open = "w")
[17:45:46.147]         }
[17:45:46.147]         else {
[17:45:46.147]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:46.147]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:46.147]         }
[17:45:46.147]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:46.147]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:46.147]             base::sink(type = "output", split = FALSE)
[17:45:46.147]             base::close(...future.stdout)
[17:45:46.147]         }, add = TRUE)
[17:45:46.147]     }
[17:45:46.147]     ...future.frame <- base::sys.nframe()
[17:45:46.147]     ...future.conditions <- base::list()
[17:45:46.147]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:46.147]     if (FALSE) {
[17:45:46.147]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:46.147]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:46.147]     }
[17:45:46.147]     ...future.result <- base::tryCatch({
[17:45:46.147]         base::withCallingHandlers({
[17:45:46.147]             ...future.value <- base::withVisible(base::local({
[17:45:46.147]                 ...future.makeSendCondition <- base::local({
[17:45:46.147]                   sendCondition <- NULL
[17:45:46.147]                   function(frame = 1L) {
[17:45:46.147]                     if (is.function(sendCondition)) 
[17:45:46.147]                       return(sendCondition)
[17:45:46.147]                     ns <- getNamespace("parallel")
[17:45:46.147]                     if (exists("sendData", mode = "function", 
[17:45:46.147]                       envir = ns)) {
[17:45:46.147]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:46.147]                         envir = ns)
[17:45:46.147]                       envir <- sys.frame(frame)
[17:45:46.147]                       master <- NULL
[17:45:46.147]                       while (!identical(envir, .GlobalEnv) && 
[17:45:46.147]                         !identical(envir, emptyenv())) {
[17:45:46.147]                         if (exists("master", mode = "list", envir = envir, 
[17:45:46.147]                           inherits = FALSE)) {
[17:45:46.147]                           master <- get("master", mode = "list", 
[17:45:46.147]                             envir = envir, inherits = FALSE)
[17:45:46.147]                           if (inherits(master, c("SOCKnode", 
[17:45:46.147]                             "SOCK0node"))) {
[17:45:46.147]                             sendCondition <<- function(cond) {
[17:45:46.147]                               data <- list(type = "VALUE", value = cond, 
[17:45:46.147]                                 success = TRUE)
[17:45:46.147]                               parallel_sendData(master, data)
[17:45:46.147]                             }
[17:45:46.147]                             return(sendCondition)
[17:45:46.147]                           }
[17:45:46.147]                         }
[17:45:46.147]                         frame <- frame + 1L
[17:45:46.147]                         envir <- sys.frame(frame)
[17:45:46.147]                       }
[17:45:46.147]                     }
[17:45:46.147]                     sendCondition <<- function(cond) NULL
[17:45:46.147]                   }
[17:45:46.147]                 })
[17:45:46.147]                 withCallingHandlers({
[17:45:46.147]                   {
[17:45:46.147]                     do.call(function(...) {
[17:45:46.147]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:46.147]                       if (!identical(...future.globals.maxSize.org, 
[17:45:46.147]                         ...future.globals.maxSize)) {
[17:45:46.147]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:46.147]                         on.exit(options(oopts), add = TRUE)
[17:45:46.147]                       }
[17:45:46.147]                       {
[17:45:46.147]                         lapply(seq_along(...future.elements_ii), 
[17:45:46.147]                           FUN = function(jj) {
[17:45:46.147]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:46.147]                             ...future.FUN(...future.X_jj, ...)
[17:45:46.147]                           })
[17:45:46.147]                       }
[17:45:46.147]                     }, args = future.call.arguments)
[17:45:46.147]                   }
[17:45:46.147]                 }, immediateCondition = function(cond) {
[17:45:46.147]                   sendCondition <- ...future.makeSendCondition()
[17:45:46.147]                   sendCondition(cond)
[17:45:46.147]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:46.147]                   {
[17:45:46.147]                     inherits <- base::inherits
[17:45:46.147]                     invokeRestart <- base::invokeRestart
[17:45:46.147]                     is.null <- base::is.null
[17:45:46.147]                     muffled <- FALSE
[17:45:46.147]                     if (inherits(cond, "message")) {
[17:45:46.147]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:46.147]                       if (muffled) 
[17:45:46.147]                         invokeRestart("muffleMessage")
[17:45:46.147]                     }
[17:45:46.147]                     else if (inherits(cond, "warning")) {
[17:45:46.147]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:46.147]                       if (muffled) 
[17:45:46.147]                         invokeRestart("muffleWarning")
[17:45:46.147]                     }
[17:45:46.147]                     else if (inherits(cond, "condition")) {
[17:45:46.147]                       if (!is.null(pattern)) {
[17:45:46.147]                         computeRestarts <- base::computeRestarts
[17:45:46.147]                         grepl <- base::grepl
[17:45:46.147]                         restarts <- computeRestarts(cond)
[17:45:46.147]                         for (restart in restarts) {
[17:45:46.147]                           name <- restart$name
[17:45:46.147]                           if (is.null(name)) 
[17:45:46.147]                             next
[17:45:46.147]                           if (!grepl(pattern, name)) 
[17:45:46.147]                             next
[17:45:46.147]                           invokeRestart(restart)
[17:45:46.147]                           muffled <- TRUE
[17:45:46.147]                           break
[17:45:46.147]                         }
[17:45:46.147]                       }
[17:45:46.147]                     }
[17:45:46.147]                     invisible(muffled)
[17:45:46.147]                   }
[17:45:46.147]                   muffleCondition(cond)
[17:45:46.147]                 })
[17:45:46.147]             }))
[17:45:46.147]             future::FutureResult(value = ...future.value$value, 
[17:45:46.147]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:46.147]                   ...future.rng), globalenv = if (FALSE) 
[17:45:46.147]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:46.147]                     ...future.globalenv.names))
[17:45:46.147]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:46.147]         }, condition = base::local({
[17:45:46.147]             c <- base::c
[17:45:46.147]             inherits <- base::inherits
[17:45:46.147]             invokeRestart <- base::invokeRestart
[17:45:46.147]             length <- base::length
[17:45:46.147]             list <- base::list
[17:45:46.147]             seq.int <- base::seq.int
[17:45:46.147]             signalCondition <- base::signalCondition
[17:45:46.147]             sys.calls <- base::sys.calls
[17:45:46.147]             `[[` <- base::`[[`
[17:45:46.147]             `+` <- base::`+`
[17:45:46.147]             `<<-` <- base::`<<-`
[17:45:46.147]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:46.147]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:46.147]                   3L)]
[17:45:46.147]             }
[17:45:46.147]             function(cond) {
[17:45:46.147]                 is_error <- inherits(cond, "error")
[17:45:46.147]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:46.147]                   NULL)
[17:45:46.147]                 if (is_error) {
[17:45:46.147]                   sessionInformation <- function() {
[17:45:46.147]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:46.147]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:46.147]                       search = base::search(), system = base::Sys.info())
[17:45:46.147]                   }
[17:45:46.147]                   ...future.conditions[[length(...future.conditions) + 
[17:45:46.147]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:46.147]                     cond$call), session = sessionInformation(), 
[17:45:46.147]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:46.147]                   signalCondition(cond)
[17:45:46.147]                 }
[17:45:46.147]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:46.147]                 "immediateCondition"))) {
[17:45:46.147]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:46.147]                   ...future.conditions[[length(...future.conditions) + 
[17:45:46.147]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:46.147]                   if (TRUE && !signal) {
[17:45:46.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:46.147]                     {
[17:45:46.147]                       inherits <- base::inherits
[17:45:46.147]                       invokeRestart <- base::invokeRestart
[17:45:46.147]                       is.null <- base::is.null
[17:45:46.147]                       muffled <- FALSE
[17:45:46.147]                       if (inherits(cond, "message")) {
[17:45:46.147]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:46.147]                         if (muffled) 
[17:45:46.147]                           invokeRestart("muffleMessage")
[17:45:46.147]                       }
[17:45:46.147]                       else if (inherits(cond, "warning")) {
[17:45:46.147]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:46.147]                         if (muffled) 
[17:45:46.147]                           invokeRestart("muffleWarning")
[17:45:46.147]                       }
[17:45:46.147]                       else if (inherits(cond, "condition")) {
[17:45:46.147]                         if (!is.null(pattern)) {
[17:45:46.147]                           computeRestarts <- base::computeRestarts
[17:45:46.147]                           grepl <- base::grepl
[17:45:46.147]                           restarts <- computeRestarts(cond)
[17:45:46.147]                           for (restart in restarts) {
[17:45:46.147]                             name <- restart$name
[17:45:46.147]                             if (is.null(name)) 
[17:45:46.147]                               next
[17:45:46.147]                             if (!grepl(pattern, name)) 
[17:45:46.147]                               next
[17:45:46.147]                             invokeRestart(restart)
[17:45:46.147]                             muffled <- TRUE
[17:45:46.147]                             break
[17:45:46.147]                           }
[17:45:46.147]                         }
[17:45:46.147]                       }
[17:45:46.147]                       invisible(muffled)
[17:45:46.147]                     }
[17:45:46.147]                     muffleCondition(cond, pattern = "^muffle")
[17:45:46.147]                   }
[17:45:46.147]                 }
[17:45:46.147]                 else {
[17:45:46.147]                   if (TRUE) {
[17:45:46.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:46.147]                     {
[17:45:46.147]                       inherits <- base::inherits
[17:45:46.147]                       invokeRestart <- base::invokeRestart
[17:45:46.147]                       is.null <- base::is.null
[17:45:46.147]                       muffled <- FALSE
[17:45:46.147]                       if (inherits(cond, "message")) {
[17:45:46.147]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:46.147]                         if (muffled) 
[17:45:46.147]                           invokeRestart("muffleMessage")
[17:45:46.147]                       }
[17:45:46.147]                       else if (inherits(cond, "warning")) {
[17:45:46.147]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:46.147]                         if (muffled) 
[17:45:46.147]                           invokeRestart("muffleWarning")
[17:45:46.147]                       }
[17:45:46.147]                       else if (inherits(cond, "condition")) {
[17:45:46.147]                         if (!is.null(pattern)) {
[17:45:46.147]                           computeRestarts <- base::computeRestarts
[17:45:46.147]                           grepl <- base::grepl
[17:45:46.147]                           restarts <- computeRestarts(cond)
[17:45:46.147]                           for (restart in restarts) {
[17:45:46.147]                             name <- restart$name
[17:45:46.147]                             if (is.null(name)) 
[17:45:46.147]                               next
[17:45:46.147]                             if (!grepl(pattern, name)) 
[17:45:46.147]                               next
[17:45:46.147]                             invokeRestart(restart)
[17:45:46.147]                             muffled <- TRUE
[17:45:46.147]                             break
[17:45:46.147]                           }
[17:45:46.147]                         }
[17:45:46.147]                       }
[17:45:46.147]                       invisible(muffled)
[17:45:46.147]                     }
[17:45:46.147]                     muffleCondition(cond, pattern = "^muffle")
[17:45:46.147]                   }
[17:45:46.147]                 }
[17:45:46.147]             }
[17:45:46.147]         }))
[17:45:46.147]     }, error = function(ex) {
[17:45:46.147]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:46.147]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:46.147]                 ...future.rng), started = ...future.startTime, 
[17:45:46.147]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:46.147]             version = "1.8"), class = "FutureResult")
[17:45:46.147]     }, finally = {
[17:45:46.147]         if (!identical(...future.workdir, getwd())) 
[17:45:46.147]             setwd(...future.workdir)
[17:45:46.147]         {
[17:45:46.147]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:46.147]                 ...future.oldOptions$nwarnings <- NULL
[17:45:46.147]             }
[17:45:46.147]             base::options(...future.oldOptions)
[17:45:46.147]             if (.Platform$OS.type == "windows") {
[17:45:46.147]                 old_names <- names(...future.oldEnvVars)
[17:45:46.147]                 envs <- base::Sys.getenv()
[17:45:46.147]                 names <- names(envs)
[17:45:46.147]                 common <- intersect(names, old_names)
[17:45:46.147]                 added <- setdiff(names, old_names)
[17:45:46.147]                 removed <- setdiff(old_names, names)
[17:45:46.147]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:46.147]                   envs[common]]
[17:45:46.147]                 NAMES <- toupper(changed)
[17:45:46.147]                 args <- list()
[17:45:46.147]                 for (kk in seq_along(NAMES)) {
[17:45:46.147]                   name <- changed[[kk]]
[17:45:46.147]                   NAME <- NAMES[[kk]]
[17:45:46.147]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:46.147]                     next
[17:45:46.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:46.147]                 }
[17:45:46.147]                 NAMES <- toupper(added)
[17:45:46.147]                 for (kk in seq_along(NAMES)) {
[17:45:46.147]                   name <- added[[kk]]
[17:45:46.147]                   NAME <- NAMES[[kk]]
[17:45:46.147]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:46.147]                     next
[17:45:46.147]                   args[[name]] <- ""
[17:45:46.147]                 }
[17:45:46.147]                 NAMES <- toupper(removed)
[17:45:46.147]                 for (kk in seq_along(NAMES)) {
[17:45:46.147]                   name <- removed[[kk]]
[17:45:46.147]                   NAME <- NAMES[[kk]]
[17:45:46.147]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:46.147]                     next
[17:45:46.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:46.147]                 }
[17:45:46.147]                 if (length(args) > 0) 
[17:45:46.147]                   base::do.call(base::Sys.setenv, args = args)
[17:45:46.147]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:46.147]             }
[17:45:46.147]             else {
[17:45:46.147]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:46.147]             }
[17:45:46.147]             {
[17:45:46.147]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:46.147]                   0L) {
[17:45:46.147]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:46.147]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:46.147]                   base::options(opts)
[17:45:46.147]                 }
[17:45:46.147]                 {
[17:45:46.147]                   {
[17:45:46.147]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:46.147]                     NULL
[17:45:46.147]                   }
[17:45:46.147]                   options(future.plan = NULL)
[17:45:46.147]                   if (is.na(NA_character_)) 
[17:45:46.147]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:46.147]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:46.147]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:46.147]                     .init = FALSE)
[17:45:46.147]                 }
[17:45:46.147]             }
[17:45:46.147]         }
[17:45:46.147]     })
[17:45:46.147]     if (TRUE) {
[17:45:46.147]         base::sink(type = "output", split = FALSE)
[17:45:46.147]         if (TRUE) {
[17:45:46.147]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:46.147]         }
[17:45:46.147]         else {
[17:45:46.147]             ...future.result["stdout"] <- base::list(NULL)
[17:45:46.147]         }
[17:45:46.147]         base::close(...future.stdout)
[17:45:46.147]         ...future.stdout <- NULL
[17:45:46.147]     }
[17:45:46.147]     ...future.result$conditions <- ...future.conditions
[17:45:46.147]     ...future.result$finished <- base::Sys.time()
[17:45:46.147]     ...future.result
[17:45:46.147] }
[17:45:46.150] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[17:45:46.150] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[17:45:46.150] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[17:45:46.151] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:45:46.151] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:45:46.151] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:45:46.151] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:45:46.152] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:46.152] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:46.152] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:46.152] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:46.153] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[17:45:46.153] MultisessionFuture started
[17:45:46.153] - Launch lazy future ... done
[17:45:46.153] run() for ‘MultisessionFuture’ ... done
[17:45:46.154] Created future:
[17:45:46.154] MultisessionFuture:
[17:45:46.154] Label: ‘future_lapply-2’
[17:45:46.154] Expression:
[17:45:46.154] {
[17:45:46.154]     do.call(function(...) {
[17:45:46.154]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:46.154]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:46.154]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:46.154]             on.exit(options(oopts), add = TRUE)
[17:45:46.154]         }
[17:45:46.154]         {
[17:45:46.154]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:46.154]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:46.154]                 ...future.FUN(...future.X_jj, ...)
[17:45:46.154]             })
[17:45:46.154]         }
[17:45:46.154]     }, args = future.call.arguments)
[17:45:46.154] }
[17:45:46.154] Lazy evaluation: FALSE
[17:45:46.154] Asynchronous evaluation: TRUE
[17:45:46.154] Local evaluation: TRUE
[17:45:46.154] Environment: R_GlobalEnv
[17:45:46.154] Capture standard output: TRUE
[17:45:46.154] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:46.154] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:46.154] Packages: <none>
[17:45:46.154] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:46.154] Resolved: FALSE
[17:45:46.154] Value: <not collected>
[17:45:46.154] Conditions captured: <none>
[17:45:46.154] Early signaling: FALSE
[17:45:46.154] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:46.154] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:46.165] Chunk #2 of 2 ... DONE
[17:45:46.165] Launching 2 futures (chunks) ... DONE
[17:45:46.165] Resolving 2 futures (chunks) ...
[17:45:46.165] resolve() on list ...
[17:45:46.166]  recursive: 0
[17:45:46.166]  length: 2
[17:45:46.166] 
[17:45:46.208] receiveMessageFromWorker() for ClusterFuture ...
[17:45:46.208] - Validating connection of MultisessionFuture
[17:45:46.208] - received message: FutureResult
[17:45:46.208] - Received FutureResult
[17:45:46.208] - Erased future from FutureRegistry
[17:45:46.208] result() for ClusterFuture ...
[17:45:46.209] - result already collected: FutureResult
[17:45:46.209] result() for ClusterFuture ... done
[17:45:46.209] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:46.209] Future #2
[17:45:46.209] result() for ClusterFuture ...
[17:45:46.209] - result already collected: FutureResult
[17:45:46.209] result() for ClusterFuture ... done
[17:45:46.209] result() for ClusterFuture ...
[17:45:46.209] - result already collected: FutureResult
[17:45:46.209] result() for ClusterFuture ... done
[17:45:46.209] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:46.210] - nx: 2
[17:45:46.210] - relay: TRUE
[17:45:46.210] - stdout: TRUE
[17:45:46.210] - signal: TRUE
[17:45:46.210] - resignal: FALSE
[17:45:46.210] - force: TRUE
[17:45:46.210] - relayed: [n=2] FALSE, FALSE
[17:45:46.210] - queued futures: [n=2] FALSE, FALSE
[17:45:46.210]  - until=1
[17:45:46.210]  - relaying element #1
[17:45:46.210] - relayed: [n=2] FALSE, FALSE
[17:45:46.210] - queued futures: [n=2] FALSE, TRUE
[17:45:46.210] signalConditionsASAP(NULL, pos=2) ... done
[17:45:46.211]  length: 1 (resolved future 2)
[17:45:46.658] receiveMessageFromWorker() for ClusterFuture ...
[17:45:46.658] - Validating connection of MultisessionFuture
[17:45:46.658] - received message: FutureResult
[17:45:46.658] - Received FutureResult
[17:45:46.659] - Erased future from FutureRegistry
[17:45:46.659] result() for ClusterFuture ...
[17:45:46.659] - result already collected: FutureResult
[17:45:46.659] result() for ClusterFuture ... done
[17:45:46.659] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:46.659] Future #1
[17:45:46.659] result() for ClusterFuture ...
[17:45:46.659] - result already collected: FutureResult
[17:45:46.659] result() for ClusterFuture ... done
[17:45:46.659] result() for ClusterFuture ...
[17:45:46.660] - result already collected: FutureResult
[17:45:46.660] result() for ClusterFuture ... done
[17:45:46.660] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:46.660] - nx: 2
[17:45:46.660] - relay: TRUE
[17:45:46.660] - stdout: TRUE
[17:45:46.660] - signal: TRUE
[17:45:46.660] - resignal: FALSE
[17:45:46.660] - force: TRUE
[17:45:46.660] - relayed: [n=2] FALSE, FALSE
[17:45:46.660] - queued futures: [n=2] FALSE, TRUE
[17:45:46.661]  - until=1
[17:45:46.661]  - relaying element #1
[17:45:46.661] result() for ClusterFuture ...
[17:45:46.661] - result already collected: FutureResult
[17:45:46.661] result() for ClusterFuture ... done
[17:45:46.661] result() for ClusterFuture ...
[17:45:46.661] - result already collected: FutureResult
[17:45:46.661] result() for ClusterFuture ... done
[17:45:46.661] result() for ClusterFuture ...
[17:45:46.661] - result already collected: FutureResult
[17:45:46.661] result() for ClusterFuture ... done
[17:45:46.662] result() for ClusterFuture ...
[17:45:46.662] - result already collected: FutureResult
[17:45:46.662] result() for ClusterFuture ... done
[17:45:46.662] - relayed: [n=2] TRUE, FALSE
[17:45:46.662] - queued futures: [n=2] TRUE, TRUE
[17:45:46.662] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:46.662]  length: 0 (resolved future 1)
[17:45:46.662] Relaying remaining futures
[17:45:46.662] signalConditionsASAP(NULL, pos=0) ...
[17:45:46.662] - nx: 2
[17:45:46.662] - relay: TRUE
[17:45:46.662] - stdout: TRUE
[17:45:46.663] - signal: TRUE
[17:45:46.663] - resignal: FALSE
[17:45:46.663] - force: TRUE
[17:45:46.663] - relayed: [n=2] TRUE, FALSE
[17:45:46.663] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:46.663]  - relaying element #2
[17:45:46.663] result() for ClusterFuture ...
[17:45:46.663] - result already collected: FutureResult
[17:45:46.663] result() for ClusterFuture ... done
[17:45:46.663] result() for ClusterFuture ...
[17:45:46.663] - result already collected: FutureResult
[17:45:46.663] result() for ClusterFuture ... done
[17:45:46.666] result() for ClusterFuture ...
[17:45:46.666] - result already collected: FutureResult
[17:45:46.666] result() for ClusterFuture ... done
[17:45:46.666] result() for ClusterFuture ...
[17:45:46.666] - result already collected: FutureResult
[17:45:46.666] result() for ClusterFuture ... done
[17:45:46.666] - relayed: [n=2] TRUE, TRUE
[17:45:46.666] - queued futures: [n=2] TRUE, TRUE
[17:45:46.666] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:45:46.666] resolve() on list ... DONE
[17:45:46.666] result() for ClusterFuture ...
[17:45:46.667] - result already collected: FutureResult
[17:45:46.667] result() for ClusterFuture ... done
[17:45:46.667] result() for ClusterFuture ...
[17:45:46.667] - result already collected: FutureResult
[17:45:46.667] result() for ClusterFuture ... done
[17:45:46.667] result() for ClusterFuture ...
[17:45:46.667] - result already collected: FutureResult
[17:45:46.667] result() for ClusterFuture ... done
[17:45:46.667] result() for ClusterFuture ...
[17:45:46.667] - result already collected: FutureResult
[17:45:46.667] result() for ClusterFuture ... done
[17:45:46.667]  - Number of value chunks collected: 2
[17:45:46.668] Resolving 2 futures (chunks) ... DONE
[17:45:46.668] Reducing values from 2 chunks ...
[17:45:46.668]  - Number of values collected after concatenation: 2
[17:45:46.668]  - Number of values expected: 2
[17:45:46.668] Reducing values from 2 chunks ... DONE
[17:45:46.668] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[17:45:46.668] future_lapply() ...
[17:45:46.673] Number of chunks: 2
[17:45:46.673] getGlobalsAndPackagesXApply() ...
[17:45:46.673]  - future.globals: TRUE
[17:45:46.673] getGlobalsAndPackages() ...
[17:45:46.673] Searching for globals...
[17:45:46.674] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[17:45:46.675] Searching for globals ... DONE
[17:45:46.675] Resolving globals: FALSE
[17:45:46.675] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[17:45:46.675] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[17:45:46.676] - globals: [1] ‘FUN’
[17:45:46.676] 
[17:45:46.676] getGlobalsAndPackages() ... DONE
[17:45:46.676]  - globals found/used: [n=1] ‘FUN’
[17:45:46.676]  - needed namespaces: [n=0] 
[17:45:46.676] Finding globals ... DONE
[17:45:46.676]  - use_args: TRUE
[17:45:46.676]  - Getting '...' globals ...
[17:45:46.677] resolve() on list ...
[17:45:46.677]  recursive: 0
[17:45:46.677]  length: 1
[17:45:46.677]  elements: ‘...’
[17:45:46.677]  length: 0 (resolved future 1)
[17:45:46.677] resolve() on list ... DONE
[17:45:46.677]    - '...' content: [n=0] 
[17:45:46.677] List of 1
[17:45:46.677]  $ ...: list()
[17:45:46.677]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:46.677]  - attr(*, "where")=List of 1
[17:45:46.677]   ..$ ...:<environment: 0x55f6c7c35a00> 
[17:45:46.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:46.677]  - attr(*, "resolved")= logi TRUE
[17:45:46.677]  - attr(*, "total_size")= num NA
[17:45:46.680]  - Getting '...' globals ... DONE
[17:45:46.680] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:46.680] List of 2
[17:45:46.680]  $ ...future.FUN:function (x)  
[17:45:46.680]  $ ...          : list()
[17:45:46.680]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:46.680]  - attr(*, "where")=List of 2
[17:45:46.680]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:46.680]   ..$ ...          :<environment: 0x55f6c7c35a00> 
[17:45:46.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:46.680]  - attr(*, "resolved")= logi FALSE
[17:45:46.680]  - attr(*, "total_size")= num 4720
[17:45:46.682] Packages to be attached in all futures: [n=0] 
[17:45:46.682] getGlobalsAndPackagesXApply() ... DONE
[17:45:46.683] Number of futures (= number of chunks): 2
[17:45:46.683] Launching 2 futures (chunks) ...
[17:45:46.683] Chunk #1 of 2 ...
[17:45:46.683]  - Finding globals in 'X' for chunk #1 ...
[17:45:46.683] getGlobalsAndPackages() ...
[17:45:46.683] Searching for globals...
[17:45:46.683] 
[17:45:46.683] Searching for globals ... DONE
[17:45:46.684] - globals: [0] <none>
[17:45:46.684] getGlobalsAndPackages() ... DONE
[17:45:46.684]    + additional globals found: [n=0] 
[17:45:46.684]    + additional namespaces needed: [n=0] 
[17:45:46.684]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:46.684]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:46.684]  - seeds: <none>
[17:45:46.684]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:46.684] getGlobalsAndPackages() ...
[17:45:46.684] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:46.684] Resolving globals: FALSE
[17:45:46.685] Tweak future expression to call with '...' arguments ...
[17:45:46.685] {
[17:45:46.685]     do.call(function(...) {
[17:45:46.685]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:46.685]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:46.685]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:46.685]             on.exit(options(oopts), add = TRUE)
[17:45:46.685]         }
[17:45:46.685]         {
[17:45:46.685]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:46.685]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:46.685]                 ...future.FUN(...future.X_jj, ...)
[17:45:46.685]             })
[17:45:46.685]         }
[17:45:46.685]     }, args = future.call.arguments)
[17:45:46.685] }
[17:45:46.685] Tweak future expression to call with '...' arguments ... DONE
[17:45:46.685] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:46.685] 
[17:45:46.685] getGlobalsAndPackages() ... DONE
[17:45:46.686] run() for ‘Future’ ...
[17:45:46.686] - state: ‘created’
[17:45:46.686] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:46.700] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:46.700] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:46.700]   - Field: ‘node’
[17:45:46.700]   - Field: ‘label’
[17:45:46.701]   - Field: ‘local’
[17:45:46.701]   - Field: ‘owner’
[17:45:46.701]   - Field: ‘envir’
[17:45:46.701]   - Field: ‘workers’
[17:45:46.701]   - Field: ‘packages’
[17:45:46.701]   - Field: ‘gc’
[17:45:46.701]   - Field: ‘conditions’
[17:45:46.701]   - Field: ‘persistent’
[17:45:46.701]   - Field: ‘expr’
[17:45:46.701]   - Field: ‘uuid’
[17:45:46.701]   - Field: ‘seed’
[17:45:46.702]   - Field: ‘version’
[17:45:46.702]   - Field: ‘result’
[17:45:46.702]   - Field: ‘asynchronous’
[17:45:46.702]   - Field: ‘calls’
[17:45:46.702]   - Field: ‘globals’
[17:45:46.702]   - Field: ‘stdout’
[17:45:46.702]   - Field: ‘earlySignal’
[17:45:46.702]   - Field: ‘lazy’
[17:45:46.702]   - Field: ‘state’
[17:45:46.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:46.702] - Launch lazy future ...
[17:45:46.703] Packages needed by the future expression (n = 0): <none>
[17:45:46.703] Packages needed by future strategies (n = 0): <none>
[17:45:46.703] {
[17:45:46.703]     {
[17:45:46.703]         {
[17:45:46.703]             ...future.startTime <- base::Sys.time()
[17:45:46.703]             {
[17:45:46.703]                 {
[17:45:46.703]                   {
[17:45:46.703]                     {
[17:45:46.703]                       base::local({
[17:45:46.703]                         has_future <- base::requireNamespace("future", 
[17:45:46.703]                           quietly = TRUE)
[17:45:46.703]                         if (has_future) {
[17:45:46.703]                           ns <- base::getNamespace("future")
[17:45:46.703]                           version <- ns[[".package"]][["version"]]
[17:45:46.703]                           if (is.null(version)) 
[17:45:46.703]                             version <- utils::packageVersion("future")
[17:45:46.703]                         }
[17:45:46.703]                         else {
[17:45:46.703]                           version <- NULL
[17:45:46.703]                         }
[17:45:46.703]                         if (!has_future || version < "1.8.0") {
[17:45:46.703]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:46.703]                             "", base::R.version$version.string), 
[17:45:46.703]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:46.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:46.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:46.703]                               "release", "version")], collapse = " "), 
[17:45:46.703]                             hostname = base::Sys.info()[["nodename"]])
[17:45:46.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:46.703]                             info)
[17:45:46.703]                           info <- base::paste(info, collapse = "; ")
[17:45:46.703]                           if (!has_future) {
[17:45:46.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:46.703]                               info)
[17:45:46.703]                           }
[17:45:46.703]                           else {
[17:45:46.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:46.703]                               info, version)
[17:45:46.703]                           }
[17:45:46.703]                           base::stop(msg)
[17:45:46.703]                         }
[17:45:46.703]                       })
[17:45:46.703]                     }
[17:45:46.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:46.703]                     base::options(mc.cores = 1L)
[17:45:46.703]                   }
[17:45:46.703]                   ...future.strategy.old <- future::plan("list")
[17:45:46.703]                   options(future.plan = NULL)
[17:45:46.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:46.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:46.703]                 }
[17:45:46.703]                 ...future.workdir <- getwd()
[17:45:46.703]             }
[17:45:46.703]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:46.703]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:46.703]         }
[17:45:46.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:46.703]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:46.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:46.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:46.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:46.703]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:46.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:46.703]             base::names(...future.oldOptions))
[17:45:46.703]     }
[17:45:46.703]     if (TRUE) {
[17:45:46.703]     }
[17:45:46.703]     else {
[17:45:46.703]         if (NA) {
[17:45:46.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:46.703]                 open = "w")
[17:45:46.703]         }
[17:45:46.703]         else {
[17:45:46.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:46.703]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:46.703]         }
[17:45:46.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:46.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:46.703]             base::sink(type = "output", split = FALSE)
[17:45:46.703]             base::close(...future.stdout)
[17:45:46.703]         }, add = TRUE)
[17:45:46.703]     }
[17:45:46.703]     ...future.frame <- base::sys.nframe()
[17:45:46.703]     ...future.conditions <- base::list()
[17:45:46.703]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:46.703]     if (FALSE) {
[17:45:46.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:46.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:46.703]     }
[17:45:46.703]     ...future.result <- base::tryCatch({
[17:45:46.703]         base::withCallingHandlers({
[17:45:46.703]             ...future.value <- base::withVisible(base::local({
[17:45:46.703]                 ...future.makeSendCondition <- base::local({
[17:45:46.703]                   sendCondition <- NULL
[17:45:46.703]                   function(frame = 1L) {
[17:45:46.703]                     if (is.function(sendCondition)) 
[17:45:46.703]                       return(sendCondition)
[17:45:46.703]                     ns <- getNamespace("parallel")
[17:45:46.703]                     if (exists("sendData", mode = "function", 
[17:45:46.703]                       envir = ns)) {
[17:45:46.703]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:46.703]                         envir = ns)
[17:45:46.703]                       envir <- sys.frame(frame)
[17:45:46.703]                       master <- NULL
[17:45:46.703]                       while (!identical(envir, .GlobalEnv) && 
[17:45:46.703]                         !identical(envir, emptyenv())) {
[17:45:46.703]                         if (exists("master", mode = "list", envir = envir, 
[17:45:46.703]                           inherits = FALSE)) {
[17:45:46.703]                           master <- get("master", mode = "list", 
[17:45:46.703]                             envir = envir, inherits = FALSE)
[17:45:46.703]                           if (inherits(master, c("SOCKnode", 
[17:45:46.703]                             "SOCK0node"))) {
[17:45:46.703]                             sendCondition <<- function(cond) {
[17:45:46.703]                               data <- list(type = "VALUE", value = cond, 
[17:45:46.703]                                 success = TRUE)
[17:45:46.703]                               parallel_sendData(master, data)
[17:45:46.703]                             }
[17:45:46.703]                             return(sendCondition)
[17:45:46.703]                           }
[17:45:46.703]                         }
[17:45:46.703]                         frame <- frame + 1L
[17:45:46.703]                         envir <- sys.frame(frame)
[17:45:46.703]                       }
[17:45:46.703]                     }
[17:45:46.703]                     sendCondition <<- function(cond) NULL
[17:45:46.703]                   }
[17:45:46.703]                 })
[17:45:46.703]                 withCallingHandlers({
[17:45:46.703]                   {
[17:45:46.703]                     do.call(function(...) {
[17:45:46.703]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:46.703]                       if (!identical(...future.globals.maxSize.org, 
[17:45:46.703]                         ...future.globals.maxSize)) {
[17:45:46.703]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:46.703]                         on.exit(options(oopts), add = TRUE)
[17:45:46.703]                       }
[17:45:46.703]                       {
[17:45:46.703]                         lapply(seq_along(...future.elements_ii), 
[17:45:46.703]                           FUN = function(jj) {
[17:45:46.703]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:46.703]                             ...future.FUN(...future.X_jj, ...)
[17:45:46.703]                           })
[17:45:46.703]                       }
[17:45:46.703]                     }, args = future.call.arguments)
[17:45:46.703]                   }
[17:45:46.703]                 }, immediateCondition = function(cond) {
[17:45:46.703]                   sendCondition <- ...future.makeSendCondition()
[17:45:46.703]                   sendCondition(cond)
[17:45:46.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:46.703]                   {
[17:45:46.703]                     inherits <- base::inherits
[17:45:46.703]                     invokeRestart <- base::invokeRestart
[17:45:46.703]                     is.null <- base::is.null
[17:45:46.703]                     muffled <- FALSE
[17:45:46.703]                     if (inherits(cond, "message")) {
[17:45:46.703]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:46.703]                       if (muffled) 
[17:45:46.703]                         invokeRestart("muffleMessage")
[17:45:46.703]                     }
[17:45:46.703]                     else if (inherits(cond, "warning")) {
[17:45:46.703]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:46.703]                       if (muffled) 
[17:45:46.703]                         invokeRestart("muffleWarning")
[17:45:46.703]                     }
[17:45:46.703]                     else if (inherits(cond, "condition")) {
[17:45:46.703]                       if (!is.null(pattern)) {
[17:45:46.703]                         computeRestarts <- base::computeRestarts
[17:45:46.703]                         grepl <- base::grepl
[17:45:46.703]                         restarts <- computeRestarts(cond)
[17:45:46.703]                         for (restart in restarts) {
[17:45:46.703]                           name <- restart$name
[17:45:46.703]                           if (is.null(name)) 
[17:45:46.703]                             next
[17:45:46.703]                           if (!grepl(pattern, name)) 
[17:45:46.703]                             next
[17:45:46.703]                           invokeRestart(restart)
[17:45:46.703]                           muffled <- TRUE
[17:45:46.703]                           break
[17:45:46.703]                         }
[17:45:46.703]                       }
[17:45:46.703]                     }
[17:45:46.703]                     invisible(muffled)
[17:45:46.703]                   }
[17:45:46.703]                   muffleCondition(cond)
[17:45:46.703]                 })
[17:45:46.703]             }))
[17:45:46.703]             future::FutureResult(value = ...future.value$value, 
[17:45:46.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:46.703]                   ...future.rng), globalenv = if (FALSE) 
[17:45:46.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:46.703]                     ...future.globalenv.names))
[17:45:46.703]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:46.703]         }, condition = base::local({
[17:45:46.703]             c <- base::c
[17:45:46.703]             inherits <- base::inherits
[17:45:46.703]             invokeRestart <- base::invokeRestart
[17:45:46.703]             length <- base::length
[17:45:46.703]             list <- base::list
[17:45:46.703]             seq.int <- base::seq.int
[17:45:46.703]             signalCondition <- base::signalCondition
[17:45:46.703]             sys.calls <- base::sys.calls
[17:45:46.703]             `[[` <- base::`[[`
[17:45:46.703]             `+` <- base::`+`
[17:45:46.703]             `<<-` <- base::`<<-`
[17:45:46.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:46.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:46.703]                   3L)]
[17:45:46.703]             }
[17:45:46.703]             function(cond) {
[17:45:46.703]                 is_error <- inherits(cond, "error")
[17:45:46.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:46.703]                   NULL)
[17:45:46.703]                 if (is_error) {
[17:45:46.703]                   sessionInformation <- function() {
[17:45:46.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:46.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:46.703]                       search = base::search(), system = base::Sys.info())
[17:45:46.703]                   }
[17:45:46.703]                   ...future.conditions[[length(...future.conditions) + 
[17:45:46.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:46.703]                     cond$call), session = sessionInformation(), 
[17:45:46.703]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:46.703]                   signalCondition(cond)
[17:45:46.703]                 }
[17:45:46.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:46.703]                 "immediateCondition"))) {
[17:45:46.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:46.703]                   ...future.conditions[[length(...future.conditions) + 
[17:45:46.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:46.703]                   if (TRUE && !signal) {
[17:45:46.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:46.703]                     {
[17:45:46.703]                       inherits <- base::inherits
[17:45:46.703]                       invokeRestart <- base::invokeRestart
[17:45:46.703]                       is.null <- base::is.null
[17:45:46.703]                       muffled <- FALSE
[17:45:46.703]                       if (inherits(cond, "message")) {
[17:45:46.703]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:46.703]                         if (muffled) 
[17:45:46.703]                           invokeRestart("muffleMessage")
[17:45:46.703]                       }
[17:45:46.703]                       else if (inherits(cond, "warning")) {
[17:45:46.703]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:46.703]                         if (muffled) 
[17:45:46.703]                           invokeRestart("muffleWarning")
[17:45:46.703]                       }
[17:45:46.703]                       else if (inherits(cond, "condition")) {
[17:45:46.703]                         if (!is.null(pattern)) {
[17:45:46.703]                           computeRestarts <- base::computeRestarts
[17:45:46.703]                           grepl <- base::grepl
[17:45:46.703]                           restarts <- computeRestarts(cond)
[17:45:46.703]                           for (restart in restarts) {
[17:45:46.703]                             name <- restart$name
[17:45:46.703]                             if (is.null(name)) 
[17:45:46.703]                               next
[17:45:46.703]                             if (!grepl(pattern, name)) 
[17:45:46.703]                               next
[17:45:46.703]                             invokeRestart(restart)
[17:45:46.703]                             muffled <- TRUE
[17:45:46.703]                             break
[17:45:46.703]                           }
[17:45:46.703]                         }
[17:45:46.703]                       }
[17:45:46.703]                       invisible(muffled)
[17:45:46.703]                     }
[17:45:46.703]                     muffleCondition(cond, pattern = "^muffle")
[17:45:46.703]                   }
[17:45:46.703]                 }
[17:45:46.703]                 else {
[17:45:46.703]                   if (TRUE) {
[17:45:46.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:46.703]                     {
[17:45:46.703]                       inherits <- base::inherits
[17:45:46.703]                       invokeRestart <- base::invokeRestart
[17:45:46.703]                       is.null <- base::is.null
[17:45:46.703]                       muffled <- FALSE
[17:45:46.703]                       if (inherits(cond, "message")) {
[17:45:46.703]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:46.703]                         if (muffled) 
[17:45:46.703]                           invokeRestart("muffleMessage")
[17:45:46.703]                       }
[17:45:46.703]                       else if (inherits(cond, "warning")) {
[17:45:46.703]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:46.703]                         if (muffled) 
[17:45:46.703]                           invokeRestart("muffleWarning")
[17:45:46.703]                       }
[17:45:46.703]                       else if (inherits(cond, "condition")) {
[17:45:46.703]                         if (!is.null(pattern)) {
[17:45:46.703]                           computeRestarts <- base::computeRestarts
[17:45:46.703]                           grepl <- base::grepl
[17:45:46.703]                           restarts <- computeRestarts(cond)
[17:45:46.703]                           for (restart in restarts) {
[17:45:46.703]                             name <- restart$name
[17:45:46.703]                             if (is.null(name)) 
[17:45:46.703]                               next
[17:45:46.703]                             if (!grepl(pattern, name)) 
[17:45:46.703]                               next
[17:45:46.703]                             invokeRestart(restart)
[17:45:46.703]                             muffled <- TRUE
[17:45:46.703]                             break
[17:45:46.703]                           }
[17:45:46.703]                         }
[17:45:46.703]                       }
[17:45:46.703]                       invisible(muffled)
[17:45:46.703]                     }
[17:45:46.703]                     muffleCondition(cond, pattern = "^muffle")
[17:45:46.703]                   }
[17:45:46.703]                 }
[17:45:46.703]             }
[17:45:46.703]         }))
[17:45:46.703]     }, error = function(ex) {
[17:45:46.703]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:46.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:46.703]                 ...future.rng), started = ...future.startTime, 
[17:45:46.703]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:46.703]             version = "1.8"), class = "FutureResult")
[17:45:46.703]     }, finally = {
[17:45:46.703]         if (!identical(...future.workdir, getwd())) 
[17:45:46.703]             setwd(...future.workdir)
[17:45:46.703]         {
[17:45:46.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:46.703]                 ...future.oldOptions$nwarnings <- NULL
[17:45:46.703]             }
[17:45:46.703]             base::options(...future.oldOptions)
[17:45:46.703]             if (.Platform$OS.type == "windows") {
[17:45:46.703]                 old_names <- names(...future.oldEnvVars)
[17:45:46.703]                 envs <- base::Sys.getenv()
[17:45:46.703]                 names <- names(envs)
[17:45:46.703]                 common <- intersect(names, old_names)
[17:45:46.703]                 added <- setdiff(names, old_names)
[17:45:46.703]                 removed <- setdiff(old_names, names)
[17:45:46.703]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:46.703]                   envs[common]]
[17:45:46.703]                 NAMES <- toupper(changed)
[17:45:46.703]                 args <- list()
[17:45:46.703]                 for (kk in seq_along(NAMES)) {
[17:45:46.703]                   name <- changed[[kk]]
[17:45:46.703]                   NAME <- NAMES[[kk]]
[17:45:46.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:46.703]                     next
[17:45:46.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:46.703]                 }
[17:45:46.703]                 NAMES <- toupper(added)
[17:45:46.703]                 for (kk in seq_along(NAMES)) {
[17:45:46.703]                   name <- added[[kk]]
[17:45:46.703]                   NAME <- NAMES[[kk]]
[17:45:46.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:46.703]                     next
[17:45:46.703]                   args[[name]] <- ""
[17:45:46.703]                 }
[17:45:46.703]                 NAMES <- toupper(removed)
[17:45:46.703]                 for (kk in seq_along(NAMES)) {
[17:45:46.703]                   name <- removed[[kk]]
[17:45:46.703]                   NAME <- NAMES[[kk]]
[17:45:46.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:46.703]                     next
[17:45:46.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:46.703]                 }
[17:45:46.703]                 if (length(args) > 0) 
[17:45:46.703]                   base::do.call(base::Sys.setenv, args = args)
[17:45:46.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:46.703]             }
[17:45:46.703]             else {
[17:45:46.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:46.703]             }
[17:45:46.703]             {
[17:45:46.703]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:46.703]                   0L) {
[17:45:46.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:46.703]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:46.703]                   base::options(opts)
[17:45:46.703]                 }
[17:45:46.703]                 {
[17:45:46.703]                   {
[17:45:46.703]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:46.703]                     NULL
[17:45:46.703]                   }
[17:45:46.703]                   options(future.plan = NULL)
[17:45:46.703]                   if (is.na(NA_character_)) 
[17:45:46.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:46.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:46.703]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:46.703]                     .init = FALSE)
[17:45:46.703]                 }
[17:45:46.703]             }
[17:45:46.703]         }
[17:45:46.703]     })
[17:45:46.703]     if (FALSE) {
[17:45:46.703]         base::sink(type = "output", split = FALSE)
[17:45:46.703]         if (NA) {
[17:45:46.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:46.703]         }
[17:45:46.703]         else {
[17:45:46.703]             ...future.result["stdout"] <- base::list(NULL)
[17:45:46.703]         }
[17:45:46.703]         base::close(...future.stdout)
[17:45:46.703]         ...future.stdout <- NULL
[17:45:46.703]     }
[17:45:46.703]     ...future.result$conditions <- ...future.conditions
[17:45:46.703]     ...future.result$finished <- base::Sys.time()
[17:45:46.703]     ...future.result
[17:45:46.703] }
[17:45:46.706] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[17:45:46.706] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[17:45:46.706] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[17:45:46.707] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:46.707] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:46.707] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:45:46.707] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:45:46.708] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:46.708] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:46.708] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:46.708] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:46.708] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[17:45:46.709] MultisessionFuture started
[17:45:46.709] - Launch lazy future ... done
[17:45:46.709] run() for ‘MultisessionFuture’ ... done
[17:45:46.709] Created future:
[17:45:46.709] MultisessionFuture:
[17:45:46.709] Label: ‘future_lapply-1’
[17:45:46.709] Expression:
[17:45:46.709] {
[17:45:46.709]     do.call(function(...) {
[17:45:46.709]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:46.709]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:46.709]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:46.709]             on.exit(options(oopts), add = TRUE)
[17:45:46.709]         }
[17:45:46.709]         {
[17:45:46.709]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:46.709]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:46.709]                 ...future.FUN(...future.X_jj, ...)
[17:45:46.709]             })
[17:45:46.709]         }
[17:45:46.709]     }, args = future.call.arguments)
[17:45:46.709] }
[17:45:46.709] Lazy evaluation: FALSE
[17:45:46.709] Asynchronous evaluation: TRUE
[17:45:46.709] Local evaluation: TRUE
[17:45:46.709] Environment: R_GlobalEnv
[17:45:46.709] Capture standard output: NA
[17:45:46.709] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:46.709] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:46.709] Packages: <none>
[17:45:46.709] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:46.709] Resolved: FALSE
[17:45:46.709] Value: <not collected>
[17:45:46.709] Conditions captured: <none>
[17:45:46.709] Early signaling: FALSE
[17:45:46.709] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:46.709] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:46.721] Chunk #1 of 2 ... DONE
[17:45:46.721] Chunk #2 of 2 ...
[17:45:46.721]  - Finding globals in 'X' for chunk #2 ...
[17:45:46.721] getGlobalsAndPackages() ...
[17:45:46.721] Searching for globals...
[17:45:46.721] 
[17:45:46.721] Searching for globals ... DONE
[17:45:46.721] - globals: [0] <none>
[17:45:46.721] getGlobalsAndPackages() ... DONE
[17:45:46.722]    + additional globals found: [n=0] 
[17:45:46.722]    + additional namespaces needed: [n=0] 
[17:45:46.722]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:46.722]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:46.722]  - seeds: <none>
[17:45:46.722]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:46.722] getGlobalsAndPackages() ...
[17:45:46.722] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:46.722] Resolving globals: FALSE
[17:45:46.722] Tweak future expression to call with '...' arguments ...
[17:45:46.723] {
[17:45:46.723]     do.call(function(...) {
[17:45:46.723]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:46.723]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:46.723]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:46.723]             on.exit(options(oopts), add = TRUE)
[17:45:46.723]         }
[17:45:46.723]         {
[17:45:46.723]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:46.723]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:46.723]                 ...future.FUN(...future.X_jj, ...)
[17:45:46.723]             })
[17:45:46.723]         }
[17:45:46.723]     }, args = future.call.arguments)
[17:45:46.723] }
[17:45:46.723] Tweak future expression to call with '...' arguments ... DONE
[17:45:46.723] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:46.723] 
[17:45:46.723] getGlobalsAndPackages() ... DONE
[17:45:46.724] run() for ‘Future’ ...
[17:45:46.724] - state: ‘created’
[17:45:46.724] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:46.737] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:46.738] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:46.738]   - Field: ‘node’
[17:45:46.738]   - Field: ‘label’
[17:45:46.738]   - Field: ‘local’
[17:45:46.738]   - Field: ‘owner’
[17:45:46.738]   - Field: ‘envir’
[17:45:46.738]   - Field: ‘workers’
[17:45:46.738]   - Field: ‘packages’
[17:45:46.738]   - Field: ‘gc’
[17:45:46.738]   - Field: ‘conditions’
[17:45:46.739]   - Field: ‘persistent’
[17:45:46.739]   - Field: ‘expr’
[17:45:46.739]   - Field: ‘uuid’
[17:45:46.739]   - Field: ‘seed’
[17:45:46.739]   - Field: ‘version’
[17:45:46.739]   - Field: ‘result’
[17:45:46.739]   - Field: ‘asynchronous’
[17:45:46.739]   - Field: ‘calls’
[17:45:46.739]   - Field: ‘globals’
[17:45:46.739]   - Field: ‘stdout’
[17:45:46.740]   - Field: ‘earlySignal’
[17:45:46.740]   - Field: ‘lazy’
[17:45:46.740]   - Field: ‘state’
[17:45:46.740] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:46.740] - Launch lazy future ...
[17:45:46.740] Packages needed by the future expression (n = 0): <none>
[17:45:46.740] Packages needed by future strategies (n = 0): <none>
[17:45:46.741] {
[17:45:46.741]     {
[17:45:46.741]         {
[17:45:46.741]             ...future.startTime <- base::Sys.time()
[17:45:46.741]             {
[17:45:46.741]                 {
[17:45:46.741]                   {
[17:45:46.741]                     {
[17:45:46.741]                       base::local({
[17:45:46.741]                         has_future <- base::requireNamespace("future", 
[17:45:46.741]                           quietly = TRUE)
[17:45:46.741]                         if (has_future) {
[17:45:46.741]                           ns <- base::getNamespace("future")
[17:45:46.741]                           version <- ns[[".package"]][["version"]]
[17:45:46.741]                           if (is.null(version)) 
[17:45:46.741]                             version <- utils::packageVersion("future")
[17:45:46.741]                         }
[17:45:46.741]                         else {
[17:45:46.741]                           version <- NULL
[17:45:46.741]                         }
[17:45:46.741]                         if (!has_future || version < "1.8.0") {
[17:45:46.741]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:46.741]                             "", base::R.version$version.string), 
[17:45:46.741]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:46.741]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:46.741]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:46.741]                               "release", "version")], collapse = " "), 
[17:45:46.741]                             hostname = base::Sys.info()[["nodename"]])
[17:45:46.741]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:46.741]                             info)
[17:45:46.741]                           info <- base::paste(info, collapse = "; ")
[17:45:46.741]                           if (!has_future) {
[17:45:46.741]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:46.741]                               info)
[17:45:46.741]                           }
[17:45:46.741]                           else {
[17:45:46.741]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:46.741]                               info, version)
[17:45:46.741]                           }
[17:45:46.741]                           base::stop(msg)
[17:45:46.741]                         }
[17:45:46.741]                       })
[17:45:46.741]                     }
[17:45:46.741]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:46.741]                     base::options(mc.cores = 1L)
[17:45:46.741]                   }
[17:45:46.741]                   ...future.strategy.old <- future::plan("list")
[17:45:46.741]                   options(future.plan = NULL)
[17:45:46.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:46.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:46.741]                 }
[17:45:46.741]                 ...future.workdir <- getwd()
[17:45:46.741]             }
[17:45:46.741]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:46.741]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:46.741]         }
[17:45:46.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:46.741]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:46.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:46.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:46.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:46.741]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:46.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:46.741]             base::names(...future.oldOptions))
[17:45:46.741]     }
[17:45:46.741]     if (TRUE) {
[17:45:46.741]     }
[17:45:46.741]     else {
[17:45:46.741]         if (NA) {
[17:45:46.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:46.741]                 open = "w")
[17:45:46.741]         }
[17:45:46.741]         else {
[17:45:46.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:46.741]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:46.741]         }
[17:45:46.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:46.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:46.741]             base::sink(type = "output", split = FALSE)
[17:45:46.741]             base::close(...future.stdout)
[17:45:46.741]         }, add = TRUE)
[17:45:46.741]     }
[17:45:46.741]     ...future.frame <- base::sys.nframe()
[17:45:46.741]     ...future.conditions <- base::list()
[17:45:46.741]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:46.741]     if (FALSE) {
[17:45:46.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:46.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:46.741]     }
[17:45:46.741]     ...future.result <- base::tryCatch({
[17:45:46.741]         base::withCallingHandlers({
[17:45:46.741]             ...future.value <- base::withVisible(base::local({
[17:45:46.741]                 ...future.makeSendCondition <- base::local({
[17:45:46.741]                   sendCondition <- NULL
[17:45:46.741]                   function(frame = 1L) {
[17:45:46.741]                     if (is.function(sendCondition)) 
[17:45:46.741]                       return(sendCondition)
[17:45:46.741]                     ns <- getNamespace("parallel")
[17:45:46.741]                     if (exists("sendData", mode = "function", 
[17:45:46.741]                       envir = ns)) {
[17:45:46.741]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:46.741]                         envir = ns)
[17:45:46.741]                       envir <- sys.frame(frame)
[17:45:46.741]                       master <- NULL
[17:45:46.741]                       while (!identical(envir, .GlobalEnv) && 
[17:45:46.741]                         !identical(envir, emptyenv())) {
[17:45:46.741]                         if (exists("master", mode = "list", envir = envir, 
[17:45:46.741]                           inherits = FALSE)) {
[17:45:46.741]                           master <- get("master", mode = "list", 
[17:45:46.741]                             envir = envir, inherits = FALSE)
[17:45:46.741]                           if (inherits(master, c("SOCKnode", 
[17:45:46.741]                             "SOCK0node"))) {
[17:45:46.741]                             sendCondition <<- function(cond) {
[17:45:46.741]                               data <- list(type = "VALUE", value = cond, 
[17:45:46.741]                                 success = TRUE)
[17:45:46.741]                               parallel_sendData(master, data)
[17:45:46.741]                             }
[17:45:46.741]                             return(sendCondition)
[17:45:46.741]                           }
[17:45:46.741]                         }
[17:45:46.741]                         frame <- frame + 1L
[17:45:46.741]                         envir <- sys.frame(frame)
[17:45:46.741]                       }
[17:45:46.741]                     }
[17:45:46.741]                     sendCondition <<- function(cond) NULL
[17:45:46.741]                   }
[17:45:46.741]                 })
[17:45:46.741]                 withCallingHandlers({
[17:45:46.741]                   {
[17:45:46.741]                     do.call(function(...) {
[17:45:46.741]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:46.741]                       if (!identical(...future.globals.maxSize.org, 
[17:45:46.741]                         ...future.globals.maxSize)) {
[17:45:46.741]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:46.741]                         on.exit(options(oopts), add = TRUE)
[17:45:46.741]                       }
[17:45:46.741]                       {
[17:45:46.741]                         lapply(seq_along(...future.elements_ii), 
[17:45:46.741]                           FUN = function(jj) {
[17:45:46.741]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:46.741]                             ...future.FUN(...future.X_jj, ...)
[17:45:46.741]                           })
[17:45:46.741]                       }
[17:45:46.741]                     }, args = future.call.arguments)
[17:45:46.741]                   }
[17:45:46.741]                 }, immediateCondition = function(cond) {
[17:45:46.741]                   sendCondition <- ...future.makeSendCondition()
[17:45:46.741]                   sendCondition(cond)
[17:45:46.741]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:46.741]                   {
[17:45:46.741]                     inherits <- base::inherits
[17:45:46.741]                     invokeRestart <- base::invokeRestart
[17:45:46.741]                     is.null <- base::is.null
[17:45:46.741]                     muffled <- FALSE
[17:45:46.741]                     if (inherits(cond, "message")) {
[17:45:46.741]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:46.741]                       if (muffled) 
[17:45:46.741]                         invokeRestart("muffleMessage")
[17:45:46.741]                     }
[17:45:46.741]                     else if (inherits(cond, "warning")) {
[17:45:46.741]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:46.741]                       if (muffled) 
[17:45:46.741]                         invokeRestart("muffleWarning")
[17:45:46.741]                     }
[17:45:46.741]                     else if (inherits(cond, "condition")) {
[17:45:46.741]                       if (!is.null(pattern)) {
[17:45:46.741]                         computeRestarts <- base::computeRestarts
[17:45:46.741]                         grepl <- base::grepl
[17:45:46.741]                         restarts <- computeRestarts(cond)
[17:45:46.741]                         for (restart in restarts) {
[17:45:46.741]                           name <- restart$name
[17:45:46.741]                           if (is.null(name)) 
[17:45:46.741]                             next
[17:45:46.741]                           if (!grepl(pattern, name)) 
[17:45:46.741]                             next
[17:45:46.741]                           invokeRestart(restart)
[17:45:46.741]                           muffled <- TRUE
[17:45:46.741]                           break
[17:45:46.741]                         }
[17:45:46.741]                       }
[17:45:46.741]                     }
[17:45:46.741]                     invisible(muffled)
[17:45:46.741]                   }
[17:45:46.741]                   muffleCondition(cond)
[17:45:46.741]                 })
[17:45:46.741]             }))
[17:45:46.741]             future::FutureResult(value = ...future.value$value, 
[17:45:46.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:46.741]                   ...future.rng), globalenv = if (FALSE) 
[17:45:46.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:46.741]                     ...future.globalenv.names))
[17:45:46.741]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:46.741]         }, condition = base::local({
[17:45:46.741]             c <- base::c
[17:45:46.741]             inherits <- base::inherits
[17:45:46.741]             invokeRestart <- base::invokeRestart
[17:45:46.741]             length <- base::length
[17:45:46.741]             list <- base::list
[17:45:46.741]             seq.int <- base::seq.int
[17:45:46.741]             signalCondition <- base::signalCondition
[17:45:46.741]             sys.calls <- base::sys.calls
[17:45:46.741]             `[[` <- base::`[[`
[17:45:46.741]             `+` <- base::`+`
[17:45:46.741]             `<<-` <- base::`<<-`
[17:45:46.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:46.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:46.741]                   3L)]
[17:45:46.741]             }
[17:45:46.741]             function(cond) {
[17:45:46.741]                 is_error <- inherits(cond, "error")
[17:45:46.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:46.741]                   NULL)
[17:45:46.741]                 if (is_error) {
[17:45:46.741]                   sessionInformation <- function() {
[17:45:46.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:46.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:46.741]                       search = base::search(), system = base::Sys.info())
[17:45:46.741]                   }
[17:45:46.741]                   ...future.conditions[[length(...future.conditions) + 
[17:45:46.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:46.741]                     cond$call), session = sessionInformation(), 
[17:45:46.741]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:46.741]                   signalCondition(cond)
[17:45:46.741]                 }
[17:45:46.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:46.741]                 "immediateCondition"))) {
[17:45:46.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:46.741]                   ...future.conditions[[length(...future.conditions) + 
[17:45:46.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:46.741]                   if (TRUE && !signal) {
[17:45:46.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:46.741]                     {
[17:45:46.741]                       inherits <- base::inherits
[17:45:46.741]                       invokeRestart <- base::invokeRestart
[17:45:46.741]                       is.null <- base::is.null
[17:45:46.741]                       muffled <- FALSE
[17:45:46.741]                       if (inherits(cond, "message")) {
[17:45:46.741]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:46.741]                         if (muffled) 
[17:45:46.741]                           invokeRestart("muffleMessage")
[17:45:46.741]                       }
[17:45:46.741]                       else if (inherits(cond, "warning")) {
[17:45:46.741]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:46.741]                         if (muffled) 
[17:45:46.741]                           invokeRestart("muffleWarning")
[17:45:46.741]                       }
[17:45:46.741]                       else if (inherits(cond, "condition")) {
[17:45:46.741]                         if (!is.null(pattern)) {
[17:45:46.741]                           computeRestarts <- base::computeRestarts
[17:45:46.741]                           grepl <- base::grepl
[17:45:46.741]                           restarts <- computeRestarts(cond)
[17:45:46.741]                           for (restart in restarts) {
[17:45:46.741]                             name <- restart$name
[17:45:46.741]                             if (is.null(name)) 
[17:45:46.741]                               next
[17:45:46.741]                             if (!grepl(pattern, name)) 
[17:45:46.741]                               next
[17:45:46.741]                             invokeRestart(restart)
[17:45:46.741]                             muffled <- TRUE
[17:45:46.741]                             break
[17:45:46.741]                           }
[17:45:46.741]                         }
[17:45:46.741]                       }
[17:45:46.741]                       invisible(muffled)
[17:45:46.741]                     }
[17:45:46.741]                     muffleCondition(cond, pattern = "^muffle")
[17:45:46.741]                   }
[17:45:46.741]                 }
[17:45:46.741]                 else {
[17:45:46.741]                   if (TRUE) {
[17:45:46.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:46.741]                     {
[17:45:46.741]                       inherits <- base::inherits
[17:45:46.741]                       invokeRestart <- base::invokeRestart
[17:45:46.741]                       is.null <- base::is.null
[17:45:46.741]                       muffled <- FALSE
[17:45:46.741]                       if (inherits(cond, "message")) {
[17:45:46.741]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:46.741]                         if (muffled) 
[17:45:46.741]                           invokeRestart("muffleMessage")
[17:45:46.741]                       }
[17:45:46.741]                       else if (inherits(cond, "warning")) {
[17:45:46.741]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:46.741]                         if (muffled) 
[17:45:46.741]                           invokeRestart("muffleWarning")
[17:45:46.741]                       }
[17:45:46.741]                       else if (inherits(cond, "condition")) {
[17:45:46.741]                         if (!is.null(pattern)) {
[17:45:46.741]                           computeRestarts <- base::computeRestarts
[17:45:46.741]                           grepl <- base::grepl
[17:45:46.741]                           restarts <- computeRestarts(cond)
[17:45:46.741]                           for (restart in restarts) {
[17:45:46.741]                             name <- restart$name
[17:45:46.741]                             if (is.null(name)) 
[17:45:46.741]                               next
[17:45:46.741]                             if (!grepl(pattern, name)) 
[17:45:46.741]                               next
[17:45:46.741]                             invokeRestart(restart)
[17:45:46.741]                             muffled <- TRUE
[17:45:46.741]                             break
[17:45:46.741]                           }
[17:45:46.741]                         }
[17:45:46.741]                       }
[17:45:46.741]                       invisible(muffled)
[17:45:46.741]                     }
[17:45:46.741]                     muffleCondition(cond, pattern = "^muffle")
[17:45:46.741]                   }
[17:45:46.741]                 }
[17:45:46.741]             }
[17:45:46.741]         }))
[17:45:46.741]     }, error = function(ex) {
[17:45:46.741]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:46.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:46.741]                 ...future.rng), started = ...future.startTime, 
[17:45:46.741]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:46.741]             version = "1.8"), class = "FutureResult")
[17:45:46.741]     }, finally = {
[17:45:46.741]         if (!identical(...future.workdir, getwd())) 
[17:45:46.741]             setwd(...future.workdir)
[17:45:46.741]         {
[17:45:46.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:46.741]                 ...future.oldOptions$nwarnings <- NULL
[17:45:46.741]             }
[17:45:46.741]             base::options(...future.oldOptions)
[17:45:46.741]             if (.Platform$OS.type == "windows") {
[17:45:46.741]                 old_names <- names(...future.oldEnvVars)
[17:45:46.741]                 envs <- base::Sys.getenv()
[17:45:46.741]                 names <- names(envs)
[17:45:46.741]                 common <- intersect(names, old_names)
[17:45:46.741]                 added <- setdiff(names, old_names)
[17:45:46.741]                 removed <- setdiff(old_names, names)
[17:45:46.741]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:46.741]                   envs[common]]
[17:45:46.741]                 NAMES <- toupper(changed)
[17:45:46.741]                 args <- list()
[17:45:46.741]                 for (kk in seq_along(NAMES)) {
[17:45:46.741]                   name <- changed[[kk]]
[17:45:46.741]                   NAME <- NAMES[[kk]]
[17:45:46.741]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:46.741]                     next
[17:45:46.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:46.741]                 }
[17:45:46.741]                 NAMES <- toupper(added)
[17:45:46.741]                 for (kk in seq_along(NAMES)) {
[17:45:46.741]                   name <- added[[kk]]
[17:45:46.741]                   NAME <- NAMES[[kk]]
[17:45:46.741]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:46.741]                     next
[17:45:46.741]                   args[[name]] <- ""
[17:45:46.741]                 }
[17:45:46.741]                 NAMES <- toupper(removed)
[17:45:46.741]                 for (kk in seq_along(NAMES)) {
[17:45:46.741]                   name <- removed[[kk]]
[17:45:46.741]                   NAME <- NAMES[[kk]]
[17:45:46.741]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:46.741]                     next
[17:45:46.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:46.741]                 }
[17:45:46.741]                 if (length(args) > 0) 
[17:45:46.741]                   base::do.call(base::Sys.setenv, args = args)
[17:45:46.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:46.741]             }
[17:45:46.741]             else {
[17:45:46.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:46.741]             }
[17:45:46.741]             {
[17:45:46.741]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:46.741]                   0L) {
[17:45:46.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:46.741]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:46.741]                   base::options(opts)
[17:45:46.741]                 }
[17:45:46.741]                 {
[17:45:46.741]                   {
[17:45:46.741]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:46.741]                     NULL
[17:45:46.741]                   }
[17:45:46.741]                   options(future.plan = NULL)
[17:45:46.741]                   if (is.na(NA_character_)) 
[17:45:46.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:46.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:46.741]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:46.741]                     .init = FALSE)
[17:45:46.741]                 }
[17:45:46.741]             }
[17:45:46.741]         }
[17:45:46.741]     })
[17:45:46.741]     if (FALSE) {
[17:45:46.741]         base::sink(type = "output", split = FALSE)
[17:45:46.741]         if (NA) {
[17:45:46.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:46.741]         }
[17:45:46.741]         else {
[17:45:46.741]             ...future.result["stdout"] <- base::list(NULL)
[17:45:46.741]         }
[17:45:46.741]         base::close(...future.stdout)
[17:45:46.741]         ...future.stdout <- NULL
[17:45:46.741]     }
[17:45:46.741]     ...future.result$conditions <- ...future.conditions
[17:45:46.741]     ...future.result$finished <- base::Sys.time()
[17:45:46.741]     ...future.result
[17:45:46.741] }
[17:45:46.743] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[17:45:46.744] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[17:45:46.744] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[17:45:46.744] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:45:46.748] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:45:46.748] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:45:46.748] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:45:46.749] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:46.749] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:46.749] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:46.749] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:46.750] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[17:45:46.750] MultisessionFuture started
[17:45:46.750] - Launch lazy future ... done
[17:45:46.750] run() for ‘MultisessionFuture’ ... done
[17:45:46.751] Created future:
[17:45:46.751] MultisessionFuture:
[17:45:46.751] Label: ‘future_lapply-2’
[17:45:46.751] Expression:
[17:45:46.751] {
[17:45:46.751]     do.call(function(...) {
[17:45:46.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:46.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:46.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:46.751]             on.exit(options(oopts), add = TRUE)
[17:45:46.751]         }
[17:45:46.751]         {
[17:45:46.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:46.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:46.751]                 ...future.FUN(...future.X_jj, ...)
[17:45:46.751]             })
[17:45:46.751]         }
[17:45:46.751]     }, args = future.call.arguments)
[17:45:46.751] }
[17:45:46.751] Lazy evaluation: FALSE
[17:45:46.751] Asynchronous evaluation: TRUE
[17:45:46.751] Local evaluation: TRUE
[17:45:46.751] Environment: R_GlobalEnv
[17:45:46.751] Capture standard output: NA
[17:45:46.751] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:46.751] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:46.751] Packages: <none>
[17:45:46.751] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:46.751] Resolved: FALSE
[17:45:46.751] Value: <not collected>
[17:45:46.751] Conditions captured: <none>
[17:45:46.751] Early signaling: FALSE
[17:45:46.751] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:46.751] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:46.762] Chunk #2 of 2 ... DONE
[17:45:46.762] Launching 2 futures (chunks) ... DONE
[17:45:46.762] Resolving 2 futures (chunks) ...
[17:45:46.763] resolve() on list ...
[17:45:46.763]  recursive: 0
[17:45:46.763]  length: 2
[17:45:46.763] 
[17:45:46.805] receiveMessageFromWorker() for ClusterFuture ...
[17:45:46.805] - Validating connection of MultisessionFuture
[17:45:46.805] - received message: FutureResult
[17:45:46.805] - Received FutureResult
[17:45:46.806] - Erased future from FutureRegistry
[17:45:46.806] result() for ClusterFuture ...
[17:45:46.806] - result already collected: FutureResult
[17:45:46.806] result() for ClusterFuture ... done
[17:45:46.806] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:46.806] Future #2
[17:45:46.806] result() for ClusterFuture ...
[17:45:46.806] - result already collected: FutureResult
[17:45:46.806] result() for ClusterFuture ... done
[17:45:46.806] result() for ClusterFuture ...
[17:45:46.806] - result already collected: FutureResult
[17:45:46.807] result() for ClusterFuture ... done
[17:45:46.807] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:46.807] - nx: 2
[17:45:46.807] - relay: TRUE
[17:45:46.807] - stdout: TRUE
[17:45:46.807] - signal: TRUE
[17:45:46.807] - resignal: FALSE
[17:45:46.807] - force: TRUE
[17:45:46.807] - relayed: [n=2] FALSE, FALSE
[17:45:46.807] - queued futures: [n=2] FALSE, FALSE
[17:45:46.807]  - until=1
[17:45:46.808]  - relaying element #1
[17:45:46.808] - relayed: [n=2] FALSE, FALSE
[17:45:46.808] - queued futures: [n=2] FALSE, TRUE
[17:45:46.808] signalConditionsASAP(NULL, pos=2) ... done
[17:45:46.808]  length: 1 (resolved future 2)
[17:45:47.254] receiveMessageFromWorker() for ClusterFuture ...
[17:45:47.254] - Validating connection of MultisessionFuture
[17:45:47.254] - received message: FutureResult
[17:45:47.254] - Received FutureResult
[17:45:47.254] - Erased future from FutureRegistry
[17:45:47.254] result() for ClusterFuture ...
[17:45:47.254] - result already collected: FutureResult
[17:45:47.255] result() for ClusterFuture ... done
[17:45:47.255] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:47.255] Future #1
[17:45:47.255] result() for ClusterFuture ...
[17:45:47.255] - result already collected: FutureResult
[17:45:47.255] result() for ClusterFuture ... done
[17:45:47.255] result() for ClusterFuture ...
[17:45:47.255] - result already collected: FutureResult
[17:45:47.255] result() for ClusterFuture ... done
[17:45:47.255] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:47.256] - nx: 2
[17:45:47.256] - relay: TRUE
[17:45:47.256] - stdout: TRUE
[17:45:47.256] - signal: TRUE
[17:45:47.256] - resignal: FALSE
[17:45:47.256] - force: TRUE
[17:45:47.256] - relayed: [n=2] FALSE, FALSE
[17:45:47.256] - queued futures: [n=2] FALSE, TRUE
[17:45:47.256]  - until=1
[17:45:47.256]  - relaying element #1
[17:45:47.256] result() for ClusterFuture ...
[17:45:47.256] - result already collected: FutureResult
[17:45:47.257] result() for ClusterFuture ... done
[17:45:47.257] result() for ClusterFuture ...
[17:45:47.257] - result already collected: FutureResult
[17:45:47.257] result() for ClusterFuture ... done
[17:45:47.257] result() for ClusterFuture ...
[17:45:47.257] - result already collected: FutureResult
[17:45:47.257] result() for ClusterFuture ... done
[17:45:47.257] result() for ClusterFuture ...
[17:45:47.257] - result already collected: FutureResult
[17:45:47.257] result() for ClusterFuture ... done
[17:45:47.257] - relayed: [n=2] TRUE, FALSE
[17:45:47.257] - queued futures: [n=2] TRUE, TRUE
[17:45:47.257] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:47.258]  length: 0 (resolved future 1)
[17:45:47.258] Relaying remaining futures
[17:45:47.258] signalConditionsASAP(NULL, pos=0) ...
[17:45:47.258] - nx: 2
[17:45:47.258] - relay: TRUE
[17:45:47.258] - stdout: TRUE
[17:45:47.258] - signal: TRUE
[17:45:47.258] - resignal: FALSE
[17:45:47.258] - force: TRUE
[17:45:47.258] - relayed: [n=2] TRUE, FALSE
[17:45:47.258] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:47.259]  - relaying element #2
[17:45:47.259] result() for ClusterFuture ...
[17:45:47.259] - result already collected: FutureResult
[17:45:47.259] result() for ClusterFuture ... done
[17:45:47.259] result() for ClusterFuture ...
[17:45:47.259] - result already collected: FutureResult
[17:45:47.259] result() for ClusterFuture ... done
[17:45:47.259] result() for ClusterFuture ...
[17:45:47.259] - result already collected: FutureResult
[17:45:47.259] result() for ClusterFuture ... done
[17:45:47.259] result() for ClusterFuture ...
[17:45:47.259] - result already collected: FutureResult
[17:45:47.260] result() for ClusterFuture ... done
[17:45:47.260] - relayed: [n=2] TRUE, TRUE
[17:45:47.260] - queued futures: [n=2] TRUE, TRUE
[17:45:47.260] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:45:47.260] resolve() on list ... DONE
[17:45:47.260] result() for ClusterFuture ...
[17:45:47.260] - result already collected: FutureResult
[17:45:47.260] result() for ClusterFuture ... done
[17:45:47.260] result() for ClusterFuture ...
[17:45:47.260] - result already collected: FutureResult
[17:45:47.260] result() for ClusterFuture ... done
[17:45:47.260] result() for ClusterFuture ...
[17:45:47.261] - result already collected: FutureResult
[17:45:47.261] result() for ClusterFuture ... done
[17:45:47.261] result() for ClusterFuture ...
[17:45:47.261] - result already collected: FutureResult
[17:45:47.261] result() for ClusterFuture ... done
[17:45:47.261]  - Number of value chunks collected: 2
[17:45:47.261] Resolving 2 futures (chunks) ... DONE
[17:45:47.261] Reducing values from 2 chunks ...
[17:45:47.261]  - Number of values collected after concatenation: 2
[17:45:47.261]  - Number of values expected: 2
[17:45:47.261] Reducing values from 2 chunks ... DONE
[17:45:47.262] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[17:45:47.262] future_mapply() ...
[17:45:47.266] Number of chunks: 2
[17:45:47.266] getGlobalsAndPackagesXApply() ...
[17:45:47.266]  - future.globals: TRUE
[17:45:47.266] getGlobalsAndPackages() ...
[17:45:47.266] Searching for globals...
[17:45:47.268] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:47.268] Searching for globals ... DONE
[17:45:47.268] Resolving globals: FALSE
[17:45:47.268] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:47.269] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:47.269] - globals: [1] ‘FUN’
[17:45:47.269] 
[17:45:47.269] getGlobalsAndPackages() ... DONE
[17:45:47.269]  - globals found/used: [n=1] ‘FUN’
[17:45:47.269]  - needed namespaces: [n=0] 
[17:45:47.269] Finding globals ... DONE
[17:45:47.269] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:47.269] List of 2
[17:45:47.269]  $ ...future.FUN:function (x, y)  
[17:45:47.269]  $ MoreArgs     : NULL
[17:45:47.269]  - attr(*, "where")=List of 2
[17:45:47.269]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:47.269]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:47.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:47.269]  - attr(*, "resolved")= logi FALSE
[17:45:47.269]  - attr(*, "total_size")= num NA
[17:45:47.272] Packages to be attached in all futures: [n=0] 
[17:45:47.272] getGlobalsAndPackagesXApply() ... DONE
[17:45:47.272] Number of futures (= number of chunks): 2
[17:45:47.272] Launching 2 futures (chunks) ...
[17:45:47.272] Chunk #1 of 2 ...
[17:45:47.273]  - Finding globals in '...' for chunk #1 ...
[17:45:47.273] getGlobalsAndPackages() ...
[17:45:47.273] Searching for globals...
[17:45:47.273] 
[17:45:47.273] Searching for globals ... DONE
[17:45:47.273] - globals: [0] <none>
[17:45:47.273] getGlobalsAndPackages() ... DONE
[17:45:47.273]    + additional globals found: [n=0] 
[17:45:47.274]    + additional namespaces needed: [n=0] 
[17:45:47.274]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:47.274]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:47.274]  - seeds: <none>
[17:45:47.274]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:47.274] getGlobalsAndPackages() ...
[17:45:47.274] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:47.274] Resolving globals: FALSE
[17:45:47.275] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:45:47.275] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:47.275] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:47.277] 
[17:45:47.277] getGlobalsAndPackages() ... DONE
[17:45:47.278] run() for ‘Future’ ...
[17:45:47.278] - state: ‘created’
[17:45:47.278] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:47.292] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:47.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:47.292]   - Field: ‘node’
[17:45:47.292]   - Field: ‘label’
[17:45:47.292]   - Field: ‘local’
[17:45:47.292]   - Field: ‘owner’
[17:45:47.292]   - Field: ‘envir’
[17:45:47.293]   - Field: ‘workers’
[17:45:47.293]   - Field: ‘packages’
[17:45:47.293]   - Field: ‘gc’
[17:45:47.293]   - Field: ‘conditions’
[17:45:47.293]   - Field: ‘persistent’
[17:45:47.293]   - Field: ‘expr’
[17:45:47.293]   - Field: ‘uuid’
[17:45:47.293]   - Field: ‘seed’
[17:45:47.293]   - Field: ‘version’
[17:45:47.293]   - Field: ‘result’
[17:45:47.293]   - Field: ‘asynchronous’
[17:45:47.294]   - Field: ‘calls’
[17:45:47.294]   - Field: ‘globals’
[17:45:47.294]   - Field: ‘stdout’
[17:45:47.294]   - Field: ‘earlySignal’
[17:45:47.294]   - Field: ‘lazy’
[17:45:47.294]   - Field: ‘state’
[17:45:47.294] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:47.294] - Launch lazy future ...
[17:45:47.294] Packages needed by the future expression (n = 0): <none>
[17:45:47.295] Packages needed by future strategies (n = 0): <none>
[17:45:47.295] {
[17:45:47.295]     {
[17:45:47.295]         {
[17:45:47.295]             ...future.startTime <- base::Sys.time()
[17:45:47.295]             {
[17:45:47.295]                 {
[17:45:47.295]                   {
[17:45:47.295]                     {
[17:45:47.295]                       base::local({
[17:45:47.295]                         has_future <- base::requireNamespace("future", 
[17:45:47.295]                           quietly = TRUE)
[17:45:47.295]                         if (has_future) {
[17:45:47.295]                           ns <- base::getNamespace("future")
[17:45:47.295]                           version <- ns[[".package"]][["version"]]
[17:45:47.295]                           if (is.null(version)) 
[17:45:47.295]                             version <- utils::packageVersion("future")
[17:45:47.295]                         }
[17:45:47.295]                         else {
[17:45:47.295]                           version <- NULL
[17:45:47.295]                         }
[17:45:47.295]                         if (!has_future || version < "1.8.0") {
[17:45:47.295]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:47.295]                             "", base::R.version$version.string), 
[17:45:47.295]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:47.295]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:47.295]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:47.295]                               "release", "version")], collapse = " "), 
[17:45:47.295]                             hostname = base::Sys.info()[["nodename"]])
[17:45:47.295]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:47.295]                             info)
[17:45:47.295]                           info <- base::paste(info, collapse = "; ")
[17:45:47.295]                           if (!has_future) {
[17:45:47.295]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:47.295]                               info)
[17:45:47.295]                           }
[17:45:47.295]                           else {
[17:45:47.295]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:47.295]                               info, version)
[17:45:47.295]                           }
[17:45:47.295]                           base::stop(msg)
[17:45:47.295]                         }
[17:45:47.295]                       })
[17:45:47.295]                     }
[17:45:47.295]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:47.295]                     base::options(mc.cores = 1L)
[17:45:47.295]                   }
[17:45:47.295]                   ...future.strategy.old <- future::plan("list")
[17:45:47.295]                   options(future.plan = NULL)
[17:45:47.295]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:47.295]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:47.295]                 }
[17:45:47.295]                 ...future.workdir <- getwd()
[17:45:47.295]             }
[17:45:47.295]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:47.295]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:47.295]         }
[17:45:47.295]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:47.295]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:47.295]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:47.295]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:47.295]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:47.295]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:47.295]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:47.295]             base::names(...future.oldOptions))
[17:45:47.295]     }
[17:45:47.295]     if (FALSE) {
[17:45:47.295]     }
[17:45:47.295]     else {
[17:45:47.295]         if (FALSE) {
[17:45:47.295]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:47.295]                 open = "w")
[17:45:47.295]         }
[17:45:47.295]         else {
[17:45:47.295]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:47.295]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:47.295]         }
[17:45:47.295]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:47.295]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:47.295]             base::sink(type = "output", split = FALSE)
[17:45:47.295]             base::close(...future.stdout)
[17:45:47.295]         }, add = TRUE)
[17:45:47.295]     }
[17:45:47.295]     ...future.frame <- base::sys.nframe()
[17:45:47.295]     ...future.conditions <- base::list()
[17:45:47.295]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:47.295]     if (FALSE) {
[17:45:47.295]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:47.295]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:47.295]     }
[17:45:47.295]     ...future.result <- base::tryCatch({
[17:45:47.295]         base::withCallingHandlers({
[17:45:47.295]             ...future.value <- base::withVisible(base::local({
[17:45:47.295]                 ...future.makeSendCondition <- base::local({
[17:45:47.295]                   sendCondition <- NULL
[17:45:47.295]                   function(frame = 1L) {
[17:45:47.295]                     if (is.function(sendCondition)) 
[17:45:47.295]                       return(sendCondition)
[17:45:47.295]                     ns <- getNamespace("parallel")
[17:45:47.295]                     if (exists("sendData", mode = "function", 
[17:45:47.295]                       envir = ns)) {
[17:45:47.295]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:47.295]                         envir = ns)
[17:45:47.295]                       envir <- sys.frame(frame)
[17:45:47.295]                       master <- NULL
[17:45:47.295]                       while (!identical(envir, .GlobalEnv) && 
[17:45:47.295]                         !identical(envir, emptyenv())) {
[17:45:47.295]                         if (exists("master", mode = "list", envir = envir, 
[17:45:47.295]                           inherits = FALSE)) {
[17:45:47.295]                           master <- get("master", mode = "list", 
[17:45:47.295]                             envir = envir, inherits = FALSE)
[17:45:47.295]                           if (inherits(master, c("SOCKnode", 
[17:45:47.295]                             "SOCK0node"))) {
[17:45:47.295]                             sendCondition <<- function(cond) {
[17:45:47.295]                               data <- list(type = "VALUE", value = cond, 
[17:45:47.295]                                 success = TRUE)
[17:45:47.295]                               parallel_sendData(master, data)
[17:45:47.295]                             }
[17:45:47.295]                             return(sendCondition)
[17:45:47.295]                           }
[17:45:47.295]                         }
[17:45:47.295]                         frame <- frame + 1L
[17:45:47.295]                         envir <- sys.frame(frame)
[17:45:47.295]                       }
[17:45:47.295]                     }
[17:45:47.295]                     sendCondition <<- function(cond) NULL
[17:45:47.295]                   }
[17:45:47.295]                 })
[17:45:47.295]                 withCallingHandlers({
[17:45:47.295]                   {
[17:45:47.295]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:47.295]                     if (!identical(...future.globals.maxSize.org, 
[17:45:47.295]                       ...future.globals.maxSize)) {
[17:45:47.295]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:47.295]                       on.exit(options(oopts), add = TRUE)
[17:45:47.295]                     }
[17:45:47.295]                     {
[17:45:47.295]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:47.295]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:47.295]                         USE.NAMES = FALSE)
[17:45:47.295]                       do.call(mapply, args = args)
[17:45:47.295]                     }
[17:45:47.295]                   }
[17:45:47.295]                 }, immediateCondition = function(cond) {
[17:45:47.295]                   sendCondition <- ...future.makeSendCondition()
[17:45:47.295]                   sendCondition(cond)
[17:45:47.295]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:47.295]                   {
[17:45:47.295]                     inherits <- base::inherits
[17:45:47.295]                     invokeRestart <- base::invokeRestart
[17:45:47.295]                     is.null <- base::is.null
[17:45:47.295]                     muffled <- FALSE
[17:45:47.295]                     if (inherits(cond, "message")) {
[17:45:47.295]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:47.295]                       if (muffled) 
[17:45:47.295]                         invokeRestart("muffleMessage")
[17:45:47.295]                     }
[17:45:47.295]                     else if (inherits(cond, "warning")) {
[17:45:47.295]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:47.295]                       if (muffled) 
[17:45:47.295]                         invokeRestart("muffleWarning")
[17:45:47.295]                     }
[17:45:47.295]                     else if (inherits(cond, "condition")) {
[17:45:47.295]                       if (!is.null(pattern)) {
[17:45:47.295]                         computeRestarts <- base::computeRestarts
[17:45:47.295]                         grepl <- base::grepl
[17:45:47.295]                         restarts <- computeRestarts(cond)
[17:45:47.295]                         for (restart in restarts) {
[17:45:47.295]                           name <- restart$name
[17:45:47.295]                           if (is.null(name)) 
[17:45:47.295]                             next
[17:45:47.295]                           if (!grepl(pattern, name)) 
[17:45:47.295]                             next
[17:45:47.295]                           invokeRestart(restart)
[17:45:47.295]                           muffled <- TRUE
[17:45:47.295]                           break
[17:45:47.295]                         }
[17:45:47.295]                       }
[17:45:47.295]                     }
[17:45:47.295]                     invisible(muffled)
[17:45:47.295]                   }
[17:45:47.295]                   muffleCondition(cond)
[17:45:47.295]                 })
[17:45:47.295]             }))
[17:45:47.295]             future::FutureResult(value = ...future.value$value, 
[17:45:47.295]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:47.295]                   ...future.rng), globalenv = if (FALSE) 
[17:45:47.295]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:47.295]                     ...future.globalenv.names))
[17:45:47.295]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:47.295]         }, condition = base::local({
[17:45:47.295]             c <- base::c
[17:45:47.295]             inherits <- base::inherits
[17:45:47.295]             invokeRestart <- base::invokeRestart
[17:45:47.295]             length <- base::length
[17:45:47.295]             list <- base::list
[17:45:47.295]             seq.int <- base::seq.int
[17:45:47.295]             signalCondition <- base::signalCondition
[17:45:47.295]             sys.calls <- base::sys.calls
[17:45:47.295]             `[[` <- base::`[[`
[17:45:47.295]             `+` <- base::`+`
[17:45:47.295]             `<<-` <- base::`<<-`
[17:45:47.295]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:47.295]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:47.295]                   3L)]
[17:45:47.295]             }
[17:45:47.295]             function(cond) {
[17:45:47.295]                 is_error <- inherits(cond, "error")
[17:45:47.295]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:47.295]                   NULL)
[17:45:47.295]                 if (is_error) {
[17:45:47.295]                   sessionInformation <- function() {
[17:45:47.295]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:47.295]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:47.295]                       search = base::search(), system = base::Sys.info())
[17:45:47.295]                   }
[17:45:47.295]                   ...future.conditions[[length(...future.conditions) + 
[17:45:47.295]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:47.295]                     cond$call), session = sessionInformation(), 
[17:45:47.295]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:47.295]                   signalCondition(cond)
[17:45:47.295]                 }
[17:45:47.295]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:47.295]                 "immediateCondition"))) {
[17:45:47.295]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:47.295]                   ...future.conditions[[length(...future.conditions) + 
[17:45:47.295]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:47.295]                   if (TRUE && !signal) {
[17:45:47.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:47.295]                     {
[17:45:47.295]                       inherits <- base::inherits
[17:45:47.295]                       invokeRestart <- base::invokeRestart
[17:45:47.295]                       is.null <- base::is.null
[17:45:47.295]                       muffled <- FALSE
[17:45:47.295]                       if (inherits(cond, "message")) {
[17:45:47.295]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:47.295]                         if (muffled) 
[17:45:47.295]                           invokeRestart("muffleMessage")
[17:45:47.295]                       }
[17:45:47.295]                       else if (inherits(cond, "warning")) {
[17:45:47.295]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:47.295]                         if (muffled) 
[17:45:47.295]                           invokeRestart("muffleWarning")
[17:45:47.295]                       }
[17:45:47.295]                       else if (inherits(cond, "condition")) {
[17:45:47.295]                         if (!is.null(pattern)) {
[17:45:47.295]                           computeRestarts <- base::computeRestarts
[17:45:47.295]                           grepl <- base::grepl
[17:45:47.295]                           restarts <- computeRestarts(cond)
[17:45:47.295]                           for (restart in restarts) {
[17:45:47.295]                             name <- restart$name
[17:45:47.295]                             if (is.null(name)) 
[17:45:47.295]                               next
[17:45:47.295]                             if (!grepl(pattern, name)) 
[17:45:47.295]                               next
[17:45:47.295]                             invokeRestart(restart)
[17:45:47.295]                             muffled <- TRUE
[17:45:47.295]                             break
[17:45:47.295]                           }
[17:45:47.295]                         }
[17:45:47.295]                       }
[17:45:47.295]                       invisible(muffled)
[17:45:47.295]                     }
[17:45:47.295]                     muffleCondition(cond, pattern = "^muffle")
[17:45:47.295]                   }
[17:45:47.295]                 }
[17:45:47.295]                 else {
[17:45:47.295]                   if (TRUE) {
[17:45:47.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:47.295]                     {
[17:45:47.295]                       inherits <- base::inherits
[17:45:47.295]                       invokeRestart <- base::invokeRestart
[17:45:47.295]                       is.null <- base::is.null
[17:45:47.295]                       muffled <- FALSE
[17:45:47.295]                       if (inherits(cond, "message")) {
[17:45:47.295]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:47.295]                         if (muffled) 
[17:45:47.295]                           invokeRestart("muffleMessage")
[17:45:47.295]                       }
[17:45:47.295]                       else if (inherits(cond, "warning")) {
[17:45:47.295]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:47.295]                         if (muffled) 
[17:45:47.295]                           invokeRestart("muffleWarning")
[17:45:47.295]                       }
[17:45:47.295]                       else if (inherits(cond, "condition")) {
[17:45:47.295]                         if (!is.null(pattern)) {
[17:45:47.295]                           computeRestarts <- base::computeRestarts
[17:45:47.295]                           grepl <- base::grepl
[17:45:47.295]                           restarts <- computeRestarts(cond)
[17:45:47.295]                           for (restart in restarts) {
[17:45:47.295]                             name <- restart$name
[17:45:47.295]                             if (is.null(name)) 
[17:45:47.295]                               next
[17:45:47.295]                             if (!grepl(pattern, name)) 
[17:45:47.295]                               next
[17:45:47.295]                             invokeRestart(restart)
[17:45:47.295]                             muffled <- TRUE
[17:45:47.295]                             break
[17:45:47.295]                           }
[17:45:47.295]                         }
[17:45:47.295]                       }
[17:45:47.295]                       invisible(muffled)
[17:45:47.295]                     }
[17:45:47.295]                     muffleCondition(cond, pattern = "^muffle")
[17:45:47.295]                   }
[17:45:47.295]                 }
[17:45:47.295]             }
[17:45:47.295]         }))
[17:45:47.295]     }, error = function(ex) {
[17:45:47.295]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:47.295]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:47.295]                 ...future.rng), started = ...future.startTime, 
[17:45:47.295]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:47.295]             version = "1.8"), class = "FutureResult")
[17:45:47.295]     }, finally = {
[17:45:47.295]         if (!identical(...future.workdir, getwd())) 
[17:45:47.295]             setwd(...future.workdir)
[17:45:47.295]         {
[17:45:47.295]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:47.295]                 ...future.oldOptions$nwarnings <- NULL
[17:45:47.295]             }
[17:45:47.295]             base::options(...future.oldOptions)
[17:45:47.295]             if (.Platform$OS.type == "windows") {
[17:45:47.295]                 old_names <- names(...future.oldEnvVars)
[17:45:47.295]                 envs <- base::Sys.getenv()
[17:45:47.295]                 names <- names(envs)
[17:45:47.295]                 common <- intersect(names, old_names)
[17:45:47.295]                 added <- setdiff(names, old_names)
[17:45:47.295]                 removed <- setdiff(old_names, names)
[17:45:47.295]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:47.295]                   envs[common]]
[17:45:47.295]                 NAMES <- toupper(changed)
[17:45:47.295]                 args <- list()
[17:45:47.295]                 for (kk in seq_along(NAMES)) {
[17:45:47.295]                   name <- changed[[kk]]
[17:45:47.295]                   NAME <- NAMES[[kk]]
[17:45:47.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:47.295]                     next
[17:45:47.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:47.295]                 }
[17:45:47.295]                 NAMES <- toupper(added)
[17:45:47.295]                 for (kk in seq_along(NAMES)) {
[17:45:47.295]                   name <- added[[kk]]
[17:45:47.295]                   NAME <- NAMES[[kk]]
[17:45:47.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:47.295]                     next
[17:45:47.295]                   args[[name]] <- ""
[17:45:47.295]                 }
[17:45:47.295]                 NAMES <- toupper(removed)
[17:45:47.295]                 for (kk in seq_along(NAMES)) {
[17:45:47.295]                   name <- removed[[kk]]
[17:45:47.295]                   NAME <- NAMES[[kk]]
[17:45:47.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:47.295]                     next
[17:45:47.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:47.295]                 }
[17:45:47.295]                 if (length(args) > 0) 
[17:45:47.295]                   base::do.call(base::Sys.setenv, args = args)
[17:45:47.295]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:47.295]             }
[17:45:47.295]             else {
[17:45:47.295]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:47.295]             }
[17:45:47.295]             {
[17:45:47.295]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:47.295]                   0L) {
[17:45:47.295]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:47.295]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:47.295]                   base::options(opts)
[17:45:47.295]                 }
[17:45:47.295]                 {
[17:45:47.295]                   {
[17:45:47.295]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:47.295]                     NULL
[17:45:47.295]                   }
[17:45:47.295]                   options(future.plan = NULL)
[17:45:47.295]                   if (is.na(NA_character_)) 
[17:45:47.295]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:47.295]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:47.295]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:47.295]                     .init = FALSE)
[17:45:47.295]                 }
[17:45:47.295]             }
[17:45:47.295]         }
[17:45:47.295]     })
[17:45:47.295]     if (TRUE) {
[17:45:47.295]         base::sink(type = "output", split = FALSE)
[17:45:47.295]         if (FALSE) {
[17:45:47.295]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:47.295]         }
[17:45:47.295]         else {
[17:45:47.295]             ...future.result["stdout"] <- base::list(NULL)
[17:45:47.295]         }
[17:45:47.295]         base::close(...future.stdout)
[17:45:47.295]         ...future.stdout <- NULL
[17:45:47.295]     }
[17:45:47.295]     ...future.result$conditions <- ...future.conditions
[17:45:47.295]     ...future.result$finished <- base::Sys.time()
[17:45:47.295]     ...future.result
[17:45:47.295] }
[17:45:47.298] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[17:45:47.298] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[17:45:47.298] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[17:45:47.298] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:45:47.299] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:45:47.299] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:45:47.299] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:45:47.299] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:47.300] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:47.300] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:47.300] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:47.300] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[17:45:47.301] MultisessionFuture started
[17:45:47.301] - Launch lazy future ... done
[17:45:47.301] run() for ‘MultisessionFuture’ ... done
[17:45:47.301] Created future:
[17:45:47.301] MultisessionFuture:
[17:45:47.301] Label: ‘future_mapply-1’
[17:45:47.301] Expression:
[17:45:47.301] {
[17:45:47.301]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:47.301]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:47.301]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:47.301]         on.exit(options(oopts), add = TRUE)
[17:45:47.301]     }
[17:45:47.301]     {
[17:45:47.301]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:47.301]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:47.301]         do.call(mapply, args = args)
[17:45:47.301]     }
[17:45:47.301] }
[17:45:47.301] Lazy evaluation: FALSE
[17:45:47.301] Asynchronous evaluation: TRUE
[17:45:47.301] Local evaluation: TRUE
[17:45:47.301] Environment: R_GlobalEnv
[17:45:47.301] Capture standard output: FALSE
[17:45:47.301] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:47.301] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:47.301] Packages: <none>
[17:45:47.301] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:47.301] Resolved: FALSE
[17:45:47.301] Value: <not collected>
[17:45:47.301] Conditions captured: <none>
[17:45:47.301] Early signaling: FALSE
[17:45:47.301] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:47.301] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:47.312] Chunk #1 of 2 ... DONE
[17:45:47.312] Chunk #2 of 2 ...
[17:45:47.313]  - Finding globals in '...' for chunk #2 ...
[17:45:47.313] getGlobalsAndPackages() ...
[17:45:47.313] Searching for globals...
[17:45:47.313] 
[17:45:47.313] Searching for globals ... DONE
[17:45:47.313] - globals: [0] <none>
[17:45:47.313] getGlobalsAndPackages() ... DONE
[17:45:47.314]    + additional globals found: [n=0] 
[17:45:47.314]    + additional namespaces needed: [n=0] 
[17:45:47.314]  - Finding globals in '...' for chunk #2 ... DONE
[17:45:47.314]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:47.314]  - seeds: <none>
[17:45:47.314]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:47.314] getGlobalsAndPackages() ...
[17:45:47.314] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:47.314] Resolving globals: FALSE
[17:45:47.315] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:45:47.315] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:47.315] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:47.315] 
[17:45:47.316] getGlobalsAndPackages() ... DONE
[17:45:47.316] run() for ‘Future’ ...
[17:45:47.316] - state: ‘created’
[17:45:47.316] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:47.330] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:47.330] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:47.330]   - Field: ‘node’
[17:45:47.330]   - Field: ‘label’
[17:45:47.330]   - Field: ‘local’
[17:45:47.330]   - Field: ‘owner’
[17:45:47.331]   - Field: ‘envir’
[17:45:47.331]   - Field: ‘workers’
[17:45:47.331]   - Field: ‘packages’
[17:45:47.331]   - Field: ‘gc’
[17:45:47.331]   - Field: ‘conditions’
[17:45:47.331]   - Field: ‘persistent’
[17:45:47.331]   - Field: ‘expr’
[17:45:47.331]   - Field: ‘uuid’
[17:45:47.331]   - Field: ‘seed’
[17:45:47.331]   - Field: ‘version’
[17:45:47.332]   - Field: ‘result’
[17:45:47.332]   - Field: ‘asynchronous’
[17:45:47.332]   - Field: ‘calls’
[17:45:47.332]   - Field: ‘globals’
[17:45:47.332]   - Field: ‘stdout’
[17:45:47.332]   - Field: ‘earlySignal’
[17:45:47.332]   - Field: ‘lazy’
[17:45:47.332]   - Field: ‘state’
[17:45:47.332] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:47.332] - Launch lazy future ...
[17:45:47.333] Packages needed by the future expression (n = 0): <none>
[17:45:47.333] Packages needed by future strategies (n = 0): <none>
[17:45:47.333] {
[17:45:47.333]     {
[17:45:47.333]         {
[17:45:47.333]             ...future.startTime <- base::Sys.time()
[17:45:47.333]             {
[17:45:47.333]                 {
[17:45:47.333]                   {
[17:45:47.333]                     {
[17:45:47.333]                       base::local({
[17:45:47.333]                         has_future <- base::requireNamespace("future", 
[17:45:47.333]                           quietly = TRUE)
[17:45:47.333]                         if (has_future) {
[17:45:47.333]                           ns <- base::getNamespace("future")
[17:45:47.333]                           version <- ns[[".package"]][["version"]]
[17:45:47.333]                           if (is.null(version)) 
[17:45:47.333]                             version <- utils::packageVersion("future")
[17:45:47.333]                         }
[17:45:47.333]                         else {
[17:45:47.333]                           version <- NULL
[17:45:47.333]                         }
[17:45:47.333]                         if (!has_future || version < "1.8.0") {
[17:45:47.333]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:47.333]                             "", base::R.version$version.string), 
[17:45:47.333]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:47.333]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:47.333]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:47.333]                               "release", "version")], collapse = " "), 
[17:45:47.333]                             hostname = base::Sys.info()[["nodename"]])
[17:45:47.333]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:47.333]                             info)
[17:45:47.333]                           info <- base::paste(info, collapse = "; ")
[17:45:47.333]                           if (!has_future) {
[17:45:47.333]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:47.333]                               info)
[17:45:47.333]                           }
[17:45:47.333]                           else {
[17:45:47.333]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:47.333]                               info, version)
[17:45:47.333]                           }
[17:45:47.333]                           base::stop(msg)
[17:45:47.333]                         }
[17:45:47.333]                       })
[17:45:47.333]                     }
[17:45:47.333]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:47.333]                     base::options(mc.cores = 1L)
[17:45:47.333]                   }
[17:45:47.333]                   ...future.strategy.old <- future::plan("list")
[17:45:47.333]                   options(future.plan = NULL)
[17:45:47.333]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:47.333]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:47.333]                 }
[17:45:47.333]                 ...future.workdir <- getwd()
[17:45:47.333]             }
[17:45:47.333]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:47.333]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:47.333]         }
[17:45:47.333]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:47.333]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:47.333]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:47.333]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:47.333]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:47.333]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:47.333]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:47.333]             base::names(...future.oldOptions))
[17:45:47.333]     }
[17:45:47.333]     if (FALSE) {
[17:45:47.333]     }
[17:45:47.333]     else {
[17:45:47.333]         if (FALSE) {
[17:45:47.333]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:47.333]                 open = "w")
[17:45:47.333]         }
[17:45:47.333]         else {
[17:45:47.333]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:47.333]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:47.333]         }
[17:45:47.333]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:47.333]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:47.333]             base::sink(type = "output", split = FALSE)
[17:45:47.333]             base::close(...future.stdout)
[17:45:47.333]         }, add = TRUE)
[17:45:47.333]     }
[17:45:47.333]     ...future.frame <- base::sys.nframe()
[17:45:47.333]     ...future.conditions <- base::list()
[17:45:47.333]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:47.333]     if (FALSE) {
[17:45:47.333]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:47.333]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:47.333]     }
[17:45:47.333]     ...future.result <- base::tryCatch({
[17:45:47.333]         base::withCallingHandlers({
[17:45:47.333]             ...future.value <- base::withVisible(base::local({
[17:45:47.333]                 ...future.makeSendCondition <- base::local({
[17:45:47.333]                   sendCondition <- NULL
[17:45:47.333]                   function(frame = 1L) {
[17:45:47.333]                     if (is.function(sendCondition)) 
[17:45:47.333]                       return(sendCondition)
[17:45:47.333]                     ns <- getNamespace("parallel")
[17:45:47.333]                     if (exists("sendData", mode = "function", 
[17:45:47.333]                       envir = ns)) {
[17:45:47.333]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:47.333]                         envir = ns)
[17:45:47.333]                       envir <- sys.frame(frame)
[17:45:47.333]                       master <- NULL
[17:45:47.333]                       while (!identical(envir, .GlobalEnv) && 
[17:45:47.333]                         !identical(envir, emptyenv())) {
[17:45:47.333]                         if (exists("master", mode = "list", envir = envir, 
[17:45:47.333]                           inherits = FALSE)) {
[17:45:47.333]                           master <- get("master", mode = "list", 
[17:45:47.333]                             envir = envir, inherits = FALSE)
[17:45:47.333]                           if (inherits(master, c("SOCKnode", 
[17:45:47.333]                             "SOCK0node"))) {
[17:45:47.333]                             sendCondition <<- function(cond) {
[17:45:47.333]                               data <- list(type = "VALUE", value = cond, 
[17:45:47.333]                                 success = TRUE)
[17:45:47.333]                               parallel_sendData(master, data)
[17:45:47.333]                             }
[17:45:47.333]                             return(sendCondition)
[17:45:47.333]                           }
[17:45:47.333]                         }
[17:45:47.333]                         frame <- frame + 1L
[17:45:47.333]                         envir <- sys.frame(frame)
[17:45:47.333]                       }
[17:45:47.333]                     }
[17:45:47.333]                     sendCondition <<- function(cond) NULL
[17:45:47.333]                   }
[17:45:47.333]                 })
[17:45:47.333]                 withCallingHandlers({
[17:45:47.333]                   {
[17:45:47.333]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:47.333]                     if (!identical(...future.globals.maxSize.org, 
[17:45:47.333]                       ...future.globals.maxSize)) {
[17:45:47.333]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:47.333]                       on.exit(options(oopts), add = TRUE)
[17:45:47.333]                     }
[17:45:47.333]                     {
[17:45:47.333]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:47.333]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:47.333]                         USE.NAMES = FALSE)
[17:45:47.333]                       do.call(mapply, args = args)
[17:45:47.333]                     }
[17:45:47.333]                   }
[17:45:47.333]                 }, immediateCondition = function(cond) {
[17:45:47.333]                   sendCondition <- ...future.makeSendCondition()
[17:45:47.333]                   sendCondition(cond)
[17:45:47.333]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:47.333]                   {
[17:45:47.333]                     inherits <- base::inherits
[17:45:47.333]                     invokeRestart <- base::invokeRestart
[17:45:47.333]                     is.null <- base::is.null
[17:45:47.333]                     muffled <- FALSE
[17:45:47.333]                     if (inherits(cond, "message")) {
[17:45:47.333]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:47.333]                       if (muffled) 
[17:45:47.333]                         invokeRestart("muffleMessage")
[17:45:47.333]                     }
[17:45:47.333]                     else if (inherits(cond, "warning")) {
[17:45:47.333]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:47.333]                       if (muffled) 
[17:45:47.333]                         invokeRestart("muffleWarning")
[17:45:47.333]                     }
[17:45:47.333]                     else if (inherits(cond, "condition")) {
[17:45:47.333]                       if (!is.null(pattern)) {
[17:45:47.333]                         computeRestarts <- base::computeRestarts
[17:45:47.333]                         grepl <- base::grepl
[17:45:47.333]                         restarts <- computeRestarts(cond)
[17:45:47.333]                         for (restart in restarts) {
[17:45:47.333]                           name <- restart$name
[17:45:47.333]                           if (is.null(name)) 
[17:45:47.333]                             next
[17:45:47.333]                           if (!grepl(pattern, name)) 
[17:45:47.333]                             next
[17:45:47.333]                           invokeRestart(restart)
[17:45:47.333]                           muffled <- TRUE
[17:45:47.333]                           break
[17:45:47.333]                         }
[17:45:47.333]                       }
[17:45:47.333]                     }
[17:45:47.333]                     invisible(muffled)
[17:45:47.333]                   }
[17:45:47.333]                   muffleCondition(cond)
[17:45:47.333]                 })
[17:45:47.333]             }))
[17:45:47.333]             future::FutureResult(value = ...future.value$value, 
[17:45:47.333]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:47.333]                   ...future.rng), globalenv = if (FALSE) 
[17:45:47.333]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:47.333]                     ...future.globalenv.names))
[17:45:47.333]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:47.333]         }, condition = base::local({
[17:45:47.333]             c <- base::c
[17:45:47.333]             inherits <- base::inherits
[17:45:47.333]             invokeRestart <- base::invokeRestart
[17:45:47.333]             length <- base::length
[17:45:47.333]             list <- base::list
[17:45:47.333]             seq.int <- base::seq.int
[17:45:47.333]             signalCondition <- base::signalCondition
[17:45:47.333]             sys.calls <- base::sys.calls
[17:45:47.333]             `[[` <- base::`[[`
[17:45:47.333]             `+` <- base::`+`
[17:45:47.333]             `<<-` <- base::`<<-`
[17:45:47.333]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:47.333]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:47.333]                   3L)]
[17:45:47.333]             }
[17:45:47.333]             function(cond) {
[17:45:47.333]                 is_error <- inherits(cond, "error")
[17:45:47.333]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:47.333]                   NULL)
[17:45:47.333]                 if (is_error) {
[17:45:47.333]                   sessionInformation <- function() {
[17:45:47.333]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:47.333]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:47.333]                       search = base::search(), system = base::Sys.info())
[17:45:47.333]                   }
[17:45:47.333]                   ...future.conditions[[length(...future.conditions) + 
[17:45:47.333]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:47.333]                     cond$call), session = sessionInformation(), 
[17:45:47.333]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:47.333]                   signalCondition(cond)
[17:45:47.333]                 }
[17:45:47.333]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:47.333]                 "immediateCondition"))) {
[17:45:47.333]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:47.333]                   ...future.conditions[[length(...future.conditions) + 
[17:45:47.333]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:47.333]                   if (TRUE && !signal) {
[17:45:47.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:47.333]                     {
[17:45:47.333]                       inherits <- base::inherits
[17:45:47.333]                       invokeRestart <- base::invokeRestart
[17:45:47.333]                       is.null <- base::is.null
[17:45:47.333]                       muffled <- FALSE
[17:45:47.333]                       if (inherits(cond, "message")) {
[17:45:47.333]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:47.333]                         if (muffled) 
[17:45:47.333]                           invokeRestart("muffleMessage")
[17:45:47.333]                       }
[17:45:47.333]                       else if (inherits(cond, "warning")) {
[17:45:47.333]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:47.333]                         if (muffled) 
[17:45:47.333]                           invokeRestart("muffleWarning")
[17:45:47.333]                       }
[17:45:47.333]                       else if (inherits(cond, "condition")) {
[17:45:47.333]                         if (!is.null(pattern)) {
[17:45:47.333]                           computeRestarts <- base::computeRestarts
[17:45:47.333]                           grepl <- base::grepl
[17:45:47.333]                           restarts <- computeRestarts(cond)
[17:45:47.333]                           for (restart in restarts) {
[17:45:47.333]                             name <- restart$name
[17:45:47.333]                             if (is.null(name)) 
[17:45:47.333]                               next
[17:45:47.333]                             if (!grepl(pattern, name)) 
[17:45:47.333]                               next
[17:45:47.333]                             invokeRestart(restart)
[17:45:47.333]                             muffled <- TRUE
[17:45:47.333]                             break
[17:45:47.333]                           }
[17:45:47.333]                         }
[17:45:47.333]                       }
[17:45:47.333]                       invisible(muffled)
[17:45:47.333]                     }
[17:45:47.333]                     muffleCondition(cond, pattern = "^muffle")
[17:45:47.333]                   }
[17:45:47.333]                 }
[17:45:47.333]                 else {
[17:45:47.333]                   if (TRUE) {
[17:45:47.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:47.333]                     {
[17:45:47.333]                       inherits <- base::inherits
[17:45:47.333]                       invokeRestart <- base::invokeRestart
[17:45:47.333]                       is.null <- base::is.null
[17:45:47.333]                       muffled <- FALSE
[17:45:47.333]                       if (inherits(cond, "message")) {
[17:45:47.333]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:47.333]                         if (muffled) 
[17:45:47.333]                           invokeRestart("muffleMessage")
[17:45:47.333]                       }
[17:45:47.333]                       else if (inherits(cond, "warning")) {
[17:45:47.333]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:47.333]                         if (muffled) 
[17:45:47.333]                           invokeRestart("muffleWarning")
[17:45:47.333]                       }
[17:45:47.333]                       else if (inherits(cond, "condition")) {
[17:45:47.333]                         if (!is.null(pattern)) {
[17:45:47.333]                           computeRestarts <- base::computeRestarts
[17:45:47.333]                           grepl <- base::grepl
[17:45:47.333]                           restarts <- computeRestarts(cond)
[17:45:47.333]                           for (restart in restarts) {
[17:45:47.333]                             name <- restart$name
[17:45:47.333]                             if (is.null(name)) 
[17:45:47.333]                               next
[17:45:47.333]                             if (!grepl(pattern, name)) 
[17:45:47.333]                               next
[17:45:47.333]                             invokeRestart(restart)
[17:45:47.333]                             muffled <- TRUE
[17:45:47.333]                             break
[17:45:47.333]                           }
[17:45:47.333]                         }
[17:45:47.333]                       }
[17:45:47.333]                       invisible(muffled)
[17:45:47.333]                     }
[17:45:47.333]                     muffleCondition(cond, pattern = "^muffle")
[17:45:47.333]                   }
[17:45:47.333]                 }
[17:45:47.333]             }
[17:45:47.333]         }))
[17:45:47.333]     }, error = function(ex) {
[17:45:47.333]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:47.333]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:47.333]                 ...future.rng), started = ...future.startTime, 
[17:45:47.333]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:47.333]             version = "1.8"), class = "FutureResult")
[17:45:47.333]     }, finally = {
[17:45:47.333]         if (!identical(...future.workdir, getwd())) 
[17:45:47.333]             setwd(...future.workdir)
[17:45:47.333]         {
[17:45:47.333]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:47.333]                 ...future.oldOptions$nwarnings <- NULL
[17:45:47.333]             }
[17:45:47.333]             base::options(...future.oldOptions)
[17:45:47.333]             if (.Platform$OS.type == "windows") {
[17:45:47.333]                 old_names <- names(...future.oldEnvVars)
[17:45:47.333]                 envs <- base::Sys.getenv()
[17:45:47.333]                 names <- names(envs)
[17:45:47.333]                 common <- intersect(names, old_names)
[17:45:47.333]                 added <- setdiff(names, old_names)
[17:45:47.333]                 removed <- setdiff(old_names, names)
[17:45:47.333]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:47.333]                   envs[common]]
[17:45:47.333]                 NAMES <- toupper(changed)
[17:45:47.333]                 args <- list()
[17:45:47.333]                 for (kk in seq_along(NAMES)) {
[17:45:47.333]                   name <- changed[[kk]]
[17:45:47.333]                   NAME <- NAMES[[kk]]
[17:45:47.333]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:47.333]                     next
[17:45:47.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:47.333]                 }
[17:45:47.333]                 NAMES <- toupper(added)
[17:45:47.333]                 for (kk in seq_along(NAMES)) {
[17:45:47.333]                   name <- added[[kk]]
[17:45:47.333]                   NAME <- NAMES[[kk]]
[17:45:47.333]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:47.333]                     next
[17:45:47.333]                   args[[name]] <- ""
[17:45:47.333]                 }
[17:45:47.333]                 NAMES <- toupper(removed)
[17:45:47.333]                 for (kk in seq_along(NAMES)) {
[17:45:47.333]                   name <- removed[[kk]]
[17:45:47.333]                   NAME <- NAMES[[kk]]
[17:45:47.333]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:47.333]                     next
[17:45:47.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:47.333]                 }
[17:45:47.333]                 if (length(args) > 0) 
[17:45:47.333]                   base::do.call(base::Sys.setenv, args = args)
[17:45:47.333]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:47.333]             }
[17:45:47.333]             else {
[17:45:47.333]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:47.333]             }
[17:45:47.333]             {
[17:45:47.333]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:47.333]                   0L) {
[17:45:47.333]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:47.333]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:47.333]                   base::options(opts)
[17:45:47.333]                 }
[17:45:47.333]                 {
[17:45:47.333]                   {
[17:45:47.333]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:47.333]                     NULL
[17:45:47.333]                   }
[17:45:47.333]                   options(future.plan = NULL)
[17:45:47.333]                   if (is.na(NA_character_)) 
[17:45:47.333]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:47.333]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:47.333]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:47.333]                     .init = FALSE)
[17:45:47.333]                 }
[17:45:47.333]             }
[17:45:47.333]         }
[17:45:47.333]     })
[17:45:47.333]     if (TRUE) {
[17:45:47.333]         base::sink(type = "output", split = FALSE)
[17:45:47.333]         if (FALSE) {
[17:45:47.333]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:47.333]         }
[17:45:47.333]         else {
[17:45:47.333]             ...future.result["stdout"] <- base::list(NULL)
[17:45:47.333]         }
[17:45:47.333]         base::close(...future.stdout)
[17:45:47.333]         ...future.stdout <- NULL
[17:45:47.333]     }
[17:45:47.333]     ...future.result$conditions <- ...future.conditions
[17:45:47.333]     ...future.result$finished <- base::Sys.time()
[17:45:47.333]     ...future.result
[17:45:47.333] }
[17:45:47.336] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[17:45:47.336] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[17:45:47.336] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[17:45:47.337] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:45:47.337] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:45:47.337] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:45:47.337] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:45:47.338] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:47.338] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:47.338] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:47.338] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:47.338] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[17:45:47.339] MultisessionFuture started
[17:45:47.339] - Launch lazy future ... done
[17:45:47.339] run() for ‘MultisessionFuture’ ... done
[17:45:47.340] Created future:
[17:45:47.340] MultisessionFuture:
[17:45:47.340] Label: ‘future_mapply-2’
[17:45:47.340] Expression:
[17:45:47.340] {
[17:45:47.340]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:47.340]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:47.340]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:47.340]         on.exit(options(oopts), add = TRUE)
[17:45:47.340]     }
[17:45:47.340]     {
[17:45:47.340]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:47.340]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:47.340]         do.call(mapply, args = args)
[17:45:47.340]     }
[17:45:47.340] }
[17:45:47.340] Lazy evaluation: FALSE
[17:45:47.340] Asynchronous evaluation: TRUE
[17:45:47.340] Local evaluation: TRUE
[17:45:47.340] Environment: R_GlobalEnv
[17:45:47.340] Capture standard output: FALSE
[17:45:47.340] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:47.340] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:47.340] Packages: <none>
[17:45:47.340] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:47.340] Resolved: FALSE
[17:45:47.340] Value: <not collected>
[17:45:47.340] Conditions captured: <none>
[17:45:47.340] Early signaling: FALSE
[17:45:47.340] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:47.340] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:47.351] Chunk #2 of 2 ... DONE
[17:45:47.351] Launching 2 futures (chunks) ... DONE
[17:45:47.351] Resolving 2 futures (chunks) ...
[17:45:47.351] resolve() on list ...
[17:45:47.351]  recursive: 0
[17:45:47.352]  length: 2
[17:45:47.352] 
[17:45:47.393] receiveMessageFromWorker() for ClusterFuture ...
[17:45:47.394] - Validating connection of MultisessionFuture
[17:45:47.394] - received message: FutureResult
[17:45:47.394] - Received FutureResult
[17:45:47.394] - Erased future from FutureRegistry
[17:45:47.394] result() for ClusterFuture ...
[17:45:47.394] - result already collected: FutureResult
[17:45:47.394] result() for ClusterFuture ... done
[17:45:47.395] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:47.395] Future #2
[17:45:47.395] result() for ClusterFuture ...
[17:45:47.395] - result already collected: FutureResult
[17:45:47.395] result() for ClusterFuture ... done
[17:45:47.395] result() for ClusterFuture ...
[17:45:47.395] - result already collected: FutureResult
[17:45:47.395] result() for ClusterFuture ... done
[17:45:47.395] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:47.395] - nx: 2
[17:45:47.395] - relay: TRUE
[17:45:47.396] - stdout: TRUE
[17:45:47.396] - signal: TRUE
[17:45:47.396] - resignal: FALSE
[17:45:47.396] - force: TRUE
[17:45:47.396] - relayed: [n=2] FALSE, FALSE
[17:45:47.396] - queued futures: [n=2] FALSE, FALSE
[17:45:47.396]  - until=1
[17:45:47.396]  - relaying element #1
[17:45:47.396] - relayed: [n=2] FALSE, FALSE
[17:45:47.396] - queued futures: [n=2] FALSE, TRUE
[17:45:47.396] signalConditionsASAP(NULL, pos=2) ... done
[17:45:47.397]  length: 1 (resolved future 2)
[17:45:47.804] receiveMessageFromWorker() for ClusterFuture ...
[17:45:47.804] - Validating connection of MultisessionFuture
[17:45:47.805] - received message: FutureResult
[17:45:47.805] - Received FutureResult
[17:45:47.805] - Erased future from FutureRegistry
[17:45:47.805] result() for ClusterFuture ...
[17:45:47.805] - result already collected: FutureResult
[17:45:47.805] result() for ClusterFuture ... done
[17:45:47.805] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:47.805] Future #1
[17:45:47.806] result() for ClusterFuture ...
[17:45:47.806] - result already collected: FutureResult
[17:45:47.806] result() for ClusterFuture ... done
[17:45:47.806] result() for ClusterFuture ...
[17:45:47.806] - result already collected: FutureResult
[17:45:47.806] result() for ClusterFuture ... done
[17:45:47.806] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:47.806] - nx: 2
[17:45:47.806] - relay: TRUE
[17:45:47.806] - stdout: TRUE
[17:45:47.806] - signal: TRUE
[17:45:47.806] - resignal: FALSE
[17:45:47.807] - force: TRUE
[17:45:47.807] - relayed: [n=2] FALSE, FALSE
[17:45:47.807] - queued futures: [n=2] FALSE, TRUE
[17:45:47.807]  - until=1
[17:45:47.807]  - relaying element #1
[17:45:47.807] result() for ClusterFuture ...
[17:45:47.807] - result already collected: FutureResult
[17:45:47.807] result() for ClusterFuture ... done
[17:45:47.807] result() for ClusterFuture ...
[17:45:47.807] - result already collected: FutureResult
[17:45:47.807] result() for ClusterFuture ... done
[17:45:47.808] result() for ClusterFuture ...
[17:45:47.808] - result already collected: FutureResult
[17:45:47.808] result() for ClusterFuture ... done
[17:45:47.808] result() for ClusterFuture ...
[17:45:47.808] - result already collected: FutureResult
[17:45:47.808] result() for ClusterFuture ... done
[17:45:47.808] - relayed: [n=2] TRUE, FALSE
[17:45:47.808] - queued futures: [n=2] TRUE, TRUE
[17:45:47.808] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:47.808]  length: 0 (resolved future 1)
[17:45:47.808] Relaying remaining futures
[17:45:47.808] signalConditionsASAP(NULL, pos=0) ...
[17:45:47.809] - nx: 2
[17:45:47.809] - relay: TRUE
[17:45:47.809] - stdout: TRUE
[17:45:47.809] - signal: TRUE
[17:45:47.809] - resignal: FALSE
[17:45:47.809] - force: TRUE
[17:45:47.809] - relayed: [n=2] TRUE, FALSE
[17:45:47.809] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:47.809]  - relaying element #2
[17:45:47.809] result() for ClusterFuture ...
[17:45:47.809] - result already collected: FutureResult
[17:45:47.809] result() for ClusterFuture ... done
[17:45:47.810] result() for ClusterFuture ...
[17:45:47.810] - result already collected: FutureResult
[17:45:47.810] result() for ClusterFuture ... done
[17:45:47.810] result() for ClusterFuture ...
[17:45:47.810] - result already collected: FutureResult
[17:45:47.810] result() for ClusterFuture ... done
[17:45:47.810] result() for ClusterFuture ...
[17:45:47.810] - result already collected: FutureResult
[17:45:47.810] result() for ClusterFuture ... done
[17:45:47.810] - relayed: [n=2] TRUE, TRUE
[17:45:47.810] - queued futures: [n=2] TRUE, TRUE
[17:45:47.810] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:45:47.811] resolve() on list ... DONE
[17:45:47.811] result() for ClusterFuture ...
[17:45:47.811] - result already collected: FutureResult
[17:45:47.811] result() for ClusterFuture ... done
[17:45:47.811] result() for ClusterFuture ...
[17:45:47.811] - result already collected: FutureResult
[17:45:47.811] result() for ClusterFuture ... done
[17:45:47.811] result() for ClusterFuture ...
[17:45:47.811] - result already collected: FutureResult
[17:45:47.811] result() for ClusterFuture ... done
[17:45:47.811] result() for ClusterFuture ...
[17:45:47.812] - result already collected: FutureResult
[17:45:47.812] result() for ClusterFuture ... done
[17:45:47.812]  - Number of value chunks collected: 2
[17:45:47.812] Resolving 2 futures (chunks) ... DONE
[17:45:47.812] Reducing values from 2 chunks ...
[17:45:47.812]  - Number of values collected after concatenation: 2
[17:45:47.812]  - Number of values expected: 2
[17:45:47.812] Reducing values from 2 chunks ... DONE
[17:45:47.812] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[17:45:47.813] future_mapply() ...
[17:45:47.816] Number of chunks: 2
[17:45:47.816] getGlobalsAndPackagesXApply() ...
[17:45:47.817]  - future.globals: TRUE
[17:45:47.817] getGlobalsAndPackages() ...
[17:45:47.817] Searching for globals...
[17:45:47.818] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:47.818] Searching for globals ... DONE
[17:45:47.818] Resolving globals: FALSE
[17:45:47.819] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:47.819] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:47.819] - globals: [1] ‘FUN’
[17:45:47.820] 
[17:45:47.820] getGlobalsAndPackages() ... DONE
[17:45:47.820]  - globals found/used: [n=1] ‘FUN’
[17:45:47.820]  - needed namespaces: [n=0] 
[17:45:47.820] Finding globals ... DONE
[17:45:47.820] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:47.820] List of 2
[17:45:47.820]  $ ...future.FUN:function (x, y)  
[17:45:47.820]  $ MoreArgs     : NULL
[17:45:47.820]  - attr(*, "where")=List of 2
[17:45:47.820]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:47.820]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:47.820]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:47.820]  - attr(*, "resolved")= logi FALSE
[17:45:47.820]  - attr(*, "total_size")= num NA
[17:45:47.823] Packages to be attached in all futures: [n=0] 
[17:45:47.823] getGlobalsAndPackagesXApply() ... DONE
[17:45:47.823] Number of futures (= number of chunks): 2
[17:45:47.823] Launching 2 futures (chunks) ...
[17:45:47.823] Chunk #1 of 2 ...
[17:45:47.823]  - Finding globals in '...' for chunk #1 ...
[17:45:47.823] getGlobalsAndPackages() ...
[17:45:47.823] Searching for globals...
[17:45:47.824] 
[17:45:47.824] Searching for globals ... DONE
[17:45:47.824] - globals: [0] <none>
[17:45:47.824] getGlobalsAndPackages() ... DONE
[17:45:47.824]    + additional globals found: [n=0] 
[17:45:47.824]    + additional namespaces needed: [n=0] 
[17:45:47.824]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:47.824]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:47.825]  - seeds: <none>
[17:45:47.825]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:47.825] getGlobalsAndPackages() ...
[17:45:47.825] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:47.825] Resolving globals: FALSE
[17:45:47.825] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:45:47.826] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:47.826] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:47.826] 
[17:45:47.826] getGlobalsAndPackages() ... DONE
[17:45:47.826] run() for ‘Future’ ...
[17:45:47.827] - state: ‘created’
[17:45:47.827] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:47.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:47.841] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:47.841]   - Field: ‘node’
[17:45:47.841]   - Field: ‘label’
[17:45:47.841]   - Field: ‘local’
[17:45:47.841]   - Field: ‘owner’
[17:45:47.841]   - Field: ‘envir’
[17:45:47.841]   - Field: ‘workers’
[17:45:47.841]   - Field: ‘packages’
[17:45:47.841]   - Field: ‘gc’
[17:45:47.842]   - Field: ‘conditions’
[17:45:47.842]   - Field: ‘persistent’
[17:45:47.842]   - Field: ‘expr’
[17:45:47.842]   - Field: ‘uuid’
[17:45:47.842]   - Field: ‘seed’
[17:45:47.842]   - Field: ‘version’
[17:45:47.842]   - Field: ‘result’
[17:45:47.842]   - Field: ‘asynchronous’
[17:45:47.842]   - Field: ‘calls’
[17:45:47.842]   - Field: ‘globals’
[17:45:47.842]   - Field: ‘stdout’
[17:45:47.843]   - Field: ‘earlySignal’
[17:45:47.843]   - Field: ‘lazy’
[17:45:47.843]   - Field: ‘state’
[17:45:47.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:47.843] - Launch lazy future ...
[17:45:47.843] Packages needed by the future expression (n = 0): <none>
[17:45:47.843] Packages needed by future strategies (n = 0): <none>
[17:45:47.844] {
[17:45:47.844]     {
[17:45:47.844]         {
[17:45:47.844]             ...future.startTime <- base::Sys.time()
[17:45:47.844]             {
[17:45:47.844]                 {
[17:45:47.844]                   {
[17:45:47.844]                     {
[17:45:47.844]                       base::local({
[17:45:47.844]                         has_future <- base::requireNamespace("future", 
[17:45:47.844]                           quietly = TRUE)
[17:45:47.844]                         if (has_future) {
[17:45:47.844]                           ns <- base::getNamespace("future")
[17:45:47.844]                           version <- ns[[".package"]][["version"]]
[17:45:47.844]                           if (is.null(version)) 
[17:45:47.844]                             version <- utils::packageVersion("future")
[17:45:47.844]                         }
[17:45:47.844]                         else {
[17:45:47.844]                           version <- NULL
[17:45:47.844]                         }
[17:45:47.844]                         if (!has_future || version < "1.8.0") {
[17:45:47.844]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:47.844]                             "", base::R.version$version.string), 
[17:45:47.844]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:47.844]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:47.844]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:47.844]                               "release", "version")], collapse = " "), 
[17:45:47.844]                             hostname = base::Sys.info()[["nodename"]])
[17:45:47.844]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:47.844]                             info)
[17:45:47.844]                           info <- base::paste(info, collapse = "; ")
[17:45:47.844]                           if (!has_future) {
[17:45:47.844]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:47.844]                               info)
[17:45:47.844]                           }
[17:45:47.844]                           else {
[17:45:47.844]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:47.844]                               info, version)
[17:45:47.844]                           }
[17:45:47.844]                           base::stop(msg)
[17:45:47.844]                         }
[17:45:47.844]                       })
[17:45:47.844]                     }
[17:45:47.844]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:47.844]                     base::options(mc.cores = 1L)
[17:45:47.844]                   }
[17:45:47.844]                   ...future.strategy.old <- future::plan("list")
[17:45:47.844]                   options(future.plan = NULL)
[17:45:47.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:47.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:47.844]                 }
[17:45:47.844]                 ...future.workdir <- getwd()
[17:45:47.844]             }
[17:45:47.844]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:47.844]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:47.844]         }
[17:45:47.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:47.844]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:47.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:47.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:47.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:47.844]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:47.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:47.844]             base::names(...future.oldOptions))
[17:45:47.844]     }
[17:45:47.844]     if (FALSE) {
[17:45:47.844]     }
[17:45:47.844]     else {
[17:45:47.844]         if (TRUE) {
[17:45:47.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:47.844]                 open = "w")
[17:45:47.844]         }
[17:45:47.844]         else {
[17:45:47.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:47.844]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:47.844]         }
[17:45:47.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:47.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:47.844]             base::sink(type = "output", split = FALSE)
[17:45:47.844]             base::close(...future.stdout)
[17:45:47.844]         }, add = TRUE)
[17:45:47.844]     }
[17:45:47.844]     ...future.frame <- base::sys.nframe()
[17:45:47.844]     ...future.conditions <- base::list()
[17:45:47.844]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:47.844]     if (FALSE) {
[17:45:47.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:47.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:47.844]     }
[17:45:47.844]     ...future.result <- base::tryCatch({
[17:45:47.844]         base::withCallingHandlers({
[17:45:47.844]             ...future.value <- base::withVisible(base::local({
[17:45:47.844]                 ...future.makeSendCondition <- base::local({
[17:45:47.844]                   sendCondition <- NULL
[17:45:47.844]                   function(frame = 1L) {
[17:45:47.844]                     if (is.function(sendCondition)) 
[17:45:47.844]                       return(sendCondition)
[17:45:47.844]                     ns <- getNamespace("parallel")
[17:45:47.844]                     if (exists("sendData", mode = "function", 
[17:45:47.844]                       envir = ns)) {
[17:45:47.844]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:47.844]                         envir = ns)
[17:45:47.844]                       envir <- sys.frame(frame)
[17:45:47.844]                       master <- NULL
[17:45:47.844]                       while (!identical(envir, .GlobalEnv) && 
[17:45:47.844]                         !identical(envir, emptyenv())) {
[17:45:47.844]                         if (exists("master", mode = "list", envir = envir, 
[17:45:47.844]                           inherits = FALSE)) {
[17:45:47.844]                           master <- get("master", mode = "list", 
[17:45:47.844]                             envir = envir, inherits = FALSE)
[17:45:47.844]                           if (inherits(master, c("SOCKnode", 
[17:45:47.844]                             "SOCK0node"))) {
[17:45:47.844]                             sendCondition <<- function(cond) {
[17:45:47.844]                               data <- list(type = "VALUE", value = cond, 
[17:45:47.844]                                 success = TRUE)
[17:45:47.844]                               parallel_sendData(master, data)
[17:45:47.844]                             }
[17:45:47.844]                             return(sendCondition)
[17:45:47.844]                           }
[17:45:47.844]                         }
[17:45:47.844]                         frame <- frame + 1L
[17:45:47.844]                         envir <- sys.frame(frame)
[17:45:47.844]                       }
[17:45:47.844]                     }
[17:45:47.844]                     sendCondition <<- function(cond) NULL
[17:45:47.844]                   }
[17:45:47.844]                 })
[17:45:47.844]                 withCallingHandlers({
[17:45:47.844]                   {
[17:45:47.844]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:47.844]                     if (!identical(...future.globals.maxSize.org, 
[17:45:47.844]                       ...future.globals.maxSize)) {
[17:45:47.844]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:47.844]                       on.exit(options(oopts), add = TRUE)
[17:45:47.844]                     }
[17:45:47.844]                     {
[17:45:47.844]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:47.844]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:47.844]                         USE.NAMES = FALSE)
[17:45:47.844]                       do.call(mapply, args = args)
[17:45:47.844]                     }
[17:45:47.844]                   }
[17:45:47.844]                 }, immediateCondition = function(cond) {
[17:45:47.844]                   sendCondition <- ...future.makeSendCondition()
[17:45:47.844]                   sendCondition(cond)
[17:45:47.844]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:47.844]                   {
[17:45:47.844]                     inherits <- base::inherits
[17:45:47.844]                     invokeRestart <- base::invokeRestart
[17:45:47.844]                     is.null <- base::is.null
[17:45:47.844]                     muffled <- FALSE
[17:45:47.844]                     if (inherits(cond, "message")) {
[17:45:47.844]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:47.844]                       if (muffled) 
[17:45:47.844]                         invokeRestart("muffleMessage")
[17:45:47.844]                     }
[17:45:47.844]                     else if (inherits(cond, "warning")) {
[17:45:47.844]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:47.844]                       if (muffled) 
[17:45:47.844]                         invokeRestart("muffleWarning")
[17:45:47.844]                     }
[17:45:47.844]                     else if (inherits(cond, "condition")) {
[17:45:47.844]                       if (!is.null(pattern)) {
[17:45:47.844]                         computeRestarts <- base::computeRestarts
[17:45:47.844]                         grepl <- base::grepl
[17:45:47.844]                         restarts <- computeRestarts(cond)
[17:45:47.844]                         for (restart in restarts) {
[17:45:47.844]                           name <- restart$name
[17:45:47.844]                           if (is.null(name)) 
[17:45:47.844]                             next
[17:45:47.844]                           if (!grepl(pattern, name)) 
[17:45:47.844]                             next
[17:45:47.844]                           invokeRestart(restart)
[17:45:47.844]                           muffled <- TRUE
[17:45:47.844]                           break
[17:45:47.844]                         }
[17:45:47.844]                       }
[17:45:47.844]                     }
[17:45:47.844]                     invisible(muffled)
[17:45:47.844]                   }
[17:45:47.844]                   muffleCondition(cond)
[17:45:47.844]                 })
[17:45:47.844]             }))
[17:45:47.844]             future::FutureResult(value = ...future.value$value, 
[17:45:47.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:47.844]                   ...future.rng), globalenv = if (FALSE) 
[17:45:47.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:47.844]                     ...future.globalenv.names))
[17:45:47.844]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:47.844]         }, condition = base::local({
[17:45:47.844]             c <- base::c
[17:45:47.844]             inherits <- base::inherits
[17:45:47.844]             invokeRestart <- base::invokeRestart
[17:45:47.844]             length <- base::length
[17:45:47.844]             list <- base::list
[17:45:47.844]             seq.int <- base::seq.int
[17:45:47.844]             signalCondition <- base::signalCondition
[17:45:47.844]             sys.calls <- base::sys.calls
[17:45:47.844]             `[[` <- base::`[[`
[17:45:47.844]             `+` <- base::`+`
[17:45:47.844]             `<<-` <- base::`<<-`
[17:45:47.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:47.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:47.844]                   3L)]
[17:45:47.844]             }
[17:45:47.844]             function(cond) {
[17:45:47.844]                 is_error <- inherits(cond, "error")
[17:45:47.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:47.844]                   NULL)
[17:45:47.844]                 if (is_error) {
[17:45:47.844]                   sessionInformation <- function() {
[17:45:47.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:47.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:47.844]                       search = base::search(), system = base::Sys.info())
[17:45:47.844]                   }
[17:45:47.844]                   ...future.conditions[[length(...future.conditions) + 
[17:45:47.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:47.844]                     cond$call), session = sessionInformation(), 
[17:45:47.844]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:47.844]                   signalCondition(cond)
[17:45:47.844]                 }
[17:45:47.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:47.844]                 "immediateCondition"))) {
[17:45:47.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:47.844]                   ...future.conditions[[length(...future.conditions) + 
[17:45:47.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:47.844]                   if (TRUE && !signal) {
[17:45:47.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:47.844]                     {
[17:45:47.844]                       inherits <- base::inherits
[17:45:47.844]                       invokeRestart <- base::invokeRestart
[17:45:47.844]                       is.null <- base::is.null
[17:45:47.844]                       muffled <- FALSE
[17:45:47.844]                       if (inherits(cond, "message")) {
[17:45:47.844]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:47.844]                         if (muffled) 
[17:45:47.844]                           invokeRestart("muffleMessage")
[17:45:47.844]                       }
[17:45:47.844]                       else if (inherits(cond, "warning")) {
[17:45:47.844]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:47.844]                         if (muffled) 
[17:45:47.844]                           invokeRestart("muffleWarning")
[17:45:47.844]                       }
[17:45:47.844]                       else if (inherits(cond, "condition")) {
[17:45:47.844]                         if (!is.null(pattern)) {
[17:45:47.844]                           computeRestarts <- base::computeRestarts
[17:45:47.844]                           grepl <- base::grepl
[17:45:47.844]                           restarts <- computeRestarts(cond)
[17:45:47.844]                           for (restart in restarts) {
[17:45:47.844]                             name <- restart$name
[17:45:47.844]                             if (is.null(name)) 
[17:45:47.844]                               next
[17:45:47.844]                             if (!grepl(pattern, name)) 
[17:45:47.844]                               next
[17:45:47.844]                             invokeRestart(restart)
[17:45:47.844]                             muffled <- TRUE
[17:45:47.844]                             break
[17:45:47.844]                           }
[17:45:47.844]                         }
[17:45:47.844]                       }
[17:45:47.844]                       invisible(muffled)
[17:45:47.844]                     }
[17:45:47.844]                     muffleCondition(cond, pattern = "^muffle")
[17:45:47.844]                   }
[17:45:47.844]                 }
[17:45:47.844]                 else {
[17:45:47.844]                   if (TRUE) {
[17:45:47.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:47.844]                     {
[17:45:47.844]                       inherits <- base::inherits
[17:45:47.844]                       invokeRestart <- base::invokeRestart
[17:45:47.844]                       is.null <- base::is.null
[17:45:47.844]                       muffled <- FALSE
[17:45:47.844]                       if (inherits(cond, "message")) {
[17:45:47.844]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:47.844]                         if (muffled) 
[17:45:47.844]                           invokeRestart("muffleMessage")
[17:45:47.844]                       }
[17:45:47.844]                       else if (inherits(cond, "warning")) {
[17:45:47.844]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:47.844]                         if (muffled) 
[17:45:47.844]                           invokeRestart("muffleWarning")
[17:45:47.844]                       }
[17:45:47.844]                       else if (inherits(cond, "condition")) {
[17:45:47.844]                         if (!is.null(pattern)) {
[17:45:47.844]                           computeRestarts <- base::computeRestarts
[17:45:47.844]                           grepl <- base::grepl
[17:45:47.844]                           restarts <- computeRestarts(cond)
[17:45:47.844]                           for (restart in restarts) {
[17:45:47.844]                             name <- restart$name
[17:45:47.844]                             if (is.null(name)) 
[17:45:47.844]                               next
[17:45:47.844]                             if (!grepl(pattern, name)) 
[17:45:47.844]                               next
[17:45:47.844]                             invokeRestart(restart)
[17:45:47.844]                             muffled <- TRUE
[17:45:47.844]                             break
[17:45:47.844]                           }
[17:45:47.844]                         }
[17:45:47.844]                       }
[17:45:47.844]                       invisible(muffled)
[17:45:47.844]                     }
[17:45:47.844]                     muffleCondition(cond, pattern = "^muffle")
[17:45:47.844]                   }
[17:45:47.844]                 }
[17:45:47.844]             }
[17:45:47.844]         }))
[17:45:47.844]     }, error = function(ex) {
[17:45:47.844]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:47.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:47.844]                 ...future.rng), started = ...future.startTime, 
[17:45:47.844]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:47.844]             version = "1.8"), class = "FutureResult")
[17:45:47.844]     }, finally = {
[17:45:47.844]         if (!identical(...future.workdir, getwd())) 
[17:45:47.844]             setwd(...future.workdir)
[17:45:47.844]         {
[17:45:47.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:47.844]                 ...future.oldOptions$nwarnings <- NULL
[17:45:47.844]             }
[17:45:47.844]             base::options(...future.oldOptions)
[17:45:47.844]             if (.Platform$OS.type == "windows") {
[17:45:47.844]                 old_names <- names(...future.oldEnvVars)
[17:45:47.844]                 envs <- base::Sys.getenv()
[17:45:47.844]                 names <- names(envs)
[17:45:47.844]                 common <- intersect(names, old_names)
[17:45:47.844]                 added <- setdiff(names, old_names)
[17:45:47.844]                 removed <- setdiff(old_names, names)
[17:45:47.844]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:47.844]                   envs[common]]
[17:45:47.844]                 NAMES <- toupper(changed)
[17:45:47.844]                 args <- list()
[17:45:47.844]                 for (kk in seq_along(NAMES)) {
[17:45:47.844]                   name <- changed[[kk]]
[17:45:47.844]                   NAME <- NAMES[[kk]]
[17:45:47.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:47.844]                     next
[17:45:47.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:47.844]                 }
[17:45:47.844]                 NAMES <- toupper(added)
[17:45:47.844]                 for (kk in seq_along(NAMES)) {
[17:45:47.844]                   name <- added[[kk]]
[17:45:47.844]                   NAME <- NAMES[[kk]]
[17:45:47.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:47.844]                     next
[17:45:47.844]                   args[[name]] <- ""
[17:45:47.844]                 }
[17:45:47.844]                 NAMES <- toupper(removed)
[17:45:47.844]                 for (kk in seq_along(NAMES)) {
[17:45:47.844]                   name <- removed[[kk]]
[17:45:47.844]                   NAME <- NAMES[[kk]]
[17:45:47.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:47.844]                     next
[17:45:47.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:47.844]                 }
[17:45:47.844]                 if (length(args) > 0) 
[17:45:47.844]                   base::do.call(base::Sys.setenv, args = args)
[17:45:47.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:47.844]             }
[17:45:47.844]             else {
[17:45:47.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:47.844]             }
[17:45:47.844]             {
[17:45:47.844]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:47.844]                   0L) {
[17:45:47.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:47.844]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:47.844]                   base::options(opts)
[17:45:47.844]                 }
[17:45:47.844]                 {
[17:45:47.844]                   {
[17:45:47.844]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:47.844]                     NULL
[17:45:47.844]                   }
[17:45:47.844]                   options(future.plan = NULL)
[17:45:47.844]                   if (is.na(NA_character_)) 
[17:45:47.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:47.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:47.844]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:47.844]                     .init = FALSE)
[17:45:47.844]                 }
[17:45:47.844]             }
[17:45:47.844]         }
[17:45:47.844]     })
[17:45:47.844]     if (TRUE) {
[17:45:47.844]         base::sink(type = "output", split = FALSE)
[17:45:47.844]         if (TRUE) {
[17:45:47.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:47.844]         }
[17:45:47.844]         else {
[17:45:47.844]             ...future.result["stdout"] <- base::list(NULL)
[17:45:47.844]         }
[17:45:47.844]         base::close(...future.stdout)
[17:45:47.844]         ...future.stdout <- NULL
[17:45:47.844]     }
[17:45:47.844]     ...future.result$conditions <- ...future.conditions
[17:45:47.844]     ...future.result$finished <- base::Sys.time()
[17:45:47.844]     ...future.result
[17:45:47.844] }
[17:45:47.847] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[17:45:47.847] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[17:45:47.847] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[17:45:47.847] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:45:47.848] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:45:47.848] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:45:47.848] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:45:47.848] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:47.848] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:47.849] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:47.849] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:47.849] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[17:45:47.849] MultisessionFuture started
[17:45:47.850] - Launch lazy future ... done
[17:45:47.850] run() for ‘MultisessionFuture’ ... done
[17:45:47.850] Created future:
[17:45:47.850] MultisessionFuture:
[17:45:47.850] Label: ‘future_mapply-1’
[17:45:47.850] Expression:
[17:45:47.850] {
[17:45:47.850]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:47.850]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:47.850]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:47.850]         on.exit(options(oopts), add = TRUE)
[17:45:47.850]     }
[17:45:47.850]     {
[17:45:47.850]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:47.850]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:47.850]         do.call(mapply, args = args)
[17:45:47.850]     }
[17:45:47.850] }
[17:45:47.850] Lazy evaluation: FALSE
[17:45:47.850] Asynchronous evaluation: TRUE
[17:45:47.850] Local evaluation: TRUE
[17:45:47.850] Environment: R_GlobalEnv
[17:45:47.850] Capture standard output: TRUE
[17:45:47.850] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:47.850] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:47.850] Packages: <none>
[17:45:47.850] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:47.850] Resolved: FALSE
[17:45:47.850] Value: <not collected>
[17:45:47.850] Conditions captured: <none>
[17:45:47.850] Early signaling: FALSE
[17:45:47.850] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:47.850] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:47.861] Chunk #1 of 2 ... DONE
[17:45:47.861] Chunk #2 of 2 ...
[17:45:47.861]  - Finding globals in '...' for chunk #2 ...
[17:45:47.862] getGlobalsAndPackages() ...
[17:45:47.862] Searching for globals...
[17:45:47.862] 
[17:45:47.862] Searching for globals ... DONE
[17:45:47.862] - globals: [0] <none>
[17:45:47.862] getGlobalsAndPackages() ... DONE
[17:45:47.862]    + additional globals found: [n=0] 
[17:45:47.863]    + additional namespaces needed: [n=0] 
[17:45:47.863]  - Finding globals in '...' for chunk #2 ... DONE
[17:45:47.863]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:47.863]  - seeds: <none>
[17:45:47.863]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:47.863] getGlobalsAndPackages() ...
[17:45:47.863] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:47.863] Resolving globals: FALSE
[17:45:47.864] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:45:47.864] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:47.864] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:47.864] 
[17:45:47.865] getGlobalsAndPackages() ... DONE
[17:45:47.865] run() for ‘Future’ ...
[17:45:47.865] - state: ‘created’
[17:45:47.865] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:47.879] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:47.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:47.879]   - Field: ‘node’
[17:45:47.879]   - Field: ‘label’
[17:45:47.879]   - Field: ‘local’
[17:45:47.880]   - Field: ‘owner’
[17:45:47.880]   - Field: ‘envir’
[17:45:47.880]   - Field: ‘workers’
[17:45:47.880]   - Field: ‘packages’
[17:45:47.880]   - Field: ‘gc’
[17:45:47.880]   - Field: ‘conditions’
[17:45:47.880]   - Field: ‘persistent’
[17:45:47.880]   - Field: ‘expr’
[17:45:47.880]   - Field: ‘uuid’
[17:45:47.880]   - Field: ‘seed’
[17:45:47.881]   - Field: ‘version’
[17:45:47.881]   - Field: ‘result’
[17:45:47.881]   - Field: ‘asynchronous’
[17:45:47.881]   - Field: ‘calls’
[17:45:47.881]   - Field: ‘globals’
[17:45:47.881]   - Field: ‘stdout’
[17:45:47.881]   - Field: ‘earlySignal’
[17:45:47.881]   - Field: ‘lazy’
[17:45:47.883]   - Field: ‘state’
[17:45:47.884] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:47.884] - Launch lazy future ...
[17:45:47.884] Packages needed by the future expression (n = 0): <none>
[17:45:47.884] Packages needed by future strategies (n = 0): <none>
[17:45:47.884] {
[17:45:47.884]     {
[17:45:47.884]         {
[17:45:47.884]             ...future.startTime <- base::Sys.time()
[17:45:47.884]             {
[17:45:47.884]                 {
[17:45:47.884]                   {
[17:45:47.884]                     {
[17:45:47.884]                       base::local({
[17:45:47.884]                         has_future <- base::requireNamespace("future", 
[17:45:47.884]                           quietly = TRUE)
[17:45:47.884]                         if (has_future) {
[17:45:47.884]                           ns <- base::getNamespace("future")
[17:45:47.884]                           version <- ns[[".package"]][["version"]]
[17:45:47.884]                           if (is.null(version)) 
[17:45:47.884]                             version <- utils::packageVersion("future")
[17:45:47.884]                         }
[17:45:47.884]                         else {
[17:45:47.884]                           version <- NULL
[17:45:47.884]                         }
[17:45:47.884]                         if (!has_future || version < "1.8.0") {
[17:45:47.884]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:47.884]                             "", base::R.version$version.string), 
[17:45:47.884]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:47.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:47.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:47.884]                               "release", "version")], collapse = " "), 
[17:45:47.884]                             hostname = base::Sys.info()[["nodename"]])
[17:45:47.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:47.884]                             info)
[17:45:47.884]                           info <- base::paste(info, collapse = "; ")
[17:45:47.884]                           if (!has_future) {
[17:45:47.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:47.884]                               info)
[17:45:47.884]                           }
[17:45:47.884]                           else {
[17:45:47.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:47.884]                               info, version)
[17:45:47.884]                           }
[17:45:47.884]                           base::stop(msg)
[17:45:47.884]                         }
[17:45:47.884]                       })
[17:45:47.884]                     }
[17:45:47.884]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:47.884]                     base::options(mc.cores = 1L)
[17:45:47.884]                   }
[17:45:47.884]                   ...future.strategy.old <- future::plan("list")
[17:45:47.884]                   options(future.plan = NULL)
[17:45:47.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:47.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:47.884]                 }
[17:45:47.884]                 ...future.workdir <- getwd()
[17:45:47.884]             }
[17:45:47.884]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:47.884]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:47.884]         }
[17:45:47.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:47.884]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:47.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:47.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:47.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:47.884]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:47.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:47.884]             base::names(...future.oldOptions))
[17:45:47.884]     }
[17:45:47.884]     if (FALSE) {
[17:45:47.884]     }
[17:45:47.884]     else {
[17:45:47.884]         if (TRUE) {
[17:45:47.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:47.884]                 open = "w")
[17:45:47.884]         }
[17:45:47.884]         else {
[17:45:47.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:47.884]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:47.884]         }
[17:45:47.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:47.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:47.884]             base::sink(type = "output", split = FALSE)
[17:45:47.884]             base::close(...future.stdout)
[17:45:47.884]         }, add = TRUE)
[17:45:47.884]     }
[17:45:47.884]     ...future.frame <- base::sys.nframe()
[17:45:47.884]     ...future.conditions <- base::list()
[17:45:47.884]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:47.884]     if (FALSE) {
[17:45:47.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:47.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:47.884]     }
[17:45:47.884]     ...future.result <- base::tryCatch({
[17:45:47.884]         base::withCallingHandlers({
[17:45:47.884]             ...future.value <- base::withVisible(base::local({
[17:45:47.884]                 ...future.makeSendCondition <- base::local({
[17:45:47.884]                   sendCondition <- NULL
[17:45:47.884]                   function(frame = 1L) {
[17:45:47.884]                     if (is.function(sendCondition)) 
[17:45:47.884]                       return(sendCondition)
[17:45:47.884]                     ns <- getNamespace("parallel")
[17:45:47.884]                     if (exists("sendData", mode = "function", 
[17:45:47.884]                       envir = ns)) {
[17:45:47.884]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:47.884]                         envir = ns)
[17:45:47.884]                       envir <- sys.frame(frame)
[17:45:47.884]                       master <- NULL
[17:45:47.884]                       while (!identical(envir, .GlobalEnv) && 
[17:45:47.884]                         !identical(envir, emptyenv())) {
[17:45:47.884]                         if (exists("master", mode = "list", envir = envir, 
[17:45:47.884]                           inherits = FALSE)) {
[17:45:47.884]                           master <- get("master", mode = "list", 
[17:45:47.884]                             envir = envir, inherits = FALSE)
[17:45:47.884]                           if (inherits(master, c("SOCKnode", 
[17:45:47.884]                             "SOCK0node"))) {
[17:45:47.884]                             sendCondition <<- function(cond) {
[17:45:47.884]                               data <- list(type = "VALUE", value = cond, 
[17:45:47.884]                                 success = TRUE)
[17:45:47.884]                               parallel_sendData(master, data)
[17:45:47.884]                             }
[17:45:47.884]                             return(sendCondition)
[17:45:47.884]                           }
[17:45:47.884]                         }
[17:45:47.884]                         frame <- frame + 1L
[17:45:47.884]                         envir <- sys.frame(frame)
[17:45:47.884]                       }
[17:45:47.884]                     }
[17:45:47.884]                     sendCondition <<- function(cond) NULL
[17:45:47.884]                   }
[17:45:47.884]                 })
[17:45:47.884]                 withCallingHandlers({
[17:45:47.884]                   {
[17:45:47.884]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:47.884]                     if (!identical(...future.globals.maxSize.org, 
[17:45:47.884]                       ...future.globals.maxSize)) {
[17:45:47.884]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:47.884]                       on.exit(options(oopts), add = TRUE)
[17:45:47.884]                     }
[17:45:47.884]                     {
[17:45:47.884]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:47.884]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:47.884]                         USE.NAMES = FALSE)
[17:45:47.884]                       do.call(mapply, args = args)
[17:45:47.884]                     }
[17:45:47.884]                   }
[17:45:47.884]                 }, immediateCondition = function(cond) {
[17:45:47.884]                   sendCondition <- ...future.makeSendCondition()
[17:45:47.884]                   sendCondition(cond)
[17:45:47.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:47.884]                   {
[17:45:47.884]                     inherits <- base::inherits
[17:45:47.884]                     invokeRestart <- base::invokeRestart
[17:45:47.884]                     is.null <- base::is.null
[17:45:47.884]                     muffled <- FALSE
[17:45:47.884]                     if (inherits(cond, "message")) {
[17:45:47.884]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:47.884]                       if (muffled) 
[17:45:47.884]                         invokeRestart("muffleMessage")
[17:45:47.884]                     }
[17:45:47.884]                     else if (inherits(cond, "warning")) {
[17:45:47.884]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:47.884]                       if (muffled) 
[17:45:47.884]                         invokeRestart("muffleWarning")
[17:45:47.884]                     }
[17:45:47.884]                     else if (inherits(cond, "condition")) {
[17:45:47.884]                       if (!is.null(pattern)) {
[17:45:47.884]                         computeRestarts <- base::computeRestarts
[17:45:47.884]                         grepl <- base::grepl
[17:45:47.884]                         restarts <- computeRestarts(cond)
[17:45:47.884]                         for (restart in restarts) {
[17:45:47.884]                           name <- restart$name
[17:45:47.884]                           if (is.null(name)) 
[17:45:47.884]                             next
[17:45:47.884]                           if (!grepl(pattern, name)) 
[17:45:47.884]                             next
[17:45:47.884]                           invokeRestart(restart)
[17:45:47.884]                           muffled <- TRUE
[17:45:47.884]                           break
[17:45:47.884]                         }
[17:45:47.884]                       }
[17:45:47.884]                     }
[17:45:47.884]                     invisible(muffled)
[17:45:47.884]                   }
[17:45:47.884]                   muffleCondition(cond)
[17:45:47.884]                 })
[17:45:47.884]             }))
[17:45:47.884]             future::FutureResult(value = ...future.value$value, 
[17:45:47.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:47.884]                   ...future.rng), globalenv = if (FALSE) 
[17:45:47.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:47.884]                     ...future.globalenv.names))
[17:45:47.884]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:47.884]         }, condition = base::local({
[17:45:47.884]             c <- base::c
[17:45:47.884]             inherits <- base::inherits
[17:45:47.884]             invokeRestart <- base::invokeRestart
[17:45:47.884]             length <- base::length
[17:45:47.884]             list <- base::list
[17:45:47.884]             seq.int <- base::seq.int
[17:45:47.884]             signalCondition <- base::signalCondition
[17:45:47.884]             sys.calls <- base::sys.calls
[17:45:47.884]             `[[` <- base::`[[`
[17:45:47.884]             `+` <- base::`+`
[17:45:47.884]             `<<-` <- base::`<<-`
[17:45:47.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:47.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:47.884]                   3L)]
[17:45:47.884]             }
[17:45:47.884]             function(cond) {
[17:45:47.884]                 is_error <- inherits(cond, "error")
[17:45:47.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:47.884]                   NULL)
[17:45:47.884]                 if (is_error) {
[17:45:47.884]                   sessionInformation <- function() {
[17:45:47.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:47.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:47.884]                       search = base::search(), system = base::Sys.info())
[17:45:47.884]                   }
[17:45:47.884]                   ...future.conditions[[length(...future.conditions) + 
[17:45:47.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:47.884]                     cond$call), session = sessionInformation(), 
[17:45:47.884]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:47.884]                   signalCondition(cond)
[17:45:47.884]                 }
[17:45:47.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:47.884]                 "immediateCondition"))) {
[17:45:47.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:47.884]                   ...future.conditions[[length(...future.conditions) + 
[17:45:47.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:47.884]                   if (TRUE && !signal) {
[17:45:47.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:47.884]                     {
[17:45:47.884]                       inherits <- base::inherits
[17:45:47.884]                       invokeRestart <- base::invokeRestart
[17:45:47.884]                       is.null <- base::is.null
[17:45:47.884]                       muffled <- FALSE
[17:45:47.884]                       if (inherits(cond, "message")) {
[17:45:47.884]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:47.884]                         if (muffled) 
[17:45:47.884]                           invokeRestart("muffleMessage")
[17:45:47.884]                       }
[17:45:47.884]                       else if (inherits(cond, "warning")) {
[17:45:47.884]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:47.884]                         if (muffled) 
[17:45:47.884]                           invokeRestart("muffleWarning")
[17:45:47.884]                       }
[17:45:47.884]                       else if (inherits(cond, "condition")) {
[17:45:47.884]                         if (!is.null(pattern)) {
[17:45:47.884]                           computeRestarts <- base::computeRestarts
[17:45:47.884]                           grepl <- base::grepl
[17:45:47.884]                           restarts <- computeRestarts(cond)
[17:45:47.884]                           for (restart in restarts) {
[17:45:47.884]                             name <- restart$name
[17:45:47.884]                             if (is.null(name)) 
[17:45:47.884]                               next
[17:45:47.884]                             if (!grepl(pattern, name)) 
[17:45:47.884]                               next
[17:45:47.884]                             invokeRestart(restart)
[17:45:47.884]                             muffled <- TRUE
[17:45:47.884]                             break
[17:45:47.884]                           }
[17:45:47.884]                         }
[17:45:47.884]                       }
[17:45:47.884]                       invisible(muffled)
[17:45:47.884]                     }
[17:45:47.884]                     muffleCondition(cond, pattern = "^muffle")
[17:45:47.884]                   }
[17:45:47.884]                 }
[17:45:47.884]                 else {
[17:45:47.884]                   if (TRUE) {
[17:45:47.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:47.884]                     {
[17:45:47.884]                       inherits <- base::inherits
[17:45:47.884]                       invokeRestart <- base::invokeRestart
[17:45:47.884]                       is.null <- base::is.null
[17:45:47.884]                       muffled <- FALSE
[17:45:47.884]                       if (inherits(cond, "message")) {
[17:45:47.884]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:47.884]                         if (muffled) 
[17:45:47.884]                           invokeRestart("muffleMessage")
[17:45:47.884]                       }
[17:45:47.884]                       else if (inherits(cond, "warning")) {
[17:45:47.884]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:47.884]                         if (muffled) 
[17:45:47.884]                           invokeRestart("muffleWarning")
[17:45:47.884]                       }
[17:45:47.884]                       else if (inherits(cond, "condition")) {
[17:45:47.884]                         if (!is.null(pattern)) {
[17:45:47.884]                           computeRestarts <- base::computeRestarts
[17:45:47.884]                           grepl <- base::grepl
[17:45:47.884]                           restarts <- computeRestarts(cond)
[17:45:47.884]                           for (restart in restarts) {
[17:45:47.884]                             name <- restart$name
[17:45:47.884]                             if (is.null(name)) 
[17:45:47.884]                               next
[17:45:47.884]                             if (!grepl(pattern, name)) 
[17:45:47.884]                               next
[17:45:47.884]                             invokeRestart(restart)
[17:45:47.884]                             muffled <- TRUE
[17:45:47.884]                             break
[17:45:47.884]                           }
[17:45:47.884]                         }
[17:45:47.884]                       }
[17:45:47.884]                       invisible(muffled)
[17:45:47.884]                     }
[17:45:47.884]                     muffleCondition(cond, pattern = "^muffle")
[17:45:47.884]                   }
[17:45:47.884]                 }
[17:45:47.884]             }
[17:45:47.884]         }))
[17:45:47.884]     }, error = function(ex) {
[17:45:47.884]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:47.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:47.884]                 ...future.rng), started = ...future.startTime, 
[17:45:47.884]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:47.884]             version = "1.8"), class = "FutureResult")
[17:45:47.884]     }, finally = {
[17:45:47.884]         if (!identical(...future.workdir, getwd())) 
[17:45:47.884]             setwd(...future.workdir)
[17:45:47.884]         {
[17:45:47.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:47.884]                 ...future.oldOptions$nwarnings <- NULL
[17:45:47.884]             }
[17:45:47.884]             base::options(...future.oldOptions)
[17:45:47.884]             if (.Platform$OS.type == "windows") {
[17:45:47.884]                 old_names <- names(...future.oldEnvVars)
[17:45:47.884]                 envs <- base::Sys.getenv()
[17:45:47.884]                 names <- names(envs)
[17:45:47.884]                 common <- intersect(names, old_names)
[17:45:47.884]                 added <- setdiff(names, old_names)
[17:45:47.884]                 removed <- setdiff(old_names, names)
[17:45:47.884]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:47.884]                   envs[common]]
[17:45:47.884]                 NAMES <- toupper(changed)
[17:45:47.884]                 args <- list()
[17:45:47.884]                 for (kk in seq_along(NAMES)) {
[17:45:47.884]                   name <- changed[[kk]]
[17:45:47.884]                   NAME <- NAMES[[kk]]
[17:45:47.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:47.884]                     next
[17:45:47.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:47.884]                 }
[17:45:47.884]                 NAMES <- toupper(added)
[17:45:47.884]                 for (kk in seq_along(NAMES)) {
[17:45:47.884]                   name <- added[[kk]]
[17:45:47.884]                   NAME <- NAMES[[kk]]
[17:45:47.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:47.884]                     next
[17:45:47.884]                   args[[name]] <- ""
[17:45:47.884]                 }
[17:45:47.884]                 NAMES <- toupper(removed)
[17:45:47.884]                 for (kk in seq_along(NAMES)) {
[17:45:47.884]                   name <- removed[[kk]]
[17:45:47.884]                   NAME <- NAMES[[kk]]
[17:45:47.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:47.884]                     next
[17:45:47.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:47.884]                 }
[17:45:47.884]                 if (length(args) > 0) 
[17:45:47.884]                   base::do.call(base::Sys.setenv, args = args)
[17:45:47.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:47.884]             }
[17:45:47.884]             else {
[17:45:47.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:47.884]             }
[17:45:47.884]             {
[17:45:47.884]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:47.884]                   0L) {
[17:45:47.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:47.884]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:47.884]                   base::options(opts)
[17:45:47.884]                 }
[17:45:47.884]                 {
[17:45:47.884]                   {
[17:45:47.884]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:47.884]                     NULL
[17:45:47.884]                   }
[17:45:47.884]                   options(future.plan = NULL)
[17:45:47.884]                   if (is.na(NA_character_)) 
[17:45:47.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:47.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:47.884]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:47.884]                     .init = FALSE)
[17:45:47.884]                 }
[17:45:47.884]             }
[17:45:47.884]         }
[17:45:47.884]     })
[17:45:47.884]     if (TRUE) {
[17:45:47.884]         base::sink(type = "output", split = FALSE)
[17:45:47.884]         if (TRUE) {
[17:45:47.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:47.884]         }
[17:45:47.884]         else {
[17:45:47.884]             ...future.result["stdout"] <- base::list(NULL)
[17:45:47.884]         }
[17:45:47.884]         base::close(...future.stdout)
[17:45:47.884]         ...future.stdout <- NULL
[17:45:47.884]     }
[17:45:47.884]     ...future.result$conditions <- ...future.conditions
[17:45:47.884]     ...future.result$finished <- base::Sys.time()
[17:45:47.884]     ...future.result
[17:45:47.884] }
[17:45:47.887] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[17:45:47.887] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[17:45:47.888] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[17:45:47.888] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:45:47.888] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:45:47.888] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:45:47.889] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:45:47.889] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:47.889] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:47.889] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:47.890] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:47.890] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[17:45:47.890] MultisessionFuture started
[17:45:47.890] - Launch lazy future ... done
[17:45:47.891] run() for ‘MultisessionFuture’ ... done
[17:45:47.891] Created future:
[17:45:47.891] MultisessionFuture:
[17:45:47.891] Label: ‘future_mapply-2’
[17:45:47.891] Expression:
[17:45:47.891] {
[17:45:47.891]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:47.891]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:47.891]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:47.891]         on.exit(options(oopts), add = TRUE)
[17:45:47.891]     }
[17:45:47.891]     {
[17:45:47.891]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:47.891]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:47.891]         do.call(mapply, args = args)
[17:45:47.891]     }
[17:45:47.891] }
[17:45:47.891] Lazy evaluation: FALSE
[17:45:47.891] Asynchronous evaluation: TRUE
[17:45:47.891] Local evaluation: TRUE
[17:45:47.891] Environment: R_GlobalEnv
[17:45:47.891] Capture standard output: TRUE
[17:45:47.891] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:47.891] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:47.891] Packages: <none>
[17:45:47.891] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:47.891] Resolved: FALSE
[17:45:47.891] Value: <not collected>
[17:45:47.891] Conditions captured: <none>
[17:45:47.891] Early signaling: FALSE
[17:45:47.891] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:47.891] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:47.902] Chunk #2 of 2 ... DONE
[17:45:47.902] Launching 2 futures (chunks) ... DONE
[17:45:47.903] Resolving 2 futures (chunks) ...
[17:45:47.903] resolve() on list ...
[17:45:47.903]  recursive: 0
[17:45:47.903]  length: 2
[17:45:47.903] 
[17:45:47.945] receiveMessageFromWorker() for ClusterFuture ...
[17:45:47.945] - Validating connection of MultisessionFuture
[17:45:47.945] - received message: FutureResult
[17:45:47.946] - Received FutureResult
[17:45:47.946] - Erased future from FutureRegistry
[17:45:47.946] result() for ClusterFuture ...
[17:45:47.946] - result already collected: FutureResult
[17:45:47.946] result() for ClusterFuture ... done
[17:45:47.946] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:47.946] Future #2
[17:45:47.946] result() for ClusterFuture ...
[17:45:47.946] - result already collected: FutureResult
[17:45:47.946] result() for ClusterFuture ... done
[17:45:47.946] result() for ClusterFuture ...
[17:45:47.947] - result already collected: FutureResult
[17:45:47.947] result() for ClusterFuture ... done
[17:45:47.947] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:47.947] - nx: 2
[17:45:47.947] - relay: TRUE
[17:45:47.947] - stdout: TRUE
[17:45:47.947] - signal: TRUE
[17:45:47.947] - resignal: FALSE
[17:45:47.947] - force: TRUE
[17:45:47.947] - relayed: [n=2] FALSE, FALSE
[17:45:47.947] - queued futures: [n=2] FALSE, FALSE
[17:45:47.948]  - until=1
[17:45:47.948]  - relaying element #1
[17:45:47.948] - relayed: [n=2] FALSE, FALSE
[17:45:47.948] - queued futures: [n=2] FALSE, TRUE
[17:45:47.948] signalConditionsASAP(NULL, pos=2) ... done
[17:45:47.948]  length: 1 (resolved future 2)
[17:45:48.394] receiveMessageFromWorker() for ClusterFuture ...
[17:45:48.394] - Validating connection of MultisessionFuture
[17:45:48.394] - received message: FutureResult
[17:45:48.394] - Received FutureResult
[17:45:48.394] - Erased future from FutureRegistry
[17:45:48.395] result() for ClusterFuture ...
[17:45:48.395] - result already collected: FutureResult
[17:45:48.395] result() for ClusterFuture ... done
[17:45:48.395] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:48.395] Future #1
[17:45:48.395] result() for ClusterFuture ...
[17:45:48.395] - result already collected: FutureResult
[17:45:48.395] result() for ClusterFuture ... done
[17:45:48.395] result() for ClusterFuture ...
[17:45:48.395] - result already collected: FutureResult
[17:45:48.396] result() for ClusterFuture ... done
[17:45:48.396] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:48.396] - nx: 2
[17:45:48.396] - relay: TRUE
[17:45:48.396] - stdout: TRUE
[17:45:48.396] - signal: TRUE
[17:45:48.396] - resignal: FALSE
[17:45:48.396] - force: TRUE
[17:45:48.396] - relayed: [n=2] FALSE, FALSE
[17:45:48.396] - queued futures: [n=2] FALSE, TRUE
[17:45:48.396]  - until=1
[17:45:48.396]  - relaying element #1
[17:45:48.397] result() for ClusterFuture ...
[17:45:48.397] - result already collected: FutureResult
[17:45:48.397] result() for ClusterFuture ... done
[17:45:48.397] result() for ClusterFuture ...
[17:45:48.397] - result already collected: FutureResult
[17:45:48.397] result() for ClusterFuture ... done
[17:45:48.397] result() for ClusterFuture ...
[17:45:48.397] - result already collected: FutureResult
[17:45:48.397] result() for ClusterFuture ... done
[17:45:48.397] result() for ClusterFuture ...
[17:45:48.397] - result already collected: FutureResult
[17:45:48.398] result() for ClusterFuture ... done
[17:45:48.398] - relayed: [n=2] TRUE, FALSE
[17:45:48.398] - queued futures: [n=2] TRUE, TRUE
[17:45:48.398] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:48.398]  length: 0 (resolved future 1)
[17:45:48.398] Relaying remaining futures
[17:45:48.398] signalConditionsASAP(NULL, pos=0) ...
[17:45:48.398] - nx: 2
[17:45:48.398] - relay: TRUE
[17:45:48.398] - stdout: TRUE
[17:45:48.398] - signal: TRUE
[17:45:48.398] - resignal: FALSE
[17:45:48.399] - force: TRUE
[17:45:48.399] - relayed: [n=2] TRUE, FALSE
[17:45:48.399] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:48.399]  - relaying element #2
[17:45:48.399] result() for ClusterFuture ...
[17:45:48.399] - result already collected: FutureResult
[17:45:48.399] result() for ClusterFuture ... done
[17:45:48.399] result() for ClusterFuture ...
[17:45:48.399] - result already collected: FutureResult
[17:45:48.399] result() for ClusterFuture ... done
[17:45:48.400] result() for ClusterFuture ...
[17:45:48.400] - result already collected: FutureResult
[17:45:48.400] result() for ClusterFuture ... done
[17:45:48.400] result() for ClusterFuture ...
[17:45:48.400] - result already collected: FutureResult
[17:45:48.400] result() for ClusterFuture ... done
[17:45:48.400] - relayed: [n=2] TRUE, TRUE
[17:45:48.400] - queued futures: [n=2] TRUE, TRUE
[17:45:48.400] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:45:48.400] resolve() on list ... DONE
[17:45:48.400] result() for ClusterFuture ...
[17:45:48.400] - result already collected: FutureResult
[17:45:48.401] result() for ClusterFuture ... done
[17:45:48.401] result() for ClusterFuture ...
[17:45:48.401] - result already collected: FutureResult
[17:45:48.401] result() for ClusterFuture ... done
[17:45:48.401] result() for ClusterFuture ...
[17:45:48.401] - result already collected: FutureResult
[17:45:48.401] result() for ClusterFuture ... done
[17:45:48.401] result() for ClusterFuture ...
[17:45:48.401] - result already collected: FutureResult
[17:45:48.401] result() for ClusterFuture ... done
[17:45:48.401]  - Number of value chunks collected: 2
[17:45:48.401] Resolving 2 futures (chunks) ... DONE
[17:45:48.402] Reducing values from 2 chunks ...
[17:45:48.402]  - Number of values collected after concatenation: 2
[17:45:48.402]  - Number of values expected: 2
[17:45:48.402] Reducing values from 2 chunks ... DONE
[17:45:48.402] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[17:45:48.402] future_mapply() ...
[17:45:48.406] Number of chunks: 2
[17:45:48.406] getGlobalsAndPackagesXApply() ...
[17:45:48.406]  - future.globals: TRUE
[17:45:48.406] getGlobalsAndPackages() ...
[17:45:48.406] Searching for globals...
[17:45:48.408] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[17:45:48.408] Searching for globals ... DONE
[17:45:48.408] Resolving globals: FALSE
[17:45:48.409] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[17:45:48.409] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[17:45:48.409] - globals: [1] ‘FUN’
[17:45:48.409] 
[17:45:48.409] getGlobalsAndPackages() ... DONE
[17:45:48.409]  - globals found/used: [n=1] ‘FUN’
[17:45:48.410]  - needed namespaces: [n=0] 
[17:45:48.410] Finding globals ... DONE
[17:45:48.410] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:45:48.410] List of 2
[17:45:48.410]  $ ...future.FUN:function (x, y)  
[17:45:48.410]  $ MoreArgs     : NULL
[17:45:48.410]  - attr(*, "where")=List of 2
[17:45:48.410]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:48.410]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:45:48.410]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:48.410]  - attr(*, "resolved")= logi FALSE
[17:45:48.410]  - attr(*, "total_size")= num NA
[17:45:48.412] Packages to be attached in all futures: [n=0] 
[17:45:48.412] getGlobalsAndPackagesXApply() ... DONE
[17:45:48.413] Number of futures (= number of chunks): 2
[17:45:48.413] Launching 2 futures (chunks) ...
[17:45:48.413] Chunk #1 of 2 ...
[17:45:48.413]  - Finding globals in '...' for chunk #1 ...
[17:45:48.413] getGlobalsAndPackages() ...
[17:45:48.413] Searching for globals...
[17:45:48.413] 
[17:45:48.414] Searching for globals ... DONE
[17:45:48.414] - globals: [0] <none>
[17:45:48.414] getGlobalsAndPackages() ... DONE
[17:45:48.414]    + additional globals found: [n=0] 
[17:45:48.414]    + additional namespaces needed: [n=0] 
[17:45:48.414]  - Finding globals in '...' for chunk #1 ... DONE
[17:45:48.414]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:48.414]  - seeds: <none>
[17:45:48.414]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:48.414] getGlobalsAndPackages() ...
[17:45:48.414] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:48.415] Resolving globals: FALSE
[17:45:48.415] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:45:48.415] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:48.416] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:48.416] 
[17:45:48.416] getGlobalsAndPackages() ... DONE
[17:45:48.416] run() for ‘Future’ ...
[17:45:48.416] - state: ‘created’
[17:45:48.416] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:48.430] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:48.430] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:48.430]   - Field: ‘node’
[17:45:48.430]   - Field: ‘label’
[17:45:48.430]   - Field: ‘local’
[17:45:48.430]   - Field: ‘owner’
[17:45:48.431]   - Field: ‘envir’
[17:45:48.431]   - Field: ‘workers’
[17:45:48.431]   - Field: ‘packages’
[17:45:48.431]   - Field: ‘gc’
[17:45:48.431]   - Field: ‘conditions’
[17:45:48.431]   - Field: ‘persistent’
[17:45:48.431]   - Field: ‘expr’
[17:45:48.431]   - Field: ‘uuid’
[17:45:48.431]   - Field: ‘seed’
[17:45:48.432]   - Field: ‘version’
[17:45:48.432]   - Field: ‘result’
[17:45:48.432]   - Field: ‘asynchronous’
[17:45:48.432]   - Field: ‘calls’
[17:45:48.432]   - Field: ‘globals’
[17:45:48.432]   - Field: ‘stdout’
[17:45:48.432]   - Field: ‘earlySignal’
[17:45:48.432]   - Field: ‘lazy’
[17:45:48.432]   - Field: ‘state’
[17:45:48.432] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:48.432] - Launch lazy future ...
[17:45:48.433] Packages needed by the future expression (n = 0): <none>
[17:45:48.433] Packages needed by future strategies (n = 0): <none>
[17:45:48.433] {
[17:45:48.433]     {
[17:45:48.433]         {
[17:45:48.433]             ...future.startTime <- base::Sys.time()
[17:45:48.433]             {
[17:45:48.433]                 {
[17:45:48.433]                   {
[17:45:48.433]                     {
[17:45:48.433]                       base::local({
[17:45:48.433]                         has_future <- base::requireNamespace("future", 
[17:45:48.433]                           quietly = TRUE)
[17:45:48.433]                         if (has_future) {
[17:45:48.433]                           ns <- base::getNamespace("future")
[17:45:48.433]                           version <- ns[[".package"]][["version"]]
[17:45:48.433]                           if (is.null(version)) 
[17:45:48.433]                             version <- utils::packageVersion("future")
[17:45:48.433]                         }
[17:45:48.433]                         else {
[17:45:48.433]                           version <- NULL
[17:45:48.433]                         }
[17:45:48.433]                         if (!has_future || version < "1.8.0") {
[17:45:48.433]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:48.433]                             "", base::R.version$version.string), 
[17:45:48.433]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:48.433]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:48.433]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:48.433]                               "release", "version")], collapse = " "), 
[17:45:48.433]                             hostname = base::Sys.info()[["nodename"]])
[17:45:48.433]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:48.433]                             info)
[17:45:48.433]                           info <- base::paste(info, collapse = "; ")
[17:45:48.433]                           if (!has_future) {
[17:45:48.433]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:48.433]                               info)
[17:45:48.433]                           }
[17:45:48.433]                           else {
[17:45:48.433]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:48.433]                               info, version)
[17:45:48.433]                           }
[17:45:48.433]                           base::stop(msg)
[17:45:48.433]                         }
[17:45:48.433]                       })
[17:45:48.433]                     }
[17:45:48.433]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:48.433]                     base::options(mc.cores = 1L)
[17:45:48.433]                   }
[17:45:48.433]                   ...future.strategy.old <- future::plan("list")
[17:45:48.433]                   options(future.plan = NULL)
[17:45:48.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:48.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:48.433]                 }
[17:45:48.433]                 ...future.workdir <- getwd()
[17:45:48.433]             }
[17:45:48.433]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:48.433]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:48.433]         }
[17:45:48.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:48.433]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:48.433]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:48.433]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:48.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:48.433]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:48.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:48.433]             base::names(...future.oldOptions))
[17:45:48.433]     }
[17:45:48.433]     if (TRUE) {
[17:45:48.433]     }
[17:45:48.433]     else {
[17:45:48.433]         if (NA) {
[17:45:48.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:48.433]                 open = "w")
[17:45:48.433]         }
[17:45:48.433]         else {
[17:45:48.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:48.433]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:48.433]         }
[17:45:48.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:48.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:48.433]             base::sink(type = "output", split = FALSE)
[17:45:48.433]             base::close(...future.stdout)
[17:45:48.433]         }, add = TRUE)
[17:45:48.433]     }
[17:45:48.433]     ...future.frame <- base::sys.nframe()
[17:45:48.433]     ...future.conditions <- base::list()
[17:45:48.433]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:48.433]     if (FALSE) {
[17:45:48.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:48.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:48.433]     }
[17:45:48.433]     ...future.result <- base::tryCatch({
[17:45:48.433]         base::withCallingHandlers({
[17:45:48.433]             ...future.value <- base::withVisible(base::local({
[17:45:48.433]                 ...future.makeSendCondition <- base::local({
[17:45:48.433]                   sendCondition <- NULL
[17:45:48.433]                   function(frame = 1L) {
[17:45:48.433]                     if (is.function(sendCondition)) 
[17:45:48.433]                       return(sendCondition)
[17:45:48.433]                     ns <- getNamespace("parallel")
[17:45:48.433]                     if (exists("sendData", mode = "function", 
[17:45:48.433]                       envir = ns)) {
[17:45:48.433]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:48.433]                         envir = ns)
[17:45:48.433]                       envir <- sys.frame(frame)
[17:45:48.433]                       master <- NULL
[17:45:48.433]                       while (!identical(envir, .GlobalEnv) && 
[17:45:48.433]                         !identical(envir, emptyenv())) {
[17:45:48.433]                         if (exists("master", mode = "list", envir = envir, 
[17:45:48.433]                           inherits = FALSE)) {
[17:45:48.433]                           master <- get("master", mode = "list", 
[17:45:48.433]                             envir = envir, inherits = FALSE)
[17:45:48.433]                           if (inherits(master, c("SOCKnode", 
[17:45:48.433]                             "SOCK0node"))) {
[17:45:48.433]                             sendCondition <<- function(cond) {
[17:45:48.433]                               data <- list(type = "VALUE", value = cond, 
[17:45:48.433]                                 success = TRUE)
[17:45:48.433]                               parallel_sendData(master, data)
[17:45:48.433]                             }
[17:45:48.433]                             return(sendCondition)
[17:45:48.433]                           }
[17:45:48.433]                         }
[17:45:48.433]                         frame <- frame + 1L
[17:45:48.433]                         envir <- sys.frame(frame)
[17:45:48.433]                       }
[17:45:48.433]                     }
[17:45:48.433]                     sendCondition <<- function(cond) NULL
[17:45:48.433]                   }
[17:45:48.433]                 })
[17:45:48.433]                 withCallingHandlers({
[17:45:48.433]                   {
[17:45:48.433]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:48.433]                     if (!identical(...future.globals.maxSize.org, 
[17:45:48.433]                       ...future.globals.maxSize)) {
[17:45:48.433]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:48.433]                       on.exit(options(oopts), add = TRUE)
[17:45:48.433]                     }
[17:45:48.433]                     {
[17:45:48.433]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:48.433]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:48.433]                         USE.NAMES = FALSE)
[17:45:48.433]                       do.call(mapply, args = args)
[17:45:48.433]                     }
[17:45:48.433]                   }
[17:45:48.433]                 }, immediateCondition = function(cond) {
[17:45:48.433]                   sendCondition <- ...future.makeSendCondition()
[17:45:48.433]                   sendCondition(cond)
[17:45:48.433]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:48.433]                   {
[17:45:48.433]                     inherits <- base::inherits
[17:45:48.433]                     invokeRestart <- base::invokeRestart
[17:45:48.433]                     is.null <- base::is.null
[17:45:48.433]                     muffled <- FALSE
[17:45:48.433]                     if (inherits(cond, "message")) {
[17:45:48.433]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:48.433]                       if (muffled) 
[17:45:48.433]                         invokeRestart("muffleMessage")
[17:45:48.433]                     }
[17:45:48.433]                     else if (inherits(cond, "warning")) {
[17:45:48.433]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:48.433]                       if (muffled) 
[17:45:48.433]                         invokeRestart("muffleWarning")
[17:45:48.433]                     }
[17:45:48.433]                     else if (inherits(cond, "condition")) {
[17:45:48.433]                       if (!is.null(pattern)) {
[17:45:48.433]                         computeRestarts <- base::computeRestarts
[17:45:48.433]                         grepl <- base::grepl
[17:45:48.433]                         restarts <- computeRestarts(cond)
[17:45:48.433]                         for (restart in restarts) {
[17:45:48.433]                           name <- restart$name
[17:45:48.433]                           if (is.null(name)) 
[17:45:48.433]                             next
[17:45:48.433]                           if (!grepl(pattern, name)) 
[17:45:48.433]                             next
[17:45:48.433]                           invokeRestart(restart)
[17:45:48.433]                           muffled <- TRUE
[17:45:48.433]                           break
[17:45:48.433]                         }
[17:45:48.433]                       }
[17:45:48.433]                     }
[17:45:48.433]                     invisible(muffled)
[17:45:48.433]                   }
[17:45:48.433]                   muffleCondition(cond)
[17:45:48.433]                 })
[17:45:48.433]             }))
[17:45:48.433]             future::FutureResult(value = ...future.value$value, 
[17:45:48.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:48.433]                   ...future.rng), globalenv = if (FALSE) 
[17:45:48.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:48.433]                     ...future.globalenv.names))
[17:45:48.433]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:48.433]         }, condition = base::local({
[17:45:48.433]             c <- base::c
[17:45:48.433]             inherits <- base::inherits
[17:45:48.433]             invokeRestart <- base::invokeRestart
[17:45:48.433]             length <- base::length
[17:45:48.433]             list <- base::list
[17:45:48.433]             seq.int <- base::seq.int
[17:45:48.433]             signalCondition <- base::signalCondition
[17:45:48.433]             sys.calls <- base::sys.calls
[17:45:48.433]             `[[` <- base::`[[`
[17:45:48.433]             `+` <- base::`+`
[17:45:48.433]             `<<-` <- base::`<<-`
[17:45:48.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:48.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:48.433]                   3L)]
[17:45:48.433]             }
[17:45:48.433]             function(cond) {
[17:45:48.433]                 is_error <- inherits(cond, "error")
[17:45:48.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:48.433]                   NULL)
[17:45:48.433]                 if (is_error) {
[17:45:48.433]                   sessionInformation <- function() {
[17:45:48.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:48.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:48.433]                       search = base::search(), system = base::Sys.info())
[17:45:48.433]                   }
[17:45:48.433]                   ...future.conditions[[length(...future.conditions) + 
[17:45:48.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:48.433]                     cond$call), session = sessionInformation(), 
[17:45:48.433]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:48.433]                   signalCondition(cond)
[17:45:48.433]                 }
[17:45:48.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:48.433]                 "immediateCondition"))) {
[17:45:48.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:48.433]                   ...future.conditions[[length(...future.conditions) + 
[17:45:48.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:48.433]                   if (TRUE && !signal) {
[17:45:48.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:48.433]                     {
[17:45:48.433]                       inherits <- base::inherits
[17:45:48.433]                       invokeRestart <- base::invokeRestart
[17:45:48.433]                       is.null <- base::is.null
[17:45:48.433]                       muffled <- FALSE
[17:45:48.433]                       if (inherits(cond, "message")) {
[17:45:48.433]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:48.433]                         if (muffled) 
[17:45:48.433]                           invokeRestart("muffleMessage")
[17:45:48.433]                       }
[17:45:48.433]                       else if (inherits(cond, "warning")) {
[17:45:48.433]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:48.433]                         if (muffled) 
[17:45:48.433]                           invokeRestart("muffleWarning")
[17:45:48.433]                       }
[17:45:48.433]                       else if (inherits(cond, "condition")) {
[17:45:48.433]                         if (!is.null(pattern)) {
[17:45:48.433]                           computeRestarts <- base::computeRestarts
[17:45:48.433]                           grepl <- base::grepl
[17:45:48.433]                           restarts <- computeRestarts(cond)
[17:45:48.433]                           for (restart in restarts) {
[17:45:48.433]                             name <- restart$name
[17:45:48.433]                             if (is.null(name)) 
[17:45:48.433]                               next
[17:45:48.433]                             if (!grepl(pattern, name)) 
[17:45:48.433]                               next
[17:45:48.433]                             invokeRestart(restart)
[17:45:48.433]                             muffled <- TRUE
[17:45:48.433]                             break
[17:45:48.433]                           }
[17:45:48.433]                         }
[17:45:48.433]                       }
[17:45:48.433]                       invisible(muffled)
[17:45:48.433]                     }
[17:45:48.433]                     muffleCondition(cond, pattern = "^muffle")
[17:45:48.433]                   }
[17:45:48.433]                 }
[17:45:48.433]                 else {
[17:45:48.433]                   if (TRUE) {
[17:45:48.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:48.433]                     {
[17:45:48.433]                       inherits <- base::inherits
[17:45:48.433]                       invokeRestart <- base::invokeRestart
[17:45:48.433]                       is.null <- base::is.null
[17:45:48.433]                       muffled <- FALSE
[17:45:48.433]                       if (inherits(cond, "message")) {
[17:45:48.433]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:48.433]                         if (muffled) 
[17:45:48.433]                           invokeRestart("muffleMessage")
[17:45:48.433]                       }
[17:45:48.433]                       else if (inherits(cond, "warning")) {
[17:45:48.433]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:48.433]                         if (muffled) 
[17:45:48.433]                           invokeRestart("muffleWarning")
[17:45:48.433]                       }
[17:45:48.433]                       else if (inherits(cond, "condition")) {
[17:45:48.433]                         if (!is.null(pattern)) {
[17:45:48.433]                           computeRestarts <- base::computeRestarts
[17:45:48.433]                           grepl <- base::grepl
[17:45:48.433]                           restarts <- computeRestarts(cond)
[17:45:48.433]                           for (restart in restarts) {
[17:45:48.433]                             name <- restart$name
[17:45:48.433]                             if (is.null(name)) 
[17:45:48.433]                               next
[17:45:48.433]                             if (!grepl(pattern, name)) 
[17:45:48.433]                               next
[17:45:48.433]                             invokeRestart(restart)
[17:45:48.433]                             muffled <- TRUE
[17:45:48.433]                             break
[17:45:48.433]                           }
[17:45:48.433]                         }
[17:45:48.433]                       }
[17:45:48.433]                       invisible(muffled)
[17:45:48.433]                     }
[17:45:48.433]                     muffleCondition(cond, pattern = "^muffle")
[17:45:48.433]                   }
[17:45:48.433]                 }
[17:45:48.433]             }
[17:45:48.433]         }))
[17:45:48.433]     }, error = function(ex) {
[17:45:48.433]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:48.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:48.433]                 ...future.rng), started = ...future.startTime, 
[17:45:48.433]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:48.433]             version = "1.8"), class = "FutureResult")
[17:45:48.433]     }, finally = {
[17:45:48.433]         if (!identical(...future.workdir, getwd())) 
[17:45:48.433]             setwd(...future.workdir)
[17:45:48.433]         {
[17:45:48.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:48.433]                 ...future.oldOptions$nwarnings <- NULL
[17:45:48.433]             }
[17:45:48.433]             base::options(...future.oldOptions)
[17:45:48.433]             if (.Platform$OS.type == "windows") {
[17:45:48.433]                 old_names <- names(...future.oldEnvVars)
[17:45:48.433]                 envs <- base::Sys.getenv()
[17:45:48.433]                 names <- names(envs)
[17:45:48.433]                 common <- intersect(names, old_names)
[17:45:48.433]                 added <- setdiff(names, old_names)
[17:45:48.433]                 removed <- setdiff(old_names, names)
[17:45:48.433]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:48.433]                   envs[common]]
[17:45:48.433]                 NAMES <- toupper(changed)
[17:45:48.433]                 args <- list()
[17:45:48.433]                 for (kk in seq_along(NAMES)) {
[17:45:48.433]                   name <- changed[[kk]]
[17:45:48.433]                   NAME <- NAMES[[kk]]
[17:45:48.433]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:48.433]                     next
[17:45:48.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:48.433]                 }
[17:45:48.433]                 NAMES <- toupper(added)
[17:45:48.433]                 for (kk in seq_along(NAMES)) {
[17:45:48.433]                   name <- added[[kk]]
[17:45:48.433]                   NAME <- NAMES[[kk]]
[17:45:48.433]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:48.433]                     next
[17:45:48.433]                   args[[name]] <- ""
[17:45:48.433]                 }
[17:45:48.433]                 NAMES <- toupper(removed)
[17:45:48.433]                 for (kk in seq_along(NAMES)) {
[17:45:48.433]                   name <- removed[[kk]]
[17:45:48.433]                   NAME <- NAMES[[kk]]
[17:45:48.433]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:48.433]                     next
[17:45:48.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:48.433]                 }
[17:45:48.433]                 if (length(args) > 0) 
[17:45:48.433]                   base::do.call(base::Sys.setenv, args = args)
[17:45:48.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:48.433]             }
[17:45:48.433]             else {
[17:45:48.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:48.433]             }
[17:45:48.433]             {
[17:45:48.433]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:48.433]                   0L) {
[17:45:48.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:48.433]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:48.433]                   base::options(opts)
[17:45:48.433]                 }
[17:45:48.433]                 {
[17:45:48.433]                   {
[17:45:48.433]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:48.433]                     NULL
[17:45:48.433]                   }
[17:45:48.433]                   options(future.plan = NULL)
[17:45:48.433]                   if (is.na(NA_character_)) 
[17:45:48.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:48.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:48.433]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:48.433]                     .init = FALSE)
[17:45:48.433]                 }
[17:45:48.433]             }
[17:45:48.433]         }
[17:45:48.433]     })
[17:45:48.433]     if (FALSE) {
[17:45:48.433]         base::sink(type = "output", split = FALSE)
[17:45:48.433]         if (NA) {
[17:45:48.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:48.433]         }
[17:45:48.433]         else {
[17:45:48.433]             ...future.result["stdout"] <- base::list(NULL)
[17:45:48.433]         }
[17:45:48.433]         base::close(...future.stdout)
[17:45:48.433]         ...future.stdout <- NULL
[17:45:48.433]     }
[17:45:48.433]     ...future.result$conditions <- ...future.conditions
[17:45:48.433]     ...future.result$finished <- base::Sys.time()
[17:45:48.433]     ...future.result
[17:45:48.433] }
[17:45:48.436] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[17:45:48.436] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[17:45:48.436] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[17:45:48.437] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:45:48.437] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:45:48.437] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:45:48.437] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:45:48.437] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:48.438] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:48.438] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:48.438] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:48.438] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[17:45:48.439] MultisessionFuture started
[17:45:48.439] - Launch lazy future ... done
[17:45:48.439] run() for ‘MultisessionFuture’ ... done
[17:45:48.439] Created future:
[17:45:48.439] MultisessionFuture:
[17:45:48.439] Label: ‘future_mapply-1’
[17:45:48.439] Expression:
[17:45:48.439] {
[17:45:48.439]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:48.439]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:48.439]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:48.439]         on.exit(options(oopts), add = TRUE)
[17:45:48.439]     }
[17:45:48.439]     {
[17:45:48.439]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:48.439]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:48.439]         do.call(mapply, args = args)
[17:45:48.439]     }
[17:45:48.439] }
[17:45:48.439] Lazy evaluation: FALSE
[17:45:48.439] Asynchronous evaluation: TRUE
[17:45:48.439] Local evaluation: TRUE
[17:45:48.439] Environment: R_GlobalEnv
[17:45:48.439] Capture standard output: NA
[17:45:48.439] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:48.439] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:48.439] Packages: <none>
[17:45:48.439] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:48.439] Resolved: FALSE
[17:45:48.439] Value: <not collected>
[17:45:48.439] Conditions captured: <none>
[17:45:48.439] Early signaling: FALSE
[17:45:48.439] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:48.439] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:48.451] Chunk #1 of 2 ... DONE
[17:45:48.451] Chunk #2 of 2 ...
[17:45:48.451]  - Finding globals in '...' for chunk #2 ...
[17:45:48.451] getGlobalsAndPackages() ...
[17:45:48.451] Searching for globals...
[17:45:48.451] 
[17:45:48.452] Searching for globals ... DONE
[17:45:48.452] - globals: [0] <none>
[17:45:48.452] getGlobalsAndPackages() ... DONE
[17:45:48.452]    + additional globals found: [n=0] 
[17:45:48.452]    + additional namespaces needed: [n=0] 
[17:45:48.452]  - Finding globals in '...' for chunk #2 ... DONE
[17:45:48.452]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:48.452]  - seeds: <none>
[17:45:48.452]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:48.452] getGlobalsAndPackages() ...
[17:45:48.452] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:48.453] Resolving globals: FALSE
[17:45:48.453] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[17:45:48.453] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:45:48.454] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:48.454] 
[17:45:48.454] getGlobalsAndPackages() ... DONE
[17:45:48.454] run() for ‘Future’ ...
[17:45:48.454] - state: ‘created’
[17:45:48.454] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:48.468] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:48.468] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:48.468]   - Field: ‘node’
[17:45:48.468]   - Field: ‘label’
[17:45:48.468]   - Field: ‘local’
[17:45:48.468]   - Field: ‘owner’
[17:45:48.468]   - Field: ‘envir’
[17:45:48.469]   - Field: ‘workers’
[17:45:48.469]   - Field: ‘packages’
[17:45:48.469]   - Field: ‘gc’
[17:45:48.469]   - Field: ‘conditions’
[17:45:48.469]   - Field: ‘persistent’
[17:45:48.469]   - Field: ‘expr’
[17:45:48.469]   - Field: ‘uuid’
[17:45:48.469]   - Field: ‘seed’
[17:45:48.469]   - Field: ‘version’
[17:45:48.469]   - Field: ‘result’
[17:45:48.469]   - Field: ‘asynchronous’
[17:45:48.470]   - Field: ‘calls’
[17:45:48.470]   - Field: ‘globals’
[17:45:48.470]   - Field: ‘stdout’
[17:45:48.470]   - Field: ‘earlySignal’
[17:45:48.470]   - Field: ‘lazy’
[17:45:48.470]   - Field: ‘state’
[17:45:48.470] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:48.470] - Launch lazy future ...
[17:45:48.470] Packages needed by the future expression (n = 0): <none>
[17:45:48.471] Packages needed by future strategies (n = 0): <none>
[17:45:48.471] {
[17:45:48.471]     {
[17:45:48.471]         {
[17:45:48.471]             ...future.startTime <- base::Sys.time()
[17:45:48.471]             {
[17:45:48.471]                 {
[17:45:48.471]                   {
[17:45:48.471]                     {
[17:45:48.471]                       base::local({
[17:45:48.471]                         has_future <- base::requireNamespace("future", 
[17:45:48.471]                           quietly = TRUE)
[17:45:48.471]                         if (has_future) {
[17:45:48.471]                           ns <- base::getNamespace("future")
[17:45:48.471]                           version <- ns[[".package"]][["version"]]
[17:45:48.471]                           if (is.null(version)) 
[17:45:48.471]                             version <- utils::packageVersion("future")
[17:45:48.471]                         }
[17:45:48.471]                         else {
[17:45:48.471]                           version <- NULL
[17:45:48.471]                         }
[17:45:48.471]                         if (!has_future || version < "1.8.0") {
[17:45:48.471]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:48.471]                             "", base::R.version$version.string), 
[17:45:48.471]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:48.471]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:48.471]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:48.471]                               "release", "version")], collapse = " "), 
[17:45:48.471]                             hostname = base::Sys.info()[["nodename"]])
[17:45:48.471]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:48.471]                             info)
[17:45:48.471]                           info <- base::paste(info, collapse = "; ")
[17:45:48.471]                           if (!has_future) {
[17:45:48.471]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:48.471]                               info)
[17:45:48.471]                           }
[17:45:48.471]                           else {
[17:45:48.471]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:48.471]                               info, version)
[17:45:48.471]                           }
[17:45:48.471]                           base::stop(msg)
[17:45:48.471]                         }
[17:45:48.471]                       })
[17:45:48.471]                     }
[17:45:48.471]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:48.471]                     base::options(mc.cores = 1L)
[17:45:48.471]                   }
[17:45:48.471]                   ...future.strategy.old <- future::plan("list")
[17:45:48.471]                   options(future.plan = NULL)
[17:45:48.471]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:48.471]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:48.471]                 }
[17:45:48.471]                 ...future.workdir <- getwd()
[17:45:48.471]             }
[17:45:48.471]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:48.471]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:48.471]         }
[17:45:48.471]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:48.471]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:48.471]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:48.471]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:48.471]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:48.471]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:48.471]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:48.471]             base::names(...future.oldOptions))
[17:45:48.471]     }
[17:45:48.471]     if (TRUE) {
[17:45:48.471]     }
[17:45:48.471]     else {
[17:45:48.471]         if (NA) {
[17:45:48.471]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:48.471]                 open = "w")
[17:45:48.471]         }
[17:45:48.471]         else {
[17:45:48.471]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:48.471]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:48.471]         }
[17:45:48.471]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:48.471]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:48.471]             base::sink(type = "output", split = FALSE)
[17:45:48.471]             base::close(...future.stdout)
[17:45:48.471]         }, add = TRUE)
[17:45:48.471]     }
[17:45:48.471]     ...future.frame <- base::sys.nframe()
[17:45:48.471]     ...future.conditions <- base::list()
[17:45:48.471]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:48.471]     if (FALSE) {
[17:45:48.471]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:48.471]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:48.471]     }
[17:45:48.471]     ...future.result <- base::tryCatch({
[17:45:48.471]         base::withCallingHandlers({
[17:45:48.471]             ...future.value <- base::withVisible(base::local({
[17:45:48.471]                 ...future.makeSendCondition <- base::local({
[17:45:48.471]                   sendCondition <- NULL
[17:45:48.471]                   function(frame = 1L) {
[17:45:48.471]                     if (is.function(sendCondition)) 
[17:45:48.471]                       return(sendCondition)
[17:45:48.471]                     ns <- getNamespace("parallel")
[17:45:48.471]                     if (exists("sendData", mode = "function", 
[17:45:48.471]                       envir = ns)) {
[17:45:48.471]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:48.471]                         envir = ns)
[17:45:48.471]                       envir <- sys.frame(frame)
[17:45:48.471]                       master <- NULL
[17:45:48.471]                       while (!identical(envir, .GlobalEnv) && 
[17:45:48.471]                         !identical(envir, emptyenv())) {
[17:45:48.471]                         if (exists("master", mode = "list", envir = envir, 
[17:45:48.471]                           inherits = FALSE)) {
[17:45:48.471]                           master <- get("master", mode = "list", 
[17:45:48.471]                             envir = envir, inherits = FALSE)
[17:45:48.471]                           if (inherits(master, c("SOCKnode", 
[17:45:48.471]                             "SOCK0node"))) {
[17:45:48.471]                             sendCondition <<- function(cond) {
[17:45:48.471]                               data <- list(type = "VALUE", value = cond, 
[17:45:48.471]                                 success = TRUE)
[17:45:48.471]                               parallel_sendData(master, data)
[17:45:48.471]                             }
[17:45:48.471]                             return(sendCondition)
[17:45:48.471]                           }
[17:45:48.471]                         }
[17:45:48.471]                         frame <- frame + 1L
[17:45:48.471]                         envir <- sys.frame(frame)
[17:45:48.471]                       }
[17:45:48.471]                     }
[17:45:48.471]                     sendCondition <<- function(cond) NULL
[17:45:48.471]                   }
[17:45:48.471]                 })
[17:45:48.471]                 withCallingHandlers({
[17:45:48.471]                   {
[17:45:48.471]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:48.471]                     if (!identical(...future.globals.maxSize.org, 
[17:45:48.471]                       ...future.globals.maxSize)) {
[17:45:48.471]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:48.471]                       on.exit(options(oopts), add = TRUE)
[17:45:48.471]                     }
[17:45:48.471]                     {
[17:45:48.471]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:48.471]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:45:48.471]                         USE.NAMES = FALSE)
[17:45:48.471]                       do.call(mapply, args = args)
[17:45:48.471]                     }
[17:45:48.471]                   }
[17:45:48.471]                 }, immediateCondition = function(cond) {
[17:45:48.471]                   sendCondition <- ...future.makeSendCondition()
[17:45:48.471]                   sendCondition(cond)
[17:45:48.471]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:48.471]                   {
[17:45:48.471]                     inherits <- base::inherits
[17:45:48.471]                     invokeRestart <- base::invokeRestart
[17:45:48.471]                     is.null <- base::is.null
[17:45:48.471]                     muffled <- FALSE
[17:45:48.471]                     if (inherits(cond, "message")) {
[17:45:48.471]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:48.471]                       if (muffled) 
[17:45:48.471]                         invokeRestart("muffleMessage")
[17:45:48.471]                     }
[17:45:48.471]                     else if (inherits(cond, "warning")) {
[17:45:48.471]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:48.471]                       if (muffled) 
[17:45:48.471]                         invokeRestart("muffleWarning")
[17:45:48.471]                     }
[17:45:48.471]                     else if (inherits(cond, "condition")) {
[17:45:48.471]                       if (!is.null(pattern)) {
[17:45:48.471]                         computeRestarts <- base::computeRestarts
[17:45:48.471]                         grepl <- base::grepl
[17:45:48.471]                         restarts <- computeRestarts(cond)
[17:45:48.471]                         for (restart in restarts) {
[17:45:48.471]                           name <- restart$name
[17:45:48.471]                           if (is.null(name)) 
[17:45:48.471]                             next
[17:45:48.471]                           if (!grepl(pattern, name)) 
[17:45:48.471]                             next
[17:45:48.471]                           invokeRestart(restart)
[17:45:48.471]                           muffled <- TRUE
[17:45:48.471]                           break
[17:45:48.471]                         }
[17:45:48.471]                       }
[17:45:48.471]                     }
[17:45:48.471]                     invisible(muffled)
[17:45:48.471]                   }
[17:45:48.471]                   muffleCondition(cond)
[17:45:48.471]                 })
[17:45:48.471]             }))
[17:45:48.471]             future::FutureResult(value = ...future.value$value, 
[17:45:48.471]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:48.471]                   ...future.rng), globalenv = if (FALSE) 
[17:45:48.471]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:48.471]                     ...future.globalenv.names))
[17:45:48.471]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:48.471]         }, condition = base::local({
[17:45:48.471]             c <- base::c
[17:45:48.471]             inherits <- base::inherits
[17:45:48.471]             invokeRestart <- base::invokeRestart
[17:45:48.471]             length <- base::length
[17:45:48.471]             list <- base::list
[17:45:48.471]             seq.int <- base::seq.int
[17:45:48.471]             signalCondition <- base::signalCondition
[17:45:48.471]             sys.calls <- base::sys.calls
[17:45:48.471]             `[[` <- base::`[[`
[17:45:48.471]             `+` <- base::`+`
[17:45:48.471]             `<<-` <- base::`<<-`
[17:45:48.471]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:48.471]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:48.471]                   3L)]
[17:45:48.471]             }
[17:45:48.471]             function(cond) {
[17:45:48.471]                 is_error <- inherits(cond, "error")
[17:45:48.471]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:48.471]                   NULL)
[17:45:48.471]                 if (is_error) {
[17:45:48.471]                   sessionInformation <- function() {
[17:45:48.471]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:48.471]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:48.471]                       search = base::search(), system = base::Sys.info())
[17:45:48.471]                   }
[17:45:48.471]                   ...future.conditions[[length(...future.conditions) + 
[17:45:48.471]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:48.471]                     cond$call), session = sessionInformation(), 
[17:45:48.471]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:48.471]                   signalCondition(cond)
[17:45:48.471]                 }
[17:45:48.471]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:48.471]                 "immediateCondition"))) {
[17:45:48.471]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:48.471]                   ...future.conditions[[length(...future.conditions) + 
[17:45:48.471]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:48.471]                   if (TRUE && !signal) {
[17:45:48.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:48.471]                     {
[17:45:48.471]                       inherits <- base::inherits
[17:45:48.471]                       invokeRestart <- base::invokeRestart
[17:45:48.471]                       is.null <- base::is.null
[17:45:48.471]                       muffled <- FALSE
[17:45:48.471]                       if (inherits(cond, "message")) {
[17:45:48.471]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:48.471]                         if (muffled) 
[17:45:48.471]                           invokeRestart("muffleMessage")
[17:45:48.471]                       }
[17:45:48.471]                       else if (inherits(cond, "warning")) {
[17:45:48.471]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:48.471]                         if (muffled) 
[17:45:48.471]                           invokeRestart("muffleWarning")
[17:45:48.471]                       }
[17:45:48.471]                       else if (inherits(cond, "condition")) {
[17:45:48.471]                         if (!is.null(pattern)) {
[17:45:48.471]                           computeRestarts <- base::computeRestarts
[17:45:48.471]                           grepl <- base::grepl
[17:45:48.471]                           restarts <- computeRestarts(cond)
[17:45:48.471]                           for (restart in restarts) {
[17:45:48.471]                             name <- restart$name
[17:45:48.471]                             if (is.null(name)) 
[17:45:48.471]                               next
[17:45:48.471]                             if (!grepl(pattern, name)) 
[17:45:48.471]                               next
[17:45:48.471]                             invokeRestart(restart)
[17:45:48.471]                             muffled <- TRUE
[17:45:48.471]                             break
[17:45:48.471]                           }
[17:45:48.471]                         }
[17:45:48.471]                       }
[17:45:48.471]                       invisible(muffled)
[17:45:48.471]                     }
[17:45:48.471]                     muffleCondition(cond, pattern = "^muffle")
[17:45:48.471]                   }
[17:45:48.471]                 }
[17:45:48.471]                 else {
[17:45:48.471]                   if (TRUE) {
[17:45:48.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:48.471]                     {
[17:45:48.471]                       inherits <- base::inherits
[17:45:48.471]                       invokeRestart <- base::invokeRestart
[17:45:48.471]                       is.null <- base::is.null
[17:45:48.471]                       muffled <- FALSE
[17:45:48.471]                       if (inherits(cond, "message")) {
[17:45:48.471]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:48.471]                         if (muffled) 
[17:45:48.471]                           invokeRestart("muffleMessage")
[17:45:48.471]                       }
[17:45:48.471]                       else if (inherits(cond, "warning")) {
[17:45:48.471]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:48.471]                         if (muffled) 
[17:45:48.471]                           invokeRestart("muffleWarning")
[17:45:48.471]                       }
[17:45:48.471]                       else if (inherits(cond, "condition")) {
[17:45:48.471]                         if (!is.null(pattern)) {
[17:45:48.471]                           computeRestarts <- base::computeRestarts
[17:45:48.471]                           grepl <- base::grepl
[17:45:48.471]                           restarts <- computeRestarts(cond)
[17:45:48.471]                           for (restart in restarts) {
[17:45:48.471]                             name <- restart$name
[17:45:48.471]                             if (is.null(name)) 
[17:45:48.471]                               next
[17:45:48.471]                             if (!grepl(pattern, name)) 
[17:45:48.471]                               next
[17:45:48.471]                             invokeRestart(restart)
[17:45:48.471]                             muffled <- TRUE
[17:45:48.471]                             break
[17:45:48.471]                           }
[17:45:48.471]                         }
[17:45:48.471]                       }
[17:45:48.471]                       invisible(muffled)
[17:45:48.471]                     }
[17:45:48.471]                     muffleCondition(cond, pattern = "^muffle")
[17:45:48.471]                   }
[17:45:48.471]                 }
[17:45:48.471]             }
[17:45:48.471]         }))
[17:45:48.471]     }, error = function(ex) {
[17:45:48.471]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:48.471]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:48.471]                 ...future.rng), started = ...future.startTime, 
[17:45:48.471]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:48.471]             version = "1.8"), class = "FutureResult")
[17:45:48.471]     }, finally = {
[17:45:48.471]         if (!identical(...future.workdir, getwd())) 
[17:45:48.471]             setwd(...future.workdir)
[17:45:48.471]         {
[17:45:48.471]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:48.471]                 ...future.oldOptions$nwarnings <- NULL
[17:45:48.471]             }
[17:45:48.471]             base::options(...future.oldOptions)
[17:45:48.471]             if (.Platform$OS.type == "windows") {
[17:45:48.471]                 old_names <- names(...future.oldEnvVars)
[17:45:48.471]                 envs <- base::Sys.getenv()
[17:45:48.471]                 names <- names(envs)
[17:45:48.471]                 common <- intersect(names, old_names)
[17:45:48.471]                 added <- setdiff(names, old_names)
[17:45:48.471]                 removed <- setdiff(old_names, names)
[17:45:48.471]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:48.471]                   envs[common]]
[17:45:48.471]                 NAMES <- toupper(changed)
[17:45:48.471]                 args <- list()
[17:45:48.471]                 for (kk in seq_along(NAMES)) {
[17:45:48.471]                   name <- changed[[kk]]
[17:45:48.471]                   NAME <- NAMES[[kk]]
[17:45:48.471]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:48.471]                     next
[17:45:48.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:48.471]                 }
[17:45:48.471]                 NAMES <- toupper(added)
[17:45:48.471]                 for (kk in seq_along(NAMES)) {
[17:45:48.471]                   name <- added[[kk]]
[17:45:48.471]                   NAME <- NAMES[[kk]]
[17:45:48.471]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:48.471]                     next
[17:45:48.471]                   args[[name]] <- ""
[17:45:48.471]                 }
[17:45:48.471]                 NAMES <- toupper(removed)
[17:45:48.471]                 for (kk in seq_along(NAMES)) {
[17:45:48.471]                   name <- removed[[kk]]
[17:45:48.471]                   NAME <- NAMES[[kk]]
[17:45:48.471]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:48.471]                     next
[17:45:48.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:48.471]                 }
[17:45:48.471]                 if (length(args) > 0) 
[17:45:48.471]                   base::do.call(base::Sys.setenv, args = args)
[17:45:48.471]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:48.471]             }
[17:45:48.471]             else {
[17:45:48.471]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:48.471]             }
[17:45:48.471]             {
[17:45:48.471]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:48.471]                   0L) {
[17:45:48.471]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:48.471]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:48.471]                   base::options(opts)
[17:45:48.471]                 }
[17:45:48.471]                 {
[17:45:48.471]                   {
[17:45:48.471]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:48.471]                     NULL
[17:45:48.471]                   }
[17:45:48.471]                   options(future.plan = NULL)
[17:45:48.471]                   if (is.na(NA_character_)) 
[17:45:48.471]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:48.471]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:48.471]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:48.471]                     .init = FALSE)
[17:45:48.471]                 }
[17:45:48.471]             }
[17:45:48.471]         }
[17:45:48.471]     })
[17:45:48.471]     if (FALSE) {
[17:45:48.471]         base::sink(type = "output", split = FALSE)
[17:45:48.471]         if (NA) {
[17:45:48.471]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:48.471]         }
[17:45:48.471]         else {
[17:45:48.471]             ...future.result["stdout"] <- base::list(NULL)
[17:45:48.471]         }
[17:45:48.471]         base::close(...future.stdout)
[17:45:48.471]         ...future.stdout <- NULL
[17:45:48.471]     }
[17:45:48.471]     ...future.result$conditions <- ...future.conditions
[17:45:48.471]     ...future.result$finished <- base::Sys.time()
[17:45:48.471]     ...future.result
[17:45:48.471] }
[17:45:48.474] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[17:45:48.474] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[17:45:48.474] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[17:45:48.474] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:45:48.475] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:45:48.475] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:45:48.475] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:45:48.475] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:48.476] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:48.476] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:48.476] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:48.476] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[17:45:48.477] MultisessionFuture started
[17:45:48.477] - Launch lazy future ... done
[17:45:48.477] run() for ‘MultisessionFuture’ ... done
[17:45:48.477] Created future:
[17:45:48.477] MultisessionFuture:
[17:45:48.477] Label: ‘future_mapply-2’
[17:45:48.477] Expression:
[17:45:48.477] {
[17:45:48.477]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:48.477]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:48.477]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:48.477]         on.exit(options(oopts), add = TRUE)
[17:45:48.477]     }
[17:45:48.477]     {
[17:45:48.477]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:45:48.477]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:45:48.477]         do.call(mapply, args = args)
[17:45:48.477]     }
[17:45:48.477] }
[17:45:48.477] Lazy evaluation: FALSE
[17:45:48.477] Asynchronous evaluation: TRUE
[17:45:48.477] Local evaluation: TRUE
[17:45:48.477] Environment: R_GlobalEnv
[17:45:48.477] Capture standard output: NA
[17:45:48.477] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:48.477] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:48.477] Packages: <none>
[17:45:48.477] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:48.477] Resolved: FALSE
[17:45:48.477] Value: <not collected>
[17:45:48.477] Conditions captured: <none>
[17:45:48.477] Early signaling: FALSE
[17:45:48.477] Owner process: 8de0bdef-c55a-f9c7-483a-73db44ed3ae0
[17:45:48.477] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:48.489] Chunk #2 of 2 ... DONE
[17:45:48.489] Launching 2 futures (chunks) ... DONE
[17:45:48.489] Resolving 2 futures (chunks) ...
[17:45:48.489] resolve() on list ...
[17:45:48.489]  recursive: 0
[17:45:48.489]  length: 2
[17:45:48.489] 
[17:45:48.531] receiveMessageFromWorker() for ClusterFuture ...
[17:45:48.532] - Validating connection of MultisessionFuture
[17:45:48.532] - received message: FutureResult
[17:45:48.532] - Received FutureResult
[17:45:48.532] - Erased future from FutureRegistry
[17:45:48.532] result() for ClusterFuture ...
[17:45:48.532] - result already collected: FutureResult
[17:45:48.532] result() for ClusterFuture ... done
[17:45:48.532] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:48.532] Future #2
[17:45:48.532] result() for ClusterFuture ...
[17:45:48.533] - result already collected: FutureResult
[17:45:48.533] result() for ClusterFuture ... done
[17:45:48.533] result() for ClusterFuture ...
[17:45:48.533] - result already collected: FutureResult
[17:45:48.533] result() for ClusterFuture ... done
[17:45:48.533] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:48.533] - nx: 2
[17:45:48.533] - relay: TRUE
[17:45:48.533] - stdout: TRUE
[17:45:48.533] - signal: TRUE
[17:45:48.533] - resignal: FALSE
[17:45:48.533] - force: TRUE
[17:45:48.534] - relayed: [n=2] FALSE, FALSE
[17:45:48.534] - queued futures: [n=2] FALSE, FALSE
[17:45:48.534]  - until=1
[17:45:48.534]  - relaying element #1
[17:45:48.534] - relayed: [n=2] FALSE, FALSE
[17:45:48.534] - queued futures: [n=2] FALSE, TRUE
[17:45:48.534] signalConditionsASAP(NULL, pos=2) ... done
[17:45:48.534]  length: 1 (resolved future 2)
[17:45:48.982] receiveMessageFromWorker() for ClusterFuture ...
[17:45:48.982] - Validating connection of MultisessionFuture
[17:45:48.982] - received message: FutureResult
[17:45:48.982] - Received FutureResult
[17:45:48.982] - Erased future from FutureRegistry
[17:45:48.983] result() for ClusterFuture ...
[17:45:48.983] - result already collected: FutureResult
[17:45:48.983] result() for ClusterFuture ... done
[17:45:48.983] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:48.983] Future #1
[17:45:48.983] result() for ClusterFuture ...
[17:45:48.983] - result already collected: FutureResult
[17:45:48.983] result() for ClusterFuture ... done
[17:45:48.983] result() for ClusterFuture ...
[17:45:48.983] - result already collected: FutureResult
[17:45:48.983] result() for ClusterFuture ... done
[17:45:48.984] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:48.984] - nx: 2
[17:45:48.984] - relay: TRUE
[17:45:48.984] - stdout: TRUE
[17:45:48.984] - signal: TRUE
[17:45:48.984] - resignal: FALSE
[17:45:48.984] - force: TRUE
[17:45:48.984] - relayed: [n=2] FALSE, FALSE
[17:45:48.984] - queued futures: [n=2] FALSE, TRUE
[17:45:48.984]  - until=1
[17:45:48.984]  - relaying element #1
[17:45:48.986] result() for ClusterFuture ...
[17:45:48.987] - result already collected: FutureResult
[17:45:48.987] result() for ClusterFuture ... done
[17:45:48.987] result() for ClusterFuture ...
[17:45:48.987] - result already collected: FutureResult
[17:45:48.987] result() for ClusterFuture ... done
[17:45:48.987] result() for ClusterFuture ...
[17:45:48.987] - result already collected: FutureResult
[17:45:48.987] result() for ClusterFuture ... done
[17:45:48.987] result() for ClusterFuture ...
[17:45:48.987] - result already collected: FutureResult
[17:45:48.987] result() for ClusterFuture ... done
[17:45:48.987] - relayed: [n=2] TRUE, FALSE
[17:45:48.988] - queued futures: [n=2] TRUE, TRUE
[17:45:48.988] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:48.988]  length: 0 (resolved future 1)
[17:45:48.988] Relaying remaining futures
[17:45:48.988] signalConditionsASAP(NULL, pos=0) ...
[17:45:48.988] - nx: 2
[17:45:48.988] - relay: TRUE
[17:45:48.988] - stdout: TRUE
[17:45:48.988] - signal: TRUE
[17:45:48.988] - resignal: FALSE
[17:45:48.988] - force: TRUE
[17:45:48.988] - relayed: [n=2] TRUE, FALSE
[17:45:48.989] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:48.989]  - relaying element #2
[17:45:48.989] result() for ClusterFuture ...
[17:45:48.989] - result already collected: FutureResult
[17:45:48.989] result() for ClusterFuture ... done
[17:45:48.989] result() for ClusterFuture ...
[17:45:48.989] - result already collected: FutureResult
[17:45:48.989] result() for ClusterFuture ... done
[17:45:48.989] result() for ClusterFuture ...
[17:45:48.989] - result already collected: FutureResult
[17:45:48.989] result() for ClusterFuture ... done
[17:45:48.990] result() for ClusterFuture ...
[17:45:48.990] - result already collected: FutureResult
[17:45:48.990] result() for ClusterFuture ... done
[17:45:48.990] - relayed: [n=2] TRUE, TRUE
[17:45:48.990] - queued futures: [n=2] TRUE, TRUE
[17:45:48.990] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[17:45:48.990] resolve() on list ... DONE
[17:45:48.990] result() for ClusterFuture ...
[17:45:48.990] - result already collected: FutureResult
[17:45:48.990] result() for ClusterFuture ... done
[17:45:48.990] result() for ClusterFuture ...
[17:45:48.990] - result already collected: FutureResult
[17:45:48.990] result() for ClusterFuture ... done
[17:45:48.991] result() for ClusterFuture ...
[17:45:48.991] - result already collected: FutureResult
[17:45:48.991] result() for ClusterFuture ... done
[17:45:48.991] result() for ClusterFuture ...
[17:45:48.991] - result already collected: FutureResult
[17:45:48.991] result() for ClusterFuture ... done
[17:45:48.991]  - Number of value chunks collected: 2
[17:45:48.991] Resolving 2 futures (chunks) ... DONE
[17:45:48.991] Reducing values from 2 chunks ...
[17:45:48.991]  - Number of values collected after concatenation: 2
[17:45:48.991]  - Number of values expected: 2
[17:45:48.992] Reducing values from 2 chunks ... DONE
[17:45:48.992] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[17:45:48.992] plan(): Setting new future strategy stack:
[17:45:48.993] List of future strategies:
[17:45:48.993] 1. FutureStrategy:
[17:45:48.993]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:48.993]    - tweaked: FALSE
[17:45:48.993]    - call: future::plan(oplan)
[17:45:48.993] plan(): nbrOfWorkers() = 1
> 
