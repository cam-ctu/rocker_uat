
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[18:02:18.230] plan(): Setting new future strategy stack:
[18:02:18.230] List of future strategies:
[18:02:18.230] 1. sequential:
[18:02:18.230]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:18.230]    - tweaked: FALSE
[18:02:18.230]    - call: future::plan("sequential")
[18:02:18.258] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[18:02:18.324] plan(): Setting new future strategy stack:
[18:02:18.324] List of future strategies:
[18:02:18.324] 1. sequential:
[18:02:18.324]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:18.324]    - tweaked: FALSE
[18:02:18.324]    - call: plan(strategy)
[18:02:18.352] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[18:02:18.353] future_lapply() ...
[18:02:18.361] Number of chunks: 1
[18:02:18.362] getGlobalsAndPackagesXApply() ...
[18:02:18.362]  - future.globals: TRUE
[18:02:18.363] getGlobalsAndPackages() ...
[18:02:18.363] Searching for globals...
[18:02:18.368] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:18.369] Searching for globals ... DONE
[18:02:18.370] Resolving globals: FALSE
[18:02:18.371] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:18.372] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:18.373] - globals: [1] ‘FUN’
[18:02:18.373] 
[18:02:18.373] getGlobalsAndPackages() ... DONE
[18:02:18.373]  - globals found/used: [n=1] ‘FUN’
[18:02:18.374]  - needed namespaces: [n=0] 
[18:02:18.374] Finding globals ... DONE
[18:02:18.374]  - use_args: TRUE
[18:02:18.374]  - Getting '...' globals ...
[18:02:18.376] resolve() on list ...
[18:02:18.376]  recursive: 0
[18:02:18.376]  length: 1
[18:02:18.377]  elements: ‘...’
[18:02:18.377]  length: 0 (resolved future 1)
[18:02:18.377] resolve() on list ... DONE
[18:02:18.377]    - '...' content: [n=0] 
[18:02:18.377] List of 1
[18:02:18.377]  $ ...: list()
[18:02:18.377]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:18.377]  - attr(*, "where")=List of 1
[18:02:18.377]   ..$ ...:<environment: 0x5e4f85188de8> 
[18:02:18.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:18.377]  - attr(*, "resolved")= logi TRUE
[18:02:18.377]  - attr(*, "total_size")= num NA
[18:02:18.386]  - Getting '...' globals ... DONE
[18:02:18.386] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:18.387] List of 2
[18:02:18.387]  $ ...future.FUN:function (x)  
[18:02:18.387]  $ ...          : list()
[18:02:18.387]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:18.387]  - attr(*, "where")=List of 2
[18:02:18.387]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:18.387]   ..$ ...          :<environment: 0x5e4f85188de8> 
[18:02:18.387]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:18.387]  - attr(*, "resolved")= logi FALSE
[18:02:18.387]  - attr(*, "total_size")= num 4720
[18:02:18.392] Packages to be attached in all futures: [n=0] 
[18:02:18.396] getGlobalsAndPackagesXApply() ... DONE
[18:02:18.397] Number of futures (= number of chunks): 1
[18:02:18.397] Launching 1 futures (chunks) ...
[18:02:18.397] Chunk #1 of 1 ...
[18:02:18.398]  - Finding globals in 'X' for chunk #1 ...
[18:02:18.398] getGlobalsAndPackages() ...
[18:02:18.398] Searching for globals...
[18:02:18.399] 
[18:02:18.399] Searching for globals ... DONE
[18:02:18.399] - globals: [0] <none>
[18:02:18.399] getGlobalsAndPackages() ... DONE
[18:02:18.400]    + additional globals found: [n=0] 
[18:02:18.401]    + additional namespaces needed: [n=0] 
[18:02:18.401]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:18.402]  - seeds: <none>
[18:02:18.402]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:18.402] getGlobalsAndPackages() ...
[18:02:18.403] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:18.403] Resolving globals: FALSE
[18:02:18.403] Tweak future expression to call with '...' arguments ...
[18:02:18.403] {
[18:02:18.403]     do.call(function(...) {
[18:02:18.403]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:18.403]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:18.403]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:18.403]             on.exit(options(oopts), add = TRUE)
[18:02:18.403]         }
[18:02:18.403]         {
[18:02:18.403]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:18.403]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:18.403]                 ...future.FUN(...future.X_jj, ...)
[18:02:18.403]             })
[18:02:18.403]         }
[18:02:18.403]     }, args = future.call.arguments)
[18:02:18.403] }
[18:02:18.404] Tweak future expression to call with '...' arguments ... DONE
[18:02:18.404] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:18.405] 
[18:02:18.405] getGlobalsAndPackages() ... DONE
[18:02:18.406] run() for ‘Future’ ...
[18:02:18.406] - state: ‘created’
[18:02:18.407] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:02:18.407] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:18.408] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:18.408]   - Field: ‘label’
[18:02:18.408]   - Field: ‘local’
[18:02:18.408]   - Field: ‘owner’
[18:02:18.409]   - Field: ‘envir’
[18:02:18.409]   - Field: ‘packages’
[18:02:18.409]   - Field: ‘gc’
[18:02:18.409]   - Field: ‘conditions’
[18:02:18.409]   - Field: ‘expr’
[18:02:18.409]   - Field: ‘uuid’
[18:02:18.410]   - Field: ‘seed’
[18:02:18.410]   - Field: ‘version’
[18:02:18.410]   - Field: ‘result’
[18:02:18.410]   - Field: ‘asynchronous’
[18:02:18.410]   - Field: ‘calls’
[18:02:18.411]   - Field: ‘globals’
[18:02:18.411]   - Field: ‘stdout’
[18:02:18.411]   - Field: ‘earlySignal’
[18:02:18.411]   - Field: ‘lazy’
[18:02:18.411]   - Field: ‘state’
[18:02:18.412] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:18.412] - Launch lazy future ...
[18:02:18.413] Packages needed by the future expression (n = 0): <none>
[18:02:18.413] Packages needed by future strategies (n = 0): <none>
[18:02:18.415] {
[18:02:18.415]     {
[18:02:18.415]         {
[18:02:18.415]             ...future.startTime <- base::Sys.time()
[18:02:18.415]             {
[18:02:18.415]                 {
[18:02:18.415]                   {
[18:02:18.415]                     base::local({
[18:02:18.415]                       has_future <- base::requireNamespace("future", 
[18:02:18.415]                         quietly = TRUE)
[18:02:18.415]                       if (has_future) {
[18:02:18.415]                         ns <- base::getNamespace("future")
[18:02:18.415]                         version <- ns[[".package"]][["version"]]
[18:02:18.415]                         if (is.null(version)) 
[18:02:18.415]                           version <- utils::packageVersion("future")
[18:02:18.415]                       }
[18:02:18.415]                       else {
[18:02:18.415]                         version <- NULL
[18:02:18.415]                       }
[18:02:18.415]                       if (!has_future || version < "1.8.0") {
[18:02:18.415]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:18.415]                           "", base::R.version$version.string), 
[18:02:18.415]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:18.415]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:18.415]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:18.415]                             "release", "version")], collapse = " "), 
[18:02:18.415]                           hostname = base::Sys.info()[["nodename"]])
[18:02:18.415]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:18.415]                           info)
[18:02:18.415]                         info <- base::paste(info, collapse = "; ")
[18:02:18.415]                         if (!has_future) {
[18:02:18.415]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:18.415]                             info)
[18:02:18.415]                         }
[18:02:18.415]                         else {
[18:02:18.415]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:18.415]                             info, version)
[18:02:18.415]                         }
[18:02:18.415]                         base::stop(msg)
[18:02:18.415]                       }
[18:02:18.415]                     })
[18:02:18.415]                   }
[18:02:18.415]                   ...future.strategy.old <- future::plan("list")
[18:02:18.415]                   options(future.plan = NULL)
[18:02:18.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:18.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:18.415]                 }
[18:02:18.415]                 ...future.workdir <- getwd()
[18:02:18.415]             }
[18:02:18.415]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:18.415]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:18.415]         }
[18:02:18.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:18.415]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:18.415]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:18.415]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:18.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:18.415]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:18.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:18.415]             base::names(...future.oldOptions))
[18:02:18.415]     }
[18:02:18.415]     if (FALSE) {
[18:02:18.415]     }
[18:02:18.415]     else {
[18:02:18.415]         if (FALSE) {
[18:02:18.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:18.415]                 open = "w")
[18:02:18.415]         }
[18:02:18.415]         else {
[18:02:18.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:18.415]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:18.415]         }
[18:02:18.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:18.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:18.415]             base::sink(type = "output", split = FALSE)
[18:02:18.415]             base::close(...future.stdout)
[18:02:18.415]         }, add = TRUE)
[18:02:18.415]     }
[18:02:18.415]     ...future.frame <- base::sys.nframe()
[18:02:18.415]     ...future.conditions <- base::list()
[18:02:18.415]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:18.415]     if (FALSE) {
[18:02:18.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:18.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:18.415]     }
[18:02:18.415]     ...future.result <- base::tryCatch({
[18:02:18.415]         base::withCallingHandlers({
[18:02:18.415]             ...future.value <- base::withVisible(base::local({
[18:02:18.415]                 do.call(function(...) {
[18:02:18.415]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:18.415]                   if (!identical(...future.globals.maxSize.org, 
[18:02:18.415]                     ...future.globals.maxSize)) {
[18:02:18.415]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:18.415]                     on.exit(options(oopts), add = TRUE)
[18:02:18.415]                   }
[18:02:18.415]                   {
[18:02:18.415]                     lapply(seq_along(...future.elements_ii), 
[18:02:18.415]                       FUN = function(jj) {
[18:02:18.415]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:18.415]                         ...future.FUN(...future.X_jj, ...)
[18:02:18.415]                       })
[18:02:18.415]                   }
[18:02:18.415]                 }, args = future.call.arguments)
[18:02:18.415]             }))
[18:02:18.415]             future::FutureResult(value = ...future.value$value, 
[18:02:18.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:18.415]                   ...future.rng), globalenv = if (FALSE) 
[18:02:18.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:18.415]                     ...future.globalenv.names))
[18:02:18.415]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:18.415]         }, condition = base::local({
[18:02:18.415]             c <- base::c
[18:02:18.415]             inherits <- base::inherits
[18:02:18.415]             invokeRestart <- base::invokeRestart
[18:02:18.415]             length <- base::length
[18:02:18.415]             list <- base::list
[18:02:18.415]             seq.int <- base::seq.int
[18:02:18.415]             signalCondition <- base::signalCondition
[18:02:18.415]             sys.calls <- base::sys.calls
[18:02:18.415]             `[[` <- base::`[[`
[18:02:18.415]             `+` <- base::`+`
[18:02:18.415]             `<<-` <- base::`<<-`
[18:02:18.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:18.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:18.415]                   3L)]
[18:02:18.415]             }
[18:02:18.415]             function(cond) {
[18:02:18.415]                 is_error <- inherits(cond, "error")
[18:02:18.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:18.415]                   NULL)
[18:02:18.415]                 if (is_error) {
[18:02:18.415]                   sessionInformation <- function() {
[18:02:18.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:18.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:18.415]                       search = base::search(), system = base::Sys.info())
[18:02:18.415]                   }
[18:02:18.415]                   ...future.conditions[[length(...future.conditions) + 
[18:02:18.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:18.415]                     cond$call), session = sessionInformation(), 
[18:02:18.415]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:18.415]                   signalCondition(cond)
[18:02:18.415]                 }
[18:02:18.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:18.415]                 "immediateCondition"))) {
[18:02:18.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:18.415]                   ...future.conditions[[length(...future.conditions) + 
[18:02:18.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:18.415]                   if (TRUE && !signal) {
[18:02:18.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:18.415]                     {
[18:02:18.415]                       inherits <- base::inherits
[18:02:18.415]                       invokeRestart <- base::invokeRestart
[18:02:18.415]                       is.null <- base::is.null
[18:02:18.415]                       muffled <- FALSE
[18:02:18.415]                       if (inherits(cond, "message")) {
[18:02:18.415]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:18.415]                         if (muffled) 
[18:02:18.415]                           invokeRestart("muffleMessage")
[18:02:18.415]                       }
[18:02:18.415]                       else if (inherits(cond, "warning")) {
[18:02:18.415]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:18.415]                         if (muffled) 
[18:02:18.415]                           invokeRestart("muffleWarning")
[18:02:18.415]                       }
[18:02:18.415]                       else if (inherits(cond, "condition")) {
[18:02:18.415]                         if (!is.null(pattern)) {
[18:02:18.415]                           computeRestarts <- base::computeRestarts
[18:02:18.415]                           grepl <- base::grepl
[18:02:18.415]                           restarts <- computeRestarts(cond)
[18:02:18.415]                           for (restart in restarts) {
[18:02:18.415]                             name <- restart$name
[18:02:18.415]                             if (is.null(name)) 
[18:02:18.415]                               next
[18:02:18.415]                             if (!grepl(pattern, name)) 
[18:02:18.415]                               next
[18:02:18.415]                             invokeRestart(restart)
[18:02:18.415]                             muffled <- TRUE
[18:02:18.415]                             break
[18:02:18.415]                           }
[18:02:18.415]                         }
[18:02:18.415]                       }
[18:02:18.415]                       invisible(muffled)
[18:02:18.415]                     }
[18:02:18.415]                     muffleCondition(cond, pattern = "^muffle")
[18:02:18.415]                   }
[18:02:18.415]                 }
[18:02:18.415]                 else {
[18:02:18.415]                   if (TRUE) {
[18:02:18.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:18.415]                     {
[18:02:18.415]                       inherits <- base::inherits
[18:02:18.415]                       invokeRestart <- base::invokeRestart
[18:02:18.415]                       is.null <- base::is.null
[18:02:18.415]                       muffled <- FALSE
[18:02:18.415]                       if (inherits(cond, "message")) {
[18:02:18.415]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:18.415]                         if (muffled) 
[18:02:18.415]                           invokeRestart("muffleMessage")
[18:02:18.415]                       }
[18:02:18.415]                       else if (inherits(cond, "warning")) {
[18:02:18.415]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:18.415]                         if (muffled) 
[18:02:18.415]                           invokeRestart("muffleWarning")
[18:02:18.415]                       }
[18:02:18.415]                       else if (inherits(cond, "condition")) {
[18:02:18.415]                         if (!is.null(pattern)) {
[18:02:18.415]                           computeRestarts <- base::computeRestarts
[18:02:18.415]                           grepl <- base::grepl
[18:02:18.415]                           restarts <- computeRestarts(cond)
[18:02:18.415]                           for (restart in restarts) {
[18:02:18.415]                             name <- restart$name
[18:02:18.415]                             if (is.null(name)) 
[18:02:18.415]                               next
[18:02:18.415]                             if (!grepl(pattern, name)) 
[18:02:18.415]                               next
[18:02:18.415]                             invokeRestart(restart)
[18:02:18.415]                             muffled <- TRUE
[18:02:18.415]                             break
[18:02:18.415]                           }
[18:02:18.415]                         }
[18:02:18.415]                       }
[18:02:18.415]                       invisible(muffled)
[18:02:18.415]                     }
[18:02:18.415]                     muffleCondition(cond, pattern = "^muffle")
[18:02:18.415]                   }
[18:02:18.415]                 }
[18:02:18.415]             }
[18:02:18.415]         }))
[18:02:18.415]     }, error = function(ex) {
[18:02:18.415]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:18.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:18.415]                 ...future.rng), started = ...future.startTime, 
[18:02:18.415]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:18.415]             version = "1.8"), class = "FutureResult")
[18:02:18.415]     }, finally = {
[18:02:18.415]         if (!identical(...future.workdir, getwd())) 
[18:02:18.415]             setwd(...future.workdir)
[18:02:18.415]         {
[18:02:18.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:18.415]                 ...future.oldOptions$nwarnings <- NULL
[18:02:18.415]             }
[18:02:18.415]             base::options(...future.oldOptions)
[18:02:18.415]             if (.Platform$OS.type == "windows") {
[18:02:18.415]                 old_names <- names(...future.oldEnvVars)
[18:02:18.415]                 envs <- base::Sys.getenv()
[18:02:18.415]                 names <- names(envs)
[18:02:18.415]                 common <- intersect(names, old_names)
[18:02:18.415]                 added <- setdiff(names, old_names)
[18:02:18.415]                 removed <- setdiff(old_names, names)
[18:02:18.415]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:18.415]                   envs[common]]
[18:02:18.415]                 NAMES <- toupper(changed)
[18:02:18.415]                 args <- list()
[18:02:18.415]                 for (kk in seq_along(NAMES)) {
[18:02:18.415]                   name <- changed[[kk]]
[18:02:18.415]                   NAME <- NAMES[[kk]]
[18:02:18.415]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:18.415]                     next
[18:02:18.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:18.415]                 }
[18:02:18.415]                 NAMES <- toupper(added)
[18:02:18.415]                 for (kk in seq_along(NAMES)) {
[18:02:18.415]                   name <- added[[kk]]
[18:02:18.415]                   NAME <- NAMES[[kk]]
[18:02:18.415]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:18.415]                     next
[18:02:18.415]                   args[[name]] <- ""
[18:02:18.415]                 }
[18:02:18.415]                 NAMES <- toupper(removed)
[18:02:18.415]                 for (kk in seq_along(NAMES)) {
[18:02:18.415]                   name <- removed[[kk]]
[18:02:18.415]                   NAME <- NAMES[[kk]]
[18:02:18.415]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:18.415]                     next
[18:02:18.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:18.415]                 }
[18:02:18.415]                 if (length(args) > 0) 
[18:02:18.415]                   base::do.call(base::Sys.setenv, args = args)
[18:02:18.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:18.415]             }
[18:02:18.415]             else {
[18:02:18.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:18.415]             }
[18:02:18.415]             {
[18:02:18.415]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:18.415]                   0L) {
[18:02:18.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:18.415]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:18.415]                   base::options(opts)
[18:02:18.415]                 }
[18:02:18.415]                 {
[18:02:18.415]                   {
[18:02:18.415]                     NULL
[18:02:18.415]                     RNGkind("Mersenne-Twister")
[18:02:18.415]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:18.415]                       inherits = FALSE)
[18:02:18.415]                   }
[18:02:18.415]                   options(future.plan = NULL)
[18:02:18.415]                   if (is.na(NA_character_)) 
[18:02:18.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:18.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:18.415]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:18.415]                     .init = FALSE)
[18:02:18.415]                 }
[18:02:18.415]             }
[18:02:18.415]         }
[18:02:18.415]     })
[18:02:18.415]     if (TRUE) {
[18:02:18.415]         base::sink(type = "output", split = FALSE)
[18:02:18.415]         if (FALSE) {
[18:02:18.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:18.415]         }
[18:02:18.415]         else {
[18:02:18.415]             ...future.result["stdout"] <- base::list(NULL)
[18:02:18.415]         }
[18:02:18.415]         base::close(...future.stdout)
[18:02:18.415]         ...future.stdout <- NULL
[18:02:18.415]     }
[18:02:18.415]     ...future.result$conditions <- ...future.conditions
[18:02:18.415]     ...future.result$finished <- base::Sys.time()
[18:02:18.415]     ...future.result
[18:02:18.415] }
[18:02:18.419] assign_globals() ...
[18:02:18.419] List of 5
[18:02:18.419]  $ ...future.FUN            :function (x)  
[18:02:18.419]  $ future.call.arguments    : list()
[18:02:18.419]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:18.419]  $ ...future.elements_ii    :List of 2
[18:02:18.419]   ..$ : int 1
[18:02:18.419]   ..$ : int 0
[18:02:18.419]  $ ...future.seeds_ii       : NULL
[18:02:18.419]  $ ...future.globals.maxSize: NULL
[18:02:18.419]  - attr(*, "where")=List of 5
[18:02:18.419]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:18.419]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:18.419]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:18.419]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:18.419]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:18.419]  - attr(*, "resolved")= logi FALSE
[18:02:18.419]  - attr(*, "total_size")= num 4720
[18:02:18.419]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:18.419]  - attr(*, "already-done")= logi TRUE
[18:02:18.429] - reassign environment for ‘...future.FUN’
[18:02:18.429] - copied ‘...future.FUN’ to environment
[18:02:18.429] - copied ‘future.call.arguments’ to environment
[18:02:18.430] - copied ‘...future.elements_ii’ to environment
[18:02:18.430] - copied ‘...future.seeds_ii’ to environment
[18:02:18.430] - copied ‘...future.globals.maxSize’ to environment
[18:02:18.430] assign_globals() ... done
[18:02:18.431] plan(): Setting new future strategy stack:
[18:02:18.431] List of future strategies:
[18:02:18.431] 1. sequential:
[18:02:18.431]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:18.431]    - tweaked: FALSE
[18:02:18.431]    - call: NULL
[18:02:18.432] plan(): nbrOfWorkers() = 1
[18:02:18.935] plan(): Setting new future strategy stack:
[18:02:18.935] List of future strategies:
[18:02:18.935] 1. sequential:
[18:02:18.935]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:18.935]    - tweaked: FALSE
[18:02:18.935]    - call: plan(strategy)
[18:02:18.936] plan(): nbrOfWorkers() = 1
[18:02:18.936] SequentialFuture started (and completed)
[18:02:18.937] - Launch lazy future ... done
[18:02:18.937] run() for ‘SequentialFuture’ ... done
[18:02:18.938] Created future:
[18:02:18.938] SequentialFuture:
[18:02:18.938] Label: ‘future_lapply-1’
[18:02:18.938] Expression:
[18:02:18.938] {
[18:02:18.938]     do.call(function(...) {
[18:02:18.938]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:18.938]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:18.938]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:18.938]             on.exit(options(oopts), add = TRUE)
[18:02:18.938]         }
[18:02:18.938]         {
[18:02:18.938]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:18.938]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:18.938]                 ...future.FUN(...future.X_jj, ...)
[18:02:18.938]             })
[18:02:18.938]         }
[18:02:18.938]     }, args = future.call.arguments)
[18:02:18.938] }
[18:02:18.938] Lazy evaluation: FALSE
[18:02:18.938] Asynchronous evaluation: FALSE
[18:02:18.938] Local evaluation: TRUE
[18:02:18.938] Environment: R_GlobalEnv
[18:02:18.938] Capture standard output: FALSE
[18:02:18.938] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:18.938] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:18.938] Packages: <none>
[18:02:18.938] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:18.938] Resolved: TRUE
[18:02:18.938] Value: 112 bytes of class ‘list’
[18:02:18.938] Early signaling: FALSE
[18:02:18.938] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:18.938] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:18.941] Chunk #1 of 1 ... DONE
[18:02:18.941] Launching 1 futures (chunks) ... DONE
[18:02:18.941] Resolving 1 futures (chunks) ...
[18:02:18.941] resolve() on list ...
[18:02:18.942]  recursive: 0
[18:02:18.942]  length: 1
[18:02:18.942] 
[18:02:18.942] resolved() for ‘SequentialFuture’ ...
[18:02:18.942] - state: ‘finished’
[18:02:18.943] - run: TRUE
[18:02:18.943] - result: ‘FutureResult’
[18:02:18.943] resolved() for ‘SequentialFuture’ ... done
[18:02:18.943] Future #1
[18:02:18.944] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:18.944] - nx: 1
[18:02:18.944] - relay: TRUE
[18:02:18.945] - stdout: TRUE
[18:02:18.945] - signal: TRUE
[18:02:18.945] - resignal: FALSE
[18:02:18.945] - force: TRUE
[18:02:18.945] - relayed: [n=1] FALSE
[18:02:18.945] - queued futures: [n=1] FALSE
[18:02:18.946]  - until=1
[18:02:18.946]  - relaying element #1
[18:02:18.946] - relayed: [n=1] TRUE
[18:02:18.946] - queued futures: [n=1] TRUE
[18:02:18.947] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:18.947]  length: 0 (resolved future 1)
[18:02:18.947] Relaying remaining futures
[18:02:18.947] signalConditionsASAP(NULL, pos=0) ...
[18:02:18.948] - nx: 1
[18:02:18.948] - relay: TRUE
[18:02:18.948] - stdout: TRUE
[18:02:18.948] - signal: TRUE
[18:02:18.948] - resignal: FALSE
[18:02:18.948] - force: TRUE
[18:02:18.949] - relayed: [n=1] TRUE
[18:02:18.949] - queued futures: [n=1] TRUE
 - flush all
[18:02:18.949] - relayed: [n=1] TRUE
[18:02:18.949] - queued futures: [n=1] TRUE
[18:02:18.949] signalConditionsASAP(NULL, pos=0) ... done
[18:02:18.950] resolve() on list ... DONE
[18:02:18.950]  - Number of value chunks collected: 1
[18:02:18.950] Resolving 1 futures (chunks) ... DONE
[18:02:18.950] Reducing values from 1 chunks ...
[18:02:18.950]  - Number of values collected after concatenation: 2
[18:02:18.951]  - Number of values expected: 2
[18:02:18.951] Reducing values from 1 chunks ... DONE
[18:02:18.951] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[18:02:18.952] future_lapply() ...
[18:02:18.953] Number of chunks: 1
[18:02:18.953] getGlobalsAndPackagesXApply() ...
[18:02:18.954]  - future.globals: TRUE
[18:02:18.954] getGlobalsAndPackages() ...
[18:02:18.954] Searching for globals...
[18:02:18.957] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:18.957] Searching for globals ... DONE
[18:02:18.957] Resolving globals: FALSE
[18:02:18.958] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:18.959] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:18.959] - globals: [1] ‘FUN’
[18:02:18.959] 
[18:02:18.959] getGlobalsAndPackages() ... DONE
[18:02:18.962]  - globals found/used: [n=1] ‘FUN’
[18:02:18.962]  - needed namespaces: [n=0] 
[18:02:18.963] Finding globals ... DONE
[18:02:18.963]  - use_args: TRUE
[18:02:18.963]  - Getting '...' globals ...
[18:02:18.964] resolve() on list ...
[18:02:18.964]  recursive: 0
[18:02:18.964]  length: 1
[18:02:18.964]  elements: ‘...’
[18:02:18.965]  length: 0 (resolved future 1)
[18:02:18.965] resolve() on list ... DONE
[18:02:18.965]    - '...' content: [n=0] 
[18:02:18.965] List of 1
[18:02:18.965]  $ ...: list()
[18:02:18.965]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:18.965]  - attr(*, "where")=List of 1
[18:02:18.965]   ..$ ...:<environment: 0x5e4f8584ed68> 
[18:02:18.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:18.965]  - attr(*, "resolved")= logi TRUE
[18:02:18.965]  - attr(*, "total_size")= num NA
[18:02:18.971]  - Getting '...' globals ... DONE
[18:02:18.971] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:18.971] List of 2
[18:02:18.971]  $ ...future.FUN:function (x)  
[18:02:18.971]  $ ...          : list()
[18:02:18.971]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:18.971]  - attr(*, "where")=List of 2
[18:02:18.971]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:18.971]   ..$ ...          :<environment: 0x5e4f8584ed68> 
[18:02:18.971]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:18.971]  - attr(*, "resolved")= logi FALSE
[18:02:18.971]  - attr(*, "total_size")= num 4720
[18:02:18.976] Packages to be attached in all futures: [n=0] 
[18:02:18.977] getGlobalsAndPackagesXApply() ... DONE
[18:02:18.977] Number of futures (= number of chunks): 1
[18:02:18.977] Launching 1 futures (chunks) ...
[18:02:18.977] Chunk #1 of 1 ...
[18:02:18.978]  - Finding globals in 'X' for chunk #1 ...
[18:02:18.978] getGlobalsAndPackages() ...
[18:02:18.978] Searching for globals...
[18:02:18.979] 
[18:02:18.979] Searching for globals ... DONE
[18:02:18.979] - globals: [0] <none>
[18:02:18.979] getGlobalsAndPackages() ... DONE
[18:02:18.979]    + additional globals found: [n=0] 
[18:02:18.979]    + additional namespaces needed: [n=0] 
[18:02:18.980]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:18.980]  - seeds: <none>
[18:02:18.980]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:18.980] getGlobalsAndPackages() ...
[18:02:18.980] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:18.981] Resolving globals: FALSE
[18:02:18.981] Tweak future expression to call with '...' arguments ...
[18:02:18.981] {
[18:02:18.981]     do.call(function(...) {
[18:02:18.981]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:18.981]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:18.981]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:18.981]             on.exit(options(oopts), add = TRUE)
[18:02:18.981]         }
[18:02:18.981]         {
[18:02:18.981]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:18.981]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:18.981]                 ...future.FUN(...future.X_jj, ...)
[18:02:18.981]             })
[18:02:18.981]         }
[18:02:18.981]     }, args = future.call.arguments)
[18:02:18.981] }
[18:02:18.982] Tweak future expression to call with '...' arguments ... DONE
[18:02:18.982] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:18.983] 
[18:02:18.983] getGlobalsAndPackages() ... DONE
[18:02:18.983] run() for ‘Future’ ...
[18:02:18.983] - state: ‘created’
[18:02:18.984] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:02:18.984] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:18.984] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:18.985]   - Field: ‘label’
[18:02:18.985]   - Field: ‘local’
[18:02:18.985]   - Field: ‘owner’
[18:02:18.985]   - Field: ‘envir’
[18:02:18.985]   - Field: ‘packages’
[18:02:18.986]   - Field: ‘gc’
[18:02:18.986]   - Field: ‘conditions’
[18:02:18.986]   - Field: ‘expr’
[18:02:18.986]   - Field: ‘uuid’
[18:02:18.986]   - Field: ‘seed’
[18:02:18.987]   - Field: ‘version’
[18:02:18.987]   - Field: ‘result’
[18:02:18.987]   - Field: ‘asynchronous’
[18:02:18.987]   - Field: ‘calls’
[18:02:18.987]   - Field: ‘globals’
[18:02:18.988]   - Field: ‘stdout’
[18:02:18.988]   - Field: ‘earlySignal’
[18:02:18.988]   - Field: ‘lazy’
[18:02:18.988]   - Field: ‘state’
[18:02:18.988] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:18.989] - Launch lazy future ...
[18:02:18.989] Packages needed by the future expression (n = 0): <none>
[18:02:18.989] Packages needed by future strategies (n = 0): <none>
[18:02:18.990] {
[18:02:18.990]     {
[18:02:18.990]         {
[18:02:18.990]             ...future.startTime <- base::Sys.time()
[18:02:18.990]             {
[18:02:18.990]                 {
[18:02:18.990]                   {
[18:02:18.990]                     base::local({
[18:02:18.990]                       has_future <- base::requireNamespace("future", 
[18:02:18.990]                         quietly = TRUE)
[18:02:18.990]                       if (has_future) {
[18:02:18.990]                         ns <- base::getNamespace("future")
[18:02:18.990]                         version <- ns[[".package"]][["version"]]
[18:02:18.990]                         if (is.null(version)) 
[18:02:18.990]                           version <- utils::packageVersion("future")
[18:02:18.990]                       }
[18:02:18.990]                       else {
[18:02:18.990]                         version <- NULL
[18:02:18.990]                       }
[18:02:18.990]                       if (!has_future || version < "1.8.0") {
[18:02:18.990]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:18.990]                           "", base::R.version$version.string), 
[18:02:18.990]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:18.990]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:18.990]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:18.990]                             "release", "version")], collapse = " "), 
[18:02:18.990]                           hostname = base::Sys.info()[["nodename"]])
[18:02:18.990]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:18.990]                           info)
[18:02:18.990]                         info <- base::paste(info, collapse = "; ")
[18:02:18.990]                         if (!has_future) {
[18:02:18.990]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:18.990]                             info)
[18:02:18.990]                         }
[18:02:18.990]                         else {
[18:02:18.990]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:18.990]                             info, version)
[18:02:18.990]                         }
[18:02:18.990]                         base::stop(msg)
[18:02:18.990]                       }
[18:02:18.990]                     })
[18:02:18.990]                   }
[18:02:18.990]                   ...future.strategy.old <- future::plan("list")
[18:02:18.990]                   options(future.plan = NULL)
[18:02:18.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:18.990]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:18.990]                 }
[18:02:18.990]                 ...future.workdir <- getwd()
[18:02:18.990]             }
[18:02:18.990]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:18.990]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:18.990]         }
[18:02:18.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:18.990]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:18.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:18.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:18.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:18.990]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:18.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:18.990]             base::names(...future.oldOptions))
[18:02:18.990]     }
[18:02:18.990]     if (FALSE) {
[18:02:18.990]     }
[18:02:18.990]     else {
[18:02:18.990]         if (TRUE) {
[18:02:18.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:18.990]                 open = "w")
[18:02:18.990]         }
[18:02:18.990]         else {
[18:02:18.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:18.990]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:18.990]         }
[18:02:18.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:18.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:18.990]             base::sink(type = "output", split = FALSE)
[18:02:18.990]             base::close(...future.stdout)
[18:02:18.990]         }, add = TRUE)
[18:02:18.990]     }
[18:02:18.990]     ...future.frame <- base::sys.nframe()
[18:02:18.990]     ...future.conditions <- base::list()
[18:02:18.990]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:18.990]     if (FALSE) {
[18:02:18.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:18.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:18.990]     }
[18:02:18.990]     ...future.result <- base::tryCatch({
[18:02:18.990]         base::withCallingHandlers({
[18:02:18.990]             ...future.value <- base::withVisible(base::local({
[18:02:18.990]                 do.call(function(...) {
[18:02:18.990]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:18.990]                   if (!identical(...future.globals.maxSize.org, 
[18:02:18.990]                     ...future.globals.maxSize)) {
[18:02:18.990]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:18.990]                     on.exit(options(oopts), add = TRUE)
[18:02:18.990]                   }
[18:02:18.990]                   {
[18:02:18.990]                     lapply(seq_along(...future.elements_ii), 
[18:02:18.990]                       FUN = function(jj) {
[18:02:18.990]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:18.990]                         ...future.FUN(...future.X_jj, ...)
[18:02:18.990]                       })
[18:02:18.990]                   }
[18:02:18.990]                 }, args = future.call.arguments)
[18:02:18.990]             }))
[18:02:18.990]             future::FutureResult(value = ...future.value$value, 
[18:02:18.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:18.990]                   ...future.rng), globalenv = if (FALSE) 
[18:02:18.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:18.990]                     ...future.globalenv.names))
[18:02:18.990]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:18.990]         }, condition = base::local({
[18:02:18.990]             c <- base::c
[18:02:18.990]             inherits <- base::inherits
[18:02:18.990]             invokeRestart <- base::invokeRestart
[18:02:18.990]             length <- base::length
[18:02:18.990]             list <- base::list
[18:02:18.990]             seq.int <- base::seq.int
[18:02:18.990]             signalCondition <- base::signalCondition
[18:02:18.990]             sys.calls <- base::sys.calls
[18:02:18.990]             `[[` <- base::`[[`
[18:02:18.990]             `+` <- base::`+`
[18:02:18.990]             `<<-` <- base::`<<-`
[18:02:18.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:18.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:18.990]                   3L)]
[18:02:18.990]             }
[18:02:18.990]             function(cond) {
[18:02:18.990]                 is_error <- inherits(cond, "error")
[18:02:18.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:18.990]                   NULL)
[18:02:18.990]                 if (is_error) {
[18:02:18.990]                   sessionInformation <- function() {
[18:02:18.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:18.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:18.990]                       search = base::search(), system = base::Sys.info())
[18:02:18.990]                   }
[18:02:18.990]                   ...future.conditions[[length(...future.conditions) + 
[18:02:18.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:18.990]                     cond$call), session = sessionInformation(), 
[18:02:18.990]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:18.990]                   signalCondition(cond)
[18:02:18.990]                 }
[18:02:18.990]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:18.990]                 "immediateCondition"))) {
[18:02:18.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:18.990]                   ...future.conditions[[length(...future.conditions) + 
[18:02:18.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:18.990]                   if (TRUE && !signal) {
[18:02:18.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:18.990]                     {
[18:02:18.990]                       inherits <- base::inherits
[18:02:18.990]                       invokeRestart <- base::invokeRestart
[18:02:18.990]                       is.null <- base::is.null
[18:02:18.990]                       muffled <- FALSE
[18:02:18.990]                       if (inherits(cond, "message")) {
[18:02:18.990]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:18.990]                         if (muffled) 
[18:02:18.990]                           invokeRestart("muffleMessage")
[18:02:18.990]                       }
[18:02:18.990]                       else if (inherits(cond, "warning")) {
[18:02:18.990]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:18.990]                         if (muffled) 
[18:02:18.990]                           invokeRestart("muffleWarning")
[18:02:18.990]                       }
[18:02:18.990]                       else if (inherits(cond, "condition")) {
[18:02:18.990]                         if (!is.null(pattern)) {
[18:02:18.990]                           computeRestarts <- base::computeRestarts
[18:02:18.990]                           grepl <- base::grepl
[18:02:18.990]                           restarts <- computeRestarts(cond)
[18:02:18.990]                           for (restart in restarts) {
[18:02:18.990]                             name <- restart$name
[18:02:18.990]                             if (is.null(name)) 
[18:02:18.990]                               next
[18:02:18.990]                             if (!grepl(pattern, name)) 
[18:02:18.990]                               next
[18:02:18.990]                             invokeRestart(restart)
[18:02:18.990]                             muffled <- TRUE
[18:02:18.990]                             break
[18:02:18.990]                           }
[18:02:18.990]                         }
[18:02:18.990]                       }
[18:02:18.990]                       invisible(muffled)
[18:02:18.990]                     }
[18:02:18.990]                     muffleCondition(cond, pattern = "^muffle")
[18:02:18.990]                   }
[18:02:18.990]                 }
[18:02:18.990]                 else {
[18:02:18.990]                   if (TRUE) {
[18:02:18.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:18.990]                     {
[18:02:18.990]                       inherits <- base::inherits
[18:02:18.990]                       invokeRestart <- base::invokeRestart
[18:02:18.990]                       is.null <- base::is.null
[18:02:18.990]                       muffled <- FALSE
[18:02:18.990]                       if (inherits(cond, "message")) {
[18:02:18.990]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:18.990]                         if (muffled) 
[18:02:18.990]                           invokeRestart("muffleMessage")
[18:02:18.990]                       }
[18:02:18.990]                       else if (inherits(cond, "warning")) {
[18:02:18.990]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:18.990]                         if (muffled) 
[18:02:18.990]                           invokeRestart("muffleWarning")
[18:02:18.990]                       }
[18:02:18.990]                       else if (inherits(cond, "condition")) {
[18:02:18.990]                         if (!is.null(pattern)) {
[18:02:18.990]                           computeRestarts <- base::computeRestarts
[18:02:18.990]                           grepl <- base::grepl
[18:02:18.990]                           restarts <- computeRestarts(cond)
[18:02:18.990]                           for (restart in restarts) {
[18:02:18.990]                             name <- restart$name
[18:02:18.990]                             if (is.null(name)) 
[18:02:18.990]                               next
[18:02:18.990]                             if (!grepl(pattern, name)) 
[18:02:18.990]                               next
[18:02:18.990]                             invokeRestart(restart)
[18:02:18.990]                             muffled <- TRUE
[18:02:18.990]                             break
[18:02:18.990]                           }
[18:02:18.990]                         }
[18:02:18.990]                       }
[18:02:18.990]                       invisible(muffled)
[18:02:18.990]                     }
[18:02:18.990]                     muffleCondition(cond, pattern = "^muffle")
[18:02:18.990]                   }
[18:02:18.990]                 }
[18:02:18.990]             }
[18:02:18.990]         }))
[18:02:18.990]     }, error = function(ex) {
[18:02:18.990]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:18.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:18.990]                 ...future.rng), started = ...future.startTime, 
[18:02:18.990]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:18.990]             version = "1.8"), class = "FutureResult")
[18:02:18.990]     }, finally = {
[18:02:18.990]         if (!identical(...future.workdir, getwd())) 
[18:02:18.990]             setwd(...future.workdir)
[18:02:18.990]         {
[18:02:18.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:18.990]                 ...future.oldOptions$nwarnings <- NULL
[18:02:18.990]             }
[18:02:18.990]             base::options(...future.oldOptions)
[18:02:18.990]             if (.Platform$OS.type == "windows") {
[18:02:18.990]                 old_names <- names(...future.oldEnvVars)
[18:02:18.990]                 envs <- base::Sys.getenv()
[18:02:18.990]                 names <- names(envs)
[18:02:18.990]                 common <- intersect(names, old_names)
[18:02:18.990]                 added <- setdiff(names, old_names)
[18:02:18.990]                 removed <- setdiff(old_names, names)
[18:02:18.990]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:18.990]                   envs[common]]
[18:02:18.990]                 NAMES <- toupper(changed)
[18:02:18.990]                 args <- list()
[18:02:18.990]                 for (kk in seq_along(NAMES)) {
[18:02:18.990]                   name <- changed[[kk]]
[18:02:18.990]                   NAME <- NAMES[[kk]]
[18:02:18.990]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:18.990]                     next
[18:02:18.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:18.990]                 }
[18:02:18.990]                 NAMES <- toupper(added)
[18:02:18.990]                 for (kk in seq_along(NAMES)) {
[18:02:18.990]                   name <- added[[kk]]
[18:02:18.990]                   NAME <- NAMES[[kk]]
[18:02:18.990]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:18.990]                     next
[18:02:18.990]                   args[[name]] <- ""
[18:02:18.990]                 }
[18:02:18.990]                 NAMES <- toupper(removed)
[18:02:18.990]                 for (kk in seq_along(NAMES)) {
[18:02:18.990]                   name <- removed[[kk]]
[18:02:18.990]                   NAME <- NAMES[[kk]]
[18:02:18.990]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:18.990]                     next
[18:02:18.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:18.990]                 }
[18:02:18.990]                 if (length(args) > 0) 
[18:02:18.990]                   base::do.call(base::Sys.setenv, args = args)
[18:02:18.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:18.990]             }
[18:02:18.990]             else {
[18:02:18.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:18.990]             }
[18:02:18.990]             {
[18:02:18.990]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:18.990]                   0L) {
[18:02:18.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:18.990]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:18.990]                   base::options(opts)
[18:02:18.990]                 }
[18:02:18.990]                 {
[18:02:18.990]                   {
[18:02:18.990]                     NULL
[18:02:18.990]                     RNGkind("Mersenne-Twister")
[18:02:18.990]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:18.990]                       inherits = FALSE)
[18:02:18.990]                   }
[18:02:18.990]                   options(future.plan = NULL)
[18:02:18.990]                   if (is.na(NA_character_)) 
[18:02:18.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:18.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:18.990]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:18.990]                     .init = FALSE)
[18:02:18.990]                 }
[18:02:18.990]             }
[18:02:18.990]         }
[18:02:18.990]     })
[18:02:18.990]     if (TRUE) {
[18:02:18.990]         base::sink(type = "output", split = FALSE)
[18:02:18.990]         if (TRUE) {
[18:02:18.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:18.990]         }
[18:02:18.990]         else {
[18:02:18.990]             ...future.result["stdout"] <- base::list(NULL)
[18:02:18.990]         }
[18:02:18.990]         base::close(...future.stdout)
[18:02:18.990]         ...future.stdout <- NULL
[18:02:18.990]     }
[18:02:18.990]     ...future.result$conditions <- ...future.conditions
[18:02:18.990]     ...future.result$finished <- base::Sys.time()
[18:02:18.990]     ...future.result
[18:02:18.990] }
[18:02:18.993] assign_globals() ...
[18:02:18.994] List of 5
[18:02:18.994]  $ ...future.FUN            :function (x)  
[18:02:18.994]  $ future.call.arguments    : list()
[18:02:18.994]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:18.994]  $ ...future.elements_ii    :List of 2
[18:02:18.994]   ..$ : int 1
[18:02:18.994]   ..$ : int 0
[18:02:18.994]  $ ...future.seeds_ii       : NULL
[18:02:18.994]  $ ...future.globals.maxSize: NULL
[18:02:18.994]  - attr(*, "where")=List of 5
[18:02:18.994]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:18.994]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:18.994]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:18.994]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:18.994]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:18.994]  - attr(*, "resolved")= logi FALSE
[18:02:18.994]  - attr(*, "total_size")= num 4720
[18:02:18.994]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:18.994]  - attr(*, "already-done")= logi TRUE
[18:02:19.003] - reassign environment for ‘...future.FUN’
[18:02:19.003] - copied ‘...future.FUN’ to environment
[18:02:19.004] - copied ‘future.call.arguments’ to environment
[18:02:19.004] - copied ‘...future.elements_ii’ to environment
[18:02:19.004] - copied ‘...future.seeds_ii’ to environment
[18:02:19.004] - copied ‘...future.globals.maxSize’ to environment
[18:02:19.004] assign_globals() ... done
[18:02:19.005] plan(): Setting new future strategy stack:
[18:02:19.005] List of future strategies:
[18:02:19.005] 1. sequential:
[18:02:19.005]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:19.005]    - tweaked: FALSE
[18:02:19.005]    - call: NULL
[18:02:19.006] plan(): nbrOfWorkers() = 1
[18:02:19.508] plan(): Setting new future strategy stack:
[18:02:19.509] List of future strategies:
[18:02:19.509] 1. sequential:
[18:02:19.509]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:19.509]    - tweaked: FALSE
[18:02:19.509]    - call: plan(strategy)
[18:02:19.510] plan(): nbrOfWorkers() = 1
[18:02:19.510] SequentialFuture started (and completed)
[18:02:19.510] - Launch lazy future ... done
[18:02:19.511] run() for ‘SequentialFuture’ ... done
[18:02:19.511] Created future:
[18:02:19.511] SequentialFuture:
[18:02:19.511] Label: ‘future_lapply-1’
[18:02:19.511] Expression:
[18:02:19.511] {
[18:02:19.511]     do.call(function(...) {
[18:02:19.511]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:19.511]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:19.511]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:19.511]             on.exit(options(oopts), add = TRUE)
[18:02:19.511]         }
[18:02:19.511]         {
[18:02:19.511]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:19.511]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:19.511]                 ...future.FUN(...future.X_jj, ...)
[18:02:19.511]             })
[18:02:19.511]         }
[18:02:19.511]     }, args = future.call.arguments)
[18:02:19.511] }
[18:02:19.511] Lazy evaluation: FALSE
[18:02:19.511] Asynchronous evaluation: FALSE
[18:02:19.511] Local evaluation: TRUE
[18:02:19.511] Environment: R_GlobalEnv
[18:02:19.511] Capture standard output: TRUE
[18:02:19.511] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:19.511] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:19.511] Packages: <none>
[18:02:19.511] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:19.511] Resolved: TRUE
[18:02:19.511] Value: 112 bytes of class ‘list’
[18:02:19.511] Early signaling: FALSE
[18:02:19.511] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:19.511] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:19.513] Chunk #1 of 1 ... DONE
[18:02:19.513] Launching 1 futures (chunks) ... DONE
[18:02:19.513] Resolving 1 futures (chunks) ...
[18:02:19.514] resolve() on list ...
[18:02:19.514]  recursive: 0
[18:02:19.514]  length: 1
[18:02:19.514] 
[18:02:19.514] resolved() for ‘SequentialFuture’ ...
[18:02:19.515] - state: ‘finished’
[18:02:19.515] - run: TRUE
[18:02:19.515] - result: ‘FutureResult’
[18:02:19.515] resolved() for ‘SequentialFuture’ ... done
[18:02:19.515] Future #1
[18:02:19.516] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:19.516] - nx: 1
[18:02:19.516] - relay: TRUE
[18:02:19.516] - stdout: TRUE
[18:02:19.516] - signal: TRUE
[18:02:19.517] - resignal: FALSE
[18:02:19.519] - force: TRUE
[18:02:19.519] - relayed: [n=1] FALSE
[18:02:19.519] - queued futures: [n=1] FALSE
[18:02:19.520]  - until=1
[18:02:19.520]  - relaying element #1
[18:02:19.520] - relayed: [n=1] TRUE
[18:02:19.520] - queued futures: [n=1] TRUE
[18:02:19.521] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:19.521]  length: 0 (resolved future 1)
[18:02:19.521] Relaying remaining futures
[18:02:19.521] signalConditionsASAP(NULL, pos=0) ...
[18:02:19.521] - nx: 1
[18:02:19.521] - relay: TRUE
[18:02:19.522] - stdout: TRUE
[18:02:19.522] - signal: TRUE
[18:02:19.522] - resignal: FALSE
[18:02:19.522] - force: TRUE
[18:02:19.522] - relayed: [n=1] TRUE
[18:02:19.522] - queued futures: [n=1] TRUE
 - flush all
[18:02:19.523] - relayed: [n=1] TRUE
[18:02:19.523] - queued futures: [n=1] TRUE
[18:02:19.523] signalConditionsASAP(NULL, pos=0) ... done
[18:02:19.523] resolve() on list ... DONE
[18:02:19.524]  - Number of value chunks collected: 1
[18:02:19.524] Resolving 1 futures (chunks) ... DONE
[18:02:19.524] Reducing values from 1 chunks ...
[18:02:19.524]  - Number of values collected after concatenation: 2
[18:02:19.524]  - Number of values expected: 2
[18:02:19.525] Reducing values from 1 chunks ... DONE
[18:02:19.525] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[18:02:19.525] future_lapply() ...
[18:02:19.527] Number of chunks: 1
[18:02:19.527] getGlobalsAndPackagesXApply() ...
[18:02:19.527]  - future.globals: TRUE
[18:02:19.527] getGlobalsAndPackages() ...
[18:02:19.528] Searching for globals...
[18:02:19.530] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:19.530] Searching for globals ... DONE
[18:02:19.531] Resolving globals: FALSE
[18:02:19.531] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:19.532] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:19.532] - globals: [1] ‘FUN’
[18:02:19.533] 
[18:02:19.533] getGlobalsAndPackages() ... DONE
[18:02:19.533]  - globals found/used: [n=1] ‘FUN’
[18:02:19.533]  - needed namespaces: [n=0] 
[18:02:19.533] Finding globals ... DONE
[18:02:19.534]  - use_args: TRUE
[18:02:19.534]  - Getting '...' globals ...
[18:02:19.534] resolve() on list ...
[18:02:19.535]  recursive: 0
[18:02:19.535]  length: 1
[18:02:19.535]  elements: ‘...’
[18:02:19.535]  length: 0 (resolved future 1)
[18:02:19.535] resolve() on list ... DONE
[18:02:19.536]    - '...' content: [n=0] 
[18:02:19.536] List of 1
[18:02:19.536]  $ ...: list()
[18:02:19.536]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:19.536]  - attr(*, "where")=List of 1
[18:02:19.536]   ..$ ...:<environment: 0x5e4f83a7dad0> 
[18:02:19.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:19.536]  - attr(*, "resolved")= logi TRUE
[18:02:19.536]  - attr(*, "total_size")= num NA
[18:02:19.541]  - Getting '...' globals ... DONE
[18:02:19.541] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:19.541] List of 2
[18:02:19.541]  $ ...future.FUN:function (x)  
[18:02:19.541]  $ ...          : list()
[18:02:19.541]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:19.541]  - attr(*, "where")=List of 2
[18:02:19.541]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:19.541]   ..$ ...          :<environment: 0x5e4f83a7dad0> 
[18:02:19.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:19.541]  - attr(*, "resolved")= logi FALSE
[18:02:19.541]  - attr(*, "total_size")= num 4720
[18:02:19.547] Packages to be attached in all futures: [n=0] 
[18:02:19.547] getGlobalsAndPackagesXApply() ... DONE
[18:02:19.547] Number of futures (= number of chunks): 1
[18:02:19.547] Launching 1 futures (chunks) ...
[18:02:19.548] Chunk #1 of 1 ...
[18:02:19.548]  - Finding globals in 'X' for chunk #1 ...
[18:02:19.548] getGlobalsAndPackages() ...
[18:02:19.548] Searching for globals...
[18:02:19.549] 
[18:02:19.549] Searching for globals ... DONE
[18:02:19.549] - globals: [0] <none>
[18:02:19.549] getGlobalsAndPackages() ... DONE
[18:02:19.549]    + additional globals found: [n=0] 
[18:02:19.550]    + additional namespaces needed: [n=0] 
[18:02:19.550]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:19.550]  - seeds: <none>
[18:02:19.550]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:19.550] getGlobalsAndPackages() ...
[18:02:19.551] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:19.551] Resolving globals: FALSE
[18:02:19.551] Tweak future expression to call with '...' arguments ...
[18:02:19.551] {
[18:02:19.551]     do.call(function(...) {
[18:02:19.551]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:19.551]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:19.551]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:19.551]             on.exit(options(oopts), add = TRUE)
[18:02:19.551]         }
[18:02:19.551]         {
[18:02:19.551]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:19.551]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:19.551]                 ...future.FUN(...future.X_jj, ...)
[18:02:19.551]             })
[18:02:19.551]         }
[18:02:19.551]     }, args = future.call.arguments)
[18:02:19.551] }
[18:02:19.552] Tweak future expression to call with '...' arguments ... DONE
[18:02:19.552] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:19.553] 
[18:02:19.553] getGlobalsAndPackages() ... DONE
[18:02:19.553] run() for ‘Future’ ...
[18:02:19.554] - state: ‘created’
[18:02:19.554] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:02:19.554] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:19.555] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:19.555]   - Field: ‘label’
[18:02:19.555]   - Field: ‘local’
[18:02:19.555]   - Field: ‘owner’
[18:02:19.555]   - Field: ‘envir’
[18:02:19.556]   - Field: ‘packages’
[18:02:19.556]   - Field: ‘gc’
[18:02:19.556]   - Field: ‘conditions’
[18:02:19.556]   - Field: ‘expr’
[18:02:19.556]   - Field: ‘uuid’
[18:02:19.557]   - Field: ‘seed’
[18:02:19.557]   - Field: ‘version’
[18:02:19.557]   - Field: ‘result’
[18:02:19.557]   - Field: ‘asynchronous’
[18:02:19.557]   - Field: ‘calls’
[18:02:19.558]   - Field: ‘globals’
[18:02:19.558]   - Field: ‘stdout’
[18:02:19.558]   - Field: ‘earlySignal’
[18:02:19.558]   - Field: ‘lazy’
[18:02:19.558]   - Field: ‘state’
[18:02:19.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:19.559] - Launch lazy future ...
[18:02:19.559] Packages needed by the future expression (n = 0): <none>
[18:02:19.559] Packages needed by future strategies (n = 0): <none>
[18:02:19.560] {
[18:02:19.560]     {
[18:02:19.560]         {
[18:02:19.560]             ...future.startTime <- base::Sys.time()
[18:02:19.560]             {
[18:02:19.560]                 {
[18:02:19.560]                   {
[18:02:19.560]                     base::local({
[18:02:19.560]                       has_future <- base::requireNamespace("future", 
[18:02:19.560]                         quietly = TRUE)
[18:02:19.560]                       if (has_future) {
[18:02:19.560]                         ns <- base::getNamespace("future")
[18:02:19.560]                         version <- ns[[".package"]][["version"]]
[18:02:19.560]                         if (is.null(version)) 
[18:02:19.560]                           version <- utils::packageVersion("future")
[18:02:19.560]                       }
[18:02:19.560]                       else {
[18:02:19.560]                         version <- NULL
[18:02:19.560]                       }
[18:02:19.560]                       if (!has_future || version < "1.8.0") {
[18:02:19.560]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:19.560]                           "", base::R.version$version.string), 
[18:02:19.560]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:19.560]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:19.560]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:19.560]                             "release", "version")], collapse = " "), 
[18:02:19.560]                           hostname = base::Sys.info()[["nodename"]])
[18:02:19.560]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:19.560]                           info)
[18:02:19.560]                         info <- base::paste(info, collapse = "; ")
[18:02:19.560]                         if (!has_future) {
[18:02:19.560]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:19.560]                             info)
[18:02:19.560]                         }
[18:02:19.560]                         else {
[18:02:19.560]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:19.560]                             info, version)
[18:02:19.560]                         }
[18:02:19.560]                         base::stop(msg)
[18:02:19.560]                       }
[18:02:19.560]                     })
[18:02:19.560]                   }
[18:02:19.560]                   ...future.strategy.old <- future::plan("list")
[18:02:19.560]                   options(future.plan = NULL)
[18:02:19.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:19.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:19.560]                 }
[18:02:19.560]                 ...future.workdir <- getwd()
[18:02:19.560]             }
[18:02:19.560]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:19.560]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:19.560]         }
[18:02:19.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:19.560]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:19.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:19.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:19.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:19.560]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:19.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:19.560]             base::names(...future.oldOptions))
[18:02:19.560]     }
[18:02:19.560]     if (TRUE) {
[18:02:19.560]     }
[18:02:19.560]     else {
[18:02:19.560]         if (NA) {
[18:02:19.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:19.560]                 open = "w")
[18:02:19.560]         }
[18:02:19.560]         else {
[18:02:19.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:19.560]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:19.560]         }
[18:02:19.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:19.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:19.560]             base::sink(type = "output", split = FALSE)
[18:02:19.560]             base::close(...future.stdout)
[18:02:19.560]         }, add = TRUE)
[18:02:19.560]     }
[18:02:19.560]     ...future.frame <- base::sys.nframe()
[18:02:19.560]     ...future.conditions <- base::list()
[18:02:19.560]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:19.560]     if (FALSE) {
[18:02:19.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:19.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:19.560]     }
[18:02:19.560]     ...future.result <- base::tryCatch({
[18:02:19.560]         base::withCallingHandlers({
[18:02:19.560]             ...future.value <- base::withVisible(base::local({
[18:02:19.560]                 do.call(function(...) {
[18:02:19.560]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:19.560]                   if (!identical(...future.globals.maxSize.org, 
[18:02:19.560]                     ...future.globals.maxSize)) {
[18:02:19.560]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:19.560]                     on.exit(options(oopts), add = TRUE)
[18:02:19.560]                   }
[18:02:19.560]                   {
[18:02:19.560]                     lapply(seq_along(...future.elements_ii), 
[18:02:19.560]                       FUN = function(jj) {
[18:02:19.560]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:19.560]                         ...future.FUN(...future.X_jj, ...)
[18:02:19.560]                       })
[18:02:19.560]                   }
[18:02:19.560]                 }, args = future.call.arguments)
[18:02:19.560]             }))
[18:02:19.560]             future::FutureResult(value = ...future.value$value, 
[18:02:19.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:19.560]                   ...future.rng), globalenv = if (FALSE) 
[18:02:19.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:19.560]                     ...future.globalenv.names))
[18:02:19.560]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:19.560]         }, condition = base::local({
[18:02:19.560]             c <- base::c
[18:02:19.560]             inherits <- base::inherits
[18:02:19.560]             invokeRestart <- base::invokeRestart
[18:02:19.560]             length <- base::length
[18:02:19.560]             list <- base::list
[18:02:19.560]             seq.int <- base::seq.int
[18:02:19.560]             signalCondition <- base::signalCondition
[18:02:19.560]             sys.calls <- base::sys.calls
[18:02:19.560]             `[[` <- base::`[[`
[18:02:19.560]             `+` <- base::`+`
[18:02:19.560]             `<<-` <- base::`<<-`
[18:02:19.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:19.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:19.560]                   3L)]
[18:02:19.560]             }
[18:02:19.560]             function(cond) {
[18:02:19.560]                 is_error <- inherits(cond, "error")
[18:02:19.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:19.560]                   NULL)
[18:02:19.560]                 if (is_error) {
[18:02:19.560]                   sessionInformation <- function() {
[18:02:19.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:19.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:19.560]                       search = base::search(), system = base::Sys.info())
[18:02:19.560]                   }
[18:02:19.560]                   ...future.conditions[[length(...future.conditions) + 
[18:02:19.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:19.560]                     cond$call), session = sessionInformation(), 
[18:02:19.560]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:19.560]                   signalCondition(cond)
[18:02:19.560]                 }
[18:02:19.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:19.560]                 "immediateCondition"))) {
[18:02:19.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:19.560]                   ...future.conditions[[length(...future.conditions) + 
[18:02:19.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:19.560]                   if (TRUE && !signal) {
[18:02:19.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:19.560]                     {
[18:02:19.560]                       inherits <- base::inherits
[18:02:19.560]                       invokeRestart <- base::invokeRestart
[18:02:19.560]                       is.null <- base::is.null
[18:02:19.560]                       muffled <- FALSE
[18:02:19.560]                       if (inherits(cond, "message")) {
[18:02:19.560]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:19.560]                         if (muffled) 
[18:02:19.560]                           invokeRestart("muffleMessage")
[18:02:19.560]                       }
[18:02:19.560]                       else if (inherits(cond, "warning")) {
[18:02:19.560]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:19.560]                         if (muffled) 
[18:02:19.560]                           invokeRestart("muffleWarning")
[18:02:19.560]                       }
[18:02:19.560]                       else if (inherits(cond, "condition")) {
[18:02:19.560]                         if (!is.null(pattern)) {
[18:02:19.560]                           computeRestarts <- base::computeRestarts
[18:02:19.560]                           grepl <- base::grepl
[18:02:19.560]                           restarts <- computeRestarts(cond)
[18:02:19.560]                           for (restart in restarts) {
[18:02:19.560]                             name <- restart$name
[18:02:19.560]                             if (is.null(name)) 
[18:02:19.560]                               next
[18:02:19.560]                             if (!grepl(pattern, name)) 
[18:02:19.560]                               next
[18:02:19.560]                             invokeRestart(restart)
[18:02:19.560]                             muffled <- TRUE
[18:02:19.560]                             break
[18:02:19.560]                           }
[18:02:19.560]                         }
[18:02:19.560]                       }
[18:02:19.560]                       invisible(muffled)
[18:02:19.560]                     }
[18:02:19.560]                     muffleCondition(cond, pattern = "^muffle")
[18:02:19.560]                   }
[18:02:19.560]                 }
[18:02:19.560]                 else {
[18:02:19.560]                   if (TRUE) {
[18:02:19.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:19.560]                     {
[18:02:19.560]                       inherits <- base::inherits
[18:02:19.560]                       invokeRestart <- base::invokeRestart
[18:02:19.560]                       is.null <- base::is.null
[18:02:19.560]                       muffled <- FALSE
[18:02:19.560]                       if (inherits(cond, "message")) {
[18:02:19.560]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:19.560]                         if (muffled) 
[18:02:19.560]                           invokeRestart("muffleMessage")
[18:02:19.560]                       }
[18:02:19.560]                       else if (inherits(cond, "warning")) {
[18:02:19.560]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:19.560]                         if (muffled) 
[18:02:19.560]                           invokeRestart("muffleWarning")
[18:02:19.560]                       }
[18:02:19.560]                       else if (inherits(cond, "condition")) {
[18:02:19.560]                         if (!is.null(pattern)) {
[18:02:19.560]                           computeRestarts <- base::computeRestarts
[18:02:19.560]                           grepl <- base::grepl
[18:02:19.560]                           restarts <- computeRestarts(cond)
[18:02:19.560]                           for (restart in restarts) {
[18:02:19.560]                             name <- restart$name
[18:02:19.560]                             if (is.null(name)) 
[18:02:19.560]                               next
[18:02:19.560]                             if (!grepl(pattern, name)) 
[18:02:19.560]                               next
[18:02:19.560]                             invokeRestart(restart)
[18:02:19.560]                             muffled <- TRUE
[18:02:19.560]                             break
[18:02:19.560]                           }
[18:02:19.560]                         }
[18:02:19.560]                       }
[18:02:19.560]                       invisible(muffled)
[18:02:19.560]                     }
[18:02:19.560]                     muffleCondition(cond, pattern = "^muffle")
[18:02:19.560]                   }
[18:02:19.560]                 }
[18:02:19.560]             }
[18:02:19.560]         }))
[18:02:19.560]     }, error = function(ex) {
[18:02:19.560]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:19.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:19.560]                 ...future.rng), started = ...future.startTime, 
[18:02:19.560]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:19.560]             version = "1.8"), class = "FutureResult")
[18:02:19.560]     }, finally = {
[18:02:19.560]         if (!identical(...future.workdir, getwd())) 
[18:02:19.560]             setwd(...future.workdir)
[18:02:19.560]         {
[18:02:19.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:19.560]                 ...future.oldOptions$nwarnings <- NULL
[18:02:19.560]             }
[18:02:19.560]             base::options(...future.oldOptions)
[18:02:19.560]             if (.Platform$OS.type == "windows") {
[18:02:19.560]                 old_names <- names(...future.oldEnvVars)
[18:02:19.560]                 envs <- base::Sys.getenv()
[18:02:19.560]                 names <- names(envs)
[18:02:19.560]                 common <- intersect(names, old_names)
[18:02:19.560]                 added <- setdiff(names, old_names)
[18:02:19.560]                 removed <- setdiff(old_names, names)
[18:02:19.560]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:19.560]                   envs[common]]
[18:02:19.560]                 NAMES <- toupper(changed)
[18:02:19.560]                 args <- list()
[18:02:19.560]                 for (kk in seq_along(NAMES)) {
[18:02:19.560]                   name <- changed[[kk]]
[18:02:19.560]                   NAME <- NAMES[[kk]]
[18:02:19.560]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:19.560]                     next
[18:02:19.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:19.560]                 }
[18:02:19.560]                 NAMES <- toupper(added)
[18:02:19.560]                 for (kk in seq_along(NAMES)) {
[18:02:19.560]                   name <- added[[kk]]
[18:02:19.560]                   NAME <- NAMES[[kk]]
[18:02:19.560]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:19.560]                     next
[18:02:19.560]                   args[[name]] <- ""
[18:02:19.560]                 }
[18:02:19.560]                 NAMES <- toupper(removed)
[18:02:19.560]                 for (kk in seq_along(NAMES)) {
[18:02:19.560]                   name <- removed[[kk]]
[18:02:19.560]                   NAME <- NAMES[[kk]]
[18:02:19.560]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:19.560]                     next
[18:02:19.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:19.560]                 }
[18:02:19.560]                 if (length(args) > 0) 
[18:02:19.560]                   base::do.call(base::Sys.setenv, args = args)
[18:02:19.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:19.560]             }
[18:02:19.560]             else {
[18:02:19.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:19.560]             }
[18:02:19.560]             {
[18:02:19.560]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:19.560]                   0L) {
[18:02:19.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:19.560]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:19.560]                   base::options(opts)
[18:02:19.560]                 }
[18:02:19.560]                 {
[18:02:19.560]                   {
[18:02:19.560]                     NULL
[18:02:19.560]                     RNGkind("Mersenne-Twister")
[18:02:19.560]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:19.560]                       inherits = FALSE)
[18:02:19.560]                   }
[18:02:19.560]                   options(future.plan = NULL)
[18:02:19.560]                   if (is.na(NA_character_)) 
[18:02:19.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:19.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:19.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:19.560]                     .init = FALSE)
[18:02:19.560]                 }
[18:02:19.560]             }
[18:02:19.560]         }
[18:02:19.560]     })
[18:02:19.560]     if (FALSE) {
[18:02:19.560]         base::sink(type = "output", split = FALSE)
[18:02:19.560]         if (NA) {
[18:02:19.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:19.560]         }
[18:02:19.560]         else {
[18:02:19.560]             ...future.result["stdout"] <- base::list(NULL)
[18:02:19.560]         }
[18:02:19.560]         base::close(...future.stdout)
[18:02:19.560]         ...future.stdout <- NULL
[18:02:19.560]     }
[18:02:19.560]     ...future.result$conditions <- ...future.conditions
[18:02:19.560]     ...future.result$finished <- base::Sys.time()
[18:02:19.560]     ...future.result
[18:02:19.560] }
[18:02:19.563] assign_globals() ...
[18:02:19.564] List of 5
[18:02:19.564]  $ ...future.FUN            :function (x)  
[18:02:19.564]  $ future.call.arguments    : list()
[18:02:19.564]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:19.564]  $ ...future.elements_ii    :List of 2
[18:02:19.564]   ..$ : int 1
[18:02:19.564]   ..$ : int 0
[18:02:19.564]  $ ...future.seeds_ii       : NULL
[18:02:19.564]  $ ...future.globals.maxSize: NULL
[18:02:19.564]  - attr(*, "where")=List of 5
[18:02:19.564]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:19.564]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:19.564]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:19.564]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:19.564]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:19.564]  - attr(*, "resolved")= logi FALSE
[18:02:19.564]  - attr(*, "total_size")= num 4720
[18:02:19.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:19.564]  - attr(*, "already-done")= logi TRUE
[18:02:19.576] - reassign environment for ‘...future.FUN’
[18:02:19.576] - copied ‘...future.FUN’ to environment
[18:02:19.576] - copied ‘future.call.arguments’ to environment
[18:02:19.576] - copied ‘...future.elements_ii’ to environment
[18:02:19.577] - copied ‘...future.seeds_ii’ to environment
[18:02:19.577] - copied ‘...future.globals.maxSize’ to environment
[18:02:19.577] assign_globals() ... done
[18:02:19.578] plan(): Setting new future strategy stack:
[18:02:19.578] List of future strategies:
[18:02:19.578] 1. sequential:
[18:02:19.578]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:19.578]    - tweaked: FALSE
[18:02:19.578]    - call: NULL
[18:02:19.579] plan(): nbrOfWorkers() = 1
[18:02:20.081] plan(): Setting new future strategy stack:
[18:02:20.081] List of future strategies:
[18:02:20.081] 1. sequential:
[18:02:20.081]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:20.081]    - tweaked: FALSE
[18:02:20.081]    - call: plan(strategy)
[18:02:20.082] plan(): nbrOfWorkers() = 1
[18:02:20.082] SequentialFuture started (and completed)
[18:02:20.083] - Launch lazy future ... done
[18:02:20.083] run() for ‘SequentialFuture’ ... done
[18:02:20.083] Created future:
[18:02:20.083] SequentialFuture:
[18:02:20.083] Label: ‘future_lapply-1’
[18:02:20.083] Expression:
[18:02:20.083] {
[18:02:20.083]     do.call(function(...) {
[18:02:20.083]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:20.083]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:20.083]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:20.083]             on.exit(options(oopts), add = TRUE)
[18:02:20.083]         }
[18:02:20.083]         {
[18:02:20.083]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:20.083]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:20.083]                 ...future.FUN(...future.X_jj, ...)
[18:02:20.083]             })
[18:02:20.083]         }
[18:02:20.083]     }, args = future.call.arguments)
[18:02:20.083] }
[18:02:20.083] Lazy evaluation: FALSE
[18:02:20.083] Asynchronous evaluation: FALSE
[18:02:20.083] Local evaluation: TRUE
[18:02:20.083] Environment: R_GlobalEnv
[18:02:20.083] Capture standard output: NA
[18:02:20.083] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:20.083] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:20.083] Packages: <none>
[18:02:20.083] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:20.083] Resolved: TRUE
[18:02:20.083] Value: 112 bytes of class ‘list’
[18:02:20.083] Early signaling: FALSE
[18:02:20.083] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:20.083] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:20.085] Chunk #1 of 1 ... DONE
[18:02:20.085] Launching 1 futures (chunks) ... DONE
[18:02:20.085] Resolving 1 futures (chunks) ...
[18:02:20.086] resolve() on list ...
[18:02:20.086]  recursive: 0
[18:02:20.086]  length: 1
[18:02:20.086] 
[18:02:20.086] resolved() for ‘SequentialFuture’ ...
[18:02:20.087] - state: ‘finished’
[18:02:20.087] - run: TRUE
[18:02:20.087] - result: ‘FutureResult’
[18:02:20.087] resolved() for ‘SequentialFuture’ ... done
[18:02:20.087] Future #1
[18:02:20.088] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:20.088] - nx: 1
[18:02:20.088] - relay: TRUE
[18:02:20.088] - stdout: TRUE
[18:02:20.088] - signal: TRUE
[18:02:20.089] - resignal: FALSE
[18:02:20.089] - force: TRUE
[18:02:20.089] - relayed: [n=1] FALSE
[18:02:20.089] - queued futures: [n=1] FALSE
[18:02:20.089]  - until=1
[18:02:20.090]  - relaying element #1
[18:02:20.090] - relayed: [n=1] TRUE
[18:02:20.090] - queued futures: [n=1] TRUE
[18:02:20.090] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:20.091]  length: 0 (resolved future 1)
[18:02:20.091] Relaying remaining futures
[18:02:20.091] signalConditionsASAP(NULL, pos=0) ...
[18:02:20.091] - nx: 1
[18:02:20.091] - relay: TRUE
[18:02:20.091] - stdout: TRUE
[18:02:20.092] - signal: TRUE
[18:02:20.092] - resignal: FALSE
[18:02:20.092] - force: TRUE
[18:02:20.093] - relayed: [n=1] TRUE
[18:02:20.093] - queued futures: [n=1] TRUE
 - flush all
[18:02:20.093] - relayed: [n=1] TRUE
[18:02:20.093] - queued futures: [n=1] TRUE
[18:02:20.094] signalConditionsASAP(NULL, pos=0) ... done
[18:02:20.094] resolve() on list ... DONE
[18:02:20.094]  - Number of value chunks collected: 1
[18:02:20.094] Resolving 1 futures (chunks) ... DONE
[18:02:20.094] Reducing values from 1 chunks ...
[18:02:20.095]  - Number of values collected after concatenation: 2
[18:02:20.095]  - Number of values expected: 2
[18:02:20.095] Reducing values from 1 chunks ... DONE
[18:02:20.095] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[18:02:20.096] future_mapply() ...
[18:02:20.096] Number of chunks: 1
[18:02:20.097] getGlobalsAndPackagesXApply() ...
[18:02:20.097]  - future.globals: TRUE
[18:02:20.097] getGlobalsAndPackages() ...
[18:02:20.097] Searching for globals...
[18:02:20.100] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:20.101] Searching for globals ... DONE
[18:02:20.101] Resolving globals: FALSE
[18:02:20.102] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:20.103] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:20.103] - globals: [1] ‘FUN’
[18:02:20.104] 
[18:02:20.104] getGlobalsAndPackages() ... DONE
[18:02:20.104]  - globals found/used: [n=1] ‘FUN’
[18:02:20.104]  - needed namespaces: [n=0] 
[18:02:20.104] Finding globals ... DONE
[18:02:20.105] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:20.105] List of 2
[18:02:20.105]  $ ...future.FUN:function (x, y)  
[18:02:20.105]  $ MoreArgs     : NULL
[18:02:20.105]  - attr(*, "where")=List of 2
[18:02:20.105]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:20.105]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:20.105]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:20.105]  - attr(*, "resolved")= logi FALSE
[18:02:20.105]  - attr(*, "total_size")= num NA
[18:02:20.110] Packages to be attached in all futures: [n=0] 
[18:02:20.111] getGlobalsAndPackagesXApply() ... DONE
[18:02:20.111] Number of futures (= number of chunks): 1
[18:02:20.111] Launching 1 futures (chunks) ...
[18:02:20.112] Chunk #1 of 1 ...
[18:02:20.112]  - Finding globals in '...' for chunk #1 ...
[18:02:20.112] getGlobalsAndPackages() ...
[18:02:20.112] Searching for globals...
[18:02:20.113] 
[18:02:20.113] Searching for globals ... DONE
[18:02:20.113] - globals: [0] <none>
[18:02:20.114] getGlobalsAndPackages() ... DONE
[18:02:20.114]    + additional globals found: [n=0] 
[18:02:20.114]    + additional namespaces needed: [n=0] 
[18:02:20.114]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:20.114]  - seeds: <none>
[18:02:20.115]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:20.115] getGlobalsAndPackages() ...
[18:02:20.115] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:20.115] Resolving globals: FALSE
[18:02:20.116] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[18:02:20.117] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:20.118] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:20.118] 
[18:02:20.118] getGlobalsAndPackages() ... DONE
[18:02:20.119] run() for ‘Future’ ...
[18:02:20.119] - state: ‘created’
[18:02:20.119] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:02:20.120] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:20.121] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:20.121]   - Field: ‘label’
[18:02:20.121]   - Field: ‘local’
[18:02:20.121]   - Field: ‘owner’
[18:02:20.121]   - Field: ‘envir’
[18:02:20.122]   - Field: ‘packages’
[18:02:20.122]   - Field: ‘gc’
[18:02:20.122]   - Field: ‘conditions’
[18:02:20.122]   - Field: ‘expr’
[18:02:20.122]   - Field: ‘uuid’
[18:02:20.123]   - Field: ‘seed’
[18:02:20.123]   - Field: ‘version’
[18:02:20.123]   - Field: ‘result’
[18:02:20.123]   - Field: ‘asynchronous’
[18:02:20.123]   - Field: ‘calls’
[18:02:20.124]   - Field: ‘globals’
[18:02:20.124]   - Field: ‘stdout’
[18:02:20.124]   - Field: ‘earlySignal’
[18:02:20.124]   - Field: ‘lazy’
[18:02:20.124]   - Field: ‘state’
[18:02:20.125] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:20.125] - Launch lazy future ...
[18:02:20.125] Packages needed by the future expression (n = 0): <none>
[18:02:20.125] Packages needed by future strategies (n = 0): <none>
[18:02:20.126] {
[18:02:20.126]     {
[18:02:20.126]         {
[18:02:20.126]             ...future.startTime <- base::Sys.time()
[18:02:20.126]             {
[18:02:20.126]                 {
[18:02:20.126]                   {
[18:02:20.126]                     base::local({
[18:02:20.126]                       has_future <- base::requireNamespace("future", 
[18:02:20.126]                         quietly = TRUE)
[18:02:20.126]                       if (has_future) {
[18:02:20.126]                         ns <- base::getNamespace("future")
[18:02:20.126]                         version <- ns[[".package"]][["version"]]
[18:02:20.126]                         if (is.null(version)) 
[18:02:20.126]                           version <- utils::packageVersion("future")
[18:02:20.126]                       }
[18:02:20.126]                       else {
[18:02:20.126]                         version <- NULL
[18:02:20.126]                       }
[18:02:20.126]                       if (!has_future || version < "1.8.0") {
[18:02:20.126]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:20.126]                           "", base::R.version$version.string), 
[18:02:20.126]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:20.126]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:20.126]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:20.126]                             "release", "version")], collapse = " "), 
[18:02:20.126]                           hostname = base::Sys.info()[["nodename"]])
[18:02:20.126]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:20.126]                           info)
[18:02:20.126]                         info <- base::paste(info, collapse = "; ")
[18:02:20.126]                         if (!has_future) {
[18:02:20.126]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:20.126]                             info)
[18:02:20.126]                         }
[18:02:20.126]                         else {
[18:02:20.126]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:20.126]                             info, version)
[18:02:20.126]                         }
[18:02:20.126]                         base::stop(msg)
[18:02:20.126]                       }
[18:02:20.126]                     })
[18:02:20.126]                   }
[18:02:20.126]                   ...future.strategy.old <- future::plan("list")
[18:02:20.126]                   options(future.plan = NULL)
[18:02:20.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:20.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:20.126]                 }
[18:02:20.126]                 ...future.workdir <- getwd()
[18:02:20.126]             }
[18:02:20.126]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:20.126]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:20.126]         }
[18:02:20.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:20.126]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:20.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:20.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:20.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:20.126]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:20.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:20.126]             base::names(...future.oldOptions))
[18:02:20.126]     }
[18:02:20.126]     if (FALSE) {
[18:02:20.126]     }
[18:02:20.126]     else {
[18:02:20.126]         if (FALSE) {
[18:02:20.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:20.126]                 open = "w")
[18:02:20.126]         }
[18:02:20.126]         else {
[18:02:20.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:20.126]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:20.126]         }
[18:02:20.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:20.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:20.126]             base::sink(type = "output", split = FALSE)
[18:02:20.126]             base::close(...future.stdout)
[18:02:20.126]         }, add = TRUE)
[18:02:20.126]     }
[18:02:20.126]     ...future.frame <- base::sys.nframe()
[18:02:20.126]     ...future.conditions <- base::list()
[18:02:20.126]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:20.126]     if (FALSE) {
[18:02:20.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:20.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:20.126]     }
[18:02:20.126]     ...future.result <- base::tryCatch({
[18:02:20.126]         base::withCallingHandlers({
[18:02:20.126]             ...future.value <- base::withVisible(base::local({
[18:02:20.126]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:20.126]                 if (!identical(...future.globals.maxSize.org, 
[18:02:20.126]                   ...future.globals.maxSize)) {
[18:02:20.126]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:20.126]                   on.exit(options(oopts), add = TRUE)
[18:02:20.126]                 }
[18:02:20.126]                 {
[18:02:20.126]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:20.126]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:20.126]                     USE.NAMES = FALSE)
[18:02:20.126]                   do.call(mapply, args = args)
[18:02:20.126]                 }
[18:02:20.126]             }))
[18:02:20.126]             future::FutureResult(value = ...future.value$value, 
[18:02:20.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:20.126]                   ...future.rng), globalenv = if (FALSE) 
[18:02:20.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:20.126]                     ...future.globalenv.names))
[18:02:20.126]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:20.126]         }, condition = base::local({
[18:02:20.126]             c <- base::c
[18:02:20.126]             inherits <- base::inherits
[18:02:20.126]             invokeRestart <- base::invokeRestart
[18:02:20.126]             length <- base::length
[18:02:20.126]             list <- base::list
[18:02:20.126]             seq.int <- base::seq.int
[18:02:20.126]             signalCondition <- base::signalCondition
[18:02:20.126]             sys.calls <- base::sys.calls
[18:02:20.126]             `[[` <- base::`[[`
[18:02:20.126]             `+` <- base::`+`
[18:02:20.126]             `<<-` <- base::`<<-`
[18:02:20.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:20.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:20.126]                   3L)]
[18:02:20.126]             }
[18:02:20.126]             function(cond) {
[18:02:20.126]                 is_error <- inherits(cond, "error")
[18:02:20.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:20.126]                   NULL)
[18:02:20.126]                 if (is_error) {
[18:02:20.126]                   sessionInformation <- function() {
[18:02:20.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:20.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:20.126]                       search = base::search(), system = base::Sys.info())
[18:02:20.126]                   }
[18:02:20.126]                   ...future.conditions[[length(...future.conditions) + 
[18:02:20.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:20.126]                     cond$call), session = sessionInformation(), 
[18:02:20.126]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:20.126]                   signalCondition(cond)
[18:02:20.126]                 }
[18:02:20.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:20.126]                 "immediateCondition"))) {
[18:02:20.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:20.126]                   ...future.conditions[[length(...future.conditions) + 
[18:02:20.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:20.126]                   if (TRUE && !signal) {
[18:02:20.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:20.126]                     {
[18:02:20.126]                       inherits <- base::inherits
[18:02:20.126]                       invokeRestart <- base::invokeRestart
[18:02:20.126]                       is.null <- base::is.null
[18:02:20.126]                       muffled <- FALSE
[18:02:20.126]                       if (inherits(cond, "message")) {
[18:02:20.126]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:20.126]                         if (muffled) 
[18:02:20.126]                           invokeRestart("muffleMessage")
[18:02:20.126]                       }
[18:02:20.126]                       else if (inherits(cond, "warning")) {
[18:02:20.126]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:20.126]                         if (muffled) 
[18:02:20.126]                           invokeRestart("muffleWarning")
[18:02:20.126]                       }
[18:02:20.126]                       else if (inherits(cond, "condition")) {
[18:02:20.126]                         if (!is.null(pattern)) {
[18:02:20.126]                           computeRestarts <- base::computeRestarts
[18:02:20.126]                           grepl <- base::grepl
[18:02:20.126]                           restarts <- computeRestarts(cond)
[18:02:20.126]                           for (restart in restarts) {
[18:02:20.126]                             name <- restart$name
[18:02:20.126]                             if (is.null(name)) 
[18:02:20.126]                               next
[18:02:20.126]                             if (!grepl(pattern, name)) 
[18:02:20.126]                               next
[18:02:20.126]                             invokeRestart(restart)
[18:02:20.126]                             muffled <- TRUE
[18:02:20.126]                             break
[18:02:20.126]                           }
[18:02:20.126]                         }
[18:02:20.126]                       }
[18:02:20.126]                       invisible(muffled)
[18:02:20.126]                     }
[18:02:20.126]                     muffleCondition(cond, pattern = "^muffle")
[18:02:20.126]                   }
[18:02:20.126]                 }
[18:02:20.126]                 else {
[18:02:20.126]                   if (TRUE) {
[18:02:20.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:20.126]                     {
[18:02:20.126]                       inherits <- base::inherits
[18:02:20.126]                       invokeRestart <- base::invokeRestart
[18:02:20.126]                       is.null <- base::is.null
[18:02:20.126]                       muffled <- FALSE
[18:02:20.126]                       if (inherits(cond, "message")) {
[18:02:20.126]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:20.126]                         if (muffled) 
[18:02:20.126]                           invokeRestart("muffleMessage")
[18:02:20.126]                       }
[18:02:20.126]                       else if (inherits(cond, "warning")) {
[18:02:20.126]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:20.126]                         if (muffled) 
[18:02:20.126]                           invokeRestart("muffleWarning")
[18:02:20.126]                       }
[18:02:20.126]                       else if (inherits(cond, "condition")) {
[18:02:20.126]                         if (!is.null(pattern)) {
[18:02:20.126]                           computeRestarts <- base::computeRestarts
[18:02:20.126]                           grepl <- base::grepl
[18:02:20.126]                           restarts <- computeRestarts(cond)
[18:02:20.126]                           for (restart in restarts) {
[18:02:20.126]                             name <- restart$name
[18:02:20.126]                             if (is.null(name)) 
[18:02:20.126]                               next
[18:02:20.126]                             if (!grepl(pattern, name)) 
[18:02:20.126]                               next
[18:02:20.126]                             invokeRestart(restart)
[18:02:20.126]                             muffled <- TRUE
[18:02:20.126]                             break
[18:02:20.126]                           }
[18:02:20.126]                         }
[18:02:20.126]                       }
[18:02:20.126]                       invisible(muffled)
[18:02:20.126]                     }
[18:02:20.126]                     muffleCondition(cond, pattern = "^muffle")
[18:02:20.126]                   }
[18:02:20.126]                 }
[18:02:20.126]             }
[18:02:20.126]         }))
[18:02:20.126]     }, error = function(ex) {
[18:02:20.126]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:20.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:20.126]                 ...future.rng), started = ...future.startTime, 
[18:02:20.126]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:20.126]             version = "1.8"), class = "FutureResult")
[18:02:20.126]     }, finally = {
[18:02:20.126]         if (!identical(...future.workdir, getwd())) 
[18:02:20.126]             setwd(...future.workdir)
[18:02:20.126]         {
[18:02:20.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:20.126]                 ...future.oldOptions$nwarnings <- NULL
[18:02:20.126]             }
[18:02:20.126]             base::options(...future.oldOptions)
[18:02:20.126]             if (.Platform$OS.type == "windows") {
[18:02:20.126]                 old_names <- names(...future.oldEnvVars)
[18:02:20.126]                 envs <- base::Sys.getenv()
[18:02:20.126]                 names <- names(envs)
[18:02:20.126]                 common <- intersect(names, old_names)
[18:02:20.126]                 added <- setdiff(names, old_names)
[18:02:20.126]                 removed <- setdiff(old_names, names)
[18:02:20.126]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:20.126]                   envs[common]]
[18:02:20.126]                 NAMES <- toupper(changed)
[18:02:20.126]                 args <- list()
[18:02:20.126]                 for (kk in seq_along(NAMES)) {
[18:02:20.126]                   name <- changed[[kk]]
[18:02:20.126]                   NAME <- NAMES[[kk]]
[18:02:20.126]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:20.126]                     next
[18:02:20.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:20.126]                 }
[18:02:20.126]                 NAMES <- toupper(added)
[18:02:20.126]                 for (kk in seq_along(NAMES)) {
[18:02:20.126]                   name <- added[[kk]]
[18:02:20.126]                   NAME <- NAMES[[kk]]
[18:02:20.126]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:20.126]                     next
[18:02:20.126]                   args[[name]] <- ""
[18:02:20.126]                 }
[18:02:20.126]                 NAMES <- toupper(removed)
[18:02:20.126]                 for (kk in seq_along(NAMES)) {
[18:02:20.126]                   name <- removed[[kk]]
[18:02:20.126]                   NAME <- NAMES[[kk]]
[18:02:20.126]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:20.126]                     next
[18:02:20.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:20.126]                 }
[18:02:20.126]                 if (length(args) > 0) 
[18:02:20.126]                   base::do.call(base::Sys.setenv, args = args)
[18:02:20.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:20.126]             }
[18:02:20.126]             else {
[18:02:20.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:20.126]             }
[18:02:20.126]             {
[18:02:20.126]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:20.126]                   0L) {
[18:02:20.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:20.126]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:20.126]                   base::options(opts)
[18:02:20.126]                 }
[18:02:20.126]                 {
[18:02:20.126]                   {
[18:02:20.126]                     NULL
[18:02:20.126]                     RNGkind("Mersenne-Twister")
[18:02:20.126]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:20.126]                       inherits = FALSE)
[18:02:20.126]                   }
[18:02:20.126]                   options(future.plan = NULL)
[18:02:20.126]                   if (is.na(NA_character_)) 
[18:02:20.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:20.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:20.126]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:20.126]                     .init = FALSE)
[18:02:20.126]                 }
[18:02:20.126]             }
[18:02:20.126]         }
[18:02:20.126]     })
[18:02:20.126]     if (TRUE) {
[18:02:20.126]         base::sink(type = "output", split = FALSE)
[18:02:20.126]         if (FALSE) {
[18:02:20.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:20.126]         }
[18:02:20.126]         else {
[18:02:20.126]             ...future.result["stdout"] <- base::list(NULL)
[18:02:20.126]         }
[18:02:20.126]         base::close(...future.stdout)
[18:02:20.126]         ...future.stdout <- NULL
[18:02:20.126]     }
[18:02:20.126]     ...future.result$conditions <- ...future.conditions
[18:02:20.126]     ...future.result$finished <- base::Sys.time()
[18:02:20.126]     ...future.result
[18:02:20.126] }
[18:02:20.130] assign_globals() ...
[18:02:20.130] List of 5
[18:02:20.130]  $ ...future.FUN            :function (x, y)  
[18:02:20.130]  $ MoreArgs                 : NULL
[18:02:20.130]  $ ...future.elements_ii    :List of 2
[18:02:20.130]   ..$ :List of 2
[18:02:20.130]   .. ..$ : int 1
[18:02:20.130]   .. ..$ : int 0
[18:02:20.130]   ..$ :List of 2
[18:02:20.130]   .. ..$ : int 0
[18:02:20.130]   .. ..$ : int 1
[18:02:20.130]  $ ...future.seeds_ii       : NULL
[18:02:20.130]  $ ...future.globals.maxSize: NULL
[18:02:20.130]  - attr(*, "where")=List of 5
[18:02:20.130]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:20.130]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:20.130]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:20.130]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:20.130]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:20.130]  - attr(*, "resolved")= logi FALSE
[18:02:20.130]  - attr(*, "total_size")= num 6480
[18:02:20.130]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:20.130]  - attr(*, "already-done")= logi TRUE
[18:02:20.147] - reassign environment for ‘...future.FUN’
[18:02:20.147] - copied ‘...future.FUN’ to environment
[18:02:20.147] - copied ‘MoreArgs’ to environment
[18:02:20.147] - copied ‘...future.elements_ii’ to environment
[18:02:20.148] - copied ‘...future.seeds_ii’ to environment
[18:02:20.148] - copied ‘...future.globals.maxSize’ to environment
[18:02:20.148] assign_globals() ... done
[18:02:20.149] plan(): Setting new future strategy stack:
[18:02:20.149] List of future strategies:
[18:02:20.149] 1. sequential:
[18:02:20.149]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:20.149]    - tweaked: FALSE
[18:02:20.149]    - call: NULL
[18:02:20.150] plan(): nbrOfWorkers() = 1
[18:02:20.653] plan(): Setting new future strategy stack:
[18:02:20.653] List of future strategies:
[18:02:20.653] 1. sequential:
[18:02:20.653]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:20.653]    - tweaked: FALSE
[18:02:20.653]    - call: plan(strategy)
[18:02:20.654] plan(): nbrOfWorkers() = 1
[18:02:20.654] SequentialFuture started (and completed)
[18:02:20.655] - Launch lazy future ... done
[18:02:20.655] run() for ‘SequentialFuture’ ... done
[18:02:20.655] Created future:
[18:02:20.655] SequentialFuture:
[18:02:20.655] Label: ‘future_mapply-1’
[18:02:20.655] Expression:
[18:02:20.655] {
[18:02:20.655]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:20.655]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:20.655]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:20.655]         on.exit(options(oopts), add = TRUE)
[18:02:20.655]     }
[18:02:20.655]     {
[18:02:20.655]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:20.655]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:20.655]         do.call(mapply, args = args)
[18:02:20.655]     }
[18:02:20.655] }
[18:02:20.655] Lazy evaluation: FALSE
[18:02:20.655] Asynchronous evaluation: FALSE
[18:02:20.655] Local evaluation: TRUE
[18:02:20.655] Environment: R_GlobalEnv
[18:02:20.655] Capture standard output: FALSE
[18:02:20.655] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:20.655] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:20.655] Packages: <none>
[18:02:20.655] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:20.655] Resolved: TRUE
[18:02:20.655] Value: 224 bytes of class ‘list’
[18:02:20.655] Early signaling: FALSE
[18:02:20.655] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:20.655] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:20.657] Chunk #1 of 1 ... DONE
[18:02:20.658] Launching 1 futures (chunks) ... DONE
[18:02:20.658] Resolving 1 futures (chunks) ...
[18:02:20.658] resolve() on list ...
[18:02:20.658]  recursive: 0
[18:02:20.659]  length: 1
[18:02:20.659] 
[18:02:20.659] resolved() for ‘SequentialFuture’ ...
[18:02:20.659] - state: ‘finished’
[18:02:20.660] - run: TRUE
[18:02:20.660] - result: ‘FutureResult’
[18:02:20.660] resolved() for ‘SequentialFuture’ ... done
[18:02:20.660] Future #1
[18:02:20.661] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:20.661] - nx: 1
[18:02:20.661] - relay: TRUE
[18:02:20.661] - stdout: TRUE
[18:02:20.662] - signal: TRUE
[18:02:20.662] - resignal: FALSE
[18:02:20.662] - force: TRUE
[18:02:20.662] - relayed: [n=1] FALSE
[18:02:20.663] - queued futures: [n=1] FALSE
[18:02:20.663]  - until=1
[18:02:20.663]  - relaying element #1
[18:02:20.663] - relayed: [n=1] TRUE
[18:02:20.664] - queued futures: [n=1] TRUE
[18:02:20.664] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:20.664]  length: 0 (resolved future 1)
[18:02:20.664] Relaying remaining futures
[18:02:20.665] signalConditionsASAP(NULL, pos=0) ...
[18:02:20.665] - nx: 1
[18:02:20.665] - relay: TRUE
[18:02:20.665] - stdout: TRUE
[18:02:20.665] - signal: TRUE
[18:02:20.665] - resignal: FALSE
[18:02:20.666] - force: TRUE
[18:02:20.666] - relayed: [n=1] TRUE
[18:02:20.666] - queued futures: [n=1] TRUE
 - flush all
[18:02:20.666] - relayed: [n=1] TRUE
[18:02:20.667] - queued futures: [n=1] TRUE
[18:02:20.667] signalConditionsASAP(NULL, pos=0) ... done
[18:02:20.667] resolve() on list ... DONE
[18:02:20.667]  - Number of value chunks collected: 1
[18:02:20.668] Resolving 1 futures (chunks) ... DONE
[18:02:20.668] Reducing values from 1 chunks ...
[18:02:20.668]  - Number of values collected after concatenation: 2
[18:02:20.668]  - Number of values expected: 2
[18:02:20.668] Reducing values from 1 chunks ... DONE
[18:02:20.669] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[18:02:20.670] future_mapply() ...
[18:02:20.670] Number of chunks: 1
[18:02:20.670] getGlobalsAndPackagesXApply() ...
[18:02:20.670]  - future.globals: TRUE
[18:02:20.671] getGlobalsAndPackages() ...
[18:02:20.671] Searching for globals...
[18:02:20.674] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:20.675] Searching for globals ... DONE
[18:02:20.675] Resolving globals: FALSE
[18:02:20.676] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:20.677] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:20.677] - globals: [1] ‘FUN’
[18:02:20.677] 
[18:02:20.678] getGlobalsAndPackages() ... DONE
[18:02:20.678]  - globals found/used: [n=1] ‘FUN’
[18:02:20.678]  - needed namespaces: [n=0] 
[18:02:20.678] Finding globals ... DONE
[18:02:20.679] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:20.679] List of 2
[18:02:20.679]  $ ...future.FUN:function (x, y)  
[18:02:20.679]  $ MoreArgs     : NULL
[18:02:20.679]  - attr(*, "where")=List of 2
[18:02:20.679]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:20.679]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:20.679]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:20.679]  - attr(*, "resolved")= logi FALSE
[18:02:20.679]  - attr(*, "total_size")= num NA
[18:02:20.684] Packages to be attached in all futures: [n=0] 
[18:02:20.684] getGlobalsAndPackagesXApply() ... DONE
[18:02:20.685] Number of futures (= number of chunks): 1
[18:02:20.685] Launching 1 futures (chunks) ...
[18:02:20.685] Chunk #1 of 1 ...
[18:02:20.686]  - Finding globals in '...' for chunk #1 ...
[18:02:20.686] getGlobalsAndPackages() ...
[18:02:20.686] Searching for globals...
[18:02:20.687] 
[18:02:20.687] Searching for globals ... DONE
[18:02:20.687] - globals: [0] <none>
[18:02:20.687] getGlobalsAndPackages() ... DONE
[18:02:20.687]    + additional globals found: [n=0] 
[18:02:20.688]    + additional namespaces needed: [n=0] 
[18:02:20.688]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:20.688]  - seeds: <none>
[18:02:20.688]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:20.688] getGlobalsAndPackages() ...
[18:02:20.689] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:20.689] Resolving globals: FALSE
[18:02:20.690] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[18:02:20.691] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:20.691] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:20.691] 
[18:02:20.692] getGlobalsAndPackages() ... DONE
[18:02:20.695] run() for ‘Future’ ...
[18:02:20.695] - state: ‘created’
[18:02:20.695] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:02:20.696] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:20.696] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:20.696]   - Field: ‘label’
[18:02:20.696]   - Field: ‘local’
[18:02:20.697]   - Field: ‘owner’
[18:02:20.697]   - Field: ‘envir’
[18:02:20.697]   - Field: ‘packages’
[18:02:20.697]   - Field: ‘gc’
[18:02:20.697]   - Field: ‘conditions’
[18:02:20.698]   - Field: ‘expr’
[18:02:20.698]   - Field: ‘uuid’
[18:02:20.698]   - Field: ‘seed’
[18:02:20.698]   - Field: ‘version’
[18:02:20.698]   - Field: ‘result’
[18:02:20.699]   - Field: ‘asynchronous’
[18:02:20.699]   - Field: ‘calls’
[18:02:20.699]   - Field: ‘globals’
[18:02:20.699]   - Field: ‘stdout’
[18:02:20.699]   - Field: ‘earlySignal’
[18:02:20.700]   - Field: ‘lazy’
[18:02:20.700]   - Field: ‘state’
[18:02:20.700] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:20.700] - Launch lazy future ...
[18:02:20.701] Packages needed by the future expression (n = 0): <none>
[18:02:20.701] Packages needed by future strategies (n = 0): <none>
[18:02:20.702] {
[18:02:20.702]     {
[18:02:20.702]         {
[18:02:20.702]             ...future.startTime <- base::Sys.time()
[18:02:20.702]             {
[18:02:20.702]                 {
[18:02:20.702]                   {
[18:02:20.702]                     base::local({
[18:02:20.702]                       has_future <- base::requireNamespace("future", 
[18:02:20.702]                         quietly = TRUE)
[18:02:20.702]                       if (has_future) {
[18:02:20.702]                         ns <- base::getNamespace("future")
[18:02:20.702]                         version <- ns[[".package"]][["version"]]
[18:02:20.702]                         if (is.null(version)) 
[18:02:20.702]                           version <- utils::packageVersion("future")
[18:02:20.702]                       }
[18:02:20.702]                       else {
[18:02:20.702]                         version <- NULL
[18:02:20.702]                       }
[18:02:20.702]                       if (!has_future || version < "1.8.0") {
[18:02:20.702]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:20.702]                           "", base::R.version$version.string), 
[18:02:20.702]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:20.702]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:20.702]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:20.702]                             "release", "version")], collapse = " "), 
[18:02:20.702]                           hostname = base::Sys.info()[["nodename"]])
[18:02:20.702]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:20.702]                           info)
[18:02:20.702]                         info <- base::paste(info, collapse = "; ")
[18:02:20.702]                         if (!has_future) {
[18:02:20.702]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:20.702]                             info)
[18:02:20.702]                         }
[18:02:20.702]                         else {
[18:02:20.702]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:20.702]                             info, version)
[18:02:20.702]                         }
[18:02:20.702]                         base::stop(msg)
[18:02:20.702]                       }
[18:02:20.702]                     })
[18:02:20.702]                   }
[18:02:20.702]                   ...future.strategy.old <- future::plan("list")
[18:02:20.702]                   options(future.plan = NULL)
[18:02:20.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:20.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:20.702]                 }
[18:02:20.702]                 ...future.workdir <- getwd()
[18:02:20.702]             }
[18:02:20.702]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:20.702]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:20.702]         }
[18:02:20.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:20.702]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:20.702]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:20.702]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:20.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:20.702]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:20.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:20.702]             base::names(...future.oldOptions))
[18:02:20.702]     }
[18:02:20.702]     if (FALSE) {
[18:02:20.702]     }
[18:02:20.702]     else {
[18:02:20.702]         if (TRUE) {
[18:02:20.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:20.702]                 open = "w")
[18:02:20.702]         }
[18:02:20.702]         else {
[18:02:20.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:20.702]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:20.702]         }
[18:02:20.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:20.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:20.702]             base::sink(type = "output", split = FALSE)
[18:02:20.702]             base::close(...future.stdout)
[18:02:20.702]         }, add = TRUE)
[18:02:20.702]     }
[18:02:20.702]     ...future.frame <- base::sys.nframe()
[18:02:20.702]     ...future.conditions <- base::list()
[18:02:20.702]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:20.702]     if (FALSE) {
[18:02:20.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:20.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:20.702]     }
[18:02:20.702]     ...future.result <- base::tryCatch({
[18:02:20.702]         base::withCallingHandlers({
[18:02:20.702]             ...future.value <- base::withVisible(base::local({
[18:02:20.702]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:20.702]                 if (!identical(...future.globals.maxSize.org, 
[18:02:20.702]                   ...future.globals.maxSize)) {
[18:02:20.702]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:20.702]                   on.exit(options(oopts), add = TRUE)
[18:02:20.702]                 }
[18:02:20.702]                 {
[18:02:20.702]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:20.702]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:20.702]                     USE.NAMES = FALSE)
[18:02:20.702]                   do.call(mapply, args = args)
[18:02:20.702]                 }
[18:02:20.702]             }))
[18:02:20.702]             future::FutureResult(value = ...future.value$value, 
[18:02:20.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:20.702]                   ...future.rng), globalenv = if (FALSE) 
[18:02:20.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:20.702]                     ...future.globalenv.names))
[18:02:20.702]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:20.702]         }, condition = base::local({
[18:02:20.702]             c <- base::c
[18:02:20.702]             inherits <- base::inherits
[18:02:20.702]             invokeRestart <- base::invokeRestart
[18:02:20.702]             length <- base::length
[18:02:20.702]             list <- base::list
[18:02:20.702]             seq.int <- base::seq.int
[18:02:20.702]             signalCondition <- base::signalCondition
[18:02:20.702]             sys.calls <- base::sys.calls
[18:02:20.702]             `[[` <- base::`[[`
[18:02:20.702]             `+` <- base::`+`
[18:02:20.702]             `<<-` <- base::`<<-`
[18:02:20.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:20.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:20.702]                   3L)]
[18:02:20.702]             }
[18:02:20.702]             function(cond) {
[18:02:20.702]                 is_error <- inherits(cond, "error")
[18:02:20.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:20.702]                   NULL)
[18:02:20.702]                 if (is_error) {
[18:02:20.702]                   sessionInformation <- function() {
[18:02:20.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:20.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:20.702]                       search = base::search(), system = base::Sys.info())
[18:02:20.702]                   }
[18:02:20.702]                   ...future.conditions[[length(...future.conditions) + 
[18:02:20.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:20.702]                     cond$call), session = sessionInformation(), 
[18:02:20.702]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:20.702]                   signalCondition(cond)
[18:02:20.702]                 }
[18:02:20.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:20.702]                 "immediateCondition"))) {
[18:02:20.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:20.702]                   ...future.conditions[[length(...future.conditions) + 
[18:02:20.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:20.702]                   if (TRUE && !signal) {
[18:02:20.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:20.702]                     {
[18:02:20.702]                       inherits <- base::inherits
[18:02:20.702]                       invokeRestart <- base::invokeRestart
[18:02:20.702]                       is.null <- base::is.null
[18:02:20.702]                       muffled <- FALSE
[18:02:20.702]                       if (inherits(cond, "message")) {
[18:02:20.702]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:20.702]                         if (muffled) 
[18:02:20.702]                           invokeRestart("muffleMessage")
[18:02:20.702]                       }
[18:02:20.702]                       else if (inherits(cond, "warning")) {
[18:02:20.702]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:20.702]                         if (muffled) 
[18:02:20.702]                           invokeRestart("muffleWarning")
[18:02:20.702]                       }
[18:02:20.702]                       else if (inherits(cond, "condition")) {
[18:02:20.702]                         if (!is.null(pattern)) {
[18:02:20.702]                           computeRestarts <- base::computeRestarts
[18:02:20.702]                           grepl <- base::grepl
[18:02:20.702]                           restarts <- computeRestarts(cond)
[18:02:20.702]                           for (restart in restarts) {
[18:02:20.702]                             name <- restart$name
[18:02:20.702]                             if (is.null(name)) 
[18:02:20.702]                               next
[18:02:20.702]                             if (!grepl(pattern, name)) 
[18:02:20.702]                               next
[18:02:20.702]                             invokeRestart(restart)
[18:02:20.702]                             muffled <- TRUE
[18:02:20.702]                             break
[18:02:20.702]                           }
[18:02:20.702]                         }
[18:02:20.702]                       }
[18:02:20.702]                       invisible(muffled)
[18:02:20.702]                     }
[18:02:20.702]                     muffleCondition(cond, pattern = "^muffle")
[18:02:20.702]                   }
[18:02:20.702]                 }
[18:02:20.702]                 else {
[18:02:20.702]                   if (TRUE) {
[18:02:20.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:20.702]                     {
[18:02:20.702]                       inherits <- base::inherits
[18:02:20.702]                       invokeRestart <- base::invokeRestart
[18:02:20.702]                       is.null <- base::is.null
[18:02:20.702]                       muffled <- FALSE
[18:02:20.702]                       if (inherits(cond, "message")) {
[18:02:20.702]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:20.702]                         if (muffled) 
[18:02:20.702]                           invokeRestart("muffleMessage")
[18:02:20.702]                       }
[18:02:20.702]                       else if (inherits(cond, "warning")) {
[18:02:20.702]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:20.702]                         if (muffled) 
[18:02:20.702]                           invokeRestart("muffleWarning")
[18:02:20.702]                       }
[18:02:20.702]                       else if (inherits(cond, "condition")) {
[18:02:20.702]                         if (!is.null(pattern)) {
[18:02:20.702]                           computeRestarts <- base::computeRestarts
[18:02:20.702]                           grepl <- base::grepl
[18:02:20.702]                           restarts <- computeRestarts(cond)
[18:02:20.702]                           for (restart in restarts) {
[18:02:20.702]                             name <- restart$name
[18:02:20.702]                             if (is.null(name)) 
[18:02:20.702]                               next
[18:02:20.702]                             if (!grepl(pattern, name)) 
[18:02:20.702]                               next
[18:02:20.702]                             invokeRestart(restart)
[18:02:20.702]                             muffled <- TRUE
[18:02:20.702]                             break
[18:02:20.702]                           }
[18:02:20.702]                         }
[18:02:20.702]                       }
[18:02:20.702]                       invisible(muffled)
[18:02:20.702]                     }
[18:02:20.702]                     muffleCondition(cond, pattern = "^muffle")
[18:02:20.702]                   }
[18:02:20.702]                 }
[18:02:20.702]             }
[18:02:20.702]         }))
[18:02:20.702]     }, error = function(ex) {
[18:02:20.702]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:20.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:20.702]                 ...future.rng), started = ...future.startTime, 
[18:02:20.702]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:20.702]             version = "1.8"), class = "FutureResult")
[18:02:20.702]     }, finally = {
[18:02:20.702]         if (!identical(...future.workdir, getwd())) 
[18:02:20.702]             setwd(...future.workdir)
[18:02:20.702]         {
[18:02:20.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:20.702]                 ...future.oldOptions$nwarnings <- NULL
[18:02:20.702]             }
[18:02:20.702]             base::options(...future.oldOptions)
[18:02:20.702]             if (.Platform$OS.type == "windows") {
[18:02:20.702]                 old_names <- names(...future.oldEnvVars)
[18:02:20.702]                 envs <- base::Sys.getenv()
[18:02:20.702]                 names <- names(envs)
[18:02:20.702]                 common <- intersect(names, old_names)
[18:02:20.702]                 added <- setdiff(names, old_names)
[18:02:20.702]                 removed <- setdiff(old_names, names)
[18:02:20.702]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:20.702]                   envs[common]]
[18:02:20.702]                 NAMES <- toupper(changed)
[18:02:20.702]                 args <- list()
[18:02:20.702]                 for (kk in seq_along(NAMES)) {
[18:02:20.702]                   name <- changed[[kk]]
[18:02:20.702]                   NAME <- NAMES[[kk]]
[18:02:20.702]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:20.702]                     next
[18:02:20.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:20.702]                 }
[18:02:20.702]                 NAMES <- toupper(added)
[18:02:20.702]                 for (kk in seq_along(NAMES)) {
[18:02:20.702]                   name <- added[[kk]]
[18:02:20.702]                   NAME <- NAMES[[kk]]
[18:02:20.702]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:20.702]                     next
[18:02:20.702]                   args[[name]] <- ""
[18:02:20.702]                 }
[18:02:20.702]                 NAMES <- toupper(removed)
[18:02:20.702]                 for (kk in seq_along(NAMES)) {
[18:02:20.702]                   name <- removed[[kk]]
[18:02:20.702]                   NAME <- NAMES[[kk]]
[18:02:20.702]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:20.702]                     next
[18:02:20.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:20.702]                 }
[18:02:20.702]                 if (length(args) > 0) 
[18:02:20.702]                   base::do.call(base::Sys.setenv, args = args)
[18:02:20.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:20.702]             }
[18:02:20.702]             else {
[18:02:20.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:20.702]             }
[18:02:20.702]             {
[18:02:20.702]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:20.702]                   0L) {
[18:02:20.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:20.702]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:20.702]                   base::options(opts)
[18:02:20.702]                 }
[18:02:20.702]                 {
[18:02:20.702]                   {
[18:02:20.702]                     NULL
[18:02:20.702]                     RNGkind("Mersenne-Twister")
[18:02:20.702]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:20.702]                       inherits = FALSE)
[18:02:20.702]                   }
[18:02:20.702]                   options(future.plan = NULL)
[18:02:20.702]                   if (is.na(NA_character_)) 
[18:02:20.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:20.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:20.702]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:20.702]                     .init = FALSE)
[18:02:20.702]                 }
[18:02:20.702]             }
[18:02:20.702]         }
[18:02:20.702]     })
[18:02:20.702]     if (TRUE) {
[18:02:20.702]         base::sink(type = "output", split = FALSE)
[18:02:20.702]         if (TRUE) {
[18:02:20.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:20.702]         }
[18:02:20.702]         else {
[18:02:20.702]             ...future.result["stdout"] <- base::list(NULL)
[18:02:20.702]         }
[18:02:20.702]         base::close(...future.stdout)
[18:02:20.702]         ...future.stdout <- NULL
[18:02:20.702]     }
[18:02:20.702]     ...future.result$conditions <- ...future.conditions
[18:02:20.702]     ...future.result$finished <- base::Sys.time()
[18:02:20.702]     ...future.result
[18:02:20.702] }
[18:02:20.705] assign_globals() ...
[18:02:20.705] List of 5
[18:02:20.705]  $ ...future.FUN            :function (x, y)  
[18:02:20.705]  $ MoreArgs                 : NULL
[18:02:20.705]  $ ...future.elements_ii    :List of 2
[18:02:20.705]   ..$ :List of 2
[18:02:20.705]   .. ..$ : int 1
[18:02:20.705]   .. ..$ : int 0
[18:02:20.705]   ..$ :List of 2
[18:02:20.705]   .. ..$ : int 0
[18:02:20.705]   .. ..$ : int 1
[18:02:20.705]  $ ...future.seeds_ii       : NULL
[18:02:20.705]  $ ...future.globals.maxSize: NULL
[18:02:20.705]  - attr(*, "where")=List of 5
[18:02:20.705]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:20.705]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:20.705]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:20.705]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:20.705]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:20.705]  - attr(*, "resolved")= logi FALSE
[18:02:20.705]  - attr(*, "total_size")= num 6480
[18:02:20.705]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:20.705]  - attr(*, "already-done")= logi TRUE
[18:02:20.718] - reassign environment for ‘...future.FUN’
[18:02:20.718] - copied ‘...future.FUN’ to environment
[18:02:20.718] - copied ‘MoreArgs’ to environment
[18:02:20.719] - copied ‘...future.elements_ii’ to environment
[18:02:20.719] - copied ‘...future.seeds_ii’ to environment
[18:02:20.719] - copied ‘...future.globals.maxSize’ to environment
[18:02:20.719] assign_globals() ... done
[18:02:20.720] plan(): Setting new future strategy stack:
[18:02:20.720] List of future strategies:
[18:02:20.720] 1. sequential:
[18:02:20.720]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:20.720]    - tweaked: FALSE
[18:02:20.720]    - call: NULL
[18:02:20.721] plan(): nbrOfWorkers() = 1
[18:02:21.223] plan(): Setting new future strategy stack:
[18:02:21.224] List of future strategies:
[18:02:21.224] 1. sequential:
[18:02:21.224]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:21.224]    - tweaked: FALSE
[18:02:21.224]    - call: plan(strategy)
[18:02:21.225] plan(): nbrOfWorkers() = 1
[18:02:21.226] SequentialFuture started (and completed)
[18:02:21.226] - Launch lazy future ... done
[18:02:21.226] run() for ‘SequentialFuture’ ... done
[18:02:21.226] Created future:
[18:02:21.227] SequentialFuture:
[18:02:21.227] Label: ‘future_mapply-1’
[18:02:21.227] Expression:
[18:02:21.227] {
[18:02:21.227]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:21.227]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:21.227]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:21.227]         on.exit(options(oopts), add = TRUE)
[18:02:21.227]     }
[18:02:21.227]     {
[18:02:21.227]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:21.227]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:21.227]         do.call(mapply, args = args)
[18:02:21.227]     }
[18:02:21.227] }
[18:02:21.227] Lazy evaluation: FALSE
[18:02:21.227] Asynchronous evaluation: FALSE
[18:02:21.227] Local evaluation: TRUE
[18:02:21.227] Environment: R_GlobalEnv
[18:02:21.227] Capture standard output: TRUE
[18:02:21.227] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:21.227] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:21.227] Packages: <none>
[18:02:21.227] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:21.227] Resolved: TRUE
[18:02:21.227] Value: 224 bytes of class ‘list’
[18:02:21.227] Early signaling: FALSE
[18:02:21.227] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:21.227] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:21.229] Chunk #1 of 1 ... DONE
[18:02:21.229] Launching 1 futures (chunks) ... DONE
[18:02:21.229] Resolving 1 futures (chunks) ...
[18:02:21.230] resolve() on list ...
[18:02:21.230]  recursive: 0
[18:02:21.230]  length: 1
[18:02:21.230] 
[18:02:21.231] resolved() for ‘SequentialFuture’ ...
[18:02:21.231] - state: ‘finished’
[18:02:21.231] - run: TRUE
[18:02:21.231] - result: ‘FutureResult’
[18:02:21.231] resolved() for ‘SequentialFuture’ ... done
[18:02:21.232] Future #1
[18:02:21.232] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:21.232] - nx: 1
[18:02:21.232] - relay: TRUE
[18:02:21.233] - stdout: TRUE
[18:02:21.233] - signal: TRUE
[18:02:21.233] - resignal: FALSE
[18:02:21.233] - force: TRUE
[18:02:21.233] - relayed: [n=1] FALSE
[18:02:21.234] - queued futures: [n=1] FALSE
[18:02:21.234]  - until=1
[18:02:21.234]  - relaying element #1
[18:02:21.234] - relayed: [n=1] TRUE
[18:02:21.235] - queued futures: [n=1] TRUE
[18:02:21.235] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:21.235]  length: 0 (resolved future 1)
[18:02:21.235] Relaying remaining futures
[18:02:21.236] signalConditionsASAP(NULL, pos=0) ...
[18:02:21.236] - nx: 1
[18:02:21.236] - relay: TRUE
[18:02:21.236] - stdout: TRUE
[18:02:21.236] - signal: TRUE
[18:02:21.236] - resignal: FALSE
[18:02:21.237] - force: TRUE
[18:02:21.237] - relayed: [n=1] TRUE
[18:02:21.237] - queued futures: [n=1] TRUE
 - flush all
[18:02:21.237] - relayed: [n=1] TRUE
[18:02:21.238] - queued futures: [n=1] TRUE
[18:02:21.238] signalConditionsASAP(NULL, pos=0) ... done
[18:02:21.238] resolve() on list ... DONE
[18:02:21.238]  - Number of value chunks collected: 1
[18:02:21.239] Resolving 1 futures (chunks) ... DONE
[18:02:21.239] Reducing values from 1 chunks ...
[18:02:21.239]  - Number of values collected after concatenation: 2
[18:02:21.239]  - Number of values expected: 2
[18:02:21.239] Reducing values from 1 chunks ... DONE
[18:02:21.240] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[18:02:21.240] future_mapply() ...
[18:02:21.241] Number of chunks: 1
[18:02:21.241] getGlobalsAndPackagesXApply() ...
[18:02:21.241]  - future.globals: TRUE
[18:02:21.242] getGlobalsAndPackages() ...
[18:02:21.242] Searching for globals...
[18:02:21.245] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:21.246] Searching for globals ... DONE
[18:02:21.246] Resolving globals: FALSE
[18:02:21.247] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:21.248] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:21.248] - globals: [1] ‘FUN’
[18:02:21.248] 
[18:02:21.249] getGlobalsAndPackages() ... DONE
[18:02:21.249]  - globals found/used: [n=1] ‘FUN’
[18:02:21.249]  - needed namespaces: [n=0] 
[18:02:21.249] Finding globals ... DONE
[18:02:21.250] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:21.250] List of 2
[18:02:21.250]  $ ...future.FUN:function (x, y)  
[18:02:21.250]  $ MoreArgs     : NULL
[18:02:21.250]  - attr(*, "where")=List of 2
[18:02:21.250]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:21.250]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:21.250]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:21.250]  - attr(*, "resolved")= logi FALSE
[18:02:21.250]  - attr(*, "total_size")= num NA
[18:02:21.258] Packages to be attached in all futures: [n=0] 
[18:02:21.259] getGlobalsAndPackagesXApply() ... DONE
[18:02:21.259] Number of futures (= number of chunks): 1
[18:02:21.259] Launching 1 futures (chunks) ...
[18:02:21.259] Chunk #1 of 1 ...
[18:02:21.260]  - Finding globals in '...' for chunk #1 ...
[18:02:21.260] getGlobalsAndPackages() ...
[18:02:21.260] Searching for globals...
[18:02:21.261] 
[18:02:21.261] Searching for globals ... DONE
[18:02:21.261] - globals: [0] <none>
[18:02:21.262] getGlobalsAndPackages() ... DONE
[18:02:21.262]    + additional globals found: [n=0] 
[18:02:21.262]    + additional namespaces needed: [n=0] 
[18:02:21.262]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:21.262]  - seeds: <none>
[18:02:21.263]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:21.263] getGlobalsAndPackages() ...
[18:02:21.263] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:21.263] Resolving globals: FALSE
[18:02:21.264] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[18:02:21.265] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:21.266] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:21.266] 
[18:02:21.266] getGlobalsAndPackages() ... DONE
[18:02:21.267] run() for ‘Future’ ...
[18:02:21.267] - state: ‘created’
[18:02:21.267] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[18:02:21.268] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:21.268] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:21.268]   - Field: ‘label’
[18:02:21.269]   - Field: ‘local’
[18:02:21.269]   - Field: ‘owner’
[18:02:21.269]   - Field: ‘envir’
[18:02:21.269]   - Field: ‘packages’
[18:02:21.269]   - Field: ‘gc’
[18:02:21.270]   - Field: ‘conditions’
[18:02:21.270]   - Field: ‘expr’
[18:02:21.270]   - Field: ‘uuid’
[18:02:21.270]   - Field: ‘seed’
[18:02:21.270]   - Field: ‘version’
[18:02:21.271]   - Field: ‘result’
[18:02:21.271]   - Field: ‘asynchronous’
[18:02:21.271]   - Field: ‘calls’
[18:02:21.271]   - Field: ‘globals’
[18:02:21.271]   - Field: ‘stdout’
[18:02:21.272]   - Field: ‘earlySignal’
[18:02:21.272]   - Field: ‘lazy’
[18:02:21.272]   - Field: ‘state’
[18:02:21.272] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:21.272] - Launch lazy future ...
[18:02:21.273] Packages needed by the future expression (n = 0): <none>
[18:02:21.273] Packages needed by future strategies (n = 0): <none>
[18:02:21.274] {
[18:02:21.274]     {
[18:02:21.274]         {
[18:02:21.274]             ...future.startTime <- base::Sys.time()
[18:02:21.274]             {
[18:02:21.274]                 {
[18:02:21.274]                   {
[18:02:21.274]                     base::local({
[18:02:21.274]                       has_future <- base::requireNamespace("future", 
[18:02:21.274]                         quietly = TRUE)
[18:02:21.274]                       if (has_future) {
[18:02:21.274]                         ns <- base::getNamespace("future")
[18:02:21.274]                         version <- ns[[".package"]][["version"]]
[18:02:21.274]                         if (is.null(version)) 
[18:02:21.274]                           version <- utils::packageVersion("future")
[18:02:21.274]                       }
[18:02:21.274]                       else {
[18:02:21.274]                         version <- NULL
[18:02:21.274]                       }
[18:02:21.274]                       if (!has_future || version < "1.8.0") {
[18:02:21.274]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:21.274]                           "", base::R.version$version.string), 
[18:02:21.274]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:21.274]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:21.274]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:21.274]                             "release", "version")], collapse = " "), 
[18:02:21.274]                           hostname = base::Sys.info()[["nodename"]])
[18:02:21.274]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:21.274]                           info)
[18:02:21.274]                         info <- base::paste(info, collapse = "; ")
[18:02:21.274]                         if (!has_future) {
[18:02:21.274]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:21.274]                             info)
[18:02:21.274]                         }
[18:02:21.274]                         else {
[18:02:21.274]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:21.274]                             info, version)
[18:02:21.274]                         }
[18:02:21.274]                         base::stop(msg)
[18:02:21.274]                       }
[18:02:21.274]                     })
[18:02:21.274]                   }
[18:02:21.274]                   ...future.strategy.old <- future::plan("list")
[18:02:21.274]                   options(future.plan = NULL)
[18:02:21.274]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:21.274]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:21.274]                 }
[18:02:21.274]                 ...future.workdir <- getwd()
[18:02:21.274]             }
[18:02:21.274]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:21.274]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:21.274]         }
[18:02:21.274]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:21.274]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:21.274]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:21.274]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:21.274]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:21.274]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:21.274]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:21.274]             base::names(...future.oldOptions))
[18:02:21.274]     }
[18:02:21.274]     if (TRUE) {
[18:02:21.274]     }
[18:02:21.274]     else {
[18:02:21.274]         if (NA) {
[18:02:21.274]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:21.274]                 open = "w")
[18:02:21.274]         }
[18:02:21.274]         else {
[18:02:21.274]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:21.274]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:21.274]         }
[18:02:21.274]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:21.274]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:21.274]             base::sink(type = "output", split = FALSE)
[18:02:21.274]             base::close(...future.stdout)
[18:02:21.274]         }, add = TRUE)
[18:02:21.274]     }
[18:02:21.274]     ...future.frame <- base::sys.nframe()
[18:02:21.274]     ...future.conditions <- base::list()
[18:02:21.274]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:21.274]     if (FALSE) {
[18:02:21.274]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:21.274]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:21.274]     }
[18:02:21.274]     ...future.result <- base::tryCatch({
[18:02:21.274]         base::withCallingHandlers({
[18:02:21.274]             ...future.value <- base::withVisible(base::local({
[18:02:21.274]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:21.274]                 if (!identical(...future.globals.maxSize.org, 
[18:02:21.274]                   ...future.globals.maxSize)) {
[18:02:21.274]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:21.274]                   on.exit(options(oopts), add = TRUE)
[18:02:21.274]                 }
[18:02:21.274]                 {
[18:02:21.274]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:21.274]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:21.274]                     USE.NAMES = FALSE)
[18:02:21.274]                   do.call(mapply, args = args)
[18:02:21.274]                 }
[18:02:21.274]             }))
[18:02:21.274]             future::FutureResult(value = ...future.value$value, 
[18:02:21.274]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:21.274]                   ...future.rng), globalenv = if (FALSE) 
[18:02:21.274]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:21.274]                     ...future.globalenv.names))
[18:02:21.274]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:21.274]         }, condition = base::local({
[18:02:21.274]             c <- base::c
[18:02:21.274]             inherits <- base::inherits
[18:02:21.274]             invokeRestart <- base::invokeRestart
[18:02:21.274]             length <- base::length
[18:02:21.274]             list <- base::list
[18:02:21.274]             seq.int <- base::seq.int
[18:02:21.274]             signalCondition <- base::signalCondition
[18:02:21.274]             sys.calls <- base::sys.calls
[18:02:21.274]             `[[` <- base::`[[`
[18:02:21.274]             `+` <- base::`+`
[18:02:21.274]             `<<-` <- base::`<<-`
[18:02:21.274]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:21.274]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:21.274]                   3L)]
[18:02:21.274]             }
[18:02:21.274]             function(cond) {
[18:02:21.274]                 is_error <- inherits(cond, "error")
[18:02:21.274]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:21.274]                   NULL)
[18:02:21.274]                 if (is_error) {
[18:02:21.274]                   sessionInformation <- function() {
[18:02:21.274]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:21.274]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:21.274]                       search = base::search(), system = base::Sys.info())
[18:02:21.274]                   }
[18:02:21.274]                   ...future.conditions[[length(...future.conditions) + 
[18:02:21.274]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:21.274]                     cond$call), session = sessionInformation(), 
[18:02:21.274]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:21.274]                   signalCondition(cond)
[18:02:21.274]                 }
[18:02:21.274]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:21.274]                 "immediateCondition"))) {
[18:02:21.274]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:21.274]                   ...future.conditions[[length(...future.conditions) + 
[18:02:21.274]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:21.274]                   if (TRUE && !signal) {
[18:02:21.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:21.274]                     {
[18:02:21.274]                       inherits <- base::inherits
[18:02:21.274]                       invokeRestart <- base::invokeRestart
[18:02:21.274]                       is.null <- base::is.null
[18:02:21.274]                       muffled <- FALSE
[18:02:21.274]                       if (inherits(cond, "message")) {
[18:02:21.274]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:21.274]                         if (muffled) 
[18:02:21.274]                           invokeRestart("muffleMessage")
[18:02:21.274]                       }
[18:02:21.274]                       else if (inherits(cond, "warning")) {
[18:02:21.274]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:21.274]                         if (muffled) 
[18:02:21.274]                           invokeRestart("muffleWarning")
[18:02:21.274]                       }
[18:02:21.274]                       else if (inherits(cond, "condition")) {
[18:02:21.274]                         if (!is.null(pattern)) {
[18:02:21.274]                           computeRestarts <- base::computeRestarts
[18:02:21.274]                           grepl <- base::grepl
[18:02:21.274]                           restarts <- computeRestarts(cond)
[18:02:21.274]                           for (restart in restarts) {
[18:02:21.274]                             name <- restart$name
[18:02:21.274]                             if (is.null(name)) 
[18:02:21.274]                               next
[18:02:21.274]                             if (!grepl(pattern, name)) 
[18:02:21.274]                               next
[18:02:21.274]                             invokeRestart(restart)
[18:02:21.274]                             muffled <- TRUE
[18:02:21.274]                             break
[18:02:21.274]                           }
[18:02:21.274]                         }
[18:02:21.274]                       }
[18:02:21.274]                       invisible(muffled)
[18:02:21.274]                     }
[18:02:21.274]                     muffleCondition(cond, pattern = "^muffle")
[18:02:21.274]                   }
[18:02:21.274]                 }
[18:02:21.274]                 else {
[18:02:21.274]                   if (TRUE) {
[18:02:21.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:21.274]                     {
[18:02:21.274]                       inherits <- base::inherits
[18:02:21.274]                       invokeRestart <- base::invokeRestart
[18:02:21.274]                       is.null <- base::is.null
[18:02:21.274]                       muffled <- FALSE
[18:02:21.274]                       if (inherits(cond, "message")) {
[18:02:21.274]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:21.274]                         if (muffled) 
[18:02:21.274]                           invokeRestart("muffleMessage")
[18:02:21.274]                       }
[18:02:21.274]                       else if (inherits(cond, "warning")) {
[18:02:21.274]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:21.274]                         if (muffled) 
[18:02:21.274]                           invokeRestart("muffleWarning")
[18:02:21.274]                       }
[18:02:21.274]                       else if (inherits(cond, "condition")) {
[18:02:21.274]                         if (!is.null(pattern)) {
[18:02:21.274]                           computeRestarts <- base::computeRestarts
[18:02:21.274]                           grepl <- base::grepl
[18:02:21.274]                           restarts <- computeRestarts(cond)
[18:02:21.274]                           for (restart in restarts) {
[18:02:21.274]                             name <- restart$name
[18:02:21.274]                             if (is.null(name)) 
[18:02:21.274]                               next
[18:02:21.274]                             if (!grepl(pattern, name)) 
[18:02:21.274]                               next
[18:02:21.274]                             invokeRestart(restart)
[18:02:21.274]                             muffled <- TRUE
[18:02:21.274]                             break
[18:02:21.274]                           }
[18:02:21.274]                         }
[18:02:21.274]                       }
[18:02:21.274]                       invisible(muffled)
[18:02:21.274]                     }
[18:02:21.274]                     muffleCondition(cond, pattern = "^muffle")
[18:02:21.274]                   }
[18:02:21.274]                 }
[18:02:21.274]             }
[18:02:21.274]         }))
[18:02:21.274]     }, error = function(ex) {
[18:02:21.274]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:21.274]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:21.274]                 ...future.rng), started = ...future.startTime, 
[18:02:21.274]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:21.274]             version = "1.8"), class = "FutureResult")
[18:02:21.274]     }, finally = {
[18:02:21.274]         if (!identical(...future.workdir, getwd())) 
[18:02:21.274]             setwd(...future.workdir)
[18:02:21.274]         {
[18:02:21.274]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:21.274]                 ...future.oldOptions$nwarnings <- NULL
[18:02:21.274]             }
[18:02:21.274]             base::options(...future.oldOptions)
[18:02:21.274]             if (.Platform$OS.type == "windows") {
[18:02:21.274]                 old_names <- names(...future.oldEnvVars)
[18:02:21.274]                 envs <- base::Sys.getenv()
[18:02:21.274]                 names <- names(envs)
[18:02:21.274]                 common <- intersect(names, old_names)
[18:02:21.274]                 added <- setdiff(names, old_names)
[18:02:21.274]                 removed <- setdiff(old_names, names)
[18:02:21.274]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:21.274]                   envs[common]]
[18:02:21.274]                 NAMES <- toupper(changed)
[18:02:21.274]                 args <- list()
[18:02:21.274]                 for (kk in seq_along(NAMES)) {
[18:02:21.274]                   name <- changed[[kk]]
[18:02:21.274]                   NAME <- NAMES[[kk]]
[18:02:21.274]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:21.274]                     next
[18:02:21.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:21.274]                 }
[18:02:21.274]                 NAMES <- toupper(added)
[18:02:21.274]                 for (kk in seq_along(NAMES)) {
[18:02:21.274]                   name <- added[[kk]]
[18:02:21.274]                   NAME <- NAMES[[kk]]
[18:02:21.274]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:21.274]                     next
[18:02:21.274]                   args[[name]] <- ""
[18:02:21.274]                 }
[18:02:21.274]                 NAMES <- toupper(removed)
[18:02:21.274]                 for (kk in seq_along(NAMES)) {
[18:02:21.274]                   name <- removed[[kk]]
[18:02:21.274]                   NAME <- NAMES[[kk]]
[18:02:21.274]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:21.274]                     next
[18:02:21.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:21.274]                 }
[18:02:21.274]                 if (length(args) > 0) 
[18:02:21.274]                   base::do.call(base::Sys.setenv, args = args)
[18:02:21.274]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:21.274]             }
[18:02:21.274]             else {
[18:02:21.274]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:21.274]             }
[18:02:21.274]             {
[18:02:21.274]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:21.274]                   0L) {
[18:02:21.274]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:21.274]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:21.274]                   base::options(opts)
[18:02:21.274]                 }
[18:02:21.274]                 {
[18:02:21.274]                   {
[18:02:21.274]                     NULL
[18:02:21.274]                     RNGkind("Mersenne-Twister")
[18:02:21.274]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:21.274]                       inherits = FALSE)
[18:02:21.274]                   }
[18:02:21.274]                   options(future.plan = NULL)
[18:02:21.274]                   if (is.na(NA_character_)) 
[18:02:21.274]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:21.274]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:21.274]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:21.274]                     .init = FALSE)
[18:02:21.274]                 }
[18:02:21.274]             }
[18:02:21.274]         }
[18:02:21.274]     })
[18:02:21.274]     if (FALSE) {
[18:02:21.274]         base::sink(type = "output", split = FALSE)
[18:02:21.274]         if (NA) {
[18:02:21.274]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:21.274]         }
[18:02:21.274]         else {
[18:02:21.274]             ...future.result["stdout"] <- base::list(NULL)
[18:02:21.274]         }
[18:02:21.274]         base::close(...future.stdout)
[18:02:21.274]         ...future.stdout <- NULL
[18:02:21.274]     }
[18:02:21.274]     ...future.result$conditions <- ...future.conditions
[18:02:21.274]     ...future.result$finished <- base::Sys.time()
[18:02:21.274]     ...future.result
[18:02:21.274] }
[18:02:21.278] assign_globals() ...
[18:02:21.278] List of 5
[18:02:21.278]  $ ...future.FUN            :function (x, y)  
[18:02:21.278]  $ MoreArgs                 : NULL
[18:02:21.278]  $ ...future.elements_ii    :List of 2
[18:02:21.278]   ..$ :List of 2
[18:02:21.278]   .. ..$ : int 1
[18:02:21.278]   .. ..$ : int 0
[18:02:21.278]   ..$ :List of 2
[18:02:21.278]   .. ..$ : int 0
[18:02:21.278]   .. ..$ : int 1
[18:02:21.278]  $ ...future.seeds_ii       : NULL
[18:02:21.278]  $ ...future.globals.maxSize: NULL
[18:02:21.278]  - attr(*, "where")=List of 5
[18:02:21.278]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:21.278]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:21.278]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:21.278]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:21.278]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:21.278]  - attr(*, "resolved")= logi FALSE
[18:02:21.278]  - attr(*, "total_size")= num 6480
[18:02:21.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:21.278]  - attr(*, "already-done")= logi TRUE
[18:02:21.291] - reassign environment for ‘...future.FUN’
[18:02:21.291] - copied ‘...future.FUN’ to environment
[18:02:21.291] - copied ‘MoreArgs’ to environment
[18:02:21.291] - copied ‘...future.elements_ii’ to environment
[18:02:21.291] - copied ‘...future.seeds_ii’ to environment
[18:02:21.292] - copied ‘...future.globals.maxSize’ to environment
[18:02:21.292] assign_globals() ... done
[18:02:21.292] plan(): Setting new future strategy stack:
[18:02:21.293] List of future strategies:
[18:02:21.293] 1. sequential:
[18:02:21.293]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:21.293]    - tweaked: FALSE
[18:02:21.293]    - call: NULL
[18:02:21.294] plan(): nbrOfWorkers() = 1
[18:02:21.796] plan(): Setting new future strategy stack:
[18:02:21.796] List of future strategies:
[18:02:21.796] 1. sequential:
[18:02:21.796]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:21.796]    - tweaked: FALSE
[18:02:21.796]    - call: plan(strategy)
[18:02:21.797] plan(): nbrOfWorkers() = 1
[18:02:21.797] SequentialFuture started (and completed)
[18:02:21.797] - Launch lazy future ... done
[18:02:21.798] run() for ‘SequentialFuture’ ... done
[18:02:21.798] Created future:
[18:02:21.798] SequentialFuture:
[18:02:21.798] Label: ‘future_mapply-1’
[18:02:21.798] Expression:
[18:02:21.798] {
[18:02:21.798]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:21.798]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:21.798]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:21.798]         on.exit(options(oopts), add = TRUE)
[18:02:21.798]     }
[18:02:21.798]     {
[18:02:21.798]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:21.798]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:21.798]         do.call(mapply, args = args)
[18:02:21.798]     }
[18:02:21.798] }
[18:02:21.798] Lazy evaluation: FALSE
[18:02:21.798] Asynchronous evaluation: FALSE
[18:02:21.798] Local evaluation: TRUE
[18:02:21.798] Environment: R_GlobalEnv
[18:02:21.798] Capture standard output: NA
[18:02:21.798] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:21.798] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:21.798] Packages: <none>
[18:02:21.798] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:21.798] Resolved: TRUE
[18:02:21.798] Value: 224 bytes of class ‘list’
[18:02:21.798] Early signaling: FALSE
[18:02:21.798] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:21.798] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:21.800] Chunk #1 of 1 ... DONE
[18:02:21.800] Launching 1 futures (chunks) ... DONE
[18:02:21.800] Resolving 1 futures (chunks) ...
[18:02:21.801] resolve() on list ...
[18:02:21.801]  recursive: 0
[18:02:21.801]  length: 1
[18:02:21.801] 
[18:02:21.801] resolved() for ‘SequentialFuture’ ...
[18:02:21.801] - state: ‘finished’
[18:02:21.802] - run: TRUE
[18:02:21.802] - result: ‘FutureResult’
[18:02:21.802] resolved() for ‘SequentialFuture’ ... done
[18:02:21.802] Future #1
[18:02:21.803] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:21.803] - nx: 1
[18:02:21.803] - relay: TRUE
[18:02:21.803] - stdout: TRUE
[18:02:21.803] - signal: TRUE
[18:02:21.803] - resignal: FALSE
[18:02:21.804] - force: TRUE
[18:02:21.804] - relayed: [n=1] FALSE
[18:02:21.804] - queued futures: [n=1] FALSE
[18:02:21.804]  - until=1
[18:02:21.804]  - relaying element #1
[18:02:21.805] - relayed: [n=1] TRUE
[18:02:21.805] - queued futures: [n=1] TRUE
[18:02:21.805] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:21.805]  length: 0 (resolved future 1)
[18:02:21.805] Relaying remaining futures
[18:02:21.806] signalConditionsASAP(NULL, pos=0) ...
[18:02:21.806] - nx: 1
[18:02:21.806] - relay: TRUE
[18:02:21.806] - stdout: TRUE
[18:02:21.806] - signal: TRUE
[18:02:21.807] - resignal: FALSE
[18:02:21.807] - force: TRUE
[18:02:21.807] - relayed: [n=1] TRUE
[18:02:21.807] - queued futures: [n=1] TRUE
 - flush all
[18:02:21.807] - relayed: [n=1] TRUE
[18:02:21.808] - queued futures: [n=1] TRUE
[18:02:21.808] signalConditionsASAP(NULL, pos=0) ... done
[18:02:21.808] resolve() on list ... DONE
[18:02:21.808]  - Number of value chunks collected: 1
[18:02:21.809] Resolving 1 futures (chunks) ... DONE
[18:02:21.809] Reducing values from 1 chunks ...
[18:02:21.809]  - Number of values collected after concatenation: 2
[18:02:21.809]  - Number of values expected: 2
[18:02:21.809] Reducing values from 1 chunks ... DONE
[18:02:21.810] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[18:02:21.811] plan(): Setting new future strategy stack:
[18:02:21.811] List of future strategies:
[18:02:21.811] 1. multicore:
[18:02:21.811]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:21.811]    - tweaked: FALSE
[18:02:21.811]    - call: plan(strategy)
[18:02:21.821] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[18:02:21.821] future_lapply() ...
[18:02:21.828] Number of chunks: 1
[18:02:21.828] getGlobalsAndPackagesXApply() ...
[18:02:21.829]  - future.globals: TRUE
[18:02:21.829] getGlobalsAndPackages() ...
[18:02:21.829] Searching for globals...
[18:02:21.832] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:21.833] Searching for globals ... DONE
[18:02:21.833] Resolving globals: FALSE
[18:02:21.834] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:21.834] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:21.835] - globals: [1] ‘FUN’
[18:02:21.835] 
[18:02:21.835] getGlobalsAndPackages() ... DONE
[18:02:21.835]  - globals found/used: [n=1] ‘FUN’
[18:02:21.836]  - needed namespaces: [n=0] 
[18:02:21.836] Finding globals ... DONE
[18:02:21.836]  - use_args: TRUE
[18:02:21.836]  - Getting '...' globals ...
[18:02:21.837] resolve() on list ...
[18:02:21.837]  recursive: 0
[18:02:21.837]  length: 1
[18:02:21.838]  elements: ‘...’
[18:02:21.838]  length: 0 (resolved future 1)
[18:02:21.838] resolve() on list ... DONE
[18:02:21.838]    - '...' content: [n=0] 
[18:02:21.838] List of 1
[18:02:21.838]  $ ...: list()
[18:02:21.838]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:21.838]  - attr(*, "where")=List of 1
[18:02:21.838]   ..$ ...:<environment: 0x5e4f84806b48> 
[18:02:21.838]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:21.838]  - attr(*, "resolved")= logi TRUE
[18:02:21.838]  - attr(*, "total_size")= num NA
[18:02:21.844]  - Getting '...' globals ... DONE
[18:02:21.844] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:21.845] List of 2
[18:02:21.845]  $ ...future.FUN:function (x)  
[18:02:21.845]  $ ...          : list()
[18:02:21.845]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:21.845]  - attr(*, "where")=List of 2
[18:02:21.845]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:21.845]   ..$ ...          :<environment: 0x5e4f84806b48> 
[18:02:21.845]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:21.845]  - attr(*, "resolved")= logi FALSE
[18:02:21.845]  - attr(*, "total_size")= num 4720
[18:02:21.850] Packages to be attached in all futures: [n=0] 
[18:02:21.851] getGlobalsAndPackagesXApply() ... DONE
[18:02:21.851] Number of futures (= number of chunks): 1
[18:02:21.851] Launching 1 futures (chunks) ...
[18:02:21.851] Chunk #1 of 1 ...
[18:02:21.852]  - Finding globals in 'X' for chunk #1 ...
[18:02:21.852] getGlobalsAndPackages() ...
[18:02:21.852] Searching for globals...
[18:02:21.853] 
[18:02:21.853] Searching for globals ... DONE
[18:02:21.853] - globals: [0] <none>
[18:02:21.853] getGlobalsAndPackages() ... DONE
[18:02:21.854]    + additional globals found: [n=0] 
[18:02:21.854]    + additional namespaces needed: [n=0] 
[18:02:21.854]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:21.854]  - seeds: <none>
[18:02:21.854]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:21.855] getGlobalsAndPackages() ...
[18:02:21.855] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:21.855] Resolving globals: FALSE
[18:02:21.855] Tweak future expression to call with '...' arguments ...
[18:02:21.856] {
[18:02:21.856]     do.call(function(...) {
[18:02:21.856]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:21.856]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:21.856]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:21.856]             on.exit(options(oopts), add = TRUE)
[18:02:21.856]         }
[18:02:21.856]         {
[18:02:21.856]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:21.856]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:21.856]                 ...future.FUN(...future.X_jj, ...)
[18:02:21.856]             })
[18:02:21.856]         }
[18:02:21.856]     }, args = future.call.arguments)
[18:02:21.856] }
[18:02:21.856] Tweak future expression to call with '...' arguments ... DONE
[18:02:21.857] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:21.857] 
[18:02:21.857] getGlobalsAndPackages() ... DONE
[18:02:21.858] run() for ‘Future’ ...
[18:02:21.858] - state: ‘created’
[18:02:21.858] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:21.865] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:21.865] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:21.865]   - Field: ‘label’
[18:02:21.866]   - Field: ‘local’
[18:02:21.866]   - Field: ‘owner’
[18:02:21.866]   - Field: ‘envir’
[18:02:21.866]   - Field: ‘packages’
[18:02:21.866]   - Field: ‘gc’
[18:02:21.867]   - Field: ‘conditions’
[18:02:21.867]   - Field: ‘expr’
[18:02:21.867]   - Field: ‘uuid’
[18:02:21.867]   - Field: ‘seed’
[18:02:21.867]   - Field: ‘version’
[18:02:21.868]   - Field: ‘result’
[18:02:21.868]   - Field: ‘asynchronous’
[18:02:21.868]   - Field: ‘calls’
[18:02:21.868]   - Field: ‘globals’
[18:02:21.869]   - Field: ‘stdout’
[18:02:21.869]   - Field: ‘earlySignal’
[18:02:21.869]   - Field: ‘lazy’
[18:02:21.869]   - Field: ‘state’
[18:02:21.869] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:21.870] - Launch lazy future ...
[18:02:21.870] Packages needed by the future expression (n = 0): <none>
[18:02:21.870] Packages needed by future strategies (n = 0): <none>
[18:02:21.871] {
[18:02:21.871]     {
[18:02:21.871]         {
[18:02:21.871]             ...future.startTime <- base::Sys.time()
[18:02:21.871]             {
[18:02:21.871]                 {
[18:02:21.871]                   {
[18:02:21.871]                     base::local({
[18:02:21.871]                       has_future <- base::requireNamespace("future", 
[18:02:21.871]                         quietly = TRUE)
[18:02:21.871]                       if (has_future) {
[18:02:21.871]                         ns <- base::getNamespace("future")
[18:02:21.871]                         version <- ns[[".package"]][["version"]]
[18:02:21.871]                         if (is.null(version)) 
[18:02:21.871]                           version <- utils::packageVersion("future")
[18:02:21.871]                       }
[18:02:21.871]                       else {
[18:02:21.871]                         version <- NULL
[18:02:21.871]                       }
[18:02:21.871]                       if (!has_future || version < "1.8.0") {
[18:02:21.871]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:21.871]                           "", base::R.version$version.string), 
[18:02:21.871]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:21.871]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:21.871]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:21.871]                             "release", "version")], collapse = " "), 
[18:02:21.871]                           hostname = base::Sys.info()[["nodename"]])
[18:02:21.871]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:21.871]                           info)
[18:02:21.871]                         info <- base::paste(info, collapse = "; ")
[18:02:21.871]                         if (!has_future) {
[18:02:21.871]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:21.871]                             info)
[18:02:21.871]                         }
[18:02:21.871]                         else {
[18:02:21.871]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:21.871]                             info, version)
[18:02:21.871]                         }
[18:02:21.871]                         base::stop(msg)
[18:02:21.871]                       }
[18:02:21.871]                     })
[18:02:21.871]                   }
[18:02:21.871]                   ...future.strategy.old <- future::plan("list")
[18:02:21.871]                   options(future.plan = NULL)
[18:02:21.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:21.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:21.871]                 }
[18:02:21.871]                 ...future.workdir <- getwd()
[18:02:21.871]             }
[18:02:21.871]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:21.871]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:21.871]         }
[18:02:21.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:21.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:21.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:21.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:21.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:21.871]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:21.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:21.871]             base::names(...future.oldOptions))
[18:02:21.871]     }
[18:02:21.871]     if (FALSE) {
[18:02:21.871]     }
[18:02:21.871]     else {
[18:02:21.871]         if (FALSE) {
[18:02:21.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:21.871]                 open = "w")
[18:02:21.871]         }
[18:02:21.871]         else {
[18:02:21.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:21.871]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:21.871]         }
[18:02:21.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:21.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:21.871]             base::sink(type = "output", split = FALSE)
[18:02:21.871]             base::close(...future.stdout)
[18:02:21.871]         }, add = TRUE)
[18:02:21.871]     }
[18:02:21.871]     ...future.frame <- base::sys.nframe()
[18:02:21.871]     ...future.conditions <- base::list()
[18:02:21.871]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:21.871]     if (FALSE) {
[18:02:21.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:21.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:21.871]     }
[18:02:21.871]     ...future.result <- base::tryCatch({
[18:02:21.871]         base::withCallingHandlers({
[18:02:21.871]             ...future.value <- base::withVisible(base::local({
[18:02:21.871]                 do.call(function(...) {
[18:02:21.871]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:21.871]                   if (!identical(...future.globals.maxSize.org, 
[18:02:21.871]                     ...future.globals.maxSize)) {
[18:02:21.871]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:21.871]                     on.exit(options(oopts), add = TRUE)
[18:02:21.871]                   }
[18:02:21.871]                   {
[18:02:21.871]                     lapply(seq_along(...future.elements_ii), 
[18:02:21.871]                       FUN = function(jj) {
[18:02:21.871]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:21.871]                         ...future.FUN(...future.X_jj, ...)
[18:02:21.871]                       })
[18:02:21.871]                   }
[18:02:21.871]                 }, args = future.call.arguments)
[18:02:21.871]             }))
[18:02:21.871]             future::FutureResult(value = ...future.value$value, 
[18:02:21.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:21.871]                   ...future.rng), globalenv = if (FALSE) 
[18:02:21.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:21.871]                     ...future.globalenv.names))
[18:02:21.871]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:21.871]         }, condition = base::local({
[18:02:21.871]             c <- base::c
[18:02:21.871]             inherits <- base::inherits
[18:02:21.871]             invokeRestart <- base::invokeRestart
[18:02:21.871]             length <- base::length
[18:02:21.871]             list <- base::list
[18:02:21.871]             seq.int <- base::seq.int
[18:02:21.871]             signalCondition <- base::signalCondition
[18:02:21.871]             sys.calls <- base::sys.calls
[18:02:21.871]             `[[` <- base::`[[`
[18:02:21.871]             `+` <- base::`+`
[18:02:21.871]             `<<-` <- base::`<<-`
[18:02:21.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:21.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:21.871]                   3L)]
[18:02:21.871]             }
[18:02:21.871]             function(cond) {
[18:02:21.871]                 is_error <- inherits(cond, "error")
[18:02:21.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:21.871]                   NULL)
[18:02:21.871]                 if (is_error) {
[18:02:21.871]                   sessionInformation <- function() {
[18:02:21.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:21.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:21.871]                       search = base::search(), system = base::Sys.info())
[18:02:21.871]                   }
[18:02:21.871]                   ...future.conditions[[length(...future.conditions) + 
[18:02:21.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:21.871]                     cond$call), session = sessionInformation(), 
[18:02:21.871]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:21.871]                   signalCondition(cond)
[18:02:21.871]                 }
[18:02:21.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:21.871]                 "immediateCondition"))) {
[18:02:21.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:21.871]                   ...future.conditions[[length(...future.conditions) + 
[18:02:21.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:21.871]                   if (TRUE && !signal) {
[18:02:21.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:21.871]                     {
[18:02:21.871]                       inherits <- base::inherits
[18:02:21.871]                       invokeRestart <- base::invokeRestart
[18:02:21.871]                       is.null <- base::is.null
[18:02:21.871]                       muffled <- FALSE
[18:02:21.871]                       if (inherits(cond, "message")) {
[18:02:21.871]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:21.871]                         if (muffled) 
[18:02:21.871]                           invokeRestart("muffleMessage")
[18:02:21.871]                       }
[18:02:21.871]                       else if (inherits(cond, "warning")) {
[18:02:21.871]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:21.871]                         if (muffled) 
[18:02:21.871]                           invokeRestart("muffleWarning")
[18:02:21.871]                       }
[18:02:21.871]                       else if (inherits(cond, "condition")) {
[18:02:21.871]                         if (!is.null(pattern)) {
[18:02:21.871]                           computeRestarts <- base::computeRestarts
[18:02:21.871]                           grepl <- base::grepl
[18:02:21.871]                           restarts <- computeRestarts(cond)
[18:02:21.871]                           for (restart in restarts) {
[18:02:21.871]                             name <- restart$name
[18:02:21.871]                             if (is.null(name)) 
[18:02:21.871]                               next
[18:02:21.871]                             if (!grepl(pattern, name)) 
[18:02:21.871]                               next
[18:02:21.871]                             invokeRestart(restart)
[18:02:21.871]                             muffled <- TRUE
[18:02:21.871]                             break
[18:02:21.871]                           }
[18:02:21.871]                         }
[18:02:21.871]                       }
[18:02:21.871]                       invisible(muffled)
[18:02:21.871]                     }
[18:02:21.871]                     muffleCondition(cond, pattern = "^muffle")
[18:02:21.871]                   }
[18:02:21.871]                 }
[18:02:21.871]                 else {
[18:02:21.871]                   if (TRUE) {
[18:02:21.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:21.871]                     {
[18:02:21.871]                       inherits <- base::inherits
[18:02:21.871]                       invokeRestart <- base::invokeRestart
[18:02:21.871]                       is.null <- base::is.null
[18:02:21.871]                       muffled <- FALSE
[18:02:21.871]                       if (inherits(cond, "message")) {
[18:02:21.871]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:21.871]                         if (muffled) 
[18:02:21.871]                           invokeRestart("muffleMessage")
[18:02:21.871]                       }
[18:02:21.871]                       else if (inherits(cond, "warning")) {
[18:02:21.871]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:21.871]                         if (muffled) 
[18:02:21.871]                           invokeRestart("muffleWarning")
[18:02:21.871]                       }
[18:02:21.871]                       else if (inherits(cond, "condition")) {
[18:02:21.871]                         if (!is.null(pattern)) {
[18:02:21.871]                           computeRestarts <- base::computeRestarts
[18:02:21.871]                           grepl <- base::grepl
[18:02:21.871]                           restarts <- computeRestarts(cond)
[18:02:21.871]                           for (restart in restarts) {
[18:02:21.871]                             name <- restart$name
[18:02:21.871]                             if (is.null(name)) 
[18:02:21.871]                               next
[18:02:21.871]                             if (!grepl(pattern, name)) 
[18:02:21.871]                               next
[18:02:21.871]                             invokeRestart(restart)
[18:02:21.871]                             muffled <- TRUE
[18:02:21.871]                             break
[18:02:21.871]                           }
[18:02:21.871]                         }
[18:02:21.871]                       }
[18:02:21.871]                       invisible(muffled)
[18:02:21.871]                     }
[18:02:21.871]                     muffleCondition(cond, pattern = "^muffle")
[18:02:21.871]                   }
[18:02:21.871]                 }
[18:02:21.871]             }
[18:02:21.871]         }))
[18:02:21.871]     }, error = function(ex) {
[18:02:21.871]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:21.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:21.871]                 ...future.rng), started = ...future.startTime, 
[18:02:21.871]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:21.871]             version = "1.8"), class = "FutureResult")
[18:02:21.871]     }, finally = {
[18:02:21.871]         if (!identical(...future.workdir, getwd())) 
[18:02:21.871]             setwd(...future.workdir)
[18:02:21.871]         {
[18:02:21.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:21.871]                 ...future.oldOptions$nwarnings <- NULL
[18:02:21.871]             }
[18:02:21.871]             base::options(...future.oldOptions)
[18:02:21.871]             if (.Platform$OS.type == "windows") {
[18:02:21.871]                 old_names <- names(...future.oldEnvVars)
[18:02:21.871]                 envs <- base::Sys.getenv()
[18:02:21.871]                 names <- names(envs)
[18:02:21.871]                 common <- intersect(names, old_names)
[18:02:21.871]                 added <- setdiff(names, old_names)
[18:02:21.871]                 removed <- setdiff(old_names, names)
[18:02:21.871]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:21.871]                   envs[common]]
[18:02:21.871]                 NAMES <- toupper(changed)
[18:02:21.871]                 args <- list()
[18:02:21.871]                 for (kk in seq_along(NAMES)) {
[18:02:21.871]                   name <- changed[[kk]]
[18:02:21.871]                   NAME <- NAMES[[kk]]
[18:02:21.871]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:21.871]                     next
[18:02:21.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:21.871]                 }
[18:02:21.871]                 NAMES <- toupper(added)
[18:02:21.871]                 for (kk in seq_along(NAMES)) {
[18:02:21.871]                   name <- added[[kk]]
[18:02:21.871]                   NAME <- NAMES[[kk]]
[18:02:21.871]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:21.871]                     next
[18:02:21.871]                   args[[name]] <- ""
[18:02:21.871]                 }
[18:02:21.871]                 NAMES <- toupper(removed)
[18:02:21.871]                 for (kk in seq_along(NAMES)) {
[18:02:21.871]                   name <- removed[[kk]]
[18:02:21.871]                   NAME <- NAMES[[kk]]
[18:02:21.871]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:21.871]                     next
[18:02:21.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:21.871]                 }
[18:02:21.871]                 if (length(args) > 0) 
[18:02:21.871]                   base::do.call(base::Sys.setenv, args = args)
[18:02:21.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:21.871]             }
[18:02:21.871]             else {
[18:02:21.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:21.871]             }
[18:02:21.871]             {
[18:02:21.871]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:21.871]                   0L) {
[18:02:21.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:21.871]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:21.871]                   base::options(opts)
[18:02:21.871]                 }
[18:02:21.871]                 {
[18:02:21.871]                   {
[18:02:21.871]                     NULL
[18:02:21.871]                     RNGkind("Mersenne-Twister")
[18:02:21.871]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:21.871]                       inherits = FALSE)
[18:02:21.871]                   }
[18:02:21.871]                   options(future.plan = NULL)
[18:02:21.871]                   if (is.na(NA_character_)) 
[18:02:21.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:21.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:21.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:21.871]                     .init = FALSE)
[18:02:21.871]                 }
[18:02:21.871]             }
[18:02:21.871]         }
[18:02:21.871]     })
[18:02:21.871]     if (TRUE) {
[18:02:21.871]         base::sink(type = "output", split = FALSE)
[18:02:21.871]         if (FALSE) {
[18:02:21.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:21.871]         }
[18:02:21.871]         else {
[18:02:21.871]             ...future.result["stdout"] <- base::list(NULL)
[18:02:21.871]         }
[18:02:21.871]         base::close(...future.stdout)
[18:02:21.871]         ...future.stdout <- NULL
[18:02:21.871]     }
[18:02:21.871]     ...future.result$conditions <- ...future.conditions
[18:02:21.871]     ...future.result$finished <- base::Sys.time()
[18:02:21.871]     ...future.result
[18:02:21.871] }
[18:02:21.875] assign_globals() ...
[18:02:21.875] List of 5
[18:02:21.875]  $ ...future.FUN            :function (x)  
[18:02:21.875]  $ future.call.arguments    : list()
[18:02:21.875]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:21.875]  $ ...future.elements_ii    :List of 2
[18:02:21.875]   ..$ : int 1
[18:02:21.875]   ..$ : int 0
[18:02:21.875]  $ ...future.seeds_ii       : NULL
[18:02:21.875]  $ ...future.globals.maxSize: NULL
[18:02:21.875]  - attr(*, "where")=List of 5
[18:02:21.875]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:21.875]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:21.875]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:21.875]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:21.875]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:21.875]  - attr(*, "resolved")= logi FALSE
[18:02:21.875]  - attr(*, "total_size")= num 4720
[18:02:21.875]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:21.875]  - attr(*, "already-done")= logi TRUE
[18:02:21.888] - reassign environment for ‘...future.FUN’
[18:02:21.888] - copied ‘...future.FUN’ to environment
[18:02:21.889] - copied ‘future.call.arguments’ to environment
[18:02:21.889] - copied ‘...future.elements_ii’ to environment
[18:02:21.889] - copied ‘...future.seeds_ii’ to environment
[18:02:21.889] - copied ‘...future.globals.maxSize’ to environment
[18:02:21.889] assign_globals() ... done
[18:02:21.890] plan(): Setting new future strategy stack:
[18:02:21.890] List of future strategies:
[18:02:21.890] 1. sequential:
[18:02:21.890]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:21.890]    - tweaked: FALSE
[18:02:21.890]    - call: NULL
[18:02:21.891] plan(): nbrOfWorkers() = 1
[18:02:22.394] plan(): Setting new future strategy stack:
[18:02:22.394] List of future strategies:
[18:02:22.394] 1. multicore:
[18:02:22.394]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:22.394]    - tweaked: FALSE
[18:02:22.394]    - call: plan(strategy)
[18:02:22.400] plan(): nbrOfWorkers() = 1
[18:02:22.401] SequentialFuture started (and completed)
[18:02:22.401] - Launch lazy future ... done
[18:02:22.401] run() for ‘SequentialFuture’ ... done
[18:02:22.402] Created future:
[18:02:22.402] SequentialFuture:
[18:02:22.402] Label: ‘future_lapply-1’
[18:02:22.402] Expression:
[18:02:22.402] {
[18:02:22.402]     do.call(function(...) {
[18:02:22.402]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:22.402]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:22.402]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:22.402]             on.exit(options(oopts), add = TRUE)
[18:02:22.402]         }
[18:02:22.402]         {
[18:02:22.402]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:22.402]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:22.402]                 ...future.FUN(...future.X_jj, ...)
[18:02:22.402]             })
[18:02:22.402]         }
[18:02:22.402]     }, args = future.call.arguments)
[18:02:22.402] }
[18:02:22.402] Lazy evaluation: FALSE
[18:02:22.402] Asynchronous evaluation: FALSE
[18:02:22.402] Local evaluation: TRUE
[18:02:22.402] Environment: R_GlobalEnv
[18:02:22.402] Capture standard output: FALSE
[18:02:22.402] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:22.402] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:22.402] Packages: <none>
[18:02:22.402] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:22.402] Resolved: TRUE
[18:02:22.402] Value: 112 bytes of class ‘list’
[18:02:22.402] Early signaling: FALSE
[18:02:22.402] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:22.402] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:22.404] Chunk #1 of 1 ... DONE
[18:02:22.405] Launching 1 futures (chunks) ... DONE
[18:02:22.405] Resolving 1 futures (chunks) ...
[18:02:22.405] resolve() on list ...
[18:02:22.405]  recursive: 0
[18:02:22.406]  length: 1
[18:02:22.406] 
[18:02:22.406] resolved() for ‘SequentialFuture’ ...
[18:02:22.406] - state: ‘finished’
[18:02:22.407] - run: TRUE
[18:02:22.407] - result: ‘FutureResult’
[18:02:22.407] resolved() for ‘SequentialFuture’ ... done
[18:02:22.407] Future #1
[18:02:22.408] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:22.408] - nx: 1
[18:02:22.408] - relay: TRUE
[18:02:22.408] - stdout: TRUE
[18:02:22.409] - signal: TRUE
[18:02:22.409] - resignal: FALSE
[18:02:22.409] - force: TRUE
[18:02:22.409] - relayed: [n=1] FALSE
[18:02:22.409] - queued futures: [n=1] FALSE
[18:02:22.410]  - until=1
[18:02:22.410]  - relaying element #1
[18:02:22.410] - relayed: [n=1] TRUE
[18:02:22.410] - queued futures: [n=1] TRUE
[18:02:22.411] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:22.411]  length: 0 (resolved future 1)
[18:02:22.411] Relaying remaining futures
[18:02:22.411] signalConditionsASAP(NULL, pos=0) ...
[18:02:22.412] - nx: 1
[18:02:22.412] - relay: TRUE
[18:02:22.412] - stdout: TRUE
[18:02:22.412] - signal: TRUE
[18:02:22.412] - resignal: FALSE
[18:02:22.413] - force: TRUE
[18:02:22.413] - relayed: [n=1] TRUE
[18:02:22.413] - queued futures: [n=1] TRUE
 - flush all
[18:02:22.413] - relayed: [n=1] TRUE
[18:02:22.414] - queued futures: [n=1] TRUE
[18:02:22.414] signalConditionsASAP(NULL, pos=0) ... done
[18:02:22.414] resolve() on list ... DONE
[18:02:22.415]  - Number of value chunks collected: 1
[18:02:22.415] Resolving 1 futures (chunks) ... DONE
[18:02:22.415] Reducing values from 1 chunks ...
[18:02:22.415]  - Number of values collected after concatenation: 2
[18:02:22.415]  - Number of values expected: 2
[18:02:22.416] Reducing values from 1 chunks ... DONE
[18:02:22.416] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[18:02:22.417] future_lapply() ...
[18:02:22.424] Number of chunks: 1
[18:02:22.425] getGlobalsAndPackagesXApply() ...
[18:02:22.425]  - future.globals: TRUE
[18:02:22.425] getGlobalsAndPackages() ...
[18:02:22.425] Searching for globals...
[18:02:22.428] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:22.429] Searching for globals ... DONE
[18:02:22.429] Resolving globals: FALSE
[18:02:22.430] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:22.431] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:22.431] - globals: [1] ‘FUN’
[18:02:22.431] 
[18:02:22.431] getGlobalsAndPackages() ... DONE
[18:02:22.432]  - globals found/used: [n=1] ‘FUN’
[18:02:22.432]  - needed namespaces: [n=0] 
[18:02:22.432] Finding globals ... DONE
[18:02:22.432]  - use_args: TRUE
[18:02:22.432]  - Getting '...' globals ...
[18:02:22.433] resolve() on list ...
[18:02:22.433]  recursive: 0
[18:02:22.433]  length: 1
[18:02:22.434]  elements: ‘...’
[18:02:22.434]  length: 0 (resolved future 1)
[18:02:22.434] resolve() on list ... DONE
[18:02:22.434]    - '...' content: [n=0] 
[18:02:22.435] List of 1
[18:02:22.435]  $ ...: list()
[18:02:22.435]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:22.435]  - attr(*, "where")=List of 1
[18:02:22.435]   ..$ ...:<environment: 0x5e4f84c43ea8> 
[18:02:22.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:22.435]  - attr(*, "resolved")= logi TRUE
[18:02:22.435]  - attr(*, "total_size")= num NA
[18:02:22.440]  - Getting '...' globals ... DONE
[18:02:22.440] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:22.440] List of 2
[18:02:22.440]  $ ...future.FUN:function (x)  
[18:02:22.440]  $ ...          : list()
[18:02:22.440]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:22.440]  - attr(*, "where")=List of 2
[18:02:22.440]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:22.440]   ..$ ...          :<environment: 0x5e4f84c43ea8> 
[18:02:22.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:22.440]  - attr(*, "resolved")= logi FALSE
[18:02:22.440]  - attr(*, "total_size")= num 4720
[18:02:22.449] Packages to be attached in all futures: [n=0] 
[18:02:22.449] getGlobalsAndPackagesXApply() ... DONE
[18:02:22.449] Number of futures (= number of chunks): 1
[18:02:22.450] Launching 1 futures (chunks) ...
[18:02:22.450] Chunk #1 of 1 ...
[18:02:22.450]  - Finding globals in 'X' for chunk #1 ...
[18:02:22.450] getGlobalsAndPackages() ...
[18:02:22.450] Searching for globals...
[18:02:22.451] 
[18:02:22.451] Searching for globals ... DONE
[18:02:22.451] - globals: [0] <none>
[18:02:22.452] getGlobalsAndPackages() ... DONE
[18:02:22.452]    + additional globals found: [n=0] 
[18:02:22.452]    + additional namespaces needed: [n=0] 
[18:02:22.452]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:22.452]  - seeds: <none>
[18:02:22.453]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:22.453] getGlobalsAndPackages() ...
[18:02:22.453] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:22.453] Resolving globals: FALSE
[18:02:22.454] Tweak future expression to call with '...' arguments ...
[18:02:22.454] {
[18:02:22.454]     do.call(function(...) {
[18:02:22.454]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:22.454]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:22.454]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:22.454]             on.exit(options(oopts), add = TRUE)
[18:02:22.454]         }
[18:02:22.454]         {
[18:02:22.454]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:22.454]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:22.454]                 ...future.FUN(...future.X_jj, ...)
[18:02:22.454]             })
[18:02:22.454]         }
[18:02:22.454]     }, args = future.call.arguments)
[18:02:22.454] }
[18:02:22.454] Tweak future expression to call with '...' arguments ... DONE
[18:02:22.455] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:22.455] 
[18:02:22.456] getGlobalsAndPackages() ... DONE
[18:02:22.456] run() for ‘Future’ ...
[18:02:22.456] - state: ‘created’
[18:02:22.457] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:22.463] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:22.464] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:22.464]   - Field: ‘label’
[18:02:22.464]   - Field: ‘local’
[18:02:22.464]   - Field: ‘owner’
[18:02:22.465]   - Field: ‘envir’
[18:02:22.465]   - Field: ‘packages’
[18:02:22.465]   - Field: ‘gc’
[18:02:22.465]   - Field: ‘conditions’
[18:02:22.465]   - Field: ‘expr’
[18:02:22.466]   - Field: ‘uuid’
[18:02:22.466]   - Field: ‘seed’
[18:02:22.466]   - Field: ‘version’
[18:02:22.466]   - Field: ‘result’
[18:02:22.467]   - Field: ‘asynchronous’
[18:02:22.467]   - Field: ‘calls’
[18:02:22.467]   - Field: ‘globals’
[18:02:22.467]   - Field: ‘stdout’
[18:02:22.467]   - Field: ‘earlySignal’
[18:02:22.468]   - Field: ‘lazy’
[18:02:22.468]   - Field: ‘state’
[18:02:22.468] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:22.468] - Launch lazy future ...
[18:02:22.469] Packages needed by the future expression (n = 0): <none>
[18:02:22.469] Packages needed by future strategies (n = 0): <none>
[18:02:22.470] {
[18:02:22.470]     {
[18:02:22.470]         {
[18:02:22.470]             ...future.startTime <- base::Sys.time()
[18:02:22.470]             {
[18:02:22.470]                 {
[18:02:22.470]                   {
[18:02:22.470]                     base::local({
[18:02:22.470]                       has_future <- base::requireNamespace("future", 
[18:02:22.470]                         quietly = TRUE)
[18:02:22.470]                       if (has_future) {
[18:02:22.470]                         ns <- base::getNamespace("future")
[18:02:22.470]                         version <- ns[[".package"]][["version"]]
[18:02:22.470]                         if (is.null(version)) 
[18:02:22.470]                           version <- utils::packageVersion("future")
[18:02:22.470]                       }
[18:02:22.470]                       else {
[18:02:22.470]                         version <- NULL
[18:02:22.470]                       }
[18:02:22.470]                       if (!has_future || version < "1.8.0") {
[18:02:22.470]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:22.470]                           "", base::R.version$version.string), 
[18:02:22.470]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:22.470]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:22.470]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:22.470]                             "release", "version")], collapse = " "), 
[18:02:22.470]                           hostname = base::Sys.info()[["nodename"]])
[18:02:22.470]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:22.470]                           info)
[18:02:22.470]                         info <- base::paste(info, collapse = "; ")
[18:02:22.470]                         if (!has_future) {
[18:02:22.470]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:22.470]                             info)
[18:02:22.470]                         }
[18:02:22.470]                         else {
[18:02:22.470]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:22.470]                             info, version)
[18:02:22.470]                         }
[18:02:22.470]                         base::stop(msg)
[18:02:22.470]                       }
[18:02:22.470]                     })
[18:02:22.470]                   }
[18:02:22.470]                   ...future.strategy.old <- future::plan("list")
[18:02:22.470]                   options(future.plan = NULL)
[18:02:22.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:22.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:22.470]                 }
[18:02:22.470]                 ...future.workdir <- getwd()
[18:02:22.470]             }
[18:02:22.470]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:22.470]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:22.470]         }
[18:02:22.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:22.470]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:22.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:22.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:22.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:22.470]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:22.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:22.470]             base::names(...future.oldOptions))
[18:02:22.470]     }
[18:02:22.470]     if (FALSE) {
[18:02:22.470]     }
[18:02:22.470]     else {
[18:02:22.470]         if (TRUE) {
[18:02:22.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:22.470]                 open = "w")
[18:02:22.470]         }
[18:02:22.470]         else {
[18:02:22.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:22.470]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:22.470]         }
[18:02:22.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:22.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:22.470]             base::sink(type = "output", split = FALSE)
[18:02:22.470]             base::close(...future.stdout)
[18:02:22.470]         }, add = TRUE)
[18:02:22.470]     }
[18:02:22.470]     ...future.frame <- base::sys.nframe()
[18:02:22.470]     ...future.conditions <- base::list()
[18:02:22.470]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:22.470]     if (FALSE) {
[18:02:22.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:22.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:22.470]     }
[18:02:22.470]     ...future.result <- base::tryCatch({
[18:02:22.470]         base::withCallingHandlers({
[18:02:22.470]             ...future.value <- base::withVisible(base::local({
[18:02:22.470]                 do.call(function(...) {
[18:02:22.470]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:22.470]                   if (!identical(...future.globals.maxSize.org, 
[18:02:22.470]                     ...future.globals.maxSize)) {
[18:02:22.470]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:22.470]                     on.exit(options(oopts), add = TRUE)
[18:02:22.470]                   }
[18:02:22.470]                   {
[18:02:22.470]                     lapply(seq_along(...future.elements_ii), 
[18:02:22.470]                       FUN = function(jj) {
[18:02:22.470]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:22.470]                         ...future.FUN(...future.X_jj, ...)
[18:02:22.470]                       })
[18:02:22.470]                   }
[18:02:22.470]                 }, args = future.call.arguments)
[18:02:22.470]             }))
[18:02:22.470]             future::FutureResult(value = ...future.value$value, 
[18:02:22.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:22.470]                   ...future.rng), globalenv = if (FALSE) 
[18:02:22.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:22.470]                     ...future.globalenv.names))
[18:02:22.470]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:22.470]         }, condition = base::local({
[18:02:22.470]             c <- base::c
[18:02:22.470]             inherits <- base::inherits
[18:02:22.470]             invokeRestart <- base::invokeRestart
[18:02:22.470]             length <- base::length
[18:02:22.470]             list <- base::list
[18:02:22.470]             seq.int <- base::seq.int
[18:02:22.470]             signalCondition <- base::signalCondition
[18:02:22.470]             sys.calls <- base::sys.calls
[18:02:22.470]             `[[` <- base::`[[`
[18:02:22.470]             `+` <- base::`+`
[18:02:22.470]             `<<-` <- base::`<<-`
[18:02:22.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:22.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:22.470]                   3L)]
[18:02:22.470]             }
[18:02:22.470]             function(cond) {
[18:02:22.470]                 is_error <- inherits(cond, "error")
[18:02:22.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:22.470]                   NULL)
[18:02:22.470]                 if (is_error) {
[18:02:22.470]                   sessionInformation <- function() {
[18:02:22.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:22.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:22.470]                       search = base::search(), system = base::Sys.info())
[18:02:22.470]                   }
[18:02:22.470]                   ...future.conditions[[length(...future.conditions) + 
[18:02:22.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:22.470]                     cond$call), session = sessionInformation(), 
[18:02:22.470]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:22.470]                   signalCondition(cond)
[18:02:22.470]                 }
[18:02:22.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:22.470]                 "immediateCondition"))) {
[18:02:22.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:22.470]                   ...future.conditions[[length(...future.conditions) + 
[18:02:22.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:22.470]                   if (TRUE && !signal) {
[18:02:22.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:22.470]                     {
[18:02:22.470]                       inherits <- base::inherits
[18:02:22.470]                       invokeRestart <- base::invokeRestart
[18:02:22.470]                       is.null <- base::is.null
[18:02:22.470]                       muffled <- FALSE
[18:02:22.470]                       if (inherits(cond, "message")) {
[18:02:22.470]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:22.470]                         if (muffled) 
[18:02:22.470]                           invokeRestart("muffleMessage")
[18:02:22.470]                       }
[18:02:22.470]                       else if (inherits(cond, "warning")) {
[18:02:22.470]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:22.470]                         if (muffled) 
[18:02:22.470]                           invokeRestart("muffleWarning")
[18:02:22.470]                       }
[18:02:22.470]                       else if (inherits(cond, "condition")) {
[18:02:22.470]                         if (!is.null(pattern)) {
[18:02:22.470]                           computeRestarts <- base::computeRestarts
[18:02:22.470]                           grepl <- base::grepl
[18:02:22.470]                           restarts <- computeRestarts(cond)
[18:02:22.470]                           for (restart in restarts) {
[18:02:22.470]                             name <- restart$name
[18:02:22.470]                             if (is.null(name)) 
[18:02:22.470]                               next
[18:02:22.470]                             if (!grepl(pattern, name)) 
[18:02:22.470]                               next
[18:02:22.470]                             invokeRestart(restart)
[18:02:22.470]                             muffled <- TRUE
[18:02:22.470]                             break
[18:02:22.470]                           }
[18:02:22.470]                         }
[18:02:22.470]                       }
[18:02:22.470]                       invisible(muffled)
[18:02:22.470]                     }
[18:02:22.470]                     muffleCondition(cond, pattern = "^muffle")
[18:02:22.470]                   }
[18:02:22.470]                 }
[18:02:22.470]                 else {
[18:02:22.470]                   if (TRUE) {
[18:02:22.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:22.470]                     {
[18:02:22.470]                       inherits <- base::inherits
[18:02:22.470]                       invokeRestart <- base::invokeRestart
[18:02:22.470]                       is.null <- base::is.null
[18:02:22.470]                       muffled <- FALSE
[18:02:22.470]                       if (inherits(cond, "message")) {
[18:02:22.470]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:22.470]                         if (muffled) 
[18:02:22.470]                           invokeRestart("muffleMessage")
[18:02:22.470]                       }
[18:02:22.470]                       else if (inherits(cond, "warning")) {
[18:02:22.470]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:22.470]                         if (muffled) 
[18:02:22.470]                           invokeRestart("muffleWarning")
[18:02:22.470]                       }
[18:02:22.470]                       else if (inherits(cond, "condition")) {
[18:02:22.470]                         if (!is.null(pattern)) {
[18:02:22.470]                           computeRestarts <- base::computeRestarts
[18:02:22.470]                           grepl <- base::grepl
[18:02:22.470]                           restarts <- computeRestarts(cond)
[18:02:22.470]                           for (restart in restarts) {
[18:02:22.470]                             name <- restart$name
[18:02:22.470]                             if (is.null(name)) 
[18:02:22.470]                               next
[18:02:22.470]                             if (!grepl(pattern, name)) 
[18:02:22.470]                               next
[18:02:22.470]                             invokeRestart(restart)
[18:02:22.470]                             muffled <- TRUE
[18:02:22.470]                             break
[18:02:22.470]                           }
[18:02:22.470]                         }
[18:02:22.470]                       }
[18:02:22.470]                       invisible(muffled)
[18:02:22.470]                     }
[18:02:22.470]                     muffleCondition(cond, pattern = "^muffle")
[18:02:22.470]                   }
[18:02:22.470]                 }
[18:02:22.470]             }
[18:02:22.470]         }))
[18:02:22.470]     }, error = function(ex) {
[18:02:22.470]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:22.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:22.470]                 ...future.rng), started = ...future.startTime, 
[18:02:22.470]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:22.470]             version = "1.8"), class = "FutureResult")
[18:02:22.470]     }, finally = {
[18:02:22.470]         if (!identical(...future.workdir, getwd())) 
[18:02:22.470]             setwd(...future.workdir)
[18:02:22.470]         {
[18:02:22.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:22.470]                 ...future.oldOptions$nwarnings <- NULL
[18:02:22.470]             }
[18:02:22.470]             base::options(...future.oldOptions)
[18:02:22.470]             if (.Platform$OS.type == "windows") {
[18:02:22.470]                 old_names <- names(...future.oldEnvVars)
[18:02:22.470]                 envs <- base::Sys.getenv()
[18:02:22.470]                 names <- names(envs)
[18:02:22.470]                 common <- intersect(names, old_names)
[18:02:22.470]                 added <- setdiff(names, old_names)
[18:02:22.470]                 removed <- setdiff(old_names, names)
[18:02:22.470]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:22.470]                   envs[common]]
[18:02:22.470]                 NAMES <- toupper(changed)
[18:02:22.470]                 args <- list()
[18:02:22.470]                 for (kk in seq_along(NAMES)) {
[18:02:22.470]                   name <- changed[[kk]]
[18:02:22.470]                   NAME <- NAMES[[kk]]
[18:02:22.470]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:22.470]                     next
[18:02:22.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:22.470]                 }
[18:02:22.470]                 NAMES <- toupper(added)
[18:02:22.470]                 for (kk in seq_along(NAMES)) {
[18:02:22.470]                   name <- added[[kk]]
[18:02:22.470]                   NAME <- NAMES[[kk]]
[18:02:22.470]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:22.470]                     next
[18:02:22.470]                   args[[name]] <- ""
[18:02:22.470]                 }
[18:02:22.470]                 NAMES <- toupper(removed)
[18:02:22.470]                 for (kk in seq_along(NAMES)) {
[18:02:22.470]                   name <- removed[[kk]]
[18:02:22.470]                   NAME <- NAMES[[kk]]
[18:02:22.470]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:22.470]                     next
[18:02:22.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:22.470]                 }
[18:02:22.470]                 if (length(args) > 0) 
[18:02:22.470]                   base::do.call(base::Sys.setenv, args = args)
[18:02:22.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:22.470]             }
[18:02:22.470]             else {
[18:02:22.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:22.470]             }
[18:02:22.470]             {
[18:02:22.470]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:22.470]                   0L) {
[18:02:22.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:22.470]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:22.470]                   base::options(opts)
[18:02:22.470]                 }
[18:02:22.470]                 {
[18:02:22.470]                   {
[18:02:22.470]                     NULL
[18:02:22.470]                     RNGkind("Mersenne-Twister")
[18:02:22.470]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:22.470]                       inherits = FALSE)
[18:02:22.470]                   }
[18:02:22.470]                   options(future.plan = NULL)
[18:02:22.470]                   if (is.na(NA_character_)) 
[18:02:22.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:22.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:22.470]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:22.470]                     .init = FALSE)
[18:02:22.470]                 }
[18:02:22.470]             }
[18:02:22.470]         }
[18:02:22.470]     })
[18:02:22.470]     if (TRUE) {
[18:02:22.470]         base::sink(type = "output", split = FALSE)
[18:02:22.470]         if (TRUE) {
[18:02:22.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:22.470]         }
[18:02:22.470]         else {
[18:02:22.470]             ...future.result["stdout"] <- base::list(NULL)
[18:02:22.470]         }
[18:02:22.470]         base::close(...future.stdout)
[18:02:22.470]         ...future.stdout <- NULL
[18:02:22.470]     }
[18:02:22.470]     ...future.result$conditions <- ...future.conditions
[18:02:22.470]     ...future.result$finished <- base::Sys.time()
[18:02:22.470]     ...future.result
[18:02:22.470] }
[18:02:22.474] assign_globals() ...
[18:02:22.474] List of 5
[18:02:22.474]  $ ...future.FUN            :function (x)  
[18:02:22.474]  $ future.call.arguments    : list()
[18:02:22.474]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:22.474]  $ ...future.elements_ii    :List of 2
[18:02:22.474]   ..$ : int 1
[18:02:22.474]   ..$ : int 0
[18:02:22.474]  $ ...future.seeds_ii       : NULL
[18:02:22.474]  $ ...future.globals.maxSize: NULL
[18:02:22.474]  - attr(*, "where")=List of 5
[18:02:22.474]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:22.474]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:22.474]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:22.474]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:22.474]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:22.474]  - attr(*, "resolved")= logi FALSE
[18:02:22.474]  - attr(*, "total_size")= num 4720
[18:02:22.474]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:22.474]  - attr(*, "already-done")= logi TRUE
[18:02:22.484] - reassign environment for ‘...future.FUN’
[18:02:22.484] - copied ‘...future.FUN’ to environment
[18:02:22.484] - copied ‘future.call.arguments’ to environment
[18:02:22.485] - copied ‘...future.elements_ii’ to environment
[18:02:22.485] - copied ‘...future.seeds_ii’ to environment
[18:02:22.485] - copied ‘...future.globals.maxSize’ to environment
[18:02:22.485] assign_globals() ... done
[18:02:22.486] plan(): Setting new future strategy stack:
[18:02:22.486] List of future strategies:
[18:02:22.486] 1. sequential:
[18:02:22.486]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:22.486]    - tweaked: FALSE
[18:02:22.486]    - call: NULL
[18:02:22.487] plan(): nbrOfWorkers() = 1
[18:02:22.989] plan(): Setting new future strategy stack:
[18:02:22.990] List of future strategies:
[18:02:22.990] 1. multicore:
[18:02:22.990]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:22.990]    - tweaked: FALSE
[18:02:22.990]    - call: plan(strategy)
[18:02:22.996] plan(): nbrOfWorkers() = 1
[18:02:22.997] SequentialFuture started (and completed)
[18:02:22.997] - Launch lazy future ... done
[18:02:22.997] run() for ‘SequentialFuture’ ... done
[18:02:22.997] Created future:
[18:02:22.998] SequentialFuture:
[18:02:22.998] Label: ‘future_lapply-1’
[18:02:22.998] Expression:
[18:02:22.998] {
[18:02:22.998]     do.call(function(...) {
[18:02:22.998]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:22.998]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:22.998]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:22.998]             on.exit(options(oopts), add = TRUE)
[18:02:22.998]         }
[18:02:22.998]         {
[18:02:22.998]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:22.998]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:22.998]                 ...future.FUN(...future.X_jj, ...)
[18:02:22.998]             })
[18:02:22.998]         }
[18:02:22.998]     }, args = future.call.arguments)
[18:02:22.998] }
[18:02:22.998] Lazy evaluation: FALSE
[18:02:22.998] Asynchronous evaluation: FALSE
[18:02:22.998] Local evaluation: TRUE
[18:02:22.998] Environment: R_GlobalEnv
[18:02:22.998] Capture standard output: TRUE
[18:02:22.998] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:22.998] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:22.998] Packages: <none>
[18:02:22.998] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:22.998] Resolved: TRUE
[18:02:22.998] Value: 112 bytes of class ‘list’
[18:02:22.998] Early signaling: FALSE
[18:02:22.998] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:22.998] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:23.000] Chunk #1 of 1 ... DONE
[18:02:23.000] Launching 1 futures (chunks) ... DONE
[18:02:23.000] Resolving 1 futures (chunks) ...
[18:02:23.000] resolve() on list ...
[18:02:23.001]  recursive: 0
[18:02:23.001]  length: 1
[18:02:23.001] 
[18:02:23.001] resolved() for ‘SequentialFuture’ ...
[18:02:23.001] - state: ‘finished’
[18:02:23.002] - run: TRUE
[18:02:23.002] - result: ‘FutureResult’
[18:02:23.002] resolved() for ‘SequentialFuture’ ... done
[18:02:23.002] Future #1
[18:02:23.003] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:23.003] - nx: 1
[18:02:23.003] - relay: TRUE
[18:02:23.003] - stdout: TRUE
[18:02:23.003] - signal: TRUE
[18:02:23.004] - resignal: FALSE
[18:02:23.004] - force: TRUE
[18:02:23.004] - relayed: [n=1] FALSE
[18:02:23.004] - queued futures: [n=1] FALSE
[18:02:23.004]  - until=1
[18:02:23.004]  - relaying element #1
[18:02:23.005] - relayed: [n=1] TRUE
[18:02:23.005] - queued futures: [n=1] TRUE
[18:02:23.005] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:23.006]  length: 0 (resolved future 1)
[18:02:23.006] Relaying remaining futures
[18:02:23.006] signalConditionsASAP(NULL, pos=0) ...
[18:02:23.006] - nx: 1
[18:02:23.006] - relay: TRUE
[18:02:23.006] - stdout: TRUE
[18:02:23.007] - signal: TRUE
[18:02:23.007] - resignal: FALSE
[18:02:23.007] - force: TRUE
[18:02:23.007] - relayed: [n=1] TRUE
[18:02:23.007] - queued futures: [n=1] TRUE
 - flush all
[18:02:23.008] - relayed: [n=1] TRUE
[18:02:23.008] - queued futures: [n=1] TRUE
[18:02:23.008] signalConditionsASAP(NULL, pos=0) ... done
[18:02:23.008] resolve() on list ... DONE
[18:02:23.009]  - Number of value chunks collected: 1
[18:02:23.009] Resolving 1 futures (chunks) ... DONE
[18:02:23.009] Reducing values from 1 chunks ...
[18:02:23.009]  - Number of values collected after concatenation: 2
[18:02:23.009]  - Number of values expected: 2
[18:02:23.009] Reducing values from 1 chunks ... DONE
[18:02:23.010] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[18:02:23.010] future_lapply() ...
[18:02:23.020] Number of chunks: 1
[18:02:23.020] getGlobalsAndPackagesXApply() ...
[18:02:23.020]  - future.globals: TRUE
[18:02:23.021] getGlobalsAndPackages() ...
[18:02:23.021] Searching for globals...
[18:02:23.024] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:23.024] Searching for globals ... DONE
[18:02:23.024] Resolving globals: FALSE
[18:02:23.025] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:23.026] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:23.026] - globals: [1] ‘FUN’
[18:02:23.026] 
[18:02:23.026] getGlobalsAndPackages() ... DONE
[18:02:23.027]  - globals found/used: [n=1] ‘FUN’
[18:02:23.027]  - needed namespaces: [n=0] 
[18:02:23.027] Finding globals ... DONE
[18:02:23.027]  - use_args: TRUE
[18:02:23.027]  - Getting '...' globals ...
[18:02:23.028] resolve() on list ...
[18:02:23.028]  recursive: 0
[18:02:23.029]  length: 1
[18:02:23.029]  elements: ‘...’
[18:02:23.029]  length: 0 (resolved future 1)
[18:02:23.029] resolve() on list ... DONE
[18:02:23.029]    - '...' content: [n=0] 
[18:02:23.030] List of 1
[18:02:23.030]  $ ...: list()
[18:02:23.030]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:23.030]  - attr(*, "where")=List of 1
[18:02:23.030]   ..$ ...:<environment: 0x5e4f85c254b0> 
[18:02:23.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:23.030]  - attr(*, "resolved")= logi TRUE
[18:02:23.030]  - attr(*, "total_size")= num NA
[18:02:23.035]  - Getting '...' globals ... DONE
[18:02:23.035] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:23.035] List of 2
[18:02:23.035]  $ ...future.FUN:function (x)  
[18:02:23.035]  $ ...          : list()
[18:02:23.035]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:23.035]  - attr(*, "where")=List of 2
[18:02:23.035]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:23.035]   ..$ ...          :<environment: 0x5e4f85c254b0> 
[18:02:23.035]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:23.035]  - attr(*, "resolved")= logi FALSE
[18:02:23.035]  - attr(*, "total_size")= num 4720
[18:02:23.041] Packages to be attached in all futures: [n=0] 
[18:02:23.041] getGlobalsAndPackagesXApply() ... DONE
[18:02:23.042] Number of futures (= number of chunks): 1
[18:02:23.042] Launching 1 futures (chunks) ...
[18:02:23.042] Chunk #1 of 1 ...
[18:02:23.043]  - Finding globals in 'X' for chunk #1 ...
[18:02:23.043] getGlobalsAndPackages() ...
[18:02:23.043] Searching for globals...
[18:02:23.044] 
[18:02:23.044] Searching for globals ... DONE
[18:02:23.044] - globals: [0] <none>
[18:02:23.044] getGlobalsAndPackages() ... DONE
[18:02:23.044]    + additional globals found: [n=0] 
[18:02:23.045]    + additional namespaces needed: [n=0] 
[18:02:23.045]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:23.045]  - seeds: <none>
[18:02:23.045]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:23.045] getGlobalsAndPackages() ...
[18:02:23.046] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:23.046] Resolving globals: FALSE
[18:02:23.046] Tweak future expression to call with '...' arguments ...
[18:02:23.046] {
[18:02:23.046]     do.call(function(...) {
[18:02:23.046]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:23.046]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:23.046]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:23.046]             on.exit(options(oopts), add = TRUE)
[18:02:23.046]         }
[18:02:23.046]         {
[18:02:23.046]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:23.046]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:23.046]                 ...future.FUN(...future.X_jj, ...)
[18:02:23.046]             })
[18:02:23.046]         }
[18:02:23.046]     }, args = future.call.arguments)
[18:02:23.046] }
[18:02:23.047] Tweak future expression to call with '...' arguments ... DONE
[18:02:23.047] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:23.048] 
[18:02:23.048] getGlobalsAndPackages() ... DONE
[18:02:23.048] run() for ‘Future’ ...
[18:02:23.049] - state: ‘created’
[18:02:23.049] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:23.056] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:23.056] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:23.056]   - Field: ‘label’
[18:02:23.057]   - Field: ‘local’
[18:02:23.057]   - Field: ‘owner’
[18:02:23.057]   - Field: ‘envir’
[18:02:23.057]   - Field: ‘packages’
[18:02:23.058]   - Field: ‘gc’
[18:02:23.058]   - Field: ‘conditions’
[18:02:23.058]   - Field: ‘expr’
[18:02:23.058]   - Field: ‘uuid’
[18:02:23.058]   - Field: ‘seed’
[18:02:23.059]   - Field: ‘version’
[18:02:23.059]   - Field: ‘result’
[18:02:23.059]   - Field: ‘asynchronous’
[18:02:23.059]   - Field: ‘calls’
[18:02:23.059]   - Field: ‘globals’
[18:02:23.060]   - Field: ‘stdout’
[18:02:23.060]   - Field: ‘earlySignal’
[18:02:23.060]   - Field: ‘lazy’
[18:02:23.060]   - Field: ‘state’
[18:02:23.061] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:23.061] - Launch lazy future ...
[18:02:23.061] Packages needed by the future expression (n = 0): <none>
[18:02:23.061] Packages needed by future strategies (n = 0): <none>
[18:02:23.062] {
[18:02:23.062]     {
[18:02:23.062]         {
[18:02:23.062]             ...future.startTime <- base::Sys.time()
[18:02:23.062]             {
[18:02:23.062]                 {
[18:02:23.062]                   {
[18:02:23.062]                     base::local({
[18:02:23.062]                       has_future <- base::requireNamespace("future", 
[18:02:23.062]                         quietly = TRUE)
[18:02:23.062]                       if (has_future) {
[18:02:23.062]                         ns <- base::getNamespace("future")
[18:02:23.062]                         version <- ns[[".package"]][["version"]]
[18:02:23.062]                         if (is.null(version)) 
[18:02:23.062]                           version <- utils::packageVersion("future")
[18:02:23.062]                       }
[18:02:23.062]                       else {
[18:02:23.062]                         version <- NULL
[18:02:23.062]                       }
[18:02:23.062]                       if (!has_future || version < "1.8.0") {
[18:02:23.062]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:23.062]                           "", base::R.version$version.string), 
[18:02:23.062]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:23.062]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:23.062]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:23.062]                             "release", "version")], collapse = " "), 
[18:02:23.062]                           hostname = base::Sys.info()[["nodename"]])
[18:02:23.062]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:23.062]                           info)
[18:02:23.062]                         info <- base::paste(info, collapse = "; ")
[18:02:23.062]                         if (!has_future) {
[18:02:23.062]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:23.062]                             info)
[18:02:23.062]                         }
[18:02:23.062]                         else {
[18:02:23.062]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:23.062]                             info, version)
[18:02:23.062]                         }
[18:02:23.062]                         base::stop(msg)
[18:02:23.062]                       }
[18:02:23.062]                     })
[18:02:23.062]                   }
[18:02:23.062]                   ...future.strategy.old <- future::plan("list")
[18:02:23.062]                   options(future.plan = NULL)
[18:02:23.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:23.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:23.062]                 }
[18:02:23.062]                 ...future.workdir <- getwd()
[18:02:23.062]             }
[18:02:23.062]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:23.062]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:23.062]         }
[18:02:23.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:23.062]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:23.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:23.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:23.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:23.062]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:23.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:23.062]             base::names(...future.oldOptions))
[18:02:23.062]     }
[18:02:23.062]     if (TRUE) {
[18:02:23.062]     }
[18:02:23.062]     else {
[18:02:23.062]         if (NA) {
[18:02:23.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:23.062]                 open = "w")
[18:02:23.062]         }
[18:02:23.062]         else {
[18:02:23.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:23.062]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:23.062]         }
[18:02:23.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:23.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:23.062]             base::sink(type = "output", split = FALSE)
[18:02:23.062]             base::close(...future.stdout)
[18:02:23.062]         }, add = TRUE)
[18:02:23.062]     }
[18:02:23.062]     ...future.frame <- base::sys.nframe()
[18:02:23.062]     ...future.conditions <- base::list()
[18:02:23.062]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:23.062]     if (FALSE) {
[18:02:23.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:23.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:23.062]     }
[18:02:23.062]     ...future.result <- base::tryCatch({
[18:02:23.062]         base::withCallingHandlers({
[18:02:23.062]             ...future.value <- base::withVisible(base::local({
[18:02:23.062]                 do.call(function(...) {
[18:02:23.062]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:23.062]                   if (!identical(...future.globals.maxSize.org, 
[18:02:23.062]                     ...future.globals.maxSize)) {
[18:02:23.062]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:23.062]                     on.exit(options(oopts), add = TRUE)
[18:02:23.062]                   }
[18:02:23.062]                   {
[18:02:23.062]                     lapply(seq_along(...future.elements_ii), 
[18:02:23.062]                       FUN = function(jj) {
[18:02:23.062]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:23.062]                         ...future.FUN(...future.X_jj, ...)
[18:02:23.062]                       })
[18:02:23.062]                   }
[18:02:23.062]                 }, args = future.call.arguments)
[18:02:23.062]             }))
[18:02:23.062]             future::FutureResult(value = ...future.value$value, 
[18:02:23.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:23.062]                   ...future.rng), globalenv = if (FALSE) 
[18:02:23.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:23.062]                     ...future.globalenv.names))
[18:02:23.062]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:23.062]         }, condition = base::local({
[18:02:23.062]             c <- base::c
[18:02:23.062]             inherits <- base::inherits
[18:02:23.062]             invokeRestart <- base::invokeRestart
[18:02:23.062]             length <- base::length
[18:02:23.062]             list <- base::list
[18:02:23.062]             seq.int <- base::seq.int
[18:02:23.062]             signalCondition <- base::signalCondition
[18:02:23.062]             sys.calls <- base::sys.calls
[18:02:23.062]             `[[` <- base::`[[`
[18:02:23.062]             `+` <- base::`+`
[18:02:23.062]             `<<-` <- base::`<<-`
[18:02:23.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:23.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:23.062]                   3L)]
[18:02:23.062]             }
[18:02:23.062]             function(cond) {
[18:02:23.062]                 is_error <- inherits(cond, "error")
[18:02:23.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:23.062]                   NULL)
[18:02:23.062]                 if (is_error) {
[18:02:23.062]                   sessionInformation <- function() {
[18:02:23.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:23.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:23.062]                       search = base::search(), system = base::Sys.info())
[18:02:23.062]                   }
[18:02:23.062]                   ...future.conditions[[length(...future.conditions) + 
[18:02:23.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:23.062]                     cond$call), session = sessionInformation(), 
[18:02:23.062]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:23.062]                   signalCondition(cond)
[18:02:23.062]                 }
[18:02:23.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:23.062]                 "immediateCondition"))) {
[18:02:23.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:23.062]                   ...future.conditions[[length(...future.conditions) + 
[18:02:23.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:23.062]                   if (TRUE && !signal) {
[18:02:23.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:23.062]                     {
[18:02:23.062]                       inherits <- base::inherits
[18:02:23.062]                       invokeRestart <- base::invokeRestart
[18:02:23.062]                       is.null <- base::is.null
[18:02:23.062]                       muffled <- FALSE
[18:02:23.062]                       if (inherits(cond, "message")) {
[18:02:23.062]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:23.062]                         if (muffled) 
[18:02:23.062]                           invokeRestart("muffleMessage")
[18:02:23.062]                       }
[18:02:23.062]                       else if (inherits(cond, "warning")) {
[18:02:23.062]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:23.062]                         if (muffled) 
[18:02:23.062]                           invokeRestart("muffleWarning")
[18:02:23.062]                       }
[18:02:23.062]                       else if (inherits(cond, "condition")) {
[18:02:23.062]                         if (!is.null(pattern)) {
[18:02:23.062]                           computeRestarts <- base::computeRestarts
[18:02:23.062]                           grepl <- base::grepl
[18:02:23.062]                           restarts <- computeRestarts(cond)
[18:02:23.062]                           for (restart in restarts) {
[18:02:23.062]                             name <- restart$name
[18:02:23.062]                             if (is.null(name)) 
[18:02:23.062]                               next
[18:02:23.062]                             if (!grepl(pattern, name)) 
[18:02:23.062]                               next
[18:02:23.062]                             invokeRestart(restart)
[18:02:23.062]                             muffled <- TRUE
[18:02:23.062]                             break
[18:02:23.062]                           }
[18:02:23.062]                         }
[18:02:23.062]                       }
[18:02:23.062]                       invisible(muffled)
[18:02:23.062]                     }
[18:02:23.062]                     muffleCondition(cond, pattern = "^muffle")
[18:02:23.062]                   }
[18:02:23.062]                 }
[18:02:23.062]                 else {
[18:02:23.062]                   if (TRUE) {
[18:02:23.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:23.062]                     {
[18:02:23.062]                       inherits <- base::inherits
[18:02:23.062]                       invokeRestart <- base::invokeRestart
[18:02:23.062]                       is.null <- base::is.null
[18:02:23.062]                       muffled <- FALSE
[18:02:23.062]                       if (inherits(cond, "message")) {
[18:02:23.062]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:23.062]                         if (muffled) 
[18:02:23.062]                           invokeRestart("muffleMessage")
[18:02:23.062]                       }
[18:02:23.062]                       else if (inherits(cond, "warning")) {
[18:02:23.062]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:23.062]                         if (muffled) 
[18:02:23.062]                           invokeRestart("muffleWarning")
[18:02:23.062]                       }
[18:02:23.062]                       else if (inherits(cond, "condition")) {
[18:02:23.062]                         if (!is.null(pattern)) {
[18:02:23.062]                           computeRestarts <- base::computeRestarts
[18:02:23.062]                           grepl <- base::grepl
[18:02:23.062]                           restarts <- computeRestarts(cond)
[18:02:23.062]                           for (restart in restarts) {
[18:02:23.062]                             name <- restart$name
[18:02:23.062]                             if (is.null(name)) 
[18:02:23.062]                               next
[18:02:23.062]                             if (!grepl(pattern, name)) 
[18:02:23.062]                               next
[18:02:23.062]                             invokeRestart(restart)
[18:02:23.062]                             muffled <- TRUE
[18:02:23.062]                             break
[18:02:23.062]                           }
[18:02:23.062]                         }
[18:02:23.062]                       }
[18:02:23.062]                       invisible(muffled)
[18:02:23.062]                     }
[18:02:23.062]                     muffleCondition(cond, pattern = "^muffle")
[18:02:23.062]                   }
[18:02:23.062]                 }
[18:02:23.062]             }
[18:02:23.062]         }))
[18:02:23.062]     }, error = function(ex) {
[18:02:23.062]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:23.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:23.062]                 ...future.rng), started = ...future.startTime, 
[18:02:23.062]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:23.062]             version = "1.8"), class = "FutureResult")
[18:02:23.062]     }, finally = {
[18:02:23.062]         if (!identical(...future.workdir, getwd())) 
[18:02:23.062]             setwd(...future.workdir)
[18:02:23.062]         {
[18:02:23.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:23.062]                 ...future.oldOptions$nwarnings <- NULL
[18:02:23.062]             }
[18:02:23.062]             base::options(...future.oldOptions)
[18:02:23.062]             if (.Platform$OS.type == "windows") {
[18:02:23.062]                 old_names <- names(...future.oldEnvVars)
[18:02:23.062]                 envs <- base::Sys.getenv()
[18:02:23.062]                 names <- names(envs)
[18:02:23.062]                 common <- intersect(names, old_names)
[18:02:23.062]                 added <- setdiff(names, old_names)
[18:02:23.062]                 removed <- setdiff(old_names, names)
[18:02:23.062]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:23.062]                   envs[common]]
[18:02:23.062]                 NAMES <- toupper(changed)
[18:02:23.062]                 args <- list()
[18:02:23.062]                 for (kk in seq_along(NAMES)) {
[18:02:23.062]                   name <- changed[[kk]]
[18:02:23.062]                   NAME <- NAMES[[kk]]
[18:02:23.062]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:23.062]                     next
[18:02:23.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:23.062]                 }
[18:02:23.062]                 NAMES <- toupper(added)
[18:02:23.062]                 for (kk in seq_along(NAMES)) {
[18:02:23.062]                   name <- added[[kk]]
[18:02:23.062]                   NAME <- NAMES[[kk]]
[18:02:23.062]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:23.062]                     next
[18:02:23.062]                   args[[name]] <- ""
[18:02:23.062]                 }
[18:02:23.062]                 NAMES <- toupper(removed)
[18:02:23.062]                 for (kk in seq_along(NAMES)) {
[18:02:23.062]                   name <- removed[[kk]]
[18:02:23.062]                   NAME <- NAMES[[kk]]
[18:02:23.062]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:23.062]                     next
[18:02:23.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:23.062]                 }
[18:02:23.062]                 if (length(args) > 0) 
[18:02:23.062]                   base::do.call(base::Sys.setenv, args = args)
[18:02:23.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:23.062]             }
[18:02:23.062]             else {
[18:02:23.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:23.062]             }
[18:02:23.062]             {
[18:02:23.062]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:23.062]                   0L) {
[18:02:23.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:23.062]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:23.062]                   base::options(opts)
[18:02:23.062]                 }
[18:02:23.062]                 {
[18:02:23.062]                   {
[18:02:23.062]                     NULL
[18:02:23.062]                     RNGkind("Mersenne-Twister")
[18:02:23.062]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:23.062]                       inherits = FALSE)
[18:02:23.062]                   }
[18:02:23.062]                   options(future.plan = NULL)
[18:02:23.062]                   if (is.na(NA_character_)) 
[18:02:23.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:23.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:23.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:23.062]                     .init = FALSE)
[18:02:23.062]                 }
[18:02:23.062]             }
[18:02:23.062]         }
[18:02:23.062]     })
[18:02:23.062]     if (FALSE) {
[18:02:23.062]         base::sink(type = "output", split = FALSE)
[18:02:23.062]         if (NA) {
[18:02:23.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:23.062]         }
[18:02:23.062]         else {
[18:02:23.062]             ...future.result["stdout"] <- base::list(NULL)
[18:02:23.062]         }
[18:02:23.062]         base::close(...future.stdout)
[18:02:23.062]         ...future.stdout <- NULL
[18:02:23.062]     }
[18:02:23.062]     ...future.result$conditions <- ...future.conditions
[18:02:23.062]     ...future.result$finished <- base::Sys.time()
[18:02:23.062]     ...future.result
[18:02:23.062] }
[18:02:23.066] assign_globals() ...
[18:02:23.066] List of 5
[18:02:23.066]  $ ...future.FUN            :function (x)  
[18:02:23.066]  $ future.call.arguments    : list()
[18:02:23.066]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:23.066]  $ ...future.elements_ii    :List of 2
[18:02:23.066]   ..$ : int 1
[18:02:23.066]   ..$ : int 0
[18:02:23.066]  $ ...future.seeds_ii       : NULL
[18:02:23.066]  $ ...future.globals.maxSize: NULL
[18:02:23.066]  - attr(*, "where")=List of 5
[18:02:23.066]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:23.066]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:23.066]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:23.066]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:23.066]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:23.066]  - attr(*, "resolved")= logi FALSE
[18:02:23.066]  - attr(*, "total_size")= num 4720
[18:02:23.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:23.066]  - attr(*, "already-done")= logi TRUE
[18:02:23.079] - reassign environment for ‘...future.FUN’
[18:02:23.079] - copied ‘...future.FUN’ to environment
[18:02:23.079] - copied ‘future.call.arguments’ to environment
[18:02:23.079] - copied ‘...future.elements_ii’ to environment
[18:02:23.080] - copied ‘...future.seeds_ii’ to environment
[18:02:23.080] - copied ‘...future.globals.maxSize’ to environment
[18:02:23.080] assign_globals() ... done
[18:02:23.080] plan(): Setting new future strategy stack:
[18:02:23.081] List of future strategies:
[18:02:23.081] 1. sequential:
[18:02:23.081]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:23.081]    - tweaked: FALSE
[18:02:23.081]    - call: NULL
[18:02:23.081] plan(): nbrOfWorkers() = 1
[18:02:23.584] plan(): Setting new future strategy stack:
[18:02:23.584] List of future strategies:
[18:02:23.584] 1. multicore:
[18:02:23.584]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:23.584]    - tweaked: FALSE
[18:02:23.584]    - call: plan(strategy)
[18:02:23.590] plan(): nbrOfWorkers() = 1
[18:02:23.591] SequentialFuture started (and completed)
[18:02:23.591] - Launch lazy future ... done
[18:02:23.591] run() for ‘SequentialFuture’ ... done
[18:02:23.592] Created future:
[18:02:23.592] SequentialFuture:
[18:02:23.592] Label: ‘future_lapply-1’
[18:02:23.592] Expression:
[18:02:23.592] {
[18:02:23.592]     do.call(function(...) {
[18:02:23.592]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:23.592]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:23.592]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:23.592]             on.exit(options(oopts), add = TRUE)
[18:02:23.592]         }
[18:02:23.592]         {
[18:02:23.592]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:23.592]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:23.592]                 ...future.FUN(...future.X_jj, ...)
[18:02:23.592]             })
[18:02:23.592]         }
[18:02:23.592]     }, args = future.call.arguments)
[18:02:23.592] }
[18:02:23.592] Lazy evaluation: FALSE
[18:02:23.592] Asynchronous evaluation: FALSE
[18:02:23.592] Local evaluation: TRUE
[18:02:23.592] Environment: R_GlobalEnv
[18:02:23.592] Capture standard output: NA
[18:02:23.592] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:23.592] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:23.592] Packages: <none>
[18:02:23.592] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:23.592] Resolved: TRUE
[18:02:23.592] Value: 112 bytes of class ‘list’
[18:02:23.592] Early signaling: FALSE
[18:02:23.592] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:23.592] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:23.594] Chunk #1 of 1 ... DONE
[18:02:23.594] Launching 1 futures (chunks) ... DONE
[18:02:23.594] Resolving 1 futures (chunks) ...
[18:02:23.595] resolve() on list ...
[18:02:23.595]  recursive: 0
[18:02:23.595]  length: 1
[18:02:23.595] 
[18:02:23.595] resolved() for ‘SequentialFuture’ ...
[18:02:23.595] - state: ‘finished’
[18:02:23.596] - run: TRUE
[18:02:23.596] - result: ‘FutureResult’
[18:02:23.596] resolved() for ‘SequentialFuture’ ... done
[18:02:23.596] Future #1
[18:02:23.597] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:23.597] - nx: 1
[18:02:23.597] - relay: TRUE
[18:02:23.597] - stdout: TRUE
[18:02:23.597] - signal: TRUE
[18:02:23.597] - resignal: FALSE
[18:02:23.598] - force: TRUE
[18:02:23.598] - relayed: [n=1] FALSE
[18:02:23.598] - queued futures: [n=1] FALSE
[18:02:23.598]  - until=1
[18:02:23.598]  - relaying element #1
[18:02:23.599] - relayed: [n=1] TRUE
[18:02:23.599] - queued futures: [n=1] TRUE
[18:02:23.599] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:23.599]  length: 0 (resolved future 1)
[18:02:23.600] Relaying remaining futures
[18:02:23.600] signalConditionsASAP(NULL, pos=0) ...
[18:02:23.600] - nx: 1
[18:02:23.600] - relay: TRUE
[18:02:23.600] - stdout: TRUE
[18:02:23.600] - signal: TRUE
[18:02:23.601] - resignal: FALSE
[18:02:23.601] - force: TRUE
[18:02:23.601] - relayed: [n=1] TRUE
[18:02:23.601] - queued futures: [n=1] TRUE
 - flush all
[18:02:23.601] - relayed: [n=1] TRUE
[18:02:23.602] - queued futures: [n=1] TRUE
[18:02:23.602] signalConditionsASAP(NULL, pos=0) ... done
[18:02:23.602] resolve() on list ... DONE
[18:02:23.602]  - Number of value chunks collected: 1
[18:02:23.602] Resolving 1 futures (chunks) ... DONE
[18:02:23.603] Reducing values from 1 chunks ...
[18:02:23.603]  - Number of values collected after concatenation: 2
[18:02:23.603]  - Number of values expected: 2
[18:02:23.603] Reducing values from 1 chunks ... DONE
[18:02:23.603] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[18:02:23.604] future_mapply() ...
[18:02:23.610] Number of chunks: 1
[18:02:23.610] getGlobalsAndPackagesXApply() ...
[18:02:23.610]  - future.globals: TRUE
[18:02:23.611] getGlobalsAndPackages() ...
[18:02:23.611] Searching for globals...
[18:02:23.614] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:23.614] Searching for globals ... DONE
[18:02:23.614] Resolving globals: FALSE
[18:02:23.615] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:23.616] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:23.616] - globals: [1] ‘FUN’
[18:02:23.616] 
[18:02:23.617] getGlobalsAndPackages() ... DONE
[18:02:23.617]  - globals found/used: [n=1] ‘FUN’
[18:02:23.617]  - needed namespaces: [n=0] 
[18:02:23.617] Finding globals ... DONE
[18:02:23.618] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:23.618] List of 2
[18:02:23.618]  $ ...future.FUN:function (x, y)  
[18:02:23.618]  $ MoreArgs     : NULL
[18:02:23.618]  - attr(*, "where")=List of 2
[18:02:23.618]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:23.618]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:23.618]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:23.618]  - attr(*, "resolved")= logi FALSE
[18:02:23.618]  - attr(*, "total_size")= num NA
[18:02:23.623] Packages to be attached in all futures: [n=0] 
[18:02:23.623] getGlobalsAndPackagesXApply() ... DONE
[18:02:23.623] Number of futures (= number of chunks): 1
[18:02:23.623] Launching 1 futures (chunks) ...
[18:02:23.624] Chunk #1 of 1 ...
[18:02:23.624]  - Finding globals in '...' for chunk #1 ...
[18:02:23.624] getGlobalsAndPackages() ...
[18:02:23.624] Searching for globals...
[18:02:23.625] 
[18:02:23.625] Searching for globals ... DONE
[18:02:23.625] - globals: [0] <none>
[18:02:23.626] getGlobalsAndPackages() ... DONE
[18:02:23.626]    + additional globals found: [n=0] 
[18:02:23.626]    + additional namespaces needed: [n=0] 
[18:02:23.626]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:23.626]  - seeds: <none>
[18:02:23.626]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:23.627] getGlobalsAndPackages() ...
[18:02:23.627] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:23.627] Resolving globals: FALSE
[18:02:23.628] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[18:02:23.629] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:23.629] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:23.630] 
[18:02:23.630] getGlobalsAndPackages() ... DONE
[18:02:23.630] run() for ‘Future’ ...
[18:02:23.630] - state: ‘created’
[18:02:23.631] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:23.639] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:23.640] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:23.640]   - Field: ‘label’
[18:02:23.640]   - Field: ‘local’
[18:02:23.640]   - Field: ‘owner’
[18:02:23.641]   - Field: ‘envir’
[18:02:23.641]   - Field: ‘packages’
[18:02:23.641]   - Field: ‘gc’
[18:02:23.641]   - Field: ‘conditions’
[18:02:23.641]   - Field: ‘expr’
[18:02:23.642]   - Field: ‘uuid’
[18:02:23.642]   - Field: ‘seed’
[18:02:23.642]   - Field: ‘version’
[18:02:23.642]   - Field: ‘result’
[18:02:23.642]   - Field: ‘asynchronous’
[18:02:23.643]   - Field: ‘calls’
[18:02:23.643]   - Field: ‘globals’
[18:02:23.643]   - Field: ‘stdout’
[18:02:23.643]   - Field: ‘earlySignal’
[18:02:23.643]   - Field: ‘lazy’
[18:02:23.644]   - Field: ‘state’
[18:02:23.644] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:23.644] - Launch lazy future ...
[18:02:23.644] Packages needed by the future expression (n = 0): <none>
[18:02:23.645] Packages needed by future strategies (n = 0): <none>
[18:02:23.645] {
[18:02:23.645]     {
[18:02:23.645]         {
[18:02:23.645]             ...future.startTime <- base::Sys.time()
[18:02:23.645]             {
[18:02:23.645]                 {
[18:02:23.645]                   {
[18:02:23.645]                     base::local({
[18:02:23.645]                       has_future <- base::requireNamespace("future", 
[18:02:23.645]                         quietly = TRUE)
[18:02:23.645]                       if (has_future) {
[18:02:23.645]                         ns <- base::getNamespace("future")
[18:02:23.645]                         version <- ns[[".package"]][["version"]]
[18:02:23.645]                         if (is.null(version)) 
[18:02:23.645]                           version <- utils::packageVersion("future")
[18:02:23.645]                       }
[18:02:23.645]                       else {
[18:02:23.645]                         version <- NULL
[18:02:23.645]                       }
[18:02:23.645]                       if (!has_future || version < "1.8.0") {
[18:02:23.645]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:23.645]                           "", base::R.version$version.string), 
[18:02:23.645]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:23.645]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:23.645]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:23.645]                             "release", "version")], collapse = " "), 
[18:02:23.645]                           hostname = base::Sys.info()[["nodename"]])
[18:02:23.645]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:23.645]                           info)
[18:02:23.645]                         info <- base::paste(info, collapse = "; ")
[18:02:23.645]                         if (!has_future) {
[18:02:23.645]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:23.645]                             info)
[18:02:23.645]                         }
[18:02:23.645]                         else {
[18:02:23.645]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:23.645]                             info, version)
[18:02:23.645]                         }
[18:02:23.645]                         base::stop(msg)
[18:02:23.645]                       }
[18:02:23.645]                     })
[18:02:23.645]                   }
[18:02:23.645]                   ...future.strategy.old <- future::plan("list")
[18:02:23.645]                   options(future.plan = NULL)
[18:02:23.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:23.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:23.645]                 }
[18:02:23.645]                 ...future.workdir <- getwd()
[18:02:23.645]             }
[18:02:23.645]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:23.645]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:23.645]         }
[18:02:23.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:23.645]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:23.645]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:23.645]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:23.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:23.645]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:23.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:23.645]             base::names(...future.oldOptions))
[18:02:23.645]     }
[18:02:23.645]     if (FALSE) {
[18:02:23.645]     }
[18:02:23.645]     else {
[18:02:23.645]         if (FALSE) {
[18:02:23.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:23.645]                 open = "w")
[18:02:23.645]         }
[18:02:23.645]         else {
[18:02:23.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:23.645]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:23.645]         }
[18:02:23.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:23.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:23.645]             base::sink(type = "output", split = FALSE)
[18:02:23.645]             base::close(...future.stdout)
[18:02:23.645]         }, add = TRUE)
[18:02:23.645]     }
[18:02:23.645]     ...future.frame <- base::sys.nframe()
[18:02:23.645]     ...future.conditions <- base::list()
[18:02:23.645]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:23.645]     if (FALSE) {
[18:02:23.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:23.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:23.645]     }
[18:02:23.645]     ...future.result <- base::tryCatch({
[18:02:23.645]         base::withCallingHandlers({
[18:02:23.645]             ...future.value <- base::withVisible(base::local({
[18:02:23.645]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:23.645]                 if (!identical(...future.globals.maxSize.org, 
[18:02:23.645]                   ...future.globals.maxSize)) {
[18:02:23.645]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:23.645]                   on.exit(options(oopts), add = TRUE)
[18:02:23.645]                 }
[18:02:23.645]                 {
[18:02:23.645]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:23.645]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:23.645]                     USE.NAMES = FALSE)
[18:02:23.645]                   do.call(mapply, args = args)
[18:02:23.645]                 }
[18:02:23.645]             }))
[18:02:23.645]             future::FutureResult(value = ...future.value$value, 
[18:02:23.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:23.645]                   ...future.rng), globalenv = if (FALSE) 
[18:02:23.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:23.645]                     ...future.globalenv.names))
[18:02:23.645]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:23.645]         }, condition = base::local({
[18:02:23.645]             c <- base::c
[18:02:23.645]             inherits <- base::inherits
[18:02:23.645]             invokeRestart <- base::invokeRestart
[18:02:23.645]             length <- base::length
[18:02:23.645]             list <- base::list
[18:02:23.645]             seq.int <- base::seq.int
[18:02:23.645]             signalCondition <- base::signalCondition
[18:02:23.645]             sys.calls <- base::sys.calls
[18:02:23.645]             `[[` <- base::`[[`
[18:02:23.645]             `+` <- base::`+`
[18:02:23.645]             `<<-` <- base::`<<-`
[18:02:23.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:23.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:23.645]                   3L)]
[18:02:23.645]             }
[18:02:23.645]             function(cond) {
[18:02:23.645]                 is_error <- inherits(cond, "error")
[18:02:23.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:23.645]                   NULL)
[18:02:23.645]                 if (is_error) {
[18:02:23.645]                   sessionInformation <- function() {
[18:02:23.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:23.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:23.645]                       search = base::search(), system = base::Sys.info())
[18:02:23.645]                   }
[18:02:23.645]                   ...future.conditions[[length(...future.conditions) + 
[18:02:23.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:23.645]                     cond$call), session = sessionInformation(), 
[18:02:23.645]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:23.645]                   signalCondition(cond)
[18:02:23.645]                 }
[18:02:23.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:23.645]                 "immediateCondition"))) {
[18:02:23.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:23.645]                   ...future.conditions[[length(...future.conditions) + 
[18:02:23.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:23.645]                   if (TRUE && !signal) {
[18:02:23.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:23.645]                     {
[18:02:23.645]                       inherits <- base::inherits
[18:02:23.645]                       invokeRestart <- base::invokeRestart
[18:02:23.645]                       is.null <- base::is.null
[18:02:23.645]                       muffled <- FALSE
[18:02:23.645]                       if (inherits(cond, "message")) {
[18:02:23.645]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:23.645]                         if (muffled) 
[18:02:23.645]                           invokeRestart("muffleMessage")
[18:02:23.645]                       }
[18:02:23.645]                       else if (inherits(cond, "warning")) {
[18:02:23.645]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:23.645]                         if (muffled) 
[18:02:23.645]                           invokeRestart("muffleWarning")
[18:02:23.645]                       }
[18:02:23.645]                       else if (inherits(cond, "condition")) {
[18:02:23.645]                         if (!is.null(pattern)) {
[18:02:23.645]                           computeRestarts <- base::computeRestarts
[18:02:23.645]                           grepl <- base::grepl
[18:02:23.645]                           restarts <- computeRestarts(cond)
[18:02:23.645]                           for (restart in restarts) {
[18:02:23.645]                             name <- restart$name
[18:02:23.645]                             if (is.null(name)) 
[18:02:23.645]                               next
[18:02:23.645]                             if (!grepl(pattern, name)) 
[18:02:23.645]                               next
[18:02:23.645]                             invokeRestart(restart)
[18:02:23.645]                             muffled <- TRUE
[18:02:23.645]                             break
[18:02:23.645]                           }
[18:02:23.645]                         }
[18:02:23.645]                       }
[18:02:23.645]                       invisible(muffled)
[18:02:23.645]                     }
[18:02:23.645]                     muffleCondition(cond, pattern = "^muffle")
[18:02:23.645]                   }
[18:02:23.645]                 }
[18:02:23.645]                 else {
[18:02:23.645]                   if (TRUE) {
[18:02:23.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:23.645]                     {
[18:02:23.645]                       inherits <- base::inherits
[18:02:23.645]                       invokeRestart <- base::invokeRestart
[18:02:23.645]                       is.null <- base::is.null
[18:02:23.645]                       muffled <- FALSE
[18:02:23.645]                       if (inherits(cond, "message")) {
[18:02:23.645]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:23.645]                         if (muffled) 
[18:02:23.645]                           invokeRestart("muffleMessage")
[18:02:23.645]                       }
[18:02:23.645]                       else if (inherits(cond, "warning")) {
[18:02:23.645]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:23.645]                         if (muffled) 
[18:02:23.645]                           invokeRestart("muffleWarning")
[18:02:23.645]                       }
[18:02:23.645]                       else if (inherits(cond, "condition")) {
[18:02:23.645]                         if (!is.null(pattern)) {
[18:02:23.645]                           computeRestarts <- base::computeRestarts
[18:02:23.645]                           grepl <- base::grepl
[18:02:23.645]                           restarts <- computeRestarts(cond)
[18:02:23.645]                           for (restart in restarts) {
[18:02:23.645]                             name <- restart$name
[18:02:23.645]                             if (is.null(name)) 
[18:02:23.645]                               next
[18:02:23.645]                             if (!grepl(pattern, name)) 
[18:02:23.645]                               next
[18:02:23.645]                             invokeRestart(restart)
[18:02:23.645]                             muffled <- TRUE
[18:02:23.645]                             break
[18:02:23.645]                           }
[18:02:23.645]                         }
[18:02:23.645]                       }
[18:02:23.645]                       invisible(muffled)
[18:02:23.645]                     }
[18:02:23.645]                     muffleCondition(cond, pattern = "^muffle")
[18:02:23.645]                   }
[18:02:23.645]                 }
[18:02:23.645]             }
[18:02:23.645]         }))
[18:02:23.645]     }, error = function(ex) {
[18:02:23.645]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:23.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:23.645]                 ...future.rng), started = ...future.startTime, 
[18:02:23.645]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:23.645]             version = "1.8"), class = "FutureResult")
[18:02:23.645]     }, finally = {
[18:02:23.645]         if (!identical(...future.workdir, getwd())) 
[18:02:23.645]             setwd(...future.workdir)
[18:02:23.645]         {
[18:02:23.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:23.645]                 ...future.oldOptions$nwarnings <- NULL
[18:02:23.645]             }
[18:02:23.645]             base::options(...future.oldOptions)
[18:02:23.645]             if (.Platform$OS.type == "windows") {
[18:02:23.645]                 old_names <- names(...future.oldEnvVars)
[18:02:23.645]                 envs <- base::Sys.getenv()
[18:02:23.645]                 names <- names(envs)
[18:02:23.645]                 common <- intersect(names, old_names)
[18:02:23.645]                 added <- setdiff(names, old_names)
[18:02:23.645]                 removed <- setdiff(old_names, names)
[18:02:23.645]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:23.645]                   envs[common]]
[18:02:23.645]                 NAMES <- toupper(changed)
[18:02:23.645]                 args <- list()
[18:02:23.645]                 for (kk in seq_along(NAMES)) {
[18:02:23.645]                   name <- changed[[kk]]
[18:02:23.645]                   NAME <- NAMES[[kk]]
[18:02:23.645]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:23.645]                     next
[18:02:23.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:23.645]                 }
[18:02:23.645]                 NAMES <- toupper(added)
[18:02:23.645]                 for (kk in seq_along(NAMES)) {
[18:02:23.645]                   name <- added[[kk]]
[18:02:23.645]                   NAME <- NAMES[[kk]]
[18:02:23.645]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:23.645]                     next
[18:02:23.645]                   args[[name]] <- ""
[18:02:23.645]                 }
[18:02:23.645]                 NAMES <- toupper(removed)
[18:02:23.645]                 for (kk in seq_along(NAMES)) {
[18:02:23.645]                   name <- removed[[kk]]
[18:02:23.645]                   NAME <- NAMES[[kk]]
[18:02:23.645]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:23.645]                     next
[18:02:23.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:23.645]                 }
[18:02:23.645]                 if (length(args) > 0) 
[18:02:23.645]                   base::do.call(base::Sys.setenv, args = args)
[18:02:23.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:23.645]             }
[18:02:23.645]             else {
[18:02:23.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:23.645]             }
[18:02:23.645]             {
[18:02:23.645]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:23.645]                   0L) {
[18:02:23.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:23.645]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:23.645]                   base::options(opts)
[18:02:23.645]                 }
[18:02:23.645]                 {
[18:02:23.645]                   {
[18:02:23.645]                     NULL
[18:02:23.645]                     RNGkind("Mersenne-Twister")
[18:02:23.645]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:23.645]                       inherits = FALSE)
[18:02:23.645]                   }
[18:02:23.645]                   options(future.plan = NULL)
[18:02:23.645]                   if (is.na(NA_character_)) 
[18:02:23.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:23.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:23.645]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:23.645]                     .init = FALSE)
[18:02:23.645]                 }
[18:02:23.645]             }
[18:02:23.645]         }
[18:02:23.645]     })
[18:02:23.645]     if (TRUE) {
[18:02:23.645]         base::sink(type = "output", split = FALSE)
[18:02:23.645]         if (FALSE) {
[18:02:23.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:23.645]         }
[18:02:23.645]         else {
[18:02:23.645]             ...future.result["stdout"] <- base::list(NULL)
[18:02:23.645]         }
[18:02:23.645]         base::close(...future.stdout)
[18:02:23.645]         ...future.stdout <- NULL
[18:02:23.645]     }
[18:02:23.645]     ...future.result$conditions <- ...future.conditions
[18:02:23.645]     ...future.result$finished <- base::Sys.time()
[18:02:23.645]     ...future.result
[18:02:23.645] }
[18:02:23.649] assign_globals() ...
[18:02:23.649] List of 5
[18:02:23.649]  $ ...future.FUN            :function (x, y)  
[18:02:23.649]  $ MoreArgs                 : NULL
[18:02:23.649]  $ ...future.elements_ii    :List of 2
[18:02:23.649]   ..$ :List of 2
[18:02:23.649]   .. ..$ : int 1
[18:02:23.649]   .. ..$ : int 0
[18:02:23.649]   ..$ :List of 2
[18:02:23.649]   .. ..$ : int 0
[18:02:23.649]   .. ..$ : int 1
[18:02:23.649]  $ ...future.seeds_ii       : NULL
[18:02:23.649]  $ ...future.globals.maxSize: NULL
[18:02:23.649]  - attr(*, "where")=List of 5
[18:02:23.649]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:23.649]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:23.649]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:23.649]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:23.649]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:23.649]  - attr(*, "resolved")= logi FALSE
[18:02:23.649]  - attr(*, "total_size")= num 6480
[18:02:23.649]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:23.649]  - attr(*, "already-done")= logi TRUE
[18:02:23.660] - reassign environment for ‘...future.FUN’
[18:02:23.661] - copied ‘...future.FUN’ to environment
[18:02:23.661] - copied ‘MoreArgs’ to environment
[18:02:23.661] - copied ‘...future.elements_ii’ to environment
[18:02:23.661] - copied ‘...future.seeds_ii’ to environment
[18:02:23.661] - copied ‘...future.globals.maxSize’ to environment
[18:02:23.662] assign_globals() ... done
[18:02:23.662] plan(): Setting new future strategy stack:
[18:02:23.662] List of future strategies:
[18:02:23.662] 1. sequential:
[18:02:23.662]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:23.662]    - tweaked: FALSE
[18:02:23.662]    - call: NULL
[18:02:23.663] plan(): nbrOfWorkers() = 1
[18:02:24.166] plan(): Setting new future strategy stack:
[18:02:24.166] List of future strategies:
[18:02:24.166] 1. multicore:
[18:02:24.166]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:24.166]    - tweaked: FALSE
[18:02:24.166]    - call: plan(strategy)
[18:02:24.172] plan(): nbrOfWorkers() = 1
[18:02:24.173] SequentialFuture started (and completed)
[18:02:24.173] - Launch lazy future ... done
[18:02:24.173] run() for ‘SequentialFuture’ ... done
[18:02:24.174] Created future:
[18:02:24.174] SequentialFuture:
[18:02:24.174] Label: ‘future_mapply-1’
[18:02:24.174] Expression:
[18:02:24.174] {
[18:02:24.174]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:24.174]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:24.174]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:24.174]         on.exit(options(oopts), add = TRUE)
[18:02:24.174]     }
[18:02:24.174]     {
[18:02:24.174]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:24.174]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:24.174]         do.call(mapply, args = args)
[18:02:24.174]     }
[18:02:24.174] }
[18:02:24.174] Lazy evaluation: FALSE
[18:02:24.174] Asynchronous evaluation: FALSE
[18:02:24.174] Local evaluation: TRUE
[18:02:24.174] Environment: R_GlobalEnv
[18:02:24.174] Capture standard output: FALSE
[18:02:24.174] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:24.174] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:24.174] Packages: <none>
[18:02:24.174] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:24.174] Resolved: TRUE
[18:02:24.174] Value: 224 bytes of class ‘list’
[18:02:24.174] Early signaling: FALSE
[18:02:24.174] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:24.174] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:24.176] Chunk #1 of 1 ... DONE
[18:02:24.176] Launching 1 futures (chunks) ... DONE
[18:02:24.176] Resolving 1 futures (chunks) ...
[18:02:24.177] resolve() on list ...
[18:02:24.177]  recursive: 0
[18:02:24.177]  length: 1
[18:02:24.177] 
[18:02:24.178] resolved() for ‘SequentialFuture’ ...
[18:02:24.178] - state: ‘finished’
[18:02:24.178] - run: TRUE
[18:02:24.178] - result: ‘FutureResult’
[18:02:24.179] resolved() for ‘SequentialFuture’ ... done
[18:02:24.179] Future #1
[18:02:24.179] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:24.179] - nx: 1
[18:02:24.179] - relay: TRUE
[18:02:24.180] - stdout: TRUE
[18:02:24.180] - signal: TRUE
[18:02:24.180] - resignal: FALSE
[18:02:24.180] - force: TRUE
[18:02:24.180] - relayed: [n=1] FALSE
[18:02:24.181] - queued futures: [n=1] FALSE
[18:02:24.181]  - until=1
[18:02:24.181]  - relaying element #1
[18:02:24.181] - relayed: [n=1] TRUE
[18:02:24.182] - queued futures: [n=1] TRUE
[18:02:24.182] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:24.182]  length: 0 (resolved future 1)
[18:02:24.182] Relaying remaining futures
[18:02:24.182] signalConditionsASAP(NULL, pos=0) ...
[18:02:24.183] - nx: 1
[18:02:24.183] - relay: TRUE
[18:02:24.183] - stdout: TRUE
[18:02:24.183] - signal: TRUE
[18:02:24.183] - resignal: FALSE
[18:02:24.184] - force: TRUE
[18:02:24.184] - relayed: [n=1] TRUE
[18:02:24.184] - queued futures: [n=1] TRUE
 - flush all
[18:02:24.184] - relayed: [n=1] TRUE
[18:02:24.184] - queued futures: [n=1] TRUE
[18:02:24.185] signalConditionsASAP(NULL, pos=0) ... done
[18:02:24.185] resolve() on list ... DONE
[18:02:24.185]  - Number of value chunks collected: 1
[18:02:24.185] Resolving 1 futures (chunks) ... DONE
[18:02:24.186] Reducing values from 1 chunks ...
[18:02:24.186]  - Number of values collected after concatenation: 2
[18:02:24.186]  - Number of values expected: 2
[18:02:24.186] Reducing values from 1 chunks ... DONE
[18:02:24.186] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[18:02:24.187] future_mapply() ...
[18:02:24.193] Number of chunks: 1
[18:02:24.193] getGlobalsAndPackagesXApply() ...
[18:02:24.194]  - future.globals: TRUE
[18:02:24.194] getGlobalsAndPackages() ...
[18:02:24.194] Searching for globals...
[18:02:24.198] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:24.198] Searching for globals ... DONE
[18:02:24.198] Resolving globals: FALSE
[18:02:24.199] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:24.203] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:24.203] - globals: [1] ‘FUN’
[18:02:24.203] 
[18:02:24.203] getGlobalsAndPackages() ... DONE
[18:02:24.204]  - globals found/used: [n=1] ‘FUN’
[18:02:24.204]  - needed namespaces: [n=0] 
[18:02:24.204] Finding globals ... DONE
[18:02:24.204] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:24.205] List of 2
[18:02:24.205]  $ ...future.FUN:function (x, y)  
[18:02:24.205]  $ MoreArgs     : NULL
[18:02:24.205]  - attr(*, "where")=List of 2
[18:02:24.205]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:24.205]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:24.205]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:24.205]  - attr(*, "resolved")= logi FALSE
[18:02:24.205]  - attr(*, "total_size")= num NA
[18:02:24.210] Packages to be attached in all futures: [n=0] 
[18:02:24.210] getGlobalsAndPackagesXApply() ... DONE
[18:02:24.211] Number of futures (= number of chunks): 1
[18:02:24.211] Launching 1 futures (chunks) ...
[18:02:24.211] Chunk #1 of 1 ...
[18:02:24.211]  - Finding globals in '...' for chunk #1 ...
[18:02:24.212] getGlobalsAndPackages() ...
[18:02:24.212] Searching for globals...
[18:02:24.212] 
[18:02:24.213] Searching for globals ... DONE
[18:02:24.213] - globals: [0] <none>
[18:02:24.213] getGlobalsAndPackages() ... DONE
[18:02:24.213]    + additional globals found: [n=0] 
[18:02:24.214]    + additional namespaces needed: [n=0] 
[18:02:24.214]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:24.214]  - seeds: <none>
[18:02:24.214]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:24.214] getGlobalsAndPackages() ...
[18:02:24.214] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:24.215] Resolving globals: FALSE
[18:02:24.216] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[18:02:24.217] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:24.217] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:24.217] 
[18:02:24.218] getGlobalsAndPackages() ... DONE
[18:02:24.218] run() for ‘Future’ ...
[18:02:24.218] - state: ‘created’
[18:02:24.219] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:24.225] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:24.225] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:24.225]   - Field: ‘label’
[18:02:24.226]   - Field: ‘local’
[18:02:24.226]   - Field: ‘owner’
[18:02:24.226]   - Field: ‘envir’
[18:02:24.226]   - Field: ‘packages’
[18:02:24.227]   - Field: ‘gc’
[18:02:24.227]   - Field: ‘conditions’
[18:02:24.227]   - Field: ‘expr’
[18:02:24.227]   - Field: ‘uuid’
[18:02:24.227]   - Field: ‘seed’
[18:02:24.228]   - Field: ‘version’
[18:02:24.228]   - Field: ‘result’
[18:02:24.228]   - Field: ‘asynchronous’
[18:02:24.228]   - Field: ‘calls’
[18:02:24.229]   - Field: ‘globals’
[18:02:24.229]   - Field: ‘stdout’
[18:02:24.229]   - Field: ‘earlySignal’
[18:02:24.229]   - Field: ‘lazy’
[18:02:24.229]   - Field: ‘state’
[18:02:24.230] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:24.230] - Launch lazy future ...
[18:02:24.230] Packages needed by the future expression (n = 0): <none>
[18:02:24.230] Packages needed by future strategies (n = 0): <none>
[18:02:24.231] {
[18:02:24.231]     {
[18:02:24.231]         {
[18:02:24.231]             ...future.startTime <- base::Sys.time()
[18:02:24.231]             {
[18:02:24.231]                 {
[18:02:24.231]                   {
[18:02:24.231]                     base::local({
[18:02:24.231]                       has_future <- base::requireNamespace("future", 
[18:02:24.231]                         quietly = TRUE)
[18:02:24.231]                       if (has_future) {
[18:02:24.231]                         ns <- base::getNamespace("future")
[18:02:24.231]                         version <- ns[[".package"]][["version"]]
[18:02:24.231]                         if (is.null(version)) 
[18:02:24.231]                           version <- utils::packageVersion("future")
[18:02:24.231]                       }
[18:02:24.231]                       else {
[18:02:24.231]                         version <- NULL
[18:02:24.231]                       }
[18:02:24.231]                       if (!has_future || version < "1.8.0") {
[18:02:24.231]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:24.231]                           "", base::R.version$version.string), 
[18:02:24.231]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:24.231]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:24.231]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:24.231]                             "release", "version")], collapse = " "), 
[18:02:24.231]                           hostname = base::Sys.info()[["nodename"]])
[18:02:24.231]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:24.231]                           info)
[18:02:24.231]                         info <- base::paste(info, collapse = "; ")
[18:02:24.231]                         if (!has_future) {
[18:02:24.231]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:24.231]                             info)
[18:02:24.231]                         }
[18:02:24.231]                         else {
[18:02:24.231]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:24.231]                             info, version)
[18:02:24.231]                         }
[18:02:24.231]                         base::stop(msg)
[18:02:24.231]                       }
[18:02:24.231]                     })
[18:02:24.231]                   }
[18:02:24.231]                   ...future.strategy.old <- future::plan("list")
[18:02:24.231]                   options(future.plan = NULL)
[18:02:24.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:24.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:24.231]                 }
[18:02:24.231]                 ...future.workdir <- getwd()
[18:02:24.231]             }
[18:02:24.231]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:24.231]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:24.231]         }
[18:02:24.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:24.231]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:24.231]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:24.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:24.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:24.231]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:24.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:24.231]             base::names(...future.oldOptions))
[18:02:24.231]     }
[18:02:24.231]     if (FALSE) {
[18:02:24.231]     }
[18:02:24.231]     else {
[18:02:24.231]         if (TRUE) {
[18:02:24.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:24.231]                 open = "w")
[18:02:24.231]         }
[18:02:24.231]         else {
[18:02:24.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:24.231]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:24.231]         }
[18:02:24.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:24.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:24.231]             base::sink(type = "output", split = FALSE)
[18:02:24.231]             base::close(...future.stdout)
[18:02:24.231]         }, add = TRUE)
[18:02:24.231]     }
[18:02:24.231]     ...future.frame <- base::sys.nframe()
[18:02:24.231]     ...future.conditions <- base::list()
[18:02:24.231]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:24.231]     if (FALSE) {
[18:02:24.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:24.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:24.231]     }
[18:02:24.231]     ...future.result <- base::tryCatch({
[18:02:24.231]         base::withCallingHandlers({
[18:02:24.231]             ...future.value <- base::withVisible(base::local({
[18:02:24.231]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:24.231]                 if (!identical(...future.globals.maxSize.org, 
[18:02:24.231]                   ...future.globals.maxSize)) {
[18:02:24.231]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:24.231]                   on.exit(options(oopts), add = TRUE)
[18:02:24.231]                 }
[18:02:24.231]                 {
[18:02:24.231]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:24.231]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:24.231]                     USE.NAMES = FALSE)
[18:02:24.231]                   do.call(mapply, args = args)
[18:02:24.231]                 }
[18:02:24.231]             }))
[18:02:24.231]             future::FutureResult(value = ...future.value$value, 
[18:02:24.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:24.231]                   ...future.rng), globalenv = if (FALSE) 
[18:02:24.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:24.231]                     ...future.globalenv.names))
[18:02:24.231]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:24.231]         }, condition = base::local({
[18:02:24.231]             c <- base::c
[18:02:24.231]             inherits <- base::inherits
[18:02:24.231]             invokeRestart <- base::invokeRestart
[18:02:24.231]             length <- base::length
[18:02:24.231]             list <- base::list
[18:02:24.231]             seq.int <- base::seq.int
[18:02:24.231]             signalCondition <- base::signalCondition
[18:02:24.231]             sys.calls <- base::sys.calls
[18:02:24.231]             `[[` <- base::`[[`
[18:02:24.231]             `+` <- base::`+`
[18:02:24.231]             `<<-` <- base::`<<-`
[18:02:24.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:24.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:24.231]                   3L)]
[18:02:24.231]             }
[18:02:24.231]             function(cond) {
[18:02:24.231]                 is_error <- inherits(cond, "error")
[18:02:24.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:24.231]                   NULL)
[18:02:24.231]                 if (is_error) {
[18:02:24.231]                   sessionInformation <- function() {
[18:02:24.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:24.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:24.231]                       search = base::search(), system = base::Sys.info())
[18:02:24.231]                   }
[18:02:24.231]                   ...future.conditions[[length(...future.conditions) + 
[18:02:24.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:24.231]                     cond$call), session = sessionInformation(), 
[18:02:24.231]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:24.231]                   signalCondition(cond)
[18:02:24.231]                 }
[18:02:24.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:24.231]                 "immediateCondition"))) {
[18:02:24.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:24.231]                   ...future.conditions[[length(...future.conditions) + 
[18:02:24.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:24.231]                   if (TRUE && !signal) {
[18:02:24.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:24.231]                     {
[18:02:24.231]                       inherits <- base::inherits
[18:02:24.231]                       invokeRestart <- base::invokeRestart
[18:02:24.231]                       is.null <- base::is.null
[18:02:24.231]                       muffled <- FALSE
[18:02:24.231]                       if (inherits(cond, "message")) {
[18:02:24.231]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:24.231]                         if (muffled) 
[18:02:24.231]                           invokeRestart("muffleMessage")
[18:02:24.231]                       }
[18:02:24.231]                       else if (inherits(cond, "warning")) {
[18:02:24.231]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:24.231]                         if (muffled) 
[18:02:24.231]                           invokeRestart("muffleWarning")
[18:02:24.231]                       }
[18:02:24.231]                       else if (inherits(cond, "condition")) {
[18:02:24.231]                         if (!is.null(pattern)) {
[18:02:24.231]                           computeRestarts <- base::computeRestarts
[18:02:24.231]                           grepl <- base::grepl
[18:02:24.231]                           restarts <- computeRestarts(cond)
[18:02:24.231]                           for (restart in restarts) {
[18:02:24.231]                             name <- restart$name
[18:02:24.231]                             if (is.null(name)) 
[18:02:24.231]                               next
[18:02:24.231]                             if (!grepl(pattern, name)) 
[18:02:24.231]                               next
[18:02:24.231]                             invokeRestart(restart)
[18:02:24.231]                             muffled <- TRUE
[18:02:24.231]                             break
[18:02:24.231]                           }
[18:02:24.231]                         }
[18:02:24.231]                       }
[18:02:24.231]                       invisible(muffled)
[18:02:24.231]                     }
[18:02:24.231]                     muffleCondition(cond, pattern = "^muffle")
[18:02:24.231]                   }
[18:02:24.231]                 }
[18:02:24.231]                 else {
[18:02:24.231]                   if (TRUE) {
[18:02:24.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:24.231]                     {
[18:02:24.231]                       inherits <- base::inherits
[18:02:24.231]                       invokeRestart <- base::invokeRestart
[18:02:24.231]                       is.null <- base::is.null
[18:02:24.231]                       muffled <- FALSE
[18:02:24.231]                       if (inherits(cond, "message")) {
[18:02:24.231]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:24.231]                         if (muffled) 
[18:02:24.231]                           invokeRestart("muffleMessage")
[18:02:24.231]                       }
[18:02:24.231]                       else if (inherits(cond, "warning")) {
[18:02:24.231]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:24.231]                         if (muffled) 
[18:02:24.231]                           invokeRestart("muffleWarning")
[18:02:24.231]                       }
[18:02:24.231]                       else if (inherits(cond, "condition")) {
[18:02:24.231]                         if (!is.null(pattern)) {
[18:02:24.231]                           computeRestarts <- base::computeRestarts
[18:02:24.231]                           grepl <- base::grepl
[18:02:24.231]                           restarts <- computeRestarts(cond)
[18:02:24.231]                           for (restart in restarts) {
[18:02:24.231]                             name <- restart$name
[18:02:24.231]                             if (is.null(name)) 
[18:02:24.231]                               next
[18:02:24.231]                             if (!grepl(pattern, name)) 
[18:02:24.231]                               next
[18:02:24.231]                             invokeRestart(restart)
[18:02:24.231]                             muffled <- TRUE
[18:02:24.231]                             break
[18:02:24.231]                           }
[18:02:24.231]                         }
[18:02:24.231]                       }
[18:02:24.231]                       invisible(muffled)
[18:02:24.231]                     }
[18:02:24.231]                     muffleCondition(cond, pattern = "^muffle")
[18:02:24.231]                   }
[18:02:24.231]                 }
[18:02:24.231]             }
[18:02:24.231]         }))
[18:02:24.231]     }, error = function(ex) {
[18:02:24.231]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:24.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:24.231]                 ...future.rng), started = ...future.startTime, 
[18:02:24.231]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:24.231]             version = "1.8"), class = "FutureResult")
[18:02:24.231]     }, finally = {
[18:02:24.231]         if (!identical(...future.workdir, getwd())) 
[18:02:24.231]             setwd(...future.workdir)
[18:02:24.231]         {
[18:02:24.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:24.231]                 ...future.oldOptions$nwarnings <- NULL
[18:02:24.231]             }
[18:02:24.231]             base::options(...future.oldOptions)
[18:02:24.231]             if (.Platform$OS.type == "windows") {
[18:02:24.231]                 old_names <- names(...future.oldEnvVars)
[18:02:24.231]                 envs <- base::Sys.getenv()
[18:02:24.231]                 names <- names(envs)
[18:02:24.231]                 common <- intersect(names, old_names)
[18:02:24.231]                 added <- setdiff(names, old_names)
[18:02:24.231]                 removed <- setdiff(old_names, names)
[18:02:24.231]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:24.231]                   envs[common]]
[18:02:24.231]                 NAMES <- toupper(changed)
[18:02:24.231]                 args <- list()
[18:02:24.231]                 for (kk in seq_along(NAMES)) {
[18:02:24.231]                   name <- changed[[kk]]
[18:02:24.231]                   NAME <- NAMES[[kk]]
[18:02:24.231]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:24.231]                     next
[18:02:24.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:24.231]                 }
[18:02:24.231]                 NAMES <- toupper(added)
[18:02:24.231]                 for (kk in seq_along(NAMES)) {
[18:02:24.231]                   name <- added[[kk]]
[18:02:24.231]                   NAME <- NAMES[[kk]]
[18:02:24.231]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:24.231]                     next
[18:02:24.231]                   args[[name]] <- ""
[18:02:24.231]                 }
[18:02:24.231]                 NAMES <- toupper(removed)
[18:02:24.231]                 for (kk in seq_along(NAMES)) {
[18:02:24.231]                   name <- removed[[kk]]
[18:02:24.231]                   NAME <- NAMES[[kk]]
[18:02:24.231]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:24.231]                     next
[18:02:24.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:24.231]                 }
[18:02:24.231]                 if (length(args) > 0) 
[18:02:24.231]                   base::do.call(base::Sys.setenv, args = args)
[18:02:24.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:24.231]             }
[18:02:24.231]             else {
[18:02:24.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:24.231]             }
[18:02:24.231]             {
[18:02:24.231]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:24.231]                   0L) {
[18:02:24.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:24.231]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:24.231]                   base::options(opts)
[18:02:24.231]                 }
[18:02:24.231]                 {
[18:02:24.231]                   {
[18:02:24.231]                     NULL
[18:02:24.231]                     RNGkind("Mersenne-Twister")
[18:02:24.231]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:24.231]                       inherits = FALSE)
[18:02:24.231]                   }
[18:02:24.231]                   options(future.plan = NULL)
[18:02:24.231]                   if (is.na(NA_character_)) 
[18:02:24.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:24.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:24.231]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:24.231]                     .init = FALSE)
[18:02:24.231]                 }
[18:02:24.231]             }
[18:02:24.231]         }
[18:02:24.231]     })
[18:02:24.231]     if (TRUE) {
[18:02:24.231]         base::sink(type = "output", split = FALSE)
[18:02:24.231]         if (TRUE) {
[18:02:24.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:24.231]         }
[18:02:24.231]         else {
[18:02:24.231]             ...future.result["stdout"] <- base::list(NULL)
[18:02:24.231]         }
[18:02:24.231]         base::close(...future.stdout)
[18:02:24.231]         ...future.stdout <- NULL
[18:02:24.231]     }
[18:02:24.231]     ...future.result$conditions <- ...future.conditions
[18:02:24.231]     ...future.result$finished <- base::Sys.time()
[18:02:24.231]     ...future.result
[18:02:24.231] }
[18:02:24.235] assign_globals() ...
[18:02:24.235] List of 5
[18:02:24.235]  $ ...future.FUN            :function (x, y)  
[18:02:24.235]  $ MoreArgs                 : NULL
[18:02:24.235]  $ ...future.elements_ii    :List of 2
[18:02:24.235]   ..$ :List of 2
[18:02:24.235]   .. ..$ : int 1
[18:02:24.235]   .. ..$ : int 0
[18:02:24.235]   ..$ :List of 2
[18:02:24.235]   .. ..$ : int 0
[18:02:24.235]   .. ..$ : int 1
[18:02:24.235]  $ ...future.seeds_ii       : NULL
[18:02:24.235]  $ ...future.globals.maxSize: NULL
[18:02:24.235]  - attr(*, "where")=List of 5
[18:02:24.235]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:24.235]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:24.235]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:24.235]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:24.235]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:24.235]  - attr(*, "resolved")= logi FALSE
[18:02:24.235]  - attr(*, "total_size")= num 6480
[18:02:24.235]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:24.235]  - attr(*, "already-done")= logi TRUE
[18:02:24.248] - reassign environment for ‘...future.FUN’
[18:02:24.248] - copied ‘...future.FUN’ to environment
[18:02:24.248] - copied ‘MoreArgs’ to environment
[18:02:24.248] - copied ‘...future.elements_ii’ to environment
[18:02:24.248] - copied ‘...future.seeds_ii’ to environment
[18:02:24.249] - copied ‘...future.globals.maxSize’ to environment
[18:02:24.249] assign_globals() ... done
[18:02:24.249] plan(): Setting new future strategy stack:
[18:02:24.250] List of future strategies:
[18:02:24.250] 1. sequential:
[18:02:24.250]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:24.250]    - tweaked: FALSE
[18:02:24.250]    - call: NULL
[18:02:24.251] plan(): nbrOfWorkers() = 1
[18:02:24.753] plan(): Setting new future strategy stack:
[18:02:24.753] List of future strategies:
[18:02:24.753] 1. multicore:
[18:02:24.753]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:24.753]    - tweaked: FALSE
[18:02:24.753]    - call: plan(strategy)
[18:02:24.760] plan(): nbrOfWorkers() = 1
[18:02:24.760] SequentialFuture started (and completed)
[18:02:24.761] - Launch lazy future ... done
[18:02:24.761] run() for ‘SequentialFuture’ ... done
[18:02:24.761] Created future:
[18:02:24.761] SequentialFuture:
[18:02:24.761] Label: ‘future_mapply-1’
[18:02:24.761] Expression:
[18:02:24.761] {
[18:02:24.761]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:24.761]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:24.761]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:24.761]         on.exit(options(oopts), add = TRUE)
[18:02:24.761]     }
[18:02:24.761]     {
[18:02:24.761]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:24.761]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:24.761]         do.call(mapply, args = args)
[18:02:24.761]     }
[18:02:24.761] }
[18:02:24.761] Lazy evaluation: FALSE
[18:02:24.761] Asynchronous evaluation: FALSE
[18:02:24.761] Local evaluation: TRUE
[18:02:24.761] Environment: R_GlobalEnv
[18:02:24.761] Capture standard output: TRUE
[18:02:24.761] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:24.761] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:24.761] Packages: <none>
[18:02:24.761] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:24.761] Resolved: TRUE
[18:02:24.761] Value: 224 bytes of class ‘list’
[18:02:24.761] Early signaling: FALSE
[18:02:24.761] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:24.761] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:24.764] Chunk #1 of 1 ... DONE
[18:02:24.764] Launching 1 futures (chunks) ... DONE
[18:02:24.764] Resolving 1 futures (chunks) ...
[18:02:24.764] resolve() on list ...
[18:02:24.764]  recursive: 0
[18:02:24.765]  length: 1
[18:02:24.768] 
[18:02:24.768] resolved() for ‘SequentialFuture’ ...
[18:02:24.768] - state: ‘finished’
[18:02:24.768] - run: TRUE
[18:02:24.768] - result: ‘FutureResult’
[18:02:24.769] resolved() for ‘SequentialFuture’ ... done
[18:02:24.769] Future #1
[18:02:24.769] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:24.769] - nx: 1
[18:02:24.770] - relay: TRUE
[18:02:24.770] - stdout: TRUE
[18:02:24.770] - signal: TRUE
[18:02:24.770] - resignal: FALSE
[18:02:24.770] - force: TRUE
[18:02:24.771] - relayed: [n=1] FALSE
[18:02:24.771] - queued futures: [n=1] FALSE
[18:02:24.771]  - until=1
[18:02:24.771]  - relaying element #1
[18:02:24.772] - relayed: [n=1] TRUE
[18:02:24.772] - queued futures: [n=1] TRUE
[18:02:24.772] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:24.772]  length: 0 (resolved future 1)
[18:02:24.773] Relaying remaining futures
[18:02:24.773] signalConditionsASAP(NULL, pos=0) ...
[18:02:24.773] - nx: 1
[18:02:24.773] - relay: TRUE
[18:02:24.773] - stdout: TRUE
[18:02:24.773] - signal: TRUE
[18:02:24.774] - resignal: FALSE
[18:02:24.774] - force: TRUE
[18:02:24.774] - relayed: [n=1] TRUE
[18:02:24.774] - queued futures: [n=1] TRUE
 - flush all
[18:02:24.774] - relayed: [n=1] TRUE
[18:02:24.775] - queued futures: [n=1] TRUE
[18:02:24.775] signalConditionsASAP(NULL, pos=0) ... done
[18:02:24.775] resolve() on list ... DONE
[18:02:24.775]  - Number of value chunks collected: 1
[18:02:24.776] Resolving 1 futures (chunks) ... DONE
[18:02:24.776] Reducing values from 1 chunks ...
[18:02:24.776]  - Number of values collected after concatenation: 2
[18:02:24.776]  - Number of values expected: 2
[18:02:24.776] Reducing values from 1 chunks ... DONE
[18:02:24.777] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[18:02:24.777] future_mapply() ...
[18:02:24.783] Number of chunks: 1
[18:02:24.784] getGlobalsAndPackagesXApply() ...
[18:02:24.784]  - future.globals: TRUE
[18:02:24.784] getGlobalsAndPackages() ...
[18:02:24.784] Searching for globals...
[18:02:24.788] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:24.788] Searching for globals ... DONE
[18:02:24.788] Resolving globals: FALSE
[18:02:24.789] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:24.790] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:24.790] - globals: [1] ‘FUN’
[18:02:24.790] 
[18:02:24.791] getGlobalsAndPackages() ... DONE
[18:02:24.791]  - globals found/used: [n=1] ‘FUN’
[18:02:24.791]  - needed namespaces: [n=0] 
[18:02:24.791] Finding globals ... DONE
[18:02:24.792] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:24.792] List of 2
[18:02:24.792]  $ ...future.FUN:function (x, y)  
[18:02:24.792]  $ MoreArgs     : NULL
[18:02:24.792]  - attr(*, "where")=List of 2
[18:02:24.792]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:24.792]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:24.792]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:24.792]  - attr(*, "resolved")= logi FALSE
[18:02:24.792]  - attr(*, "total_size")= num NA
[18:02:24.798] Packages to be attached in all futures: [n=0] 
[18:02:24.798] getGlobalsAndPackagesXApply() ... DONE
[18:02:24.798] Number of futures (= number of chunks): 1
[18:02:24.798] Launching 1 futures (chunks) ...
[18:02:24.799] Chunk #1 of 1 ...
[18:02:24.799]  - Finding globals in '...' for chunk #1 ...
[18:02:24.799] getGlobalsAndPackages() ...
[18:02:24.799] Searching for globals...
[18:02:24.800] 
[18:02:24.800] Searching for globals ... DONE
[18:02:24.800] - globals: [0] <none>
[18:02:24.801] getGlobalsAndPackages() ... DONE
[18:02:24.801]    + additional globals found: [n=0] 
[18:02:24.801]    + additional namespaces needed: [n=0] 
[18:02:24.801]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:24.801]  - seeds: <none>
[18:02:24.802]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:24.802] getGlobalsAndPackages() ...
[18:02:24.802] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:24.802] Resolving globals: FALSE
[18:02:24.803] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[18:02:24.804] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:24.805] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:24.805] 
[18:02:24.805] getGlobalsAndPackages() ... DONE
[18:02:24.806] run() for ‘Future’ ...
[18:02:24.806] - state: ‘created’
[18:02:24.806] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:24.813] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:24.813] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:24.813]   - Field: ‘label’
[18:02:24.814]   - Field: ‘local’
[18:02:24.814]   - Field: ‘owner’
[18:02:24.814]   - Field: ‘envir’
[18:02:24.814]   - Field: ‘packages’
[18:02:24.814]   - Field: ‘gc’
[18:02:24.815]   - Field: ‘conditions’
[18:02:24.815]   - Field: ‘expr’
[18:02:24.815]   - Field: ‘uuid’
[18:02:24.815]   - Field: ‘seed’
[18:02:24.815]   - Field: ‘version’
[18:02:24.816]   - Field: ‘result’
[18:02:24.816]   - Field: ‘asynchronous’
[18:02:24.816]   - Field: ‘calls’
[18:02:24.816]   - Field: ‘globals’
[18:02:24.817]   - Field: ‘stdout’
[18:02:24.817]   - Field: ‘earlySignal’
[18:02:24.817]   - Field: ‘lazy’
[18:02:24.817]   - Field: ‘state’
[18:02:24.817] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:24.818] - Launch lazy future ...
[18:02:24.818] Packages needed by the future expression (n = 0): <none>
[18:02:24.818] Packages needed by future strategies (n = 0): <none>
[18:02:24.819] {
[18:02:24.819]     {
[18:02:24.819]         {
[18:02:24.819]             ...future.startTime <- base::Sys.time()
[18:02:24.819]             {
[18:02:24.819]                 {
[18:02:24.819]                   {
[18:02:24.819]                     base::local({
[18:02:24.819]                       has_future <- base::requireNamespace("future", 
[18:02:24.819]                         quietly = TRUE)
[18:02:24.819]                       if (has_future) {
[18:02:24.819]                         ns <- base::getNamespace("future")
[18:02:24.819]                         version <- ns[[".package"]][["version"]]
[18:02:24.819]                         if (is.null(version)) 
[18:02:24.819]                           version <- utils::packageVersion("future")
[18:02:24.819]                       }
[18:02:24.819]                       else {
[18:02:24.819]                         version <- NULL
[18:02:24.819]                       }
[18:02:24.819]                       if (!has_future || version < "1.8.0") {
[18:02:24.819]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:24.819]                           "", base::R.version$version.string), 
[18:02:24.819]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:24.819]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:24.819]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:24.819]                             "release", "version")], collapse = " "), 
[18:02:24.819]                           hostname = base::Sys.info()[["nodename"]])
[18:02:24.819]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:24.819]                           info)
[18:02:24.819]                         info <- base::paste(info, collapse = "; ")
[18:02:24.819]                         if (!has_future) {
[18:02:24.819]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:24.819]                             info)
[18:02:24.819]                         }
[18:02:24.819]                         else {
[18:02:24.819]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:24.819]                             info, version)
[18:02:24.819]                         }
[18:02:24.819]                         base::stop(msg)
[18:02:24.819]                       }
[18:02:24.819]                     })
[18:02:24.819]                   }
[18:02:24.819]                   ...future.strategy.old <- future::plan("list")
[18:02:24.819]                   options(future.plan = NULL)
[18:02:24.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:24.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:24.819]                 }
[18:02:24.819]                 ...future.workdir <- getwd()
[18:02:24.819]             }
[18:02:24.819]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:24.819]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:24.819]         }
[18:02:24.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:24.819]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:24.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:24.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:24.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:24.819]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:24.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:24.819]             base::names(...future.oldOptions))
[18:02:24.819]     }
[18:02:24.819]     if (TRUE) {
[18:02:24.819]     }
[18:02:24.819]     else {
[18:02:24.819]         if (NA) {
[18:02:24.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:24.819]                 open = "w")
[18:02:24.819]         }
[18:02:24.819]         else {
[18:02:24.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:24.819]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:24.819]         }
[18:02:24.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:24.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:24.819]             base::sink(type = "output", split = FALSE)
[18:02:24.819]             base::close(...future.stdout)
[18:02:24.819]         }, add = TRUE)
[18:02:24.819]     }
[18:02:24.819]     ...future.frame <- base::sys.nframe()
[18:02:24.819]     ...future.conditions <- base::list()
[18:02:24.819]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:24.819]     if (FALSE) {
[18:02:24.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:24.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:24.819]     }
[18:02:24.819]     ...future.result <- base::tryCatch({
[18:02:24.819]         base::withCallingHandlers({
[18:02:24.819]             ...future.value <- base::withVisible(base::local({
[18:02:24.819]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:24.819]                 if (!identical(...future.globals.maxSize.org, 
[18:02:24.819]                   ...future.globals.maxSize)) {
[18:02:24.819]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:24.819]                   on.exit(options(oopts), add = TRUE)
[18:02:24.819]                 }
[18:02:24.819]                 {
[18:02:24.819]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:24.819]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:24.819]                     USE.NAMES = FALSE)
[18:02:24.819]                   do.call(mapply, args = args)
[18:02:24.819]                 }
[18:02:24.819]             }))
[18:02:24.819]             future::FutureResult(value = ...future.value$value, 
[18:02:24.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:24.819]                   ...future.rng), globalenv = if (FALSE) 
[18:02:24.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:24.819]                     ...future.globalenv.names))
[18:02:24.819]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:24.819]         }, condition = base::local({
[18:02:24.819]             c <- base::c
[18:02:24.819]             inherits <- base::inherits
[18:02:24.819]             invokeRestart <- base::invokeRestart
[18:02:24.819]             length <- base::length
[18:02:24.819]             list <- base::list
[18:02:24.819]             seq.int <- base::seq.int
[18:02:24.819]             signalCondition <- base::signalCondition
[18:02:24.819]             sys.calls <- base::sys.calls
[18:02:24.819]             `[[` <- base::`[[`
[18:02:24.819]             `+` <- base::`+`
[18:02:24.819]             `<<-` <- base::`<<-`
[18:02:24.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:24.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:24.819]                   3L)]
[18:02:24.819]             }
[18:02:24.819]             function(cond) {
[18:02:24.819]                 is_error <- inherits(cond, "error")
[18:02:24.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:24.819]                   NULL)
[18:02:24.819]                 if (is_error) {
[18:02:24.819]                   sessionInformation <- function() {
[18:02:24.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:24.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:24.819]                       search = base::search(), system = base::Sys.info())
[18:02:24.819]                   }
[18:02:24.819]                   ...future.conditions[[length(...future.conditions) + 
[18:02:24.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:24.819]                     cond$call), session = sessionInformation(), 
[18:02:24.819]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:24.819]                   signalCondition(cond)
[18:02:24.819]                 }
[18:02:24.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:24.819]                 "immediateCondition"))) {
[18:02:24.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:24.819]                   ...future.conditions[[length(...future.conditions) + 
[18:02:24.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:24.819]                   if (TRUE && !signal) {
[18:02:24.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:24.819]                     {
[18:02:24.819]                       inherits <- base::inherits
[18:02:24.819]                       invokeRestart <- base::invokeRestart
[18:02:24.819]                       is.null <- base::is.null
[18:02:24.819]                       muffled <- FALSE
[18:02:24.819]                       if (inherits(cond, "message")) {
[18:02:24.819]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:24.819]                         if (muffled) 
[18:02:24.819]                           invokeRestart("muffleMessage")
[18:02:24.819]                       }
[18:02:24.819]                       else if (inherits(cond, "warning")) {
[18:02:24.819]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:24.819]                         if (muffled) 
[18:02:24.819]                           invokeRestart("muffleWarning")
[18:02:24.819]                       }
[18:02:24.819]                       else if (inherits(cond, "condition")) {
[18:02:24.819]                         if (!is.null(pattern)) {
[18:02:24.819]                           computeRestarts <- base::computeRestarts
[18:02:24.819]                           grepl <- base::grepl
[18:02:24.819]                           restarts <- computeRestarts(cond)
[18:02:24.819]                           for (restart in restarts) {
[18:02:24.819]                             name <- restart$name
[18:02:24.819]                             if (is.null(name)) 
[18:02:24.819]                               next
[18:02:24.819]                             if (!grepl(pattern, name)) 
[18:02:24.819]                               next
[18:02:24.819]                             invokeRestart(restart)
[18:02:24.819]                             muffled <- TRUE
[18:02:24.819]                             break
[18:02:24.819]                           }
[18:02:24.819]                         }
[18:02:24.819]                       }
[18:02:24.819]                       invisible(muffled)
[18:02:24.819]                     }
[18:02:24.819]                     muffleCondition(cond, pattern = "^muffle")
[18:02:24.819]                   }
[18:02:24.819]                 }
[18:02:24.819]                 else {
[18:02:24.819]                   if (TRUE) {
[18:02:24.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:24.819]                     {
[18:02:24.819]                       inherits <- base::inherits
[18:02:24.819]                       invokeRestart <- base::invokeRestart
[18:02:24.819]                       is.null <- base::is.null
[18:02:24.819]                       muffled <- FALSE
[18:02:24.819]                       if (inherits(cond, "message")) {
[18:02:24.819]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:24.819]                         if (muffled) 
[18:02:24.819]                           invokeRestart("muffleMessage")
[18:02:24.819]                       }
[18:02:24.819]                       else if (inherits(cond, "warning")) {
[18:02:24.819]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:24.819]                         if (muffled) 
[18:02:24.819]                           invokeRestart("muffleWarning")
[18:02:24.819]                       }
[18:02:24.819]                       else if (inherits(cond, "condition")) {
[18:02:24.819]                         if (!is.null(pattern)) {
[18:02:24.819]                           computeRestarts <- base::computeRestarts
[18:02:24.819]                           grepl <- base::grepl
[18:02:24.819]                           restarts <- computeRestarts(cond)
[18:02:24.819]                           for (restart in restarts) {
[18:02:24.819]                             name <- restart$name
[18:02:24.819]                             if (is.null(name)) 
[18:02:24.819]                               next
[18:02:24.819]                             if (!grepl(pattern, name)) 
[18:02:24.819]                               next
[18:02:24.819]                             invokeRestart(restart)
[18:02:24.819]                             muffled <- TRUE
[18:02:24.819]                             break
[18:02:24.819]                           }
[18:02:24.819]                         }
[18:02:24.819]                       }
[18:02:24.819]                       invisible(muffled)
[18:02:24.819]                     }
[18:02:24.819]                     muffleCondition(cond, pattern = "^muffle")
[18:02:24.819]                   }
[18:02:24.819]                 }
[18:02:24.819]             }
[18:02:24.819]         }))
[18:02:24.819]     }, error = function(ex) {
[18:02:24.819]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:24.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:24.819]                 ...future.rng), started = ...future.startTime, 
[18:02:24.819]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:24.819]             version = "1.8"), class = "FutureResult")
[18:02:24.819]     }, finally = {
[18:02:24.819]         if (!identical(...future.workdir, getwd())) 
[18:02:24.819]             setwd(...future.workdir)
[18:02:24.819]         {
[18:02:24.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:24.819]                 ...future.oldOptions$nwarnings <- NULL
[18:02:24.819]             }
[18:02:24.819]             base::options(...future.oldOptions)
[18:02:24.819]             if (.Platform$OS.type == "windows") {
[18:02:24.819]                 old_names <- names(...future.oldEnvVars)
[18:02:24.819]                 envs <- base::Sys.getenv()
[18:02:24.819]                 names <- names(envs)
[18:02:24.819]                 common <- intersect(names, old_names)
[18:02:24.819]                 added <- setdiff(names, old_names)
[18:02:24.819]                 removed <- setdiff(old_names, names)
[18:02:24.819]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:24.819]                   envs[common]]
[18:02:24.819]                 NAMES <- toupper(changed)
[18:02:24.819]                 args <- list()
[18:02:24.819]                 for (kk in seq_along(NAMES)) {
[18:02:24.819]                   name <- changed[[kk]]
[18:02:24.819]                   NAME <- NAMES[[kk]]
[18:02:24.819]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:24.819]                     next
[18:02:24.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:24.819]                 }
[18:02:24.819]                 NAMES <- toupper(added)
[18:02:24.819]                 for (kk in seq_along(NAMES)) {
[18:02:24.819]                   name <- added[[kk]]
[18:02:24.819]                   NAME <- NAMES[[kk]]
[18:02:24.819]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:24.819]                     next
[18:02:24.819]                   args[[name]] <- ""
[18:02:24.819]                 }
[18:02:24.819]                 NAMES <- toupper(removed)
[18:02:24.819]                 for (kk in seq_along(NAMES)) {
[18:02:24.819]                   name <- removed[[kk]]
[18:02:24.819]                   NAME <- NAMES[[kk]]
[18:02:24.819]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:24.819]                     next
[18:02:24.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:24.819]                 }
[18:02:24.819]                 if (length(args) > 0) 
[18:02:24.819]                   base::do.call(base::Sys.setenv, args = args)
[18:02:24.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:24.819]             }
[18:02:24.819]             else {
[18:02:24.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:24.819]             }
[18:02:24.819]             {
[18:02:24.819]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:24.819]                   0L) {
[18:02:24.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:24.819]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:24.819]                   base::options(opts)
[18:02:24.819]                 }
[18:02:24.819]                 {
[18:02:24.819]                   {
[18:02:24.819]                     NULL
[18:02:24.819]                     RNGkind("Mersenne-Twister")
[18:02:24.819]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:24.819]                       inherits = FALSE)
[18:02:24.819]                   }
[18:02:24.819]                   options(future.plan = NULL)
[18:02:24.819]                   if (is.na(NA_character_)) 
[18:02:24.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:24.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:24.819]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:24.819]                     .init = FALSE)
[18:02:24.819]                 }
[18:02:24.819]             }
[18:02:24.819]         }
[18:02:24.819]     })
[18:02:24.819]     if (FALSE) {
[18:02:24.819]         base::sink(type = "output", split = FALSE)
[18:02:24.819]         if (NA) {
[18:02:24.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:24.819]         }
[18:02:24.819]         else {
[18:02:24.819]             ...future.result["stdout"] <- base::list(NULL)
[18:02:24.819]         }
[18:02:24.819]         base::close(...future.stdout)
[18:02:24.819]         ...future.stdout <- NULL
[18:02:24.819]     }
[18:02:24.819]     ...future.result$conditions <- ...future.conditions
[18:02:24.819]     ...future.result$finished <- base::Sys.time()
[18:02:24.819]     ...future.result
[18:02:24.819] }
[18:02:24.823] assign_globals() ...
[18:02:24.823] List of 5
[18:02:24.823]  $ ...future.FUN            :function (x, y)  
[18:02:24.823]  $ MoreArgs                 : NULL
[18:02:24.823]  $ ...future.elements_ii    :List of 2
[18:02:24.823]   ..$ :List of 2
[18:02:24.823]   .. ..$ : int 1
[18:02:24.823]   .. ..$ : int 0
[18:02:24.823]   ..$ :List of 2
[18:02:24.823]   .. ..$ : int 0
[18:02:24.823]   .. ..$ : int 1
[18:02:24.823]  $ ...future.seeds_ii       : NULL
[18:02:24.823]  $ ...future.globals.maxSize: NULL
[18:02:24.823]  - attr(*, "where")=List of 5
[18:02:24.823]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:24.823]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:24.823]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:24.823]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:24.823]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:24.823]  - attr(*, "resolved")= logi FALSE
[18:02:24.823]  - attr(*, "total_size")= num 6480
[18:02:24.823]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:24.823]  - attr(*, "already-done")= logi TRUE
[18:02:24.838] - reassign environment for ‘...future.FUN’
[18:02:24.839] - copied ‘...future.FUN’ to environment
[18:02:24.839] - copied ‘MoreArgs’ to environment
[18:02:24.839] - copied ‘...future.elements_ii’ to environment
[18:02:24.839] - copied ‘...future.seeds_ii’ to environment
[18:02:24.839] - copied ‘...future.globals.maxSize’ to environment
[18:02:24.840] assign_globals() ... done
[18:02:24.840] plan(): Setting new future strategy stack:
[18:02:24.840] List of future strategies:
[18:02:24.840] 1. sequential:
[18:02:24.840]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:24.840]    - tweaked: FALSE
[18:02:24.840]    - call: NULL
[18:02:24.841] plan(): nbrOfWorkers() = 1
[18:02:25.344] plan(): Setting new future strategy stack:
[18:02:25.345] List of future strategies:
[18:02:25.345] 1. multicore:
[18:02:25.345]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:25.345]    - tweaked: FALSE
[18:02:25.345]    - call: plan(strategy)
[18:02:25.351] plan(): nbrOfWorkers() = 1
[18:02:25.351] SequentialFuture started (and completed)
[18:02:25.352] - Launch lazy future ... done
[18:02:25.352] run() for ‘SequentialFuture’ ... done
[18:02:25.352] Created future:
[18:02:25.352] SequentialFuture:
[18:02:25.352] Label: ‘future_mapply-1’
[18:02:25.352] Expression:
[18:02:25.352] {
[18:02:25.352]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:25.352]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:25.352]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:25.352]         on.exit(options(oopts), add = TRUE)
[18:02:25.352]     }
[18:02:25.352]     {
[18:02:25.352]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:25.352]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:25.352]         do.call(mapply, args = args)
[18:02:25.352]     }
[18:02:25.352] }
[18:02:25.352] Lazy evaluation: FALSE
[18:02:25.352] Asynchronous evaluation: FALSE
[18:02:25.352] Local evaluation: TRUE
[18:02:25.352] Environment: R_GlobalEnv
[18:02:25.352] Capture standard output: NA
[18:02:25.352] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:25.352] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:25.352] Packages: <none>
[18:02:25.352] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:25.352] Resolved: TRUE
[18:02:25.352] Value: 224 bytes of class ‘list’
[18:02:25.352] Early signaling: FALSE
[18:02:25.352] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:25.352] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:25.354] Chunk #1 of 1 ... DONE
[18:02:25.355] Launching 1 futures (chunks) ... DONE
[18:02:25.355] Resolving 1 futures (chunks) ...
[18:02:25.355] resolve() on list ...
[18:02:25.355]  recursive: 0
[18:02:25.356]  length: 1
[18:02:25.356] 
[18:02:25.356] resolved() for ‘SequentialFuture’ ...
[18:02:25.356] - state: ‘finished’
[18:02:25.357] - run: TRUE
[18:02:25.357] - result: ‘FutureResult’
[18:02:25.357] resolved() for ‘SequentialFuture’ ... done
[18:02:25.357] Future #1
[18:02:25.358] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:25.358] - nx: 1
[18:02:25.358] - relay: TRUE
[18:02:25.358] - stdout: TRUE
[18:02:25.358] - signal: TRUE
[18:02:25.359] - resignal: FALSE
[18:02:25.359] - force: TRUE
[18:02:25.359] - relayed: [n=1] FALSE
[18:02:25.359] - queued futures: [n=1] FALSE
[18:02:25.360]  - until=1
[18:02:25.360]  - relaying element #1
[18:02:25.360] - relayed: [n=1] TRUE
[18:02:25.360] - queued futures: [n=1] TRUE
[18:02:25.361] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:25.361]  length: 0 (resolved future 1)
[18:02:25.361] Relaying remaining futures
[18:02:25.361] signalConditionsASAP(NULL, pos=0) ...
[18:02:25.361] - nx: 1
[18:02:25.362] - relay: TRUE
[18:02:25.362] - stdout: TRUE
[18:02:25.362] - signal: TRUE
[18:02:25.362] - resignal: FALSE
[18:02:25.362] - force: TRUE
[18:02:25.362] - relayed: [n=1] TRUE
[18:02:25.363] - queued futures: [n=1] TRUE
 - flush all
[18:02:25.363] - relayed: [n=1] TRUE
[18:02:25.363] - queued futures: [n=1] TRUE
[18:02:25.363] signalConditionsASAP(NULL, pos=0) ... done
[18:02:25.364] resolve() on list ... DONE
[18:02:25.364]  - Number of value chunks collected: 1
[18:02:25.364] Resolving 1 futures (chunks) ... DONE
[18:02:25.364] Reducing values from 1 chunks ...
[18:02:25.364]  - Number of values collected after concatenation: 2
[18:02:25.365]  - Number of values expected: 2
[18:02:25.365] Reducing values from 1 chunks ... DONE
[18:02:25.365] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[18:02:25.366] plan(): Setting new future strategy stack:
[18:02:25.366] List of future strategies:
[18:02:25.366] 1. multisession:
[18:02:25.366]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:02:25.366]    - tweaked: FALSE
[18:02:25.366]    - call: plan(strategy)
[18:02:25.367] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:02:25.367] multisession:
[18:02:25.367] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:02:25.367] - tweaked: FALSE
[18:02:25.367] - call: plan(strategy)
[18:02:25.374] getGlobalsAndPackages() ...
[18:02:25.374] Not searching for globals
[18:02:25.374] - globals: [0] <none>
[18:02:25.375] getGlobalsAndPackages() ... DONE
[18:02:25.376] Packages needed by the future expression (n = 0): <none>
[18:02:25.376] Packages needed by future strategies (n = 0): <none>
[18:02:25.377] {
[18:02:25.377]     {
[18:02:25.377]         {
[18:02:25.377]             ...future.startTime <- base::Sys.time()
[18:02:25.377]             {
[18:02:25.377]                 {
[18:02:25.377]                   {
[18:02:25.377]                     base::local({
[18:02:25.377]                       has_future <- base::requireNamespace("future", 
[18:02:25.377]                         quietly = TRUE)
[18:02:25.377]                       if (has_future) {
[18:02:25.377]                         ns <- base::getNamespace("future")
[18:02:25.377]                         version <- ns[[".package"]][["version"]]
[18:02:25.377]                         if (is.null(version)) 
[18:02:25.377]                           version <- utils::packageVersion("future")
[18:02:25.377]                       }
[18:02:25.377]                       else {
[18:02:25.377]                         version <- NULL
[18:02:25.377]                       }
[18:02:25.377]                       if (!has_future || version < "1.8.0") {
[18:02:25.377]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:25.377]                           "", base::R.version$version.string), 
[18:02:25.377]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:25.377]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:25.377]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:25.377]                             "release", "version")], collapse = " "), 
[18:02:25.377]                           hostname = base::Sys.info()[["nodename"]])
[18:02:25.377]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:25.377]                           info)
[18:02:25.377]                         info <- base::paste(info, collapse = "; ")
[18:02:25.377]                         if (!has_future) {
[18:02:25.377]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:25.377]                             info)
[18:02:25.377]                         }
[18:02:25.377]                         else {
[18:02:25.377]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:25.377]                             info, version)
[18:02:25.377]                         }
[18:02:25.377]                         base::stop(msg)
[18:02:25.377]                       }
[18:02:25.377]                     })
[18:02:25.377]                   }
[18:02:25.377]                   ...future.strategy.old <- future::plan("list")
[18:02:25.377]                   options(future.plan = NULL)
[18:02:25.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:25.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:25.377]                 }
[18:02:25.377]                 ...future.workdir <- getwd()
[18:02:25.377]             }
[18:02:25.377]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:25.377]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:25.377]         }
[18:02:25.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:25.377]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:25.377]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:25.377]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:25.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:25.377]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:25.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:25.377]             base::names(...future.oldOptions))
[18:02:25.377]     }
[18:02:25.377]     if (FALSE) {
[18:02:25.377]     }
[18:02:25.377]     else {
[18:02:25.377]         if (TRUE) {
[18:02:25.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:25.377]                 open = "w")
[18:02:25.377]         }
[18:02:25.377]         else {
[18:02:25.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:25.377]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:25.377]         }
[18:02:25.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:25.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:25.377]             base::sink(type = "output", split = FALSE)
[18:02:25.377]             base::close(...future.stdout)
[18:02:25.377]         }, add = TRUE)
[18:02:25.377]     }
[18:02:25.377]     ...future.frame <- base::sys.nframe()
[18:02:25.377]     ...future.conditions <- base::list()
[18:02:25.377]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:25.377]     if (FALSE) {
[18:02:25.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:25.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:25.377]     }
[18:02:25.377]     ...future.result <- base::tryCatch({
[18:02:25.377]         base::withCallingHandlers({
[18:02:25.377]             ...future.value <- base::withVisible(base::local(NA))
[18:02:25.377]             future::FutureResult(value = ...future.value$value, 
[18:02:25.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:25.377]                   ...future.rng), globalenv = if (FALSE) 
[18:02:25.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:25.377]                     ...future.globalenv.names))
[18:02:25.377]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:25.377]         }, condition = base::local({
[18:02:25.377]             c <- base::c
[18:02:25.377]             inherits <- base::inherits
[18:02:25.377]             invokeRestart <- base::invokeRestart
[18:02:25.377]             length <- base::length
[18:02:25.377]             list <- base::list
[18:02:25.377]             seq.int <- base::seq.int
[18:02:25.377]             signalCondition <- base::signalCondition
[18:02:25.377]             sys.calls <- base::sys.calls
[18:02:25.377]             `[[` <- base::`[[`
[18:02:25.377]             `+` <- base::`+`
[18:02:25.377]             `<<-` <- base::`<<-`
[18:02:25.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:25.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:25.377]                   3L)]
[18:02:25.377]             }
[18:02:25.377]             function(cond) {
[18:02:25.377]                 is_error <- inherits(cond, "error")
[18:02:25.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:25.377]                   NULL)
[18:02:25.377]                 if (is_error) {
[18:02:25.377]                   sessionInformation <- function() {
[18:02:25.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:25.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:25.377]                       search = base::search(), system = base::Sys.info())
[18:02:25.377]                   }
[18:02:25.377]                   ...future.conditions[[length(...future.conditions) + 
[18:02:25.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:25.377]                     cond$call), session = sessionInformation(), 
[18:02:25.377]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:25.377]                   signalCondition(cond)
[18:02:25.377]                 }
[18:02:25.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:25.377]                 "immediateCondition"))) {
[18:02:25.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:25.377]                   ...future.conditions[[length(...future.conditions) + 
[18:02:25.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:25.377]                   if (TRUE && !signal) {
[18:02:25.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:25.377]                     {
[18:02:25.377]                       inherits <- base::inherits
[18:02:25.377]                       invokeRestart <- base::invokeRestart
[18:02:25.377]                       is.null <- base::is.null
[18:02:25.377]                       muffled <- FALSE
[18:02:25.377]                       if (inherits(cond, "message")) {
[18:02:25.377]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:25.377]                         if (muffled) 
[18:02:25.377]                           invokeRestart("muffleMessage")
[18:02:25.377]                       }
[18:02:25.377]                       else if (inherits(cond, "warning")) {
[18:02:25.377]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:25.377]                         if (muffled) 
[18:02:25.377]                           invokeRestart("muffleWarning")
[18:02:25.377]                       }
[18:02:25.377]                       else if (inherits(cond, "condition")) {
[18:02:25.377]                         if (!is.null(pattern)) {
[18:02:25.377]                           computeRestarts <- base::computeRestarts
[18:02:25.377]                           grepl <- base::grepl
[18:02:25.377]                           restarts <- computeRestarts(cond)
[18:02:25.377]                           for (restart in restarts) {
[18:02:25.377]                             name <- restart$name
[18:02:25.377]                             if (is.null(name)) 
[18:02:25.377]                               next
[18:02:25.377]                             if (!grepl(pattern, name)) 
[18:02:25.377]                               next
[18:02:25.377]                             invokeRestart(restart)
[18:02:25.377]                             muffled <- TRUE
[18:02:25.377]                             break
[18:02:25.377]                           }
[18:02:25.377]                         }
[18:02:25.377]                       }
[18:02:25.377]                       invisible(muffled)
[18:02:25.377]                     }
[18:02:25.377]                     muffleCondition(cond, pattern = "^muffle")
[18:02:25.377]                   }
[18:02:25.377]                 }
[18:02:25.377]                 else {
[18:02:25.377]                   if (TRUE) {
[18:02:25.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:25.377]                     {
[18:02:25.377]                       inherits <- base::inherits
[18:02:25.377]                       invokeRestart <- base::invokeRestart
[18:02:25.377]                       is.null <- base::is.null
[18:02:25.377]                       muffled <- FALSE
[18:02:25.377]                       if (inherits(cond, "message")) {
[18:02:25.377]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:25.377]                         if (muffled) 
[18:02:25.377]                           invokeRestart("muffleMessage")
[18:02:25.377]                       }
[18:02:25.377]                       else if (inherits(cond, "warning")) {
[18:02:25.377]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:25.377]                         if (muffled) 
[18:02:25.377]                           invokeRestart("muffleWarning")
[18:02:25.377]                       }
[18:02:25.377]                       else if (inherits(cond, "condition")) {
[18:02:25.377]                         if (!is.null(pattern)) {
[18:02:25.377]                           computeRestarts <- base::computeRestarts
[18:02:25.377]                           grepl <- base::grepl
[18:02:25.377]                           restarts <- computeRestarts(cond)
[18:02:25.377]                           for (restart in restarts) {
[18:02:25.377]                             name <- restart$name
[18:02:25.377]                             if (is.null(name)) 
[18:02:25.377]                               next
[18:02:25.377]                             if (!grepl(pattern, name)) 
[18:02:25.377]                               next
[18:02:25.377]                             invokeRestart(restart)
[18:02:25.377]                             muffled <- TRUE
[18:02:25.377]                             break
[18:02:25.377]                           }
[18:02:25.377]                         }
[18:02:25.377]                       }
[18:02:25.377]                       invisible(muffled)
[18:02:25.377]                     }
[18:02:25.377]                     muffleCondition(cond, pattern = "^muffle")
[18:02:25.377]                   }
[18:02:25.377]                 }
[18:02:25.377]             }
[18:02:25.377]         }))
[18:02:25.377]     }, error = function(ex) {
[18:02:25.377]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:25.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:25.377]                 ...future.rng), started = ...future.startTime, 
[18:02:25.377]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:25.377]             version = "1.8"), class = "FutureResult")
[18:02:25.377]     }, finally = {
[18:02:25.377]         if (!identical(...future.workdir, getwd())) 
[18:02:25.377]             setwd(...future.workdir)
[18:02:25.377]         {
[18:02:25.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:25.377]                 ...future.oldOptions$nwarnings <- NULL
[18:02:25.377]             }
[18:02:25.377]             base::options(...future.oldOptions)
[18:02:25.377]             if (.Platform$OS.type == "windows") {
[18:02:25.377]                 old_names <- names(...future.oldEnvVars)
[18:02:25.377]                 envs <- base::Sys.getenv()
[18:02:25.377]                 names <- names(envs)
[18:02:25.377]                 common <- intersect(names, old_names)
[18:02:25.377]                 added <- setdiff(names, old_names)
[18:02:25.377]                 removed <- setdiff(old_names, names)
[18:02:25.377]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:25.377]                   envs[common]]
[18:02:25.377]                 NAMES <- toupper(changed)
[18:02:25.377]                 args <- list()
[18:02:25.377]                 for (kk in seq_along(NAMES)) {
[18:02:25.377]                   name <- changed[[kk]]
[18:02:25.377]                   NAME <- NAMES[[kk]]
[18:02:25.377]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:25.377]                     next
[18:02:25.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:25.377]                 }
[18:02:25.377]                 NAMES <- toupper(added)
[18:02:25.377]                 for (kk in seq_along(NAMES)) {
[18:02:25.377]                   name <- added[[kk]]
[18:02:25.377]                   NAME <- NAMES[[kk]]
[18:02:25.377]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:25.377]                     next
[18:02:25.377]                   args[[name]] <- ""
[18:02:25.377]                 }
[18:02:25.377]                 NAMES <- toupper(removed)
[18:02:25.377]                 for (kk in seq_along(NAMES)) {
[18:02:25.377]                   name <- removed[[kk]]
[18:02:25.377]                   NAME <- NAMES[[kk]]
[18:02:25.377]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:25.377]                     next
[18:02:25.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:25.377]                 }
[18:02:25.377]                 if (length(args) > 0) 
[18:02:25.377]                   base::do.call(base::Sys.setenv, args = args)
[18:02:25.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:25.377]             }
[18:02:25.377]             else {
[18:02:25.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:25.377]             }
[18:02:25.377]             {
[18:02:25.377]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:25.377]                   0L) {
[18:02:25.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:25.377]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:25.377]                   base::options(opts)
[18:02:25.377]                 }
[18:02:25.377]                 {
[18:02:25.377]                   {
[18:02:25.377]                     NULL
[18:02:25.377]                     RNGkind("Mersenne-Twister")
[18:02:25.377]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:25.377]                       inherits = FALSE)
[18:02:25.377]                   }
[18:02:25.377]                   options(future.plan = NULL)
[18:02:25.377]                   if (is.na(NA_character_)) 
[18:02:25.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:25.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:25.377]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:25.377]                     .init = FALSE)
[18:02:25.377]                 }
[18:02:25.377]             }
[18:02:25.377]         }
[18:02:25.377]     })
[18:02:25.377]     if (TRUE) {
[18:02:25.377]         base::sink(type = "output", split = FALSE)
[18:02:25.377]         if (TRUE) {
[18:02:25.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:25.377]         }
[18:02:25.377]         else {
[18:02:25.377]             ...future.result["stdout"] <- base::list(NULL)
[18:02:25.377]         }
[18:02:25.377]         base::close(...future.stdout)
[18:02:25.377]         ...future.stdout <- NULL
[18:02:25.377]     }
[18:02:25.377]     ...future.result$conditions <- ...future.conditions
[18:02:25.377]     ...future.result$finished <- base::Sys.time()
[18:02:25.377]     ...future.result
[18:02:25.377] }
[18:02:25.381] plan(): Setting new future strategy stack:
[18:02:25.381] List of future strategies:
[18:02:25.381] 1. sequential:
[18:02:25.381]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:25.381]    - tweaked: FALSE
[18:02:25.381]    - call: NULL
[18:02:25.382] plan(): nbrOfWorkers() = 1
[18:02:25.384] plan(): Setting new future strategy stack:
[18:02:25.384] List of future strategies:
[18:02:25.384] 1. multisession:
[18:02:25.384]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:02:25.384]    - tweaked: FALSE
[18:02:25.384]    - call: plan(strategy)
[18:02:25.390] plan(): nbrOfWorkers() = 1
[18:02:25.391] SequentialFuture started (and completed)
[18:02:25.391] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:02:25.397] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[18:02:25.397] future_lapply() ...
[18:02:25.404] Number of chunks: 1
[18:02:25.405] getGlobalsAndPackagesXApply() ...
[18:02:25.405]  - future.globals: TRUE
[18:02:25.405] getGlobalsAndPackages() ...
[18:02:25.405] Searching for globals...
[18:02:25.411] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:25.412] Searching for globals ... DONE
[18:02:25.412] Resolving globals: FALSE
[18:02:25.413] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:25.414] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:25.414] - globals: [1] ‘FUN’
[18:02:25.414] 
[18:02:25.414] getGlobalsAndPackages() ... DONE
[18:02:25.415]  - globals found/used: [n=1] ‘FUN’
[18:02:25.415]  - needed namespaces: [n=0] 
[18:02:25.415] Finding globals ... DONE
[18:02:25.415]  - use_args: TRUE
[18:02:25.415]  - Getting '...' globals ...
[18:02:25.416] resolve() on list ...
[18:02:25.416]  recursive: 0
[18:02:25.417]  length: 1
[18:02:25.417]  elements: ‘...’
[18:02:25.417]  length: 0 (resolved future 1)
[18:02:25.417] resolve() on list ... DONE
[18:02:25.417]    - '...' content: [n=0] 
[18:02:25.418] List of 1
[18:02:25.418]  $ ...: list()
[18:02:25.418]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:25.418]  - attr(*, "where")=List of 1
[18:02:25.418]   ..$ ...:<environment: 0x5e4f85817d18> 
[18:02:25.418]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:25.418]  - attr(*, "resolved")= logi TRUE
[18:02:25.418]  - attr(*, "total_size")= num NA
[18:02:25.423]  - Getting '...' globals ... DONE
[18:02:25.424] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:25.424] List of 2
[18:02:25.424]  $ ...future.FUN:function (x)  
[18:02:25.424]  $ ...          : list()
[18:02:25.424]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:25.424]  - attr(*, "where")=List of 2
[18:02:25.424]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:25.424]   ..$ ...          :<environment: 0x5e4f85817d18> 
[18:02:25.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:25.424]  - attr(*, "resolved")= logi FALSE
[18:02:25.424]  - attr(*, "total_size")= num 4720
[18:02:25.430] Packages to be attached in all futures: [n=0] 
[18:02:25.430] getGlobalsAndPackagesXApply() ... DONE
[18:02:25.431] Number of futures (= number of chunks): 1
[18:02:25.431] Launching 1 futures (chunks) ...
[18:02:25.431] Chunk #1 of 1 ...
[18:02:25.431]  - Finding globals in 'X' for chunk #1 ...
[18:02:25.432] getGlobalsAndPackages() ...
[18:02:25.432] Searching for globals...
[18:02:25.432] 
[18:02:25.433] Searching for globals ... DONE
[18:02:25.433] - globals: [0] <none>
[18:02:25.433] getGlobalsAndPackages() ... DONE
[18:02:25.433]    + additional globals found: [n=0] 
[18:02:25.433]    + additional namespaces needed: [n=0] 
[18:02:25.434]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:25.434]  - seeds: <none>
[18:02:25.434]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:25.434] getGlobalsAndPackages() ...
[18:02:25.434] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:25.435] Resolving globals: FALSE
[18:02:25.435] Tweak future expression to call with '...' arguments ...
[18:02:25.435] {
[18:02:25.435]     do.call(function(...) {
[18:02:25.435]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:25.435]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:25.435]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:25.435]             on.exit(options(oopts), add = TRUE)
[18:02:25.435]         }
[18:02:25.435]         {
[18:02:25.435]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:25.435]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:25.435]                 ...future.FUN(...future.X_jj, ...)
[18:02:25.435]             })
[18:02:25.435]         }
[18:02:25.435]     }, args = future.call.arguments)
[18:02:25.435] }
[18:02:25.436] Tweak future expression to call with '...' arguments ... DONE
[18:02:25.436] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:25.437] 
[18:02:25.437] getGlobalsAndPackages() ... DONE
[18:02:25.437] run() for ‘Future’ ...
[18:02:25.438] - state: ‘created’
[18:02:25.438] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:25.444] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:25.444] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:25.445]   - Field: ‘label’
[18:02:25.445]   - Field: ‘local’
[18:02:25.445]   - Field: ‘owner’
[18:02:25.445]   - Field: ‘envir’
[18:02:25.446]   - Field: ‘packages’
[18:02:25.446]   - Field: ‘gc’
[18:02:25.446]   - Field: ‘conditions’
[18:02:25.446]   - Field: ‘expr’
[18:02:25.446]   - Field: ‘uuid’
[18:02:25.447]   - Field: ‘seed’
[18:02:25.447]   - Field: ‘version’
[18:02:25.447]   - Field: ‘result’
[18:02:25.447]   - Field: ‘asynchronous’
[18:02:25.447]   - Field: ‘calls’
[18:02:25.448]   - Field: ‘globals’
[18:02:25.448]   - Field: ‘stdout’
[18:02:25.448]   - Field: ‘earlySignal’
[18:02:25.448]   - Field: ‘lazy’
[18:02:25.449]   - Field: ‘state’
[18:02:25.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:25.449] - Launch lazy future ...
[18:02:25.449] Packages needed by the future expression (n = 0): <none>
[18:02:25.450] Packages needed by future strategies (n = 0): <none>
[18:02:25.451] {
[18:02:25.451]     {
[18:02:25.451]         {
[18:02:25.451]             ...future.startTime <- base::Sys.time()
[18:02:25.451]             {
[18:02:25.451]                 {
[18:02:25.451]                   {
[18:02:25.451]                     base::local({
[18:02:25.451]                       has_future <- base::requireNamespace("future", 
[18:02:25.451]                         quietly = TRUE)
[18:02:25.451]                       if (has_future) {
[18:02:25.451]                         ns <- base::getNamespace("future")
[18:02:25.451]                         version <- ns[[".package"]][["version"]]
[18:02:25.451]                         if (is.null(version)) 
[18:02:25.451]                           version <- utils::packageVersion("future")
[18:02:25.451]                       }
[18:02:25.451]                       else {
[18:02:25.451]                         version <- NULL
[18:02:25.451]                       }
[18:02:25.451]                       if (!has_future || version < "1.8.0") {
[18:02:25.451]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:25.451]                           "", base::R.version$version.string), 
[18:02:25.451]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:25.451]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:25.451]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:25.451]                             "release", "version")], collapse = " "), 
[18:02:25.451]                           hostname = base::Sys.info()[["nodename"]])
[18:02:25.451]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:25.451]                           info)
[18:02:25.451]                         info <- base::paste(info, collapse = "; ")
[18:02:25.451]                         if (!has_future) {
[18:02:25.451]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:25.451]                             info)
[18:02:25.451]                         }
[18:02:25.451]                         else {
[18:02:25.451]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:25.451]                             info, version)
[18:02:25.451]                         }
[18:02:25.451]                         base::stop(msg)
[18:02:25.451]                       }
[18:02:25.451]                     })
[18:02:25.451]                   }
[18:02:25.451]                   ...future.strategy.old <- future::plan("list")
[18:02:25.451]                   options(future.plan = NULL)
[18:02:25.451]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:25.451]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:25.451]                 }
[18:02:25.451]                 ...future.workdir <- getwd()
[18:02:25.451]             }
[18:02:25.451]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:25.451]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:25.451]         }
[18:02:25.451]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:25.451]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:25.451]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:25.451]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:25.451]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:25.451]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:25.451]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:25.451]             base::names(...future.oldOptions))
[18:02:25.451]     }
[18:02:25.451]     if (FALSE) {
[18:02:25.451]     }
[18:02:25.451]     else {
[18:02:25.451]         if (FALSE) {
[18:02:25.451]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:25.451]                 open = "w")
[18:02:25.451]         }
[18:02:25.451]         else {
[18:02:25.451]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:25.451]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:25.451]         }
[18:02:25.451]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:25.451]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:25.451]             base::sink(type = "output", split = FALSE)
[18:02:25.451]             base::close(...future.stdout)
[18:02:25.451]         }, add = TRUE)
[18:02:25.451]     }
[18:02:25.451]     ...future.frame <- base::sys.nframe()
[18:02:25.451]     ...future.conditions <- base::list()
[18:02:25.451]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:25.451]     if (FALSE) {
[18:02:25.451]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:25.451]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:25.451]     }
[18:02:25.451]     ...future.result <- base::tryCatch({
[18:02:25.451]         base::withCallingHandlers({
[18:02:25.451]             ...future.value <- base::withVisible(base::local({
[18:02:25.451]                 do.call(function(...) {
[18:02:25.451]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:25.451]                   if (!identical(...future.globals.maxSize.org, 
[18:02:25.451]                     ...future.globals.maxSize)) {
[18:02:25.451]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:25.451]                     on.exit(options(oopts), add = TRUE)
[18:02:25.451]                   }
[18:02:25.451]                   {
[18:02:25.451]                     lapply(seq_along(...future.elements_ii), 
[18:02:25.451]                       FUN = function(jj) {
[18:02:25.451]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:25.451]                         ...future.FUN(...future.X_jj, ...)
[18:02:25.451]                       })
[18:02:25.451]                   }
[18:02:25.451]                 }, args = future.call.arguments)
[18:02:25.451]             }))
[18:02:25.451]             future::FutureResult(value = ...future.value$value, 
[18:02:25.451]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:25.451]                   ...future.rng), globalenv = if (FALSE) 
[18:02:25.451]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:25.451]                     ...future.globalenv.names))
[18:02:25.451]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:25.451]         }, condition = base::local({
[18:02:25.451]             c <- base::c
[18:02:25.451]             inherits <- base::inherits
[18:02:25.451]             invokeRestart <- base::invokeRestart
[18:02:25.451]             length <- base::length
[18:02:25.451]             list <- base::list
[18:02:25.451]             seq.int <- base::seq.int
[18:02:25.451]             signalCondition <- base::signalCondition
[18:02:25.451]             sys.calls <- base::sys.calls
[18:02:25.451]             `[[` <- base::`[[`
[18:02:25.451]             `+` <- base::`+`
[18:02:25.451]             `<<-` <- base::`<<-`
[18:02:25.451]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:25.451]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:25.451]                   3L)]
[18:02:25.451]             }
[18:02:25.451]             function(cond) {
[18:02:25.451]                 is_error <- inherits(cond, "error")
[18:02:25.451]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:25.451]                   NULL)
[18:02:25.451]                 if (is_error) {
[18:02:25.451]                   sessionInformation <- function() {
[18:02:25.451]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:25.451]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:25.451]                       search = base::search(), system = base::Sys.info())
[18:02:25.451]                   }
[18:02:25.451]                   ...future.conditions[[length(...future.conditions) + 
[18:02:25.451]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:25.451]                     cond$call), session = sessionInformation(), 
[18:02:25.451]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:25.451]                   signalCondition(cond)
[18:02:25.451]                 }
[18:02:25.451]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:25.451]                 "immediateCondition"))) {
[18:02:25.451]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:25.451]                   ...future.conditions[[length(...future.conditions) + 
[18:02:25.451]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:25.451]                   if (TRUE && !signal) {
[18:02:25.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:25.451]                     {
[18:02:25.451]                       inherits <- base::inherits
[18:02:25.451]                       invokeRestart <- base::invokeRestart
[18:02:25.451]                       is.null <- base::is.null
[18:02:25.451]                       muffled <- FALSE
[18:02:25.451]                       if (inherits(cond, "message")) {
[18:02:25.451]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:25.451]                         if (muffled) 
[18:02:25.451]                           invokeRestart("muffleMessage")
[18:02:25.451]                       }
[18:02:25.451]                       else if (inherits(cond, "warning")) {
[18:02:25.451]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:25.451]                         if (muffled) 
[18:02:25.451]                           invokeRestart("muffleWarning")
[18:02:25.451]                       }
[18:02:25.451]                       else if (inherits(cond, "condition")) {
[18:02:25.451]                         if (!is.null(pattern)) {
[18:02:25.451]                           computeRestarts <- base::computeRestarts
[18:02:25.451]                           grepl <- base::grepl
[18:02:25.451]                           restarts <- computeRestarts(cond)
[18:02:25.451]                           for (restart in restarts) {
[18:02:25.451]                             name <- restart$name
[18:02:25.451]                             if (is.null(name)) 
[18:02:25.451]                               next
[18:02:25.451]                             if (!grepl(pattern, name)) 
[18:02:25.451]                               next
[18:02:25.451]                             invokeRestart(restart)
[18:02:25.451]                             muffled <- TRUE
[18:02:25.451]                             break
[18:02:25.451]                           }
[18:02:25.451]                         }
[18:02:25.451]                       }
[18:02:25.451]                       invisible(muffled)
[18:02:25.451]                     }
[18:02:25.451]                     muffleCondition(cond, pattern = "^muffle")
[18:02:25.451]                   }
[18:02:25.451]                 }
[18:02:25.451]                 else {
[18:02:25.451]                   if (TRUE) {
[18:02:25.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:25.451]                     {
[18:02:25.451]                       inherits <- base::inherits
[18:02:25.451]                       invokeRestart <- base::invokeRestart
[18:02:25.451]                       is.null <- base::is.null
[18:02:25.451]                       muffled <- FALSE
[18:02:25.451]                       if (inherits(cond, "message")) {
[18:02:25.451]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:25.451]                         if (muffled) 
[18:02:25.451]                           invokeRestart("muffleMessage")
[18:02:25.451]                       }
[18:02:25.451]                       else if (inherits(cond, "warning")) {
[18:02:25.451]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:25.451]                         if (muffled) 
[18:02:25.451]                           invokeRestart("muffleWarning")
[18:02:25.451]                       }
[18:02:25.451]                       else if (inherits(cond, "condition")) {
[18:02:25.451]                         if (!is.null(pattern)) {
[18:02:25.451]                           computeRestarts <- base::computeRestarts
[18:02:25.451]                           grepl <- base::grepl
[18:02:25.451]                           restarts <- computeRestarts(cond)
[18:02:25.451]                           for (restart in restarts) {
[18:02:25.451]                             name <- restart$name
[18:02:25.451]                             if (is.null(name)) 
[18:02:25.451]                               next
[18:02:25.451]                             if (!grepl(pattern, name)) 
[18:02:25.451]                               next
[18:02:25.451]                             invokeRestart(restart)
[18:02:25.451]                             muffled <- TRUE
[18:02:25.451]                             break
[18:02:25.451]                           }
[18:02:25.451]                         }
[18:02:25.451]                       }
[18:02:25.451]                       invisible(muffled)
[18:02:25.451]                     }
[18:02:25.451]                     muffleCondition(cond, pattern = "^muffle")
[18:02:25.451]                   }
[18:02:25.451]                 }
[18:02:25.451]             }
[18:02:25.451]         }))
[18:02:25.451]     }, error = function(ex) {
[18:02:25.451]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:25.451]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:25.451]                 ...future.rng), started = ...future.startTime, 
[18:02:25.451]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:25.451]             version = "1.8"), class = "FutureResult")
[18:02:25.451]     }, finally = {
[18:02:25.451]         if (!identical(...future.workdir, getwd())) 
[18:02:25.451]             setwd(...future.workdir)
[18:02:25.451]         {
[18:02:25.451]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:25.451]                 ...future.oldOptions$nwarnings <- NULL
[18:02:25.451]             }
[18:02:25.451]             base::options(...future.oldOptions)
[18:02:25.451]             if (.Platform$OS.type == "windows") {
[18:02:25.451]                 old_names <- names(...future.oldEnvVars)
[18:02:25.451]                 envs <- base::Sys.getenv()
[18:02:25.451]                 names <- names(envs)
[18:02:25.451]                 common <- intersect(names, old_names)
[18:02:25.451]                 added <- setdiff(names, old_names)
[18:02:25.451]                 removed <- setdiff(old_names, names)
[18:02:25.451]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:25.451]                   envs[common]]
[18:02:25.451]                 NAMES <- toupper(changed)
[18:02:25.451]                 args <- list()
[18:02:25.451]                 for (kk in seq_along(NAMES)) {
[18:02:25.451]                   name <- changed[[kk]]
[18:02:25.451]                   NAME <- NAMES[[kk]]
[18:02:25.451]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:25.451]                     next
[18:02:25.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:25.451]                 }
[18:02:25.451]                 NAMES <- toupper(added)
[18:02:25.451]                 for (kk in seq_along(NAMES)) {
[18:02:25.451]                   name <- added[[kk]]
[18:02:25.451]                   NAME <- NAMES[[kk]]
[18:02:25.451]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:25.451]                     next
[18:02:25.451]                   args[[name]] <- ""
[18:02:25.451]                 }
[18:02:25.451]                 NAMES <- toupper(removed)
[18:02:25.451]                 for (kk in seq_along(NAMES)) {
[18:02:25.451]                   name <- removed[[kk]]
[18:02:25.451]                   NAME <- NAMES[[kk]]
[18:02:25.451]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:25.451]                     next
[18:02:25.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:25.451]                 }
[18:02:25.451]                 if (length(args) > 0) 
[18:02:25.451]                   base::do.call(base::Sys.setenv, args = args)
[18:02:25.451]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:25.451]             }
[18:02:25.451]             else {
[18:02:25.451]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:25.451]             }
[18:02:25.451]             {
[18:02:25.451]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:25.451]                   0L) {
[18:02:25.451]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:25.451]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:25.451]                   base::options(opts)
[18:02:25.451]                 }
[18:02:25.451]                 {
[18:02:25.451]                   {
[18:02:25.451]                     NULL
[18:02:25.451]                     RNGkind("Mersenne-Twister")
[18:02:25.451]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:25.451]                       inherits = FALSE)
[18:02:25.451]                   }
[18:02:25.451]                   options(future.plan = NULL)
[18:02:25.451]                   if (is.na(NA_character_)) 
[18:02:25.451]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:25.451]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:25.451]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:25.451]                     .init = FALSE)
[18:02:25.451]                 }
[18:02:25.451]             }
[18:02:25.451]         }
[18:02:25.451]     })
[18:02:25.451]     if (TRUE) {
[18:02:25.451]         base::sink(type = "output", split = FALSE)
[18:02:25.451]         if (FALSE) {
[18:02:25.451]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:25.451]         }
[18:02:25.451]         else {
[18:02:25.451]             ...future.result["stdout"] <- base::list(NULL)
[18:02:25.451]         }
[18:02:25.451]         base::close(...future.stdout)
[18:02:25.451]         ...future.stdout <- NULL
[18:02:25.451]     }
[18:02:25.451]     ...future.result$conditions <- ...future.conditions
[18:02:25.451]     ...future.result$finished <- base::Sys.time()
[18:02:25.451]     ...future.result
[18:02:25.451] }
[18:02:25.454] assign_globals() ...
[18:02:25.454] List of 5
[18:02:25.454]  $ ...future.FUN            :function (x)  
[18:02:25.454]  $ future.call.arguments    : list()
[18:02:25.454]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:25.454]  $ ...future.elements_ii    :List of 2
[18:02:25.454]   ..$ : int 1
[18:02:25.454]   ..$ : int 0
[18:02:25.454]  $ ...future.seeds_ii       : NULL
[18:02:25.454]  $ ...future.globals.maxSize: NULL
[18:02:25.454]  - attr(*, "where")=List of 5
[18:02:25.454]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:25.454]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:25.454]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:25.454]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:25.454]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:25.454]  - attr(*, "resolved")= logi FALSE
[18:02:25.454]  - attr(*, "total_size")= num 4720
[18:02:25.454]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:25.454]  - attr(*, "already-done")= logi TRUE
[18:02:25.499] - reassign environment for ‘...future.FUN’
[18:02:25.500] - copied ‘...future.FUN’ to environment
[18:02:25.500] - copied ‘future.call.arguments’ to environment
[18:02:25.500] - copied ‘...future.elements_ii’ to environment
[18:02:25.500] - copied ‘...future.seeds_ii’ to environment
[18:02:25.500] - copied ‘...future.globals.maxSize’ to environment
[18:02:25.501] assign_globals() ... done
[18:02:25.501] plan(): Setting new future strategy stack:
[18:02:25.501] List of future strategies:
[18:02:25.501] 1. sequential:
[18:02:25.501]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:25.501]    - tweaked: FALSE
[18:02:25.501]    - call: NULL
[18:02:25.502] plan(): nbrOfWorkers() = 1
[18:02:26.005] plan(): Setting new future strategy stack:
[18:02:26.005] List of future strategies:
[18:02:26.005] 1. multisession:
[18:02:26.005]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:02:26.005]    - tweaked: FALSE
[18:02:26.005]    - call: plan(strategy)
[18:02:26.011] plan(): nbrOfWorkers() = 1
[18:02:26.012] SequentialFuture started (and completed)
[18:02:26.012] - Launch lazy future ... done
[18:02:26.012] run() for ‘SequentialFuture’ ... done
[18:02:26.012] Created future:
[18:02:26.013] SequentialFuture:
[18:02:26.013] Label: ‘future_lapply-1’
[18:02:26.013] Expression:
[18:02:26.013] {
[18:02:26.013]     do.call(function(...) {
[18:02:26.013]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:26.013]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:26.013]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:26.013]             on.exit(options(oopts), add = TRUE)
[18:02:26.013]         }
[18:02:26.013]         {
[18:02:26.013]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:26.013]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:26.013]                 ...future.FUN(...future.X_jj, ...)
[18:02:26.013]             })
[18:02:26.013]         }
[18:02:26.013]     }, args = future.call.arguments)
[18:02:26.013] }
[18:02:26.013] Lazy evaluation: FALSE
[18:02:26.013] Asynchronous evaluation: FALSE
[18:02:26.013] Local evaluation: TRUE
[18:02:26.013] Environment: R_GlobalEnv
[18:02:26.013] Capture standard output: FALSE
[18:02:26.013] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:26.013] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:26.013] Packages: <none>
[18:02:26.013] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:26.013] Resolved: TRUE
[18:02:26.013] Value: 112 bytes of class ‘list’
[18:02:26.013] Early signaling: FALSE
[18:02:26.013] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:26.013] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:26.015] Chunk #1 of 1 ... DONE
[18:02:26.015] Launching 1 futures (chunks) ... DONE
[18:02:26.015] Resolving 1 futures (chunks) ...
[18:02:26.015] resolve() on list ...
[18:02:26.015]  recursive: 0
[18:02:26.016]  length: 1
[18:02:26.016] 
[18:02:26.016] resolved() for ‘SequentialFuture’ ...
[18:02:26.016] - state: ‘finished’
[18:02:26.016] - run: TRUE
[18:02:26.017] - result: ‘FutureResult’
[18:02:26.017] resolved() for ‘SequentialFuture’ ... done
[18:02:26.017] Future #1
[18:02:26.017] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:26.018] - nx: 1
[18:02:26.018] - relay: TRUE
[18:02:26.018] - stdout: TRUE
[18:02:26.018] - signal: TRUE
[18:02:26.018] - resignal: FALSE
[18:02:26.018] - force: TRUE
[18:02:26.019] - relayed: [n=1] FALSE
[18:02:26.019] - queued futures: [n=1] FALSE
[18:02:26.019]  - until=1
[18:02:26.019]  - relaying element #1
[18:02:26.020] - relayed: [n=1] TRUE
[18:02:26.020] - queued futures: [n=1] TRUE
[18:02:26.020] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:26.020]  length: 0 (resolved future 1)
[18:02:26.020] Relaying remaining futures
[18:02:26.020] signalConditionsASAP(NULL, pos=0) ...
[18:02:26.021] - nx: 1
[18:02:26.021] - relay: TRUE
[18:02:26.021] - stdout: TRUE
[18:02:26.021] - signal: TRUE
[18:02:26.021] - resignal: FALSE
[18:02:26.022] - force: TRUE
[18:02:26.022] - relayed: [n=1] TRUE
[18:02:26.022] - queued futures: [n=1] TRUE
 - flush all
[18:02:26.022] - relayed: [n=1] TRUE
[18:02:26.022] - queued futures: [n=1] TRUE
[18:02:26.023] signalConditionsASAP(NULL, pos=0) ... done
[18:02:26.023] resolve() on list ... DONE
[18:02:26.023]  - Number of value chunks collected: 1
[18:02:26.023] Resolving 1 futures (chunks) ... DONE
[18:02:26.023] Reducing values from 1 chunks ...
[18:02:26.024]  - Number of values collected after concatenation: 2
[18:02:26.024]  - Number of values expected: 2
[18:02:26.024] Reducing values from 1 chunks ... DONE
[18:02:26.024] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[18:02:26.025] future_lapply() ...
[18:02:26.032] Number of chunks: 1
[18:02:26.032] getGlobalsAndPackagesXApply() ...
[18:02:26.032]  - future.globals: TRUE
[18:02:26.032] getGlobalsAndPackages() ...
[18:02:26.033] Searching for globals...
[18:02:26.035] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:26.036] Searching for globals ... DONE
[18:02:26.036] Resolving globals: FALSE
[18:02:26.037] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:26.037] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:26.038] - globals: [1] ‘FUN’
[18:02:26.038] 
[18:02:26.038] getGlobalsAndPackages() ... DONE
[18:02:26.038]  - globals found/used: [n=1] ‘FUN’
[18:02:26.038]  - needed namespaces: [n=0] 
[18:02:26.039] Finding globals ... DONE
[18:02:26.039]  - use_args: TRUE
[18:02:26.039]  - Getting '...' globals ...
[18:02:26.040] resolve() on list ...
[18:02:26.040]  recursive: 0
[18:02:26.040]  length: 1
[18:02:26.040]  elements: ‘...’
[18:02:26.040]  length: 0 (resolved future 1)
[18:02:26.041] resolve() on list ... DONE
[18:02:26.041]    - '...' content: [n=0] 
[18:02:26.041] List of 1
[18:02:26.041]  $ ...: list()
[18:02:26.041]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:26.041]  - attr(*, "where")=List of 1
[18:02:26.041]   ..$ ...:<environment: 0x5e4f840b5f18> 
[18:02:26.041]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:26.041]  - attr(*, "resolved")= logi TRUE
[18:02:26.041]  - attr(*, "total_size")= num NA
[18:02:26.046]  - Getting '...' globals ... DONE
[18:02:26.046] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:26.047] List of 2
[18:02:26.047]  $ ...future.FUN:function (x)  
[18:02:26.047]  $ ...          : list()
[18:02:26.047]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:26.047]  - attr(*, "where")=List of 2
[18:02:26.047]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:26.047]   ..$ ...          :<environment: 0x5e4f840b5f18> 
[18:02:26.047]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:26.047]  - attr(*, "resolved")= logi FALSE
[18:02:26.047]  - attr(*, "total_size")= num 4720
[18:02:26.052] Packages to be attached in all futures: [n=0] 
[18:02:26.052] getGlobalsAndPackagesXApply() ... DONE
[18:02:26.052] Number of futures (= number of chunks): 1
[18:02:26.053] Launching 1 futures (chunks) ...
[18:02:26.053] Chunk #1 of 1 ...
[18:02:26.053]  - Finding globals in 'X' for chunk #1 ...
[18:02:26.053] getGlobalsAndPackages() ...
[18:02:26.054] Searching for globals...
[18:02:26.054] 
[18:02:26.054] Searching for globals ... DONE
[18:02:26.055] - globals: [0] <none>
[18:02:26.055] getGlobalsAndPackages() ... DONE
[18:02:26.055]    + additional globals found: [n=0] 
[18:02:26.055]    + additional namespaces needed: [n=0] 
[18:02:26.055]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:26.055]  - seeds: <none>
[18:02:26.056]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:26.056] getGlobalsAndPackages() ...
[18:02:26.056] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:26.056] Resolving globals: FALSE
[18:02:26.057] Tweak future expression to call with '...' arguments ...
[18:02:26.057] {
[18:02:26.057]     do.call(function(...) {
[18:02:26.057]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:26.057]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:26.057]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:26.057]             on.exit(options(oopts), add = TRUE)
[18:02:26.057]         }
[18:02:26.057]         {
[18:02:26.057]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:26.057]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:26.057]                 ...future.FUN(...future.X_jj, ...)
[18:02:26.057]             })
[18:02:26.057]         }
[18:02:26.057]     }, args = future.call.arguments)
[18:02:26.057] }
[18:02:26.057] Tweak future expression to call with '...' arguments ... DONE
[18:02:26.058] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:26.058] 
[18:02:26.058] getGlobalsAndPackages() ... DONE
[18:02:26.059] run() for ‘Future’ ...
[18:02:26.059] - state: ‘created’
[18:02:26.059] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:26.068] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:26.068] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:26.068]   - Field: ‘label’
[18:02:26.069]   - Field: ‘local’
[18:02:26.069]   - Field: ‘owner’
[18:02:26.069]   - Field: ‘envir’
[18:02:26.069]   - Field: ‘packages’
[18:02:26.069]   - Field: ‘gc’
[18:02:26.070]   - Field: ‘conditions’
[18:02:26.070]   - Field: ‘expr’
[18:02:26.070]   - Field: ‘uuid’
[18:02:26.070]   - Field: ‘seed’
[18:02:26.070]   - Field: ‘version’
[18:02:26.071]   - Field: ‘result’
[18:02:26.071]   - Field: ‘asynchronous’
[18:02:26.071]   - Field: ‘calls’
[18:02:26.071]   - Field: ‘globals’
[18:02:26.071]   - Field: ‘stdout’
[18:02:26.072]   - Field: ‘earlySignal’
[18:02:26.072]   - Field: ‘lazy’
[18:02:26.072]   - Field: ‘state’
[18:02:26.072] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:26.072] - Launch lazy future ...
[18:02:26.073] Packages needed by the future expression (n = 0): <none>
[18:02:26.073] Packages needed by future strategies (n = 0): <none>
[18:02:26.074] {
[18:02:26.074]     {
[18:02:26.074]         {
[18:02:26.074]             ...future.startTime <- base::Sys.time()
[18:02:26.074]             {
[18:02:26.074]                 {
[18:02:26.074]                   {
[18:02:26.074]                     base::local({
[18:02:26.074]                       has_future <- base::requireNamespace("future", 
[18:02:26.074]                         quietly = TRUE)
[18:02:26.074]                       if (has_future) {
[18:02:26.074]                         ns <- base::getNamespace("future")
[18:02:26.074]                         version <- ns[[".package"]][["version"]]
[18:02:26.074]                         if (is.null(version)) 
[18:02:26.074]                           version <- utils::packageVersion("future")
[18:02:26.074]                       }
[18:02:26.074]                       else {
[18:02:26.074]                         version <- NULL
[18:02:26.074]                       }
[18:02:26.074]                       if (!has_future || version < "1.8.0") {
[18:02:26.074]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:26.074]                           "", base::R.version$version.string), 
[18:02:26.074]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:26.074]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:26.074]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:26.074]                             "release", "version")], collapse = " "), 
[18:02:26.074]                           hostname = base::Sys.info()[["nodename"]])
[18:02:26.074]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:26.074]                           info)
[18:02:26.074]                         info <- base::paste(info, collapse = "; ")
[18:02:26.074]                         if (!has_future) {
[18:02:26.074]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:26.074]                             info)
[18:02:26.074]                         }
[18:02:26.074]                         else {
[18:02:26.074]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:26.074]                             info, version)
[18:02:26.074]                         }
[18:02:26.074]                         base::stop(msg)
[18:02:26.074]                       }
[18:02:26.074]                     })
[18:02:26.074]                   }
[18:02:26.074]                   ...future.strategy.old <- future::plan("list")
[18:02:26.074]                   options(future.plan = NULL)
[18:02:26.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:26.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:26.074]                 }
[18:02:26.074]                 ...future.workdir <- getwd()
[18:02:26.074]             }
[18:02:26.074]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:26.074]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:26.074]         }
[18:02:26.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:26.074]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:26.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:26.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:26.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:26.074]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:26.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:26.074]             base::names(...future.oldOptions))
[18:02:26.074]     }
[18:02:26.074]     if (FALSE) {
[18:02:26.074]     }
[18:02:26.074]     else {
[18:02:26.074]         if (TRUE) {
[18:02:26.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:26.074]                 open = "w")
[18:02:26.074]         }
[18:02:26.074]         else {
[18:02:26.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:26.074]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:26.074]         }
[18:02:26.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:26.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:26.074]             base::sink(type = "output", split = FALSE)
[18:02:26.074]             base::close(...future.stdout)
[18:02:26.074]         }, add = TRUE)
[18:02:26.074]     }
[18:02:26.074]     ...future.frame <- base::sys.nframe()
[18:02:26.074]     ...future.conditions <- base::list()
[18:02:26.074]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:26.074]     if (FALSE) {
[18:02:26.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:26.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:26.074]     }
[18:02:26.074]     ...future.result <- base::tryCatch({
[18:02:26.074]         base::withCallingHandlers({
[18:02:26.074]             ...future.value <- base::withVisible(base::local({
[18:02:26.074]                 do.call(function(...) {
[18:02:26.074]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:26.074]                   if (!identical(...future.globals.maxSize.org, 
[18:02:26.074]                     ...future.globals.maxSize)) {
[18:02:26.074]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:26.074]                     on.exit(options(oopts), add = TRUE)
[18:02:26.074]                   }
[18:02:26.074]                   {
[18:02:26.074]                     lapply(seq_along(...future.elements_ii), 
[18:02:26.074]                       FUN = function(jj) {
[18:02:26.074]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:26.074]                         ...future.FUN(...future.X_jj, ...)
[18:02:26.074]                       })
[18:02:26.074]                   }
[18:02:26.074]                 }, args = future.call.arguments)
[18:02:26.074]             }))
[18:02:26.074]             future::FutureResult(value = ...future.value$value, 
[18:02:26.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:26.074]                   ...future.rng), globalenv = if (FALSE) 
[18:02:26.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:26.074]                     ...future.globalenv.names))
[18:02:26.074]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:26.074]         }, condition = base::local({
[18:02:26.074]             c <- base::c
[18:02:26.074]             inherits <- base::inherits
[18:02:26.074]             invokeRestart <- base::invokeRestart
[18:02:26.074]             length <- base::length
[18:02:26.074]             list <- base::list
[18:02:26.074]             seq.int <- base::seq.int
[18:02:26.074]             signalCondition <- base::signalCondition
[18:02:26.074]             sys.calls <- base::sys.calls
[18:02:26.074]             `[[` <- base::`[[`
[18:02:26.074]             `+` <- base::`+`
[18:02:26.074]             `<<-` <- base::`<<-`
[18:02:26.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:26.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:26.074]                   3L)]
[18:02:26.074]             }
[18:02:26.074]             function(cond) {
[18:02:26.074]                 is_error <- inherits(cond, "error")
[18:02:26.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:26.074]                   NULL)
[18:02:26.074]                 if (is_error) {
[18:02:26.074]                   sessionInformation <- function() {
[18:02:26.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:26.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:26.074]                       search = base::search(), system = base::Sys.info())
[18:02:26.074]                   }
[18:02:26.074]                   ...future.conditions[[length(...future.conditions) + 
[18:02:26.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:26.074]                     cond$call), session = sessionInformation(), 
[18:02:26.074]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:26.074]                   signalCondition(cond)
[18:02:26.074]                 }
[18:02:26.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:26.074]                 "immediateCondition"))) {
[18:02:26.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:26.074]                   ...future.conditions[[length(...future.conditions) + 
[18:02:26.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:26.074]                   if (TRUE && !signal) {
[18:02:26.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:26.074]                     {
[18:02:26.074]                       inherits <- base::inherits
[18:02:26.074]                       invokeRestart <- base::invokeRestart
[18:02:26.074]                       is.null <- base::is.null
[18:02:26.074]                       muffled <- FALSE
[18:02:26.074]                       if (inherits(cond, "message")) {
[18:02:26.074]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:26.074]                         if (muffled) 
[18:02:26.074]                           invokeRestart("muffleMessage")
[18:02:26.074]                       }
[18:02:26.074]                       else if (inherits(cond, "warning")) {
[18:02:26.074]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:26.074]                         if (muffled) 
[18:02:26.074]                           invokeRestart("muffleWarning")
[18:02:26.074]                       }
[18:02:26.074]                       else if (inherits(cond, "condition")) {
[18:02:26.074]                         if (!is.null(pattern)) {
[18:02:26.074]                           computeRestarts <- base::computeRestarts
[18:02:26.074]                           grepl <- base::grepl
[18:02:26.074]                           restarts <- computeRestarts(cond)
[18:02:26.074]                           for (restart in restarts) {
[18:02:26.074]                             name <- restart$name
[18:02:26.074]                             if (is.null(name)) 
[18:02:26.074]                               next
[18:02:26.074]                             if (!grepl(pattern, name)) 
[18:02:26.074]                               next
[18:02:26.074]                             invokeRestart(restart)
[18:02:26.074]                             muffled <- TRUE
[18:02:26.074]                             break
[18:02:26.074]                           }
[18:02:26.074]                         }
[18:02:26.074]                       }
[18:02:26.074]                       invisible(muffled)
[18:02:26.074]                     }
[18:02:26.074]                     muffleCondition(cond, pattern = "^muffle")
[18:02:26.074]                   }
[18:02:26.074]                 }
[18:02:26.074]                 else {
[18:02:26.074]                   if (TRUE) {
[18:02:26.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:26.074]                     {
[18:02:26.074]                       inherits <- base::inherits
[18:02:26.074]                       invokeRestart <- base::invokeRestart
[18:02:26.074]                       is.null <- base::is.null
[18:02:26.074]                       muffled <- FALSE
[18:02:26.074]                       if (inherits(cond, "message")) {
[18:02:26.074]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:26.074]                         if (muffled) 
[18:02:26.074]                           invokeRestart("muffleMessage")
[18:02:26.074]                       }
[18:02:26.074]                       else if (inherits(cond, "warning")) {
[18:02:26.074]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:26.074]                         if (muffled) 
[18:02:26.074]                           invokeRestart("muffleWarning")
[18:02:26.074]                       }
[18:02:26.074]                       else if (inherits(cond, "condition")) {
[18:02:26.074]                         if (!is.null(pattern)) {
[18:02:26.074]                           computeRestarts <- base::computeRestarts
[18:02:26.074]                           grepl <- base::grepl
[18:02:26.074]                           restarts <- computeRestarts(cond)
[18:02:26.074]                           for (restart in restarts) {
[18:02:26.074]                             name <- restart$name
[18:02:26.074]                             if (is.null(name)) 
[18:02:26.074]                               next
[18:02:26.074]                             if (!grepl(pattern, name)) 
[18:02:26.074]                               next
[18:02:26.074]                             invokeRestart(restart)
[18:02:26.074]                             muffled <- TRUE
[18:02:26.074]                             break
[18:02:26.074]                           }
[18:02:26.074]                         }
[18:02:26.074]                       }
[18:02:26.074]                       invisible(muffled)
[18:02:26.074]                     }
[18:02:26.074]                     muffleCondition(cond, pattern = "^muffle")
[18:02:26.074]                   }
[18:02:26.074]                 }
[18:02:26.074]             }
[18:02:26.074]         }))
[18:02:26.074]     }, error = function(ex) {
[18:02:26.074]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:26.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:26.074]                 ...future.rng), started = ...future.startTime, 
[18:02:26.074]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:26.074]             version = "1.8"), class = "FutureResult")
[18:02:26.074]     }, finally = {
[18:02:26.074]         if (!identical(...future.workdir, getwd())) 
[18:02:26.074]             setwd(...future.workdir)
[18:02:26.074]         {
[18:02:26.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:26.074]                 ...future.oldOptions$nwarnings <- NULL
[18:02:26.074]             }
[18:02:26.074]             base::options(...future.oldOptions)
[18:02:26.074]             if (.Platform$OS.type == "windows") {
[18:02:26.074]                 old_names <- names(...future.oldEnvVars)
[18:02:26.074]                 envs <- base::Sys.getenv()
[18:02:26.074]                 names <- names(envs)
[18:02:26.074]                 common <- intersect(names, old_names)
[18:02:26.074]                 added <- setdiff(names, old_names)
[18:02:26.074]                 removed <- setdiff(old_names, names)
[18:02:26.074]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:26.074]                   envs[common]]
[18:02:26.074]                 NAMES <- toupper(changed)
[18:02:26.074]                 args <- list()
[18:02:26.074]                 for (kk in seq_along(NAMES)) {
[18:02:26.074]                   name <- changed[[kk]]
[18:02:26.074]                   NAME <- NAMES[[kk]]
[18:02:26.074]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:26.074]                     next
[18:02:26.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:26.074]                 }
[18:02:26.074]                 NAMES <- toupper(added)
[18:02:26.074]                 for (kk in seq_along(NAMES)) {
[18:02:26.074]                   name <- added[[kk]]
[18:02:26.074]                   NAME <- NAMES[[kk]]
[18:02:26.074]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:26.074]                     next
[18:02:26.074]                   args[[name]] <- ""
[18:02:26.074]                 }
[18:02:26.074]                 NAMES <- toupper(removed)
[18:02:26.074]                 for (kk in seq_along(NAMES)) {
[18:02:26.074]                   name <- removed[[kk]]
[18:02:26.074]                   NAME <- NAMES[[kk]]
[18:02:26.074]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:26.074]                     next
[18:02:26.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:26.074]                 }
[18:02:26.074]                 if (length(args) > 0) 
[18:02:26.074]                   base::do.call(base::Sys.setenv, args = args)
[18:02:26.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:26.074]             }
[18:02:26.074]             else {
[18:02:26.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:26.074]             }
[18:02:26.074]             {
[18:02:26.074]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:26.074]                   0L) {
[18:02:26.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:26.074]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:26.074]                   base::options(opts)
[18:02:26.074]                 }
[18:02:26.074]                 {
[18:02:26.074]                   {
[18:02:26.074]                     NULL
[18:02:26.074]                     RNGkind("Mersenne-Twister")
[18:02:26.074]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:26.074]                       inherits = FALSE)
[18:02:26.074]                   }
[18:02:26.074]                   options(future.plan = NULL)
[18:02:26.074]                   if (is.na(NA_character_)) 
[18:02:26.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:26.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:26.074]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:26.074]                     .init = FALSE)
[18:02:26.074]                 }
[18:02:26.074]             }
[18:02:26.074]         }
[18:02:26.074]     })
[18:02:26.074]     if (TRUE) {
[18:02:26.074]         base::sink(type = "output", split = FALSE)
[18:02:26.074]         if (TRUE) {
[18:02:26.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:26.074]         }
[18:02:26.074]         else {
[18:02:26.074]             ...future.result["stdout"] <- base::list(NULL)
[18:02:26.074]         }
[18:02:26.074]         base::close(...future.stdout)
[18:02:26.074]         ...future.stdout <- NULL
[18:02:26.074]     }
[18:02:26.074]     ...future.result$conditions <- ...future.conditions
[18:02:26.074]     ...future.result$finished <- base::Sys.time()
[18:02:26.074]     ...future.result
[18:02:26.074] }
[18:02:26.077] assign_globals() ...
[18:02:26.077] List of 5
[18:02:26.077]  $ ...future.FUN            :function (x)  
[18:02:26.077]  $ future.call.arguments    : list()
[18:02:26.077]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:26.077]  $ ...future.elements_ii    :List of 2
[18:02:26.077]   ..$ : int 1
[18:02:26.077]   ..$ : int 0
[18:02:26.077]  $ ...future.seeds_ii       : NULL
[18:02:26.077]  $ ...future.globals.maxSize: NULL
[18:02:26.077]  - attr(*, "where")=List of 5
[18:02:26.077]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:26.077]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:26.077]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:26.077]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:26.077]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:26.077]  - attr(*, "resolved")= logi FALSE
[18:02:26.077]  - attr(*, "total_size")= num 4720
[18:02:26.077]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:26.077]  - attr(*, "already-done")= logi TRUE
[18:02:26.087] - reassign environment for ‘...future.FUN’
[18:02:26.087] - copied ‘...future.FUN’ to environment
[18:02:26.088] - copied ‘future.call.arguments’ to environment
[18:02:26.088] - copied ‘...future.elements_ii’ to environment
[18:02:26.088] - copied ‘...future.seeds_ii’ to environment
[18:02:26.088] - copied ‘...future.globals.maxSize’ to environment
[18:02:26.088] assign_globals() ... done
[18:02:26.089] plan(): Setting new future strategy stack:
[18:02:26.089] List of future strategies:
[18:02:26.089] 1. sequential:
[18:02:26.089]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:26.089]    - tweaked: FALSE
[18:02:26.089]    - call: NULL
[18:02:26.090] plan(): nbrOfWorkers() = 1
[18:02:26.592] plan(): Setting new future strategy stack:
[18:02:26.593] List of future strategies:
[18:02:26.593] 1. multisession:
[18:02:26.593]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:02:26.593]    - tweaked: FALSE
[18:02:26.593]    - call: plan(strategy)
[18:02:26.599] plan(): nbrOfWorkers() = 1
[18:02:26.599] SequentialFuture started (and completed)
[18:02:26.600] - Launch lazy future ... done
[18:02:26.600] run() for ‘SequentialFuture’ ... done
[18:02:26.600] Created future:
[18:02:26.600] SequentialFuture:
[18:02:26.600] Label: ‘future_lapply-1’
[18:02:26.600] Expression:
[18:02:26.600] {
[18:02:26.600]     do.call(function(...) {
[18:02:26.600]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:26.600]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:26.600]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:26.600]             on.exit(options(oopts), add = TRUE)
[18:02:26.600]         }
[18:02:26.600]         {
[18:02:26.600]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:26.600]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:26.600]                 ...future.FUN(...future.X_jj, ...)
[18:02:26.600]             })
[18:02:26.600]         }
[18:02:26.600]     }, args = future.call.arguments)
[18:02:26.600] }
[18:02:26.600] Lazy evaluation: FALSE
[18:02:26.600] Asynchronous evaluation: FALSE
[18:02:26.600] Local evaluation: TRUE
[18:02:26.600] Environment: R_GlobalEnv
[18:02:26.600] Capture standard output: TRUE
[18:02:26.600] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:26.600] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:26.600] Packages: <none>
[18:02:26.600] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:26.600] Resolved: TRUE
[18:02:26.600] Value: 112 bytes of class ‘list’
[18:02:26.600] Early signaling: FALSE
[18:02:26.600] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:26.600] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:26.602] Chunk #1 of 1 ... DONE
[18:02:26.603] Launching 1 futures (chunks) ... DONE
[18:02:26.603] Resolving 1 futures (chunks) ...
[18:02:26.603] resolve() on list ...
[18:02:26.603]  recursive: 0
[18:02:26.603]  length: 1
[18:02:26.604] 
[18:02:26.604] resolved() for ‘SequentialFuture’ ...
[18:02:26.604] - state: ‘finished’
[18:02:26.604] - run: TRUE
[18:02:26.604] - result: ‘FutureResult’
[18:02:26.605] resolved() for ‘SequentialFuture’ ... done
[18:02:26.605] Future #1
[18:02:26.605] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:26.605] - nx: 1
[18:02:26.606] - relay: TRUE
[18:02:26.606] - stdout: TRUE
[18:02:26.606] - signal: TRUE
[18:02:26.606] - resignal: FALSE
[18:02:26.606] - force: TRUE
[18:02:26.606] - relayed: [n=1] FALSE
[18:02:26.607] - queued futures: [n=1] FALSE
[18:02:26.607]  - until=1
[18:02:26.607]  - relaying element #1
[18:02:26.607] - relayed: [n=1] TRUE
[18:02:26.608] - queued futures: [n=1] TRUE
[18:02:26.608] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:26.608]  length: 0 (resolved future 1)
[18:02:26.608] Relaying remaining futures
[18:02:26.608] signalConditionsASAP(NULL, pos=0) ...
[18:02:26.609] - nx: 1
[18:02:26.609] - relay: TRUE
[18:02:26.609] - stdout: TRUE
[18:02:26.609] - signal: TRUE
[18:02:26.609] - resignal: FALSE
[18:02:26.609] - force: TRUE
[18:02:26.610] - relayed: [n=1] TRUE
[18:02:26.610] - queued futures: [n=1] TRUE
 - flush all
[18:02:26.610] - relayed: [n=1] TRUE
[18:02:26.610] - queued futures: [n=1] TRUE
[18:02:26.610] signalConditionsASAP(NULL, pos=0) ... done
[18:02:26.611] resolve() on list ... DONE
[18:02:26.611]  - Number of value chunks collected: 1
[18:02:26.611] Resolving 1 futures (chunks) ... DONE
[18:02:26.611] Reducing values from 1 chunks ...
[18:02:26.611]  - Number of values collected after concatenation: 2
[18:02:26.612]  - Number of values expected: 2
[18:02:26.612] Reducing values from 1 chunks ... DONE
[18:02:26.612] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[18:02:26.613] future_lapply() ...
[18:02:26.619] Number of chunks: 1
[18:02:26.620] getGlobalsAndPackagesXApply() ...
[18:02:26.620]  - future.globals: TRUE
[18:02:26.620] getGlobalsAndPackages() ...
[18:02:26.620] Searching for globals...
[18:02:26.623] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:26.623] Searching for globals ... DONE
[18:02:26.624] Resolving globals: FALSE
[18:02:26.624] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:26.625] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:26.625] - globals: [1] ‘FUN’
[18:02:26.626] 
[18:02:26.626] getGlobalsAndPackages() ... DONE
[18:02:26.626]  - globals found/used: [n=1] ‘FUN’
[18:02:26.626]  - needed namespaces: [n=0] 
[18:02:26.626] Finding globals ... DONE
[18:02:26.627]  - use_args: TRUE
[18:02:26.627]  - Getting '...' globals ...
[18:02:26.627] resolve() on list ...
[18:02:26.628]  recursive: 0
[18:02:26.628]  length: 1
[18:02:26.628]  elements: ‘...’
[18:02:26.628]  length: 0 (resolved future 1)
[18:02:26.628] resolve() on list ... DONE
[18:02:26.631]    - '...' content: [n=0] 
[18:02:26.631] List of 1
[18:02:26.631]  $ ...: list()
[18:02:26.631]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:26.631]  - attr(*, "where")=List of 1
[18:02:26.631]   ..$ ...:<environment: 0x5e4f85592e28> 
[18:02:26.631]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:26.631]  - attr(*, "resolved")= logi TRUE
[18:02:26.631]  - attr(*, "total_size")= num NA
[18:02:26.636]  - Getting '...' globals ... DONE
[18:02:26.637] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:26.637] List of 2
[18:02:26.637]  $ ...future.FUN:function (x)  
[18:02:26.637]  $ ...          : list()
[18:02:26.637]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:26.637]  - attr(*, "where")=List of 2
[18:02:26.637]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:26.637]   ..$ ...          :<environment: 0x5e4f85592e28> 
[18:02:26.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:26.637]  - attr(*, "resolved")= logi FALSE
[18:02:26.637]  - attr(*, "total_size")= num 4720
[18:02:26.642] Packages to be attached in all futures: [n=0] 
[18:02:26.642] getGlobalsAndPackagesXApply() ... DONE
[18:02:26.643] Number of futures (= number of chunks): 1
[18:02:26.643] Launching 1 futures (chunks) ...
[18:02:26.643] Chunk #1 of 1 ...
[18:02:26.643]  - Finding globals in 'X' for chunk #1 ...
[18:02:26.644] getGlobalsAndPackages() ...
[18:02:26.644] Searching for globals...
[18:02:26.644] 
[18:02:26.644] Searching for globals ... DONE
[18:02:26.645] - globals: [0] <none>
[18:02:26.645] getGlobalsAndPackages() ... DONE
[18:02:26.645]    + additional globals found: [n=0] 
[18:02:26.645]    + additional namespaces needed: [n=0] 
[18:02:26.645]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:26.646]  - seeds: <none>
[18:02:26.646]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:26.646] getGlobalsAndPackages() ...
[18:02:26.646] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:26.646] Resolving globals: FALSE
[18:02:26.647] Tweak future expression to call with '...' arguments ...
[18:02:26.647] {
[18:02:26.647]     do.call(function(...) {
[18:02:26.647]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:26.647]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:26.647]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:26.647]             on.exit(options(oopts), add = TRUE)
[18:02:26.647]         }
[18:02:26.647]         {
[18:02:26.647]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:26.647]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:26.647]                 ...future.FUN(...future.X_jj, ...)
[18:02:26.647]             })
[18:02:26.647]         }
[18:02:26.647]     }, args = future.call.arguments)
[18:02:26.647] }
[18:02:26.647] Tweak future expression to call with '...' arguments ... DONE
[18:02:26.648] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:26.648] 
[18:02:26.648] getGlobalsAndPackages() ... DONE
[18:02:26.649] run() for ‘Future’ ...
[18:02:26.649] - state: ‘created’
[18:02:26.649] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:26.656] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:26.656] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:26.656]   - Field: ‘label’
[18:02:26.656]   - Field: ‘local’
[18:02:26.657]   - Field: ‘owner’
[18:02:26.657]   - Field: ‘envir’
[18:02:26.657]   - Field: ‘packages’
[18:02:26.657]   - Field: ‘gc’
[18:02:26.657]   - Field: ‘conditions’
[18:02:26.658]   - Field: ‘expr’
[18:02:26.658]   - Field: ‘uuid’
[18:02:26.658]   - Field: ‘seed’
[18:02:26.658]   - Field: ‘version’
[18:02:26.658]   - Field: ‘result’
[18:02:26.659]   - Field: ‘asynchronous’
[18:02:26.659]   - Field: ‘calls’
[18:02:26.659]   - Field: ‘globals’
[18:02:26.659]   - Field: ‘stdout’
[18:02:26.659]   - Field: ‘earlySignal’
[18:02:26.660]   - Field: ‘lazy’
[18:02:26.660]   - Field: ‘state’
[18:02:26.660] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:26.660] - Launch lazy future ...
[18:02:26.661] Packages needed by the future expression (n = 0): <none>
[18:02:26.661] Packages needed by future strategies (n = 0): <none>
[18:02:26.662] {
[18:02:26.662]     {
[18:02:26.662]         {
[18:02:26.662]             ...future.startTime <- base::Sys.time()
[18:02:26.662]             {
[18:02:26.662]                 {
[18:02:26.662]                   {
[18:02:26.662]                     base::local({
[18:02:26.662]                       has_future <- base::requireNamespace("future", 
[18:02:26.662]                         quietly = TRUE)
[18:02:26.662]                       if (has_future) {
[18:02:26.662]                         ns <- base::getNamespace("future")
[18:02:26.662]                         version <- ns[[".package"]][["version"]]
[18:02:26.662]                         if (is.null(version)) 
[18:02:26.662]                           version <- utils::packageVersion("future")
[18:02:26.662]                       }
[18:02:26.662]                       else {
[18:02:26.662]                         version <- NULL
[18:02:26.662]                       }
[18:02:26.662]                       if (!has_future || version < "1.8.0") {
[18:02:26.662]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:26.662]                           "", base::R.version$version.string), 
[18:02:26.662]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:26.662]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:26.662]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:26.662]                             "release", "version")], collapse = " "), 
[18:02:26.662]                           hostname = base::Sys.info()[["nodename"]])
[18:02:26.662]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:26.662]                           info)
[18:02:26.662]                         info <- base::paste(info, collapse = "; ")
[18:02:26.662]                         if (!has_future) {
[18:02:26.662]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:26.662]                             info)
[18:02:26.662]                         }
[18:02:26.662]                         else {
[18:02:26.662]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:26.662]                             info, version)
[18:02:26.662]                         }
[18:02:26.662]                         base::stop(msg)
[18:02:26.662]                       }
[18:02:26.662]                     })
[18:02:26.662]                   }
[18:02:26.662]                   ...future.strategy.old <- future::plan("list")
[18:02:26.662]                   options(future.plan = NULL)
[18:02:26.662]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:26.662]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:26.662]                 }
[18:02:26.662]                 ...future.workdir <- getwd()
[18:02:26.662]             }
[18:02:26.662]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:26.662]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:26.662]         }
[18:02:26.662]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:26.662]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:26.662]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:26.662]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:26.662]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:26.662]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:26.662]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:26.662]             base::names(...future.oldOptions))
[18:02:26.662]     }
[18:02:26.662]     if (TRUE) {
[18:02:26.662]     }
[18:02:26.662]     else {
[18:02:26.662]         if (NA) {
[18:02:26.662]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:26.662]                 open = "w")
[18:02:26.662]         }
[18:02:26.662]         else {
[18:02:26.662]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:26.662]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:26.662]         }
[18:02:26.662]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:26.662]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:26.662]             base::sink(type = "output", split = FALSE)
[18:02:26.662]             base::close(...future.stdout)
[18:02:26.662]         }, add = TRUE)
[18:02:26.662]     }
[18:02:26.662]     ...future.frame <- base::sys.nframe()
[18:02:26.662]     ...future.conditions <- base::list()
[18:02:26.662]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:26.662]     if (FALSE) {
[18:02:26.662]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:26.662]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:26.662]     }
[18:02:26.662]     ...future.result <- base::tryCatch({
[18:02:26.662]         base::withCallingHandlers({
[18:02:26.662]             ...future.value <- base::withVisible(base::local({
[18:02:26.662]                 do.call(function(...) {
[18:02:26.662]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:26.662]                   if (!identical(...future.globals.maxSize.org, 
[18:02:26.662]                     ...future.globals.maxSize)) {
[18:02:26.662]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:26.662]                     on.exit(options(oopts), add = TRUE)
[18:02:26.662]                   }
[18:02:26.662]                   {
[18:02:26.662]                     lapply(seq_along(...future.elements_ii), 
[18:02:26.662]                       FUN = function(jj) {
[18:02:26.662]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:26.662]                         ...future.FUN(...future.X_jj, ...)
[18:02:26.662]                       })
[18:02:26.662]                   }
[18:02:26.662]                 }, args = future.call.arguments)
[18:02:26.662]             }))
[18:02:26.662]             future::FutureResult(value = ...future.value$value, 
[18:02:26.662]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:26.662]                   ...future.rng), globalenv = if (FALSE) 
[18:02:26.662]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:26.662]                     ...future.globalenv.names))
[18:02:26.662]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:26.662]         }, condition = base::local({
[18:02:26.662]             c <- base::c
[18:02:26.662]             inherits <- base::inherits
[18:02:26.662]             invokeRestart <- base::invokeRestart
[18:02:26.662]             length <- base::length
[18:02:26.662]             list <- base::list
[18:02:26.662]             seq.int <- base::seq.int
[18:02:26.662]             signalCondition <- base::signalCondition
[18:02:26.662]             sys.calls <- base::sys.calls
[18:02:26.662]             `[[` <- base::`[[`
[18:02:26.662]             `+` <- base::`+`
[18:02:26.662]             `<<-` <- base::`<<-`
[18:02:26.662]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:26.662]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:26.662]                   3L)]
[18:02:26.662]             }
[18:02:26.662]             function(cond) {
[18:02:26.662]                 is_error <- inherits(cond, "error")
[18:02:26.662]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:26.662]                   NULL)
[18:02:26.662]                 if (is_error) {
[18:02:26.662]                   sessionInformation <- function() {
[18:02:26.662]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:26.662]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:26.662]                       search = base::search(), system = base::Sys.info())
[18:02:26.662]                   }
[18:02:26.662]                   ...future.conditions[[length(...future.conditions) + 
[18:02:26.662]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:26.662]                     cond$call), session = sessionInformation(), 
[18:02:26.662]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:26.662]                   signalCondition(cond)
[18:02:26.662]                 }
[18:02:26.662]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:26.662]                 "immediateCondition"))) {
[18:02:26.662]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:26.662]                   ...future.conditions[[length(...future.conditions) + 
[18:02:26.662]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:26.662]                   if (TRUE && !signal) {
[18:02:26.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:26.662]                     {
[18:02:26.662]                       inherits <- base::inherits
[18:02:26.662]                       invokeRestart <- base::invokeRestart
[18:02:26.662]                       is.null <- base::is.null
[18:02:26.662]                       muffled <- FALSE
[18:02:26.662]                       if (inherits(cond, "message")) {
[18:02:26.662]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:26.662]                         if (muffled) 
[18:02:26.662]                           invokeRestart("muffleMessage")
[18:02:26.662]                       }
[18:02:26.662]                       else if (inherits(cond, "warning")) {
[18:02:26.662]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:26.662]                         if (muffled) 
[18:02:26.662]                           invokeRestart("muffleWarning")
[18:02:26.662]                       }
[18:02:26.662]                       else if (inherits(cond, "condition")) {
[18:02:26.662]                         if (!is.null(pattern)) {
[18:02:26.662]                           computeRestarts <- base::computeRestarts
[18:02:26.662]                           grepl <- base::grepl
[18:02:26.662]                           restarts <- computeRestarts(cond)
[18:02:26.662]                           for (restart in restarts) {
[18:02:26.662]                             name <- restart$name
[18:02:26.662]                             if (is.null(name)) 
[18:02:26.662]                               next
[18:02:26.662]                             if (!grepl(pattern, name)) 
[18:02:26.662]                               next
[18:02:26.662]                             invokeRestart(restart)
[18:02:26.662]                             muffled <- TRUE
[18:02:26.662]                             break
[18:02:26.662]                           }
[18:02:26.662]                         }
[18:02:26.662]                       }
[18:02:26.662]                       invisible(muffled)
[18:02:26.662]                     }
[18:02:26.662]                     muffleCondition(cond, pattern = "^muffle")
[18:02:26.662]                   }
[18:02:26.662]                 }
[18:02:26.662]                 else {
[18:02:26.662]                   if (TRUE) {
[18:02:26.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:26.662]                     {
[18:02:26.662]                       inherits <- base::inherits
[18:02:26.662]                       invokeRestart <- base::invokeRestart
[18:02:26.662]                       is.null <- base::is.null
[18:02:26.662]                       muffled <- FALSE
[18:02:26.662]                       if (inherits(cond, "message")) {
[18:02:26.662]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:26.662]                         if (muffled) 
[18:02:26.662]                           invokeRestart("muffleMessage")
[18:02:26.662]                       }
[18:02:26.662]                       else if (inherits(cond, "warning")) {
[18:02:26.662]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:26.662]                         if (muffled) 
[18:02:26.662]                           invokeRestart("muffleWarning")
[18:02:26.662]                       }
[18:02:26.662]                       else if (inherits(cond, "condition")) {
[18:02:26.662]                         if (!is.null(pattern)) {
[18:02:26.662]                           computeRestarts <- base::computeRestarts
[18:02:26.662]                           grepl <- base::grepl
[18:02:26.662]                           restarts <- computeRestarts(cond)
[18:02:26.662]                           for (restart in restarts) {
[18:02:26.662]                             name <- restart$name
[18:02:26.662]                             if (is.null(name)) 
[18:02:26.662]                               next
[18:02:26.662]                             if (!grepl(pattern, name)) 
[18:02:26.662]                               next
[18:02:26.662]                             invokeRestart(restart)
[18:02:26.662]                             muffled <- TRUE
[18:02:26.662]                             break
[18:02:26.662]                           }
[18:02:26.662]                         }
[18:02:26.662]                       }
[18:02:26.662]                       invisible(muffled)
[18:02:26.662]                     }
[18:02:26.662]                     muffleCondition(cond, pattern = "^muffle")
[18:02:26.662]                   }
[18:02:26.662]                 }
[18:02:26.662]             }
[18:02:26.662]         }))
[18:02:26.662]     }, error = function(ex) {
[18:02:26.662]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:26.662]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:26.662]                 ...future.rng), started = ...future.startTime, 
[18:02:26.662]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:26.662]             version = "1.8"), class = "FutureResult")
[18:02:26.662]     }, finally = {
[18:02:26.662]         if (!identical(...future.workdir, getwd())) 
[18:02:26.662]             setwd(...future.workdir)
[18:02:26.662]         {
[18:02:26.662]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:26.662]                 ...future.oldOptions$nwarnings <- NULL
[18:02:26.662]             }
[18:02:26.662]             base::options(...future.oldOptions)
[18:02:26.662]             if (.Platform$OS.type == "windows") {
[18:02:26.662]                 old_names <- names(...future.oldEnvVars)
[18:02:26.662]                 envs <- base::Sys.getenv()
[18:02:26.662]                 names <- names(envs)
[18:02:26.662]                 common <- intersect(names, old_names)
[18:02:26.662]                 added <- setdiff(names, old_names)
[18:02:26.662]                 removed <- setdiff(old_names, names)
[18:02:26.662]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:26.662]                   envs[common]]
[18:02:26.662]                 NAMES <- toupper(changed)
[18:02:26.662]                 args <- list()
[18:02:26.662]                 for (kk in seq_along(NAMES)) {
[18:02:26.662]                   name <- changed[[kk]]
[18:02:26.662]                   NAME <- NAMES[[kk]]
[18:02:26.662]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:26.662]                     next
[18:02:26.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:26.662]                 }
[18:02:26.662]                 NAMES <- toupper(added)
[18:02:26.662]                 for (kk in seq_along(NAMES)) {
[18:02:26.662]                   name <- added[[kk]]
[18:02:26.662]                   NAME <- NAMES[[kk]]
[18:02:26.662]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:26.662]                     next
[18:02:26.662]                   args[[name]] <- ""
[18:02:26.662]                 }
[18:02:26.662]                 NAMES <- toupper(removed)
[18:02:26.662]                 for (kk in seq_along(NAMES)) {
[18:02:26.662]                   name <- removed[[kk]]
[18:02:26.662]                   NAME <- NAMES[[kk]]
[18:02:26.662]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:26.662]                     next
[18:02:26.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:26.662]                 }
[18:02:26.662]                 if (length(args) > 0) 
[18:02:26.662]                   base::do.call(base::Sys.setenv, args = args)
[18:02:26.662]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:26.662]             }
[18:02:26.662]             else {
[18:02:26.662]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:26.662]             }
[18:02:26.662]             {
[18:02:26.662]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:26.662]                   0L) {
[18:02:26.662]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:26.662]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:26.662]                   base::options(opts)
[18:02:26.662]                 }
[18:02:26.662]                 {
[18:02:26.662]                   {
[18:02:26.662]                     NULL
[18:02:26.662]                     RNGkind("Mersenne-Twister")
[18:02:26.662]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:26.662]                       inherits = FALSE)
[18:02:26.662]                   }
[18:02:26.662]                   options(future.plan = NULL)
[18:02:26.662]                   if (is.na(NA_character_)) 
[18:02:26.662]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:26.662]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:26.662]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:26.662]                     .init = FALSE)
[18:02:26.662]                 }
[18:02:26.662]             }
[18:02:26.662]         }
[18:02:26.662]     })
[18:02:26.662]     if (FALSE) {
[18:02:26.662]         base::sink(type = "output", split = FALSE)
[18:02:26.662]         if (NA) {
[18:02:26.662]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:26.662]         }
[18:02:26.662]         else {
[18:02:26.662]             ...future.result["stdout"] <- base::list(NULL)
[18:02:26.662]         }
[18:02:26.662]         base::close(...future.stdout)
[18:02:26.662]         ...future.stdout <- NULL
[18:02:26.662]     }
[18:02:26.662]     ...future.result$conditions <- ...future.conditions
[18:02:26.662]     ...future.result$finished <- base::Sys.time()
[18:02:26.662]     ...future.result
[18:02:26.662] }
[18:02:26.665] assign_globals() ...
[18:02:26.665] List of 5
[18:02:26.665]  $ ...future.FUN            :function (x)  
[18:02:26.665]  $ future.call.arguments    : list()
[18:02:26.665]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:26.665]  $ ...future.elements_ii    :List of 2
[18:02:26.665]   ..$ : int 1
[18:02:26.665]   ..$ : int 0
[18:02:26.665]  $ ...future.seeds_ii       : NULL
[18:02:26.665]  $ ...future.globals.maxSize: NULL
[18:02:26.665]  - attr(*, "where")=List of 5
[18:02:26.665]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:26.665]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:26.665]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:26.665]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:26.665]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:26.665]  - attr(*, "resolved")= logi FALSE
[18:02:26.665]  - attr(*, "total_size")= num 4720
[18:02:26.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:26.665]  - attr(*, "already-done")= logi TRUE
[18:02:26.675] - reassign environment for ‘...future.FUN’
[18:02:26.675] - copied ‘...future.FUN’ to environment
[18:02:26.675] - copied ‘future.call.arguments’ to environment
[18:02:26.676] - copied ‘...future.elements_ii’ to environment
[18:02:26.676] - copied ‘...future.seeds_ii’ to environment
[18:02:26.676] - copied ‘...future.globals.maxSize’ to environment
[18:02:26.676] assign_globals() ... done
[18:02:26.677] plan(): Setting new future strategy stack:
[18:02:26.677] List of future strategies:
[18:02:26.677] 1. sequential:
[18:02:26.677]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:26.677]    - tweaked: FALSE
[18:02:26.677]    - call: NULL
[18:02:26.678] plan(): nbrOfWorkers() = 1
[18:02:27.180] plan(): Setting new future strategy stack:
[18:02:27.180] List of future strategies:
[18:02:27.180] 1. multisession:
[18:02:27.180]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:02:27.180]    - tweaked: FALSE
[18:02:27.180]    - call: plan(strategy)
[18:02:27.187] plan(): nbrOfWorkers() = 1
[18:02:27.187] SequentialFuture started (and completed)
[18:02:27.187] - Launch lazy future ... done
[18:02:27.187] run() for ‘SequentialFuture’ ... done
[18:02:27.188] Created future:
[18:02:27.188] SequentialFuture:
[18:02:27.188] Label: ‘future_lapply-1’
[18:02:27.188] Expression:
[18:02:27.188] {
[18:02:27.188]     do.call(function(...) {
[18:02:27.188]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:27.188]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:27.188]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:27.188]             on.exit(options(oopts), add = TRUE)
[18:02:27.188]         }
[18:02:27.188]         {
[18:02:27.188]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:27.188]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:27.188]                 ...future.FUN(...future.X_jj, ...)
[18:02:27.188]             })
[18:02:27.188]         }
[18:02:27.188]     }, args = future.call.arguments)
[18:02:27.188] }
[18:02:27.188] Lazy evaluation: FALSE
[18:02:27.188] Asynchronous evaluation: FALSE
[18:02:27.188] Local evaluation: TRUE
[18:02:27.188] Environment: R_GlobalEnv
[18:02:27.188] Capture standard output: NA
[18:02:27.188] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:27.188] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:27.188] Packages: <none>
[18:02:27.188] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:27.188] Resolved: TRUE
[18:02:27.188] Value: 112 bytes of class ‘list’
[18:02:27.188] Early signaling: FALSE
[18:02:27.188] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:27.188] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:27.190] Chunk #1 of 1 ... DONE
[18:02:27.190] Launching 1 futures (chunks) ... DONE
[18:02:27.190] Resolving 1 futures (chunks) ...
[18:02:27.191] resolve() on list ...
[18:02:27.191]  recursive: 0
[18:02:27.191]  length: 1
[18:02:27.191] 
[18:02:27.191] resolved() for ‘SequentialFuture’ ...
[18:02:27.192] - state: ‘finished’
[18:02:27.192] - run: TRUE
[18:02:27.192] - result: ‘FutureResult’
[18:02:27.192] resolved() for ‘SequentialFuture’ ... done
[18:02:27.192] Future #1
[18:02:27.193] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:27.193] - nx: 1
[18:02:27.193] - relay: TRUE
[18:02:27.193] - stdout: TRUE
[18:02:27.193] - signal: TRUE
[18:02:27.194] - resignal: FALSE
[18:02:27.196] - force: TRUE
[18:02:27.196] - relayed: [n=1] FALSE
[18:02:27.196] - queued futures: [n=1] FALSE
[18:02:27.197]  - until=1
[18:02:27.197]  - relaying element #1
[18:02:27.197] - relayed: [n=1] TRUE
[18:02:27.197] - queued futures: [n=1] TRUE
[18:02:27.198] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:27.198]  length: 0 (resolved future 1)
[18:02:27.198] Relaying remaining futures
[18:02:27.198] signalConditionsASAP(NULL, pos=0) ...
[18:02:27.198] - nx: 1
[18:02:27.199] - relay: TRUE
[18:02:27.199] - stdout: TRUE
[18:02:27.199] - signal: TRUE
[18:02:27.199] - resignal: FALSE
[18:02:27.199] - force: TRUE
[18:02:27.199] - relayed: [n=1] TRUE
[18:02:27.200] - queued futures: [n=1] TRUE
 - flush all
[18:02:27.200] - relayed: [n=1] TRUE
[18:02:27.200] - queued futures: [n=1] TRUE
[18:02:27.200] signalConditionsASAP(NULL, pos=0) ... done
[18:02:27.201] resolve() on list ... DONE
[18:02:27.201]  - Number of value chunks collected: 1
[18:02:27.201] Resolving 1 futures (chunks) ... DONE
[18:02:27.201] Reducing values from 1 chunks ...
[18:02:27.201]  - Number of values collected after concatenation: 2
[18:02:27.202]  - Number of values expected: 2
[18:02:27.202] Reducing values from 1 chunks ... DONE
[18:02:27.202] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[18:02:27.203] future_mapply() ...
[18:02:27.208] Number of chunks: 1
[18:02:27.209] getGlobalsAndPackagesXApply() ...
[18:02:27.209]  - future.globals: TRUE
[18:02:27.209] getGlobalsAndPackages() ...
[18:02:27.209] Searching for globals...
[18:02:27.213] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:27.213] Searching for globals ... DONE
[18:02:27.213] Resolving globals: FALSE
[18:02:27.214] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:27.215] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:27.215] - globals: [1] ‘FUN’
[18:02:27.215] 
[18:02:27.215] getGlobalsAndPackages() ... DONE
[18:02:27.216]  - globals found/used: [n=1] ‘FUN’
[18:02:27.216]  - needed namespaces: [n=0] 
[18:02:27.216] Finding globals ... DONE
[18:02:27.216] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:27.217] List of 2
[18:02:27.217]  $ ...future.FUN:function (x, y)  
[18:02:27.217]  $ MoreArgs     : NULL
[18:02:27.217]  - attr(*, "where")=List of 2
[18:02:27.217]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:27.217]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:27.217]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:27.217]  - attr(*, "resolved")= logi FALSE
[18:02:27.217]  - attr(*, "total_size")= num NA
[18:02:27.221] Packages to be attached in all futures: [n=0] 
[18:02:27.222] getGlobalsAndPackagesXApply() ... DONE
[18:02:27.222] Number of futures (= number of chunks): 1
[18:02:27.222] Launching 1 futures (chunks) ...
[18:02:27.222] Chunk #1 of 1 ...
[18:02:27.223]  - Finding globals in '...' for chunk #1 ...
[18:02:27.223] getGlobalsAndPackages() ...
[18:02:27.223] Searching for globals...
[18:02:27.224] 
[18:02:27.224] Searching for globals ... DONE
[18:02:27.224] - globals: [0] <none>
[18:02:27.224] getGlobalsAndPackages() ... DONE
[18:02:27.225]    + additional globals found: [n=0] 
[18:02:27.225]    + additional namespaces needed: [n=0] 
[18:02:27.225]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:27.225]  - seeds: <none>
[18:02:27.225]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:27.226] getGlobalsAndPackages() ...
[18:02:27.226] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:27.226] Resolving globals: FALSE
[18:02:27.227] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[18:02:27.228] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:27.228] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:27.228] 
[18:02:27.228] getGlobalsAndPackages() ... DONE
[18:02:27.229] run() for ‘Future’ ...
[18:02:27.229] - state: ‘created’
[18:02:27.229] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:27.236] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:27.236] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:27.236]   - Field: ‘label’
[18:02:27.236]   - Field: ‘local’
[18:02:27.237]   - Field: ‘owner’
[18:02:27.237]   - Field: ‘envir’
[18:02:27.237]   - Field: ‘packages’
[18:02:27.237]   - Field: ‘gc’
[18:02:27.237]   - Field: ‘conditions’
[18:02:27.238]   - Field: ‘expr’
[18:02:27.238]   - Field: ‘uuid’
[18:02:27.238]   - Field: ‘seed’
[18:02:27.238]   - Field: ‘version’
[18:02:27.238]   - Field: ‘result’
[18:02:27.239]   - Field: ‘asynchronous’
[18:02:27.239]   - Field: ‘calls’
[18:02:27.239]   - Field: ‘globals’
[18:02:27.239]   - Field: ‘stdout’
[18:02:27.239]   - Field: ‘earlySignal’
[18:02:27.240]   - Field: ‘lazy’
[18:02:27.240]   - Field: ‘state’
[18:02:27.240] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:27.240] - Launch lazy future ...
[18:02:27.241] Packages needed by the future expression (n = 0): <none>
[18:02:27.241] Packages needed by future strategies (n = 0): <none>
[18:02:27.242] {
[18:02:27.242]     {
[18:02:27.242]         {
[18:02:27.242]             ...future.startTime <- base::Sys.time()
[18:02:27.242]             {
[18:02:27.242]                 {
[18:02:27.242]                   {
[18:02:27.242]                     base::local({
[18:02:27.242]                       has_future <- base::requireNamespace("future", 
[18:02:27.242]                         quietly = TRUE)
[18:02:27.242]                       if (has_future) {
[18:02:27.242]                         ns <- base::getNamespace("future")
[18:02:27.242]                         version <- ns[[".package"]][["version"]]
[18:02:27.242]                         if (is.null(version)) 
[18:02:27.242]                           version <- utils::packageVersion("future")
[18:02:27.242]                       }
[18:02:27.242]                       else {
[18:02:27.242]                         version <- NULL
[18:02:27.242]                       }
[18:02:27.242]                       if (!has_future || version < "1.8.0") {
[18:02:27.242]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:27.242]                           "", base::R.version$version.string), 
[18:02:27.242]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:27.242]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:27.242]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:27.242]                             "release", "version")], collapse = " "), 
[18:02:27.242]                           hostname = base::Sys.info()[["nodename"]])
[18:02:27.242]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:27.242]                           info)
[18:02:27.242]                         info <- base::paste(info, collapse = "; ")
[18:02:27.242]                         if (!has_future) {
[18:02:27.242]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:27.242]                             info)
[18:02:27.242]                         }
[18:02:27.242]                         else {
[18:02:27.242]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:27.242]                             info, version)
[18:02:27.242]                         }
[18:02:27.242]                         base::stop(msg)
[18:02:27.242]                       }
[18:02:27.242]                     })
[18:02:27.242]                   }
[18:02:27.242]                   ...future.strategy.old <- future::plan("list")
[18:02:27.242]                   options(future.plan = NULL)
[18:02:27.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:27.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:27.242]                 }
[18:02:27.242]                 ...future.workdir <- getwd()
[18:02:27.242]             }
[18:02:27.242]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:27.242]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:27.242]         }
[18:02:27.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:27.242]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:27.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:27.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:27.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:27.242]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:27.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:27.242]             base::names(...future.oldOptions))
[18:02:27.242]     }
[18:02:27.242]     if (FALSE) {
[18:02:27.242]     }
[18:02:27.242]     else {
[18:02:27.242]         if (FALSE) {
[18:02:27.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:27.242]                 open = "w")
[18:02:27.242]         }
[18:02:27.242]         else {
[18:02:27.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:27.242]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:27.242]         }
[18:02:27.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:27.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:27.242]             base::sink(type = "output", split = FALSE)
[18:02:27.242]             base::close(...future.stdout)
[18:02:27.242]         }, add = TRUE)
[18:02:27.242]     }
[18:02:27.242]     ...future.frame <- base::sys.nframe()
[18:02:27.242]     ...future.conditions <- base::list()
[18:02:27.242]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:27.242]     if (FALSE) {
[18:02:27.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:27.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:27.242]     }
[18:02:27.242]     ...future.result <- base::tryCatch({
[18:02:27.242]         base::withCallingHandlers({
[18:02:27.242]             ...future.value <- base::withVisible(base::local({
[18:02:27.242]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:27.242]                 if (!identical(...future.globals.maxSize.org, 
[18:02:27.242]                   ...future.globals.maxSize)) {
[18:02:27.242]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:27.242]                   on.exit(options(oopts), add = TRUE)
[18:02:27.242]                 }
[18:02:27.242]                 {
[18:02:27.242]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:27.242]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:27.242]                     USE.NAMES = FALSE)
[18:02:27.242]                   do.call(mapply, args = args)
[18:02:27.242]                 }
[18:02:27.242]             }))
[18:02:27.242]             future::FutureResult(value = ...future.value$value, 
[18:02:27.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:27.242]                   ...future.rng), globalenv = if (FALSE) 
[18:02:27.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:27.242]                     ...future.globalenv.names))
[18:02:27.242]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:27.242]         }, condition = base::local({
[18:02:27.242]             c <- base::c
[18:02:27.242]             inherits <- base::inherits
[18:02:27.242]             invokeRestart <- base::invokeRestart
[18:02:27.242]             length <- base::length
[18:02:27.242]             list <- base::list
[18:02:27.242]             seq.int <- base::seq.int
[18:02:27.242]             signalCondition <- base::signalCondition
[18:02:27.242]             sys.calls <- base::sys.calls
[18:02:27.242]             `[[` <- base::`[[`
[18:02:27.242]             `+` <- base::`+`
[18:02:27.242]             `<<-` <- base::`<<-`
[18:02:27.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:27.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:27.242]                   3L)]
[18:02:27.242]             }
[18:02:27.242]             function(cond) {
[18:02:27.242]                 is_error <- inherits(cond, "error")
[18:02:27.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:27.242]                   NULL)
[18:02:27.242]                 if (is_error) {
[18:02:27.242]                   sessionInformation <- function() {
[18:02:27.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:27.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:27.242]                       search = base::search(), system = base::Sys.info())
[18:02:27.242]                   }
[18:02:27.242]                   ...future.conditions[[length(...future.conditions) + 
[18:02:27.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:27.242]                     cond$call), session = sessionInformation(), 
[18:02:27.242]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:27.242]                   signalCondition(cond)
[18:02:27.242]                 }
[18:02:27.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:27.242]                 "immediateCondition"))) {
[18:02:27.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:27.242]                   ...future.conditions[[length(...future.conditions) + 
[18:02:27.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:27.242]                   if (TRUE && !signal) {
[18:02:27.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:27.242]                     {
[18:02:27.242]                       inherits <- base::inherits
[18:02:27.242]                       invokeRestart <- base::invokeRestart
[18:02:27.242]                       is.null <- base::is.null
[18:02:27.242]                       muffled <- FALSE
[18:02:27.242]                       if (inherits(cond, "message")) {
[18:02:27.242]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:27.242]                         if (muffled) 
[18:02:27.242]                           invokeRestart("muffleMessage")
[18:02:27.242]                       }
[18:02:27.242]                       else if (inherits(cond, "warning")) {
[18:02:27.242]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:27.242]                         if (muffled) 
[18:02:27.242]                           invokeRestart("muffleWarning")
[18:02:27.242]                       }
[18:02:27.242]                       else if (inherits(cond, "condition")) {
[18:02:27.242]                         if (!is.null(pattern)) {
[18:02:27.242]                           computeRestarts <- base::computeRestarts
[18:02:27.242]                           grepl <- base::grepl
[18:02:27.242]                           restarts <- computeRestarts(cond)
[18:02:27.242]                           for (restart in restarts) {
[18:02:27.242]                             name <- restart$name
[18:02:27.242]                             if (is.null(name)) 
[18:02:27.242]                               next
[18:02:27.242]                             if (!grepl(pattern, name)) 
[18:02:27.242]                               next
[18:02:27.242]                             invokeRestart(restart)
[18:02:27.242]                             muffled <- TRUE
[18:02:27.242]                             break
[18:02:27.242]                           }
[18:02:27.242]                         }
[18:02:27.242]                       }
[18:02:27.242]                       invisible(muffled)
[18:02:27.242]                     }
[18:02:27.242]                     muffleCondition(cond, pattern = "^muffle")
[18:02:27.242]                   }
[18:02:27.242]                 }
[18:02:27.242]                 else {
[18:02:27.242]                   if (TRUE) {
[18:02:27.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:27.242]                     {
[18:02:27.242]                       inherits <- base::inherits
[18:02:27.242]                       invokeRestart <- base::invokeRestart
[18:02:27.242]                       is.null <- base::is.null
[18:02:27.242]                       muffled <- FALSE
[18:02:27.242]                       if (inherits(cond, "message")) {
[18:02:27.242]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:27.242]                         if (muffled) 
[18:02:27.242]                           invokeRestart("muffleMessage")
[18:02:27.242]                       }
[18:02:27.242]                       else if (inherits(cond, "warning")) {
[18:02:27.242]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:27.242]                         if (muffled) 
[18:02:27.242]                           invokeRestart("muffleWarning")
[18:02:27.242]                       }
[18:02:27.242]                       else if (inherits(cond, "condition")) {
[18:02:27.242]                         if (!is.null(pattern)) {
[18:02:27.242]                           computeRestarts <- base::computeRestarts
[18:02:27.242]                           grepl <- base::grepl
[18:02:27.242]                           restarts <- computeRestarts(cond)
[18:02:27.242]                           for (restart in restarts) {
[18:02:27.242]                             name <- restart$name
[18:02:27.242]                             if (is.null(name)) 
[18:02:27.242]                               next
[18:02:27.242]                             if (!grepl(pattern, name)) 
[18:02:27.242]                               next
[18:02:27.242]                             invokeRestart(restart)
[18:02:27.242]                             muffled <- TRUE
[18:02:27.242]                             break
[18:02:27.242]                           }
[18:02:27.242]                         }
[18:02:27.242]                       }
[18:02:27.242]                       invisible(muffled)
[18:02:27.242]                     }
[18:02:27.242]                     muffleCondition(cond, pattern = "^muffle")
[18:02:27.242]                   }
[18:02:27.242]                 }
[18:02:27.242]             }
[18:02:27.242]         }))
[18:02:27.242]     }, error = function(ex) {
[18:02:27.242]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:27.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:27.242]                 ...future.rng), started = ...future.startTime, 
[18:02:27.242]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:27.242]             version = "1.8"), class = "FutureResult")
[18:02:27.242]     }, finally = {
[18:02:27.242]         if (!identical(...future.workdir, getwd())) 
[18:02:27.242]             setwd(...future.workdir)
[18:02:27.242]         {
[18:02:27.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:27.242]                 ...future.oldOptions$nwarnings <- NULL
[18:02:27.242]             }
[18:02:27.242]             base::options(...future.oldOptions)
[18:02:27.242]             if (.Platform$OS.type == "windows") {
[18:02:27.242]                 old_names <- names(...future.oldEnvVars)
[18:02:27.242]                 envs <- base::Sys.getenv()
[18:02:27.242]                 names <- names(envs)
[18:02:27.242]                 common <- intersect(names, old_names)
[18:02:27.242]                 added <- setdiff(names, old_names)
[18:02:27.242]                 removed <- setdiff(old_names, names)
[18:02:27.242]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:27.242]                   envs[common]]
[18:02:27.242]                 NAMES <- toupper(changed)
[18:02:27.242]                 args <- list()
[18:02:27.242]                 for (kk in seq_along(NAMES)) {
[18:02:27.242]                   name <- changed[[kk]]
[18:02:27.242]                   NAME <- NAMES[[kk]]
[18:02:27.242]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:27.242]                     next
[18:02:27.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:27.242]                 }
[18:02:27.242]                 NAMES <- toupper(added)
[18:02:27.242]                 for (kk in seq_along(NAMES)) {
[18:02:27.242]                   name <- added[[kk]]
[18:02:27.242]                   NAME <- NAMES[[kk]]
[18:02:27.242]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:27.242]                     next
[18:02:27.242]                   args[[name]] <- ""
[18:02:27.242]                 }
[18:02:27.242]                 NAMES <- toupper(removed)
[18:02:27.242]                 for (kk in seq_along(NAMES)) {
[18:02:27.242]                   name <- removed[[kk]]
[18:02:27.242]                   NAME <- NAMES[[kk]]
[18:02:27.242]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:27.242]                     next
[18:02:27.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:27.242]                 }
[18:02:27.242]                 if (length(args) > 0) 
[18:02:27.242]                   base::do.call(base::Sys.setenv, args = args)
[18:02:27.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:27.242]             }
[18:02:27.242]             else {
[18:02:27.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:27.242]             }
[18:02:27.242]             {
[18:02:27.242]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:27.242]                   0L) {
[18:02:27.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:27.242]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:27.242]                   base::options(opts)
[18:02:27.242]                 }
[18:02:27.242]                 {
[18:02:27.242]                   {
[18:02:27.242]                     NULL
[18:02:27.242]                     RNGkind("Mersenne-Twister")
[18:02:27.242]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:27.242]                       inherits = FALSE)
[18:02:27.242]                   }
[18:02:27.242]                   options(future.plan = NULL)
[18:02:27.242]                   if (is.na(NA_character_)) 
[18:02:27.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:27.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:27.242]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:27.242]                     .init = FALSE)
[18:02:27.242]                 }
[18:02:27.242]             }
[18:02:27.242]         }
[18:02:27.242]     })
[18:02:27.242]     if (TRUE) {
[18:02:27.242]         base::sink(type = "output", split = FALSE)
[18:02:27.242]         if (FALSE) {
[18:02:27.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:27.242]         }
[18:02:27.242]         else {
[18:02:27.242]             ...future.result["stdout"] <- base::list(NULL)
[18:02:27.242]         }
[18:02:27.242]         base::close(...future.stdout)
[18:02:27.242]         ...future.stdout <- NULL
[18:02:27.242]     }
[18:02:27.242]     ...future.result$conditions <- ...future.conditions
[18:02:27.242]     ...future.result$finished <- base::Sys.time()
[18:02:27.242]     ...future.result
[18:02:27.242] }
[18:02:27.245] assign_globals() ...
[18:02:27.246] List of 5
[18:02:27.246]  $ ...future.FUN            :function (x, y)  
[18:02:27.246]  $ MoreArgs                 : NULL
[18:02:27.246]  $ ...future.elements_ii    :List of 2
[18:02:27.246]   ..$ :List of 2
[18:02:27.246]   .. ..$ : int 1
[18:02:27.246]   .. ..$ : int 0
[18:02:27.246]   ..$ :List of 2
[18:02:27.246]   .. ..$ : int 0
[18:02:27.246]   .. ..$ : int 1
[18:02:27.246]  $ ...future.seeds_ii       : NULL
[18:02:27.246]  $ ...future.globals.maxSize: NULL
[18:02:27.246]  - attr(*, "where")=List of 5
[18:02:27.246]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:27.246]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:27.246]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:27.246]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:27.246]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:27.246]  - attr(*, "resolved")= logi FALSE
[18:02:27.246]  - attr(*, "total_size")= num 6480
[18:02:27.246]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:27.246]  - attr(*, "already-done")= logi TRUE
[18:02:27.257] - reassign environment for ‘...future.FUN’
[18:02:27.259] - copied ‘...future.FUN’ to environment
[18:02:27.259] - copied ‘MoreArgs’ to environment
[18:02:27.260] - copied ‘...future.elements_ii’ to environment
[18:02:27.260] - copied ‘...future.seeds_ii’ to environment
[18:02:27.260] - copied ‘...future.globals.maxSize’ to environment
[18:02:27.260] assign_globals() ... done
[18:02:27.261] plan(): Setting new future strategy stack:
[18:02:27.261] List of future strategies:
[18:02:27.261] 1. sequential:
[18:02:27.261]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:27.261]    - tweaked: FALSE
[18:02:27.261]    - call: NULL
[18:02:27.262] plan(): nbrOfWorkers() = 1
[18:02:27.764] plan(): Setting new future strategy stack:
[18:02:27.765] List of future strategies:
[18:02:27.765] 1. multisession:
[18:02:27.765]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:02:27.765]    - tweaked: FALSE
[18:02:27.765]    - call: plan(strategy)
[18:02:27.771] plan(): nbrOfWorkers() = 1
[18:02:27.772] SequentialFuture started (and completed)
[18:02:27.772] - Launch lazy future ... done
[18:02:27.772] run() for ‘SequentialFuture’ ... done
[18:02:27.773] Created future:
[18:02:27.773] SequentialFuture:
[18:02:27.773] Label: ‘future_mapply-1’
[18:02:27.773] Expression:
[18:02:27.773] {
[18:02:27.773]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:27.773]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:27.773]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:27.773]         on.exit(options(oopts), add = TRUE)
[18:02:27.773]     }
[18:02:27.773]     {
[18:02:27.773]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:27.773]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:27.773]         do.call(mapply, args = args)
[18:02:27.773]     }
[18:02:27.773] }
[18:02:27.773] Lazy evaluation: FALSE
[18:02:27.773] Asynchronous evaluation: FALSE
[18:02:27.773] Local evaluation: TRUE
[18:02:27.773] Environment: R_GlobalEnv
[18:02:27.773] Capture standard output: FALSE
[18:02:27.773] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:27.773] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:27.773] Packages: <none>
[18:02:27.773] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:27.773] Resolved: TRUE
[18:02:27.773] Value: 224 bytes of class ‘list’
[18:02:27.773] Early signaling: FALSE
[18:02:27.773] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:27.773] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:27.775] Chunk #1 of 1 ... DONE
[18:02:27.775] Launching 1 futures (chunks) ... DONE
[18:02:27.775] Resolving 1 futures (chunks) ...
[18:02:27.776] resolve() on list ...
[18:02:27.776]  recursive: 0
[18:02:27.776]  length: 1
[18:02:27.776] 
[18:02:27.776] resolved() for ‘SequentialFuture’ ...
[18:02:27.777] - state: ‘finished’
[18:02:27.777] - run: TRUE
[18:02:27.777] - result: ‘FutureResult’
[18:02:27.777] resolved() for ‘SequentialFuture’ ... done
[18:02:27.777] Future #1
[18:02:27.778] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:27.778] - nx: 1
[18:02:27.778] - relay: TRUE
[18:02:27.778] - stdout: TRUE
[18:02:27.779] - signal: TRUE
[18:02:27.779] - resignal: FALSE
[18:02:27.779] - force: TRUE
[18:02:27.779] - relayed: [n=1] FALSE
[18:02:27.779] - queued futures: [n=1] FALSE
[18:02:27.779]  - until=1
[18:02:27.780]  - relaying element #1
[18:02:27.780] - relayed: [n=1] TRUE
[18:02:27.780] - queued futures: [n=1] TRUE
[18:02:27.780] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:27.781]  length: 0 (resolved future 1)
[18:02:27.781] Relaying remaining futures
[18:02:27.781] signalConditionsASAP(NULL, pos=0) ...
[18:02:27.781] - nx: 1
[18:02:27.781] - relay: TRUE
[18:02:27.782] - stdout: TRUE
[18:02:27.782] - signal: TRUE
[18:02:27.782] - resignal: FALSE
[18:02:27.782] - force: TRUE
[18:02:27.782] - relayed: [n=1] TRUE
[18:02:27.782] - queued futures: [n=1] TRUE
 - flush all
[18:02:27.783] - relayed: [n=1] TRUE
[18:02:27.783] - queued futures: [n=1] TRUE
[18:02:27.783] signalConditionsASAP(NULL, pos=0) ... done
[18:02:27.783] resolve() on list ... DONE
[18:02:27.784]  - Number of value chunks collected: 1
[18:02:27.784] Resolving 1 futures (chunks) ... DONE
[18:02:27.784] Reducing values from 1 chunks ...
[18:02:27.784]  - Number of values collected after concatenation: 2
[18:02:27.784]  - Number of values expected: 2
[18:02:27.785] Reducing values from 1 chunks ... DONE
[18:02:27.785] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[18:02:27.786] future_mapply() ...
[18:02:27.792] Number of chunks: 1
[18:02:27.792] getGlobalsAndPackagesXApply() ...
[18:02:27.792]  - future.globals: TRUE
[18:02:27.793] getGlobalsAndPackages() ...
[18:02:27.793] Searching for globals...
[18:02:27.796] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:27.796] Searching for globals ... DONE
[18:02:27.797] Resolving globals: FALSE
[18:02:27.798] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:27.798] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:27.799] - globals: [1] ‘FUN’
[18:02:27.799] 
[18:02:27.799] getGlobalsAndPackages() ... DONE
[18:02:27.799]  - globals found/used: [n=1] ‘FUN’
[18:02:27.800]  - needed namespaces: [n=0] 
[18:02:27.800] Finding globals ... DONE
[18:02:27.800] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:27.800] List of 2
[18:02:27.800]  $ ...future.FUN:function (x, y)  
[18:02:27.800]  $ MoreArgs     : NULL
[18:02:27.800]  - attr(*, "where")=List of 2
[18:02:27.800]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:27.800]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:27.800]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:27.800]  - attr(*, "resolved")= logi FALSE
[18:02:27.800]  - attr(*, "total_size")= num NA
[18:02:27.806] Packages to be attached in all futures: [n=0] 
[18:02:27.806] getGlobalsAndPackagesXApply() ... DONE
[18:02:27.806] Number of futures (= number of chunks): 1
[18:02:27.807] Launching 1 futures (chunks) ...
[18:02:27.807] Chunk #1 of 1 ...
[18:02:27.807]  - Finding globals in '...' for chunk #1 ...
[18:02:27.807] getGlobalsAndPackages() ...
[18:02:27.808] Searching for globals...
[18:02:27.808] 
[18:02:27.809] Searching for globals ... DONE
[18:02:27.809] - globals: [0] <none>
[18:02:27.809] getGlobalsAndPackages() ... DONE
[18:02:27.809]    + additional globals found: [n=0] 
[18:02:27.809]    + additional namespaces needed: [n=0] 
[18:02:27.810]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:27.810]  - seeds: <none>
[18:02:27.810]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:27.810] getGlobalsAndPackages() ...
[18:02:27.810] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:27.811] Resolving globals: FALSE
[18:02:27.812] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[18:02:27.813] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:27.813] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:27.813] 
[18:02:27.814] getGlobalsAndPackages() ... DONE
[18:02:27.814] run() for ‘Future’ ...
[18:02:27.814] - state: ‘created’
[18:02:27.815] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:27.821] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:27.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:27.821]   - Field: ‘label’
[18:02:27.821]   - Field: ‘local’
[18:02:27.822]   - Field: ‘owner’
[18:02:27.822]   - Field: ‘envir’
[18:02:27.822]   - Field: ‘packages’
[18:02:27.822]   - Field: ‘gc’
[18:02:27.823]   - Field: ‘conditions’
[18:02:27.823]   - Field: ‘expr’
[18:02:27.823]   - Field: ‘uuid’
[18:02:27.823]   - Field: ‘seed’
[18:02:27.823]   - Field: ‘version’
[18:02:27.824]   - Field: ‘result’
[18:02:27.824]   - Field: ‘asynchronous’
[18:02:27.824]   - Field: ‘calls’
[18:02:27.824]   - Field: ‘globals’
[18:02:27.824]   - Field: ‘stdout’
[18:02:27.825]   - Field: ‘earlySignal’
[18:02:27.825]   - Field: ‘lazy’
[18:02:27.825]   - Field: ‘state’
[18:02:27.825] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:27.826] - Launch lazy future ...
[18:02:27.826] Packages needed by the future expression (n = 0): <none>
[18:02:27.826] Packages needed by future strategies (n = 0): <none>
[18:02:27.827] {
[18:02:27.827]     {
[18:02:27.827]         {
[18:02:27.827]             ...future.startTime <- base::Sys.time()
[18:02:27.827]             {
[18:02:27.827]                 {
[18:02:27.827]                   {
[18:02:27.827]                     base::local({
[18:02:27.827]                       has_future <- base::requireNamespace("future", 
[18:02:27.827]                         quietly = TRUE)
[18:02:27.827]                       if (has_future) {
[18:02:27.827]                         ns <- base::getNamespace("future")
[18:02:27.827]                         version <- ns[[".package"]][["version"]]
[18:02:27.827]                         if (is.null(version)) 
[18:02:27.827]                           version <- utils::packageVersion("future")
[18:02:27.827]                       }
[18:02:27.827]                       else {
[18:02:27.827]                         version <- NULL
[18:02:27.827]                       }
[18:02:27.827]                       if (!has_future || version < "1.8.0") {
[18:02:27.827]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:27.827]                           "", base::R.version$version.string), 
[18:02:27.827]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:27.827]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:27.827]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:27.827]                             "release", "version")], collapse = " "), 
[18:02:27.827]                           hostname = base::Sys.info()[["nodename"]])
[18:02:27.827]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:27.827]                           info)
[18:02:27.827]                         info <- base::paste(info, collapse = "; ")
[18:02:27.827]                         if (!has_future) {
[18:02:27.827]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:27.827]                             info)
[18:02:27.827]                         }
[18:02:27.827]                         else {
[18:02:27.827]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:27.827]                             info, version)
[18:02:27.827]                         }
[18:02:27.827]                         base::stop(msg)
[18:02:27.827]                       }
[18:02:27.827]                     })
[18:02:27.827]                   }
[18:02:27.827]                   ...future.strategy.old <- future::plan("list")
[18:02:27.827]                   options(future.plan = NULL)
[18:02:27.827]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:27.827]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:27.827]                 }
[18:02:27.827]                 ...future.workdir <- getwd()
[18:02:27.827]             }
[18:02:27.827]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:27.827]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:27.827]         }
[18:02:27.827]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:27.827]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:27.827]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:27.827]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:27.827]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:27.827]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:27.827]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:27.827]             base::names(...future.oldOptions))
[18:02:27.827]     }
[18:02:27.827]     if (FALSE) {
[18:02:27.827]     }
[18:02:27.827]     else {
[18:02:27.827]         if (TRUE) {
[18:02:27.827]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:27.827]                 open = "w")
[18:02:27.827]         }
[18:02:27.827]         else {
[18:02:27.827]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:27.827]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:27.827]         }
[18:02:27.827]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:27.827]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:27.827]             base::sink(type = "output", split = FALSE)
[18:02:27.827]             base::close(...future.stdout)
[18:02:27.827]         }, add = TRUE)
[18:02:27.827]     }
[18:02:27.827]     ...future.frame <- base::sys.nframe()
[18:02:27.827]     ...future.conditions <- base::list()
[18:02:27.827]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:27.827]     if (FALSE) {
[18:02:27.827]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:27.827]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:27.827]     }
[18:02:27.827]     ...future.result <- base::tryCatch({
[18:02:27.827]         base::withCallingHandlers({
[18:02:27.827]             ...future.value <- base::withVisible(base::local({
[18:02:27.827]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:27.827]                 if (!identical(...future.globals.maxSize.org, 
[18:02:27.827]                   ...future.globals.maxSize)) {
[18:02:27.827]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:27.827]                   on.exit(options(oopts), add = TRUE)
[18:02:27.827]                 }
[18:02:27.827]                 {
[18:02:27.827]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:27.827]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:27.827]                     USE.NAMES = FALSE)
[18:02:27.827]                   do.call(mapply, args = args)
[18:02:27.827]                 }
[18:02:27.827]             }))
[18:02:27.827]             future::FutureResult(value = ...future.value$value, 
[18:02:27.827]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:27.827]                   ...future.rng), globalenv = if (FALSE) 
[18:02:27.827]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:27.827]                     ...future.globalenv.names))
[18:02:27.827]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:27.827]         }, condition = base::local({
[18:02:27.827]             c <- base::c
[18:02:27.827]             inherits <- base::inherits
[18:02:27.827]             invokeRestart <- base::invokeRestart
[18:02:27.827]             length <- base::length
[18:02:27.827]             list <- base::list
[18:02:27.827]             seq.int <- base::seq.int
[18:02:27.827]             signalCondition <- base::signalCondition
[18:02:27.827]             sys.calls <- base::sys.calls
[18:02:27.827]             `[[` <- base::`[[`
[18:02:27.827]             `+` <- base::`+`
[18:02:27.827]             `<<-` <- base::`<<-`
[18:02:27.827]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:27.827]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:27.827]                   3L)]
[18:02:27.827]             }
[18:02:27.827]             function(cond) {
[18:02:27.827]                 is_error <- inherits(cond, "error")
[18:02:27.827]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:27.827]                   NULL)
[18:02:27.827]                 if (is_error) {
[18:02:27.827]                   sessionInformation <- function() {
[18:02:27.827]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:27.827]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:27.827]                       search = base::search(), system = base::Sys.info())
[18:02:27.827]                   }
[18:02:27.827]                   ...future.conditions[[length(...future.conditions) + 
[18:02:27.827]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:27.827]                     cond$call), session = sessionInformation(), 
[18:02:27.827]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:27.827]                   signalCondition(cond)
[18:02:27.827]                 }
[18:02:27.827]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:27.827]                 "immediateCondition"))) {
[18:02:27.827]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:27.827]                   ...future.conditions[[length(...future.conditions) + 
[18:02:27.827]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:27.827]                   if (TRUE && !signal) {
[18:02:27.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:27.827]                     {
[18:02:27.827]                       inherits <- base::inherits
[18:02:27.827]                       invokeRestart <- base::invokeRestart
[18:02:27.827]                       is.null <- base::is.null
[18:02:27.827]                       muffled <- FALSE
[18:02:27.827]                       if (inherits(cond, "message")) {
[18:02:27.827]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:27.827]                         if (muffled) 
[18:02:27.827]                           invokeRestart("muffleMessage")
[18:02:27.827]                       }
[18:02:27.827]                       else if (inherits(cond, "warning")) {
[18:02:27.827]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:27.827]                         if (muffled) 
[18:02:27.827]                           invokeRestart("muffleWarning")
[18:02:27.827]                       }
[18:02:27.827]                       else if (inherits(cond, "condition")) {
[18:02:27.827]                         if (!is.null(pattern)) {
[18:02:27.827]                           computeRestarts <- base::computeRestarts
[18:02:27.827]                           grepl <- base::grepl
[18:02:27.827]                           restarts <- computeRestarts(cond)
[18:02:27.827]                           for (restart in restarts) {
[18:02:27.827]                             name <- restart$name
[18:02:27.827]                             if (is.null(name)) 
[18:02:27.827]                               next
[18:02:27.827]                             if (!grepl(pattern, name)) 
[18:02:27.827]                               next
[18:02:27.827]                             invokeRestart(restart)
[18:02:27.827]                             muffled <- TRUE
[18:02:27.827]                             break
[18:02:27.827]                           }
[18:02:27.827]                         }
[18:02:27.827]                       }
[18:02:27.827]                       invisible(muffled)
[18:02:27.827]                     }
[18:02:27.827]                     muffleCondition(cond, pattern = "^muffle")
[18:02:27.827]                   }
[18:02:27.827]                 }
[18:02:27.827]                 else {
[18:02:27.827]                   if (TRUE) {
[18:02:27.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:27.827]                     {
[18:02:27.827]                       inherits <- base::inherits
[18:02:27.827]                       invokeRestart <- base::invokeRestart
[18:02:27.827]                       is.null <- base::is.null
[18:02:27.827]                       muffled <- FALSE
[18:02:27.827]                       if (inherits(cond, "message")) {
[18:02:27.827]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:27.827]                         if (muffled) 
[18:02:27.827]                           invokeRestart("muffleMessage")
[18:02:27.827]                       }
[18:02:27.827]                       else if (inherits(cond, "warning")) {
[18:02:27.827]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:27.827]                         if (muffled) 
[18:02:27.827]                           invokeRestart("muffleWarning")
[18:02:27.827]                       }
[18:02:27.827]                       else if (inherits(cond, "condition")) {
[18:02:27.827]                         if (!is.null(pattern)) {
[18:02:27.827]                           computeRestarts <- base::computeRestarts
[18:02:27.827]                           grepl <- base::grepl
[18:02:27.827]                           restarts <- computeRestarts(cond)
[18:02:27.827]                           for (restart in restarts) {
[18:02:27.827]                             name <- restart$name
[18:02:27.827]                             if (is.null(name)) 
[18:02:27.827]                               next
[18:02:27.827]                             if (!grepl(pattern, name)) 
[18:02:27.827]                               next
[18:02:27.827]                             invokeRestart(restart)
[18:02:27.827]                             muffled <- TRUE
[18:02:27.827]                             break
[18:02:27.827]                           }
[18:02:27.827]                         }
[18:02:27.827]                       }
[18:02:27.827]                       invisible(muffled)
[18:02:27.827]                     }
[18:02:27.827]                     muffleCondition(cond, pattern = "^muffle")
[18:02:27.827]                   }
[18:02:27.827]                 }
[18:02:27.827]             }
[18:02:27.827]         }))
[18:02:27.827]     }, error = function(ex) {
[18:02:27.827]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:27.827]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:27.827]                 ...future.rng), started = ...future.startTime, 
[18:02:27.827]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:27.827]             version = "1.8"), class = "FutureResult")
[18:02:27.827]     }, finally = {
[18:02:27.827]         if (!identical(...future.workdir, getwd())) 
[18:02:27.827]             setwd(...future.workdir)
[18:02:27.827]         {
[18:02:27.827]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:27.827]                 ...future.oldOptions$nwarnings <- NULL
[18:02:27.827]             }
[18:02:27.827]             base::options(...future.oldOptions)
[18:02:27.827]             if (.Platform$OS.type == "windows") {
[18:02:27.827]                 old_names <- names(...future.oldEnvVars)
[18:02:27.827]                 envs <- base::Sys.getenv()
[18:02:27.827]                 names <- names(envs)
[18:02:27.827]                 common <- intersect(names, old_names)
[18:02:27.827]                 added <- setdiff(names, old_names)
[18:02:27.827]                 removed <- setdiff(old_names, names)
[18:02:27.827]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:27.827]                   envs[common]]
[18:02:27.827]                 NAMES <- toupper(changed)
[18:02:27.827]                 args <- list()
[18:02:27.827]                 for (kk in seq_along(NAMES)) {
[18:02:27.827]                   name <- changed[[kk]]
[18:02:27.827]                   NAME <- NAMES[[kk]]
[18:02:27.827]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:27.827]                     next
[18:02:27.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:27.827]                 }
[18:02:27.827]                 NAMES <- toupper(added)
[18:02:27.827]                 for (kk in seq_along(NAMES)) {
[18:02:27.827]                   name <- added[[kk]]
[18:02:27.827]                   NAME <- NAMES[[kk]]
[18:02:27.827]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:27.827]                     next
[18:02:27.827]                   args[[name]] <- ""
[18:02:27.827]                 }
[18:02:27.827]                 NAMES <- toupper(removed)
[18:02:27.827]                 for (kk in seq_along(NAMES)) {
[18:02:27.827]                   name <- removed[[kk]]
[18:02:27.827]                   NAME <- NAMES[[kk]]
[18:02:27.827]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:27.827]                     next
[18:02:27.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:27.827]                 }
[18:02:27.827]                 if (length(args) > 0) 
[18:02:27.827]                   base::do.call(base::Sys.setenv, args = args)
[18:02:27.827]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:27.827]             }
[18:02:27.827]             else {
[18:02:27.827]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:27.827]             }
[18:02:27.827]             {
[18:02:27.827]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:27.827]                   0L) {
[18:02:27.827]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:27.827]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:27.827]                   base::options(opts)
[18:02:27.827]                 }
[18:02:27.827]                 {
[18:02:27.827]                   {
[18:02:27.827]                     NULL
[18:02:27.827]                     RNGkind("Mersenne-Twister")
[18:02:27.827]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:27.827]                       inherits = FALSE)
[18:02:27.827]                   }
[18:02:27.827]                   options(future.plan = NULL)
[18:02:27.827]                   if (is.na(NA_character_)) 
[18:02:27.827]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:27.827]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:27.827]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:27.827]                     .init = FALSE)
[18:02:27.827]                 }
[18:02:27.827]             }
[18:02:27.827]         }
[18:02:27.827]     })
[18:02:27.827]     if (TRUE) {
[18:02:27.827]         base::sink(type = "output", split = FALSE)
[18:02:27.827]         if (TRUE) {
[18:02:27.827]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:27.827]         }
[18:02:27.827]         else {
[18:02:27.827]             ...future.result["stdout"] <- base::list(NULL)
[18:02:27.827]         }
[18:02:27.827]         base::close(...future.stdout)
[18:02:27.827]         ...future.stdout <- NULL
[18:02:27.827]     }
[18:02:27.827]     ...future.result$conditions <- ...future.conditions
[18:02:27.827]     ...future.result$finished <- base::Sys.time()
[18:02:27.827]     ...future.result
[18:02:27.827] }
[18:02:27.833] assign_globals() ...
[18:02:27.833] List of 5
[18:02:27.833]  $ ...future.FUN            :function (x, y)  
[18:02:27.833]  $ MoreArgs                 : NULL
[18:02:27.833]  $ ...future.elements_ii    :List of 2
[18:02:27.833]   ..$ :List of 2
[18:02:27.833]   .. ..$ : int 1
[18:02:27.833]   .. ..$ : int 0
[18:02:27.833]   ..$ :List of 2
[18:02:27.833]   .. ..$ : int 0
[18:02:27.833]   .. ..$ : int 1
[18:02:27.833]  $ ...future.seeds_ii       : NULL
[18:02:27.833]  $ ...future.globals.maxSize: NULL
[18:02:27.833]  - attr(*, "where")=List of 5
[18:02:27.833]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:27.833]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:27.833]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:27.833]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:27.833]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:27.833]  - attr(*, "resolved")= logi FALSE
[18:02:27.833]  - attr(*, "total_size")= num 6480
[18:02:27.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:27.833]  - attr(*, "already-done")= logi TRUE
[18:02:27.847] - reassign environment for ‘...future.FUN’
[18:02:27.847] - copied ‘...future.FUN’ to environment
[18:02:27.847] - copied ‘MoreArgs’ to environment
[18:02:27.847] - copied ‘...future.elements_ii’ to environment
[18:02:27.847] - copied ‘...future.seeds_ii’ to environment
[18:02:27.848] - copied ‘...future.globals.maxSize’ to environment
[18:02:27.848] assign_globals() ... done
[18:02:27.848] plan(): Setting new future strategy stack:
[18:02:27.849] List of future strategies:
[18:02:27.849] 1. sequential:
[18:02:27.849]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:27.849]    - tweaked: FALSE
[18:02:27.849]    - call: NULL
[18:02:27.850] plan(): nbrOfWorkers() = 1
[18:02:28.352] plan(): Setting new future strategy stack:
[18:02:28.352] List of future strategies:
[18:02:28.352] 1. multisession:
[18:02:28.352]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:02:28.352]    - tweaked: FALSE
[18:02:28.352]    - call: plan(strategy)
[18:02:28.358] plan(): nbrOfWorkers() = 1
[18:02:28.359] SequentialFuture started (and completed)
[18:02:28.359] - Launch lazy future ... done
[18:02:28.359] run() for ‘SequentialFuture’ ... done
[18:02:28.359] Created future:
[18:02:28.360] SequentialFuture:
[18:02:28.360] Label: ‘future_mapply-1’
[18:02:28.360] Expression:
[18:02:28.360] {
[18:02:28.360]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:28.360]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:28.360]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:28.360]         on.exit(options(oopts), add = TRUE)
[18:02:28.360]     }
[18:02:28.360]     {
[18:02:28.360]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:28.360]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:28.360]         do.call(mapply, args = args)
[18:02:28.360]     }
[18:02:28.360] }
[18:02:28.360] Lazy evaluation: FALSE
[18:02:28.360] Asynchronous evaluation: FALSE
[18:02:28.360] Local evaluation: TRUE
[18:02:28.360] Environment: R_GlobalEnv
[18:02:28.360] Capture standard output: TRUE
[18:02:28.360] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:28.360] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:28.360] Packages: <none>
[18:02:28.360] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:28.360] Resolved: TRUE
[18:02:28.360] Value: 224 bytes of class ‘list’
[18:02:28.360] Early signaling: FALSE
[18:02:28.360] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:28.360] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:28.362] Chunk #1 of 1 ... DONE
[18:02:28.362] Launching 1 futures (chunks) ... DONE
[18:02:28.362] Resolving 1 futures (chunks) ...
[18:02:28.362] resolve() on list ...
[18:02:28.362]  recursive: 0
[18:02:28.363]  length: 1
[18:02:28.363] 
[18:02:28.363] resolved() for ‘SequentialFuture’ ...
[18:02:28.363] - state: ‘finished’
[18:02:28.363] - run: TRUE
[18:02:28.364] - result: ‘FutureResult’
[18:02:28.364] resolved() for ‘SequentialFuture’ ... done
[18:02:28.364] Future #1
[18:02:28.364] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:28.364] - nx: 1
[18:02:28.365] - relay: TRUE
[18:02:28.365] - stdout: TRUE
[18:02:28.365] - signal: TRUE
[18:02:28.365] - resignal: FALSE
[18:02:28.365] - force: TRUE
[18:02:28.366] - relayed: [n=1] FALSE
[18:02:28.366] - queued futures: [n=1] FALSE
[18:02:28.366]  - until=1
[18:02:28.366]  - relaying element #1
[18:02:28.367] - relayed: [n=1] TRUE
[18:02:28.367] - queued futures: [n=1] TRUE
[18:02:28.367] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:28.368]  length: 0 (resolved future 1)
[18:02:28.368] Relaying remaining futures
[18:02:28.368] signalConditionsASAP(NULL, pos=0) ...
[18:02:28.368] - nx: 1
[18:02:28.369] - relay: TRUE
[18:02:28.369] - stdout: TRUE
[18:02:28.369] - signal: TRUE
[18:02:28.369] - resignal: FALSE
[18:02:28.370] - force: TRUE
[18:02:28.370] - relayed: [n=1] TRUE
[18:02:28.370] - queued futures: [n=1] TRUE
 - flush all
[18:02:28.370] - relayed: [n=1] TRUE
[18:02:28.370] - queued futures: [n=1] TRUE
[18:02:28.371] signalConditionsASAP(NULL, pos=0) ... done
[18:02:28.371] resolve() on list ... DONE
[18:02:28.371]  - Number of value chunks collected: 1
[18:02:28.371] Resolving 1 futures (chunks) ... DONE
[18:02:28.372] Reducing values from 1 chunks ...
[18:02:28.372]  - Number of values collected after concatenation: 2
[18:02:28.372]  - Number of values expected: 2
[18:02:28.372] Reducing values from 1 chunks ... DONE
[18:02:28.372] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[18:02:28.373] future_mapply() ...
[18:02:28.381] Number of chunks: 1
[18:02:28.381] getGlobalsAndPackagesXApply() ...
[18:02:28.381]  - future.globals: TRUE
[18:02:28.382] getGlobalsAndPackages() ...
[18:02:28.382] Searching for globals...
[18:02:28.385] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:28.386] Searching for globals ... DONE
[18:02:28.386] Resolving globals: FALSE
[18:02:28.387] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:28.388] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:28.388] - globals: [1] ‘FUN’
[18:02:28.388] 
[18:02:28.388] getGlobalsAndPackages() ... DONE
[18:02:28.389]  - globals found/used: [n=1] ‘FUN’
[18:02:28.389]  - needed namespaces: [n=0] 
[18:02:28.389] Finding globals ... DONE
[18:02:28.389] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:28.390] List of 2
[18:02:28.390]  $ ...future.FUN:function (x, y)  
[18:02:28.390]  $ MoreArgs     : NULL
[18:02:28.390]  - attr(*, "where")=List of 2
[18:02:28.390]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:28.390]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:28.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:28.390]  - attr(*, "resolved")= logi FALSE
[18:02:28.390]  - attr(*, "total_size")= num NA
[18:02:28.395] Packages to be attached in all futures: [n=0] 
[18:02:28.395] getGlobalsAndPackagesXApply() ... DONE
[18:02:28.396] Number of futures (= number of chunks): 1
[18:02:28.396] Launching 1 futures (chunks) ...
[18:02:28.396] Chunk #1 of 1 ...
[18:02:28.397]  - Finding globals in '...' for chunk #1 ...
[18:02:28.397] getGlobalsAndPackages() ...
[18:02:28.397] Searching for globals...
[18:02:28.398] 
[18:02:28.398] Searching for globals ... DONE
[18:02:28.398] - globals: [0] <none>
[18:02:28.401] getGlobalsAndPackages() ... DONE
[18:02:28.401]    + additional globals found: [n=0] 
[18:02:28.401]    + additional namespaces needed: [n=0] 
[18:02:28.401]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:28.402]  - seeds: <none>
[18:02:28.402]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:28.402] getGlobalsAndPackages() ...
[18:02:28.402] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:28.403] Resolving globals: FALSE
[18:02:28.404] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[18:02:28.405] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:28.405] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:28.405] 
[18:02:28.406] getGlobalsAndPackages() ... DONE
[18:02:28.406] run() for ‘Future’ ...
[18:02:28.407] - state: ‘created’
[18:02:28.407] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:28.413] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:28.413] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[18:02:28.413]   - Field: ‘label’
[18:02:28.414]   - Field: ‘local’
[18:02:28.414]   - Field: ‘owner’
[18:02:28.414]   - Field: ‘envir’
[18:02:28.414]   - Field: ‘packages’
[18:02:28.415]   - Field: ‘gc’
[18:02:28.415]   - Field: ‘conditions’
[18:02:28.415]   - Field: ‘expr’
[18:02:28.415]   - Field: ‘uuid’
[18:02:28.415]   - Field: ‘seed’
[18:02:28.416]   - Field: ‘version’
[18:02:28.416]   - Field: ‘result’
[18:02:28.416]   - Field: ‘asynchronous’
[18:02:28.416]   - Field: ‘calls’
[18:02:28.416]   - Field: ‘globals’
[18:02:28.417]   - Field: ‘stdout’
[18:02:28.417]   - Field: ‘earlySignal’
[18:02:28.417]   - Field: ‘lazy’
[18:02:28.417]   - Field: ‘state’
[18:02:28.417] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[18:02:28.418] - Launch lazy future ...
[18:02:28.418] Packages needed by the future expression (n = 0): <none>
[18:02:28.418] Packages needed by future strategies (n = 0): <none>
[18:02:28.419] {
[18:02:28.419]     {
[18:02:28.419]         {
[18:02:28.419]             ...future.startTime <- base::Sys.time()
[18:02:28.419]             {
[18:02:28.419]                 {
[18:02:28.419]                   {
[18:02:28.419]                     base::local({
[18:02:28.419]                       has_future <- base::requireNamespace("future", 
[18:02:28.419]                         quietly = TRUE)
[18:02:28.419]                       if (has_future) {
[18:02:28.419]                         ns <- base::getNamespace("future")
[18:02:28.419]                         version <- ns[[".package"]][["version"]]
[18:02:28.419]                         if (is.null(version)) 
[18:02:28.419]                           version <- utils::packageVersion("future")
[18:02:28.419]                       }
[18:02:28.419]                       else {
[18:02:28.419]                         version <- NULL
[18:02:28.419]                       }
[18:02:28.419]                       if (!has_future || version < "1.8.0") {
[18:02:28.419]                         info <- base::c(r_version = base::gsub("R version ", 
[18:02:28.419]                           "", base::R.version$version.string), 
[18:02:28.419]                           platform = base::sprintf("%s (%s-bit)", 
[18:02:28.419]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:28.419]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:28.419]                             "release", "version")], collapse = " "), 
[18:02:28.419]                           hostname = base::Sys.info()[["nodename"]])
[18:02:28.419]                         info <- base::sprintf("%s: %s", base::names(info), 
[18:02:28.419]                           info)
[18:02:28.419]                         info <- base::paste(info, collapse = "; ")
[18:02:28.419]                         if (!has_future) {
[18:02:28.419]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:28.419]                             info)
[18:02:28.419]                         }
[18:02:28.419]                         else {
[18:02:28.419]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:28.419]                             info, version)
[18:02:28.419]                         }
[18:02:28.419]                         base::stop(msg)
[18:02:28.419]                       }
[18:02:28.419]                     })
[18:02:28.419]                   }
[18:02:28.419]                   ...future.strategy.old <- future::plan("list")
[18:02:28.419]                   options(future.plan = NULL)
[18:02:28.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:28.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:28.419]                 }
[18:02:28.419]                 ...future.workdir <- getwd()
[18:02:28.419]             }
[18:02:28.419]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:28.419]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:28.419]         }
[18:02:28.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:28.419]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:28.419]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:28.419]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:28.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:28.419]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:28.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:28.419]             base::names(...future.oldOptions))
[18:02:28.419]     }
[18:02:28.419]     if (TRUE) {
[18:02:28.419]     }
[18:02:28.419]     else {
[18:02:28.419]         if (NA) {
[18:02:28.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:28.419]                 open = "w")
[18:02:28.419]         }
[18:02:28.419]         else {
[18:02:28.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:28.419]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:28.419]         }
[18:02:28.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:28.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:28.419]             base::sink(type = "output", split = FALSE)
[18:02:28.419]             base::close(...future.stdout)
[18:02:28.419]         }, add = TRUE)
[18:02:28.419]     }
[18:02:28.419]     ...future.frame <- base::sys.nframe()
[18:02:28.419]     ...future.conditions <- base::list()
[18:02:28.419]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:28.419]     if (FALSE) {
[18:02:28.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:28.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:28.419]     }
[18:02:28.419]     ...future.result <- base::tryCatch({
[18:02:28.419]         base::withCallingHandlers({
[18:02:28.419]             ...future.value <- base::withVisible(base::local({
[18:02:28.419]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:28.419]                 if (!identical(...future.globals.maxSize.org, 
[18:02:28.419]                   ...future.globals.maxSize)) {
[18:02:28.419]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:28.419]                   on.exit(options(oopts), add = TRUE)
[18:02:28.419]                 }
[18:02:28.419]                 {
[18:02:28.419]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:28.419]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:28.419]                     USE.NAMES = FALSE)
[18:02:28.419]                   do.call(mapply, args = args)
[18:02:28.419]                 }
[18:02:28.419]             }))
[18:02:28.419]             future::FutureResult(value = ...future.value$value, 
[18:02:28.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:28.419]                   ...future.rng), globalenv = if (FALSE) 
[18:02:28.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:28.419]                     ...future.globalenv.names))
[18:02:28.419]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:28.419]         }, condition = base::local({
[18:02:28.419]             c <- base::c
[18:02:28.419]             inherits <- base::inherits
[18:02:28.419]             invokeRestart <- base::invokeRestart
[18:02:28.419]             length <- base::length
[18:02:28.419]             list <- base::list
[18:02:28.419]             seq.int <- base::seq.int
[18:02:28.419]             signalCondition <- base::signalCondition
[18:02:28.419]             sys.calls <- base::sys.calls
[18:02:28.419]             `[[` <- base::`[[`
[18:02:28.419]             `+` <- base::`+`
[18:02:28.419]             `<<-` <- base::`<<-`
[18:02:28.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:28.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:28.419]                   3L)]
[18:02:28.419]             }
[18:02:28.419]             function(cond) {
[18:02:28.419]                 is_error <- inherits(cond, "error")
[18:02:28.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:28.419]                   NULL)
[18:02:28.419]                 if (is_error) {
[18:02:28.419]                   sessionInformation <- function() {
[18:02:28.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:28.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:28.419]                       search = base::search(), system = base::Sys.info())
[18:02:28.419]                   }
[18:02:28.419]                   ...future.conditions[[length(...future.conditions) + 
[18:02:28.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:28.419]                     cond$call), session = sessionInformation(), 
[18:02:28.419]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:28.419]                   signalCondition(cond)
[18:02:28.419]                 }
[18:02:28.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:28.419]                 "immediateCondition"))) {
[18:02:28.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:28.419]                   ...future.conditions[[length(...future.conditions) + 
[18:02:28.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:28.419]                   if (TRUE && !signal) {
[18:02:28.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:28.419]                     {
[18:02:28.419]                       inherits <- base::inherits
[18:02:28.419]                       invokeRestart <- base::invokeRestart
[18:02:28.419]                       is.null <- base::is.null
[18:02:28.419]                       muffled <- FALSE
[18:02:28.419]                       if (inherits(cond, "message")) {
[18:02:28.419]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:28.419]                         if (muffled) 
[18:02:28.419]                           invokeRestart("muffleMessage")
[18:02:28.419]                       }
[18:02:28.419]                       else if (inherits(cond, "warning")) {
[18:02:28.419]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:28.419]                         if (muffled) 
[18:02:28.419]                           invokeRestart("muffleWarning")
[18:02:28.419]                       }
[18:02:28.419]                       else if (inherits(cond, "condition")) {
[18:02:28.419]                         if (!is.null(pattern)) {
[18:02:28.419]                           computeRestarts <- base::computeRestarts
[18:02:28.419]                           grepl <- base::grepl
[18:02:28.419]                           restarts <- computeRestarts(cond)
[18:02:28.419]                           for (restart in restarts) {
[18:02:28.419]                             name <- restart$name
[18:02:28.419]                             if (is.null(name)) 
[18:02:28.419]                               next
[18:02:28.419]                             if (!grepl(pattern, name)) 
[18:02:28.419]                               next
[18:02:28.419]                             invokeRestart(restart)
[18:02:28.419]                             muffled <- TRUE
[18:02:28.419]                             break
[18:02:28.419]                           }
[18:02:28.419]                         }
[18:02:28.419]                       }
[18:02:28.419]                       invisible(muffled)
[18:02:28.419]                     }
[18:02:28.419]                     muffleCondition(cond, pattern = "^muffle")
[18:02:28.419]                   }
[18:02:28.419]                 }
[18:02:28.419]                 else {
[18:02:28.419]                   if (TRUE) {
[18:02:28.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:28.419]                     {
[18:02:28.419]                       inherits <- base::inherits
[18:02:28.419]                       invokeRestart <- base::invokeRestart
[18:02:28.419]                       is.null <- base::is.null
[18:02:28.419]                       muffled <- FALSE
[18:02:28.419]                       if (inherits(cond, "message")) {
[18:02:28.419]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:28.419]                         if (muffled) 
[18:02:28.419]                           invokeRestart("muffleMessage")
[18:02:28.419]                       }
[18:02:28.419]                       else if (inherits(cond, "warning")) {
[18:02:28.419]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:28.419]                         if (muffled) 
[18:02:28.419]                           invokeRestart("muffleWarning")
[18:02:28.419]                       }
[18:02:28.419]                       else if (inherits(cond, "condition")) {
[18:02:28.419]                         if (!is.null(pattern)) {
[18:02:28.419]                           computeRestarts <- base::computeRestarts
[18:02:28.419]                           grepl <- base::grepl
[18:02:28.419]                           restarts <- computeRestarts(cond)
[18:02:28.419]                           for (restart in restarts) {
[18:02:28.419]                             name <- restart$name
[18:02:28.419]                             if (is.null(name)) 
[18:02:28.419]                               next
[18:02:28.419]                             if (!grepl(pattern, name)) 
[18:02:28.419]                               next
[18:02:28.419]                             invokeRestart(restart)
[18:02:28.419]                             muffled <- TRUE
[18:02:28.419]                             break
[18:02:28.419]                           }
[18:02:28.419]                         }
[18:02:28.419]                       }
[18:02:28.419]                       invisible(muffled)
[18:02:28.419]                     }
[18:02:28.419]                     muffleCondition(cond, pattern = "^muffle")
[18:02:28.419]                   }
[18:02:28.419]                 }
[18:02:28.419]             }
[18:02:28.419]         }))
[18:02:28.419]     }, error = function(ex) {
[18:02:28.419]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:28.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:28.419]                 ...future.rng), started = ...future.startTime, 
[18:02:28.419]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:28.419]             version = "1.8"), class = "FutureResult")
[18:02:28.419]     }, finally = {
[18:02:28.419]         if (!identical(...future.workdir, getwd())) 
[18:02:28.419]             setwd(...future.workdir)
[18:02:28.419]         {
[18:02:28.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:28.419]                 ...future.oldOptions$nwarnings <- NULL
[18:02:28.419]             }
[18:02:28.419]             base::options(...future.oldOptions)
[18:02:28.419]             if (.Platform$OS.type == "windows") {
[18:02:28.419]                 old_names <- names(...future.oldEnvVars)
[18:02:28.419]                 envs <- base::Sys.getenv()
[18:02:28.419]                 names <- names(envs)
[18:02:28.419]                 common <- intersect(names, old_names)
[18:02:28.419]                 added <- setdiff(names, old_names)
[18:02:28.419]                 removed <- setdiff(old_names, names)
[18:02:28.419]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:28.419]                   envs[common]]
[18:02:28.419]                 NAMES <- toupper(changed)
[18:02:28.419]                 args <- list()
[18:02:28.419]                 for (kk in seq_along(NAMES)) {
[18:02:28.419]                   name <- changed[[kk]]
[18:02:28.419]                   NAME <- NAMES[[kk]]
[18:02:28.419]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:28.419]                     next
[18:02:28.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:28.419]                 }
[18:02:28.419]                 NAMES <- toupper(added)
[18:02:28.419]                 for (kk in seq_along(NAMES)) {
[18:02:28.419]                   name <- added[[kk]]
[18:02:28.419]                   NAME <- NAMES[[kk]]
[18:02:28.419]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:28.419]                     next
[18:02:28.419]                   args[[name]] <- ""
[18:02:28.419]                 }
[18:02:28.419]                 NAMES <- toupper(removed)
[18:02:28.419]                 for (kk in seq_along(NAMES)) {
[18:02:28.419]                   name <- removed[[kk]]
[18:02:28.419]                   NAME <- NAMES[[kk]]
[18:02:28.419]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:28.419]                     next
[18:02:28.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:28.419]                 }
[18:02:28.419]                 if (length(args) > 0) 
[18:02:28.419]                   base::do.call(base::Sys.setenv, args = args)
[18:02:28.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:28.419]             }
[18:02:28.419]             else {
[18:02:28.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:28.419]             }
[18:02:28.419]             {
[18:02:28.419]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:28.419]                   0L) {
[18:02:28.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:28.419]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:28.419]                   base::options(opts)
[18:02:28.419]                 }
[18:02:28.419]                 {
[18:02:28.419]                   {
[18:02:28.419]                     NULL
[18:02:28.419]                     RNGkind("Mersenne-Twister")
[18:02:28.419]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[18:02:28.419]                       inherits = FALSE)
[18:02:28.419]                   }
[18:02:28.419]                   options(future.plan = NULL)
[18:02:28.419]                   if (is.na(NA_character_)) 
[18:02:28.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:28.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:28.419]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:28.419]                     .init = FALSE)
[18:02:28.419]                 }
[18:02:28.419]             }
[18:02:28.419]         }
[18:02:28.419]     })
[18:02:28.419]     if (FALSE) {
[18:02:28.419]         base::sink(type = "output", split = FALSE)
[18:02:28.419]         if (NA) {
[18:02:28.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:28.419]         }
[18:02:28.419]         else {
[18:02:28.419]             ...future.result["stdout"] <- base::list(NULL)
[18:02:28.419]         }
[18:02:28.419]         base::close(...future.stdout)
[18:02:28.419]         ...future.stdout <- NULL
[18:02:28.419]     }
[18:02:28.419]     ...future.result$conditions <- ...future.conditions
[18:02:28.419]     ...future.result$finished <- base::Sys.time()
[18:02:28.419]     ...future.result
[18:02:28.419] }
[18:02:28.423] assign_globals() ...
[18:02:28.423] List of 5
[18:02:28.423]  $ ...future.FUN            :function (x, y)  
[18:02:28.423]  $ MoreArgs                 : NULL
[18:02:28.423]  $ ...future.elements_ii    :List of 2
[18:02:28.423]   ..$ :List of 2
[18:02:28.423]   .. ..$ : int 1
[18:02:28.423]   .. ..$ : int 0
[18:02:28.423]   ..$ :List of 2
[18:02:28.423]   .. ..$ : int 0
[18:02:28.423]   .. ..$ : int 1
[18:02:28.423]  $ ...future.seeds_ii       : NULL
[18:02:28.423]  $ ...future.globals.maxSize: NULL
[18:02:28.423]  - attr(*, "where")=List of 5
[18:02:28.423]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:28.423]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:28.423]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:28.423]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:28.423]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:28.423]  - attr(*, "resolved")= logi FALSE
[18:02:28.423]  - attr(*, "total_size")= num 6480
[18:02:28.423]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:28.423]  - attr(*, "already-done")= logi TRUE
[18:02:28.435] - reassign environment for ‘...future.FUN’
[18:02:28.436] - copied ‘...future.FUN’ to environment
[18:02:28.436] - copied ‘MoreArgs’ to environment
[18:02:28.436] - copied ‘...future.elements_ii’ to environment
[18:02:28.436] - copied ‘...future.seeds_ii’ to environment
[18:02:28.436] - copied ‘...future.globals.maxSize’ to environment
[18:02:28.437] assign_globals() ... done
[18:02:28.437] plan(): Setting new future strategy stack:
[18:02:28.437] List of future strategies:
[18:02:28.437] 1. sequential:
[18:02:28.437]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:28.437]    - tweaked: FALSE
[18:02:28.437]    - call: NULL
[18:02:28.438] plan(): nbrOfWorkers() = 1
[18:02:28.941] plan(): Setting new future strategy stack:
[18:02:28.941] List of future strategies:
[18:02:28.941] 1. multisession:
[18:02:28.941]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:02:28.941]    - tweaked: FALSE
[18:02:28.941]    - call: plan(strategy)
[18:02:28.947] plan(): nbrOfWorkers() = 1
[18:02:28.948] SequentialFuture started (and completed)
[18:02:28.948] - Launch lazy future ... done
[18:02:28.948] run() for ‘SequentialFuture’ ... done
[18:02:28.948] Created future:
[18:02:28.949] SequentialFuture:
[18:02:28.949] Label: ‘future_mapply-1’
[18:02:28.949] Expression:
[18:02:28.949] {
[18:02:28.949]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:28.949]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:28.949]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:28.949]         on.exit(options(oopts), add = TRUE)
[18:02:28.949]     }
[18:02:28.949]     {
[18:02:28.949]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:28.949]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:28.949]         do.call(mapply, args = args)
[18:02:28.949]     }
[18:02:28.949] }
[18:02:28.949] Lazy evaluation: FALSE
[18:02:28.949] Asynchronous evaluation: FALSE
[18:02:28.949] Local evaluation: TRUE
[18:02:28.949] Environment: R_GlobalEnv
[18:02:28.949] Capture standard output: NA
[18:02:28.949] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:28.949] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:28.949] Packages: <none>
[18:02:28.949] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:28.949] Resolved: TRUE
[18:02:28.949] Value: 224 bytes of class ‘list’
[18:02:28.949] Early signaling: FALSE
[18:02:28.949] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:28.949] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[18:02:28.951] Chunk #1 of 1 ... DONE
[18:02:28.951] Launching 1 futures (chunks) ... DONE
[18:02:28.951] Resolving 1 futures (chunks) ...
[18:02:28.952] resolve() on list ...
[18:02:28.952]  recursive: 0
[18:02:28.952]  length: 1
[18:02:28.952] 
[18:02:28.952] resolved() for ‘SequentialFuture’ ...
[18:02:28.953] - state: ‘finished’
[18:02:28.953] - run: TRUE
[18:02:28.953] - result: ‘FutureResult’
[18:02:28.953] resolved() for ‘SequentialFuture’ ... done
[18:02:28.953] Future #1
[18:02:28.954] signalConditionsASAP(SequentialFuture, pos=1) ...
[18:02:28.954] - nx: 1
[18:02:28.954] - relay: TRUE
[18:02:28.954] - stdout: TRUE
[18:02:28.955] - signal: TRUE
[18:02:28.955] - resignal: FALSE
[18:02:28.955] - force: TRUE
[18:02:28.955] - relayed: [n=1] FALSE
[18:02:28.955] - queued futures: [n=1] FALSE
[18:02:28.956]  - until=1
[18:02:28.956]  - relaying element #1
[18:02:28.956] - relayed: [n=1] TRUE
[18:02:28.956] - queued futures: [n=1] TRUE
[18:02:28.956] signalConditionsASAP(SequentialFuture, pos=1) ... done
[18:02:28.957]  length: 0 (resolved future 1)
[18:02:28.957] Relaying remaining futures
[18:02:28.957] signalConditionsASAP(NULL, pos=0) ...
[18:02:28.957] - nx: 1
[18:02:28.957] - relay: TRUE
[18:02:28.958] - stdout: TRUE
[18:02:28.958] - signal: TRUE
[18:02:28.958] - resignal: FALSE
[18:02:28.958] - force: TRUE
[18:02:28.958] - relayed: [n=1] TRUE
[18:02:28.959] - queued futures: [n=1] TRUE
 - flush all
[18:02:28.959] - relayed: [n=1] TRUE
[18:02:28.959] - queued futures: [n=1] TRUE
[18:02:28.959] signalConditionsASAP(NULL, pos=0) ... done
[18:02:28.959] resolve() on list ... DONE
[18:02:28.960]  - Number of value chunks collected: 1
[18:02:28.960] Resolving 1 futures (chunks) ... DONE
[18:02:28.960] Reducing values from 1 chunks ...
[18:02:28.960]  - Number of values collected after concatenation: 2
[18:02:28.961]  - Number of values expected: 2
[18:02:28.961] Reducing values from 1 chunks ... DONE
[18:02:28.961] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[18:02:28.972] plan(): Setting new future strategy stack:
[18:02:28.972] List of future strategies:
[18:02:28.972] 1. multicore:
[18:02:28.972]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:28.972]    - tweaked: FALSE
[18:02:28.972]    - call: plan(strategy)
[18:02:28.978] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[18:02:28.979] future_lapply() ...
[18:02:28.989] Number of chunks: 2
[18:02:28.989] getGlobalsAndPackagesXApply() ...
[18:02:28.989]  - future.globals: TRUE
[18:02:28.990] getGlobalsAndPackages() ...
[18:02:28.990] Searching for globals...
[18:02:28.993] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:28.993] Searching for globals ... DONE
[18:02:28.994] Resolving globals: FALSE
[18:02:28.994] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:28.995] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:28.995] - globals: [1] ‘FUN’
[18:02:28.996] 
[18:02:28.996] getGlobalsAndPackages() ... DONE
[18:02:28.996]  - globals found/used: [n=1] ‘FUN’
[18:02:28.996]  - needed namespaces: [n=0] 
[18:02:28.997] Finding globals ... DONE
[18:02:28.997]  - use_args: TRUE
[18:02:28.997]  - Getting '...' globals ...
[18:02:28.998] resolve() on list ...
[18:02:28.998]  recursive: 0
[18:02:28.998]  length: 1
[18:02:28.998]  elements: ‘...’
[18:02:28.998]  length: 0 (resolved future 1)
[18:02:28.999] resolve() on list ... DONE
[18:02:28.999]    - '...' content: [n=0] 
[18:02:28.999] List of 1
[18:02:28.999]  $ ...: list()
[18:02:28.999]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:28.999]  - attr(*, "where")=List of 1
[18:02:28.999]   ..$ ...:<environment: 0x5e4f840d51f8> 
[18:02:28.999]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:28.999]  - attr(*, "resolved")= logi TRUE
[18:02:28.999]  - attr(*, "total_size")= num NA
[18:02:29.005]  - Getting '...' globals ... DONE
[18:02:29.005] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:29.005] List of 2
[18:02:29.005]  $ ...future.FUN:function (x)  
[18:02:29.005]  $ ...          : list()
[18:02:29.005]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:29.005]  - attr(*, "where")=List of 2
[18:02:29.005]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:29.005]   ..$ ...          :<environment: 0x5e4f840d51f8> 
[18:02:29.005]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:29.005]  - attr(*, "resolved")= logi FALSE
[18:02:29.005]  - attr(*, "total_size")= num 4720
[18:02:29.011] Packages to be attached in all futures: [n=0] 
[18:02:29.012] getGlobalsAndPackagesXApply() ... DONE
[18:02:29.012] Number of futures (= number of chunks): 2
[18:02:29.012] Launching 2 futures (chunks) ...
[18:02:29.013] Chunk #1 of 2 ...
[18:02:29.013]  - Finding globals in 'X' for chunk #1 ...
[18:02:29.013] getGlobalsAndPackages() ...
[18:02:29.013] Searching for globals...
[18:02:29.014] 
[18:02:29.014] Searching for globals ... DONE
[18:02:29.014] - globals: [0] <none>
[18:02:29.014] getGlobalsAndPackages() ... DONE
[18:02:29.015]    + additional globals found: [n=0] 
[18:02:29.015]    + additional namespaces needed: [n=0] 
[18:02:29.015]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:29.015]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:29.015]  - seeds: <none>
[18:02:29.016]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:29.016] getGlobalsAndPackages() ...
[18:02:29.016] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:29.016] Resolving globals: FALSE
[18:02:29.016] Tweak future expression to call with '...' arguments ...
[18:02:29.017] {
[18:02:29.017]     do.call(function(...) {
[18:02:29.017]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:29.017]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:29.017]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:29.017]             on.exit(options(oopts), add = TRUE)
[18:02:29.017]         }
[18:02:29.017]         {
[18:02:29.017]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:29.017]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:29.017]                 ...future.FUN(...future.X_jj, ...)
[18:02:29.017]             })
[18:02:29.017]         }
[18:02:29.017]     }, args = future.call.arguments)
[18:02:29.017] }
[18:02:29.017] Tweak future expression to call with '...' arguments ... DONE
[18:02:29.018] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:29.018] 
[18:02:29.019] getGlobalsAndPackages() ... DONE
[18:02:29.019] run() for ‘Future’ ...
[18:02:29.019] - state: ‘created’
[18:02:29.020] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:29.026] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:29.027] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:29.027]   - Field: ‘label’
[18:02:29.027]   - Field: ‘local’
[18:02:29.027]   - Field: ‘owner’
[18:02:29.028]   - Field: ‘envir’
[18:02:29.028]   - Field: ‘workers’
[18:02:29.028]   - Field: ‘packages’
[18:02:29.028]   - Field: ‘gc’
[18:02:29.028]   - Field: ‘job’
[18:02:29.029]   - Field: ‘conditions’
[18:02:29.029]   - Field: ‘expr’
[18:02:29.029]   - Field: ‘uuid’
[18:02:29.029]   - Field: ‘seed’
[18:02:29.029]   - Field: ‘version’
[18:02:29.030]   - Field: ‘result’
[18:02:29.030]   - Field: ‘asynchronous’
[18:02:29.030]   - Field: ‘calls’
[18:02:29.030]   - Field: ‘globals’
[18:02:29.030]   - Field: ‘stdout’
[18:02:29.031]   - Field: ‘earlySignal’
[18:02:29.031]   - Field: ‘lazy’
[18:02:29.031]   - Field: ‘state’
[18:02:29.031] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:29.032] - Launch lazy future ...
[18:02:29.033] Packages needed by the future expression (n = 0): <none>
[18:02:29.034] Packages needed by future strategies (n = 0): <none>
[18:02:29.037] {
[18:02:29.037]     {
[18:02:29.037]         {
[18:02:29.037]             ...future.startTime <- base::Sys.time()
[18:02:29.037]             {
[18:02:29.037]                 {
[18:02:29.037]                   {
[18:02:29.037]                     {
[18:02:29.037]                       base::local({
[18:02:29.037]                         has_future <- base::requireNamespace("future", 
[18:02:29.037]                           quietly = TRUE)
[18:02:29.037]                         if (has_future) {
[18:02:29.037]                           ns <- base::getNamespace("future")
[18:02:29.037]                           version <- ns[[".package"]][["version"]]
[18:02:29.037]                           if (is.null(version)) 
[18:02:29.037]                             version <- utils::packageVersion("future")
[18:02:29.037]                         }
[18:02:29.037]                         else {
[18:02:29.037]                           version <- NULL
[18:02:29.037]                         }
[18:02:29.037]                         if (!has_future || version < "1.8.0") {
[18:02:29.037]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:29.037]                             "", base::R.version$version.string), 
[18:02:29.037]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:29.037]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:29.037]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:29.037]                               "release", "version")], collapse = " "), 
[18:02:29.037]                             hostname = base::Sys.info()[["nodename"]])
[18:02:29.037]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:29.037]                             info)
[18:02:29.037]                           info <- base::paste(info, collapse = "; ")
[18:02:29.037]                           if (!has_future) {
[18:02:29.037]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:29.037]                               info)
[18:02:29.037]                           }
[18:02:29.037]                           else {
[18:02:29.037]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:29.037]                               info, version)
[18:02:29.037]                           }
[18:02:29.037]                           base::stop(msg)
[18:02:29.037]                         }
[18:02:29.037]                       })
[18:02:29.037]                     }
[18:02:29.037]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:29.037]                     base::options(mc.cores = 1L)
[18:02:29.037]                   }
[18:02:29.037]                   ...future.strategy.old <- future::plan("list")
[18:02:29.037]                   options(future.plan = NULL)
[18:02:29.037]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:29.037]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:29.037]                 }
[18:02:29.037]                 ...future.workdir <- getwd()
[18:02:29.037]             }
[18:02:29.037]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:29.037]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:29.037]         }
[18:02:29.037]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:29.037]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:29.037]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:29.037]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:29.037]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:29.037]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:29.037]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:29.037]             base::names(...future.oldOptions))
[18:02:29.037]     }
[18:02:29.037]     if (FALSE) {
[18:02:29.037]     }
[18:02:29.037]     else {
[18:02:29.037]         if (FALSE) {
[18:02:29.037]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:29.037]                 open = "w")
[18:02:29.037]         }
[18:02:29.037]         else {
[18:02:29.037]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:29.037]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:29.037]         }
[18:02:29.037]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:29.037]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:29.037]             base::sink(type = "output", split = FALSE)
[18:02:29.037]             base::close(...future.stdout)
[18:02:29.037]         }, add = TRUE)
[18:02:29.037]     }
[18:02:29.037]     ...future.frame <- base::sys.nframe()
[18:02:29.037]     ...future.conditions <- base::list()
[18:02:29.037]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:29.037]     if (FALSE) {
[18:02:29.037]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:29.037]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:29.037]     }
[18:02:29.037]     ...future.result <- base::tryCatch({
[18:02:29.037]         base::withCallingHandlers({
[18:02:29.037]             ...future.value <- base::withVisible(base::local({
[18:02:29.037]                 withCallingHandlers({
[18:02:29.037]                   {
[18:02:29.037]                     do.call(function(...) {
[18:02:29.037]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:29.037]                       if (!identical(...future.globals.maxSize.org, 
[18:02:29.037]                         ...future.globals.maxSize)) {
[18:02:29.037]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:29.037]                         on.exit(options(oopts), add = TRUE)
[18:02:29.037]                       }
[18:02:29.037]                       {
[18:02:29.037]                         lapply(seq_along(...future.elements_ii), 
[18:02:29.037]                           FUN = function(jj) {
[18:02:29.037]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:29.037]                             ...future.FUN(...future.X_jj, ...)
[18:02:29.037]                           })
[18:02:29.037]                       }
[18:02:29.037]                     }, args = future.call.arguments)
[18:02:29.037]                   }
[18:02:29.037]                 }, immediateCondition = function(cond) {
[18:02:29.037]                   save_rds <- function (object, pathname, ...) 
[18:02:29.037]                   {
[18:02:29.037]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:29.037]                     if (file_test("-f", pathname_tmp)) {
[18:02:29.037]                       fi_tmp <- file.info(pathname_tmp)
[18:02:29.037]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:29.037]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:29.037]                         fi_tmp[["mtime"]])
[18:02:29.037]                     }
[18:02:29.037]                     tryCatch({
[18:02:29.037]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:29.037]                     }, error = function(ex) {
[18:02:29.037]                       msg <- conditionMessage(ex)
[18:02:29.037]                       fi_tmp <- file.info(pathname_tmp)
[18:02:29.037]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:29.037]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:29.037]                         fi_tmp[["mtime"]], msg)
[18:02:29.037]                       ex$message <- msg
[18:02:29.037]                       stop(ex)
[18:02:29.037]                     })
[18:02:29.037]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:29.037]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:29.037]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:29.037]                       fi_tmp <- file.info(pathname_tmp)
[18:02:29.037]                       fi <- file.info(pathname)
[18:02:29.037]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:29.037]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:29.037]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:29.037]                         fi[["size"]], fi[["mtime"]])
[18:02:29.037]                       stop(msg)
[18:02:29.037]                     }
[18:02:29.037]                     invisible(pathname)
[18:02:29.037]                   }
[18:02:29.037]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:29.037]                     rootPath = tempdir()) 
[18:02:29.037]                   {
[18:02:29.037]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:29.037]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:29.037]                       tmpdir = path, fileext = ".rds")
[18:02:29.037]                     save_rds(obj, file)
[18:02:29.037]                   }
[18:02:29.037]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1j8FfD/.future/immediateConditions")
[18:02:29.037]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:29.037]                   {
[18:02:29.037]                     inherits <- base::inherits
[18:02:29.037]                     invokeRestart <- base::invokeRestart
[18:02:29.037]                     is.null <- base::is.null
[18:02:29.037]                     muffled <- FALSE
[18:02:29.037]                     if (inherits(cond, "message")) {
[18:02:29.037]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:29.037]                       if (muffled) 
[18:02:29.037]                         invokeRestart("muffleMessage")
[18:02:29.037]                     }
[18:02:29.037]                     else if (inherits(cond, "warning")) {
[18:02:29.037]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:29.037]                       if (muffled) 
[18:02:29.037]                         invokeRestart("muffleWarning")
[18:02:29.037]                     }
[18:02:29.037]                     else if (inherits(cond, "condition")) {
[18:02:29.037]                       if (!is.null(pattern)) {
[18:02:29.037]                         computeRestarts <- base::computeRestarts
[18:02:29.037]                         grepl <- base::grepl
[18:02:29.037]                         restarts <- computeRestarts(cond)
[18:02:29.037]                         for (restart in restarts) {
[18:02:29.037]                           name <- restart$name
[18:02:29.037]                           if (is.null(name)) 
[18:02:29.037]                             next
[18:02:29.037]                           if (!grepl(pattern, name)) 
[18:02:29.037]                             next
[18:02:29.037]                           invokeRestart(restart)
[18:02:29.037]                           muffled <- TRUE
[18:02:29.037]                           break
[18:02:29.037]                         }
[18:02:29.037]                       }
[18:02:29.037]                     }
[18:02:29.037]                     invisible(muffled)
[18:02:29.037]                   }
[18:02:29.037]                   muffleCondition(cond)
[18:02:29.037]                 })
[18:02:29.037]             }))
[18:02:29.037]             future::FutureResult(value = ...future.value$value, 
[18:02:29.037]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:29.037]                   ...future.rng), globalenv = if (FALSE) 
[18:02:29.037]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:29.037]                     ...future.globalenv.names))
[18:02:29.037]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:29.037]         }, condition = base::local({
[18:02:29.037]             c <- base::c
[18:02:29.037]             inherits <- base::inherits
[18:02:29.037]             invokeRestart <- base::invokeRestart
[18:02:29.037]             length <- base::length
[18:02:29.037]             list <- base::list
[18:02:29.037]             seq.int <- base::seq.int
[18:02:29.037]             signalCondition <- base::signalCondition
[18:02:29.037]             sys.calls <- base::sys.calls
[18:02:29.037]             `[[` <- base::`[[`
[18:02:29.037]             `+` <- base::`+`
[18:02:29.037]             `<<-` <- base::`<<-`
[18:02:29.037]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:29.037]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:29.037]                   3L)]
[18:02:29.037]             }
[18:02:29.037]             function(cond) {
[18:02:29.037]                 is_error <- inherits(cond, "error")
[18:02:29.037]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:29.037]                   NULL)
[18:02:29.037]                 if (is_error) {
[18:02:29.037]                   sessionInformation <- function() {
[18:02:29.037]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:29.037]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:29.037]                       search = base::search(), system = base::Sys.info())
[18:02:29.037]                   }
[18:02:29.037]                   ...future.conditions[[length(...future.conditions) + 
[18:02:29.037]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:29.037]                     cond$call), session = sessionInformation(), 
[18:02:29.037]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:29.037]                   signalCondition(cond)
[18:02:29.037]                 }
[18:02:29.037]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:29.037]                 "immediateCondition"))) {
[18:02:29.037]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:29.037]                   ...future.conditions[[length(...future.conditions) + 
[18:02:29.037]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:29.037]                   if (TRUE && !signal) {
[18:02:29.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:29.037]                     {
[18:02:29.037]                       inherits <- base::inherits
[18:02:29.037]                       invokeRestart <- base::invokeRestart
[18:02:29.037]                       is.null <- base::is.null
[18:02:29.037]                       muffled <- FALSE
[18:02:29.037]                       if (inherits(cond, "message")) {
[18:02:29.037]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:29.037]                         if (muffled) 
[18:02:29.037]                           invokeRestart("muffleMessage")
[18:02:29.037]                       }
[18:02:29.037]                       else if (inherits(cond, "warning")) {
[18:02:29.037]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:29.037]                         if (muffled) 
[18:02:29.037]                           invokeRestart("muffleWarning")
[18:02:29.037]                       }
[18:02:29.037]                       else if (inherits(cond, "condition")) {
[18:02:29.037]                         if (!is.null(pattern)) {
[18:02:29.037]                           computeRestarts <- base::computeRestarts
[18:02:29.037]                           grepl <- base::grepl
[18:02:29.037]                           restarts <- computeRestarts(cond)
[18:02:29.037]                           for (restart in restarts) {
[18:02:29.037]                             name <- restart$name
[18:02:29.037]                             if (is.null(name)) 
[18:02:29.037]                               next
[18:02:29.037]                             if (!grepl(pattern, name)) 
[18:02:29.037]                               next
[18:02:29.037]                             invokeRestart(restart)
[18:02:29.037]                             muffled <- TRUE
[18:02:29.037]                             break
[18:02:29.037]                           }
[18:02:29.037]                         }
[18:02:29.037]                       }
[18:02:29.037]                       invisible(muffled)
[18:02:29.037]                     }
[18:02:29.037]                     muffleCondition(cond, pattern = "^muffle")
[18:02:29.037]                   }
[18:02:29.037]                 }
[18:02:29.037]                 else {
[18:02:29.037]                   if (TRUE) {
[18:02:29.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:29.037]                     {
[18:02:29.037]                       inherits <- base::inherits
[18:02:29.037]                       invokeRestart <- base::invokeRestart
[18:02:29.037]                       is.null <- base::is.null
[18:02:29.037]                       muffled <- FALSE
[18:02:29.037]                       if (inherits(cond, "message")) {
[18:02:29.037]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:29.037]                         if (muffled) 
[18:02:29.037]                           invokeRestart("muffleMessage")
[18:02:29.037]                       }
[18:02:29.037]                       else if (inherits(cond, "warning")) {
[18:02:29.037]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:29.037]                         if (muffled) 
[18:02:29.037]                           invokeRestart("muffleWarning")
[18:02:29.037]                       }
[18:02:29.037]                       else if (inherits(cond, "condition")) {
[18:02:29.037]                         if (!is.null(pattern)) {
[18:02:29.037]                           computeRestarts <- base::computeRestarts
[18:02:29.037]                           grepl <- base::grepl
[18:02:29.037]                           restarts <- computeRestarts(cond)
[18:02:29.037]                           for (restart in restarts) {
[18:02:29.037]                             name <- restart$name
[18:02:29.037]                             if (is.null(name)) 
[18:02:29.037]                               next
[18:02:29.037]                             if (!grepl(pattern, name)) 
[18:02:29.037]                               next
[18:02:29.037]                             invokeRestart(restart)
[18:02:29.037]                             muffled <- TRUE
[18:02:29.037]                             break
[18:02:29.037]                           }
[18:02:29.037]                         }
[18:02:29.037]                       }
[18:02:29.037]                       invisible(muffled)
[18:02:29.037]                     }
[18:02:29.037]                     muffleCondition(cond, pattern = "^muffle")
[18:02:29.037]                   }
[18:02:29.037]                 }
[18:02:29.037]             }
[18:02:29.037]         }))
[18:02:29.037]     }, error = function(ex) {
[18:02:29.037]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:29.037]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:29.037]                 ...future.rng), started = ...future.startTime, 
[18:02:29.037]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:29.037]             version = "1.8"), class = "FutureResult")
[18:02:29.037]     }, finally = {
[18:02:29.037]         if (!identical(...future.workdir, getwd())) 
[18:02:29.037]             setwd(...future.workdir)
[18:02:29.037]         {
[18:02:29.037]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:29.037]                 ...future.oldOptions$nwarnings <- NULL
[18:02:29.037]             }
[18:02:29.037]             base::options(...future.oldOptions)
[18:02:29.037]             if (.Platform$OS.type == "windows") {
[18:02:29.037]                 old_names <- names(...future.oldEnvVars)
[18:02:29.037]                 envs <- base::Sys.getenv()
[18:02:29.037]                 names <- names(envs)
[18:02:29.037]                 common <- intersect(names, old_names)
[18:02:29.037]                 added <- setdiff(names, old_names)
[18:02:29.037]                 removed <- setdiff(old_names, names)
[18:02:29.037]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:29.037]                   envs[common]]
[18:02:29.037]                 NAMES <- toupper(changed)
[18:02:29.037]                 args <- list()
[18:02:29.037]                 for (kk in seq_along(NAMES)) {
[18:02:29.037]                   name <- changed[[kk]]
[18:02:29.037]                   NAME <- NAMES[[kk]]
[18:02:29.037]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:29.037]                     next
[18:02:29.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:29.037]                 }
[18:02:29.037]                 NAMES <- toupper(added)
[18:02:29.037]                 for (kk in seq_along(NAMES)) {
[18:02:29.037]                   name <- added[[kk]]
[18:02:29.037]                   NAME <- NAMES[[kk]]
[18:02:29.037]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:29.037]                     next
[18:02:29.037]                   args[[name]] <- ""
[18:02:29.037]                 }
[18:02:29.037]                 NAMES <- toupper(removed)
[18:02:29.037]                 for (kk in seq_along(NAMES)) {
[18:02:29.037]                   name <- removed[[kk]]
[18:02:29.037]                   NAME <- NAMES[[kk]]
[18:02:29.037]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:29.037]                     next
[18:02:29.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:29.037]                 }
[18:02:29.037]                 if (length(args) > 0) 
[18:02:29.037]                   base::do.call(base::Sys.setenv, args = args)
[18:02:29.037]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:29.037]             }
[18:02:29.037]             else {
[18:02:29.037]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:29.037]             }
[18:02:29.037]             {
[18:02:29.037]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:29.037]                   0L) {
[18:02:29.037]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:29.037]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:29.037]                   base::options(opts)
[18:02:29.037]                 }
[18:02:29.037]                 {
[18:02:29.037]                   {
[18:02:29.037]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:29.037]                     NULL
[18:02:29.037]                   }
[18:02:29.037]                   options(future.plan = NULL)
[18:02:29.037]                   if (is.na(NA_character_)) 
[18:02:29.037]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:29.037]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:29.037]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:29.037]                     .init = FALSE)
[18:02:29.037]                 }
[18:02:29.037]             }
[18:02:29.037]         }
[18:02:29.037]     })
[18:02:29.037]     if (TRUE) {
[18:02:29.037]         base::sink(type = "output", split = FALSE)
[18:02:29.037]         if (FALSE) {
[18:02:29.037]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:29.037]         }
[18:02:29.037]         else {
[18:02:29.037]             ...future.result["stdout"] <- base::list(NULL)
[18:02:29.037]         }
[18:02:29.037]         base::close(...future.stdout)
[18:02:29.037]         ...future.stdout <- NULL
[18:02:29.037]     }
[18:02:29.037]     ...future.result$conditions <- ...future.conditions
[18:02:29.037]     ...future.result$finished <- base::Sys.time()
[18:02:29.037]     ...future.result
[18:02:29.037] }
[18:02:29.042] assign_globals() ...
[18:02:29.043] List of 5
[18:02:29.043]  $ ...future.FUN            :function (x)  
[18:02:29.043]  $ future.call.arguments    : list()
[18:02:29.043]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:29.043]  $ ...future.elements_ii    :List of 1
[18:02:29.043]   ..$ : int 1
[18:02:29.043]  $ ...future.seeds_ii       : NULL
[18:02:29.043]  $ ...future.globals.maxSize: NULL
[18:02:29.043]  - attr(*, "where")=List of 5
[18:02:29.043]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:29.043]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:29.043]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:29.043]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:29.043]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:29.043]  - attr(*, "resolved")= logi FALSE
[18:02:29.043]  - attr(*, "total_size")= num 4720
[18:02:29.043]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:29.043]  - attr(*, "already-done")= logi TRUE
[18:02:29.053] - reassign environment for ‘...future.FUN’
[18:02:29.053] - copied ‘...future.FUN’ to environment
[18:02:29.054] - copied ‘future.call.arguments’ to environment
[18:02:29.054] - copied ‘...future.elements_ii’ to environment
[18:02:29.054] - copied ‘...future.seeds_ii’ to environment
[18:02:29.054] - copied ‘...future.globals.maxSize’ to environment
[18:02:29.054] assign_globals() ... done
[18:02:29.055] requestCore(): workers = 2
[18:02:29.062] MulticoreFuture started
[18:02:29.063] - Launch lazy future ... done
[18:02:29.063] run() for ‘MulticoreFuture’ ... done
[18:02:29.066] plan(): Setting new future strategy stack:
[18:02:29.064] Created future:
[18:02:29.067] List of future strategies:
[18:02:29.067] 1. sequential:
[18:02:29.067]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:29.067]    - tweaked: FALSE
[18:02:29.067]    - call: NULL
[18:02:29.073] plan(): nbrOfWorkers() = 1
[18:02:29.067] MulticoreFuture:
[18:02:29.067] Label: ‘future_lapply-1’
[18:02:29.067] Expression:
[18:02:29.067] {
[18:02:29.067]     do.call(function(...) {
[18:02:29.067]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:29.067]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:29.067]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:29.067]             on.exit(options(oopts), add = TRUE)
[18:02:29.067]         }
[18:02:29.067]         {
[18:02:29.067]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:29.067]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:29.067]                 ...future.FUN(...future.X_jj, ...)
[18:02:29.067]             })
[18:02:29.067]         }
[18:02:29.067]     }, args = future.call.arguments)
[18:02:29.067] }
[18:02:29.067] Lazy evaluation: FALSE
[18:02:29.067] Asynchronous evaluation: TRUE
[18:02:29.067] Local evaluation: TRUE
[18:02:29.067] Environment: R_GlobalEnv
[18:02:29.067] Capture standard output: FALSE
[18:02:29.067] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:29.067] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:29.067] Packages: <none>
[18:02:29.067] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:29.067] Resolved: FALSE
[18:02:29.067] Value: <not collected>
[18:02:29.067] Conditions captured: <none>
[18:02:29.067] Early signaling: FALSE
[18:02:29.067] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:29.067] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:29.093] Chunk #1 of 2 ... DONE
[18:02:29.093] Chunk #2 of 2 ...
[18:02:29.094]  - Finding globals in 'X' for chunk #2 ...
[18:02:29.094] getGlobalsAndPackages() ...
[18:02:29.094] Searching for globals...
[18:02:29.095] 
[18:02:29.096] Searching for globals ... DONE
[18:02:29.096] - globals: [0] <none>
[18:02:29.096] getGlobalsAndPackages() ... DONE
[18:02:29.097]    + additional globals found: [n=0] 
[18:02:29.097]    + additional namespaces needed: [n=0] 
[18:02:29.097]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:29.098]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:29.098]  - seeds: <none>
[18:02:29.098]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:29.099] getGlobalsAndPackages() ...
[18:02:29.099] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:29.100] Resolving globals: FALSE
[18:02:29.100] Tweak future expression to call with '...' arguments ...
[18:02:29.100] {
[18:02:29.100]     do.call(function(...) {
[18:02:29.100]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:29.100]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:29.100]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:29.100]             on.exit(options(oopts), add = TRUE)
[18:02:29.100]         }
[18:02:29.100]         {
[18:02:29.100]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:29.100]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:29.100]                 ...future.FUN(...future.X_jj, ...)
[18:02:29.100]             })
[18:02:29.100]         }
[18:02:29.100]     }, args = future.call.arguments)
[18:02:29.100] }
[18:02:29.101] Tweak future expression to call with '...' arguments ... DONE
[18:02:29.103] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:29.103] 
[18:02:29.104] getGlobalsAndPackages() ... DONE
[18:02:29.105] run() for ‘Future’ ...
[18:02:29.105] - state: ‘created’
[18:02:29.106] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:29.115] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:29.115] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:29.115]   - Field: ‘label’
[18:02:29.116]   - Field: ‘local’
[18:02:29.116]   - Field: ‘owner’
[18:02:29.116]   - Field: ‘envir’
[18:02:29.117]   - Field: ‘workers’
[18:02:29.117]   - Field: ‘packages’
[18:02:29.117]   - Field: ‘gc’
[18:02:29.118]   - Field: ‘job’
[18:02:29.118]   - Field: ‘conditions’
[18:02:29.118]   - Field: ‘expr’
[18:02:29.119]   - Field: ‘uuid’
[18:02:29.119]   - Field: ‘seed’
[18:02:29.119]   - Field: ‘version’
[18:02:29.120]   - Field: ‘result’
[18:02:29.120]   - Field: ‘asynchronous’
[18:02:29.120]   - Field: ‘calls’
[18:02:29.121]   - Field: ‘globals’
[18:02:29.121]   - Field: ‘stdout’
[18:02:29.121]   - Field: ‘earlySignal’
[18:02:29.122]   - Field: ‘lazy’
[18:02:29.122]   - Field: ‘state’
[18:02:29.122] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:29.123] - Launch lazy future ...
[18:02:29.124] Packages needed by the future expression (n = 0): <none>
[18:02:29.125] Packages needed by future strategies (n = 0): <none>
[18:02:29.126] {
[18:02:29.126]     {
[18:02:29.126]         {
[18:02:29.126]             ...future.startTime <- base::Sys.time()
[18:02:29.126]             {
[18:02:29.126]                 {
[18:02:29.126]                   {
[18:02:29.126]                     {
[18:02:29.126]                       base::local({
[18:02:29.126]                         has_future <- base::requireNamespace("future", 
[18:02:29.126]                           quietly = TRUE)
[18:02:29.126]                         if (has_future) {
[18:02:29.126]                           ns <- base::getNamespace("future")
[18:02:29.126]                           version <- ns[[".package"]][["version"]]
[18:02:29.126]                           if (is.null(version)) 
[18:02:29.126]                             version <- utils::packageVersion("future")
[18:02:29.126]                         }
[18:02:29.126]                         else {
[18:02:29.126]                           version <- NULL
[18:02:29.126]                         }
[18:02:29.126]                         if (!has_future || version < "1.8.0") {
[18:02:29.126]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:29.126]                             "", base::R.version$version.string), 
[18:02:29.126]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:29.126]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:29.126]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:29.126]                               "release", "version")], collapse = " "), 
[18:02:29.126]                             hostname = base::Sys.info()[["nodename"]])
[18:02:29.126]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:29.126]                             info)
[18:02:29.126]                           info <- base::paste(info, collapse = "; ")
[18:02:29.126]                           if (!has_future) {
[18:02:29.126]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:29.126]                               info)
[18:02:29.126]                           }
[18:02:29.126]                           else {
[18:02:29.126]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:29.126]                               info, version)
[18:02:29.126]                           }
[18:02:29.126]                           base::stop(msg)
[18:02:29.126]                         }
[18:02:29.126]                       })
[18:02:29.126]                     }
[18:02:29.126]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:29.126]                     base::options(mc.cores = 1L)
[18:02:29.126]                   }
[18:02:29.126]                   ...future.strategy.old <- future::plan("list")
[18:02:29.126]                   options(future.plan = NULL)
[18:02:29.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:29.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:29.126]                 }
[18:02:29.126]                 ...future.workdir <- getwd()
[18:02:29.126]             }
[18:02:29.126]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:29.126]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:29.126]         }
[18:02:29.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:29.126]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:29.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:29.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:29.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:29.126]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:29.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:29.126]             base::names(...future.oldOptions))
[18:02:29.126]     }
[18:02:29.126]     if (FALSE) {
[18:02:29.126]     }
[18:02:29.126]     else {
[18:02:29.126]         if (FALSE) {
[18:02:29.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:29.126]                 open = "w")
[18:02:29.126]         }
[18:02:29.126]         else {
[18:02:29.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:29.126]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:29.126]         }
[18:02:29.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:29.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:29.126]             base::sink(type = "output", split = FALSE)
[18:02:29.126]             base::close(...future.stdout)
[18:02:29.126]         }, add = TRUE)
[18:02:29.126]     }
[18:02:29.126]     ...future.frame <- base::sys.nframe()
[18:02:29.126]     ...future.conditions <- base::list()
[18:02:29.126]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:29.126]     if (FALSE) {
[18:02:29.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:29.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:29.126]     }
[18:02:29.126]     ...future.result <- base::tryCatch({
[18:02:29.126]         base::withCallingHandlers({
[18:02:29.126]             ...future.value <- base::withVisible(base::local({
[18:02:29.126]                 withCallingHandlers({
[18:02:29.126]                   {
[18:02:29.126]                     do.call(function(...) {
[18:02:29.126]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:29.126]                       if (!identical(...future.globals.maxSize.org, 
[18:02:29.126]                         ...future.globals.maxSize)) {
[18:02:29.126]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:29.126]                         on.exit(options(oopts), add = TRUE)
[18:02:29.126]                       }
[18:02:29.126]                       {
[18:02:29.126]                         lapply(seq_along(...future.elements_ii), 
[18:02:29.126]                           FUN = function(jj) {
[18:02:29.126]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:29.126]                             ...future.FUN(...future.X_jj, ...)
[18:02:29.126]                           })
[18:02:29.126]                       }
[18:02:29.126]                     }, args = future.call.arguments)
[18:02:29.126]                   }
[18:02:29.126]                 }, immediateCondition = function(cond) {
[18:02:29.126]                   save_rds <- function (object, pathname, ...) 
[18:02:29.126]                   {
[18:02:29.126]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:29.126]                     if (file_test("-f", pathname_tmp)) {
[18:02:29.126]                       fi_tmp <- file.info(pathname_tmp)
[18:02:29.126]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:29.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:29.126]                         fi_tmp[["mtime"]])
[18:02:29.126]                     }
[18:02:29.126]                     tryCatch({
[18:02:29.126]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:29.126]                     }, error = function(ex) {
[18:02:29.126]                       msg <- conditionMessage(ex)
[18:02:29.126]                       fi_tmp <- file.info(pathname_tmp)
[18:02:29.126]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:29.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:29.126]                         fi_tmp[["mtime"]], msg)
[18:02:29.126]                       ex$message <- msg
[18:02:29.126]                       stop(ex)
[18:02:29.126]                     })
[18:02:29.126]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:29.126]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:29.126]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:29.126]                       fi_tmp <- file.info(pathname_tmp)
[18:02:29.126]                       fi <- file.info(pathname)
[18:02:29.126]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:29.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:29.126]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:29.126]                         fi[["size"]], fi[["mtime"]])
[18:02:29.126]                       stop(msg)
[18:02:29.126]                     }
[18:02:29.126]                     invisible(pathname)
[18:02:29.126]                   }
[18:02:29.126]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:29.126]                     rootPath = tempdir()) 
[18:02:29.126]                   {
[18:02:29.126]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:29.126]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:29.126]                       tmpdir = path, fileext = ".rds")
[18:02:29.126]                     save_rds(obj, file)
[18:02:29.126]                   }
[18:02:29.126]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1j8FfD/.future/immediateConditions")
[18:02:29.126]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:29.126]                   {
[18:02:29.126]                     inherits <- base::inherits
[18:02:29.126]                     invokeRestart <- base::invokeRestart
[18:02:29.126]                     is.null <- base::is.null
[18:02:29.126]                     muffled <- FALSE
[18:02:29.126]                     if (inherits(cond, "message")) {
[18:02:29.126]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:29.126]                       if (muffled) 
[18:02:29.126]                         invokeRestart("muffleMessage")
[18:02:29.126]                     }
[18:02:29.126]                     else if (inherits(cond, "warning")) {
[18:02:29.126]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:29.126]                       if (muffled) 
[18:02:29.126]                         invokeRestart("muffleWarning")
[18:02:29.126]                     }
[18:02:29.126]                     else if (inherits(cond, "condition")) {
[18:02:29.126]                       if (!is.null(pattern)) {
[18:02:29.126]                         computeRestarts <- base::computeRestarts
[18:02:29.126]                         grepl <- base::grepl
[18:02:29.126]                         restarts <- computeRestarts(cond)
[18:02:29.126]                         for (restart in restarts) {
[18:02:29.126]                           name <- restart$name
[18:02:29.126]                           if (is.null(name)) 
[18:02:29.126]                             next
[18:02:29.126]                           if (!grepl(pattern, name)) 
[18:02:29.126]                             next
[18:02:29.126]                           invokeRestart(restart)
[18:02:29.126]                           muffled <- TRUE
[18:02:29.126]                           break
[18:02:29.126]                         }
[18:02:29.126]                       }
[18:02:29.126]                     }
[18:02:29.126]                     invisible(muffled)
[18:02:29.126]                   }
[18:02:29.126]                   muffleCondition(cond)
[18:02:29.126]                 })
[18:02:29.126]             }))
[18:02:29.126]             future::FutureResult(value = ...future.value$value, 
[18:02:29.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:29.126]                   ...future.rng), globalenv = if (FALSE) 
[18:02:29.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:29.126]                     ...future.globalenv.names))
[18:02:29.126]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:29.126]         }, condition = base::local({
[18:02:29.126]             c <- base::c
[18:02:29.126]             inherits <- base::inherits
[18:02:29.126]             invokeRestart <- base::invokeRestart
[18:02:29.126]             length <- base::length
[18:02:29.126]             list <- base::list
[18:02:29.126]             seq.int <- base::seq.int
[18:02:29.126]             signalCondition <- base::signalCondition
[18:02:29.126]             sys.calls <- base::sys.calls
[18:02:29.126]             `[[` <- base::`[[`
[18:02:29.126]             `+` <- base::`+`
[18:02:29.126]             `<<-` <- base::`<<-`
[18:02:29.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:29.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:29.126]                   3L)]
[18:02:29.126]             }
[18:02:29.126]             function(cond) {
[18:02:29.126]                 is_error <- inherits(cond, "error")
[18:02:29.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:29.126]                   NULL)
[18:02:29.126]                 if (is_error) {
[18:02:29.126]                   sessionInformation <- function() {
[18:02:29.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:29.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:29.126]                       search = base::search(), system = base::Sys.info())
[18:02:29.126]                   }
[18:02:29.126]                   ...future.conditions[[length(...future.conditions) + 
[18:02:29.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:29.126]                     cond$call), session = sessionInformation(), 
[18:02:29.126]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:29.126]                   signalCondition(cond)
[18:02:29.126]                 }
[18:02:29.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:29.126]                 "immediateCondition"))) {
[18:02:29.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:29.126]                   ...future.conditions[[length(...future.conditions) + 
[18:02:29.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:29.126]                   if (TRUE && !signal) {
[18:02:29.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:29.126]                     {
[18:02:29.126]                       inherits <- base::inherits
[18:02:29.126]                       invokeRestart <- base::invokeRestart
[18:02:29.126]                       is.null <- base::is.null
[18:02:29.126]                       muffled <- FALSE
[18:02:29.126]                       if (inherits(cond, "message")) {
[18:02:29.126]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:29.126]                         if (muffled) 
[18:02:29.126]                           invokeRestart("muffleMessage")
[18:02:29.126]                       }
[18:02:29.126]                       else if (inherits(cond, "warning")) {
[18:02:29.126]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:29.126]                         if (muffled) 
[18:02:29.126]                           invokeRestart("muffleWarning")
[18:02:29.126]                       }
[18:02:29.126]                       else if (inherits(cond, "condition")) {
[18:02:29.126]                         if (!is.null(pattern)) {
[18:02:29.126]                           computeRestarts <- base::computeRestarts
[18:02:29.126]                           grepl <- base::grepl
[18:02:29.126]                           restarts <- computeRestarts(cond)
[18:02:29.126]                           for (restart in restarts) {
[18:02:29.126]                             name <- restart$name
[18:02:29.126]                             if (is.null(name)) 
[18:02:29.126]                               next
[18:02:29.126]                             if (!grepl(pattern, name)) 
[18:02:29.126]                               next
[18:02:29.126]                             invokeRestart(restart)
[18:02:29.126]                             muffled <- TRUE
[18:02:29.126]                             break
[18:02:29.126]                           }
[18:02:29.126]                         }
[18:02:29.126]                       }
[18:02:29.126]                       invisible(muffled)
[18:02:29.126]                     }
[18:02:29.126]                     muffleCondition(cond, pattern = "^muffle")
[18:02:29.126]                   }
[18:02:29.126]                 }
[18:02:29.126]                 else {
[18:02:29.126]                   if (TRUE) {
[18:02:29.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:29.126]                     {
[18:02:29.126]                       inherits <- base::inherits
[18:02:29.126]                       invokeRestart <- base::invokeRestart
[18:02:29.126]                       is.null <- base::is.null
[18:02:29.126]                       muffled <- FALSE
[18:02:29.126]                       if (inherits(cond, "message")) {
[18:02:29.126]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:29.126]                         if (muffled) 
[18:02:29.126]                           invokeRestart("muffleMessage")
[18:02:29.126]                       }
[18:02:29.126]                       else if (inherits(cond, "warning")) {
[18:02:29.126]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:29.126]                         if (muffled) 
[18:02:29.126]                           invokeRestart("muffleWarning")
[18:02:29.126]                       }
[18:02:29.126]                       else if (inherits(cond, "condition")) {
[18:02:29.126]                         if (!is.null(pattern)) {
[18:02:29.126]                           computeRestarts <- base::computeRestarts
[18:02:29.126]                           grepl <- base::grepl
[18:02:29.126]                           restarts <- computeRestarts(cond)
[18:02:29.126]                           for (restart in restarts) {
[18:02:29.126]                             name <- restart$name
[18:02:29.126]                             if (is.null(name)) 
[18:02:29.126]                               next
[18:02:29.126]                             if (!grepl(pattern, name)) 
[18:02:29.126]                               next
[18:02:29.126]                             invokeRestart(restart)
[18:02:29.126]                             muffled <- TRUE
[18:02:29.126]                             break
[18:02:29.126]                           }
[18:02:29.126]                         }
[18:02:29.126]                       }
[18:02:29.126]                       invisible(muffled)
[18:02:29.126]                     }
[18:02:29.126]                     muffleCondition(cond, pattern = "^muffle")
[18:02:29.126]                   }
[18:02:29.126]                 }
[18:02:29.126]             }
[18:02:29.126]         }))
[18:02:29.126]     }, error = function(ex) {
[18:02:29.126]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:29.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:29.126]                 ...future.rng), started = ...future.startTime, 
[18:02:29.126]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:29.126]             version = "1.8"), class = "FutureResult")
[18:02:29.126]     }, finally = {
[18:02:29.126]         if (!identical(...future.workdir, getwd())) 
[18:02:29.126]             setwd(...future.workdir)
[18:02:29.126]         {
[18:02:29.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:29.126]                 ...future.oldOptions$nwarnings <- NULL
[18:02:29.126]             }
[18:02:29.126]             base::options(...future.oldOptions)
[18:02:29.126]             if (.Platform$OS.type == "windows") {
[18:02:29.126]                 old_names <- names(...future.oldEnvVars)
[18:02:29.126]                 envs <- base::Sys.getenv()
[18:02:29.126]                 names <- names(envs)
[18:02:29.126]                 common <- intersect(names, old_names)
[18:02:29.126]                 added <- setdiff(names, old_names)
[18:02:29.126]                 removed <- setdiff(old_names, names)
[18:02:29.126]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:29.126]                   envs[common]]
[18:02:29.126]                 NAMES <- toupper(changed)
[18:02:29.126]                 args <- list()
[18:02:29.126]                 for (kk in seq_along(NAMES)) {
[18:02:29.126]                   name <- changed[[kk]]
[18:02:29.126]                   NAME <- NAMES[[kk]]
[18:02:29.126]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:29.126]                     next
[18:02:29.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:29.126]                 }
[18:02:29.126]                 NAMES <- toupper(added)
[18:02:29.126]                 for (kk in seq_along(NAMES)) {
[18:02:29.126]                   name <- added[[kk]]
[18:02:29.126]                   NAME <- NAMES[[kk]]
[18:02:29.126]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:29.126]                     next
[18:02:29.126]                   args[[name]] <- ""
[18:02:29.126]                 }
[18:02:29.126]                 NAMES <- toupper(removed)
[18:02:29.126]                 for (kk in seq_along(NAMES)) {
[18:02:29.126]                   name <- removed[[kk]]
[18:02:29.126]                   NAME <- NAMES[[kk]]
[18:02:29.126]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:29.126]                     next
[18:02:29.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:29.126]                 }
[18:02:29.126]                 if (length(args) > 0) 
[18:02:29.126]                   base::do.call(base::Sys.setenv, args = args)
[18:02:29.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:29.126]             }
[18:02:29.126]             else {
[18:02:29.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:29.126]             }
[18:02:29.126]             {
[18:02:29.126]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:29.126]                   0L) {
[18:02:29.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:29.126]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:29.126]                   base::options(opts)
[18:02:29.126]                 }
[18:02:29.126]                 {
[18:02:29.126]                   {
[18:02:29.126]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:29.126]                     NULL
[18:02:29.126]                   }
[18:02:29.126]                   options(future.plan = NULL)
[18:02:29.126]                   if (is.na(NA_character_)) 
[18:02:29.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:29.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:29.126]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:29.126]                     .init = FALSE)
[18:02:29.126]                 }
[18:02:29.126]             }
[18:02:29.126]         }
[18:02:29.126]     })
[18:02:29.126]     if (TRUE) {
[18:02:29.126]         base::sink(type = "output", split = FALSE)
[18:02:29.126]         if (FALSE) {
[18:02:29.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:29.126]         }
[18:02:29.126]         else {
[18:02:29.126]             ...future.result["stdout"] <- base::list(NULL)
[18:02:29.126]         }
[18:02:29.126]         base::close(...future.stdout)
[18:02:29.126]         ...future.stdout <- NULL
[18:02:29.126]     }
[18:02:29.126]     ...future.result$conditions <- ...future.conditions
[18:02:29.126]     ...future.result$finished <- base::Sys.time()
[18:02:29.126]     ...future.result
[18:02:29.126] }
[18:02:29.133] assign_globals() ...
[18:02:29.133] List of 5
[18:02:29.133]  $ ...future.FUN            :function (x)  
[18:02:29.133]  $ future.call.arguments    : list()
[18:02:29.133]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:29.133]  $ ...future.elements_ii    :List of 1
[18:02:29.133]   ..$ : int 0
[18:02:29.133]  $ ...future.seeds_ii       : NULL
[18:02:29.133]  $ ...future.globals.maxSize: NULL
[18:02:29.133]  - attr(*, "where")=List of 5
[18:02:29.133]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:29.133]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:29.133]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:29.133]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:29.133]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:29.133]  - attr(*, "resolved")= logi FALSE
[18:02:29.133]  - attr(*, "total_size")= num 4720
[18:02:29.133]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:29.133]  - attr(*, "already-done")= logi TRUE
[18:02:29.148] - reassign environment for ‘...future.FUN’
[18:02:29.148] - copied ‘...future.FUN’ to environment
[18:02:29.148] - copied ‘future.call.arguments’ to environment
[18:02:29.149] - copied ‘...future.elements_ii’ to environment
[18:02:29.149] - copied ‘...future.seeds_ii’ to environment
[18:02:29.149] - copied ‘...future.globals.maxSize’ to environment
[18:02:29.149] assign_globals() ... done
[18:02:29.150] requestCore(): workers = 2
[18:02:29.167] MulticoreFuture started
[18:02:29.169] - Launch lazy future ... done
[18:02:29.170] plan(): Setting new future strategy stack:
[18:02:29.170] run() for ‘MulticoreFuture’ ... done
[18:02:29.171] Created future:
[18:02:29.170] List of future strategies:
[18:02:29.170] 1. sequential:
[18:02:29.170]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:29.170]    - tweaked: FALSE
[18:02:29.170]    - call: NULL
[18:02:29.173] plan(): nbrOfWorkers() = 1
[18:02:29.178] plan(): Setting new future strategy stack:
[18:02:29.178] List of future strategies:
[18:02:29.178] 1. multicore:
[18:02:29.178]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:29.178]    - tweaked: FALSE
[18:02:29.178]    - call: plan(strategy)
[18:02:29.171] MulticoreFuture:
[18:02:29.171] Label: ‘future_lapply-2’
[18:02:29.171] Expression:
[18:02:29.171] {
[18:02:29.171]     do.call(function(...) {
[18:02:29.171]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:29.171]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:29.171]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:29.171]             on.exit(options(oopts), add = TRUE)
[18:02:29.171]         }
[18:02:29.171]         {
[18:02:29.171]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:29.171]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:29.171]                 ...future.FUN(...future.X_jj, ...)
[18:02:29.171]             })
[18:02:29.171]         }
[18:02:29.171]     }, args = future.call.arguments)
[18:02:29.171] }
[18:02:29.171] Lazy evaluation: FALSE
[18:02:29.171] Asynchronous evaluation: TRUE
[18:02:29.171] Local evaluation: TRUE
[18:02:29.171] Environment: R_GlobalEnv
[18:02:29.171] Capture standard output: FALSE
[18:02:29.171] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:29.171] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:29.171] Packages: <none>
[18:02:29.171] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:29.171] Resolved: FALSE
[18:02:29.171] Value: <not collected>
[18:02:29.171] Conditions captured: <none>
[18:02:29.171] Early signaling: FALSE
[18:02:29.171] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:29.171] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:29.187] Chunk #2 of 2 ... DONE
[18:02:29.187] Launching 2 futures (chunks) ... DONE
[18:02:29.188] Resolving 2 futures (chunks) ...
[18:02:29.188] resolve() on list ...
[18:02:29.189]  recursive: 0
[18:02:29.189] plan(): nbrOfWorkers() = 2
[18:02:29.189]  length: 2
[18:02:29.189] 
[18:02:29.201] Future #2
[18:02:29.202] result() for MulticoreFuture ...
[18:02:29.206] result() for MulticoreFuture ...
[18:02:29.207] result() for MulticoreFuture ... done
[18:02:29.207] result() for MulticoreFuture ... done
[18:02:29.208] result() for MulticoreFuture ...
[18:02:29.208] result() for MulticoreFuture ... done
[18:02:29.208] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:02:29.209] - nx: 2
[18:02:29.209] - relay: TRUE
[18:02:29.209] - stdout: TRUE
[18:02:29.209] - signal: TRUE
[18:02:29.210] - resignal: FALSE
[18:02:29.210] - force: TRUE
[18:02:29.210] - relayed: [n=2] FALSE, FALSE
[18:02:29.210] - queued futures: [n=2] FALSE, FALSE
[18:02:29.211]  - until=1
[18:02:29.211]  - relaying element #1
[18:02:29.211] - relayed: [n=2] FALSE, FALSE
[18:02:29.211] - queued futures: [n=2] FALSE, TRUE
[18:02:29.212] signalConditionsASAP(NULL, pos=2) ... done
[18:02:29.212]  length: 1 (resolved future 2)
[18:02:29.581] plan(): Setting new future strategy stack:
[18:02:29.582] List of future strategies:
[18:02:29.582] 1. multicore:
[18:02:29.582]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:29.582]    - tweaked: FALSE
[18:02:29.582]    - call: plan(strategy)
[18:02:29.592] plan(): nbrOfWorkers() = 2
[18:02:29.597] Future #1
[18:02:29.597] result() for MulticoreFuture ...
[18:02:29.598] result() for MulticoreFuture ...
[18:02:29.599] result() for MulticoreFuture ... done
[18:02:29.599] result() for MulticoreFuture ... done
[18:02:29.599] result() for MulticoreFuture ...
[18:02:29.603] result() for MulticoreFuture ... done
[18:02:29.603] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:02:29.604] - nx: 2
[18:02:29.604] - relay: TRUE
[18:02:29.604] - stdout: TRUE
[18:02:29.604] - signal: TRUE
[18:02:29.605] - resignal: FALSE
[18:02:29.605] - force: TRUE
[18:02:29.605] - relayed: [n=2] FALSE, FALSE
[18:02:29.605] - queued futures: [n=2] FALSE, TRUE
[18:02:29.606]  - until=1
[18:02:29.606]  - relaying element #1
[18:02:29.606] result() for MulticoreFuture ...
[18:02:29.606] result() for MulticoreFuture ... done
[18:02:29.606] result() for MulticoreFuture ...
[18:02:29.607] result() for MulticoreFuture ... done
[18:02:29.607] result() for MulticoreFuture ...
[18:02:29.607] result() for MulticoreFuture ... done
[18:02:29.607] result() for MulticoreFuture ...
[18:02:29.608] result() for MulticoreFuture ... done
[18:02:29.608] - relayed: [n=2] TRUE, FALSE
[18:02:29.608] - queued futures: [n=2] TRUE, TRUE
[18:02:29.608] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:02:29.609]  length: 0 (resolved future 1)
[18:02:29.609] Relaying remaining futures
[18:02:29.609] signalConditionsASAP(NULL, pos=0) ...
[18:02:29.609] - nx: 2
[18:02:29.610] - relay: TRUE
[18:02:29.610] - stdout: TRUE
[18:02:29.610] - signal: TRUE
[18:02:29.610] - resignal: FALSE
[18:02:29.610] - force: TRUE
[18:02:29.611] - relayed: [n=2] TRUE, FALSE
[18:02:29.611] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:29.611]  - relaying element #2
[18:02:29.612] result() for MulticoreFuture ...
[18:02:29.612] result() for MulticoreFuture ... done
[18:02:29.612] result() for MulticoreFuture ...
[18:02:29.612] result() for MulticoreFuture ... done
[18:02:29.613] result() for MulticoreFuture ...
[18:02:29.613] result() for MulticoreFuture ... done
[18:02:29.613] result() for MulticoreFuture ...
[18:02:29.613] result() for MulticoreFuture ... done
[18:02:29.614] - relayed: [n=2] TRUE, TRUE
[18:02:29.614] - queued futures: [n=2] TRUE, TRUE
[18:02:29.614] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[18:02:29.614] resolve() on list ... DONE
[18:02:29.615] result() for MulticoreFuture ...
[18:02:29.615] result() for MulticoreFuture ... done
[18:02:29.615] result() for MulticoreFuture ...
[18:02:29.615] result() for MulticoreFuture ... done
[18:02:29.616] result() for MulticoreFuture ...
[18:02:29.616] result() for MulticoreFuture ... done
[18:02:29.616] result() for MulticoreFuture ...
[18:02:29.616] result() for MulticoreFuture ... done
[18:02:29.617]  - Number of value chunks collected: 2
[18:02:29.617] Resolving 2 futures (chunks) ... DONE
[18:02:29.617] Reducing values from 2 chunks ...
[18:02:29.617]  - Number of values collected after concatenation: 2
[18:02:29.617]  - Number of values expected: 2
[18:02:29.618] Reducing values from 2 chunks ... DONE
[18:02:29.618] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[18:02:29.619] future_lapply() ...
[18:02:29.628] Number of chunks: 2
[18:02:29.628] getGlobalsAndPackagesXApply() ...
[18:02:29.629]  - future.globals: TRUE
[18:02:29.629] getGlobalsAndPackages() ...
[18:02:29.629] Searching for globals...
[18:02:29.633] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:29.633] Searching for globals ... DONE
[18:02:29.634] Resolving globals: FALSE
[18:02:29.635] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:29.636] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:29.637] - globals: [1] ‘FUN’
[18:02:29.637] 
[18:02:29.637] getGlobalsAndPackages() ... DONE
[18:02:29.637]  - globals found/used: [n=1] ‘FUN’
[18:02:29.638]  - needed namespaces: [n=0] 
[18:02:29.638] Finding globals ... DONE
[18:02:29.638]  - use_args: TRUE
[18:02:29.638]  - Getting '...' globals ...
[18:02:29.639] resolve() on list ...
[18:02:29.640]  recursive: 0
[18:02:29.640]  length: 1
[18:02:29.640]  elements: ‘...’
[18:02:29.640]  length: 0 (resolved future 1)
[18:02:29.641] resolve() on list ... DONE
[18:02:29.641]    - '...' content: [n=0] 
[18:02:29.641] List of 1
[18:02:29.641]  $ ...: list()
[18:02:29.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:29.641]  - attr(*, "where")=List of 1
[18:02:29.641]   ..$ ...:<environment: 0x5e4f851ead20> 
[18:02:29.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:29.641]  - attr(*, "resolved")= logi TRUE
[18:02:29.641]  - attr(*, "total_size")= num NA
[18:02:29.651]  - Getting '...' globals ... DONE
[18:02:29.651] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:29.651] List of 2
[18:02:29.651]  $ ...future.FUN:function (x)  
[18:02:29.651]  $ ...          : list()
[18:02:29.651]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:29.651]  - attr(*, "where")=List of 2
[18:02:29.651]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:29.651]   ..$ ...          :<environment: 0x5e4f851ead20> 
[18:02:29.651]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:29.651]  - attr(*, "resolved")= logi FALSE
[18:02:29.651]  - attr(*, "total_size")= num 4720
[18:02:29.658] Packages to be attached in all futures: [n=0] 
[18:02:29.658] getGlobalsAndPackagesXApply() ... DONE
[18:02:29.658] Number of futures (= number of chunks): 2
[18:02:29.659] Launching 2 futures (chunks) ...
[18:02:29.659] Chunk #1 of 2 ...
[18:02:29.659]  - Finding globals in 'X' for chunk #1 ...
[18:02:29.659] getGlobalsAndPackages() ...
[18:02:29.659] Searching for globals...
[18:02:29.660] 
[18:02:29.660] Searching for globals ... DONE
[18:02:29.661] - globals: [0] <none>
[18:02:29.661] getGlobalsAndPackages() ... DONE
[18:02:29.661]    + additional globals found: [n=0] 
[18:02:29.661]    + additional namespaces needed: [n=0] 
[18:02:29.661]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:29.662]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:29.662]  - seeds: <none>
[18:02:29.662]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:29.662] getGlobalsAndPackages() ...
[18:02:29.662] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:29.663] Resolving globals: FALSE
[18:02:29.663] Tweak future expression to call with '...' arguments ...
[18:02:29.663] {
[18:02:29.663]     do.call(function(...) {
[18:02:29.663]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:29.663]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:29.663]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:29.663]             on.exit(options(oopts), add = TRUE)
[18:02:29.663]         }
[18:02:29.663]         {
[18:02:29.663]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:29.663]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:29.663]                 ...future.FUN(...future.X_jj, ...)
[18:02:29.663]             })
[18:02:29.663]         }
[18:02:29.663]     }, args = future.call.arguments)
[18:02:29.663] }
[18:02:29.664] Tweak future expression to call with '...' arguments ... DONE
[18:02:29.664] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:29.665] 
[18:02:29.665] getGlobalsAndPackages() ... DONE
[18:02:29.666] run() for ‘Future’ ...
[18:02:29.666] - state: ‘created’
[18:02:29.666] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:29.673] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:29.673] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:29.673]   - Field: ‘label’
[18:02:29.674]   - Field: ‘local’
[18:02:29.674]   - Field: ‘owner’
[18:02:29.675]   - Field: ‘envir’
[18:02:29.675]   - Field: ‘workers’
[18:02:29.675]   - Field: ‘packages’
[18:02:29.675]   - Field: ‘gc’
[18:02:29.676]   - Field: ‘job’
[18:02:29.676]   - Field: ‘conditions’
[18:02:29.676]   - Field: ‘expr’
[18:02:29.676]   - Field: ‘uuid’
[18:02:29.677]   - Field: ‘seed’
[18:02:29.677]   - Field: ‘version’
[18:02:29.678]   - Field: ‘result’
[18:02:29.678]   - Field: ‘asynchronous’
[18:02:29.678]   - Field: ‘calls’
[18:02:29.678]   - Field: ‘globals’
[18:02:29.679]   - Field: ‘stdout’
[18:02:29.679]   - Field: ‘earlySignal’
[18:02:29.679]   - Field: ‘lazy’
[18:02:29.679]   - Field: ‘state’
[18:02:29.680] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:29.680] - Launch lazy future ...
[18:02:29.681] Packages needed by the future expression (n = 0): <none>
[18:02:29.682] Packages needed by future strategies (n = 0): <none>
[18:02:29.683] {
[18:02:29.683]     {
[18:02:29.683]         {
[18:02:29.683]             ...future.startTime <- base::Sys.time()
[18:02:29.683]             {
[18:02:29.683]                 {
[18:02:29.683]                   {
[18:02:29.683]                     {
[18:02:29.683]                       base::local({
[18:02:29.683]                         has_future <- base::requireNamespace("future", 
[18:02:29.683]                           quietly = TRUE)
[18:02:29.683]                         if (has_future) {
[18:02:29.683]                           ns <- base::getNamespace("future")
[18:02:29.683]                           version <- ns[[".package"]][["version"]]
[18:02:29.683]                           if (is.null(version)) 
[18:02:29.683]                             version <- utils::packageVersion("future")
[18:02:29.683]                         }
[18:02:29.683]                         else {
[18:02:29.683]                           version <- NULL
[18:02:29.683]                         }
[18:02:29.683]                         if (!has_future || version < "1.8.0") {
[18:02:29.683]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:29.683]                             "", base::R.version$version.string), 
[18:02:29.683]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:29.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:29.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:29.683]                               "release", "version")], collapse = " "), 
[18:02:29.683]                             hostname = base::Sys.info()[["nodename"]])
[18:02:29.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:29.683]                             info)
[18:02:29.683]                           info <- base::paste(info, collapse = "; ")
[18:02:29.683]                           if (!has_future) {
[18:02:29.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:29.683]                               info)
[18:02:29.683]                           }
[18:02:29.683]                           else {
[18:02:29.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:29.683]                               info, version)
[18:02:29.683]                           }
[18:02:29.683]                           base::stop(msg)
[18:02:29.683]                         }
[18:02:29.683]                       })
[18:02:29.683]                     }
[18:02:29.683]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:29.683]                     base::options(mc.cores = 1L)
[18:02:29.683]                   }
[18:02:29.683]                   ...future.strategy.old <- future::plan("list")
[18:02:29.683]                   options(future.plan = NULL)
[18:02:29.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:29.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:29.683]                 }
[18:02:29.683]                 ...future.workdir <- getwd()
[18:02:29.683]             }
[18:02:29.683]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:29.683]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:29.683]         }
[18:02:29.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:29.683]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:29.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:29.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:29.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:29.683]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:29.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:29.683]             base::names(...future.oldOptions))
[18:02:29.683]     }
[18:02:29.683]     if (FALSE) {
[18:02:29.683]     }
[18:02:29.683]     else {
[18:02:29.683]         if (TRUE) {
[18:02:29.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:29.683]                 open = "w")
[18:02:29.683]         }
[18:02:29.683]         else {
[18:02:29.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:29.683]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:29.683]         }
[18:02:29.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:29.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:29.683]             base::sink(type = "output", split = FALSE)
[18:02:29.683]             base::close(...future.stdout)
[18:02:29.683]         }, add = TRUE)
[18:02:29.683]     }
[18:02:29.683]     ...future.frame <- base::sys.nframe()
[18:02:29.683]     ...future.conditions <- base::list()
[18:02:29.683]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:29.683]     if (FALSE) {
[18:02:29.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:29.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:29.683]     }
[18:02:29.683]     ...future.result <- base::tryCatch({
[18:02:29.683]         base::withCallingHandlers({
[18:02:29.683]             ...future.value <- base::withVisible(base::local({
[18:02:29.683]                 withCallingHandlers({
[18:02:29.683]                   {
[18:02:29.683]                     do.call(function(...) {
[18:02:29.683]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:29.683]                       if (!identical(...future.globals.maxSize.org, 
[18:02:29.683]                         ...future.globals.maxSize)) {
[18:02:29.683]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:29.683]                         on.exit(options(oopts), add = TRUE)
[18:02:29.683]                       }
[18:02:29.683]                       {
[18:02:29.683]                         lapply(seq_along(...future.elements_ii), 
[18:02:29.683]                           FUN = function(jj) {
[18:02:29.683]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:29.683]                             ...future.FUN(...future.X_jj, ...)
[18:02:29.683]                           })
[18:02:29.683]                       }
[18:02:29.683]                     }, args = future.call.arguments)
[18:02:29.683]                   }
[18:02:29.683]                 }, immediateCondition = function(cond) {
[18:02:29.683]                   save_rds <- function (object, pathname, ...) 
[18:02:29.683]                   {
[18:02:29.683]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:29.683]                     if (file_test("-f", pathname_tmp)) {
[18:02:29.683]                       fi_tmp <- file.info(pathname_tmp)
[18:02:29.683]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:29.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:29.683]                         fi_tmp[["mtime"]])
[18:02:29.683]                     }
[18:02:29.683]                     tryCatch({
[18:02:29.683]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:29.683]                     }, error = function(ex) {
[18:02:29.683]                       msg <- conditionMessage(ex)
[18:02:29.683]                       fi_tmp <- file.info(pathname_tmp)
[18:02:29.683]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:29.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:29.683]                         fi_tmp[["mtime"]], msg)
[18:02:29.683]                       ex$message <- msg
[18:02:29.683]                       stop(ex)
[18:02:29.683]                     })
[18:02:29.683]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:29.683]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:29.683]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:29.683]                       fi_tmp <- file.info(pathname_tmp)
[18:02:29.683]                       fi <- file.info(pathname)
[18:02:29.683]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:29.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:29.683]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:29.683]                         fi[["size"]], fi[["mtime"]])
[18:02:29.683]                       stop(msg)
[18:02:29.683]                     }
[18:02:29.683]                     invisible(pathname)
[18:02:29.683]                   }
[18:02:29.683]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:29.683]                     rootPath = tempdir()) 
[18:02:29.683]                   {
[18:02:29.683]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:29.683]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:29.683]                       tmpdir = path, fileext = ".rds")
[18:02:29.683]                     save_rds(obj, file)
[18:02:29.683]                   }
[18:02:29.683]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1j8FfD/.future/immediateConditions")
[18:02:29.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:29.683]                   {
[18:02:29.683]                     inherits <- base::inherits
[18:02:29.683]                     invokeRestart <- base::invokeRestart
[18:02:29.683]                     is.null <- base::is.null
[18:02:29.683]                     muffled <- FALSE
[18:02:29.683]                     if (inherits(cond, "message")) {
[18:02:29.683]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:29.683]                       if (muffled) 
[18:02:29.683]                         invokeRestart("muffleMessage")
[18:02:29.683]                     }
[18:02:29.683]                     else if (inherits(cond, "warning")) {
[18:02:29.683]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:29.683]                       if (muffled) 
[18:02:29.683]                         invokeRestart("muffleWarning")
[18:02:29.683]                     }
[18:02:29.683]                     else if (inherits(cond, "condition")) {
[18:02:29.683]                       if (!is.null(pattern)) {
[18:02:29.683]                         computeRestarts <- base::computeRestarts
[18:02:29.683]                         grepl <- base::grepl
[18:02:29.683]                         restarts <- computeRestarts(cond)
[18:02:29.683]                         for (restart in restarts) {
[18:02:29.683]                           name <- restart$name
[18:02:29.683]                           if (is.null(name)) 
[18:02:29.683]                             next
[18:02:29.683]                           if (!grepl(pattern, name)) 
[18:02:29.683]                             next
[18:02:29.683]                           invokeRestart(restart)
[18:02:29.683]                           muffled <- TRUE
[18:02:29.683]                           break
[18:02:29.683]                         }
[18:02:29.683]                       }
[18:02:29.683]                     }
[18:02:29.683]                     invisible(muffled)
[18:02:29.683]                   }
[18:02:29.683]                   muffleCondition(cond)
[18:02:29.683]                 })
[18:02:29.683]             }))
[18:02:29.683]             future::FutureResult(value = ...future.value$value, 
[18:02:29.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:29.683]                   ...future.rng), globalenv = if (FALSE) 
[18:02:29.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:29.683]                     ...future.globalenv.names))
[18:02:29.683]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:29.683]         }, condition = base::local({
[18:02:29.683]             c <- base::c
[18:02:29.683]             inherits <- base::inherits
[18:02:29.683]             invokeRestart <- base::invokeRestart
[18:02:29.683]             length <- base::length
[18:02:29.683]             list <- base::list
[18:02:29.683]             seq.int <- base::seq.int
[18:02:29.683]             signalCondition <- base::signalCondition
[18:02:29.683]             sys.calls <- base::sys.calls
[18:02:29.683]             `[[` <- base::`[[`
[18:02:29.683]             `+` <- base::`+`
[18:02:29.683]             `<<-` <- base::`<<-`
[18:02:29.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:29.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:29.683]                   3L)]
[18:02:29.683]             }
[18:02:29.683]             function(cond) {
[18:02:29.683]                 is_error <- inherits(cond, "error")
[18:02:29.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:29.683]                   NULL)
[18:02:29.683]                 if (is_error) {
[18:02:29.683]                   sessionInformation <- function() {
[18:02:29.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:29.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:29.683]                       search = base::search(), system = base::Sys.info())
[18:02:29.683]                   }
[18:02:29.683]                   ...future.conditions[[length(...future.conditions) + 
[18:02:29.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:29.683]                     cond$call), session = sessionInformation(), 
[18:02:29.683]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:29.683]                   signalCondition(cond)
[18:02:29.683]                 }
[18:02:29.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:29.683]                 "immediateCondition"))) {
[18:02:29.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:29.683]                   ...future.conditions[[length(...future.conditions) + 
[18:02:29.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:29.683]                   if (TRUE && !signal) {
[18:02:29.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:29.683]                     {
[18:02:29.683]                       inherits <- base::inherits
[18:02:29.683]                       invokeRestart <- base::invokeRestart
[18:02:29.683]                       is.null <- base::is.null
[18:02:29.683]                       muffled <- FALSE
[18:02:29.683]                       if (inherits(cond, "message")) {
[18:02:29.683]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:29.683]                         if (muffled) 
[18:02:29.683]                           invokeRestart("muffleMessage")
[18:02:29.683]                       }
[18:02:29.683]                       else if (inherits(cond, "warning")) {
[18:02:29.683]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:29.683]                         if (muffled) 
[18:02:29.683]                           invokeRestart("muffleWarning")
[18:02:29.683]                       }
[18:02:29.683]                       else if (inherits(cond, "condition")) {
[18:02:29.683]                         if (!is.null(pattern)) {
[18:02:29.683]                           computeRestarts <- base::computeRestarts
[18:02:29.683]                           grepl <- base::grepl
[18:02:29.683]                           restarts <- computeRestarts(cond)
[18:02:29.683]                           for (restart in restarts) {
[18:02:29.683]                             name <- restart$name
[18:02:29.683]                             if (is.null(name)) 
[18:02:29.683]                               next
[18:02:29.683]                             if (!grepl(pattern, name)) 
[18:02:29.683]                               next
[18:02:29.683]                             invokeRestart(restart)
[18:02:29.683]                             muffled <- TRUE
[18:02:29.683]                             break
[18:02:29.683]                           }
[18:02:29.683]                         }
[18:02:29.683]                       }
[18:02:29.683]                       invisible(muffled)
[18:02:29.683]                     }
[18:02:29.683]                     muffleCondition(cond, pattern = "^muffle")
[18:02:29.683]                   }
[18:02:29.683]                 }
[18:02:29.683]                 else {
[18:02:29.683]                   if (TRUE) {
[18:02:29.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:29.683]                     {
[18:02:29.683]                       inherits <- base::inherits
[18:02:29.683]                       invokeRestart <- base::invokeRestart
[18:02:29.683]                       is.null <- base::is.null
[18:02:29.683]                       muffled <- FALSE
[18:02:29.683]                       if (inherits(cond, "message")) {
[18:02:29.683]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:29.683]                         if (muffled) 
[18:02:29.683]                           invokeRestart("muffleMessage")
[18:02:29.683]                       }
[18:02:29.683]                       else if (inherits(cond, "warning")) {
[18:02:29.683]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:29.683]                         if (muffled) 
[18:02:29.683]                           invokeRestart("muffleWarning")
[18:02:29.683]                       }
[18:02:29.683]                       else if (inherits(cond, "condition")) {
[18:02:29.683]                         if (!is.null(pattern)) {
[18:02:29.683]                           computeRestarts <- base::computeRestarts
[18:02:29.683]                           grepl <- base::grepl
[18:02:29.683]                           restarts <- computeRestarts(cond)
[18:02:29.683]                           for (restart in restarts) {
[18:02:29.683]                             name <- restart$name
[18:02:29.683]                             if (is.null(name)) 
[18:02:29.683]                               next
[18:02:29.683]                             if (!grepl(pattern, name)) 
[18:02:29.683]                               next
[18:02:29.683]                             invokeRestart(restart)
[18:02:29.683]                             muffled <- TRUE
[18:02:29.683]                             break
[18:02:29.683]                           }
[18:02:29.683]                         }
[18:02:29.683]                       }
[18:02:29.683]                       invisible(muffled)
[18:02:29.683]                     }
[18:02:29.683]                     muffleCondition(cond, pattern = "^muffle")
[18:02:29.683]                   }
[18:02:29.683]                 }
[18:02:29.683]             }
[18:02:29.683]         }))
[18:02:29.683]     }, error = function(ex) {
[18:02:29.683]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:29.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:29.683]                 ...future.rng), started = ...future.startTime, 
[18:02:29.683]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:29.683]             version = "1.8"), class = "FutureResult")
[18:02:29.683]     }, finally = {
[18:02:29.683]         if (!identical(...future.workdir, getwd())) 
[18:02:29.683]             setwd(...future.workdir)
[18:02:29.683]         {
[18:02:29.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:29.683]                 ...future.oldOptions$nwarnings <- NULL
[18:02:29.683]             }
[18:02:29.683]             base::options(...future.oldOptions)
[18:02:29.683]             if (.Platform$OS.type == "windows") {
[18:02:29.683]                 old_names <- names(...future.oldEnvVars)
[18:02:29.683]                 envs <- base::Sys.getenv()
[18:02:29.683]                 names <- names(envs)
[18:02:29.683]                 common <- intersect(names, old_names)
[18:02:29.683]                 added <- setdiff(names, old_names)
[18:02:29.683]                 removed <- setdiff(old_names, names)
[18:02:29.683]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:29.683]                   envs[common]]
[18:02:29.683]                 NAMES <- toupper(changed)
[18:02:29.683]                 args <- list()
[18:02:29.683]                 for (kk in seq_along(NAMES)) {
[18:02:29.683]                   name <- changed[[kk]]
[18:02:29.683]                   NAME <- NAMES[[kk]]
[18:02:29.683]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:29.683]                     next
[18:02:29.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:29.683]                 }
[18:02:29.683]                 NAMES <- toupper(added)
[18:02:29.683]                 for (kk in seq_along(NAMES)) {
[18:02:29.683]                   name <- added[[kk]]
[18:02:29.683]                   NAME <- NAMES[[kk]]
[18:02:29.683]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:29.683]                     next
[18:02:29.683]                   args[[name]] <- ""
[18:02:29.683]                 }
[18:02:29.683]                 NAMES <- toupper(removed)
[18:02:29.683]                 for (kk in seq_along(NAMES)) {
[18:02:29.683]                   name <- removed[[kk]]
[18:02:29.683]                   NAME <- NAMES[[kk]]
[18:02:29.683]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:29.683]                     next
[18:02:29.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:29.683]                 }
[18:02:29.683]                 if (length(args) > 0) 
[18:02:29.683]                   base::do.call(base::Sys.setenv, args = args)
[18:02:29.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:29.683]             }
[18:02:29.683]             else {
[18:02:29.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:29.683]             }
[18:02:29.683]             {
[18:02:29.683]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:29.683]                   0L) {
[18:02:29.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:29.683]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:29.683]                   base::options(opts)
[18:02:29.683]                 }
[18:02:29.683]                 {
[18:02:29.683]                   {
[18:02:29.683]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:29.683]                     NULL
[18:02:29.683]                   }
[18:02:29.683]                   options(future.plan = NULL)
[18:02:29.683]                   if (is.na(NA_character_)) 
[18:02:29.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:29.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:29.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:29.683]                     .init = FALSE)
[18:02:29.683]                 }
[18:02:29.683]             }
[18:02:29.683]         }
[18:02:29.683]     })
[18:02:29.683]     if (TRUE) {
[18:02:29.683]         base::sink(type = "output", split = FALSE)
[18:02:29.683]         if (TRUE) {
[18:02:29.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:29.683]         }
[18:02:29.683]         else {
[18:02:29.683]             ...future.result["stdout"] <- base::list(NULL)
[18:02:29.683]         }
[18:02:29.683]         base::close(...future.stdout)
[18:02:29.683]         ...future.stdout <- NULL
[18:02:29.683]     }
[18:02:29.683]     ...future.result$conditions <- ...future.conditions
[18:02:29.683]     ...future.result$finished <- base::Sys.time()
[18:02:29.683]     ...future.result
[18:02:29.683] }
[18:02:29.689] assign_globals() ...
[18:02:29.689] List of 5
[18:02:29.689]  $ ...future.FUN            :function (x)  
[18:02:29.689]  $ future.call.arguments    : list()
[18:02:29.689]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:29.689]  $ ...future.elements_ii    :List of 1
[18:02:29.689]   ..$ : int 1
[18:02:29.689]  $ ...future.seeds_ii       : NULL
[18:02:29.689]  $ ...future.globals.maxSize: NULL
[18:02:29.689]  - attr(*, "where")=List of 5
[18:02:29.689]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:29.689]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:29.689]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:29.689]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:29.689]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:29.689]  - attr(*, "resolved")= logi FALSE
[18:02:29.689]  - attr(*, "total_size")= num 4720
[18:02:29.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:29.689]  - attr(*, "already-done")= logi TRUE
[18:02:29.703] - reassign environment for ‘...future.FUN’
[18:02:29.703] - copied ‘...future.FUN’ to environment
[18:02:29.703] - copied ‘future.call.arguments’ to environment
[18:02:29.704] - copied ‘...future.elements_ii’ to environment
[18:02:29.704] - copied ‘...future.seeds_ii’ to environment
[18:02:29.704] - copied ‘...future.globals.maxSize’ to environment
[18:02:29.704] assign_globals() ... done
[18:02:29.705] requestCore(): workers = 2
[18:02:29.708] MulticoreFuture started
[18:02:29.711] - Launch lazy future ... done
[18:02:29.713] plan(): Setting new future strategy stack:
[18:02:29.712] run() for ‘MulticoreFuture’ ... done
[18:02:29.714] Created future:
[18:02:29.713] List of future strategies:
[18:02:29.713] 1. sequential:
[18:02:29.713]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:29.713]    - tweaked: FALSE
[18:02:29.713]    - call: NULL
[18:02:29.719] plan(): nbrOfWorkers() = 1
[18:02:29.715] MulticoreFuture:
[18:02:29.715] Label: ‘future_lapply-1’
[18:02:29.715] Expression:
[18:02:29.715] {
[18:02:29.715]     do.call(function(...) {
[18:02:29.715]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:29.715]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:29.715]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:29.715]             on.exit(options(oopts), add = TRUE)
[18:02:29.715]         }
[18:02:29.715]         {
[18:02:29.715]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:29.715]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:29.715]                 ...future.FUN(...future.X_jj, ...)
[18:02:29.715]             })
[18:02:29.715]         }
[18:02:29.715]     }, args = future.call.arguments)
[18:02:29.715] }
[18:02:29.715] Lazy evaluation: FALSE
[18:02:29.715] Asynchronous evaluation: TRUE
[18:02:29.715] Local evaluation: TRUE
[18:02:29.715] Environment: R_GlobalEnv
[18:02:29.715] Capture standard output: TRUE
[18:02:29.715] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:29.715] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:29.715] Packages: <none>
[18:02:29.715] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:29.715] Resolved: FALSE
[18:02:29.715] Value: <not collected>
[18:02:29.715] Conditions captured: <none>
[18:02:29.715] Early signaling: FALSE
[18:02:29.715] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:29.715] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:29.735] Chunk #1 of 2 ... DONE
[18:02:29.735] Chunk #2 of 2 ...
[18:02:29.736]  - Finding globals in 'X' for chunk #2 ...
[18:02:29.736] getGlobalsAndPackages() ...
[18:02:29.736] Searching for globals...
[18:02:29.738] 
[18:02:29.738] Searching for globals ... DONE
[18:02:29.739] - globals: [0] <none>
[18:02:29.739] getGlobalsAndPackages() ... DONE
[18:02:29.740]    + additional globals found: [n=0] 
[18:02:29.740]    + additional namespaces needed: [n=0] 
[18:02:29.740]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:29.741]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:29.741]  - seeds: <none>
[18:02:29.741]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:29.742] getGlobalsAndPackages() ...
[18:02:29.742] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:29.742] Resolving globals: FALSE
[18:02:29.743] Tweak future expression to call with '...' arguments ...
[18:02:29.743] {
[18:02:29.743]     do.call(function(...) {
[18:02:29.743]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:29.743]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:29.743]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:29.743]             on.exit(options(oopts), add = TRUE)
[18:02:29.743]         }
[18:02:29.743]         {
[18:02:29.743]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:29.743]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:29.743]                 ...future.FUN(...future.X_jj, ...)
[18:02:29.743]             })
[18:02:29.743]         }
[18:02:29.743]     }, args = future.call.arguments)
[18:02:29.743] }
[18:02:29.744] Tweak future expression to call with '...' arguments ... DONE
[18:02:29.751] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:29.752] 
[18:02:29.753] getGlobalsAndPackages() ... DONE
[18:02:29.754] run() for ‘Future’ ...
[18:02:29.755] - state: ‘created’
[18:02:29.756] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:29.767] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:29.768] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:29.768]   - Field: ‘label’
[18:02:29.768]   - Field: ‘local’
[18:02:29.769]   - Field: ‘owner’
[18:02:29.769]   - Field: ‘envir’
[18:02:29.769]   - Field: ‘workers’
[18:02:29.770]   - Field: ‘packages’
[18:02:29.770]   - Field: ‘gc’
[18:02:29.771]   - Field: ‘job’
[18:02:29.771]   - Field: ‘conditions’
[18:02:29.771]   - Field: ‘expr’
[18:02:29.772]   - Field: ‘uuid’
[18:02:29.772]   - Field: ‘seed’
[18:02:29.772]   - Field: ‘version’
[18:02:29.773]   - Field: ‘result’
[18:02:29.773]   - Field: ‘asynchronous’
[18:02:29.774]   - Field: ‘calls’
[18:02:29.774]   - Field: ‘globals’
[18:02:29.774]   - Field: ‘stdout’
[18:02:29.774]   - Field: ‘earlySignal’
[18:02:29.775]   - Field: ‘lazy’
[18:02:29.775]   - Field: ‘state’
[18:02:29.775] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:29.776] - Launch lazy future ...
[18:02:29.777] Packages needed by the future expression (n = 0): <none>
[18:02:29.777] Packages needed by future strategies (n = 0): <none>
[18:02:29.781] {
[18:02:29.781]     {
[18:02:29.781]         {
[18:02:29.781]             ...future.startTime <- base::Sys.time()
[18:02:29.781]             {
[18:02:29.781]                 {
[18:02:29.781]                   {
[18:02:29.781]                     {
[18:02:29.781]                       base::local({
[18:02:29.781]                         has_future <- base::requireNamespace("future", 
[18:02:29.781]                           quietly = TRUE)
[18:02:29.781]                         if (has_future) {
[18:02:29.781]                           ns <- base::getNamespace("future")
[18:02:29.781]                           version <- ns[[".package"]][["version"]]
[18:02:29.781]                           if (is.null(version)) 
[18:02:29.781]                             version <- utils::packageVersion("future")
[18:02:29.781]                         }
[18:02:29.781]                         else {
[18:02:29.781]                           version <- NULL
[18:02:29.781]                         }
[18:02:29.781]                         if (!has_future || version < "1.8.0") {
[18:02:29.781]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:29.781]                             "", base::R.version$version.string), 
[18:02:29.781]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:29.781]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:29.781]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:29.781]                               "release", "version")], collapse = " "), 
[18:02:29.781]                             hostname = base::Sys.info()[["nodename"]])
[18:02:29.781]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:29.781]                             info)
[18:02:29.781]                           info <- base::paste(info, collapse = "; ")
[18:02:29.781]                           if (!has_future) {
[18:02:29.781]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:29.781]                               info)
[18:02:29.781]                           }
[18:02:29.781]                           else {
[18:02:29.781]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:29.781]                               info, version)
[18:02:29.781]                           }
[18:02:29.781]                           base::stop(msg)
[18:02:29.781]                         }
[18:02:29.781]                       })
[18:02:29.781]                     }
[18:02:29.781]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:29.781]                     base::options(mc.cores = 1L)
[18:02:29.781]                   }
[18:02:29.781]                   ...future.strategy.old <- future::plan("list")
[18:02:29.781]                   options(future.plan = NULL)
[18:02:29.781]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:29.781]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:29.781]                 }
[18:02:29.781]                 ...future.workdir <- getwd()
[18:02:29.781]             }
[18:02:29.781]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:29.781]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:29.781]         }
[18:02:29.781]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:29.781]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:29.781]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:29.781]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:29.781]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:29.781]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:29.781]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:29.781]             base::names(...future.oldOptions))
[18:02:29.781]     }
[18:02:29.781]     if (FALSE) {
[18:02:29.781]     }
[18:02:29.781]     else {
[18:02:29.781]         if (TRUE) {
[18:02:29.781]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:29.781]                 open = "w")
[18:02:29.781]         }
[18:02:29.781]         else {
[18:02:29.781]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:29.781]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:29.781]         }
[18:02:29.781]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:29.781]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:29.781]             base::sink(type = "output", split = FALSE)
[18:02:29.781]             base::close(...future.stdout)
[18:02:29.781]         }, add = TRUE)
[18:02:29.781]     }
[18:02:29.781]     ...future.frame <- base::sys.nframe()
[18:02:29.781]     ...future.conditions <- base::list()
[18:02:29.781]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:29.781]     if (FALSE) {
[18:02:29.781]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:29.781]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:29.781]     }
[18:02:29.781]     ...future.result <- base::tryCatch({
[18:02:29.781]         base::withCallingHandlers({
[18:02:29.781]             ...future.value <- base::withVisible(base::local({
[18:02:29.781]                 withCallingHandlers({
[18:02:29.781]                   {
[18:02:29.781]                     do.call(function(...) {
[18:02:29.781]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:29.781]                       if (!identical(...future.globals.maxSize.org, 
[18:02:29.781]                         ...future.globals.maxSize)) {
[18:02:29.781]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:29.781]                         on.exit(options(oopts), add = TRUE)
[18:02:29.781]                       }
[18:02:29.781]                       {
[18:02:29.781]                         lapply(seq_along(...future.elements_ii), 
[18:02:29.781]                           FUN = function(jj) {
[18:02:29.781]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:29.781]                             ...future.FUN(...future.X_jj, ...)
[18:02:29.781]                           })
[18:02:29.781]                       }
[18:02:29.781]                     }, args = future.call.arguments)
[18:02:29.781]                   }
[18:02:29.781]                 }, immediateCondition = function(cond) {
[18:02:29.781]                   save_rds <- function (object, pathname, ...) 
[18:02:29.781]                   {
[18:02:29.781]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:29.781]                     if (file_test("-f", pathname_tmp)) {
[18:02:29.781]                       fi_tmp <- file.info(pathname_tmp)
[18:02:29.781]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:29.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:29.781]                         fi_tmp[["mtime"]])
[18:02:29.781]                     }
[18:02:29.781]                     tryCatch({
[18:02:29.781]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:29.781]                     }, error = function(ex) {
[18:02:29.781]                       msg <- conditionMessage(ex)
[18:02:29.781]                       fi_tmp <- file.info(pathname_tmp)
[18:02:29.781]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:29.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:29.781]                         fi_tmp[["mtime"]], msg)
[18:02:29.781]                       ex$message <- msg
[18:02:29.781]                       stop(ex)
[18:02:29.781]                     })
[18:02:29.781]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:29.781]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:29.781]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:29.781]                       fi_tmp <- file.info(pathname_tmp)
[18:02:29.781]                       fi <- file.info(pathname)
[18:02:29.781]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:29.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:29.781]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:29.781]                         fi[["size"]], fi[["mtime"]])
[18:02:29.781]                       stop(msg)
[18:02:29.781]                     }
[18:02:29.781]                     invisible(pathname)
[18:02:29.781]                   }
[18:02:29.781]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:29.781]                     rootPath = tempdir()) 
[18:02:29.781]                   {
[18:02:29.781]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:29.781]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:29.781]                       tmpdir = path, fileext = ".rds")
[18:02:29.781]                     save_rds(obj, file)
[18:02:29.781]                   }
[18:02:29.781]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1j8FfD/.future/immediateConditions")
[18:02:29.781]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:29.781]                   {
[18:02:29.781]                     inherits <- base::inherits
[18:02:29.781]                     invokeRestart <- base::invokeRestart
[18:02:29.781]                     is.null <- base::is.null
[18:02:29.781]                     muffled <- FALSE
[18:02:29.781]                     if (inherits(cond, "message")) {
[18:02:29.781]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:29.781]                       if (muffled) 
[18:02:29.781]                         invokeRestart("muffleMessage")
[18:02:29.781]                     }
[18:02:29.781]                     else if (inherits(cond, "warning")) {
[18:02:29.781]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:29.781]                       if (muffled) 
[18:02:29.781]                         invokeRestart("muffleWarning")
[18:02:29.781]                     }
[18:02:29.781]                     else if (inherits(cond, "condition")) {
[18:02:29.781]                       if (!is.null(pattern)) {
[18:02:29.781]                         computeRestarts <- base::computeRestarts
[18:02:29.781]                         grepl <- base::grepl
[18:02:29.781]                         restarts <- computeRestarts(cond)
[18:02:29.781]                         for (restart in restarts) {
[18:02:29.781]                           name <- restart$name
[18:02:29.781]                           if (is.null(name)) 
[18:02:29.781]                             next
[18:02:29.781]                           if (!grepl(pattern, name)) 
[18:02:29.781]                             next
[18:02:29.781]                           invokeRestart(restart)
[18:02:29.781]                           muffled <- TRUE
[18:02:29.781]                           break
[18:02:29.781]                         }
[18:02:29.781]                       }
[18:02:29.781]                     }
[18:02:29.781]                     invisible(muffled)
[18:02:29.781]                   }
[18:02:29.781]                   muffleCondition(cond)
[18:02:29.781]                 })
[18:02:29.781]             }))
[18:02:29.781]             future::FutureResult(value = ...future.value$value, 
[18:02:29.781]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:29.781]                   ...future.rng), globalenv = if (FALSE) 
[18:02:29.781]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:29.781]                     ...future.globalenv.names))
[18:02:29.781]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:29.781]         }, condition = base::local({
[18:02:29.781]             c <- base::c
[18:02:29.781]             inherits <- base::inherits
[18:02:29.781]             invokeRestart <- base::invokeRestart
[18:02:29.781]             length <- base::length
[18:02:29.781]             list <- base::list
[18:02:29.781]             seq.int <- base::seq.int
[18:02:29.781]             signalCondition <- base::signalCondition
[18:02:29.781]             sys.calls <- base::sys.calls
[18:02:29.781]             `[[` <- base::`[[`
[18:02:29.781]             `+` <- base::`+`
[18:02:29.781]             `<<-` <- base::`<<-`
[18:02:29.781]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:29.781]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:29.781]                   3L)]
[18:02:29.781]             }
[18:02:29.781]             function(cond) {
[18:02:29.781]                 is_error <- inherits(cond, "error")
[18:02:29.781]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:29.781]                   NULL)
[18:02:29.781]                 if (is_error) {
[18:02:29.781]                   sessionInformation <- function() {
[18:02:29.781]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:29.781]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:29.781]                       search = base::search(), system = base::Sys.info())
[18:02:29.781]                   }
[18:02:29.781]                   ...future.conditions[[length(...future.conditions) + 
[18:02:29.781]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:29.781]                     cond$call), session = sessionInformation(), 
[18:02:29.781]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:29.781]                   signalCondition(cond)
[18:02:29.781]                 }
[18:02:29.781]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:29.781]                 "immediateCondition"))) {
[18:02:29.781]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:29.781]                   ...future.conditions[[length(...future.conditions) + 
[18:02:29.781]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:29.781]                   if (TRUE && !signal) {
[18:02:29.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:29.781]                     {
[18:02:29.781]                       inherits <- base::inherits
[18:02:29.781]                       invokeRestart <- base::invokeRestart
[18:02:29.781]                       is.null <- base::is.null
[18:02:29.781]                       muffled <- FALSE
[18:02:29.781]                       if (inherits(cond, "message")) {
[18:02:29.781]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:29.781]                         if (muffled) 
[18:02:29.781]                           invokeRestart("muffleMessage")
[18:02:29.781]                       }
[18:02:29.781]                       else if (inherits(cond, "warning")) {
[18:02:29.781]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:29.781]                         if (muffled) 
[18:02:29.781]                           invokeRestart("muffleWarning")
[18:02:29.781]                       }
[18:02:29.781]                       else if (inherits(cond, "condition")) {
[18:02:29.781]                         if (!is.null(pattern)) {
[18:02:29.781]                           computeRestarts <- base::computeRestarts
[18:02:29.781]                           grepl <- base::grepl
[18:02:29.781]                           restarts <- computeRestarts(cond)
[18:02:29.781]                           for (restart in restarts) {
[18:02:29.781]                             name <- restart$name
[18:02:29.781]                             if (is.null(name)) 
[18:02:29.781]                               next
[18:02:29.781]                             if (!grepl(pattern, name)) 
[18:02:29.781]                               next
[18:02:29.781]                             invokeRestart(restart)
[18:02:29.781]                             muffled <- TRUE
[18:02:29.781]                             break
[18:02:29.781]                           }
[18:02:29.781]                         }
[18:02:29.781]                       }
[18:02:29.781]                       invisible(muffled)
[18:02:29.781]                     }
[18:02:29.781]                     muffleCondition(cond, pattern = "^muffle")
[18:02:29.781]                   }
[18:02:29.781]                 }
[18:02:29.781]                 else {
[18:02:29.781]                   if (TRUE) {
[18:02:29.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:29.781]                     {
[18:02:29.781]                       inherits <- base::inherits
[18:02:29.781]                       invokeRestart <- base::invokeRestart
[18:02:29.781]                       is.null <- base::is.null
[18:02:29.781]                       muffled <- FALSE
[18:02:29.781]                       if (inherits(cond, "message")) {
[18:02:29.781]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:29.781]                         if (muffled) 
[18:02:29.781]                           invokeRestart("muffleMessage")
[18:02:29.781]                       }
[18:02:29.781]                       else if (inherits(cond, "warning")) {
[18:02:29.781]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:29.781]                         if (muffled) 
[18:02:29.781]                           invokeRestart("muffleWarning")
[18:02:29.781]                       }
[18:02:29.781]                       else if (inherits(cond, "condition")) {
[18:02:29.781]                         if (!is.null(pattern)) {
[18:02:29.781]                           computeRestarts <- base::computeRestarts
[18:02:29.781]                           grepl <- base::grepl
[18:02:29.781]                           restarts <- computeRestarts(cond)
[18:02:29.781]                           for (restart in restarts) {
[18:02:29.781]                             name <- restart$name
[18:02:29.781]                             if (is.null(name)) 
[18:02:29.781]                               next
[18:02:29.781]                             if (!grepl(pattern, name)) 
[18:02:29.781]                               next
[18:02:29.781]                             invokeRestart(restart)
[18:02:29.781]                             muffled <- TRUE
[18:02:29.781]                             break
[18:02:29.781]                           }
[18:02:29.781]                         }
[18:02:29.781]                       }
[18:02:29.781]                       invisible(muffled)
[18:02:29.781]                     }
[18:02:29.781]                     muffleCondition(cond, pattern = "^muffle")
[18:02:29.781]                   }
[18:02:29.781]                 }
[18:02:29.781]             }
[18:02:29.781]         }))
[18:02:29.781]     }, error = function(ex) {
[18:02:29.781]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:29.781]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:29.781]                 ...future.rng), started = ...future.startTime, 
[18:02:29.781]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:29.781]             version = "1.8"), class = "FutureResult")
[18:02:29.781]     }, finally = {
[18:02:29.781]         if (!identical(...future.workdir, getwd())) 
[18:02:29.781]             setwd(...future.workdir)
[18:02:29.781]         {
[18:02:29.781]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:29.781]                 ...future.oldOptions$nwarnings <- NULL
[18:02:29.781]             }
[18:02:29.781]             base::options(...future.oldOptions)
[18:02:29.781]             if (.Platform$OS.type == "windows") {
[18:02:29.781]                 old_names <- names(...future.oldEnvVars)
[18:02:29.781]                 envs <- base::Sys.getenv()
[18:02:29.781]                 names <- names(envs)
[18:02:29.781]                 common <- intersect(names, old_names)
[18:02:29.781]                 added <- setdiff(names, old_names)
[18:02:29.781]                 removed <- setdiff(old_names, names)
[18:02:29.781]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:29.781]                   envs[common]]
[18:02:29.781]                 NAMES <- toupper(changed)
[18:02:29.781]                 args <- list()
[18:02:29.781]                 for (kk in seq_along(NAMES)) {
[18:02:29.781]                   name <- changed[[kk]]
[18:02:29.781]                   NAME <- NAMES[[kk]]
[18:02:29.781]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:29.781]                     next
[18:02:29.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:29.781]                 }
[18:02:29.781]                 NAMES <- toupper(added)
[18:02:29.781]                 for (kk in seq_along(NAMES)) {
[18:02:29.781]                   name <- added[[kk]]
[18:02:29.781]                   NAME <- NAMES[[kk]]
[18:02:29.781]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:29.781]                     next
[18:02:29.781]                   args[[name]] <- ""
[18:02:29.781]                 }
[18:02:29.781]                 NAMES <- toupper(removed)
[18:02:29.781]                 for (kk in seq_along(NAMES)) {
[18:02:29.781]                   name <- removed[[kk]]
[18:02:29.781]                   NAME <- NAMES[[kk]]
[18:02:29.781]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:29.781]                     next
[18:02:29.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:29.781]                 }
[18:02:29.781]                 if (length(args) > 0) 
[18:02:29.781]                   base::do.call(base::Sys.setenv, args = args)
[18:02:29.781]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:29.781]             }
[18:02:29.781]             else {
[18:02:29.781]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:29.781]             }
[18:02:29.781]             {
[18:02:29.781]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:29.781]                   0L) {
[18:02:29.781]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:29.781]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:29.781]                   base::options(opts)
[18:02:29.781]                 }
[18:02:29.781]                 {
[18:02:29.781]                   {
[18:02:29.781]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:29.781]                     NULL
[18:02:29.781]                   }
[18:02:29.781]                   options(future.plan = NULL)
[18:02:29.781]                   if (is.na(NA_character_)) 
[18:02:29.781]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:29.781]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:29.781]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:29.781]                     .init = FALSE)
[18:02:29.781]                 }
[18:02:29.781]             }
[18:02:29.781]         }
[18:02:29.781]     })
[18:02:29.781]     if (TRUE) {
[18:02:29.781]         base::sink(type = "output", split = FALSE)
[18:02:29.781]         if (TRUE) {
[18:02:29.781]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:29.781]         }
[18:02:29.781]         else {
[18:02:29.781]             ...future.result["stdout"] <- base::list(NULL)
[18:02:29.781]         }
[18:02:29.781]         base::close(...future.stdout)
[18:02:29.781]         ...future.stdout <- NULL
[18:02:29.781]     }
[18:02:29.781]     ...future.result$conditions <- ...future.conditions
[18:02:29.781]     ...future.result$finished <- base::Sys.time()
[18:02:29.781]     ...future.result
[18:02:29.781] }
[18:02:29.787] assign_globals() ...
[18:02:29.787] List of 5
[18:02:29.787]  $ ...future.FUN            :function (x)  
[18:02:29.787]  $ future.call.arguments    : list()
[18:02:29.787]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:29.787]  $ ...future.elements_ii    :List of 1
[18:02:29.787]   ..$ : int 0
[18:02:29.787]  $ ...future.seeds_ii       : NULL
[18:02:29.787]  $ ...future.globals.maxSize: NULL
[18:02:29.787]  - attr(*, "where")=List of 5
[18:02:29.787]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:29.787]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:29.787]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:29.787]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:29.787]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:29.787]  - attr(*, "resolved")= logi FALSE
[18:02:29.787]  - attr(*, "total_size")= num 4720
[18:02:29.787]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:29.787]  - attr(*, "already-done")= logi TRUE
[18:02:29.801] - reassign environment for ‘...future.FUN’
[18:02:29.802] - copied ‘...future.FUN’ to environment
[18:02:29.802] - copied ‘future.call.arguments’ to environment
[18:02:29.802] - copied ‘...future.elements_ii’ to environment
[18:02:29.803] - copied ‘...future.seeds_ii’ to environment
[18:02:29.803] - copied ‘...future.globals.maxSize’ to environment
[18:02:29.803] assign_globals() ... done
[18:02:29.804] requestCore(): workers = 2
[18:02:29.808] MulticoreFuture started
[18:02:29.809] - Launch lazy future ... done
[18:02:29.810] run() for ‘MulticoreFuture’ ... done
[18:02:29.813] plan(): Setting new future strategy stack:
[18:02:29.811] Created future:
[18:02:29.813] List of future strategies:
[18:02:29.813] 1. sequential:
[18:02:29.813]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:29.813]    - tweaked: FALSE
[18:02:29.813]    - call: NULL
[18:02:29.818] plan(): nbrOfWorkers() = 1
[18:02:29.822] plan(): Setting new future strategy stack:
[18:02:29.822] List of future strategies:
[18:02:29.822] 1. multicore:
[18:02:29.822]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:29.822]    - tweaked: FALSE
[18:02:29.822]    - call: plan(strategy)
[18:02:29.814] MulticoreFuture:
[18:02:29.814] Label: ‘future_lapply-2’
[18:02:29.814] Expression:
[18:02:29.814] {
[18:02:29.814]     do.call(function(...) {
[18:02:29.814]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:29.814]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:29.814]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:29.814]             on.exit(options(oopts), add = TRUE)
[18:02:29.814]         }
[18:02:29.814]         {
[18:02:29.814]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:29.814]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:29.814]                 ...future.FUN(...future.X_jj, ...)
[18:02:29.814]             })
[18:02:29.814]         }
[18:02:29.814]     }, args = future.call.arguments)
[18:02:29.814] }
[18:02:29.814] Lazy evaluation: FALSE
[18:02:29.814] Asynchronous evaluation: TRUE
[18:02:29.814] Local evaluation: TRUE
[18:02:29.814] Environment: R_GlobalEnv
[18:02:29.814] Capture standard output: TRUE
[18:02:29.814] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:29.814] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:29.814] Packages: <none>
[18:02:29.814] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:29.814] Resolved: FALSE
[18:02:29.814] Value: <not collected>
[18:02:29.814] Conditions captured: <none>
[18:02:29.814] Early signaling: FALSE
[18:02:29.814] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:29.814] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:29.830] Chunk #2 of 2 ... DONE
[18:02:29.831] Launching 2 futures (chunks) ... DONE
[18:02:29.831] Resolving 2 futures (chunks) ...
[18:02:29.831] resolve() on list ...
[18:02:29.832] plan(): nbrOfWorkers() = 2
[18:02:29.832]  recursive: 0
[18:02:29.832]  length: 2
[18:02:29.832] 
[18:02:29.844] Future #2
[18:02:29.844] result() for MulticoreFuture ...
[18:02:29.846] result() for MulticoreFuture ...
[18:02:29.846] result() for MulticoreFuture ... done
[18:02:29.847] result() for MulticoreFuture ... done
[18:02:29.847] result() for MulticoreFuture ...
[18:02:29.847] result() for MulticoreFuture ... done
[18:02:29.848] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:02:29.848] - nx: 2
[18:02:29.848] - relay: TRUE
[18:02:29.849] - stdout: TRUE
[18:02:29.849] - signal: TRUE
[18:02:29.849] - resignal: FALSE
[18:02:29.850] - force: TRUE
[18:02:29.850] - relayed: [n=2] FALSE, FALSE
[18:02:29.850] - queued futures: [n=2] FALSE, FALSE
[18:02:29.850]  - until=1
[18:02:29.851]  - relaying element #1
[18:02:29.851] - relayed: [n=2] FALSE, FALSE
[18:02:29.851] - queued futures: [n=2] FALSE, TRUE
[18:02:29.852] signalConditionsASAP(NULL, pos=2) ... done
[18:02:29.852]  length: 1 (resolved future 2)
[18:02:30.226] plan(): Setting new future strategy stack:
[18:02:30.227] List of future strategies:
[18:02:30.227] 1. multicore:
[18:02:30.227]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:30.227]    - tweaked: FALSE
[18:02:30.227]    - call: plan(strategy)
[18:02:30.238] plan(): nbrOfWorkers() = 2
[18:02:30.239] Future #1
[18:02:30.239] result() for MulticoreFuture ...
[18:02:30.243] result() for MulticoreFuture ...
[18:02:30.244] result() for MulticoreFuture ... done
[18:02:30.244] result() for MulticoreFuture ... done
[18:02:30.245] result() for MulticoreFuture ...
[18:02:30.245] result() for MulticoreFuture ... done
[18:02:30.245] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:02:30.246] - nx: 2
[18:02:30.246] - relay: TRUE
[18:02:30.246] - stdout: TRUE
[18:02:30.247] - signal: TRUE
[18:02:30.249] - resignal: FALSE
[18:02:30.249] - force: TRUE
[18:02:30.250] - relayed: [n=2] FALSE, FALSE
[18:02:30.250] - queued futures: [n=2] FALSE, TRUE
[18:02:30.250]  - until=1
[18:02:30.251]  - relaying element #1
[18:02:30.252] result() for MulticoreFuture ...
[18:02:30.252] result() for MulticoreFuture ... done
[18:02:30.253] result() for MulticoreFuture ...
[18:02:30.253] result() for MulticoreFuture ... done
[18:02:30.254] result() for MulticoreFuture ...
[18:02:30.254] result() for MulticoreFuture ... done
[18:02:30.254] result() for MulticoreFuture ...
[18:02:30.254] result() for MulticoreFuture ... done
[18:02:30.255] - relayed: [n=2] TRUE, FALSE
[18:02:30.255] - queued futures: [n=2] TRUE, TRUE
[18:02:30.255] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:02:30.256]  length: 0 (resolved future 1)
[18:02:30.256] Relaying remaining futures
[18:02:30.256] signalConditionsASAP(NULL, pos=0) ...
[18:02:30.257] - nx: 2
[18:02:30.257] - relay: TRUE
[18:02:30.257] - stdout: TRUE
[18:02:30.257] - signal: TRUE
[18:02:30.257] - resignal: FALSE
[18:02:30.258] - force: TRUE
[18:02:30.258] - relayed: [n=2] TRUE, FALSE
[18:02:30.258] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:30.259]  - relaying element #2
[18:02:30.259] result() for MulticoreFuture ...
[18:02:30.259] result() for MulticoreFuture ... done
[18:02:30.259] result() for MulticoreFuture ...
[18:02:30.260] result() for MulticoreFuture ... done
[18:02:30.260] result() for MulticoreFuture ...
[18:02:30.260] result() for MulticoreFuture ... done
[18:02:30.261] result() for MulticoreFuture ...
[18:02:30.261] result() for MulticoreFuture ... done
[18:02:30.261] - relayed: [n=2] TRUE, TRUE
[18:02:30.265] - queued futures: [n=2] TRUE, TRUE
[18:02:30.265] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[18:02:30.266] resolve() on list ... DONE
[18:02:30.266] result() for MulticoreFuture ...
[18:02:30.267] result() for MulticoreFuture ... done
[18:02:30.267] result() for MulticoreFuture ...
[18:02:30.267] result() for MulticoreFuture ... done
[18:02:30.268] result() for MulticoreFuture ...
[18:02:30.268] result() for MulticoreFuture ... done
[18:02:30.269] result() for MulticoreFuture ...
[18:02:30.269] result() for MulticoreFuture ... done
[18:02:30.269]  - Number of value chunks collected: 2
[18:02:30.270] Resolving 2 futures (chunks) ... DONE
[18:02:30.270] Reducing values from 2 chunks ...
[18:02:30.270]  - Number of values collected after concatenation: 2
[18:02:30.271]  - Number of values expected: 2
[18:02:30.271] Reducing values from 2 chunks ... DONE
[18:02:30.271] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[18:02:30.272] future_lapply() ...
[18:02:30.281] Number of chunks: 2
[18:02:30.281] getGlobalsAndPackagesXApply() ...
[18:02:30.282]  - future.globals: TRUE
[18:02:30.282] getGlobalsAndPackages() ...
[18:02:30.282] Searching for globals...
[18:02:30.286] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:30.286] Searching for globals ... DONE
[18:02:30.286] Resolving globals: FALSE
[18:02:30.287] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:30.288] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:30.289] - globals: [1] ‘FUN’
[18:02:30.289] 
[18:02:30.289] getGlobalsAndPackages() ... DONE
[18:02:30.289]  - globals found/used: [n=1] ‘FUN’
[18:02:30.290]  - needed namespaces: [n=0] 
[18:02:30.290] Finding globals ... DONE
[18:02:30.290]  - use_args: TRUE
[18:02:30.290]  - Getting '...' globals ...
[18:02:30.291] resolve() on list ...
[18:02:30.291]  recursive: 0
[18:02:30.292]  length: 1
[18:02:30.292]  elements: ‘...’
[18:02:30.292]  length: 0 (resolved future 1)
[18:02:30.292] resolve() on list ... DONE
[18:02:30.293]    - '...' content: [n=0] 
[18:02:30.293] List of 1
[18:02:30.293]  $ ...: list()
[18:02:30.293]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:30.293]  - attr(*, "where")=List of 1
[18:02:30.293]   ..$ ...:<environment: 0x5e4f848b0cd0> 
[18:02:30.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:30.293]  - attr(*, "resolved")= logi TRUE
[18:02:30.293]  - attr(*, "total_size")= num NA
[18:02:30.299]  - Getting '...' globals ... DONE
[18:02:30.300] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:30.300] List of 2
[18:02:30.300]  $ ...future.FUN:function (x)  
[18:02:30.300]  $ ...          : list()
[18:02:30.300]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:30.300]  - attr(*, "where")=List of 2
[18:02:30.300]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:30.300]   ..$ ...          :<environment: 0x5e4f848b0cd0> 
[18:02:30.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:30.300]  - attr(*, "resolved")= logi FALSE
[18:02:30.300]  - attr(*, "total_size")= num 4720
[18:02:30.306] Packages to be attached in all futures: [n=0] 
[18:02:30.307] getGlobalsAndPackagesXApply() ... DONE
[18:02:30.307] Number of futures (= number of chunks): 2
[18:02:30.307] Launching 2 futures (chunks) ...
[18:02:30.308] Chunk #1 of 2 ...
[18:02:30.308]  - Finding globals in 'X' for chunk #1 ...
[18:02:30.308] getGlobalsAndPackages() ...
[18:02:30.308] Searching for globals...
[18:02:30.309] 
[18:02:30.309] Searching for globals ... DONE
[18:02:30.309] - globals: [0] <none>
[18:02:30.309] getGlobalsAndPackages() ... DONE
[18:02:30.310]    + additional globals found: [n=0] 
[18:02:30.310]    + additional namespaces needed: [n=0] 
[18:02:30.310]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:30.310]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:30.310]  - seeds: <none>
[18:02:30.311]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:30.311] getGlobalsAndPackages() ...
[18:02:30.311] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:30.311] Resolving globals: FALSE
[18:02:30.312] Tweak future expression to call with '...' arguments ...
[18:02:30.312] {
[18:02:30.312]     do.call(function(...) {
[18:02:30.312]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:30.312]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:30.312]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:30.312]             on.exit(options(oopts), add = TRUE)
[18:02:30.312]         }
[18:02:30.312]         {
[18:02:30.312]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:30.312]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:30.312]                 ...future.FUN(...future.X_jj, ...)
[18:02:30.312]             })
[18:02:30.312]         }
[18:02:30.312]     }, args = future.call.arguments)
[18:02:30.312] }
[18:02:30.313] Tweak future expression to call with '...' arguments ... DONE
[18:02:30.313] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:30.314] 
[18:02:30.314] getGlobalsAndPackages() ... DONE
[18:02:30.314] run() for ‘Future’ ...
[18:02:30.315] - state: ‘created’
[18:02:30.315] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:30.321] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:30.322] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:30.322]   - Field: ‘label’
[18:02:30.322]   - Field: ‘local’
[18:02:30.323]   - Field: ‘owner’
[18:02:30.323]   - Field: ‘envir’
[18:02:30.323]   - Field: ‘workers’
[18:02:30.323]   - Field: ‘packages’
[18:02:30.323]   - Field: ‘gc’
[18:02:30.324]   - Field: ‘job’
[18:02:30.324]   - Field: ‘conditions’
[18:02:30.324]   - Field: ‘expr’
[18:02:30.324]   - Field: ‘uuid’
[18:02:30.324]   - Field: ‘seed’
[18:02:30.325]   - Field: ‘version’
[18:02:30.325]   - Field: ‘result’
[18:02:30.325]   - Field: ‘asynchronous’
[18:02:30.325]   - Field: ‘calls’
[18:02:30.325]   - Field: ‘globals’
[18:02:30.326]   - Field: ‘stdout’
[18:02:30.326]   - Field: ‘earlySignal’
[18:02:30.327]   - Field: ‘lazy’
[18:02:30.327]   - Field: ‘state’
[18:02:30.327] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:30.327] - Launch lazy future ...
[18:02:30.328] Packages needed by the future expression (n = 0): <none>
[18:02:30.328] Packages needed by future strategies (n = 0): <none>
[18:02:30.331] {
[18:02:30.331]     {
[18:02:30.331]         {
[18:02:30.331]             ...future.startTime <- base::Sys.time()
[18:02:30.331]             {
[18:02:30.331]                 {
[18:02:30.331]                   {
[18:02:30.331]                     {
[18:02:30.331]                       base::local({
[18:02:30.331]                         has_future <- base::requireNamespace("future", 
[18:02:30.331]                           quietly = TRUE)
[18:02:30.331]                         if (has_future) {
[18:02:30.331]                           ns <- base::getNamespace("future")
[18:02:30.331]                           version <- ns[[".package"]][["version"]]
[18:02:30.331]                           if (is.null(version)) 
[18:02:30.331]                             version <- utils::packageVersion("future")
[18:02:30.331]                         }
[18:02:30.331]                         else {
[18:02:30.331]                           version <- NULL
[18:02:30.331]                         }
[18:02:30.331]                         if (!has_future || version < "1.8.0") {
[18:02:30.331]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:30.331]                             "", base::R.version$version.string), 
[18:02:30.331]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:30.331]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:30.331]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:30.331]                               "release", "version")], collapse = " "), 
[18:02:30.331]                             hostname = base::Sys.info()[["nodename"]])
[18:02:30.331]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:30.331]                             info)
[18:02:30.331]                           info <- base::paste(info, collapse = "; ")
[18:02:30.331]                           if (!has_future) {
[18:02:30.331]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:30.331]                               info)
[18:02:30.331]                           }
[18:02:30.331]                           else {
[18:02:30.331]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:30.331]                               info, version)
[18:02:30.331]                           }
[18:02:30.331]                           base::stop(msg)
[18:02:30.331]                         }
[18:02:30.331]                       })
[18:02:30.331]                     }
[18:02:30.331]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:30.331]                     base::options(mc.cores = 1L)
[18:02:30.331]                   }
[18:02:30.331]                   ...future.strategy.old <- future::plan("list")
[18:02:30.331]                   options(future.plan = NULL)
[18:02:30.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:30.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:30.331]                 }
[18:02:30.331]                 ...future.workdir <- getwd()
[18:02:30.331]             }
[18:02:30.331]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:30.331]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:30.331]         }
[18:02:30.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:30.331]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:30.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:30.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:30.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:30.331]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:30.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:30.331]             base::names(...future.oldOptions))
[18:02:30.331]     }
[18:02:30.331]     if (TRUE) {
[18:02:30.331]     }
[18:02:30.331]     else {
[18:02:30.331]         if (NA) {
[18:02:30.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:30.331]                 open = "w")
[18:02:30.331]         }
[18:02:30.331]         else {
[18:02:30.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:30.331]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:30.331]         }
[18:02:30.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:30.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:30.331]             base::sink(type = "output", split = FALSE)
[18:02:30.331]             base::close(...future.stdout)
[18:02:30.331]         }, add = TRUE)
[18:02:30.331]     }
[18:02:30.331]     ...future.frame <- base::sys.nframe()
[18:02:30.331]     ...future.conditions <- base::list()
[18:02:30.331]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:30.331]     if (FALSE) {
[18:02:30.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:30.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:30.331]     }
[18:02:30.331]     ...future.result <- base::tryCatch({
[18:02:30.331]         base::withCallingHandlers({
[18:02:30.331]             ...future.value <- base::withVisible(base::local({
[18:02:30.331]                 withCallingHandlers({
[18:02:30.331]                   {
[18:02:30.331]                     do.call(function(...) {
[18:02:30.331]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:30.331]                       if (!identical(...future.globals.maxSize.org, 
[18:02:30.331]                         ...future.globals.maxSize)) {
[18:02:30.331]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:30.331]                         on.exit(options(oopts), add = TRUE)
[18:02:30.331]                       }
[18:02:30.331]                       {
[18:02:30.331]                         lapply(seq_along(...future.elements_ii), 
[18:02:30.331]                           FUN = function(jj) {
[18:02:30.331]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:30.331]                             ...future.FUN(...future.X_jj, ...)
[18:02:30.331]                           })
[18:02:30.331]                       }
[18:02:30.331]                     }, args = future.call.arguments)
[18:02:30.331]                   }
[18:02:30.331]                 }, immediateCondition = function(cond) {
[18:02:30.331]                   save_rds <- function (object, pathname, ...) 
[18:02:30.331]                   {
[18:02:30.331]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:30.331]                     if (file_test("-f", pathname_tmp)) {
[18:02:30.331]                       fi_tmp <- file.info(pathname_tmp)
[18:02:30.331]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:30.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:30.331]                         fi_tmp[["mtime"]])
[18:02:30.331]                     }
[18:02:30.331]                     tryCatch({
[18:02:30.331]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:30.331]                     }, error = function(ex) {
[18:02:30.331]                       msg <- conditionMessage(ex)
[18:02:30.331]                       fi_tmp <- file.info(pathname_tmp)
[18:02:30.331]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:30.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:30.331]                         fi_tmp[["mtime"]], msg)
[18:02:30.331]                       ex$message <- msg
[18:02:30.331]                       stop(ex)
[18:02:30.331]                     })
[18:02:30.331]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:30.331]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:30.331]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:30.331]                       fi_tmp <- file.info(pathname_tmp)
[18:02:30.331]                       fi <- file.info(pathname)
[18:02:30.331]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:30.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:30.331]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:30.331]                         fi[["size"]], fi[["mtime"]])
[18:02:30.331]                       stop(msg)
[18:02:30.331]                     }
[18:02:30.331]                     invisible(pathname)
[18:02:30.331]                   }
[18:02:30.331]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:30.331]                     rootPath = tempdir()) 
[18:02:30.331]                   {
[18:02:30.331]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:30.331]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:30.331]                       tmpdir = path, fileext = ".rds")
[18:02:30.331]                     save_rds(obj, file)
[18:02:30.331]                   }
[18:02:30.331]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1j8FfD/.future/immediateConditions")
[18:02:30.331]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:30.331]                   {
[18:02:30.331]                     inherits <- base::inherits
[18:02:30.331]                     invokeRestart <- base::invokeRestart
[18:02:30.331]                     is.null <- base::is.null
[18:02:30.331]                     muffled <- FALSE
[18:02:30.331]                     if (inherits(cond, "message")) {
[18:02:30.331]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:30.331]                       if (muffled) 
[18:02:30.331]                         invokeRestart("muffleMessage")
[18:02:30.331]                     }
[18:02:30.331]                     else if (inherits(cond, "warning")) {
[18:02:30.331]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:30.331]                       if (muffled) 
[18:02:30.331]                         invokeRestart("muffleWarning")
[18:02:30.331]                     }
[18:02:30.331]                     else if (inherits(cond, "condition")) {
[18:02:30.331]                       if (!is.null(pattern)) {
[18:02:30.331]                         computeRestarts <- base::computeRestarts
[18:02:30.331]                         grepl <- base::grepl
[18:02:30.331]                         restarts <- computeRestarts(cond)
[18:02:30.331]                         for (restart in restarts) {
[18:02:30.331]                           name <- restart$name
[18:02:30.331]                           if (is.null(name)) 
[18:02:30.331]                             next
[18:02:30.331]                           if (!grepl(pattern, name)) 
[18:02:30.331]                             next
[18:02:30.331]                           invokeRestart(restart)
[18:02:30.331]                           muffled <- TRUE
[18:02:30.331]                           break
[18:02:30.331]                         }
[18:02:30.331]                       }
[18:02:30.331]                     }
[18:02:30.331]                     invisible(muffled)
[18:02:30.331]                   }
[18:02:30.331]                   muffleCondition(cond)
[18:02:30.331]                 })
[18:02:30.331]             }))
[18:02:30.331]             future::FutureResult(value = ...future.value$value, 
[18:02:30.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:30.331]                   ...future.rng), globalenv = if (FALSE) 
[18:02:30.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:30.331]                     ...future.globalenv.names))
[18:02:30.331]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:30.331]         }, condition = base::local({
[18:02:30.331]             c <- base::c
[18:02:30.331]             inherits <- base::inherits
[18:02:30.331]             invokeRestart <- base::invokeRestart
[18:02:30.331]             length <- base::length
[18:02:30.331]             list <- base::list
[18:02:30.331]             seq.int <- base::seq.int
[18:02:30.331]             signalCondition <- base::signalCondition
[18:02:30.331]             sys.calls <- base::sys.calls
[18:02:30.331]             `[[` <- base::`[[`
[18:02:30.331]             `+` <- base::`+`
[18:02:30.331]             `<<-` <- base::`<<-`
[18:02:30.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:30.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:30.331]                   3L)]
[18:02:30.331]             }
[18:02:30.331]             function(cond) {
[18:02:30.331]                 is_error <- inherits(cond, "error")
[18:02:30.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:30.331]                   NULL)
[18:02:30.331]                 if (is_error) {
[18:02:30.331]                   sessionInformation <- function() {
[18:02:30.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:30.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:30.331]                       search = base::search(), system = base::Sys.info())
[18:02:30.331]                   }
[18:02:30.331]                   ...future.conditions[[length(...future.conditions) + 
[18:02:30.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:30.331]                     cond$call), session = sessionInformation(), 
[18:02:30.331]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:30.331]                   signalCondition(cond)
[18:02:30.331]                 }
[18:02:30.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:30.331]                 "immediateCondition"))) {
[18:02:30.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:30.331]                   ...future.conditions[[length(...future.conditions) + 
[18:02:30.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:30.331]                   if (TRUE && !signal) {
[18:02:30.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:30.331]                     {
[18:02:30.331]                       inherits <- base::inherits
[18:02:30.331]                       invokeRestart <- base::invokeRestart
[18:02:30.331]                       is.null <- base::is.null
[18:02:30.331]                       muffled <- FALSE
[18:02:30.331]                       if (inherits(cond, "message")) {
[18:02:30.331]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:30.331]                         if (muffled) 
[18:02:30.331]                           invokeRestart("muffleMessage")
[18:02:30.331]                       }
[18:02:30.331]                       else if (inherits(cond, "warning")) {
[18:02:30.331]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:30.331]                         if (muffled) 
[18:02:30.331]                           invokeRestart("muffleWarning")
[18:02:30.331]                       }
[18:02:30.331]                       else if (inherits(cond, "condition")) {
[18:02:30.331]                         if (!is.null(pattern)) {
[18:02:30.331]                           computeRestarts <- base::computeRestarts
[18:02:30.331]                           grepl <- base::grepl
[18:02:30.331]                           restarts <- computeRestarts(cond)
[18:02:30.331]                           for (restart in restarts) {
[18:02:30.331]                             name <- restart$name
[18:02:30.331]                             if (is.null(name)) 
[18:02:30.331]                               next
[18:02:30.331]                             if (!grepl(pattern, name)) 
[18:02:30.331]                               next
[18:02:30.331]                             invokeRestart(restart)
[18:02:30.331]                             muffled <- TRUE
[18:02:30.331]                             break
[18:02:30.331]                           }
[18:02:30.331]                         }
[18:02:30.331]                       }
[18:02:30.331]                       invisible(muffled)
[18:02:30.331]                     }
[18:02:30.331]                     muffleCondition(cond, pattern = "^muffle")
[18:02:30.331]                   }
[18:02:30.331]                 }
[18:02:30.331]                 else {
[18:02:30.331]                   if (TRUE) {
[18:02:30.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:30.331]                     {
[18:02:30.331]                       inherits <- base::inherits
[18:02:30.331]                       invokeRestart <- base::invokeRestart
[18:02:30.331]                       is.null <- base::is.null
[18:02:30.331]                       muffled <- FALSE
[18:02:30.331]                       if (inherits(cond, "message")) {
[18:02:30.331]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:30.331]                         if (muffled) 
[18:02:30.331]                           invokeRestart("muffleMessage")
[18:02:30.331]                       }
[18:02:30.331]                       else if (inherits(cond, "warning")) {
[18:02:30.331]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:30.331]                         if (muffled) 
[18:02:30.331]                           invokeRestart("muffleWarning")
[18:02:30.331]                       }
[18:02:30.331]                       else if (inherits(cond, "condition")) {
[18:02:30.331]                         if (!is.null(pattern)) {
[18:02:30.331]                           computeRestarts <- base::computeRestarts
[18:02:30.331]                           grepl <- base::grepl
[18:02:30.331]                           restarts <- computeRestarts(cond)
[18:02:30.331]                           for (restart in restarts) {
[18:02:30.331]                             name <- restart$name
[18:02:30.331]                             if (is.null(name)) 
[18:02:30.331]                               next
[18:02:30.331]                             if (!grepl(pattern, name)) 
[18:02:30.331]                               next
[18:02:30.331]                             invokeRestart(restart)
[18:02:30.331]                             muffled <- TRUE
[18:02:30.331]                             break
[18:02:30.331]                           }
[18:02:30.331]                         }
[18:02:30.331]                       }
[18:02:30.331]                       invisible(muffled)
[18:02:30.331]                     }
[18:02:30.331]                     muffleCondition(cond, pattern = "^muffle")
[18:02:30.331]                   }
[18:02:30.331]                 }
[18:02:30.331]             }
[18:02:30.331]         }))
[18:02:30.331]     }, error = function(ex) {
[18:02:30.331]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:30.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:30.331]                 ...future.rng), started = ...future.startTime, 
[18:02:30.331]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:30.331]             version = "1.8"), class = "FutureResult")
[18:02:30.331]     }, finally = {
[18:02:30.331]         if (!identical(...future.workdir, getwd())) 
[18:02:30.331]             setwd(...future.workdir)
[18:02:30.331]         {
[18:02:30.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:30.331]                 ...future.oldOptions$nwarnings <- NULL
[18:02:30.331]             }
[18:02:30.331]             base::options(...future.oldOptions)
[18:02:30.331]             if (.Platform$OS.type == "windows") {
[18:02:30.331]                 old_names <- names(...future.oldEnvVars)
[18:02:30.331]                 envs <- base::Sys.getenv()
[18:02:30.331]                 names <- names(envs)
[18:02:30.331]                 common <- intersect(names, old_names)
[18:02:30.331]                 added <- setdiff(names, old_names)
[18:02:30.331]                 removed <- setdiff(old_names, names)
[18:02:30.331]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:30.331]                   envs[common]]
[18:02:30.331]                 NAMES <- toupper(changed)
[18:02:30.331]                 args <- list()
[18:02:30.331]                 for (kk in seq_along(NAMES)) {
[18:02:30.331]                   name <- changed[[kk]]
[18:02:30.331]                   NAME <- NAMES[[kk]]
[18:02:30.331]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:30.331]                     next
[18:02:30.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:30.331]                 }
[18:02:30.331]                 NAMES <- toupper(added)
[18:02:30.331]                 for (kk in seq_along(NAMES)) {
[18:02:30.331]                   name <- added[[kk]]
[18:02:30.331]                   NAME <- NAMES[[kk]]
[18:02:30.331]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:30.331]                     next
[18:02:30.331]                   args[[name]] <- ""
[18:02:30.331]                 }
[18:02:30.331]                 NAMES <- toupper(removed)
[18:02:30.331]                 for (kk in seq_along(NAMES)) {
[18:02:30.331]                   name <- removed[[kk]]
[18:02:30.331]                   NAME <- NAMES[[kk]]
[18:02:30.331]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:30.331]                     next
[18:02:30.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:30.331]                 }
[18:02:30.331]                 if (length(args) > 0) 
[18:02:30.331]                   base::do.call(base::Sys.setenv, args = args)
[18:02:30.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:30.331]             }
[18:02:30.331]             else {
[18:02:30.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:30.331]             }
[18:02:30.331]             {
[18:02:30.331]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:30.331]                   0L) {
[18:02:30.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:30.331]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:30.331]                   base::options(opts)
[18:02:30.331]                 }
[18:02:30.331]                 {
[18:02:30.331]                   {
[18:02:30.331]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:30.331]                     NULL
[18:02:30.331]                   }
[18:02:30.331]                   options(future.plan = NULL)
[18:02:30.331]                   if (is.na(NA_character_)) 
[18:02:30.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:30.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:30.331]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:30.331]                     .init = FALSE)
[18:02:30.331]                 }
[18:02:30.331]             }
[18:02:30.331]         }
[18:02:30.331]     })
[18:02:30.331]     if (FALSE) {
[18:02:30.331]         base::sink(type = "output", split = FALSE)
[18:02:30.331]         if (NA) {
[18:02:30.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:30.331]         }
[18:02:30.331]         else {
[18:02:30.331]             ...future.result["stdout"] <- base::list(NULL)
[18:02:30.331]         }
[18:02:30.331]         base::close(...future.stdout)
[18:02:30.331]         ...future.stdout <- NULL
[18:02:30.331]     }
[18:02:30.331]     ...future.result$conditions <- ...future.conditions
[18:02:30.331]     ...future.result$finished <- base::Sys.time()
[18:02:30.331]     ...future.result
[18:02:30.331] }
[18:02:30.336] assign_globals() ...
[18:02:30.336] List of 5
[18:02:30.336]  $ ...future.FUN            :function (x)  
[18:02:30.336]  $ future.call.arguments    : list()
[18:02:30.336]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:30.336]  $ ...future.elements_ii    :List of 1
[18:02:30.336]   ..$ : int 1
[18:02:30.336]  $ ...future.seeds_ii       : NULL
[18:02:30.336]  $ ...future.globals.maxSize: NULL
[18:02:30.336]  - attr(*, "where")=List of 5
[18:02:30.336]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:30.336]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:30.336]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:30.336]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:30.336]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:30.336]  - attr(*, "resolved")= logi FALSE
[18:02:30.336]  - attr(*, "total_size")= num 4720
[18:02:30.336]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:30.336]  - attr(*, "already-done")= logi TRUE
[18:02:30.350] - reassign environment for ‘...future.FUN’
[18:02:30.350] - copied ‘...future.FUN’ to environment
[18:02:30.350] - copied ‘future.call.arguments’ to environment
[18:02:30.351] - copied ‘...future.elements_ii’ to environment
[18:02:30.351] - copied ‘...future.seeds_ii’ to environment
[18:02:30.351] - copied ‘...future.globals.maxSize’ to environment
[18:02:30.351] assign_globals() ... done
[18:02:30.352] requestCore(): workers = 2
[18:02:30.355] MulticoreFuture started
[18:02:30.356] - Launch lazy future ... done
[18:02:30.360] plan(): Setting new future strategy stack:
[18:02:30.361] run() for ‘MulticoreFuture’ ... done
[18:02:30.361] Created future:
[18:02:30.363] List of future strategies:
[18:02:30.363] 1. sequential:
[18:02:30.363]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:30.363]    - tweaked: FALSE
[18:02:30.363]    - call: NULL
[18:02:30.367] plan(): nbrOfWorkers() = 1
[18:02:30.362] MulticoreFuture:
[18:02:30.362] Label: ‘future_lapply-1’
[18:02:30.362] Expression:
[18:02:30.362] {
[18:02:30.362]     do.call(function(...) {
[18:02:30.362]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:30.362]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:30.362]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:30.362]             on.exit(options(oopts), add = TRUE)
[18:02:30.362]         }
[18:02:30.362]         {
[18:02:30.362]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:30.362]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:30.362]                 ...future.FUN(...future.X_jj, ...)
[18:02:30.362]             })
[18:02:30.362]         }
[18:02:30.362]     }, args = future.call.arguments)
[18:02:30.362] }
[18:02:30.362] Lazy evaluation: FALSE
[18:02:30.362] Asynchronous evaluation: TRUE
[18:02:30.362] Local evaluation: TRUE
[18:02:30.362] Environment: R_GlobalEnv
[18:02:30.362] Capture standard output: NA
[18:02:30.362] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:30.362] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:30.362] Packages: <none>
[18:02:30.362] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:30.362] Resolved: FALSE
[18:02:30.362] Value: <not collected>
[18:02:30.362] Conditions captured: <none>
[18:02:30.362] Early signaling: FALSE
[18:02:30.362] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:30.362] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:30.382] Chunk #1 of 2 ... DONE
[18:02:30.382] Chunk #2 of 2 ...
[18:02:30.383]  - Finding globals in 'X' for chunk #2 ...
[18:02:30.383] getGlobalsAndPackages() ...
[18:02:30.383] Searching for globals...
[18:02:30.384] 
[18:02:30.385] Searching for globals ... DONE
[18:02:30.385] - globals: [0] <none>
[18:02:30.385] getGlobalsAndPackages() ... DONE
[18:02:30.386]    + additional globals found: [n=0] 
[18:02:30.386]    + additional namespaces needed: [n=0] 
[18:02:30.386]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:30.387]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:30.387]  - seeds: <none>
[18:02:30.387]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:30.388] getGlobalsAndPackages() ...
[18:02:30.388] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:30.388] Resolving globals: FALSE
[18:02:30.389] Tweak future expression to call with '...' arguments ...
[18:02:30.389] {
[18:02:30.389]     do.call(function(...) {
[18:02:30.389]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:30.389]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:30.389]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:30.389]             on.exit(options(oopts), add = TRUE)
[18:02:30.389]         }
[18:02:30.389]         {
[18:02:30.389]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:30.389]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:30.389]                 ...future.FUN(...future.X_jj, ...)
[18:02:30.389]             })
[18:02:30.389]         }
[18:02:30.389]     }, args = future.call.arguments)
[18:02:30.389] }
[18:02:30.390] Tweak future expression to call with '...' arguments ... DONE
[18:02:30.392] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:30.392] 
[18:02:30.392] getGlobalsAndPackages() ... DONE
[18:02:30.393] run() for ‘Future’ ...
[18:02:30.394] - state: ‘created’
[18:02:30.394] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:30.403] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:30.403] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:30.404]   - Field: ‘label’
[18:02:30.404]   - Field: ‘local’
[18:02:30.404]   - Field: ‘owner’
[18:02:30.405]   - Field: ‘envir’
[18:02:30.405]   - Field: ‘workers’
[18:02:30.405]   - Field: ‘packages’
[18:02:30.406]   - Field: ‘gc’
[18:02:30.406]   - Field: ‘job’
[18:02:30.406]   - Field: ‘conditions’
[18:02:30.407]   - Field: ‘expr’
[18:02:30.407]   - Field: ‘uuid’
[18:02:30.407]   - Field: ‘seed’
[18:02:30.408]   - Field: ‘version’
[18:02:30.408]   - Field: ‘result’
[18:02:30.408]   - Field: ‘asynchronous’
[18:02:30.409]   - Field: ‘calls’
[18:02:30.409]   - Field: ‘globals’
[18:02:30.409]   - Field: ‘stdout’
[18:02:30.410]   - Field: ‘earlySignal’
[18:02:30.410]   - Field: ‘lazy’
[18:02:30.410]   - Field: ‘state’
[18:02:30.411] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:30.411] - Launch lazy future ...
[18:02:30.412] Packages needed by the future expression (n = 0): <none>
[18:02:30.413] Packages needed by future strategies (n = 0): <none>
[18:02:30.414] {
[18:02:30.414]     {
[18:02:30.414]         {
[18:02:30.414]             ...future.startTime <- base::Sys.time()
[18:02:30.414]             {
[18:02:30.414]                 {
[18:02:30.414]                   {
[18:02:30.414]                     {
[18:02:30.414]                       base::local({
[18:02:30.414]                         has_future <- base::requireNamespace("future", 
[18:02:30.414]                           quietly = TRUE)
[18:02:30.414]                         if (has_future) {
[18:02:30.414]                           ns <- base::getNamespace("future")
[18:02:30.414]                           version <- ns[[".package"]][["version"]]
[18:02:30.414]                           if (is.null(version)) 
[18:02:30.414]                             version <- utils::packageVersion("future")
[18:02:30.414]                         }
[18:02:30.414]                         else {
[18:02:30.414]                           version <- NULL
[18:02:30.414]                         }
[18:02:30.414]                         if (!has_future || version < "1.8.0") {
[18:02:30.414]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:30.414]                             "", base::R.version$version.string), 
[18:02:30.414]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:30.414]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:30.414]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:30.414]                               "release", "version")], collapse = " "), 
[18:02:30.414]                             hostname = base::Sys.info()[["nodename"]])
[18:02:30.414]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:30.414]                             info)
[18:02:30.414]                           info <- base::paste(info, collapse = "; ")
[18:02:30.414]                           if (!has_future) {
[18:02:30.414]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:30.414]                               info)
[18:02:30.414]                           }
[18:02:30.414]                           else {
[18:02:30.414]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:30.414]                               info, version)
[18:02:30.414]                           }
[18:02:30.414]                           base::stop(msg)
[18:02:30.414]                         }
[18:02:30.414]                       })
[18:02:30.414]                     }
[18:02:30.414]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:30.414]                     base::options(mc.cores = 1L)
[18:02:30.414]                   }
[18:02:30.414]                   ...future.strategy.old <- future::plan("list")
[18:02:30.414]                   options(future.plan = NULL)
[18:02:30.414]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:30.414]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:30.414]                 }
[18:02:30.414]                 ...future.workdir <- getwd()
[18:02:30.414]             }
[18:02:30.414]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:30.414]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:30.414]         }
[18:02:30.414]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:30.414]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:30.414]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:30.414]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:30.414]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:30.414]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:30.414]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:30.414]             base::names(...future.oldOptions))
[18:02:30.414]     }
[18:02:30.414]     if (TRUE) {
[18:02:30.414]     }
[18:02:30.414]     else {
[18:02:30.414]         if (NA) {
[18:02:30.414]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:30.414]                 open = "w")
[18:02:30.414]         }
[18:02:30.414]         else {
[18:02:30.414]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:30.414]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:30.414]         }
[18:02:30.414]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:30.414]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:30.414]             base::sink(type = "output", split = FALSE)
[18:02:30.414]             base::close(...future.stdout)
[18:02:30.414]         }, add = TRUE)
[18:02:30.414]     }
[18:02:30.414]     ...future.frame <- base::sys.nframe()
[18:02:30.414]     ...future.conditions <- base::list()
[18:02:30.414]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:30.414]     if (FALSE) {
[18:02:30.414]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:30.414]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:30.414]     }
[18:02:30.414]     ...future.result <- base::tryCatch({
[18:02:30.414]         base::withCallingHandlers({
[18:02:30.414]             ...future.value <- base::withVisible(base::local({
[18:02:30.414]                 withCallingHandlers({
[18:02:30.414]                   {
[18:02:30.414]                     do.call(function(...) {
[18:02:30.414]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:30.414]                       if (!identical(...future.globals.maxSize.org, 
[18:02:30.414]                         ...future.globals.maxSize)) {
[18:02:30.414]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:30.414]                         on.exit(options(oopts), add = TRUE)
[18:02:30.414]                       }
[18:02:30.414]                       {
[18:02:30.414]                         lapply(seq_along(...future.elements_ii), 
[18:02:30.414]                           FUN = function(jj) {
[18:02:30.414]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:30.414]                             ...future.FUN(...future.X_jj, ...)
[18:02:30.414]                           })
[18:02:30.414]                       }
[18:02:30.414]                     }, args = future.call.arguments)
[18:02:30.414]                   }
[18:02:30.414]                 }, immediateCondition = function(cond) {
[18:02:30.414]                   save_rds <- function (object, pathname, ...) 
[18:02:30.414]                   {
[18:02:30.414]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:30.414]                     if (file_test("-f", pathname_tmp)) {
[18:02:30.414]                       fi_tmp <- file.info(pathname_tmp)
[18:02:30.414]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:30.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:30.414]                         fi_tmp[["mtime"]])
[18:02:30.414]                     }
[18:02:30.414]                     tryCatch({
[18:02:30.414]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:30.414]                     }, error = function(ex) {
[18:02:30.414]                       msg <- conditionMessage(ex)
[18:02:30.414]                       fi_tmp <- file.info(pathname_tmp)
[18:02:30.414]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:30.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:30.414]                         fi_tmp[["mtime"]], msg)
[18:02:30.414]                       ex$message <- msg
[18:02:30.414]                       stop(ex)
[18:02:30.414]                     })
[18:02:30.414]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:30.414]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:30.414]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:30.414]                       fi_tmp <- file.info(pathname_tmp)
[18:02:30.414]                       fi <- file.info(pathname)
[18:02:30.414]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:30.414]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:30.414]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:30.414]                         fi[["size"]], fi[["mtime"]])
[18:02:30.414]                       stop(msg)
[18:02:30.414]                     }
[18:02:30.414]                     invisible(pathname)
[18:02:30.414]                   }
[18:02:30.414]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:30.414]                     rootPath = tempdir()) 
[18:02:30.414]                   {
[18:02:30.414]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:30.414]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:30.414]                       tmpdir = path, fileext = ".rds")
[18:02:30.414]                     save_rds(obj, file)
[18:02:30.414]                   }
[18:02:30.414]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1j8FfD/.future/immediateConditions")
[18:02:30.414]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:30.414]                   {
[18:02:30.414]                     inherits <- base::inherits
[18:02:30.414]                     invokeRestart <- base::invokeRestart
[18:02:30.414]                     is.null <- base::is.null
[18:02:30.414]                     muffled <- FALSE
[18:02:30.414]                     if (inherits(cond, "message")) {
[18:02:30.414]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:30.414]                       if (muffled) 
[18:02:30.414]                         invokeRestart("muffleMessage")
[18:02:30.414]                     }
[18:02:30.414]                     else if (inherits(cond, "warning")) {
[18:02:30.414]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:30.414]                       if (muffled) 
[18:02:30.414]                         invokeRestart("muffleWarning")
[18:02:30.414]                     }
[18:02:30.414]                     else if (inherits(cond, "condition")) {
[18:02:30.414]                       if (!is.null(pattern)) {
[18:02:30.414]                         computeRestarts <- base::computeRestarts
[18:02:30.414]                         grepl <- base::grepl
[18:02:30.414]                         restarts <- computeRestarts(cond)
[18:02:30.414]                         for (restart in restarts) {
[18:02:30.414]                           name <- restart$name
[18:02:30.414]                           if (is.null(name)) 
[18:02:30.414]                             next
[18:02:30.414]                           if (!grepl(pattern, name)) 
[18:02:30.414]                             next
[18:02:30.414]                           invokeRestart(restart)
[18:02:30.414]                           muffled <- TRUE
[18:02:30.414]                           break
[18:02:30.414]                         }
[18:02:30.414]                       }
[18:02:30.414]                     }
[18:02:30.414]                     invisible(muffled)
[18:02:30.414]                   }
[18:02:30.414]                   muffleCondition(cond)
[18:02:30.414]                 })
[18:02:30.414]             }))
[18:02:30.414]             future::FutureResult(value = ...future.value$value, 
[18:02:30.414]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:30.414]                   ...future.rng), globalenv = if (FALSE) 
[18:02:30.414]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:30.414]                     ...future.globalenv.names))
[18:02:30.414]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:30.414]         }, condition = base::local({
[18:02:30.414]             c <- base::c
[18:02:30.414]             inherits <- base::inherits
[18:02:30.414]             invokeRestart <- base::invokeRestart
[18:02:30.414]             length <- base::length
[18:02:30.414]             list <- base::list
[18:02:30.414]             seq.int <- base::seq.int
[18:02:30.414]             signalCondition <- base::signalCondition
[18:02:30.414]             sys.calls <- base::sys.calls
[18:02:30.414]             `[[` <- base::`[[`
[18:02:30.414]             `+` <- base::`+`
[18:02:30.414]             `<<-` <- base::`<<-`
[18:02:30.414]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:30.414]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:30.414]                   3L)]
[18:02:30.414]             }
[18:02:30.414]             function(cond) {
[18:02:30.414]                 is_error <- inherits(cond, "error")
[18:02:30.414]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:30.414]                   NULL)
[18:02:30.414]                 if (is_error) {
[18:02:30.414]                   sessionInformation <- function() {
[18:02:30.414]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:30.414]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:30.414]                       search = base::search(), system = base::Sys.info())
[18:02:30.414]                   }
[18:02:30.414]                   ...future.conditions[[length(...future.conditions) + 
[18:02:30.414]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:30.414]                     cond$call), session = sessionInformation(), 
[18:02:30.414]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:30.414]                   signalCondition(cond)
[18:02:30.414]                 }
[18:02:30.414]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:30.414]                 "immediateCondition"))) {
[18:02:30.414]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:30.414]                   ...future.conditions[[length(...future.conditions) + 
[18:02:30.414]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:30.414]                   if (TRUE && !signal) {
[18:02:30.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:30.414]                     {
[18:02:30.414]                       inherits <- base::inherits
[18:02:30.414]                       invokeRestart <- base::invokeRestart
[18:02:30.414]                       is.null <- base::is.null
[18:02:30.414]                       muffled <- FALSE
[18:02:30.414]                       if (inherits(cond, "message")) {
[18:02:30.414]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:30.414]                         if (muffled) 
[18:02:30.414]                           invokeRestart("muffleMessage")
[18:02:30.414]                       }
[18:02:30.414]                       else if (inherits(cond, "warning")) {
[18:02:30.414]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:30.414]                         if (muffled) 
[18:02:30.414]                           invokeRestart("muffleWarning")
[18:02:30.414]                       }
[18:02:30.414]                       else if (inherits(cond, "condition")) {
[18:02:30.414]                         if (!is.null(pattern)) {
[18:02:30.414]                           computeRestarts <- base::computeRestarts
[18:02:30.414]                           grepl <- base::grepl
[18:02:30.414]                           restarts <- computeRestarts(cond)
[18:02:30.414]                           for (restart in restarts) {
[18:02:30.414]                             name <- restart$name
[18:02:30.414]                             if (is.null(name)) 
[18:02:30.414]                               next
[18:02:30.414]                             if (!grepl(pattern, name)) 
[18:02:30.414]                               next
[18:02:30.414]                             invokeRestart(restart)
[18:02:30.414]                             muffled <- TRUE
[18:02:30.414]                             break
[18:02:30.414]                           }
[18:02:30.414]                         }
[18:02:30.414]                       }
[18:02:30.414]                       invisible(muffled)
[18:02:30.414]                     }
[18:02:30.414]                     muffleCondition(cond, pattern = "^muffle")
[18:02:30.414]                   }
[18:02:30.414]                 }
[18:02:30.414]                 else {
[18:02:30.414]                   if (TRUE) {
[18:02:30.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:30.414]                     {
[18:02:30.414]                       inherits <- base::inherits
[18:02:30.414]                       invokeRestart <- base::invokeRestart
[18:02:30.414]                       is.null <- base::is.null
[18:02:30.414]                       muffled <- FALSE
[18:02:30.414]                       if (inherits(cond, "message")) {
[18:02:30.414]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:30.414]                         if (muffled) 
[18:02:30.414]                           invokeRestart("muffleMessage")
[18:02:30.414]                       }
[18:02:30.414]                       else if (inherits(cond, "warning")) {
[18:02:30.414]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:30.414]                         if (muffled) 
[18:02:30.414]                           invokeRestart("muffleWarning")
[18:02:30.414]                       }
[18:02:30.414]                       else if (inherits(cond, "condition")) {
[18:02:30.414]                         if (!is.null(pattern)) {
[18:02:30.414]                           computeRestarts <- base::computeRestarts
[18:02:30.414]                           grepl <- base::grepl
[18:02:30.414]                           restarts <- computeRestarts(cond)
[18:02:30.414]                           for (restart in restarts) {
[18:02:30.414]                             name <- restart$name
[18:02:30.414]                             if (is.null(name)) 
[18:02:30.414]                               next
[18:02:30.414]                             if (!grepl(pattern, name)) 
[18:02:30.414]                               next
[18:02:30.414]                             invokeRestart(restart)
[18:02:30.414]                             muffled <- TRUE
[18:02:30.414]                             break
[18:02:30.414]                           }
[18:02:30.414]                         }
[18:02:30.414]                       }
[18:02:30.414]                       invisible(muffled)
[18:02:30.414]                     }
[18:02:30.414]                     muffleCondition(cond, pattern = "^muffle")
[18:02:30.414]                   }
[18:02:30.414]                 }
[18:02:30.414]             }
[18:02:30.414]         }))
[18:02:30.414]     }, error = function(ex) {
[18:02:30.414]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:30.414]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:30.414]                 ...future.rng), started = ...future.startTime, 
[18:02:30.414]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:30.414]             version = "1.8"), class = "FutureResult")
[18:02:30.414]     }, finally = {
[18:02:30.414]         if (!identical(...future.workdir, getwd())) 
[18:02:30.414]             setwd(...future.workdir)
[18:02:30.414]         {
[18:02:30.414]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:30.414]                 ...future.oldOptions$nwarnings <- NULL
[18:02:30.414]             }
[18:02:30.414]             base::options(...future.oldOptions)
[18:02:30.414]             if (.Platform$OS.type == "windows") {
[18:02:30.414]                 old_names <- names(...future.oldEnvVars)
[18:02:30.414]                 envs <- base::Sys.getenv()
[18:02:30.414]                 names <- names(envs)
[18:02:30.414]                 common <- intersect(names, old_names)
[18:02:30.414]                 added <- setdiff(names, old_names)
[18:02:30.414]                 removed <- setdiff(old_names, names)
[18:02:30.414]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:30.414]                   envs[common]]
[18:02:30.414]                 NAMES <- toupper(changed)
[18:02:30.414]                 args <- list()
[18:02:30.414]                 for (kk in seq_along(NAMES)) {
[18:02:30.414]                   name <- changed[[kk]]
[18:02:30.414]                   NAME <- NAMES[[kk]]
[18:02:30.414]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:30.414]                     next
[18:02:30.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:30.414]                 }
[18:02:30.414]                 NAMES <- toupper(added)
[18:02:30.414]                 for (kk in seq_along(NAMES)) {
[18:02:30.414]                   name <- added[[kk]]
[18:02:30.414]                   NAME <- NAMES[[kk]]
[18:02:30.414]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:30.414]                     next
[18:02:30.414]                   args[[name]] <- ""
[18:02:30.414]                 }
[18:02:30.414]                 NAMES <- toupper(removed)
[18:02:30.414]                 for (kk in seq_along(NAMES)) {
[18:02:30.414]                   name <- removed[[kk]]
[18:02:30.414]                   NAME <- NAMES[[kk]]
[18:02:30.414]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:30.414]                     next
[18:02:30.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:30.414]                 }
[18:02:30.414]                 if (length(args) > 0) 
[18:02:30.414]                   base::do.call(base::Sys.setenv, args = args)
[18:02:30.414]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:30.414]             }
[18:02:30.414]             else {
[18:02:30.414]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:30.414]             }
[18:02:30.414]             {
[18:02:30.414]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:30.414]                   0L) {
[18:02:30.414]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:30.414]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:30.414]                   base::options(opts)
[18:02:30.414]                 }
[18:02:30.414]                 {
[18:02:30.414]                   {
[18:02:30.414]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:30.414]                     NULL
[18:02:30.414]                   }
[18:02:30.414]                   options(future.plan = NULL)
[18:02:30.414]                   if (is.na(NA_character_)) 
[18:02:30.414]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:30.414]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:30.414]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:30.414]                     .init = FALSE)
[18:02:30.414]                 }
[18:02:30.414]             }
[18:02:30.414]         }
[18:02:30.414]     })
[18:02:30.414]     if (FALSE) {
[18:02:30.414]         base::sink(type = "output", split = FALSE)
[18:02:30.414]         if (NA) {
[18:02:30.414]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:30.414]         }
[18:02:30.414]         else {
[18:02:30.414]             ...future.result["stdout"] <- base::list(NULL)
[18:02:30.414]         }
[18:02:30.414]         base::close(...future.stdout)
[18:02:30.414]         ...future.stdout <- NULL
[18:02:30.414]     }
[18:02:30.414]     ...future.result$conditions <- ...future.conditions
[18:02:30.414]     ...future.result$finished <- base::Sys.time()
[18:02:30.414]     ...future.result
[18:02:30.414] }
[18:02:30.421] assign_globals() ...
[18:02:30.421] List of 5
[18:02:30.421]  $ ...future.FUN            :function (x)  
[18:02:30.421]  $ future.call.arguments    : list()
[18:02:30.421]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:30.421]  $ ...future.elements_ii    :List of 1
[18:02:30.421]   ..$ : int 0
[18:02:30.421]  $ ...future.seeds_ii       : NULL
[18:02:30.421]  $ ...future.globals.maxSize: NULL
[18:02:30.421]  - attr(*, "where")=List of 5
[18:02:30.421]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:30.421]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[18:02:30.421]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:30.421]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:30.421]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:30.421]  - attr(*, "resolved")= logi FALSE
[18:02:30.421]  - attr(*, "total_size")= num 4720
[18:02:30.421]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:30.421]  - attr(*, "already-done")= logi TRUE
[18:02:30.438] - reassign environment for ‘...future.FUN’
[18:02:30.438] - copied ‘...future.FUN’ to environment
[18:02:30.438] - copied ‘future.call.arguments’ to environment
[18:02:30.439] - copied ‘...future.elements_ii’ to environment
[18:02:30.439] - copied ‘...future.seeds_ii’ to environment
[18:02:30.439] - copied ‘...future.globals.maxSize’ to environment
[18:02:30.440] assign_globals() ... done
[18:02:30.440] requestCore(): workers = 2
[18:02:30.444] MulticoreFuture started
[18:02:30.445] - Launch lazy future ... done
[18:02:30.445] run() for ‘MulticoreFuture’ ... done
[18:02:30.449] plan(): Setting new future strategy stack:
[18:02:30.453] Created future:
[18:02:30.449] List of future strategies:
[18:02:30.449] 1. sequential:
[18:02:30.449]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:30.449]    - tweaked: FALSE
[18:02:30.449]    - call: NULL
[18:02:30.463] plan(): nbrOfWorkers() = 1
[18:02:30.468] plan(): Setting new future strategy stack:
[18:02:30.468] List of future strategies:
[18:02:30.468] 1. multicore:
[18:02:30.468]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:30.468]    - tweaked: FALSE
[18:02:30.468]    - call: plan(strategy)
[18:02:30.453] MulticoreFuture:
[18:02:30.453] Label: ‘future_lapply-2’
[18:02:30.453] Expression:
[18:02:30.453] {
[18:02:30.453]     do.call(function(...) {
[18:02:30.453]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:30.453]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:30.453]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:30.453]             on.exit(options(oopts), add = TRUE)
[18:02:30.453]         }
[18:02:30.453]         {
[18:02:30.453]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:30.453]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:30.453]                 ...future.FUN(...future.X_jj, ...)
[18:02:30.453]             })
[18:02:30.453]         }
[18:02:30.453]     }, args = future.call.arguments)
[18:02:30.453] }
[18:02:30.453] Lazy evaluation: FALSE
[18:02:30.453] Asynchronous evaluation: TRUE
[18:02:30.453] Local evaluation: TRUE
[18:02:30.453] Environment: R_GlobalEnv
[18:02:30.453] Capture standard output: NA
[18:02:30.453] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:30.453] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:30.453] Packages: <none>
[18:02:30.453] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:30.453] Resolved: FALSE
[18:02:30.453] Value: <not collected>
[18:02:30.453] Conditions captured: <none>
[18:02:30.453] Early signaling: FALSE
[18:02:30.453] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:30.453] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:30.472] Chunk #2 of 2 ... DONE
[18:02:30.473] Launching 2 futures (chunks) ... DONE
[18:02:30.473] Resolving 2 futures (chunks) ...
[18:02:30.474] resolve() on list ...
[18:02:30.474]  recursive: 0
[18:02:30.475]  length: 2
[18:02:30.475] 
[18:02:30.479] plan(): nbrOfWorkers() = 2
[18:02:30.487] Future #2
[18:02:30.487] result() for MulticoreFuture ...
[18:02:30.489] result() for MulticoreFuture ...
[18:02:30.490] result() for MulticoreFuture ... done
[18:02:30.490] result() for MulticoreFuture ... done
[18:02:30.490] result() for MulticoreFuture ...
[18:02:30.491] result() for MulticoreFuture ... done
[18:02:30.491] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:02:30.491] - nx: 2
[18:02:30.492] - relay: TRUE
[18:02:30.492] - stdout: TRUE
[18:02:30.492] - signal: TRUE
[18:02:30.492] - resignal: FALSE
[18:02:30.493] - force: TRUE
[18:02:30.493] - relayed: [n=2] FALSE, FALSE
[18:02:30.493] - queued futures: [n=2] FALSE, FALSE
[18:02:30.494]  - until=1
[18:02:30.494]  - relaying element #1
[18:02:30.494] - relayed: [n=2] FALSE, FALSE
[18:02:30.495] - queued futures: [n=2] FALSE, TRUE
[18:02:30.495] signalConditionsASAP(NULL, pos=2) ... done
[18:02:30.495]  length: 1 (resolved future 2)
[18:02:30.874] plan(): Setting new future strategy stack:
[18:02:30.874] List of future strategies:
[18:02:30.874] 1. multicore:
[18:02:30.874]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:30.874]    - tweaked: FALSE
[18:02:30.874]    - call: plan(strategy)
[18:02:30.885] plan(): nbrOfWorkers() = 2
[18:02:30.886] Future #1
[18:02:30.886] result() for MulticoreFuture ...
[18:02:30.888] result() for MulticoreFuture ...
[18:02:30.888] result() for MulticoreFuture ... done
[18:02:30.889] result() for MulticoreFuture ... done
[18:02:30.889] result() for MulticoreFuture ...
[18:02:30.889] result() for MulticoreFuture ... done
[18:02:30.890] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:02:30.890] - nx: 2
[18:02:30.890] - relay: TRUE
[18:02:30.890] - stdout: TRUE
[18:02:30.891] - signal: TRUE
[18:02:30.891] - resignal: FALSE
[18:02:30.891] - force: TRUE
[18:02:30.891] - relayed: [n=2] FALSE, FALSE
[18:02:30.892] - queued futures: [n=2] FALSE, TRUE
[18:02:30.892]  - until=1
[18:02:30.892]  - relaying element #1
[18:02:30.892] result() for MulticoreFuture ...
[18:02:30.893] result() for MulticoreFuture ... done
[18:02:30.893] result() for MulticoreFuture ...
[18:02:30.893] result() for MulticoreFuture ... done
[18:02:30.893] result() for MulticoreFuture ...
[18:02:30.894] result() for MulticoreFuture ... done
[18:02:30.894] result() for MulticoreFuture ...
[18:02:30.894] result() for MulticoreFuture ... done
[18:02:30.894] - relayed: [n=2] TRUE, FALSE
[18:02:30.894] - queued futures: [n=2] TRUE, TRUE
[18:02:30.895] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:02:30.895]  length: 0 (resolved future 1)
[18:02:30.895] Relaying remaining futures
[18:02:30.895] signalConditionsASAP(NULL, pos=0) ...
[18:02:30.896] - nx: 2
[18:02:30.896] - relay: TRUE
[18:02:30.896] - stdout: TRUE
[18:02:30.896] - signal: TRUE
[18:02:30.896] - resignal: FALSE
[18:02:30.897] - force: TRUE
[18:02:30.897] - relayed: [n=2] TRUE, FALSE
[18:02:30.897] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:30.897]  - relaying element #2
[18:02:30.898] result() for MulticoreFuture ...
[18:02:30.898] result() for MulticoreFuture ... done
[18:02:30.898] result() for MulticoreFuture ...
[18:02:30.898] result() for MulticoreFuture ... done
[18:02:30.899] result() for MulticoreFuture ...
[18:02:30.899] result() for MulticoreFuture ... done
[18:02:30.899] result() for MulticoreFuture ...
[18:02:30.899] result() for MulticoreFuture ... done
[18:02:30.900] - relayed: [n=2] TRUE, TRUE
[18:02:30.900] - queued futures: [n=2] TRUE, TRUE
[18:02:30.900] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[18:02:30.900] resolve() on list ... DONE
[18:02:30.901] result() for MulticoreFuture ...
[18:02:30.901] result() for MulticoreFuture ... done
[18:02:30.901] result() for MulticoreFuture ...
[18:02:30.901] result() for MulticoreFuture ... done
[18:02:30.902] result() for MulticoreFuture ...
[18:02:30.902] result() for MulticoreFuture ... done
[18:02:30.902] result() for MulticoreFuture ...
[18:02:30.902] result() for MulticoreFuture ... done
[18:02:30.902]  - Number of value chunks collected: 2
[18:02:30.903] Resolving 2 futures (chunks) ... DONE
[18:02:30.903] Reducing values from 2 chunks ...
[18:02:30.903]  - Number of values collected after concatenation: 2
[18:02:30.903]  - Number of values expected: 2
[18:02:30.904] Reducing values from 2 chunks ... DONE
[18:02:30.904] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[18:02:30.905] future_mapply() ...
[18:02:30.912] Number of chunks: 2
[18:02:30.912] getGlobalsAndPackagesXApply() ...
[18:02:30.912]  - future.globals: TRUE
[18:02:30.913] getGlobalsAndPackages() ...
[18:02:30.913] Searching for globals...
[18:02:30.917] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:30.917] Searching for globals ... DONE
[18:02:30.917] Resolving globals: FALSE
[18:02:30.918] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:30.919] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:30.920] - globals: [1] ‘FUN’
[18:02:30.920] 
[18:02:30.920] getGlobalsAndPackages() ... DONE
[18:02:30.920]  - globals found/used: [n=1] ‘FUN’
[18:02:30.921]  - needed namespaces: [n=0] 
[18:02:30.921] Finding globals ... DONE
[18:02:30.921] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:30.921] List of 2
[18:02:30.921]  $ ...future.FUN:function (x, y)  
[18:02:30.921]  $ MoreArgs     : NULL
[18:02:30.921]  - attr(*, "where")=List of 2
[18:02:30.921]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:30.921]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:30.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:30.921]  - attr(*, "resolved")= logi FALSE
[18:02:30.921]  - attr(*, "total_size")= num NA
[18:02:30.927] Packages to be attached in all futures: [n=0] 
[18:02:30.927] getGlobalsAndPackagesXApply() ... DONE
[18:02:30.928] Number of futures (= number of chunks): 2
[18:02:30.928] Launching 2 futures (chunks) ...
[18:02:30.928] Chunk #1 of 2 ...
[18:02:30.929]  - Finding globals in '...' for chunk #1 ...
[18:02:30.929] getGlobalsAndPackages() ...
[18:02:30.929] Searching for globals...
[18:02:30.930] 
[18:02:30.930] Searching for globals ... DONE
[18:02:30.930] - globals: [0] <none>
[18:02:30.931] getGlobalsAndPackages() ... DONE
[18:02:30.931]    + additional globals found: [n=0] 
[18:02:30.931]    + additional namespaces needed: [n=0] 
[18:02:30.931]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:30.934]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:30.934]  - seeds: <none>
[18:02:30.935]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:30.935] getGlobalsAndPackages() ...
[18:02:30.935] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:30.935] Resolving globals: FALSE
[18:02:30.937] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[18:02:30.938] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:30.938] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:30.938] 
[18:02:30.939] getGlobalsAndPackages() ... DONE
[18:02:30.939] run() for ‘Future’ ...
[18:02:30.940] - state: ‘created’
[18:02:30.940] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:30.946] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:30.947] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:30.947]   - Field: ‘label’
[18:02:30.947]   - Field: ‘local’
[18:02:30.947]   - Field: ‘owner’
[18:02:30.947]   - Field: ‘envir’
[18:02:30.948]   - Field: ‘workers’
[18:02:30.948]   - Field: ‘packages’
[18:02:30.948]   - Field: ‘gc’
[18:02:30.948]   - Field: ‘job’
[18:02:30.949]   - Field: ‘conditions’
[18:02:30.949]   - Field: ‘expr’
[18:02:30.949]   - Field: ‘uuid’
[18:02:30.949]   - Field: ‘seed’
[18:02:30.949]   - Field: ‘version’
[18:02:30.950]   - Field: ‘result’
[18:02:30.950]   - Field: ‘asynchronous’
[18:02:30.950]   - Field: ‘calls’
[18:02:30.950]   - Field: ‘globals’
[18:02:30.950]   - Field: ‘stdout’
[18:02:30.951]   - Field: ‘earlySignal’
[18:02:30.951]   - Field: ‘lazy’
[18:02:30.951]   - Field: ‘state’
[18:02:30.951] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:30.951] - Launch lazy future ...
[18:02:30.952] Packages needed by the future expression (n = 0): <none>
[18:02:30.952] Packages needed by future strategies (n = 0): <none>
[18:02:30.953] {
[18:02:30.953]     {
[18:02:30.953]         {
[18:02:30.953]             ...future.startTime <- base::Sys.time()
[18:02:30.953]             {
[18:02:30.953]                 {
[18:02:30.953]                   {
[18:02:30.953]                     {
[18:02:30.953]                       base::local({
[18:02:30.953]                         has_future <- base::requireNamespace("future", 
[18:02:30.953]                           quietly = TRUE)
[18:02:30.953]                         if (has_future) {
[18:02:30.953]                           ns <- base::getNamespace("future")
[18:02:30.953]                           version <- ns[[".package"]][["version"]]
[18:02:30.953]                           if (is.null(version)) 
[18:02:30.953]                             version <- utils::packageVersion("future")
[18:02:30.953]                         }
[18:02:30.953]                         else {
[18:02:30.953]                           version <- NULL
[18:02:30.953]                         }
[18:02:30.953]                         if (!has_future || version < "1.8.0") {
[18:02:30.953]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:30.953]                             "", base::R.version$version.string), 
[18:02:30.953]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:30.953]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:30.953]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:30.953]                               "release", "version")], collapse = " "), 
[18:02:30.953]                             hostname = base::Sys.info()[["nodename"]])
[18:02:30.953]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:30.953]                             info)
[18:02:30.953]                           info <- base::paste(info, collapse = "; ")
[18:02:30.953]                           if (!has_future) {
[18:02:30.953]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:30.953]                               info)
[18:02:30.953]                           }
[18:02:30.953]                           else {
[18:02:30.953]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:30.953]                               info, version)
[18:02:30.953]                           }
[18:02:30.953]                           base::stop(msg)
[18:02:30.953]                         }
[18:02:30.953]                       })
[18:02:30.953]                     }
[18:02:30.953]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:30.953]                     base::options(mc.cores = 1L)
[18:02:30.953]                   }
[18:02:30.953]                   ...future.strategy.old <- future::plan("list")
[18:02:30.953]                   options(future.plan = NULL)
[18:02:30.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:30.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:30.953]                 }
[18:02:30.953]                 ...future.workdir <- getwd()
[18:02:30.953]             }
[18:02:30.953]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:30.953]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:30.953]         }
[18:02:30.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:30.953]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:30.953]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:30.953]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:30.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:30.953]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:30.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:30.953]             base::names(...future.oldOptions))
[18:02:30.953]     }
[18:02:30.953]     if (FALSE) {
[18:02:30.953]     }
[18:02:30.953]     else {
[18:02:30.953]         if (FALSE) {
[18:02:30.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:30.953]                 open = "w")
[18:02:30.953]         }
[18:02:30.953]         else {
[18:02:30.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:30.953]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:30.953]         }
[18:02:30.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:30.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:30.953]             base::sink(type = "output", split = FALSE)
[18:02:30.953]             base::close(...future.stdout)
[18:02:30.953]         }, add = TRUE)
[18:02:30.953]     }
[18:02:30.953]     ...future.frame <- base::sys.nframe()
[18:02:30.953]     ...future.conditions <- base::list()
[18:02:30.953]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:30.953]     if (FALSE) {
[18:02:30.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:30.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:30.953]     }
[18:02:30.953]     ...future.result <- base::tryCatch({
[18:02:30.953]         base::withCallingHandlers({
[18:02:30.953]             ...future.value <- base::withVisible(base::local({
[18:02:30.953]                 withCallingHandlers({
[18:02:30.953]                   {
[18:02:30.953]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:30.953]                     if (!identical(...future.globals.maxSize.org, 
[18:02:30.953]                       ...future.globals.maxSize)) {
[18:02:30.953]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:30.953]                       on.exit(options(oopts), add = TRUE)
[18:02:30.953]                     }
[18:02:30.953]                     {
[18:02:30.953]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:30.953]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:30.953]                         USE.NAMES = FALSE)
[18:02:30.953]                       do.call(mapply, args = args)
[18:02:30.953]                     }
[18:02:30.953]                   }
[18:02:30.953]                 }, immediateCondition = function(cond) {
[18:02:30.953]                   save_rds <- function (object, pathname, ...) 
[18:02:30.953]                   {
[18:02:30.953]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:30.953]                     if (file_test("-f", pathname_tmp)) {
[18:02:30.953]                       fi_tmp <- file.info(pathname_tmp)
[18:02:30.953]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:30.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:30.953]                         fi_tmp[["mtime"]])
[18:02:30.953]                     }
[18:02:30.953]                     tryCatch({
[18:02:30.953]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:30.953]                     }, error = function(ex) {
[18:02:30.953]                       msg <- conditionMessage(ex)
[18:02:30.953]                       fi_tmp <- file.info(pathname_tmp)
[18:02:30.953]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:30.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:30.953]                         fi_tmp[["mtime"]], msg)
[18:02:30.953]                       ex$message <- msg
[18:02:30.953]                       stop(ex)
[18:02:30.953]                     })
[18:02:30.953]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:30.953]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:30.953]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:30.953]                       fi_tmp <- file.info(pathname_tmp)
[18:02:30.953]                       fi <- file.info(pathname)
[18:02:30.953]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:30.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:30.953]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:30.953]                         fi[["size"]], fi[["mtime"]])
[18:02:30.953]                       stop(msg)
[18:02:30.953]                     }
[18:02:30.953]                     invisible(pathname)
[18:02:30.953]                   }
[18:02:30.953]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:30.953]                     rootPath = tempdir()) 
[18:02:30.953]                   {
[18:02:30.953]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:30.953]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:30.953]                       tmpdir = path, fileext = ".rds")
[18:02:30.953]                     save_rds(obj, file)
[18:02:30.953]                   }
[18:02:30.953]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1j8FfD/.future/immediateConditions")
[18:02:30.953]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:30.953]                   {
[18:02:30.953]                     inherits <- base::inherits
[18:02:30.953]                     invokeRestart <- base::invokeRestart
[18:02:30.953]                     is.null <- base::is.null
[18:02:30.953]                     muffled <- FALSE
[18:02:30.953]                     if (inherits(cond, "message")) {
[18:02:30.953]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:30.953]                       if (muffled) 
[18:02:30.953]                         invokeRestart("muffleMessage")
[18:02:30.953]                     }
[18:02:30.953]                     else if (inherits(cond, "warning")) {
[18:02:30.953]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:30.953]                       if (muffled) 
[18:02:30.953]                         invokeRestart("muffleWarning")
[18:02:30.953]                     }
[18:02:30.953]                     else if (inherits(cond, "condition")) {
[18:02:30.953]                       if (!is.null(pattern)) {
[18:02:30.953]                         computeRestarts <- base::computeRestarts
[18:02:30.953]                         grepl <- base::grepl
[18:02:30.953]                         restarts <- computeRestarts(cond)
[18:02:30.953]                         for (restart in restarts) {
[18:02:30.953]                           name <- restart$name
[18:02:30.953]                           if (is.null(name)) 
[18:02:30.953]                             next
[18:02:30.953]                           if (!grepl(pattern, name)) 
[18:02:30.953]                             next
[18:02:30.953]                           invokeRestart(restart)
[18:02:30.953]                           muffled <- TRUE
[18:02:30.953]                           break
[18:02:30.953]                         }
[18:02:30.953]                       }
[18:02:30.953]                     }
[18:02:30.953]                     invisible(muffled)
[18:02:30.953]                   }
[18:02:30.953]                   muffleCondition(cond)
[18:02:30.953]                 })
[18:02:30.953]             }))
[18:02:30.953]             future::FutureResult(value = ...future.value$value, 
[18:02:30.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:30.953]                   ...future.rng), globalenv = if (FALSE) 
[18:02:30.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:30.953]                     ...future.globalenv.names))
[18:02:30.953]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:30.953]         }, condition = base::local({
[18:02:30.953]             c <- base::c
[18:02:30.953]             inherits <- base::inherits
[18:02:30.953]             invokeRestart <- base::invokeRestart
[18:02:30.953]             length <- base::length
[18:02:30.953]             list <- base::list
[18:02:30.953]             seq.int <- base::seq.int
[18:02:30.953]             signalCondition <- base::signalCondition
[18:02:30.953]             sys.calls <- base::sys.calls
[18:02:30.953]             `[[` <- base::`[[`
[18:02:30.953]             `+` <- base::`+`
[18:02:30.953]             `<<-` <- base::`<<-`
[18:02:30.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:30.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:30.953]                   3L)]
[18:02:30.953]             }
[18:02:30.953]             function(cond) {
[18:02:30.953]                 is_error <- inherits(cond, "error")
[18:02:30.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:30.953]                   NULL)
[18:02:30.953]                 if (is_error) {
[18:02:30.953]                   sessionInformation <- function() {
[18:02:30.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:30.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:30.953]                       search = base::search(), system = base::Sys.info())
[18:02:30.953]                   }
[18:02:30.953]                   ...future.conditions[[length(...future.conditions) + 
[18:02:30.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:30.953]                     cond$call), session = sessionInformation(), 
[18:02:30.953]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:30.953]                   signalCondition(cond)
[18:02:30.953]                 }
[18:02:30.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:30.953]                 "immediateCondition"))) {
[18:02:30.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:30.953]                   ...future.conditions[[length(...future.conditions) + 
[18:02:30.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:30.953]                   if (TRUE && !signal) {
[18:02:30.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:30.953]                     {
[18:02:30.953]                       inherits <- base::inherits
[18:02:30.953]                       invokeRestart <- base::invokeRestart
[18:02:30.953]                       is.null <- base::is.null
[18:02:30.953]                       muffled <- FALSE
[18:02:30.953]                       if (inherits(cond, "message")) {
[18:02:30.953]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:30.953]                         if (muffled) 
[18:02:30.953]                           invokeRestart("muffleMessage")
[18:02:30.953]                       }
[18:02:30.953]                       else if (inherits(cond, "warning")) {
[18:02:30.953]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:30.953]                         if (muffled) 
[18:02:30.953]                           invokeRestart("muffleWarning")
[18:02:30.953]                       }
[18:02:30.953]                       else if (inherits(cond, "condition")) {
[18:02:30.953]                         if (!is.null(pattern)) {
[18:02:30.953]                           computeRestarts <- base::computeRestarts
[18:02:30.953]                           grepl <- base::grepl
[18:02:30.953]                           restarts <- computeRestarts(cond)
[18:02:30.953]                           for (restart in restarts) {
[18:02:30.953]                             name <- restart$name
[18:02:30.953]                             if (is.null(name)) 
[18:02:30.953]                               next
[18:02:30.953]                             if (!grepl(pattern, name)) 
[18:02:30.953]                               next
[18:02:30.953]                             invokeRestart(restart)
[18:02:30.953]                             muffled <- TRUE
[18:02:30.953]                             break
[18:02:30.953]                           }
[18:02:30.953]                         }
[18:02:30.953]                       }
[18:02:30.953]                       invisible(muffled)
[18:02:30.953]                     }
[18:02:30.953]                     muffleCondition(cond, pattern = "^muffle")
[18:02:30.953]                   }
[18:02:30.953]                 }
[18:02:30.953]                 else {
[18:02:30.953]                   if (TRUE) {
[18:02:30.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:30.953]                     {
[18:02:30.953]                       inherits <- base::inherits
[18:02:30.953]                       invokeRestart <- base::invokeRestart
[18:02:30.953]                       is.null <- base::is.null
[18:02:30.953]                       muffled <- FALSE
[18:02:30.953]                       if (inherits(cond, "message")) {
[18:02:30.953]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:30.953]                         if (muffled) 
[18:02:30.953]                           invokeRestart("muffleMessage")
[18:02:30.953]                       }
[18:02:30.953]                       else if (inherits(cond, "warning")) {
[18:02:30.953]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:30.953]                         if (muffled) 
[18:02:30.953]                           invokeRestart("muffleWarning")
[18:02:30.953]                       }
[18:02:30.953]                       else if (inherits(cond, "condition")) {
[18:02:30.953]                         if (!is.null(pattern)) {
[18:02:30.953]                           computeRestarts <- base::computeRestarts
[18:02:30.953]                           grepl <- base::grepl
[18:02:30.953]                           restarts <- computeRestarts(cond)
[18:02:30.953]                           for (restart in restarts) {
[18:02:30.953]                             name <- restart$name
[18:02:30.953]                             if (is.null(name)) 
[18:02:30.953]                               next
[18:02:30.953]                             if (!grepl(pattern, name)) 
[18:02:30.953]                               next
[18:02:30.953]                             invokeRestart(restart)
[18:02:30.953]                             muffled <- TRUE
[18:02:30.953]                             break
[18:02:30.953]                           }
[18:02:30.953]                         }
[18:02:30.953]                       }
[18:02:30.953]                       invisible(muffled)
[18:02:30.953]                     }
[18:02:30.953]                     muffleCondition(cond, pattern = "^muffle")
[18:02:30.953]                   }
[18:02:30.953]                 }
[18:02:30.953]             }
[18:02:30.953]         }))
[18:02:30.953]     }, error = function(ex) {
[18:02:30.953]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:30.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:30.953]                 ...future.rng), started = ...future.startTime, 
[18:02:30.953]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:30.953]             version = "1.8"), class = "FutureResult")
[18:02:30.953]     }, finally = {
[18:02:30.953]         if (!identical(...future.workdir, getwd())) 
[18:02:30.953]             setwd(...future.workdir)
[18:02:30.953]         {
[18:02:30.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:30.953]                 ...future.oldOptions$nwarnings <- NULL
[18:02:30.953]             }
[18:02:30.953]             base::options(...future.oldOptions)
[18:02:30.953]             if (.Platform$OS.type == "windows") {
[18:02:30.953]                 old_names <- names(...future.oldEnvVars)
[18:02:30.953]                 envs <- base::Sys.getenv()
[18:02:30.953]                 names <- names(envs)
[18:02:30.953]                 common <- intersect(names, old_names)
[18:02:30.953]                 added <- setdiff(names, old_names)
[18:02:30.953]                 removed <- setdiff(old_names, names)
[18:02:30.953]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:30.953]                   envs[common]]
[18:02:30.953]                 NAMES <- toupper(changed)
[18:02:30.953]                 args <- list()
[18:02:30.953]                 for (kk in seq_along(NAMES)) {
[18:02:30.953]                   name <- changed[[kk]]
[18:02:30.953]                   NAME <- NAMES[[kk]]
[18:02:30.953]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:30.953]                     next
[18:02:30.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:30.953]                 }
[18:02:30.953]                 NAMES <- toupper(added)
[18:02:30.953]                 for (kk in seq_along(NAMES)) {
[18:02:30.953]                   name <- added[[kk]]
[18:02:30.953]                   NAME <- NAMES[[kk]]
[18:02:30.953]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:30.953]                     next
[18:02:30.953]                   args[[name]] <- ""
[18:02:30.953]                 }
[18:02:30.953]                 NAMES <- toupper(removed)
[18:02:30.953]                 for (kk in seq_along(NAMES)) {
[18:02:30.953]                   name <- removed[[kk]]
[18:02:30.953]                   NAME <- NAMES[[kk]]
[18:02:30.953]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:30.953]                     next
[18:02:30.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:30.953]                 }
[18:02:30.953]                 if (length(args) > 0) 
[18:02:30.953]                   base::do.call(base::Sys.setenv, args = args)
[18:02:30.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:30.953]             }
[18:02:30.953]             else {
[18:02:30.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:30.953]             }
[18:02:30.953]             {
[18:02:30.953]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:30.953]                   0L) {
[18:02:30.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:30.953]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:30.953]                   base::options(opts)
[18:02:30.953]                 }
[18:02:30.953]                 {
[18:02:30.953]                   {
[18:02:30.953]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:30.953]                     NULL
[18:02:30.953]                   }
[18:02:30.953]                   options(future.plan = NULL)
[18:02:30.953]                   if (is.na(NA_character_)) 
[18:02:30.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:30.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:30.953]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:30.953]                     .init = FALSE)
[18:02:30.953]                 }
[18:02:30.953]             }
[18:02:30.953]         }
[18:02:30.953]     })
[18:02:30.953]     if (TRUE) {
[18:02:30.953]         base::sink(type = "output", split = FALSE)
[18:02:30.953]         if (FALSE) {
[18:02:30.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:30.953]         }
[18:02:30.953]         else {
[18:02:30.953]             ...future.result["stdout"] <- base::list(NULL)
[18:02:30.953]         }
[18:02:30.953]         base::close(...future.stdout)
[18:02:30.953]         ...future.stdout <- NULL
[18:02:30.953]     }
[18:02:30.953]     ...future.result$conditions <- ...future.conditions
[18:02:30.953]     ...future.result$finished <- base::Sys.time()
[18:02:30.953]     ...future.result
[18:02:30.953] }
[18:02:30.958] assign_globals() ...
[18:02:30.958] List of 5
[18:02:30.958]  $ ...future.FUN            :function (x, y)  
[18:02:30.958]  $ MoreArgs                 : NULL
[18:02:30.958]  $ ...future.elements_ii    :List of 2
[18:02:30.958]   ..$ :List of 1
[18:02:30.958]   .. ..$ : int 1
[18:02:30.958]   ..$ :List of 1
[18:02:30.958]   .. ..$ : int 0
[18:02:30.958]  $ ...future.seeds_ii       : NULL
[18:02:30.958]  $ ...future.globals.maxSize: NULL
[18:02:30.958]  - attr(*, "where")=List of 5
[18:02:30.958]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:30.958]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:30.958]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:30.958]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:30.958]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:30.958]  - attr(*, "resolved")= logi FALSE
[18:02:30.958]  - attr(*, "total_size")= num 6368
[18:02:30.958]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:30.958]  - attr(*, "already-done")= logi TRUE
[18:02:30.969] - reassign environment for ‘...future.FUN’
[18:02:30.970] - copied ‘...future.FUN’ to environment
[18:02:30.970] - copied ‘MoreArgs’ to environment
[18:02:30.970] - copied ‘...future.elements_ii’ to environment
[18:02:30.970] - copied ‘...future.seeds_ii’ to environment
[18:02:30.970] - copied ‘...future.globals.maxSize’ to environment
[18:02:30.971] assign_globals() ... done
[18:02:30.971] requestCore(): workers = 2
[18:02:30.974] MulticoreFuture started
[18:02:30.975] - Launch lazy future ... done
[18:02:30.975] run() for ‘MulticoreFuture’ ... done
[18:02:30.976] Created future:
[18:02:30.976] plan(): Setting new future strategy stack:
[18:02:30.977] List of future strategies:
[18:02:30.977] 1. sequential:
[18:02:30.977]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:30.977]    - tweaked: FALSE
[18:02:30.977]    - call: NULL
[18:02:30.979] plan(): nbrOfWorkers() = 1
[18:02:30.976] MulticoreFuture:
[18:02:30.976] Label: ‘future_mapply-1’
[18:02:30.976] Expression:
[18:02:30.976] {
[18:02:30.976]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:30.976]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:30.976]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:30.976]         on.exit(options(oopts), add = TRUE)
[18:02:30.976]     }
[18:02:30.976]     {
[18:02:30.976]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:30.976]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:30.976]         do.call(mapply, args = args)
[18:02:30.976]     }
[18:02:30.976] }
[18:02:30.976] Lazy evaluation: FALSE
[18:02:30.976] Asynchronous evaluation: TRUE
[18:02:30.976] Local evaluation: TRUE
[18:02:30.976] Environment: R_GlobalEnv
[18:02:30.976] Capture standard output: FALSE
[18:02:30.976] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:30.976] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:30.976] Packages: <none>
[18:02:30.976] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:30.976] Resolved: FALSE
[18:02:30.976] Value: <not collected>
[18:02:30.976] Conditions captured: <none>
[18:02:30.976] Early signaling: FALSE
[18:02:30.976] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:30.976] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:30.992] Chunk #1 of 2 ... DONE
[18:02:30.992] Chunk #2 of 2 ...
[18:02:30.993]  - Finding globals in '...' for chunk #2 ...
[18:02:30.993] getGlobalsAndPackages() ...
[18:02:30.993] Searching for globals...
[18:02:30.995] 
[18:02:30.995] Searching for globals ... DONE
[18:02:30.995] - globals: [0] <none>
[18:02:30.996] getGlobalsAndPackages() ... DONE
[18:02:30.996]    + additional globals found: [n=0] 
[18:02:30.996]    + additional namespaces needed: [n=0] 
[18:02:30.997]  - Finding globals in '...' for chunk #2 ... DONE
[18:02:30.997]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:30.997]  - seeds: <none>
[18:02:30.998]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:30.998] getGlobalsAndPackages() ...
[18:02:30.998] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:30.999] Resolving globals: FALSE
[18:02:31.001] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[18:02:31.002] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:31.003] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:31.003] 
[18:02:31.003] getGlobalsAndPackages() ... DONE
[18:02:31.005] run() for ‘Future’ ...
[18:02:31.005] - state: ‘created’
[18:02:31.006] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:31.015] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:31.015] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:31.016]   - Field: ‘label’
[18:02:31.016]   - Field: ‘local’
[18:02:31.016]   - Field: ‘owner’
[18:02:31.017]   - Field: ‘envir’
[18:02:31.017]   - Field: ‘workers’
[18:02:31.017]   - Field: ‘packages’
[18:02:31.018]   - Field: ‘gc’
[18:02:31.018]   - Field: ‘job’
[18:02:31.019]   - Field: ‘conditions’
[18:02:31.019]   - Field: ‘expr’
[18:02:31.019]   - Field: ‘uuid’
[18:02:31.020]   - Field: ‘seed’
[18:02:31.020]   - Field: ‘version’
[18:02:31.020]   - Field: ‘result’
[18:02:31.020]   - Field: ‘asynchronous’
[18:02:31.021]   - Field: ‘calls’
[18:02:31.021]   - Field: ‘globals’
[18:02:31.021]   - Field: ‘stdout’
[18:02:31.022]   - Field: ‘earlySignal’
[18:02:31.022]   - Field: ‘lazy’
[18:02:31.022]   - Field: ‘state’
[18:02:31.023] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:31.023] - Launch lazy future ...
[18:02:31.029] Packages needed by the future expression (n = 0): <none>
[18:02:31.030] Packages needed by future strategies (n = 0): <none>
[18:02:31.033] {
[18:02:31.033]     {
[18:02:31.033]         {
[18:02:31.033]             ...future.startTime <- base::Sys.time()
[18:02:31.033]             {
[18:02:31.033]                 {
[18:02:31.033]                   {
[18:02:31.033]                     {
[18:02:31.033]                       base::local({
[18:02:31.033]                         has_future <- base::requireNamespace("future", 
[18:02:31.033]                           quietly = TRUE)
[18:02:31.033]                         if (has_future) {
[18:02:31.033]                           ns <- base::getNamespace("future")
[18:02:31.033]                           version <- ns[[".package"]][["version"]]
[18:02:31.033]                           if (is.null(version)) 
[18:02:31.033]                             version <- utils::packageVersion("future")
[18:02:31.033]                         }
[18:02:31.033]                         else {
[18:02:31.033]                           version <- NULL
[18:02:31.033]                         }
[18:02:31.033]                         if (!has_future || version < "1.8.0") {
[18:02:31.033]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:31.033]                             "", base::R.version$version.string), 
[18:02:31.033]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:31.033]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:31.033]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:31.033]                               "release", "version")], collapse = " "), 
[18:02:31.033]                             hostname = base::Sys.info()[["nodename"]])
[18:02:31.033]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:31.033]                             info)
[18:02:31.033]                           info <- base::paste(info, collapse = "; ")
[18:02:31.033]                           if (!has_future) {
[18:02:31.033]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:31.033]                               info)
[18:02:31.033]                           }
[18:02:31.033]                           else {
[18:02:31.033]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:31.033]                               info, version)
[18:02:31.033]                           }
[18:02:31.033]                           base::stop(msg)
[18:02:31.033]                         }
[18:02:31.033]                       })
[18:02:31.033]                     }
[18:02:31.033]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:31.033]                     base::options(mc.cores = 1L)
[18:02:31.033]                   }
[18:02:31.033]                   ...future.strategy.old <- future::plan("list")
[18:02:31.033]                   options(future.plan = NULL)
[18:02:31.033]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:31.033]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:31.033]                 }
[18:02:31.033]                 ...future.workdir <- getwd()
[18:02:31.033]             }
[18:02:31.033]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:31.033]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:31.033]         }
[18:02:31.033]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:31.033]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:31.033]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:31.033]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:31.033]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:31.033]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:31.033]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:31.033]             base::names(...future.oldOptions))
[18:02:31.033]     }
[18:02:31.033]     if (FALSE) {
[18:02:31.033]     }
[18:02:31.033]     else {
[18:02:31.033]         if (FALSE) {
[18:02:31.033]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:31.033]                 open = "w")
[18:02:31.033]         }
[18:02:31.033]         else {
[18:02:31.033]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:31.033]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:31.033]         }
[18:02:31.033]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:31.033]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:31.033]             base::sink(type = "output", split = FALSE)
[18:02:31.033]             base::close(...future.stdout)
[18:02:31.033]         }, add = TRUE)
[18:02:31.033]     }
[18:02:31.033]     ...future.frame <- base::sys.nframe()
[18:02:31.033]     ...future.conditions <- base::list()
[18:02:31.033]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:31.033]     if (FALSE) {
[18:02:31.033]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:31.033]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:31.033]     }
[18:02:31.033]     ...future.result <- base::tryCatch({
[18:02:31.033]         base::withCallingHandlers({
[18:02:31.033]             ...future.value <- base::withVisible(base::local({
[18:02:31.033]                 withCallingHandlers({
[18:02:31.033]                   {
[18:02:31.033]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:31.033]                     if (!identical(...future.globals.maxSize.org, 
[18:02:31.033]                       ...future.globals.maxSize)) {
[18:02:31.033]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:31.033]                       on.exit(options(oopts), add = TRUE)
[18:02:31.033]                     }
[18:02:31.033]                     {
[18:02:31.033]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:31.033]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:31.033]                         USE.NAMES = FALSE)
[18:02:31.033]                       do.call(mapply, args = args)
[18:02:31.033]                     }
[18:02:31.033]                   }
[18:02:31.033]                 }, immediateCondition = function(cond) {
[18:02:31.033]                   save_rds <- function (object, pathname, ...) 
[18:02:31.033]                   {
[18:02:31.033]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:31.033]                     if (file_test("-f", pathname_tmp)) {
[18:02:31.033]                       fi_tmp <- file.info(pathname_tmp)
[18:02:31.033]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:31.033]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:31.033]                         fi_tmp[["mtime"]])
[18:02:31.033]                     }
[18:02:31.033]                     tryCatch({
[18:02:31.033]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:31.033]                     }, error = function(ex) {
[18:02:31.033]                       msg <- conditionMessage(ex)
[18:02:31.033]                       fi_tmp <- file.info(pathname_tmp)
[18:02:31.033]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:31.033]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:31.033]                         fi_tmp[["mtime"]], msg)
[18:02:31.033]                       ex$message <- msg
[18:02:31.033]                       stop(ex)
[18:02:31.033]                     })
[18:02:31.033]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:31.033]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:31.033]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:31.033]                       fi_tmp <- file.info(pathname_tmp)
[18:02:31.033]                       fi <- file.info(pathname)
[18:02:31.033]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:31.033]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:31.033]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:31.033]                         fi[["size"]], fi[["mtime"]])
[18:02:31.033]                       stop(msg)
[18:02:31.033]                     }
[18:02:31.033]                     invisible(pathname)
[18:02:31.033]                   }
[18:02:31.033]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:31.033]                     rootPath = tempdir()) 
[18:02:31.033]                   {
[18:02:31.033]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:31.033]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:31.033]                       tmpdir = path, fileext = ".rds")
[18:02:31.033]                     save_rds(obj, file)
[18:02:31.033]                   }
[18:02:31.033]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1j8FfD/.future/immediateConditions")
[18:02:31.033]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:31.033]                   {
[18:02:31.033]                     inherits <- base::inherits
[18:02:31.033]                     invokeRestart <- base::invokeRestart
[18:02:31.033]                     is.null <- base::is.null
[18:02:31.033]                     muffled <- FALSE
[18:02:31.033]                     if (inherits(cond, "message")) {
[18:02:31.033]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:31.033]                       if (muffled) 
[18:02:31.033]                         invokeRestart("muffleMessage")
[18:02:31.033]                     }
[18:02:31.033]                     else if (inherits(cond, "warning")) {
[18:02:31.033]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:31.033]                       if (muffled) 
[18:02:31.033]                         invokeRestart("muffleWarning")
[18:02:31.033]                     }
[18:02:31.033]                     else if (inherits(cond, "condition")) {
[18:02:31.033]                       if (!is.null(pattern)) {
[18:02:31.033]                         computeRestarts <- base::computeRestarts
[18:02:31.033]                         grepl <- base::grepl
[18:02:31.033]                         restarts <- computeRestarts(cond)
[18:02:31.033]                         for (restart in restarts) {
[18:02:31.033]                           name <- restart$name
[18:02:31.033]                           if (is.null(name)) 
[18:02:31.033]                             next
[18:02:31.033]                           if (!grepl(pattern, name)) 
[18:02:31.033]                             next
[18:02:31.033]                           invokeRestart(restart)
[18:02:31.033]                           muffled <- TRUE
[18:02:31.033]                           break
[18:02:31.033]                         }
[18:02:31.033]                       }
[18:02:31.033]                     }
[18:02:31.033]                     invisible(muffled)
[18:02:31.033]                   }
[18:02:31.033]                   muffleCondition(cond)
[18:02:31.033]                 })
[18:02:31.033]             }))
[18:02:31.033]             future::FutureResult(value = ...future.value$value, 
[18:02:31.033]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:31.033]                   ...future.rng), globalenv = if (FALSE) 
[18:02:31.033]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:31.033]                     ...future.globalenv.names))
[18:02:31.033]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:31.033]         }, condition = base::local({
[18:02:31.033]             c <- base::c
[18:02:31.033]             inherits <- base::inherits
[18:02:31.033]             invokeRestart <- base::invokeRestart
[18:02:31.033]             length <- base::length
[18:02:31.033]             list <- base::list
[18:02:31.033]             seq.int <- base::seq.int
[18:02:31.033]             signalCondition <- base::signalCondition
[18:02:31.033]             sys.calls <- base::sys.calls
[18:02:31.033]             `[[` <- base::`[[`
[18:02:31.033]             `+` <- base::`+`
[18:02:31.033]             `<<-` <- base::`<<-`
[18:02:31.033]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:31.033]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:31.033]                   3L)]
[18:02:31.033]             }
[18:02:31.033]             function(cond) {
[18:02:31.033]                 is_error <- inherits(cond, "error")
[18:02:31.033]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:31.033]                   NULL)
[18:02:31.033]                 if (is_error) {
[18:02:31.033]                   sessionInformation <- function() {
[18:02:31.033]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:31.033]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:31.033]                       search = base::search(), system = base::Sys.info())
[18:02:31.033]                   }
[18:02:31.033]                   ...future.conditions[[length(...future.conditions) + 
[18:02:31.033]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:31.033]                     cond$call), session = sessionInformation(), 
[18:02:31.033]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:31.033]                   signalCondition(cond)
[18:02:31.033]                 }
[18:02:31.033]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:31.033]                 "immediateCondition"))) {
[18:02:31.033]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:31.033]                   ...future.conditions[[length(...future.conditions) + 
[18:02:31.033]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:31.033]                   if (TRUE && !signal) {
[18:02:31.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:31.033]                     {
[18:02:31.033]                       inherits <- base::inherits
[18:02:31.033]                       invokeRestart <- base::invokeRestart
[18:02:31.033]                       is.null <- base::is.null
[18:02:31.033]                       muffled <- FALSE
[18:02:31.033]                       if (inherits(cond, "message")) {
[18:02:31.033]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:31.033]                         if (muffled) 
[18:02:31.033]                           invokeRestart("muffleMessage")
[18:02:31.033]                       }
[18:02:31.033]                       else if (inherits(cond, "warning")) {
[18:02:31.033]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:31.033]                         if (muffled) 
[18:02:31.033]                           invokeRestart("muffleWarning")
[18:02:31.033]                       }
[18:02:31.033]                       else if (inherits(cond, "condition")) {
[18:02:31.033]                         if (!is.null(pattern)) {
[18:02:31.033]                           computeRestarts <- base::computeRestarts
[18:02:31.033]                           grepl <- base::grepl
[18:02:31.033]                           restarts <- computeRestarts(cond)
[18:02:31.033]                           for (restart in restarts) {
[18:02:31.033]                             name <- restart$name
[18:02:31.033]                             if (is.null(name)) 
[18:02:31.033]                               next
[18:02:31.033]                             if (!grepl(pattern, name)) 
[18:02:31.033]                               next
[18:02:31.033]                             invokeRestart(restart)
[18:02:31.033]                             muffled <- TRUE
[18:02:31.033]                             break
[18:02:31.033]                           }
[18:02:31.033]                         }
[18:02:31.033]                       }
[18:02:31.033]                       invisible(muffled)
[18:02:31.033]                     }
[18:02:31.033]                     muffleCondition(cond, pattern = "^muffle")
[18:02:31.033]                   }
[18:02:31.033]                 }
[18:02:31.033]                 else {
[18:02:31.033]                   if (TRUE) {
[18:02:31.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:31.033]                     {
[18:02:31.033]                       inherits <- base::inherits
[18:02:31.033]                       invokeRestart <- base::invokeRestart
[18:02:31.033]                       is.null <- base::is.null
[18:02:31.033]                       muffled <- FALSE
[18:02:31.033]                       if (inherits(cond, "message")) {
[18:02:31.033]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:31.033]                         if (muffled) 
[18:02:31.033]                           invokeRestart("muffleMessage")
[18:02:31.033]                       }
[18:02:31.033]                       else if (inherits(cond, "warning")) {
[18:02:31.033]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:31.033]                         if (muffled) 
[18:02:31.033]                           invokeRestart("muffleWarning")
[18:02:31.033]                       }
[18:02:31.033]                       else if (inherits(cond, "condition")) {
[18:02:31.033]                         if (!is.null(pattern)) {
[18:02:31.033]                           computeRestarts <- base::computeRestarts
[18:02:31.033]                           grepl <- base::grepl
[18:02:31.033]                           restarts <- computeRestarts(cond)
[18:02:31.033]                           for (restart in restarts) {
[18:02:31.033]                             name <- restart$name
[18:02:31.033]                             if (is.null(name)) 
[18:02:31.033]                               next
[18:02:31.033]                             if (!grepl(pattern, name)) 
[18:02:31.033]                               next
[18:02:31.033]                             invokeRestart(restart)
[18:02:31.033]                             muffled <- TRUE
[18:02:31.033]                             break
[18:02:31.033]                           }
[18:02:31.033]                         }
[18:02:31.033]                       }
[18:02:31.033]                       invisible(muffled)
[18:02:31.033]                     }
[18:02:31.033]                     muffleCondition(cond, pattern = "^muffle")
[18:02:31.033]                   }
[18:02:31.033]                 }
[18:02:31.033]             }
[18:02:31.033]         }))
[18:02:31.033]     }, error = function(ex) {
[18:02:31.033]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:31.033]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:31.033]                 ...future.rng), started = ...future.startTime, 
[18:02:31.033]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:31.033]             version = "1.8"), class = "FutureResult")
[18:02:31.033]     }, finally = {
[18:02:31.033]         if (!identical(...future.workdir, getwd())) 
[18:02:31.033]             setwd(...future.workdir)
[18:02:31.033]         {
[18:02:31.033]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:31.033]                 ...future.oldOptions$nwarnings <- NULL
[18:02:31.033]             }
[18:02:31.033]             base::options(...future.oldOptions)
[18:02:31.033]             if (.Platform$OS.type == "windows") {
[18:02:31.033]                 old_names <- names(...future.oldEnvVars)
[18:02:31.033]                 envs <- base::Sys.getenv()
[18:02:31.033]                 names <- names(envs)
[18:02:31.033]                 common <- intersect(names, old_names)
[18:02:31.033]                 added <- setdiff(names, old_names)
[18:02:31.033]                 removed <- setdiff(old_names, names)
[18:02:31.033]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:31.033]                   envs[common]]
[18:02:31.033]                 NAMES <- toupper(changed)
[18:02:31.033]                 args <- list()
[18:02:31.033]                 for (kk in seq_along(NAMES)) {
[18:02:31.033]                   name <- changed[[kk]]
[18:02:31.033]                   NAME <- NAMES[[kk]]
[18:02:31.033]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:31.033]                     next
[18:02:31.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:31.033]                 }
[18:02:31.033]                 NAMES <- toupper(added)
[18:02:31.033]                 for (kk in seq_along(NAMES)) {
[18:02:31.033]                   name <- added[[kk]]
[18:02:31.033]                   NAME <- NAMES[[kk]]
[18:02:31.033]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:31.033]                     next
[18:02:31.033]                   args[[name]] <- ""
[18:02:31.033]                 }
[18:02:31.033]                 NAMES <- toupper(removed)
[18:02:31.033]                 for (kk in seq_along(NAMES)) {
[18:02:31.033]                   name <- removed[[kk]]
[18:02:31.033]                   NAME <- NAMES[[kk]]
[18:02:31.033]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:31.033]                     next
[18:02:31.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:31.033]                 }
[18:02:31.033]                 if (length(args) > 0) 
[18:02:31.033]                   base::do.call(base::Sys.setenv, args = args)
[18:02:31.033]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:31.033]             }
[18:02:31.033]             else {
[18:02:31.033]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:31.033]             }
[18:02:31.033]             {
[18:02:31.033]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:31.033]                   0L) {
[18:02:31.033]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:31.033]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:31.033]                   base::options(opts)
[18:02:31.033]                 }
[18:02:31.033]                 {
[18:02:31.033]                   {
[18:02:31.033]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:31.033]                     NULL
[18:02:31.033]                   }
[18:02:31.033]                   options(future.plan = NULL)
[18:02:31.033]                   if (is.na(NA_character_)) 
[18:02:31.033]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:31.033]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:31.033]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:31.033]                     .init = FALSE)
[18:02:31.033]                 }
[18:02:31.033]             }
[18:02:31.033]         }
[18:02:31.033]     })
[18:02:31.033]     if (TRUE) {
[18:02:31.033]         base::sink(type = "output", split = FALSE)
[18:02:31.033]         if (FALSE) {
[18:02:31.033]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:31.033]         }
[18:02:31.033]         else {
[18:02:31.033]             ...future.result["stdout"] <- base::list(NULL)
[18:02:31.033]         }
[18:02:31.033]         base::close(...future.stdout)
[18:02:31.033]         ...future.stdout <- NULL
[18:02:31.033]     }
[18:02:31.033]     ...future.result$conditions <- ...future.conditions
[18:02:31.033]     ...future.result$finished <- base::Sys.time()
[18:02:31.033]     ...future.result
[18:02:31.033] }
[18:02:31.039] assign_globals() ...
[18:02:31.039] List of 5
[18:02:31.039]  $ ...future.FUN            :function (x, y)  
[18:02:31.039]  $ MoreArgs                 : NULL
[18:02:31.039]  $ ...future.elements_ii    :List of 2
[18:02:31.039]   ..$ :List of 1
[18:02:31.039]   .. ..$ : int 0
[18:02:31.039]   ..$ :List of 1
[18:02:31.039]   .. ..$ : int 1
[18:02:31.039]  $ ...future.seeds_ii       : NULL
[18:02:31.039]  $ ...future.globals.maxSize: NULL
[18:02:31.039]  - attr(*, "where")=List of 5
[18:02:31.039]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:31.039]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:31.039]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:31.039]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:31.039]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:31.039]  - attr(*, "resolved")= logi FALSE
[18:02:31.039]  - attr(*, "total_size")= num 6368
[18:02:31.039]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:31.039]  - attr(*, "already-done")= logi TRUE
[18:02:31.057] - reassign environment for ‘...future.FUN’
[18:02:31.057] - copied ‘...future.FUN’ to environment
[18:02:31.058] - copied ‘MoreArgs’ to environment
[18:02:31.058] - copied ‘...future.elements_ii’ to environment
[18:02:31.058] - copied ‘...future.seeds_ii’ to environment
[18:02:31.058] - copied ‘...future.globals.maxSize’ to environment
[18:02:31.059] assign_globals() ... done
[18:02:31.059] requestCore(): workers = 2
[18:02:31.063] MulticoreFuture started
[18:02:31.063] - Launch lazy future ... done
[18:02:31.064] run() for ‘MulticoreFuture’ ... done
[18:02:31.064] Created future:
[18:02:31.064] plan(): Setting new future strategy stack:
[18:02:31.065] List of future strategies:
[18:02:31.065] 1. sequential:
[18:02:31.065]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:31.065]    - tweaked: FALSE
[18:02:31.065]    - call: NULL
[18:02:31.067] plan(): nbrOfWorkers() = 1
[18:02:31.072] plan(): Setting new future strategy stack:
[18:02:31.072] List of future strategies:
[18:02:31.072] 1. multicore:
[18:02:31.072]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:31.072]    - tweaked: FALSE
[18:02:31.072]    - call: plan(strategy)
[18:02:31.065] MulticoreFuture:
[18:02:31.065] Label: ‘future_mapply-2’
[18:02:31.065] Expression:
[18:02:31.065] {
[18:02:31.065]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:31.065]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:31.065]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:31.065]         on.exit(options(oopts), add = TRUE)
[18:02:31.065]     }
[18:02:31.065]     {
[18:02:31.065]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:31.065]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:31.065]         do.call(mapply, args = args)
[18:02:31.065]     }
[18:02:31.065] }
[18:02:31.065] Lazy evaluation: FALSE
[18:02:31.065] Asynchronous evaluation: TRUE
[18:02:31.065] Local evaluation: TRUE
[18:02:31.065] Environment: R_GlobalEnv
[18:02:31.065] Capture standard output: FALSE
[18:02:31.065] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:31.065] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:31.065] Packages: <none>
[18:02:31.065] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:31.065] Resolved: FALSE
[18:02:31.065] Value: <not collected>
[18:02:31.065] Conditions captured: <none>
[18:02:31.065] Early signaling: FALSE
[18:02:31.065] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:31.065] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:31.080] Chunk #2 of 2 ... DONE
[18:02:31.080] Launching 2 futures (chunks) ... DONE
[18:02:31.080] Resolving 2 futures (chunks) ...
[18:02:31.081] resolve() on list ...
[18:02:31.081] plan(): nbrOfWorkers() = 2
[18:02:31.081]  recursive: 0
[18:02:31.082]  length: 2
[18:02:31.082] 
[18:02:31.093] Future #2
[18:02:31.094] result() for MulticoreFuture ...
[18:02:31.095] result() for MulticoreFuture ...
[18:02:31.096] result() for MulticoreFuture ... done
[18:02:31.096] result() for MulticoreFuture ... done
[18:02:31.096] result() for MulticoreFuture ...
[18:02:31.097] result() for MulticoreFuture ... done
[18:02:31.097] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:02:31.097] - nx: 2
[18:02:31.098] - relay: TRUE
[18:02:31.098] - stdout: TRUE
[18:02:31.098] - signal: TRUE
[18:02:31.099] - resignal: FALSE
[18:02:31.099] - force: TRUE
[18:02:31.099] - relayed: [n=2] FALSE, FALSE
[18:02:31.099] - queued futures: [n=2] FALSE, FALSE
[18:02:31.100]  - until=1
[18:02:31.100]  - relaying element #1
[18:02:31.100] - relayed: [n=2] FALSE, FALSE
[18:02:31.100] - queued futures: [n=2] FALSE, TRUE
[18:02:31.101] signalConditionsASAP(NULL, pos=2) ... done
[18:02:31.101]  length: 1 (resolved future 2)
[18:02:31.484] plan(): Setting new future strategy stack:
[18:02:31.485] List of future strategies:
[18:02:31.485] 1. multicore:
[18:02:31.485]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:31.485]    - tweaked: FALSE
[18:02:31.485]    - call: plan(strategy)
[18:02:31.496] plan(): nbrOfWorkers() = 2
[18:02:31.507] Future #1
[18:02:31.507] result() for MulticoreFuture ...
[18:02:31.509] result() for MulticoreFuture ...
[18:02:31.510] result() for MulticoreFuture ... done
[18:02:31.510] result() for MulticoreFuture ... done
[18:02:31.510] result() for MulticoreFuture ...
[18:02:31.511] result() for MulticoreFuture ... done
[18:02:31.511] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:02:31.512] - nx: 2
[18:02:31.513] - relay: TRUE
[18:02:31.513] - stdout: TRUE
[18:02:31.513] - signal: TRUE
[18:02:31.514] - resignal: FALSE
[18:02:31.514] - force: TRUE
[18:02:31.515] - relayed: [n=2] FALSE, FALSE
[18:02:31.515] - queued futures: [n=2] FALSE, TRUE
[18:02:31.515]  - until=1
[18:02:31.516]  - relaying element #1
[18:02:31.516] result() for MulticoreFuture ...
[18:02:31.517] result() for MulticoreFuture ... done
[18:02:31.517] result() for MulticoreFuture ...
[18:02:31.517] result() for MulticoreFuture ... done
[18:02:31.518] result() for MulticoreFuture ...
[18:02:31.518] result() for MulticoreFuture ... done
[18:02:31.519] result() for MulticoreFuture ...
[18:02:31.519] result() for MulticoreFuture ... done
[18:02:31.519] - relayed: [n=2] TRUE, FALSE
[18:02:31.520] - queued futures: [n=2] TRUE, TRUE
[18:02:31.520] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:02:31.521]  length: 0 (resolved future 1)
[18:02:31.521] Relaying remaining futures
[18:02:31.521] signalConditionsASAP(NULL, pos=0) ...
[18:02:31.522] - nx: 2
[18:02:31.522] - relay: TRUE
[18:02:31.522] - stdout: TRUE
[18:02:31.523] - signal: TRUE
[18:02:31.523] - resignal: FALSE
[18:02:31.523] - force: TRUE
[18:02:31.524] - relayed: [n=2] TRUE, FALSE
[18:02:31.524] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:31.525]  - relaying element #2
[18:02:31.525] result() for MulticoreFuture ...
[18:02:31.525] result() for MulticoreFuture ... done
[18:02:31.526] result() for MulticoreFuture ...
[18:02:31.526] result() for MulticoreFuture ... done
[18:02:31.527] result() for MulticoreFuture ...
[18:02:31.527] result() for MulticoreFuture ... done
[18:02:31.527] result() for MulticoreFuture ...
[18:02:31.528] result() for MulticoreFuture ... done
[18:02:31.528] - relayed: [n=2] TRUE, TRUE
[18:02:31.528] - queued futures: [n=2] TRUE, TRUE
[18:02:31.529] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[18:02:31.529] resolve() on list ... DONE
[18:02:31.530] result() for MulticoreFuture ...
[18:02:31.530] result() for MulticoreFuture ... done
[18:02:31.530] result() for MulticoreFuture ...
[18:02:31.531] result() for MulticoreFuture ... done
[18:02:31.531] result() for MulticoreFuture ...
[18:02:31.531] result() for MulticoreFuture ... done
[18:02:31.532] result() for MulticoreFuture ...
[18:02:31.532] result() for MulticoreFuture ... done
[18:02:31.533]  - Number of value chunks collected: 2
[18:02:31.533] Resolving 2 futures (chunks) ... DONE
[18:02:31.533] Reducing values from 2 chunks ...
[18:02:31.534]  - Number of values collected after concatenation: 2
[18:02:31.534]  - Number of values expected: 2
[18:02:31.534] Reducing values from 2 chunks ... DONE
[18:02:31.535] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[18:02:31.536] future_mapply() ...
[18:02:31.549] Number of chunks: 2
[18:02:31.549] getGlobalsAndPackagesXApply() ...
[18:02:31.550]  - future.globals: TRUE
[18:02:31.550] getGlobalsAndPackages() ...
[18:02:31.550] Searching for globals...
[18:02:31.555] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:31.556] Searching for globals ... DONE
[18:02:31.556] Resolving globals: FALSE
[18:02:31.557] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:31.558] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:31.558] - globals: [1] ‘FUN’
[18:02:31.558] 
[18:02:31.559] getGlobalsAndPackages() ... DONE
[18:02:31.559]  - globals found/used: [n=1] ‘FUN’
[18:02:31.559]  - needed namespaces: [n=0] 
[18:02:31.560] Finding globals ... DONE
[18:02:31.560] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:31.560] List of 2
[18:02:31.560]  $ ...future.FUN:function (x, y)  
[18:02:31.560]  $ MoreArgs     : NULL
[18:02:31.560]  - attr(*, "where")=List of 2
[18:02:31.560]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:31.560]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:31.560]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:31.560]  - attr(*, "resolved")= logi FALSE
[18:02:31.560]  - attr(*, "total_size")= num NA
[18:02:31.567] Packages to be attached in all futures: [n=0] 
[18:02:31.567] getGlobalsAndPackagesXApply() ... DONE
[18:02:31.568] Number of futures (= number of chunks): 2
[18:02:31.568] Launching 2 futures (chunks) ...
[18:02:31.568] Chunk #1 of 2 ...
[18:02:31.569]  - Finding globals in '...' for chunk #1 ...
[18:02:31.569] getGlobalsAndPackages() ...
[18:02:31.569] Searching for globals...
[18:02:31.570] 
[18:02:31.570] Searching for globals ... DONE
[18:02:31.570] - globals: [0] <none>
[18:02:31.571] getGlobalsAndPackages() ... DONE
[18:02:31.571]    + additional globals found: [n=0] 
[18:02:31.571]    + additional namespaces needed: [n=0] 
[18:02:31.571]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:31.572]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:31.572]  - seeds: <none>
[18:02:31.572]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:31.572] getGlobalsAndPackages() ...
[18:02:31.572] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:31.573] Resolving globals: FALSE
[18:02:31.574] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[18:02:31.575] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:31.575] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:31.576] 
[18:02:31.576] getGlobalsAndPackages() ... DONE
[18:02:31.576] run() for ‘Future’ ...
[18:02:31.577] - state: ‘created’
[18:02:31.577] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:31.584] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:31.584] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:31.584]   - Field: ‘label’
[18:02:31.584]   - Field: ‘local’
[18:02:31.585]   - Field: ‘owner’
[18:02:31.585]   - Field: ‘envir’
[18:02:31.585]   - Field: ‘workers’
[18:02:31.585]   - Field: ‘packages’
[18:02:31.585]   - Field: ‘gc’
[18:02:31.586]   - Field: ‘job’
[18:02:31.586]   - Field: ‘conditions’
[18:02:31.586]   - Field: ‘expr’
[18:02:31.586]   - Field: ‘uuid’
[18:02:31.586]   - Field: ‘seed’
[18:02:31.587]   - Field: ‘version’
[18:02:31.587]   - Field: ‘result’
[18:02:31.587]   - Field: ‘asynchronous’
[18:02:31.587]   - Field: ‘calls’
[18:02:31.587]   - Field: ‘globals’
[18:02:31.588]   - Field: ‘stdout’
[18:02:31.588]   - Field: ‘earlySignal’
[18:02:31.588]   - Field: ‘lazy’
[18:02:31.588]   - Field: ‘state’
[18:02:31.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:31.589] - Launch lazy future ...
[18:02:31.589] Packages needed by the future expression (n = 0): <none>
[18:02:31.589] Packages needed by future strategies (n = 0): <none>
[18:02:31.590] {
[18:02:31.590]     {
[18:02:31.590]         {
[18:02:31.590]             ...future.startTime <- base::Sys.time()
[18:02:31.590]             {
[18:02:31.590]                 {
[18:02:31.590]                   {
[18:02:31.590]                     {
[18:02:31.590]                       base::local({
[18:02:31.590]                         has_future <- base::requireNamespace("future", 
[18:02:31.590]                           quietly = TRUE)
[18:02:31.590]                         if (has_future) {
[18:02:31.590]                           ns <- base::getNamespace("future")
[18:02:31.590]                           version <- ns[[".package"]][["version"]]
[18:02:31.590]                           if (is.null(version)) 
[18:02:31.590]                             version <- utils::packageVersion("future")
[18:02:31.590]                         }
[18:02:31.590]                         else {
[18:02:31.590]                           version <- NULL
[18:02:31.590]                         }
[18:02:31.590]                         if (!has_future || version < "1.8.0") {
[18:02:31.590]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:31.590]                             "", base::R.version$version.string), 
[18:02:31.590]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:31.590]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:31.590]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:31.590]                               "release", "version")], collapse = " "), 
[18:02:31.590]                             hostname = base::Sys.info()[["nodename"]])
[18:02:31.590]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:31.590]                             info)
[18:02:31.590]                           info <- base::paste(info, collapse = "; ")
[18:02:31.590]                           if (!has_future) {
[18:02:31.590]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:31.590]                               info)
[18:02:31.590]                           }
[18:02:31.590]                           else {
[18:02:31.590]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:31.590]                               info, version)
[18:02:31.590]                           }
[18:02:31.590]                           base::stop(msg)
[18:02:31.590]                         }
[18:02:31.590]                       })
[18:02:31.590]                     }
[18:02:31.590]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:31.590]                     base::options(mc.cores = 1L)
[18:02:31.590]                   }
[18:02:31.590]                   ...future.strategy.old <- future::plan("list")
[18:02:31.590]                   options(future.plan = NULL)
[18:02:31.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:31.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:31.590]                 }
[18:02:31.590]                 ...future.workdir <- getwd()
[18:02:31.590]             }
[18:02:31.590]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:31.590]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:31.590]         }
[18:02:31.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:31.590]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:31.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:31.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:31.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:31.590]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:31.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:31.590]             base::names(...future.oldOptions))
[18:02:31.590]     }
[18:02:31.590]     if (FALSE) {
[18:02:31.590]     }
[18:02:31.590]     else {
[18:02:31.590]         if (TRUE) {
[18:02:31.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:31.590]                 open = "w")
[18:02:31.590]         }
[18:02:31.590]         else {
[18:02:31.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:31.590]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:31.590]         }
[18:02:31.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:31.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:31.590]             base::sink(type = "output", split = FALSE)
[18:02:31.590]             base::close(...future.stdout)
[18:02:31.590]         }, add = TRUE)
[18:02:31.590]     }
[18:02:31.590]     ...future.frame <- base::sys.nframe()
[18:02:31.590]     ...future.conditions <- base::list()
[18:02:31.590]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:31.590]     if (FALSE) {
[18:02:31.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:31.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:31.590]     }
[18:02:31.590]     ...future.result <- base::tryCatch({
[18:02:31.590]         base::withCallingHandlers({
[18:02:31.590]             ...future.value <- base::withVisible(base::local({
[18:02:31.590]                 withCallingHandlers({
[18:02:31.590]                   {
[18:02:31.590]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:31.590]                     if (!identical(...future.globals.maxSize.org, 
[18:02:31.590]                       ...future.globals.maxSize)) {
[18:02:31.590]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:31.590]                       on.exit(options(oopts), add = TRUE)
[18:02:31.590]                     }
[18:02:31.590]                     {
[18:02:31.590]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:31.590]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:31.590]                         USE.NAMES = FALSE)
[18:02:31.590]                       do.call(mapply, args = args)
[18:02:31.590]                     }
[18:02:31.590]                   }
[18:02:31.590]                 }, immediateCondition = function(cond) {
[18:02:31.590]                   save_rds <- function (object, pathname, ...) 
[18:02:31.590]                   {
[18:02:31.590]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:31.590]                     if (file_test("-f", pathname_tmp)) {
[18:02:31.590]                       fi_tmp <- file.info(pathname_tmp)
[18:02:31.590]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:31.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:31.590]                         fi_tmp[["mtime"]])
[18:02:31.590]                     }
[18:02:31.590]                     tryCatch({
[18:02:31.590]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:31.590]                     }, error = function(ex) {
[18:02:31.590]                       msg <- conditionMessage(ex)
[18:02:31.590]                       fi_tmp <- file.info(pathname_tmp)
[18:02:31.590]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:31.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:31.590]                         fi_tmp[["mtime"]], msg)
[18:02:31.590]                       ex$message <- msg
[18:02:31.590]                       stop(ex)
[18:02:31.590]                     })
[18:02:31.590]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:31.590]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:31.590]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:31.590]                       fi_tmp <- file.info(pathname_tmp)
[18:02:31.590]                       fi <- file.info(pathname)
[18:02:31.590]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:31.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:31.590]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:31.590]                         fi[["size"]], fi[["mtime"]])
[18:02:31.590]                       stop(msg)
[18:02:31.590]                     }
[18:02:31.590]                     invisible(pathname)
[18:02:31.590]                   }
[18:02:31.590]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:31.590]                     rootPath = tempdir()) 
[18:02:31.590]                   {
[18:02:31.590]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:31.590]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:31.590]                       tmpdir = path, fileext = ".rds")
[18:02:31.590]                     save_rds(obj, file)
[18:02:31.590]                   }
[18:02:31.590]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1j8FfD/.future/immediateConditions")
[18:02:31.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:31.590]                   {
[18:02:31.590]                     inherits <- base::inherits
[18:02:31.590]                     invokeRestart <- base::invokeRestart
[18:02:31.590]                     is.null <- base::is.null
[18:02:31.590]                     muffled <- FALSE
[18:02:31.590]                     if (inherits(cond, "message")) {
[18:02:31.590]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:31.590]                       if (muffled) 
[18:02:31.590]                         invokeRestart("muffleMessage")
[18:02:31.590]                     }
[18:02:31.590]                     else if (inherits(cond, "warning")) {
[18:02:31.590]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:31.590]                       if (muffled) 
[18:02:31.590]                         invokeRestart("muffleWarning")
[18:02:31.590]                     }
[18:02:31.590]                     else if (inherits(cond, "condition")) {
[18:02:31.590]                       if (!is.null(pattern)) {
[18:02:31.590]                         computeRestarts <- base::computeRestarts
[18:02:31.590]                         grepl <- base::grepl
[18:02:31.590]                         restarts <- computeRestarts(cond)
[18:02:31.590]                         for (restart in restarts) {
[18:02:31.590]                           name <- restart$name
[18:02:31.590]                           if (is.null(name)) 
[18:02:31.590]                             next
[18:02:31.590]                           if (!grepl(pattern, name)) 
[18:02:31.590]                             next
[18:02:31.590]                           invokeRestart(restart)
[18:02:31.590]                           muffled <- TRUE
[18:02:31.590]                           break
[18:02:31.590]                         }
[18:02:31.590]                       }
[18:02:31.590]                     }
[18:02:31.590]                     invisible(muffled)
[18:02:31.590]                   }
[18:02:31.590]                   muffleCondition(cond)
[18:02:31.590]                 })
[18:02:31.590]             }))
[18:02:31.590]             future::FutureResult(value = ...future.value$value, 
[18:02:31.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:31.590]                   ...future.rng), globalenv = if (FALSE) 
[18:02:31.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:31.590]                     ...future.globalenv.names))
[18:02:31.590]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:31.590]         }, condition = base::local({
[18:02:31.590]             c <- base::c
[18:02:31.590]             inherits <- base::inherits
[18:02:31.590]             invokeRestart <- base::invokeRestart
[18:02:31.590]             length <- base::length
[18:02:31.590]             list <- base::list
[18:02:31.590]             seq.int <- base::seq.int
[18:02:31.590]             signalCondition <- base::signalCondition
[18:02:31.590]             sys.calls <- base::sys.calls
[18:02:31.590]             `[[` <- base::`[[`
[18:02:31.590]             `+` <- base::`+`
[18:02:31.590]             `<<-` <- base::`<<-`
[18:02:31.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:31.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:31.590]                   3L)]
[18:02:31.590]             }
[18:02:31.590]             function(cond) {
[18:02:31.590]                 is_error <- inherits(cond, "error")
[18:02:31.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:31.590]                   NULL)
[18:02:31.590]                 if (is_error) {
[18:02:31.590]                   sessionInformation <- function() {
[18:02:31.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:31.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:31.590]                       search = base::search(), system = base::Sys.info())
[18:02:31.590]                   }
[18:02:31.590]                   ...future.conditions[[length(...future.conditions) + 
[18:02:31.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:31.590]                     cond$call), session = sessionInformation(), 
[18:02:31.590]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:31.590]                   signalCondition(cond)
[18:02:31.590]                 }
[18:02:31.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:31.590]                 "immediateCondition"))) {
[18:02:31.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:31.590]                   ...future.conditions[[length(...future.conditions) + 
[18:02:31.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:31.590]                   if (TRUE && !signal) {
[18:02:31.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:31.590]                     {
[18:02:31.590]                       inherits <- base::inherits
[18:02:31.590]                       invokeRestart <- base::invokeRestart
[18:02:31.590]                       is.null <- base::is.null
[18:02:31.590]                       muffled <- FALSE
[18:02:31.590]                       if (inherits(cond, "message")) {
[18:02:31.590]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:31.590]                         if (muffled) 
[18:02:31.590]                           invokeRestart("muffleMessage")
[18:02:31.590]                       }
[18:02:31.590]                       else if (inherits(cond, "warning")) {
[18:02:31.590]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:31.590]                         if (muffled) 
[18:02:31.590]                           invokeRestart("muffleWarning")
[18:02:31.590]                       }
[18:02:31.590]                       else if (inherits(cond, "condition")) {
[18:02:31.590]                         if (!is.null(pattern)) {
[18:02:31.590]                           computeRestarts <- base::computeRestarts
[18:02:31.590]                           grepl <- base::grepl
[18:02:31.590]                           restarts <- computeRestarts(cond)
[18:02:31.590]                           for (restart in restarts) {
[18:02:31.590]                             name <- restart$name
[18:02:31.590]                             if (is.null(name)) 
[18:02:31.590]                               next
[18:02:31.590]                             if (!grepl(pattern, name)) 
[18:02:31.590]                               next
[18:02:31.590]                             invokeRestart(restart)
[18:02:31.590]                             muffled <- TRUE
[18:02:31.590]                             break
[18:02:31.590]                           }
[18:02:31.590]                         }
[18:02:31.590]                       }
[18:02:31.590]                       invisible(muffled)
[18:02:31.590]                     }
[18:02:31.590]                     muffleCondition(cond, pattern = "^muffle")
[18:02:31.590]                   }
[18:02:31.590]                 }
[18:02:31.590]                 else {
[18:02:31.590]                   if (TRUE) {
[18:02:31.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:31.590]                     {
[18:02:31.590]                       inherits <- base::inherits
[18:02:31.590]                       invokeRestart <- base::invokeRestart
[18:02:31.590]                       is.null <- base::is.null
[18:02:31.590]                       muffled <- FALSE
[18:02:31.590]                       if (inherits(cond, "message")) {
[18:02:31.590]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:31.590]                         if (muffled) 
[18:02:31.590]                           invokeRestart("muffleMessage")
[18:02:31.590]                       }
[18:02:31.590]                       else if (inherits(cond, "warning")) {
[18:02:31.590]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:31.590]                         if (muffled) 
[18:02:31.590]                           invokeRestart("muffleWarning")
[18:02:31.590]                       }
[18:02:31.590]                       else if (inherits(cond, "condition")) {
[18:02:31.590]                         if (!is.null(pattern)) {
[18:02:31.590]                           computeRestarts <- base::computeRestarts
[18:02:31.590]                           grepl <- base::grepl
[18:02:31.590]                           restarts <- computeRestarts(cond)
[18:02:31.590]                           for (restart in restarts) {
[18:02:31.590]                             name <- restart$name
[18:02:31.590]                             if (is.null(name)) 
[18:02:31.590]                               next
[18:02:31.590]                             if (!grepl(pattern, name)) 
[18:02:31.590]                               next
[18:02:31.590]                             invokeRestart(restart)
[18:02:31.590]                             muffled <- TRUE
[18:02:31.590]                             break
[18:02:31.590]                           }
[18:02:31.590]                         }
[18:02:31.590]                       }
[18:02:31.590]                       invisible(muffled)
[18:02:31.590]                     }
[18:02:31.590]                     muffleCondition(cond, pattern = "^muffle")
[18:02:31.590]                   }
[18:02:31.590]                 }
[18:02:31.590]             }
[18:02:31.590]         }))
[18:02:31.590]     }, error = function(ex) {
[18:02:31.590]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:31.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:31.590]                 ...future.rng), started = ...future.startTime, 
[18:02:31.590]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:31.590]             version = "1.8"), class = "FutureResult")
[18:02:31.590]     }, finally = {
[18:02:31.590]         if (!identical(...future.workdir, getwd())) 
[18:02:31.590]             setwd(...future.workdir)
[18:02:31.590]         {
[18:02:31.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:31.590]                 ...future.oldOptions$nwarnings <- NULL
[18:02:31.590]             }
[18:02:31.590]             base::options(...future.oldOptions)
[18:02:31.590]             if (.Platform$OS.type == "windows") {
[18:02:31.590]                 old_names <- names(...future.oldEnvVars)
[18:02:31.590]                 envs <- base::Sys.getenv()
[18:02:31.590]                 names <- names(envs)
[18:02:31.590]                 common <- intersect(names, old_names)
[18:02:31.590]                 added <- setdiff(names, old_names)
[18:02:31.590]                 removed <- setdiff(old_names, names)
[18:02:31.590]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:31.590]                   envs[common]]
[18:02:31.590]                 NAMES <- toupper(changed)
[18:02:31.590]                 args <- list()
[18:02:31.590]                 for (kk in seq_along(NAMES)) {
[18:02:31.590]                   name <- changed[[kk]]
[18:02:31.590]                   NAME <- NAMES[[kk]]
[18:02:31.590]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:31.590]                     next
[18:02:31.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:31.590]                 }
[18:02:31.590]                 NAMES <- toupper(added)
[18:02:31.590]                 for (kk in seq_along(NAMES)) {
[18:02:31.590]                   name <- added[[kk]]
[18:02:31.590]                   NAME <- NAMES[[kk]]
[18:02:31.590]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:31.590]                     next
[18:02:31.590]                   args[[name]] <- ""
[18:02:31.590]                 }
[18:02:31.590]                 NAMES <- toupper(removed)
[18:02:31.590]                 for (kk in seq_along(NAMES)) {
[18:02:31.590]                   name <- removed[[kk]]
[18:02:31.590]                   NAME <- NAMES[[kk]]
[18:02:31.590]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:31.590]                     next
[18:02:31.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:31.590]                 }
[18:02:31.590]                 if (length(args) > 0) 
[18:02:31.590]                   base::do.call(base::Sys.setenv, args = args)
[18:02:31.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:31.590]             }
[18:02:31.590]             else {
[18:02:31.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:31.590]             }
[18:02:31.590]             {
[18:02:31.590]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:31.590]                   0L) {
[18:02:31.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:31.590]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:31.590]                   base::options(opts)
[18:02:31.590]                 }
[18:02:31.590]                 {
[18:02:31.590]                   {
[18:02:31.590]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:31.590]                     NULL
[18:02:31.590]                   }
[18:02:31.590]                   options(future.plan = NULL)
[18:02:31.590]                   if (is.na(NA_character_)) 
[18:02:31.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:31.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:31.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:31.590]                     .init = FALSE)
[18:02:31.590]                 }
[18:02:31.590]             }
[18:02:31.590]         }
[18:02:31.590]     })
[18:02:31.590]     if (TRUE) {
[18:02:31.590]         base::sink(type = "output", split = FALSE)
[18:02:31.590]         if (TRUE) {
[18:02:31.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:31.590]         }
[18:02:31.590]         else {
[18:02:31.590]             ...future.result["stdout"] <- base::list(NULL)
[18:02:31.590]         }
[18:02:31.590]         base::close(...future.stdout)
[18:02:31.590]         ...future.stdout <- NULL
[18:02:31.590]     }
[18:02:31.590]     ...future.result$conditions <- ...future.conditions
[18:02:31.590]     ...future.result$finished <- base::Sys.time()
[18:02:31.590]     ...future.result
[18:02:31.590] }
[18:02:31.595] assign_globals() ...
[18:02:31.595] List of 5
[18:02:31.595]  $ ...future.FUN            :function (x, y)  
[18:02:31.595]  $ MoreArgs                 : NULL
[18:02:31.595]  $ ...future.elements_ii    :List of 2
[18:02:31.595]   ..$ :List of 1
[18:02:31.595]   .. ..$ : int 1
[18:02:31.595]   ..$ :List of 1
[18:02:31.595]   .. ..$ : int 0
[18:02:31.595]  $ ...future.seeds_ii       : NULL
[18:02:31.595]  $ ...future.globals.maxSize: NULL
[18:02:31.595]  - attr(*, "where")=List of 5
[18:02:31.595]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:31.595]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:31.595]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:31.595]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:31.595]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:31.595]  - attr(*, "resolved")= logi FALSE
[18:02:31.595]  - attr(*, "total_size")= num 6368
[18:02:31.595]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:31.595]  - attr(*, "already-done")= logi TRUE
[18:02:31.605] - reassign environment for ‘...future.FUN’
[18:02:31.605] - copied ‘...future.FUN’ to environment
[18:02:31.606] - copied ‘MoreArgs’ to environment
[18:02:31.606] - copied ‘...future.elements_ii’ to environment
[18:02:31.606] - copied ‘...future.seeds_ii’ to environment
[18:02:31.606] - copied ‘...future.globals.maxSize’ to environment
[18:02:31.606] assign_globals() ... done
[18:02:31.607] requestCore(): workers = 2
[18:02:31.613] MulticoreFuture started
[18:02:31.614] - Launch lazy future ... done
[18:02:31.615] run() for ‘MulticoreFuture’ ... done
[18:02:31.616] plan(): Setting new future strategy stack:
[18:02:31.616] Created future:
[18:02:31.617] List of future strategies:
[18:02:31.617] 1. sequential:
[18:02:31.617]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:31.617]    - tweaked: FALSE
[18:02:31.617]    - call: NULL
[18:02:31.620] plan(): nbrOfWorkers() = 1
[18:02:31.617] MulticoreFuture:
[18:02:31.617] Label: ‘future_mapply-1’
[18:02:31.617] Expression:
[18:02:31.617] {
[18:02:31.617]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:31.617]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:31.617]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:31.617]         on.exit(options(oopts), add = TRUE)
[18:02:31.617]     }
[18:02:31.617]     {
[18:02:31.617]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:31.617]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:31.617]         do.call(mapply, args = args)
[18:02:31.617]     }
[18:02:31.617] }
[18:02:31.617] Lazy evaluation: FALSE
[18:02:31.617] Asynchronous evaluation: TRUE
[18:02:31.617] Local evaluation: TRUE
[18:02:31.617] Environment: R_GlobalEnv
[18:02:31.617] Capture standard output: TRUE
[18:02:31.617] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:31.617] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:31.617] Packages: <none>
[18:02:31.617] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:31.617] Resolved: FALSE
[18:02:31.617] Value: <not collected>
[18:02:31.617] Conditions captured: <none>
[18:02:31.617] Early signaling: FALSE
[18:02:31.617] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:31.617] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:31.635] Chunk #1 of 2 ... DONE
[18:02:31.636] Chunk #2 of 2 ...
[18:02:31.636]  - Finding globals in '...' for chunk #2 ...
[18:02:31.637] getGlobalsAndPackages() ...
[18:02:31.638] Searching for globals...
[18:02:31.640] 
[18:02:31.640] Searching for globals ... DONE
[18:02:31.641] - globals: [0] <none>
[18:02:31.641] getGlobalsAndPackages() ... DONE
[18:02:31.641]    + additional globals found: [n=0] 
[18:02:31.642]    + additional namespaces needed: [n=0] 
[18:02:31.642]  - Finding globals in '...' for chunk #2 ... DONE
[18:02:31.642]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:31.643]  - seeds: <none>
[18:02:31.643]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:31.643] getGlobalsAndPackages() ...
[18:02:31.644] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:31.644] Resolving globals: FALSE
[18:02:31.646] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[18:02:31.648] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:31.648] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:31.649] 
[18:02:31.649] getGlobalsAndPackages() ... DONE
[18:02:31.650] run() for ‘Future’ ...
[18:02:31.651] - state: ‘created’
[18:02:31.651] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:31.659] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:31.660] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:31.660]   - Field: ‘label’
[18:02:31.661]   - Field: ‘local’
[18:02:31.661]   - Field: ‘owner’
[18:02:31.661]   - Field: ‘envir’
[18:02:31.662]   - Field: ‘workers’
[18:02:31.662]   - Field: ‘packages’
[18:02:31.662]   - Field: ‘gc’
[18:02:31.662]   - Field: ‘job’
[18:02:31.663]   - Field: ‘conditions’
[18:02:31.663]   - Field: ‘expr’
[18:02:31.663]   - Field: ‘uuid’
[18:02:31.664]   - Field: ‘seed’
[18:02:31.664]   - Field: ‘version’
[18:02:31.664]   - Field: ‘result’
[18:02:31.664]   - Field: ‘asynchronous’
[18:02:31.665]   - Field: ‘calls’
[18:02:31.665]   - Field: ‘globals’
[18:02:31.665]   - Field: ‘stdout’
[18:02:31.666]   - Field: ‘earlySignal’
[18:02:31.666]   - Field: ‘lazy’
[18:02:31.666]   - Field: ‘state’
[18:02:31.666] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:31.667] - Launch lazy future ...
[18:02:31.667] Packages needed by the future expression (n = 0): <none>
[18:02:31.668] Packages needed by future strategies (n = 0): <none>
[18:02:31.669] {
[18:02:31.669]     {
[18:02:31.669]         {
[18:02:31.669]             ...future.startTime <- base::Sys.time()
[18:02:31.669]             {
[18:02:31.669]                 {
[18:02:31.669]                   {
[18:02:31.669]                     {
[18:02:31.669]                       base::local({
[18:02:31.669]                         has_future <- base::requireNamespace("future", 
[18:02:31.669]                           quietly = TRUE)
[18:02:31.669]                         if (has_future) {
[18:02:31.669]                           ns <- base::getNamespace("future")
[18:02:31.669]                           version <- ns[[".package"]][["version"]]
[18:02:31.669]                           if (is.null(version)) 
[18:02:31.669]                             version <- utils::packageVersion("future")
[18:02:31.669]                         }
[18:02:31.669]                         else {
[18:02:31.669]                           version <- NULL
[18:02:31.669]                         }
[18:02:31.669]                         if (!has_future || version < "1.8.0") {
[18:02:31.669]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:31.669]                             "", base::R.version$version.string), 
[18:02:31.669]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:31.669]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:31.669]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:31.669]                               "release", "version")], collapse = " "), 
[18:02:31.669]                             hostname = base::Sys.info()[["nodename"]])
[18:02:31.669]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:31.669]                             info)
[18:02:31.669]                           info <- base::paste(info, collapse = "; ")
[18:02:31.669]                           if (!has_future) {
[18:02:31.669]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:31.669]                               info)
[18:02:31.669]                           }
[18:02:31.669]                           else {
[18:02:31.669]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:31.669]                               info, version)
[18:02:31.669]                           }
[18:02:31.669]                           base::stop(msg)
[18:02:31.669]                         }
[18:02:31.669]                       })
[18:02:31.669]                     }
[18:02:31.669]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:31.669]                     base::options(mc.cores = 1L)
[18:02:31.669]                   }
[18:02:31.669]                   ...future.strategy.old <- future::plan("list")
[18:02:31.669]                   options(future.plan = NULL)
[18:02:31.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:31.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:31.669]                 }
[18:02:31.669]                 ...future.workdir <- getwd()
[18:02:31.669]             }
[18:02:31.669]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:31.669]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:31.669]         }
[18:02:31.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:31.669]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:31.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:31.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:31.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:31.669]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:31.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:31.669]             base::names(...future.oldOptions))
[18:02:31.669]     }
[18:02:31.669]     if (FALSE) {
[18:02:31.669]     }
[18:02:31.669]     else {
[18:02:31.669]         if (TRUE) {
[18:02:31.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:31.669]                 open = "w")
[18:02:31.669]         }
[18:02:31.669]         else {
[18:02:31.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:31.669]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:31.669]         }
[18:02:31.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:31.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:31.669]             base::sink(type = "output", split = FALSE)
[18:02:31.669]             base::close(...future.stdout)
[18:02:31.669]         }, add = TRUE)
[18:02:31.669]     }
[18:02:31.669]     ...future.frame <- base::sys.nframe()
[18:02:31.669]     ...future.conditions <- base::list()
[18:02:31.669]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:31.669]     if (FALSE) {
[18:02:31.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:31.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:31.669]     }
[18:02:31.669]     ...future.result <- base::tryCatch({
[18:02:31.669]         base::withCallingHandlers({
[18:02:31.669]             ...future.value <- base::withVisible(base::local({
[18:02:31.669]                 withCallingHandlers({
[18:02:31.669]                   {
[18:02:31.669]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:31.669]                     if (!identical(...future.globals.maxSize.org, 
[18:02:31.669]                       ...future.globals.maxSize)) {
[18:02:31.669]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:31.669]                       on.exit(options(oopts), add = TRUE)
[18:02:31.669]                     }
[18:02:31.669]                     {
[18:02:31.669]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:31.669]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:31.669]                         USE.NAMES = FALSE)
[18:02:31.669]                       do.call(mapply, args = args)
[18:02:31.669]                     }
[18:02:31.669]                   }
[18:02:31.669]                 }, immediateCondition = function(cond) {
[18:02:31.669]                   save_rds <- function (object, pathname, ...) 
[18:02:31.669]                   {
[18:02:31.669]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:31.669]                     if (file_test("-f", pathname_tmp)) {
[18:02:31.669]                       fi_tmp <- file.info(pathname_tmp)
[18:02:31.669]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:31.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:31.669]                         fi_tmp[["mtime"]])
[18:02:31.669]                     }
[18:02:31.669]                     tryCatch({
[18:02:31.669]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:31.669]                     }, error = function(ex) {
[18:02:31.669]                       msg <- conditionMessage(ex)
[18:02:31.669]                       fi_tmp <- file.info(pathname_tmp)
[18:02:31.669]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:31.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:31.669]                         fi_tmp[["mtime"]], msg)
[18:02:31.669]                       ex$message <- msg
[18:02:31.669]                       stop(ex)
[18:02:31.669]                     })
[18:02:31.669]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:31.669]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:31.669]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:31.669]                       fi_tmp <- file.info(pathname_tmp)
[18:02:31.669]                       fi <- file.info(pathname)
[18:02:31.669]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:31.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:31.669]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:31.669]                         fi[["size"]], fi[["mtime"]])
[18:02:31.669]                       stop(msg)
[18:02:31.669]                     }
[18:02:31.669]                     invisible(pathname)
[18:02:31.669]                   }
[18:02:31.669]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:31.669]                     rootPath = tempdir()) 
[18:02:31.669]                   {
[18:02:31.669]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:31.669]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:31.669]                       tmpdir = path, fileext = ".rds")
[18:02:31.669]                     save_rds(obj, file)
[18:02:31.669]                   }
[18:02:31.669]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1j8FfD/.future/immediateConditions")
[18:02:31.669]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:31.669]                   {
[18:02:31.669]                     inherits <- base::inherits
[18:02:31.669]                     invokeRestart <- base::invokeRestart
[18:02:31.669]                     is.null <- base::is.null
[18:02:31.669]                     muffled <- FALSE
[18:02:31.669]                     if (inherits(cond, "message")) {
[18:02:31.669]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:31.669]                       if (muffled) 
[18:02:31.669]                         invokeRestart("muffleMessage")
[18:02:31.669]                     }
[18:02:31.669]                     else if (inherits(cond, "warning")) {
[18:02:31.669]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:31.669]                       if (muffled) 
[18:02:31.669]                         invokeRestart("muffleWarning")
[18:02:31.669]                     }
[18:02:31.669]                     else if (inherits(cond, "condition")) {
[18:02:31.669]                       if (!is.null(pattern)) {
[18:02:31.669]                         computeRestarts <- base::computeRestarts
[18:02:31.669]                         grepl <- base::grepl
[18:02:31.669]                         restarts <- computeRestarts(cond)
[18:02:31.669]                         for (restart in restarts) {
[18:02:31.669]                           name <- restart$name
[18:02:31.669]                           if (is.null(name)) 
[18:02:31.669]                             next
[18:02:31.669]                           if (!grepl(pattern, name)) 
[18:02:31.669]                             next
[18:02:31.669]                           invokeRestart(restart)
[18:02:31.669]                           muffled <- TRUE
[18:02:31.669]                           break
[18:02:31.669]                         }
[18:02:31.669]                       }
[18:02:31.669]                     }
[18:02:31.669]                     invisible(muffled)
[18:02:31.669]                   }
[18:02:31.669]                   muffleCondition(cond)
[18:02:31.669]                 })
[18:02:31.669]             }))
[18:02:31.669]             future::FutureResult(value = ...future.value$value, 
[18:02:31.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:31.669]                   ...future.rng), globalenv = if (FALSE) 
[18:02:31.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:31.669]                     ...future.globalenv.names))
[18:02:31.669]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:31.669]         }, condition = base::local({
[18:02:31.669]             c <- base::c
[18:02:31.669]             inherits <- base::inherits
[18:02:31.669]             invokeRestart <- base::invokeRestart
[18:02:31.669]             length <- base::length
[18:02:31.669]             list <- base::list
[18:02:31.669]             seq.int <- base::seq.int
[18:02:31.669]             signalCondition <- base::signalCondition
[18:02:31.669]             sys.calls <- base::sys.calls
[18:02:31.669]             `[[` <- base::`[[`
[18:02:31.669]             `+` <- base::`+`
[18:02:31.669]             `<<-` <- base::`<<-`
[18:02:31.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:31.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:31.669]                   3L)]
[18:02:31.669]             }
[18:02:31.669]             function(cond) {
[18:02:31.669]                 is_error <- inherits(cond, "error")
[18:02:31.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:31.669]                   NULL)
[18:02:31.669]                 if (is_error) {
[18:02:31.669]                   sessionInformation <- function() {
[18:02:31.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:31.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:31.669]                       search = base::search(), system = base::Sys.info())
[18:02:31.669]                   }
[18:02:31.669]                   ...future.conditions[[length(...future.conditions) + 
[18:02:31.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:31.669]                     cond$call), session = sessionInformation(), 
[18:02:31.669]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:31.669]                   signalCondition(cond)
[18:02:31.669]                 }
[18:02:31.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:31.669]                 "immediateCondition"))) {
[18:02:31.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:31.669]                   ...future.conditions[[length(...future.conditions) + 
[18:02:31.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:31.669]                   if (TRUE && !signal) {
[18:02:31.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:31.669]                     {
[18:02:31.669]                       inherits <- base::inherits
[18:02:31.669]                       invokeRestart <- base::invokeRestart
[18:02:31.669]                       is.null <- base::is.null
[18:02:31.669]                       muffled <- FALSE
[18:02:31.669]                       if (inherits(cond, "message")) {
[18:02:31.669]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:31.669]                         if (muffled) 
[18:02:31.669]                           invokeRestart("muffleMessage")
[18:02:31.669]                       }
[18:02:31.669]                       else if (inherits(cond, "warning")) {
[18:02:31.669]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:31.669]                         if (muffled) 
[18:02:31.669]                           invokeRestart("muffleWarning")
[18:02:31.669]                       }
[18:02:31.669]                       else if (inherits(cond, "condition")) {
[18:02:31.669]                         if (!is.null(pattern)) {
[18:02:31.669]                           computeRestarts <- base::computeRestarts
[18:02:31.669]                           grepl <- base::grepl
[18:02:31.669]                           restarts <- computeRestarts(cond)
[18:02:31.669]                           for (restart in restarts) {
[18:02:31.669]                             name <- restart$name
[18:02:31.669]                             if (is.null(name)) 
[18:02:31.669]                               next
[18:02:31.669]                             if (!grepl(pattern, name)) 
[18:02:31.669]                               next
[18:02:31.669]                             invokeRestart(restart)
[18:02:31.669]                             muffled <- TRUE
[18:02:31.669]                             break
[18:02:31.669]                           }
[18:02:31.669]                         }
[18:02:31.669]                       }
[18:02:31.669]                       invisible(muffled)
[18:02:31.669]                     }
[18:02:31.669]                     muffleCondition(cond, pattern = "^muffle")
[18:02:31.669]                   }
[18:02:31.669]                 }
[18:02:31.669]                 else {
[18:02:31.669]                   if (TRUE) {
[18:02:31.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:31.669]                     {
[18:02:31.669]                       inherits <- base::inherits
[18:02:31.669]                       invokeRestart <- base::invokeRestart
[18:02:31.669]                       is.null <- base::is.null
[18:02:31.669]                       muffled <- FALSE
[18:02:31.669]                       if (inherits(cond, "message")) {
[18:02:31.669]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:31.669]                         if (muffled) 
[18:02:31.669]                           invokeRestart("muffleMessage")
[18:02:31.669]                       }
[18:02:31.669]                       else if (inherits(cond, "warning")) {
[18:02:31.669]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:31.669]                         if (muffled) 
[18:02:31.669]                           invokeRestart("muffleWarning")
[18:02:31.669]                       }
[18:02:31.669]                       else if (inherits(cond, "condition")) {
[18:02:31.669]                         if (!is.null(pattern)) {
[18:02:31.669]                           computeRestarts <- base::computeRestarts
[18:02:31.669]                           grepl <- base::grepl
[18:02:31.669]                           restarts <- computeRestarts(cond)
[18:02:31.669]                           for (restart in restarts) {
[18:02:31.669]                             name <- restart$name
[18:02:31.669]                             if (is.null(name)) 
[18:02:31.669]                               next
[18:02:31.669]                             if (!grepl(pattern, name)) 
[18:02:31.669]                               next
[18:02:31.669]                             invokeRestart(restart)
[18:02:31.669]                             muffled <- TRUE
[18:02:31.669]                             break
[18:02:31.669]                           }
[18:02:31.669]                         }
[18:02:31.669]                       }
[18:02:31.669]                       invisible(muffled)
[18:02:31.669]                     }
[18:02:31.669]                     muffleCondition(cond, pattern = "^muffle")
[18:02:31.669]                   }
[18:02:31.669]                 }
[18:02:31.669]             }
[18:02:31.669]         }))
[18:02:31.669]     }, error = function(ex) {
[18:02:31.669]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:31.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:31.669]                 ...future.rng), started = ...future.startTime, 
[18:02:31.669]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:31.669]             version = "1.8"), class = "FutureResult")
[18:02:31.669]     }, finally = {
[18:02:31.669]         if (!identical(...future.workdir, getwd())) 
[18:02:31.669]             setwd(...future.workdir)
[18:02:31.669]         {
[18:02:31.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:31.669]                 ...future.oldOptions$nwarnings <- NULL
[18:02:31.669]             }
[18:02:31.669]             base::options(...future.oldOptions)
[18:02:31.669]             if (.Platform$OS.type == "windows") {
[18:02:31.669]                 old_names <- names(...future.oldEnvVars)
[18:02:31.669]                 envs <- base::Sys.getenv()
[18:02:31.669]                 names <- names(envs)
[18:02:31.669]                 common <- intersect(names, old_names)
[18:02:31.669]                 added <- setdiff(names, old_names)
[18:02:31.669]                 removed <- setdiff(old_names, names)
[18:02:31.669]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:31.669]                   envs[common]]
[18:02:31.669]                 NAMES <- toupper(changed)
[18:02:31.669]                 args <- list()
[18:02:31.669]                 for (kk in seq_along(NAMES)) {
[18:02:31.669]                   name <- changed[[kk]]
[18:02:31.669]                   NAME <- NAMES[[kk]]
[18:02:31.669]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:31.669]                     next
[18:02:31.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:31.669]                 }
[18:02:31.669]                 NAMES <- toupper(added)
[18:02:31.669]                 for (kk in seq_along(NAMES)) {
[18:02:31.669]                   name <- added[[kk]]
[18:02:31.669]                   NAME <- NAMES[[kk]]
[18:02:31.669]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:31.669]                     next
[18:02:31.669]                   args[[name]] <- ""
[18:02:31.669]                 }
[18:02:31.669]                 NAMES <- toupper(removed)
[18:02:31.669]                 for (kk in seq_along(NAMES)) {
[18:02:31.669]                   name <- removed[[kk]]
[18:02:31.669]                   NAME <- NAMES[[kk]]
[18:02:31.669]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:31.669]                     next
[18:02:31.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:31.669]                 }
[18:02:31.669]                 if (length(args) > 0) 
[18:02:31.669]                   base::do.call(base::Sys.setenv, args = args)
[18:02:31.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:31.669]             }
[18:02:31.669]             else {
[18:02:31.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:31.669]             }
[18:02:31.669]             {
[18:02:31.669]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:31.669]                   0L) {
[18:02:31.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:31.669]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:31.669]                   base::options(opts)
[18:02:31.669]                 }
[18:02:31.669]                 {
[18:02:31.669]                   {
[18:02:31.669]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:31.669]                     NULL
[18:02:31.669]                   }
[18:02:31.669]                   options(future.plan = NULL)
[18:02:31.669]                   if (is.na(NA_character_)) 
[18:02:31.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:31.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:31.669]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:31.669]                     .init = FALSE)
[18:02:31.669]                 }
[18:02:31.669]             }
[18:02:31.669]         }
[18:02:31.669]     })
[18:02:31.669]     if (TRUE) {
[18:02:31.669]         base::sink(type = "output", split = FALSE)
[18:02:31.669]         if (TRUE) {
[18:02:31.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:31.669]         }
[18:02:31.669]         else {
[18:02:31.669]             ...future.result["stdout"] <- base::list(NULL)
[18:02:31.669]         }
[18:02:31.669]         base::close(...future.stdout)
[18:02:31.669]         ...future.stdout <- NULL
[18:02:31.669]     }
[18:02:31.669]     ...future.result$conditions <- ...future.conditions
[18:02:31.669]     ...future.result$finished <- base::Sys.time()
[18:02:31.669]     ...future.result
[18:02:31.669] }
[18:02:31.675] assign_globals() ...
[18:02:31.675] List of 5
[18:02:31.675]  $ ...future.FUN            :function (x, y)  
[18:02:31.675]  $ MoreArgs                 : NULL
[18:02:31.675]  $ ...future.elements_ii    :List of 2
[18:02:31.675]   ..$ :List of 1
[18:02:31.675]   .. ..$ : int 0
[18:02:31.675]   ..$ :List of 1
[18:02:31.675]   .. ..$ : int 1
[18:02:31.675]  $ ...future.seeds_ii       : NULL
[18:02:31.675]  $ ...future.globals.maxSize: NULL
[18:02:31.675]  - attr(*, "where")=List of 5
[18:02:31.675]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:31.675]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:31.675]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:31.675]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:31.675]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:31.675]  - attr(*, "resolved")= logi FALSE
[18:02:31.675]  - attr(*, "total_size")= num 6368
[18:02:31.675]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:31.675]  - attr(*, "already-done")= logi TRUE
[18:02:31.690] - reassign environment for ‘...future.FUN’
[18:02:31.690] - copied ‘...future.FUN’ to environment
[18:02:31.690] - copied ‘MoreArgs’ to environment
[18:02:31.691] - copied ‘...future.elements_ii’ to environment
[18:02:31.691] - copied ‘...future.seeds_ii’ to environment
[18:02:31.691] - copied ‘...future.globals.maxSize’ to environment
[18:02:31.691] assign_globals() ... done
[18:02:31.692] requestCore(): workers = 2
[18:02:31.695] MulticoreFuture started
[18:02:31.696] - Launch lazy future ... done
[18:02:31.697] run() for ‘MulticoreFuture’ ... done
[18:02:31.697] Created future:
[18:02:31.697] plan(): Setting new future strategy stack:
[18:02:31.698] List of future strategies:
[18:02:31.698] 1. sequential:
[18:02:31.698]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:31.698]    - tweaked: FALSE
[18:02:31.698]    - call: NULL
[18:02:31.700] plan(): nbrOfWorkers() = 1
[18:02:31.705] plan(): Setting new future strategy stack:
[18:02:31.705] List of future strategies:
[18:02:31.705] 1. multicore:
[18:02:31.705]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:31.705]    - tweaked: FALSE
[18:02:31.705]    - call: plan(strategy)
[18:02:31.698] MulticoreFuture:
[18:02:31.698] Label: ‘future_mapply-2’
[18:02:31.698] Expression:
[18:02:31.698] {
[18:02:31.698]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:31.698]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:31.698]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:31.698]         on.exit(options(oopts), add = TRUE)
[18:02:31.698]     }
[18:02:31.698]     {
[18:02:31.698]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:31.698]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:31.698]         do.call(mapply, args = args)
[18:02:31.698]     }
[18:02:31.698] }
[18:02:31.698] Lazy evaluation: FALSE
[18:02:31.698] Asynchronous evaluation: TRUE
[18:02:31.698] Local evaluation: TRUE
[18:02:31.698] Environment: R_GlobalEnv
[18:02:31.698] Capture standard output: TRUE
[18:02:31.698] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:31.698] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:31.698] Packages: <none>
[18:02:31.698] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:31.698] Resolved: FALSE
[18:02:31.698] Value: <not collected>
[18:02:31.698] Conditions captured: <none>
[18:02:31.698] Early signaling: FALSE
[18:02:31.698] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:31.698] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:31.713] Chunk #2 of 2 ... DONE
[18:02:31.713] Launching 2 futures (chunks) ... DONE
[18:02:31.713] Resolving 2 futures (chunks) ...
[18:02:31.714] resolve() on list ...
[18:02:31.714]  recursive: 0
[18:02:31.714]  length: 2
[18:02:31.715] 
[18:02:31.715] plan(): nbrOfWorkers() = 2
[18:02:31.726] Future #2
[18:02:31.726] result() for MulticoreFuture ...
[18:02:31.728] result() for MulticoreFuture ...
[18:02:31.728] result() for MulticoreFuture ... done
[18:02:31.729] result() for MulticoreFuture ... done
[18:02:31.729] result() for MulticoreFuture ...
[18:02:31.729] result() for MulticoreFuture ... done
[18:02:31.730] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:02:31.730] - nx: 2
[18:02:31.731] - relay: TRUE
[18:02:31.731] - stdout: TRUE
[18:02:31.731] - signal: TRUE
[18:02:31.731] - resignal: FALSE
[18:02:31.732] - force: TRUE
[18:02:31.732] - relayed: [n=2] FALSE, FALSE
[18:02:31.732] - queued futures: [n=2] FALSE, FALSE
[18:02:31.732]  - until=1
[18:02:31.733]  - relaying element #1
[18:02:31.733] - relayed: [n=2] FALSE, FALSE
[18:02:31.733] - queued futures: [n=2] FALSE, TRUE
[18:02:31.733] signalConditionsASAP(NULL, pos=2) ... done
[18:02:31.734]  length: 1 (resolved future 2)
[18:02:32.126] plan(): Setting new future strategy stack:
[18:02:32.126] List of future strategies:
[18:02:32.126] 1. multicore:
[18:02:32.126]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:32.126]    - tweaked: FALSE
[18:02:32.126]    - call: plan(strategy)
[18:02:32.136] plan(): nbrOfWorkers() = 2
[18:02:32.144] Future #1
[18:02:32.145] result() for MulticoreFuture ...
[18:02:32.147] result() for MulticoreFuture ...
[18:02:32.148] result() for MulticoreFuture ... done
[18:02:32.148] result() for MulticoreFuture ... done
[18:02:32.149] result() for MulticoreFuture ...
[18:02:32.149] result() for MulticoreFuture ... done
[18:02:32.150] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:02:32.150] - nx: 2
[18:02:32.151] - relay: TRUE
[18:02:32.151] - stdout: TRUE
[18:02:32.152] - signal: TRUE
[18:02:32.152] - resignal: FALSE
[18:02:32.153] - force: TRUE
[18:02:32.153] - relayed: [n=2] FALSE, FALSE
[18:02:32.154] - queued futures: [n=2] FALSE, TRUE
[18:02:32.154]  - until=1
[18:02:32.155]  - relaying element #1
[18:02:32.155] result() for MulticoreFuture ...
[18:02:32.156] result() for MulticoreFuture ... done
[18:02:32.156] result() for MulticoreFuture ...
[18:02:32.156] result() for MulticoreFuture ... done
[18:02:32.157] result() for MulticoreFuture ...
[18:02:32.157] result() for MulticoreFuture ... done
[18:02:32.158] result() for MulticoreFuture ...
[18:02:32.158] result() for MulticoreFuture ... done
[18:02:32.158] - relayed: [n=2] TRUE, FALSE
[18:02:32.159] - queued futures: [n=2] TRUE, TRUE
[18:02:32.159] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:02:32.160]  length: 0 (resolved future 1)
[18:02:32.160] Relaying remaining futures
[18:02:32.160] signalConditionsASAP(NULL, pos=0) ...
[18:02:32.161] - nx: 2
[18:02:32.161] - relay: TRUE
[18:02:32.161] - stdout: TRUE
[18:02:32.162] - signal: TRUE
[18:02:32.162] - resignal: FALSE
[18:02:32.162] - force: TRUE
[18:02:32.163] - relayed: [n=2] TRUE, FALSE
[18:02:32.163] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:32.164]  - relaying element #2
[18:02:32.164] result() for MulticoreFuture ...
[18:02:32.164] result() for MulticoreFuture ... done
[18:02:32.165] result() for MulticoreFuture ...
[18:02:32.165] result() for MulticoreFuture ... done
[18:02:32.166] result() for MulticoreFuture ...
[18:02:32.166] result() for MulticoreFuture ... done
[18:02:32.167] result() for MulticoreFuture ...
[18:02:32.167] result() for MulticoreFuture ... done
[18:02:32.167] - relayed: [n=2] TRUE, TRUE
[18:02:32.168] - queued futures: [n=2] TRUE, TRUE
[18:02:32.168] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[18:02:32.168] resolve() on list ... DONE
[18:02:32.169] result() for MulticoreFuture ...
[18:02:32.169] result() for MulticoreFuture ... done
[18:02:32.169] result() for MulticoreFuture ...
[18:02:32.170] result() for MulticoreFuture ... done
[18:02:32.170] result() for MulticoreFuture ...
[18:02:32.170] result() for MulticoreFuture ... done
[18:02:32.171] result() for MulticoreFuture ...
[18:02:32.171] result() for MulticoreFuture ... done
[18:02:32.172]  - Number of value chunks collected: 2
[18:02:32.172] Resolving 2 futures (chunks) ... DONE
[18:02:32.172] Reducing values from 2 chunks ...
[18:02:32.173]  - Number of values collected after concatenation: 2
[18:02:32.173]  - Number of values expected: 2
[18:02:32.173] Reducing values from 2 chunks ... DONE
[18:02:32.174] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[18:02:32.175] future_mapply() ...
[18:02:32.184] Number of chunks: 2
[18:02:32.185] getGlobalsAndPackagesXApply() ...
[18:02:32.185]  - future.globals: TRUE
[18:02:32.185] getGlobalsAndPackages() ...
[18:02:32.185] Searching for globals...
[18:02:32.190] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:32.190] Searching for globals ... DONE
[18:02:32.190] Resolving globals: FALSE
[18:02:32.191] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:32.192] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:32.193] - globals: [1] ‘FUN’
[18:02:32.193] 
[18:02:32.193] getGlobalsAndPackages() ... DONE
[18:02:32.193]  - globals found/used: [n=1] ‘FUN’
[18:02:32.194]  - needed namespaces: [n=0] 
[18:02:32.194] Finding globals ... DONE
[18:02:32.194] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:32.195] List of 2
[18:02:32.195]  $ ...future.FUN:function (x, y)  
[18:02:32.195]  $ MoreArgs     : NULL
[18:02:32.195]  - attr(*, "where")=List of 2
[18:02:32.195]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:32.195]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:32.195]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:32.195]  - attr(*, "resolved")= logi FALSE
[18:02:32.195]  - attr(*, "total_size")= num NA
[18:02:32.201] Packages to be attached in all futures: [n=0] 
[18:02:32.202] getGlobalsAndPackagesXApply() ... DONE
[18:02:32.202] Number of futures (= number of chunks): 2
[18:02:32.202] Launching 2 futures (chunks) ...
[18:02:32.203] Chunk #1 of 2 ...
[18:02:32.203]  - Finding globals in '...' for chunk #1 ...
[18:02:32.203] getGlobalsAndPackages() ...
[18:02:32.204] Searching for globals...
[18:02:32.204] 
[18:02:32.205] Searching for globals ... DONE
[18:02:32.205] - globals: [0] <none>
[18:02:32.205] getGlobalsAndPackages() ... DONE
[18:02:32.205]    + additional globals found: [n=0] 
[18:02:32.205]    + additional namespaces needed: [n=0] 
[18:02:32.206]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:32.206]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:32.206]  - seeds: <none>
[18:02:32.206]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:32.207] getGlobalsAndPackages() ...
[18:02:32.207] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:32.207] Resolving globals: FALSE
[18:02:32.208] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[18:02:32.209] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:32.210] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:32.210] 
[18:02:32.210] getGlobalsAndPackages() ... DONE
[18:02:32.211] run() for ‘Future’ ...
[18:02:32.211] - state: ‘created’
[18:02:32.211] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:32.218] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:32.218] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:32.219]   - Field: ‘label’
[18:02:32.220]   - Field: ‘local’
[18:02:32.221]   - Field: ‘owner’
[18:02:32.221]   - Field: ‘envir’
[18:02:32.221]   - Field: ‘workers’
[18:02:32.221]   - Field: ‘packages’
[18:02:32.221]   - Field: ‘gc’
[18:02:32.222]   - Field: ‘job’
[18:02:32.224]   - Field: ‘conditions’
[18:02:32.225]   - Field: ‘expr’
[18:02:32.225]   - Field: ‘uuid’
[18:02:32.225]   - Field: ‘seed’
[18:02:32.225]   - Field: ‘version’
[18:02:32.226]   - Field: ‘result’
[18:02:32.226]   - Field: ‘asynchronous’
[18:02:32.226]   - Field: ‘calls’
[18:02:32.226]   - Field: ‘globals’
[18:02:32.226]   - Field: ‘stdout’
[18:02:32.227]   - Field: ‘earlySignal’
[18:02:32.227]   - Field: ‘lazy’
[18:02:32.227]   - Field: ‘state’
[18:02:32.227] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:32.227] - Launch lazy future ...
[18:02:32.228] Packages needed by the future expression (n = 0): <none>
[18:02:32.228] Packages needed by future strategies (n = 0): <none>
[18:02:32.229] {
[18:02:32.229]     {
[18:02:32.229]         {
[18:02:32.229]             ...future.startTime <- base::Sys.time()
[18:02:32.229]             {
[18:02:32.229]                 {
[18:02:32.229]                   {
[18:02:32.229]                     {
[18:02:32.229]                       base::local({
[18:02:32.229]                         has_future <- base::requireNamespace("future", 
[18:02:32.229]                           quietly = TRUE)
[18:02:32.229]                         if (has_future) {
[18:02:32.229]                           ns <- base::getNamespace("future")
[18:02:32.229]                           version <- ns[[".package"]][["version"]]
[18:02:32.229]                           if (is.null(version)) 
[18:02:32.229]                             version <- utils::packageVersion("future")
[18:02:32.229]                         }
[18:02:32.229]                         else {
[18:02:32.229]                           version <- NULL
[18:02:32.229]                         }
[18:02:32.229]                         if (!has_future || version < "1.8.0") {
[18:02:32.229]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:32.229]                             "", base::R.version$version.string), 
[18:02:32.229]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:32.229]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:32.229]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:32.229]                               "release", "version")], collapse = " "), 
[18:02:32.229]                             hostname = base::Sys.info()[["nodename"]])
[18:02:32.229]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:32.229]                             info)
[18:02:32.229]                           info <- base::paste(info, collapse = "; ")
[18:02:32.229]                           if (!has_future) {
[18:02:32.229]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:32.229]                               info)
[18:02:32.229]                           }
[18:02:32.229]                           else {
[18:02:32.229]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:32.229]                               info, version)
[18:02:32.229]                           }
[18:02:32.229]                           base::stop(msg)
[18:02:32.229]                         }
[18:02:32.229]                       })
[18:02:32.229]                     }
[18:02:32.229]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:32.229]                     base::options(mc.cores = 1L)
[18:02:32.229]                   }
[18:02:32.229]                   ...future.strategy.old <- future::plan("list")
[18:02:32.229]                   options(future.plan = NULL)
[18:02:32.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:32.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:32.229]                 }
[18:02:32.229]                 ...future.workdir <- getwd()
[18:02:32.229]             }
[18:02:32.229]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:32.229]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:32.229]         }
[18:02:32.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:32.229]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:32.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:32.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:32.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:32.229]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:32.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:32.229]             base::names(...future.oldOptions))
[18:02:32.229]     }
[18:02:32.229]     if (TRUE) {
[18:02:32.229]     }
[18:02:32.229]     else {
[18:02:32.229]         if (NA) {
[18:02:32.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:32.229]                 open = "w")
[18:02:32.229]         }
[18:02:32.229]         else {
[18:02:32.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:32.229]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:32.229]         }
[18:02:32.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:32.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:32.229]             base::sink(type = "output", split = FALSE)
[18:02:32.229]             base::close(...future.stdout)
[18:02:32.229]         }, add = TRUE)
[18:02:32.229]     }
[18:02:32.229]     ...future.frame <- base::sys.nframe()
[18:02:32.229]     ...future.conditions <- base::list()
[18:02:32.229]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:32.229]     if (FALSE) {
[18:02:32.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:32.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:32.229]     }
[18:02:32.229]     ...future.result <- base::tryCatch({
[18:02:32.229]         base::withCallingHandlers({
[18:02:32.229]             ...future.value <- base::withVisible(base::local({
[18:02:32.229]                 withCallingHandlers({
[18:02:32.229]                   {
[18:02:32.229]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:32.229]                     if (!identical(...future.globals.maxSize.org, 
[18:02:32.229]                       ...future.globals.maxSize)) {
[18:02:32.229]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:32.229]                       on.exit(options(oopts), add = TRUE)
[18:02:32.229]                     }
[18:02:32.229]                     {
[18:02:32.229]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:32.229]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:32.229]                         USE.NAMES = FALSE)
[18:02:32.229]                       do.call(mapply, args = args)
[18:02:32.229]                     }
[18:02:32.229]                   }
[18:02:32.229]                 }, immediateCondition = function(cond) {
[18:02:32.229]                   save_rds <- function (object, pathname, ...) 
[18:02:32.229]                   {
[18:02:32.229]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:32.229]                     if (file_test("-f", pathname_tmp)) {
[18:02:32.229]                       fi_tmp <- file.info(pathname_tmp)
[18:02:32.229]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:32.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:32.229]                         fi_tmp[["mtime"]])
[18:02:32.229]                     }
[18:02:32.229]                     tryCatch({
[18:02:32.229]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:32.229]                     }, error = function(ex) {
[18:02:32.229]                       msg <- conditionMessage(ex)
[18:02:32.229]                       fi_tmp <- file.info(pathname_tmp)
[18:02:32.229]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:32.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:32.229]                         fi_tmp[["mtime"]], msg)
[18:02:32.229]                       ex$message <- msg
[18:02:32.229]                       stop(ex)
[18:02:32.229]                     })
[18:02:32.229]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:32.229]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:32.229]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:32.229]                       fi_tmp <- file.info(pathname_tmp)
[18:02:32.229]                       fi <- file.info(pathname)
[18:02:32.229]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:32.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:32.229]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:32.229]                         fi[["size"]], fi[["mtime"]])
[18:02:32.229]                       stop(msg)
[18:02:32.229]                     }
[18:02:32.229]                     invisible(pathname)
[18:02:32.229]                   }
[18:02:32.229]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:32.229]                     rootPath = tempdir()) 
[18:02:32.229]                   {
[18:02:32.229]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:32.229]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:32.229]                       tmpdir = path, fileext = ".rds")
[18:02:32.229]                     save_rds(obj, file)
[18:02:32.229]                   }
[18:02:32.229]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1j8FfD/.future/immediateConditions")
[18:02:32.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:32.229]                   {
[18:02:32.229]                     inherits <- base::inherits
[18:02:32.229]                     invokeRestart <- base::invokeRestart
[18:02:32.229]                     is.null <- base::is.null
[18:02:32.229]                     muffled <- FALSE
[18:02:32.229]                     if (inherits(cond, "message")) {
[18:02:32.229]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:32.229]                       if (muffled) 
[18:02:32.229]                         invokeRestart("muffleMessage")
[18:02:32.229]                     }
[18:02:32.229]                     else if (inherits(cond, "warning")) {
[18:02:32.229]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:32.229]                       if (muffled) 
[18:02:32.229]                         invokeRestart("muffleWarning")
[18:02:32.229]                     }
[18:02:32.229]                     else if (inherits(cond, "condition")) {
[18:02:32.229]                       if (!is.null(pattern)) {
[18:02:32.229]                         computeRestarts <- base::computeRestarts
[18:02:32.229]                         grepl <- base::grepl
[18:02:32.229]                         restarts <- computeRestarts(cond)
[18:02:32.229]                         for (restart in restarts) {
[18:02:32.229]                           name <- restart$name
[18:02:32.229]                           if (is.null(name)) 
[18:02:32.229]                             next
[18:02:32.229]                           if (!grepl(pattern, name)) 
[18:02:32.229]                             next
[18:02:32.229]                           invokeRestart(restart)
[18:02:32.229]                           muffled <- TRUE
[18:02:32.229]                           break
[18:02:32.229]                         }
[18:02:32.229]                       }
[18:02:32.229]                     }
[18:02:32.229]                     invisible(muffled)
[18:02:32.229]                   }
[18:02:32.229]                   muffleCondition(cond)
[18:02:32.229]                 })
[18:02:32.229]             }))
[18:02:32.229]             future::FutureResult(value = ...future.value$value, 
[18:02:32.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:32.229]                   ...future.rng), globalenv = if (FALSE) 
[18:02:32.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:32.229]                     ...future.globalenv.names))
[18:02:32.229]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:32.229]         }, condition = base::local({
[18:02:32.229]             c <- base::c
[18:02:32.229]             inherits <- base::inherits
[18:02:32.229]             invokeRestart <- base::invokeRestart
[18:02:32.229]             length <- base::length
[18:02:32.229]             list <- base::list
[18:02:32.229]             seq.int <- base::seq.int
[18:02:32.229]             signalCondition <- base::signalCondition
[18:02:32.229]             sys.calls <- base::sys.calls
[18:02:32.229]             `[[` <- base::`[[`
[18:02:32.229]             `+` <- base::`+`
[18:02:32.229]             `<<-` <- base::`<<-`
[18:02:32.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:32.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:32.229]                   3L)]
[18:02:32.229]             }
[18:02:32.229]             function(cond) {
[18:02:32.229]                 is_error <- inherits(cond, "error")
[18:02:32.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:32.229]                   NULL)
[18:02:32.229]                 if (is_error) {
[18:02:32.229]                   sessionInformation <- function() {
[18:02:32.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:32.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:32.229]                       search = base::search(), system = base::Sys.info())
[18:02:32.229]                   }
[18:02:32.229]                   ...future.conditions[[length(...future.conditions) + 
[18:02:32.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:32.229]                     cond$call), session = sessionInformation(), 
[18:02:32.229]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:32.229]                   signalCondition(cond)
[18:02:32.229]                 }
[18:02:32.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:32.229]                 "immediateCondition"))) {
[18:02:32.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:32.229]                   ...future.conditions[[length(...future.conditions) + 
[18:02:32.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:32.229]                   if (TRUE && !signal) {
[18:02:32.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:32.229]                     {
[18:02:32.229]                       inherits <- base::inherits
[18:02:32.229]                       invokeRestart <- base::invokeRestart
[18:02:32.229]                       is.null <- base::is.null
[18:02:32.229]                       muffled <- FALSE
[18:02:32.229]                       if (inherits(cond, "message")) {
[18:02:32.229]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:32.229]                         if (muffled) 
[18:02:32.229]                           invokeRestart("muffleMessage")
[18:02:32.229]                       }
[18:02:32.229]                       else if (inherits(cond, "warning")) {
[18:02:32.229]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:32.229]                         if (muffled) 
[18:02:32.229]                           invokeRestart("muffleWarning")
[18:02:32.229]                       }
[18:02:32.229]                       else if (inherits(cond, "condition")) {
[18:02:32.229]                         if (!is.null(pattern)) {
[18:02:32.229]                           computeRestarts <- base::computeRestarts
[18:02:32.229]                           grepl <- base::grepl
[18:02:32.229]                           restarts <- computeRestarts(cond)
[18:02:32.229]                           for (restart in restarts) {
[18:02:32.229]                             name <- restart$name
[18:02:32.229]                             if (is.null(name)) 
[18:02:32.229]                               next
[18:02:32.229]                             if (!grepl(pattern, name)) 
[18:02:32.229]                               next
[18:02:32.229]                             invokeRestart(restart)
[18:02:32.229]                             muffled <- TRUE
[18:02:32.229]                             break
[18:02:32.229]                           }
[18:02:32.229]                         }
[18:02:32.229]                       }
[18:02:32.229]                       invisible(muffled)
[18:02:32.229]                     }
[18:02:32.229]                     muffleCondition(cond, pattern = "^muffle")
[18:02:32.229]                   }
[18:02:32.229]                 }
[18:02:32.229]                 else {
[18:02:32.229]                   if (TRUE) {
[18:02:32.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:32.229]                     {
[18:02:32.229]                       inherits <- base::inherits
[18:02:32.229]                       invokeRestart <- base::invokeRestart
[18:02:32.229]                       is.null <- base::is.null
[18:02:32.229]                       muffled <- FALSE
[18:02:32.229]                       if (inherits(cond, "message")) {
[18:02:32.229]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:32.229]                         if (muffled) 
[18:02:32.229]                           invokeRestart("muffleMessage")
[18:02:32.229]                       }
[18:02:32.229]                       else if (inherits(cond, "warning")) {
[18:02:32.229]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:32.229]                         if (muffled) 
[18:02:32.229]                           invokeRestart("muffleWarning")
[18:02:32.229]                       }
[18:02:32.229]                       else if (inherits(cond, "condition")) {
[18:02:32.229]                         if (!is.null(pattern)) {
[18:02:32.229]                           computeRestarts <- base::computeRestarts
[18:02:32.229]                           grepl <- base::grepl
[18:02:32.229]                           restarts <- computeRestarts(cond)
[18:02:32.229]                           for (restart in restarts) {
[18:02:32.229]                             name <- restart$name
[18:02:32.229]                             if (is.null(name)) 
[18:02:32.229]                               next
[18:02:32.229]                             if (!grepl(pattern, name)) 
[18:02:32.229]                               next
[18:02:32.229]                             invokeRestart(restart)
[18:02:32.229]                             muffled <- TRUE
[18:02:32.229]                             break
[18:02:32.229]                           }
[18:02:32.229]                         }
[18:02:32.229]                       }
[18:02:32.229]                       invisible(muffled)
[18:02:32.229]                     }
[18:02:32.229]                     muffleCondition(cond, pattern = "^muffle")
[18:02:32.229]                   }
[18:02:32.229]                 }
[18:02:32.229]             }
[18:02:32.229]         }))
[18:02:32.229]     }, error = function(ex) {
[18:02:32.229]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:32.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:32.229]                 ...future.rng), started = ...future.startTime, 
[18:02:32.229]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:32.229]             version = "1.8"), class = "FutureResult")
[18:02:32.229]     }, finally = {
[18:02:32.229]         if (!identical(...future.workdir, getwd())) 
[18:02:32.229]             setwd(...future.workdir)
[18:02:32.229]         {
[18:02:32.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:32.229]                 ...future.oldOptions$nwarnings <- NULL
[18:02:32.229]             }
[18:02:32.229]             base::options(...future.oldOptions)
[18:02:32.229]             if (.Platform$OS.type == "windows") {
[18:02:32.229]                 old_names <- names(...future.oldEnvVars)
[18:02:32.229]                 envs <- base::Sys.getenv()
[18:02:32.229]                 names <- names(envs)
[18:02:32.229]                 common <- intersect(names, old_names)
[18:02:32.229]                 added <- setdiff(names, old_names)
[18:02:32.229]                 removed <- setdiff(old_names, names)
[18:02:32.229]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:32.229]                   envs[common]]
[18:02:32.229]                 NAMES <- toupper(changed)
[18:02:32.229]                 args <- list()
[18:02:32.229]                 for (kk in seq_along(NAMES)) {
[18:02:32.229]                   name <- changed[[kk]]
[18:02:32.229]                   NAME <- NAMES[[kk]]
[18:02:32.229]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:32.229]                     next
[18:02:32.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:32.229]                 }
[18:02:32.229]                 NAMES <- toupper(added)
[18:02:32.229]                 for (kk in seq_along(NAMES)) {
[18:02:32.229]                   name <- added[[kk]]
[18:02:32.229]                   NAME <- NAMES[[kk]]
[18:02:32.229]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:32.229]                     next
[18:02:32.229]                   args[[name]] <- ""
[18:02:32.229]                 }
[18:02:32.229]                 NAMES <- toupper(removed)
[18:02:32.229]                 for (kk in seq_along(NAMES)) {
[18:02:32.229]                   name <- removed[[kk]]
[18:02:32.229]                   NAME <- NAMES[[kk]]
[18:02:32.229]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:32.229]                     next
[18:02:32.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:32.229]                 }
[18:02:32.229]                 if (length(args) > 0) 
[18:02:32.229]                   base::do.call(base::Sys.setenv, args = args)
[18:02:32.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:32.229]             }
[18:02:32.229]             else {
[18:02:32.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:32.229]             }
[18:02:32.229]             {
[18:02:32.229]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:32.229]                   0L) {
[18:02:32.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:32.229]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:32.229]                   base::options(opts)
[18:02:32.229]                 }
[18:02:32.229]                 {
[18:02:32.229]                   {
[18:02:32.229]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:32.229]                     NULL
[18:02:32.229]                   }
[18:02:32.229]                   options(future.plan = NULL)
[18:02:32.229]                   if (is.na(NA_character_)) 
[18:02:32.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:32.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:32.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:32.229]                     .init = FALSE)
[18:02:32.229]                 }
[18:02:32.229]             }
[18:02:32.229]         }
[18:02:32.229]     })
[18:02:32.229]     if (FALSE) {
[18:02:32.229]         base::sink(type = "output", split = FALSE)
[18:02:32.229]         if (NA) {
[18:02:32.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:32.229]         }
[18:02:32.229]         else {
[18:02:32.229]             ...future.result["stdout"] <- base::list(NULL)
[18:02:32.229]         }
[18:02:32.229]         base::close(...future.stdout)
[18:02:32.229]         ...future.stdout <- NULL
[18:02:32.229]     }
[18:02:32.229]     ...future.result$conditions <- ...future.conditions
[18:02:32.229]     ...future.result$finished <- base::Sys.time()
[18:02:32.229]     ...future.result
[18:02:32.229] }
[18:02:32.234] assign_globals() ...
[18:02:32.234] List of 5
[18:02:32.234]  $ ...future.FUN            :function (x, y)  
[18:02:32.234]  $ MoreArgs                 : NULL
[18:02:32.234]  $ ...future.elements_ii    :List of 2
[18:02:32.234]   ..$ :List of 1
[18:02:32.234]   .. ..$ : int 1
[18:02:32.234]   ..$ :List of 1
[18:02:32.234]   .. ..$ : int 0
[18:02:32.234]  $ ...future.seeds_ii       : NULL
[18:02:32.234]  $ ...future.globals.maxSize: NULL
[18:02:32.234]  - attr(*, "where")=List of 5
[18:02:32.234]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:32.234]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:32.234]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:32.234]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:32.234]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:32.234]  - attr(*, "resolved")= logi FALSE
[18:02:32.234]  - attr(*, "total_size")= num 6368
[18:02:32.234]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:32.234]  - attr(*, "already-done")= logi TRUE
[18:02:32.244] - reassign environment for ‘...future.FUN’
[18:02:32.244] - copied ‘...future.FUN’ to environment
[18:02:32.244] - copied ‘MoreArgs’ to environment
[18:02:32.245] - copied ‘...future.elements_ii’ to environment
[18:02:32.245] - copied ‘...future.seeds_ii’ to environment
[18:02:32.245] - copied ‘...future.globals.maxSize’ to environment
[18:02:32.245] assign_globals() ... done
[18:02:32.245] requestCore(): workers = 2
[18:02:32.251] MulticoreFuture started
[18:02:32.252] - Launch lazy future ... done
[18:02:32.252] run() for ‘MulticoreFuture’ ... done
[18:02:32.254] plan(): Setting new future strategy stack:
[18:02:32.253] Created future:
[18:02:32.254] List of future strategies:
[18:02:32.254] 1. sequential:
[18:02:32.254]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:32.254]    - tweaked: FALSE
[18:02:32.254]    - call: NULL
[18:02:32.258] plan(): nbrOfWorkers() = 1
[18:02:32.255] MulticoreFuture:
[18:02:32.255] Label: ‘future_mapply-1’
[18:02:32.255] Expression:
[18:02:32.255] {
[18:02:32.255]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:32.255]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:32.255]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:32.255]         on.exit(options(oopts), add = TRUE)
[18:02:32.255]     }
[18:02:32.255]     {
[18:02:32.255]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:32.255]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:32.255]         do.call(mapply, args = args)
[18:02:32.255]     }
[18:02:32.255] }
[18:02:32.255] Lazy evaluation: FALSE
[18:02:32.255] Asynchronous evaluation: TRUE
[18:02:32.255] Local evaluation: TRUE
[18:02:32.255] Environment: R_GlobalEnv
[18:02:32.255] Capture standard output: NA
[18:02:32.255] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:32.255] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:32.255] Packages: <none>
[18:02:32.255] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:32.255] Resolved: FALSE
[18:02:32.255] Value: <not collected>
[18:02:32.255] Conditions captured: <none>
[18:02:32.255] Early signaling: FALSE
[18:02:32.255] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:32.255] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:32.272] Chunk #1 of 2 ... DONE
[18:02:32.272] Chunk #2 of 2 ...
[18:02:32.273]  - Finding globals in '...' for chunk #2 ...
[18:02:32.273] getGlobalsAndPackages() ...
[18:02:32.274] Searching for globals...
[18:02:32.275] 
[18:02:32.276] Searching for globals ... DONE
[18:02:32.276] - globals: [0] <none>
[18:02:32.276] getGlobalsAndPackages() ... DONE
[18:02:32.277]    + additional globals found: [n=0] 
[18:02:32.277]    + additional namespaces needed: [n=0] 
[18:02:32.277]  - Finding globals in '...' for chunk #2 ... DONE
[18:02:32.278]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:32.278]  - seeds: <none>
[18:02:32.278]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:32.279] getGlobalsAndPackages() ...
[18:02:32.279] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:32.279] Resolving globals: FALSE
[18:02:32.281] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[18:02:32.283] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:32.284] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:32.284] 
[18:02:32.285] getGlobalsAndPackages() ... DONE
[18:02:32.286] run() for ‘Future’ ...
[18:02:32.286] - state: ‘created’
[18:02:32.287] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[18:02:32.297] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:32.297] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[18:02:32.297]   - Field: ‘label’
[18:02:32.298]   - Field: ‘local’
[18:02:32.298]   - Field: ‘owner’
[18:02:32.298]   - Field: ‘envir’
[18:02:32.299]   - Field: ‘workers’
[18:02:32.299]   - Field: ‘packages’
[18:02:32.299]   - Field: ‘gc’
[18:02:32.300]   - Field: ‘job’
[18:02:32.300]   - Field: ‘conditions’
[18:02:32.300]   - Field: ‘expr’
[18:02:32.301]   - Field: ‘uuid’
[18:02:32.301]   - Field: ‘seed’
[18:02:32.301]   - Field: ‘version’
[18:02:32.302]   - Field: ‘result’
[18:02:32.302]   - Field: ‘asynchronous’
[18:02:32.302]   - Field: ‘calls’
[18:02:32.303]   - Field: ‘globals’
[18:02:32.303]   - Field: ‘stdout’
[18:02:32.303]   - Field: ‘earlySignal’
[18:02:32.304]   - Field: ‘lazy’
[18:02:32.304]   - Field: ‘state’
[18:02:32.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[18:02:32.305] - Launch lazy future ...
[18:02:32.306] Packages needed by the future expression (n = 0): <none>
[18:02:32.306] Packages needed by future strategies (n = 0): <none>
[18:02:32.307] {
[18:02:32.307]     {
[18:02:32.307]         {
[18:02:32.307]             ...future.startTime <- base::Sys.time()
[18:02:32.307]             {
[18:02:32.307]                 {
[18:02:32.307]                   {
[18:02:32.307]                     {
[18:02:32.307]                       base::local({
[18:02:32.307]                         has_future <- base::requireNamespace("future", 
[18:02:32.307]                           quietly = TRUE)
[18:02:32.307]                         if (has_future) {
[18:02:32.307]                           ns <- base::getNamespace("future")
[18:02:32.307]                           version <- ns[[".package"]][["version"]]
[18:02:32.307]                           if (is.null(version)) 
[18:02:32.307]                             version <- utils::packageVersion("future")
[18:02:32.307]                         }
[18:02:32.307]                         else {
[18:02:32.307]                           version <- NULL
[18:02:32.307]                         }
[18:02:32.307]                         if (!has_future || version < "1.8.0") {
[18:02:32.307]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:32.307]                             "", base::R.version$version.string), 
[18:02:32.307]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:32.307]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:32.307]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:32.307]                               "release", "version")], collapse = " "), 
[18:02:32.307]                             hostname = base::Sys.info()[["nodename"]])
[18:02:32.307]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:32.307]                             info)
[18:02:32.307]                           info <- base::paste(info, collapse = "; ")
[18:02:32.307]                           if (!has_future) {
[18:02:32.307]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:32.307]                               info)
[18:02:32.307]                           }
[18:02:32.307]                           else {
[18:02:32.307]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:32.307]                               info, version)
[18:02:32.307]                           }
[18:02:32.307]                           base::stop(msg)
[18:02:32.307]                         }
[18:02:32.307]                       })
[18:02:32.307]                     }
[18:02:32.307]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:32.307]                     base::options(mc.cores = 1L)
[18:02:32.307]                   }
[18:02:32.307]                   ...future.strategy.old <- future::plan("list")
[18:02:32.307]                   options(future.plan = NULL)
[18:02:32.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:32.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:32.307]                 }
[18:02:32.307]                 ...future.workdir <- getwd()
[18:02:32.307]             }
[18:02:32.307]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:32.307]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:32.307]         }
[18:02:32.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:32.307]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:32.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:32.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:32.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:32.307]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:32.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:32.307]             base::names(...future.oldOptions))
[18:02:32.307]     }
[18:02:32.307]     if (TRUE) {
[18:02:32.307]     }
[18:02:32.307]     else {
[18:02:32.307]         if (NA) {
[18:02:32.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:32.307]                 open = "w")
[18:02:32.307]         }
[18:02:32.307]         else {
[18:02:32.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:32.307]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:32.307]         }
[18:02:32.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:32.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:32.307]             base::sink(type = "output", split = FALSE)
[18:02:32.307]             base::close(...future.stdout)
[18:02:32.307]         }, add = TRUE)
[18:02:32.307]     }
[18:02:32.307]     ...future.frame <- base::sys.nframe()
[18:02:32.307]     ...future.conditions <- base::list()
[18:02:32.307]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:32.307]     if (FALSE) {
[18:02:32.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:32.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:32.307]     }
[18:02:32.307]     ...future.result <- base::tryCatch({
[18:02:32.307]         base::withCallingHandlers({
[18:02:32.307]             ...future.value <- base::withVisible(base::local({
[18:02:32.307]                 withCallingHandlers({
[18:02:32.307]                   {
[18:02:32.307]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:32.307]                     if (!identical(...future.globals.maxSize.org, 
[18:02:32.307]                       ...future.globals.maxSize)) {
[18:02:32.307]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:32.307]                       on.exit(options(oopts), add = TRUE)
[18:02:32.307]                     }
[18:02:32.307]                     {
[18:02:32.307]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:32.307]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:32.307]                         USE.NAMES = FALSE)
[18:02:32.307]                       do.call(mapply, args = args)
[18:02:32.307]                     }
[18:02:32.307]                   }
[18:02:32.307]                 }, immediateCondition = function(cond) {
[18:02:32.307]                   save_rds <- function (object, pathname, ...) 
[18:02:32.307]                   {
[18:02:32.307]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[18:02:32.307]                     if (file_test("-f", pathname_tmp)) {
[18:02:32.307]                       fi_tmp <- file.info(pathname_tmp)
[18:02:32.307]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[18:02:32.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:32.307]                         fi_tmp[["mtime"]])
[18:02:32.307]                     }
[18:02:32.307]                     tryCatch({
[18:02:32.307]                       saveRDS(object, file = pathname_tmp, ...)
[18:02:32.307]                     }, error = function(ex) {
[18:02:32.307]                       msg <- conditionMessage(ex)
[18:02:32.307]                       fi_tmp <- file.info(pathname_tmp)
[18:02:32.307]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[18:02:32.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:32.307]                         fi_tmp[["mtime"]], msg)
[18:02:32.307]                       ex$message <- msg
[18:02:32.307]                       stop(ex)
[18:02:32.307]                     })
[18:02:32.307]                     stopifnot(file_test("-f", pathname_tmp))
[18:02:32.307]                     res <- file.rename(from = pathname_tmp, to = pathname)
[18:02:32.307]                     if (!res || file_test("-f", pathname_tmp)) {
[18:02:32.307]                       fi_tmp <- file.info(pathname_tmp)
[18:02:32.307]                       fi <- file.info(pathname)
[18:02:32.307]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[18:02:32.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[18:02:32.307]                         fi_tmp[["mtime"]], sQuote(pathname), 
[18:02:32.307]                         fi[["size"]], fi[["mtime"]])
[18:02:32.307]                       stop(msg)
[18:02:32.307]                     }
[18:02:32.307]                     invisible(pathname)
[18:02:32.307]                   }
[18:02:32.307]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[18:02:32.307]                     rootPath = tempdir()) 
[18:02:32.307]                   {
[18:02:32.307]                     obj <- list(time = Sys.time(), condition = cond)
[18:02:32.307]                     file <- tempfile(pattern = class(cond)[1], 
[18:02:32.307]                       tmpdir = path, fileext = ".rds")
[18:02:32.307]                     save_rds(obj, file)
[18:02:32.307]                   }
[18:02:32.307]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1j8FfD/.future/immediateConditions")
[18:02:32.307]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:32.307]                   {
[18:02:32.307]                     inherits <- base::inherits
[18:02:32.307]                     invokeRestart <- base::invokeRestart
[18:02:32.307]                     is.null <- base::is.null
[18:02:32.307]                     muffled <- FALSE
[18:02:32.307]                     if (inherits(cond, "message")) {
[18:02:32.307]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:32.307]                       if (muffled) 
[18:02:32.307]                         invokeRestart("muffleMessage")
[18:02:32.307]                     }
[18:02:32.307]                     else if (inherits(cond, "warning")) {
[18:02:32.307]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:32.307]                       if (muffled) 
[18:02:32.307]                         invokeRestart("muffleWarning")
[18:02:32.307]                     }
[18:02:32.307]                     else if (inherits(cond, "condition")) {
[18:02:32.307]                       if (!is.null(pattern)) {
[18:02:32.307]                         computeRestarts <- base::computeRestarts
[18:02:32.307]                         grepl <- base::grepl
[18:02:32.307]                         restarts <- computeRestarts(cond)
[18:02:32.307]                         for (restart in restarts) {
[18:02:32.307]                           name <- restart$name
[18:02:32.307]                           if (is.null(name)) 
[18:02:32.307]                             next
[18:02:32.307]                           if (!grepl(pattern, name)) 
[18:02:32.307]                             next
[18:02:32.307]                           invokeRestart(restart)
[18:02:32.307]                           muffled <- TRUE
[18:02:32.307]                           break
[18:02:32.307]                         }
[18:02:32.307]                       }
[18:02:32.307]                     }
[18:02:32.307]                     invisible(muffled)
[18:02:32.307]                   }
[18:02:32.307]                   muffleCondition(cond)
[18:02:32.307]                 })
[18:02:32.307]             }))
[18:02:32.307]             future::FutureResult(value = ...future.value$value, 
[18:02:32.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:32.307]                   ...future.rng), globalenv = if (FALSE) 
[18:02:32.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:32.307]                     ...future.globalenv.names))
[18:02:32.307]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:32.307]         }, condition = base::local({
[18:02:32.307]             c <- base::c
[18:02:32.307]             inherits <- base::inherits
[18:02:32.307]             invokeRestart <- base::invokeRestart
[18:02:32.307]             length <- base::length
[18:02:32.307]             list <- base::list
[18:02:32.307]             seq.int <- base::seq.int
[18:02:32.307]             signalCondition <- base::signalCondition
[18:02:32.307]             sys.calls <- base::sys.calls
[18:02:32.307]             `[[` <- base::`[[`
[18:02:32.307]             `+` <- base::`+`
[18:02:32.307]             `<<-` <- base::`<<-`
[18:02:32.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:32.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:32.307]                   3L)]
[18:02:32.307]             }
[18:02:32.307]             function(cond) {
[18:02:32.307]                 is_error <- inherits(cond, "error")
[18:02:32.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:32.307]                   NULL)
[18:02:32.307]                 if (is_error) {
[18:02:32.307]                   sessionInformation <- function() {
[18:02:32.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:32.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:32.307]                       search = base::search(), system = base::Sys.info())
[18:02:32.307]                   }
[18:02:32.307]                   ...future.conditions[[length(...future.conditions) + 
[18:02:32.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:32.307]                     cond$call), session = sessionInformation(), 
[18:02:32.307]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:32.307]                   signalCondition(cond)
[18:02:32.307]                 }
[18:02:32.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:32.307]                 "immediateCondition"))) {
[18:02:32.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:32.307]                   ...future.conditions[[length(...future.conditions) + 
[18:02:32.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:32.307]                   if (TRUE && !signal) {
[18:02:32.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:32.307]                     {
[18:02:32.307]                       inherits <- base::inherits
[18:02:32.307]                       invokeRestart <- base::invokeRestart
[18:02:32.307]                       is.null <- base::is.null
[18:02:32.307]                       muffled <- FALSE
[18:02:32.307]                       if (inherits(cond, "message")) {
[18:02:32.307]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:32.307]                         if (muffled) 
[18:02:32.307]                           invokeRestart("muffleMessage")
[18:02:32.307]                       }
[18:02:32.307]                       else if (inherits(cond, "warning")) {
[18:02:32.307]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:32.307]                         if (muffled) 
[18:02:32.307]                           invokeRestart("muffleWarning")
[18:02:32.307]                       }
[18:02:32.307]                       else if (inherits(cond, "condition")) {
[18:02:32.307]                         if (!is.null(pattern)) {
[18:02:32.307]                           computeRestarts <- base::computeRestarts
[18:02:32.307]                           grepl <- base::grepl
[18:02:32.307]                           restarts <- computeRestarts(cond)
[18:02:32.307]                           for (restart in restarts) {
[18:02:32.307]                             name <- restart$name
[18:02:32.307]                             if (is.null(name)) 
[18:02:32.307]                               next
[18:02:32.307]                             if (!grepl(pattern, name)) 
[18:02:32.307]                               next
[18:02:32.307]                             invokeRestart(restart)
[18:02:32.307]                             muffled <- TRUE
[18:02:32.307]                             break
[18:02:32.307]                           }
[18:02:32.307]                         }
[18:02:32.307]                       }
[18:02:32.307]                       invisible(muffled)
[18:02:32.307]                     }
[18:02:32.307]                     muffleCondition(cond, pattern = "^muffle")
[18:02:32.307]                   }
[18:02:32.307]                 }
[18:02:32.307]                 else {
[18:02:32.307]                   if (TRUE) {
[18:02:32.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:32.307]                     {
[18:02:32.307]                       inherits <- base::inherits
[18:02:32.307]                       invokeRestart <- base::invokeRestart
[18:02:32.307]                       is.null <- base::is.null
[18:02:32.307]                       muffled <- FALSE
[18:02:32.307]                       if (inherits(cond, "message")) {
[18:02:32.307]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:32.307]                         if (muffled) 
[18:02:32.307]                           invokeRestart("muffleMessage")
[18:02:32.307]                       }
[18:02:32.307]                       else if (inherits(cond, "warning")) {
[18:02:32.307]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:32.307]                         if (muffled) 
[18:02:32.307]                           invokeRestart("muffleWarning")
[18:02:32.307]                       }
[18:02:32.307]                       else if (inherits(cond, "condition")) {
[18:02:32.307]                         if (!is.null(pattern)) {
[18:02:32.307]                           computeRestarts <- base::computeRestarts
[18:02:32.307]                           grepl <- base::grepl
[18:02:32.307]                           restarts <- computeRestarts(cond)
[18:02:32.307]                           for (restart in restarts) {
[18:02:32.307]                             name <- restart$name
[18:02:32.307]                             if (is.null(name)) 
[18:02:32.307]                               next
[18:02:32.307]                             if (!grepl(pattern, name)) 
[18:02:32.307]                               next
[18:02:32.307]                             invokeRestart(restart)
[18:02:32.307]                             muffled <- TRUE
[18:02:32.307]                             break
[18:02:32.307]                           }
[18:02:32.307]                         }
[18:02:32.307]                       }
[18:02:32.307]                       invisible(muffled)
[18:02:32.307]                     }
[18:02:32.307]                     muffleCondition(cond, pattern = "^muffle")
[18:02:32.307]                   }
[18:02:32.307]                 }
[18:02:32.307]             }
[18:02:32.307]         }))
[18:02:32.307]     }, error = function(ex) {
[18:02:32.307]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:32.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:32.307]                 ...future.rng), started = ...future.startTime, 
[18:02:32.307]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:32.307]             version = "1.8"), class = "FutureResult")
[18:02:32.307]     }, finally = {
[18:02:32.307]         if (!identical(...future.workdir, getwd())) 
[18:02:32.307]             setwd(...future.workdir)
[18:02:32.307]         {
[18:02:32.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:32.307]                 ...future.oldOptions$nwarnings <- NULL
[18:02:32.307]             }
[18:02:32.307]             base::options(...future.oldOptions)
[18:02:32.307]             if (.Platform$OS.type == "windows") {
[18:02:32.307]                 old_names <- names(...future.oldEnvVars)
[18:02:32.307]                 envs <- base::Sys.getenv()
[18:02:32.307]                 names <- names(envs)
[18:02:32.307]                 common <- intersect(names, old_names)
[18:02:32.307]                 added <- setdiff(names, old_names)
[18:02:32.307]                 removed <- setdiff(old_names, names)
[18:02:32.307]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:32.307]                   envs[common]]
[18:02:32.307]                 NAMES <- toupper(changed)
[18:02:32.307]                 args <- list()
[18:02:32.307]                 for (kk in seq_along(NAMES)) {
[18:02:32.307]                   name <- changed[[kk]]
[18:02:32.307]                   NAME <- NAMES[[kk]]
[18:02:32.307]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:32.307]                     next
[18:02:32.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:32.307]                 }
[18:02:32.307]                 NAMES <- toupper(added)
[18:02:32.307]                 for (kk in seq_along(NAMES)) {
[18:02:32.307]                   name <- added[[kk]]
[18:02:32.307]                   NAME <- NAMES[[kk]]
[18:02:32.307]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:32.307]                     next
[18:02:32.307]                   args[[name]] <- ""
[18:02:32.307]                 }
[18:02:32.307]                 NAMES <- toupper(removed)
[18:02:32.307]                 for (kk in seq_along(NAMES)) {
[18:02:32.307]                   name <- removed[[kk]]
[18:02:32.307]                   NAME <- NAMES[[kk]]
[18:02:32.307]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:32.307]                     next
[18:02:32.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:32.307]                 }
[18:02:32.307]                 if (length(args) > 0) 
[18:02:32.307]                   base::do.call(base::Sys.setenv, args = args)
[18:02:32.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:32.307]             }
[18:02:32.307]             else {
[18:02:32.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:32.307]             }
[18:02:32.307]             {
[18:02:32.307]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:32.307]                   0L) {
[18:02:32.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:32.307]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:32.307]                   base::options(opts)
[18:02:32.307]                 }
[18:02:32.307]                 {
[18:02:32.307]                   {
[18:02:32.307]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:32.307]                     NULL
[18:02:32.307]                   }
[18:02:32.307]                   options(future.plan = NULL)
[18:02:32.307]                   if (is.na(NA_character_)) 
[18:02:32.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:32.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:32.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:32.307]                     .init = FALSE)
[18:02:32.307]                 }
[18:02:32.307]             }
[18:02:32.307]         }
[18:02:32.307]     })
[18:02:32.307]     if (FALSE) {
[18:02:32.307]         base::sink(type = "output", split = FALSE)
[18:02:32.307]         if (NA) {
[18:02:32.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:32.307]         }
[18:02:32.307]         else {
[18:02:32.307]             ...future.result["stdout"] <- base::list(NULL)
[18:02:32.307]         }
[18:02:32.307]         base::close(...future.stdout)
[18:02:32.307]         ...future.stdout <- NULL
[18:02:32.307]     }
[18:02:32.307]     ...future.result$conditions <- ...future.conditions
[18:02:32.307]     ...future.result$finished <- base::Sys.time()
[18:02:32.307]     ...future.result
[18:02:32.307] }
[18:02:32.315] assign_globals() ...
[18:02:32.316] List of 5
[18:02:32.316]  $ ...future.FUN            :function (x, y)  
[18:02:32.316]  $ MoreArgs                 : NULL
[18:02:32.316]  $ ...future.elements_ii    :List of 2
[18:02:32.316]   ..$ :List of 1
[18:02:32.316]   .. ..$ : int 0
[18:02:32.316]   ..$ :List of 1
[18:02:32.316]   .. ..$ : int 1
[18:02:32.316]  $ ...future.seeds_ii       : NULL
[18:02:32.316]  $ ...future.globals.maxSize: NULL
[18:02:32.316]  - attr(*, "where")=List of 5
[18:02:32.316]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[18:02:32.316]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[18:02:32.316]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[18:02:32.316]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[18:02:32.316]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[18:02:32.316]  - attr(*, "resolved")= logi FALSE
[18:02:32.316]  - attr(*, "total_size")= num 6368
[18:02:32.316]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:32.316]  - attr(*, "already-done")= logi TRUE
[18:02:32.351] - reassign environment for ‘...future.FUN’
[18:02:32.351] - copied ‘...future.FUN’ to environment
[18:02:32.351] - copied ‘MoreArgs’ to environment
[18:02:32.351] - copied ‘...future.elements_ii’ to environment
[18:02:32.352] - copied ‘...future.seeds_ii’ to environment
[18:02:32.352] - copied ‘...future.globals.maxSize’ to environment
[18:02:32.352] assign_globals() ... done
[18:02:32.352] requestCore(): workers = 2
[18:02:32.356] MulticoreFuture started
[18:02:32.357] - Launch lazy future ... done
[18:02:32.358] run() for ‘MulticoreFuture’ ... done
[18:02:32.358] plan(): Setting new future strategy stack:
[18:02:32.359] Created future:
[18:02:32.359] List of future strategies:
[18:02:32.359] 1. sequential:
[18:02:32.359]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:32.359]    - tweaked: FALSE
[18:02:32.359]    - call: NULL
[18:02:32.362] plan(): nbrOfWorkers() = 1
[18:02:32.367] plan(): Setting new future strategy stack:
[18:02:32.367] List of future strategies:
[18:02:32.367] 1. multicore:
[18:02:32.367]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:32.367]    - tweaked: FALSE
[18:02:32.367]    - call: plan(strategy)
[18:02:32.359] MulticoreFuture:
[18:02:32.359] Label: ‘future_mapply-2’
[18:02:32.359] Expression:
[18:02:32.359] {
[18:02:32.359]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:32.359]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:32.359]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:32.359]         on.exit(options(oopts), add = TRUE)
[18:02:32.359]     }
[18:02:32.359]     {
[18:02:32.359]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:32.359]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:32.359]         do.call(mapply, args = args)
[18:02:32.359]     }
[18:02:32.359] }
[18:02:32.359] Lazy evaluation: FALSE
[18:02:32.359] Asynchronous evaluation: TRUE
[18:02:32.359] Local evaluation: TRUE
[18:02:32.359] Environment: R_GlobalEnv
[18:02:32.359] Capture standard output: NA
[18:02:32.359] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:32.359] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:32.359] Packages: <none>
[18:02:32.359] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:32.359] Resolved: FALSE
[18:02:32.359] Value: <not collected>
[18:02:32.359] Conditions captured: <none>
[18:02:32.359] Early signaling: FALSE
[18:02:32.359] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:32.359] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:32.375] Chunk #2 of 2 ... DONE
[18:02:32.375] Launching 2 futures (chunks) ... DONE
[18:02:32.376] Resolving 2 futures (chunks) ...
[18:02:32.376] resolve() on list ...
[18:02:32.377]  recursive: 0
[18:02:32.377]  length: 2
[18:02:32.377] 
[18:02:32.381] plan(): nbrOfWorkers() = 2
[18:02:32.389] Future #2
[18:02:32.389] result() for MulticoreFuture ...
[18:02:32.391] result() for MulticoreFuture ...
[18:02:32.394] result() for MulticoreFuture ... done
[18:02:32.394] result() for MulticoreFuture ... done
[18:02:32.395] result() for MulticoreFuture ...
[18:02:32.395] result() for MulticoreFuture ... done
[18:02:32.396] signalConditionsASAP(MulticoreFuture, pos=2) ...
[18:02:32.397] - nx: 2
[18:02:32.397] - relay: TRUE
[18:02:32.398] - stdout: TRUE
[18:02:32.398] - signal: TRUE
[18:02:32.398] - resignal: FALSE
[18:02:32.398] - force: TRUE
[18:02:32.399] - relayed: [n=2] FALSE, FALSE
[18:02:32.399] - queued futures: [n=2] FALSE, FALSE
[18:02:32.399]  - until=1
[18:02:32.400]  - relaying element #1
[18:02:32.400] - relayed: [n=2] FALSE, FALSE
[18:02:32.400] - queued futures: [n=2] FALSE, TRUE
[18:02:32.400] signalConditionsASAP(NULL, pos=2) ... done
[18:02:32.401]  length: 1 (resolved future 2)
[18:02:32.765] plan(): Setting new future strategy stack:
[18:02:32.766] List of future strategies:
[18:02:32.766] 1. multicore:
[18:02:32.766]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[18:02:32.766]    - tweaked: FALSE
[18:02:32.766]    - call: plan(strategy)
[18:02:32.777] plan(): nbrOfWorkers() = 2
[18:02:32.784] Future #1
[18:02:32.785] result() for MulticoreFuture ...
[18:02:32.786] result() for MulticoreFuture ...
[18:02:32.787] result() for MulticoreFuture ... done
[18:02:32.787] result() for MulticoreFuture ... done
[18:02:32.788] result() for MulticoreFuture ...
[18:02:32.788] result() for MulticoreFuture ... done
[18:02:32.789] signalConditionsASAP(MulticoreFuture, pos=1) ...
[18:02:32.789] - nx: 2
[18:02:32.789] - relay: TRUE
[18:02:32.789] - stdout: TRUE
[18:02:32.790] - signal: TRUE
[18:02:32.790] - resignal: FALSE
[18:02:32.790] - force: TRUE
[18:02:32.791] - relayed: [n=2] FALSE, FALSE
[18:02:32.791] - queued futures: [n=2] FALSE, TRUE
[18:02:32.791]  - until=1
[18:02:32.792]  - relaying element #1
[18:02:32.792] result() for MulticoreFuture ...
[18:02:32.792] result() for MulticoreFuture ... done
[18:02:32.792] result() for MulticoreFuture ...
[18:02:32.793] result() for MulticoreFuture ... done
[18:02:32.793] result() for MulticoreFuture ...
[18:02:32.793] result() for MulticoreFuture ... done
[18:02:32.794] result() for MulticoreFuture ...
[18:02:32.794] result() for MulticoreFuture ... done
[18:02:32.794] - relayed: [n=2] TRUE, FALSE
[18:02:32.795] - queued futures: [n=2] TRUE, TRUE
[18:02:32.795] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[18:02:32.795]  length: 0 (resolved future 1)
[18:02:32.796] Relaying remaining futures
[18:02:32.796] signalConditionsASAP(NULL, pos=0) ...
[18:02:32.796] - nx: 2
[18:02:32.796] - relay: TRUE
[18:02:32.797] - stdout: TRUE
[18:02:32.797] - signal: TRUE
[18:02:32.797] - resignal: FALSE
[18:02:32.797] - force: TRUE
[18:02:32.798] - relayed: [n=2] TRUE, FALSE
[18:02:32.798] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:32.799]  - relaying element #2
[18:02:32.799] result() for MulticoreFuture ...
[18:02:32.799] result() for MulticoreFuture ... done
[18:02:32.799] result() for MulticoreFuture ...
[18:02:32.800] result() for MulticoreFuture ... done
[18:02:32.800] result() for MulticoreFuture ...
[18:02:32.800] result() for MulticoreFuture ... done
[18:02:32.801] result() for MulticoreFuture ...
[18:02:32.801] result() for MulticoreFuture ... done
[18:02:32.801] - relayed: [n=2] TRUE, TRUE
[18:02:32.802] - queued futures: [n=2] TRUE, TRUE
[18:02:32.802] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[18:02:32.802] resolve() on list ... DONE
[18:02:32.803] result() for MulticoreFuture ...
[18:02:32.803] result() for MulticoreFuture ... done
[18:02:32.803] result() for MulticoreFuture ...
[18:02:32.803] result() for MulticoreFuture ... done
[18:02:32.804] result() for MulticoreFuture ...
[18:02:32.804] result() for MulticoreFuture ... done
[18:02:32.804] result() for MulticoreFuture ...
[18:02:32.805] result() for MulticoreFuture ... done
[18:02:32.805]  - Number of value chunks collected: 2
[18:02:32.805] Resolving 2 futures (chunks) ... DONE
[18:02:32.806] Reducing values from 2 chunks ...
[18:02:32.806]  - Number of values collected after concatenation: 2
[18:02:32.806]  - Number of values expected: 2
[18:02:32.807] Reducing values from 2 chunks ... DONE
[18:02:32.807] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[18:02:32.808] plan(): Setting new future strategy stack:
[18:02:32.809] List of future strategies:
[18:02:32.809] 1. multisession:
[18:02:32.809]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:02:32.809]    - tweaked: FALSE
[18:02:32.809]    - call: plan(strategy)
[18:02:32.810] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[18:02:32.810] multisession:
[18:02:32.810] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[18:02:32.810] - tweaked: FALSE
[18:02:32.810] - call: plan(strategy)
[18:02:32.822] getGlobalsAndPackages() ...
[18:02:32.822] Not searching for globals
[18:02:32.823] - globals: [0] <none>
[18:02:32.823] getGlobalsAndPackages() ... DONE
[18:02:32.824] [local output] makeClusterPSOCK() ...
[18:02:32.895] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[18:02:32.897] [local output] Base port: 11364
[18:02:32.897] [local output] Getting setup options for 2 cluster nodes ...
[18:02:32.897] [local output]  - Node 1 of 2 ...
[18:02:32.898] [local output] localMachine=TRUE => revtunnel=FALSE

[18:02:32.900] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp1j8FfD/worker.rank=1.parallelly.parent=317950.4d9fe7c07123d.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp1j8FfD/worker.rank=1.parallelly.parent=317950.4d9fe7c07123d.pid")'’
[18:02:33.165] - Possible to infer worker's PID: TRUE
[18:02:33.165] [local output] Rscript port: 11364

[18:02:33.166] [local output]  - Node 2 of 2 ...
[18:02:33.167] [local output] localMachine=TRUE => revtunnel=FALSE

[18:02:33.168] [local output] Rscript port: 11364

[18:02:33.169] [local output] Getting setup options for 2 cluster nodes ... done
[18:02:33.169] [local output]  - Parallel setup requested for some PSOCK nodes
[18:02:33.170] [local output] Setting up PSOCK nodes in parallel
[18:02:33.171] List of 36
[18:02:33.171]  $ worker          : chr "localhost"
[18:02:33.171]   ..- attr(*, "localhost")= logi TRUE
[18:02:33.171]  $ master          : chr "localhost"
[18:02:33.171]  $ port            : int 11364
[18:02:33.171]  $ connectTimeout  : num 120
[18:02:33.171]  $ timeout         : num 2592000
[18:02:33.171]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[18:02:33.171]  $ homogeneous     : logi TRUE
[18:02:33.171]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[18:02:33.171]  $ rscript_envs    : NULL
[18:02:33.171]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:02:33.171]  $ rscript_startup : NULL
[18:02:33.171]  $ rscript_sh      : chr "sh"
[18:02:33.171]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:02:33.171]  $ methods         : logi TRUE
[18:02:33.171]  $ socketOptions   : chr "no-delay"
[18:02:33.171]  $ useXDR          : logi FALSE
[18:02:33.171]  $ outfile         : chr "/dev/null"
[18:02:33.171]  $ renice          : int NA
[18:02:33.171]  $ rshcmd          : NULL
[18:02:33.171]  $ user            : chr(0) 
[18:02:33.171]  $ revtunnel       : logi FALSE
[18:02:33.171]  $ rshlogfile      : NULL
[18:02:33.171]  $ rshopts         : chr(0) 
[18:02:33.171]  $ rank            : int 1
[18:02:33.171]  $ manual          : logi FALSE
[18:02:33.171]  $ dryrun          : logi FALSE
[18:02:33.171]  $ quiet           : logi FALSE
[18:02:33.171]  $ setup_strategy  : chr "parallel"
[18:02:33.171]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:02:33.171]  $ pidfile         : chr "/tmp/Rtmp1j8FfD/worker.rank=1.parallelly.parent=317950.4d9fe7c07123d.pid"
[18:02:33.171]  $ rshcmd_label    : NULL
[18:02:33.171]  $ rsh_call        : NULL
[18:02:33.171]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[18:02:33.171]  $ localMachine    : logi TRUE
[18:02:33.171]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[18:02:33.171]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[18:02:33.171]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[18:02:33.171]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[18:02:33.171]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[18:02:33.171]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[18:02:33.171]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[18:02:33.171]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[18:02:33.171]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[18:02:33.171]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[18:02:33.171]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[18:02:33.171]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[18:02:33.171]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[18:02:33.171]  $ arguments       :List of 28
[18:02:33.171]   ..$ worker          : chr "localhost"
[18:02:33.171]   ..$ master          : NULL
[18:02:33.171]   ..$ port            : int 11364
[18:02:33.171]   ..$ connectTimeout  : num 120
[18:02:33.171]   ..$ timeout         : num 2592000
[18:02:33.171]   ..$ rscript         : NULL
[18:02:33.171]   ..$ homogeneous     : NULL
[18:02:33.171]   ..$ rscript_args    : NULL
[18:02:33.171]   ..$ rscript_envs    : NULL
[18:02:33.171]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[18:02:33.171]   ..$ rscript_startup : NULL
[18:02:33.171]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[18:02:33.171]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[18:02:33.171]   ..$ methods         : logi TRUE
[18:02:33.171]   ..$ socketOptions   : chr "no-delay"
[18:02:33.171]   ..$ useXDR          : logi FALSE
[18:02:33.171]   ..$ outfile         : chr "/dev/null"
[18:02:33.171]   ..$ renice          : int NA
[18:02:33.171]   ..$ rshcmd          : NULL
[18:02:33.171]   ..$ user            : NULL
[18:02:33.171]   ..$ revtunnel       : logi NA
[18:02:33.171]   ..$ rshlogfile      : NULL
[18:02:33.171]   ..$ rshopts         : NULL
[18:02:33.171]   ..$ rank            : int 1
[18:02:33.171]   ..$ manual          : logi FALSE
[18:02:33.171]   ..$ dryrun          : logi FALSE
[18:02:33.171]   ..$ quiet           : logi FALSE
[18:02:33.171]   ..$ setup_strategy  : chr "parallel"
[18:02:33.171]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[18:02:33.205] [local output] System call to launch all workers:
[18:02:33.205] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp1j8FfD/worker.rank=1.parallelly.parent=317950.4d9fe7c07123d.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11364 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[18:02:33.205] [local output] Starting PSOCK main server
[18:02:33.214] [local output] Workers launched
[18:02:33.214] [local output] Waiting for workers to connect back
[18:02:33.214]  - [local output] 0 workers out of 2 ready
[18:02:33.577]  - [local output] 0 workers out of 2 ready
[18:02:33.578]  - [local output] 1 workers out of 2 ready
[18:02:33.582]  - [local output] 1 workers out of 2 ready
[18:02:33.583]  - [local output] 2 workers out of 2 ready
[18:02:33.583] [local output] Launching of workers completed
[18:02:33.583] [local output] Collecting session information from workers
[18:02:33.585] [local output]  - Worker #1 of 2
[18:02:33.586] [local output]  - Worker #2 of 2
[18:02:33.586] [local output] makeClusterPSOCK() ... done
[18:02:33.606] Packages needed by the future expression (n = 0): <none>
[18:02:33.606] Packages needed by future strategies (n = 0): <none>
[18:02:33.607] {
[18:02:33.607]     {
[18:02:33.607]         {
[18:02:33.607]             ...future.startTime <- base::Sys.time()
[18:02:33.607]             {
[18:02:33.607]                 {
[18:02:33.607]                   {
[18:02:33.607]                     {
[18:02:33.607]                       base::local({
[18:02:33.607]                         has_future <- base::requireNamespace("future", 
[18:02:33.607]                           quietly = TRUE)
[18:02:33.607]                         if (has_future) {
[18:02:33.607]                           ns <- base::getNamespace("future")
[18:02:33.607]                           version <- ns[[".package"]][["version"]]
[18:02:33.607]                           if (is.null(version)) 
[18:02:33.607]                             version <- utils::packageVersion("future")
[18:02:33.607]                         }
[18:02:33.607]                         else {
[18:02:33.607]                           version <- NULL
[18:02:33.607]                         }
[18:02:33.607]                         if (!has_future || version < "1.8.0") {
[18:02:33.607]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:33.607]                             "", base::R.version$version.string), 
[18:02:33.607]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:33.607]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:33.607]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:33.607]                               "release", "version")], collapse = " "), 
[18:02:33.607]                             hostname = base::Sys.info()[["nodename"]])
[18:02:33.607]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:33.607]                             info)
[18:02:33.607]                           info <- base::paste(info, collapse = "; ")
[18:02:33.607]                           if (!has_future) {
[18:02:33.607]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:33.607]                               info)
[18:02:33.607]                           }
[18:02:33.607]                           else {
[18:02:33.607]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:33.607]                               info, version)
[18:02:33.607]                           }
[18:02:33.607]                           base::stop(msg)
[18:02:33.607]                         }
[18:02:33.607]                       })
[18:02:33.607]                     }
[18:02:33.607]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:33.607]                     base::options(mc.cores = 1L)
[18:02:33.607]                   }
[18:02:33.607]                   ...future.strategy.old <- future::plan("list")
[18:02:33.607]                   options(future.plan = NULL)
[18:02:33.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:33.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:33.607]                 }
[18:02:33.607]                 ...future.workdir <- getwd()
[18:02:33.607]             }
[18:02:33.607]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:33.607]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:33.607]         }
[18:02:33.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:33.607]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[18:02:33.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:33.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:33.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:33.607]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:33.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:33.607]             base::names(...future.oldOptions))
[18:02:33.607]     }
[18:02:33.607]     if (FALSE) {
[18:02:33.607]     }
[18:02:33.607]     else {
[18:02:33.607]         if (TRUE) {
[18:02:33.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:33.607]                 open = "w")
[18:02:33.607]         }
[18:02:33.607]         else {
[18:02:33.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:33.607]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:33.607]         }
[18:02:33.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:33.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:33.607]             base::sink(type = "output", split = FALSE)
[18:02:33.607]             base::close(...future.stdout)
[18:02:33.607]         }, add = TRUE)
[18:02:33.607]     }
[18:02:33.607]     ...future.frame <- base::sys.nframe()
[18:02:33.607]     ...future.conditions <- base::list()
[18:02:33.607]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:33.607]     if (FALSE) {
[18:02:33.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:33.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:33.607]     }
[18:02:33.607]     ...future.result <- base::tryCatch({
[18:02:33.607]         base::withCallingHandlers({
[18:02:33.607]             ...future.value <- base::withVisible(base::local({
[18:02:33.607]                 ...future.makeSendCondition <- base::local({
[18:02:33.607]                   sendCondition <- NULL
[18:02:33.607]                   function(frame = 1L) {
[18:02:33.607]                     if (is.function(sendCondition)) 
[18:02:33.607]                       return(sendCondition)
[18:02:33.607]                     ns <- getNamespace("parallel")
[18:02:33.607]                     if (exists("sendData", mode = "function", 
[18:02:33.607]                       envir = ns)) {
[18:02:33.607]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:33.607]                         envir = ns)
[18:02:33.607]                       envir <- sys.frame(frame)
[18:02:33.607]                       master <- NULL
[18:02:33.607]                       while (!identical(envir, .GlobalEnv) && 
[18:02:33.607]                         !identical(envir, emptyenv())) {
[18:02:33.607]                         if (exists("master", mode = "list", envir = envir, 
[18:02:33.607]                           inherits = FALSE)) {
[18:02:33.607]                           master <- get("master", mode = "list", 
[18:02:33.607]                             envir = envir, inherits = FALSE)
[18:02:33.607]                           if (inherits(master, c("SOCKnode", 
[18:02:33.607]                             "SOCK0node"))) {
[18:02:33.607]                             sendCondition <<- function(cond) {
[18:02:33.607]                               data <- list(type = "VALUE", value = cond, 
[18:02:33.607]                                 success = TRUE)
[18:02:33.607]                               parallel_sendData(master, data)
[18:02:33.607]                             }
[18:02:33.607]                             return(sendCondition)
[18:02:33.607]                           }
[18:02:33.607]                         }
[18:02:33.607]                         frame <- frame + 1L
[18:02:33.607]                         envir <- sys.frame(frame)
[18:02:33.607]                       }
[18:02:33.607]                     }
[18:02:33.607]                     sendCondition <<- function(cond) NULL
[18:02:33.607]                   }
[18:02:33.607]                 })
[18:02:33.607]                 withCallingHandlers({
[18:02:33.607]                   NA
[18:02:33.607]                 }, immediateCondition = function(cond) {
[18:02:33.607]                   sendCondition <- ...future.makeSendCondition()
[18:02:33.607]                   sendCondition(cond)
[18:02:33.607]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:33.607]                   {
[18:02:33.607]                     inherits <- base::inherits
[18:02:33.607]                     invokeRestart <- base::invokeRestart
[18:02:33.607]                     is.null <- base::is.null
[18:02:33.607]                     muffled <- FALSE
[18:02:33.607]                     if (inherits(cond, "message")) {
[18:02:33.607]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:33.607]                       if (muffled) 
[18:02:33.607]                         invokeRestart("muffleMessage")
[18:02:33.607]                     }
[18:02:33.607]                     else if (inherits(cond, "warning")) {
[18:02:33.607]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:33.607]                       if (muffled) 
[18:02:33.607]                         invokeRestart("muffleWarning")
[18:02:33.607]                     }
[18:02:33.607]                     else if (inherits(cond, "condition")) {
[18:02:33.607]                       if (!is.null(pattern)) {
[18:02:33.607]                         computeRestarts <- base::computeRestarts
[18:02:33.607]                         grepl <- base::grepl
[18:02:33.607]                         restarts <- computeRestarts(cond)
[18:02:33.607]                         for (restart in restarts) {
[18:02:33.607]                           name <- restart$name
[18:02:33.607]                           if (is.null(name)) 
[18:02:33.607]                             next
[18:02:33.607]                           if (!grepl(pattern, name)) 
[18:02:33.607]                             next
[18:02:33.607]                           invokeRestart(restart)
[18:02:33.607]                           muffled <- TRUE
[18:02:33.607]                           break
[18:02:33.607]                         }
[18:02:33.607]                       }
[18:02:33.607]                     }
[18:02:33.607]                     invisible(muffled)
[18:02:33.607]                   }
[18:02:33.607]                   muffleCondition(cond)
[18:02:33.607]                 })
[18:02:33.607]             }))
[18:02:33.607]             future::FutureResult(value = ...future.value$value, 
[18:02:33.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:33.607]                   ...future.rng), globalenv = if (FALSE) 
[18:02:33.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:33.607]                     ...future.globalenv.names))
[18:02:33.607]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:33.607]         }, condition = base::local({
[18:02:33.607]             c <- base::c
[18:02:33.607]             inherits <- base::inherits
[18:02:33.607]             invokeRestart <- base::invokeRestart
[18:02:33.607]             length <- base::length
[18:02:33.607]             list <- base::list
[18:02:33.607]             seq.int <- base::seq.int
[18:02:33.607]             signalCondition <- base::signalCondition
[18:02:33.607]             sys.calls <- base::sys.calls
[18:02:33.607]             `[[` <- base::`[[`
[18:02:33.607]             `+` <- base::`+`
[18:02:33.607]             `<<-` <- base::`<<-`
[18:02:33.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:33.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:33.607]                   3L)]
[18:02:33.607]             }
[18:02:33.607]             function(cond) {
[18:02:33.607]                 is_error <- inherits(cond, "error")
[18:02:33.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:33.607]                   NULL)
[18:02:33.607]                 if (is_error) {
[18:02:33.607]                   sessionInformation <- function() {
[18:02:33.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:33.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:33.607]                       search = base::search(), system = base::Sys.info())
[18:02:33.607]                   }
[18:02:33.607]                   ...future.conditions[[length(...future.conditions) + 
[18:02:33.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:33.607]                     cond$call), session = sessionInformation(), 
[18:02:33.607]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:33.607]                   signalCondition(cond)
[18:02:33.607]                 }
[18:02:33.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:33.607]                 "immediateCondition"))) {
[18:02:33.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:33.607]                   ...future.conditions[[length(...future.conditions) + 
[18:02:33.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:33.607]                   if (TRUE && !signal) {
[18:02:33.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:33.607]                     {
[18:02:33.607]                       inherits <- base::inherits
[18:02:33.607]                       invokeRestart <- base::invokeRestart
[18:02:33.607]                       is.null <- base::is.null
[18:02:33.607]                       muffled <- FALSE
[18:02:33.607]                       if (inherits(cond, "message")) {
[18:02:33.607]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:33.607]                         if (muffled) 
[18:02:33.607]                           invokeRestart("muffleMessage")
[18:02:33.607]                       }
[18:02:33.607]                       else if (inherits(cond, "warning")) {
[18:02:33.607]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:33.607]                         if (muffled) 
[18:02:33.607]                           invokeRestart("muffleWarning")
[18:02:33.607]                       }
[18:02:33.607]                       else if (inherits(cond, "condition")) {
[18:02:33.607]                         if (!is.null(pattern)) {
[18:02:33.607]                           computeRestarts <- base::computeRestarts
[18:02:33.607]                           grepl <- base::grepl
[18:02:33.607]                           restarts <- computeRestarts(cond)
[18:02:33.607]                           for (restart in restarts) {
[18:02:33.607]                             name <- restart$name
[18:02:33.607]                             if (is.null(name)) 
[18:02:33.607]                               next
[18:02:33.607]                             if (!grepl(pattern, name)) 
[18:02:33.607]                               next
[18:02:33.607]                             invokeRestart(restart)
[18:02:33.607]                             muffled <- TRUE
[18:02:33.607]                             break
[18:02:33.607]                           }
[18:02:33.607]                         }
[18:02:33.607]                       }
[18:02:33.607]                       invisible(muffled)
[18:02:33.607]                     }
[18:02:33.607]                     muffleCondition(cond, pattern = "^muffle")
[18:02:33.607]                   }
[18:02:33.607]                 }
[18:02:33.607]                 else {
[18:02:33.607]                   if (TRUE) {
[18:02:33.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:33.607]                     {
[18:02:33.607]                       inherits <- base::inherits
[18:02:33.607]                       invokeRestart <- base::invokeRestart
[18:02:33.607]                       is.null <- base::is.null
[18:02:33.607]                       muffled <- FALSE
[18:02:33.607]                       if (inherits(cond, "message")) {
[18:02:33.607]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:33.607]                         if (muffled) 
[18:02:33.607]                           invokeRestart("muffleMessage")
[18:02:33.607]                       }
[18:02:33.607]                       else if (inherits(cond, "warning")) {
[18:02:33.607]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:33.607]                         if (muffled) 
[18:02:33.607]                           invokeRestart("muffleWarning")
[18:02:33.607]                       }
[18:02:33.607]                       else if (inherits(cond, "condition")) {
[18:02:33.607]                         if (!is.null(pattern)) {
[18:02:33.607]                           computeRestarts <- base::computeRestarts
[18:02:33.607]                           grepl <- base::grepl
[18:02:33.607]                           restarts <- computeRestarts(cond)
[18:02:33.607]                           for (restart in restarts) {
[18:02:33.607]                             name <- restart$name
[18:02:33.607]                             if (is.null(name)) 
[18:02:33.607]                               next
[18:02:33.607]                             if (!grepl(pattern, name)) 
[18:02:33.607]                               next
[18:02:33.607]                             invokeRestart(restart)
[18:02:33.607]                             muffled <- TRUE
[18:02:33.607]                             break
[18:02:33.607]                           }
[18:02:33.607]                         }
[18:02:33.607]                       }
[18:02:33.607]                       invisible(muffled)
[18:02:33.607]                     }
[18:02:33.607]                     muffleCondition(cond, pattern = "^muffle")
[18:02:33.607]                   }
[18:02:33.607]                 }
[18:02:33.607]             }
[18:02:33.607]         }))
[18:02:33.607]     }, error = function(ex) {
[18:02:33.607]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:33.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:33.607]                 ...future.rng), started = ...future.startTime, 
[18:02:33.607]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:33.607]             version = "1.8"), class = "FutureResult")
[18:02:33.607]     }, finally = {
[18:02:33.607]         if (!identical(...future.workdir, getwd())) 
[18:02:33.607]             setwd(...future.workdir)
[18:02:33.607]         {
[18:02:33.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:33.607]                 ...future.oldOptions$nwarnings <- NULL
[18:02:33.607]             }
[18:02:33.607]             base::options(...future.oldOptions)
[18:02:33.607]             if (.Platform$OS.type == "windows") {
[18:02:33.607]                 old_names <- names(...future.oldEnvVars)
[18:02:33.607]                 envs <- base::Sys.getenv()
[18:02:33.607]                 names <- names(envs)
[18:02:33.607]                 common <- intersect(names, old_names)
[18:02:33.607]                 added <- setdiff(names, old_names)
[18:02:33.607]                 removed <- setdiff(old_names, names)
[18:02:33.607]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:33.607]                   envs[common]]
[18:02:33.607]                 NAMES <- toupper(changed)
[18:02:33.607]                 args <- list()
[18:02:33.607]                 for (kk in seq_along(NAMES)) {
[18:02:33.607]                   name <- changed[[kk]]
[18:02:33.607]                   NAME <- NAMES[[kk]]
[18:02:33.607]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:33.607]                     next
[18:02:33.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:33.607]                 }
[18:02:33.607]                 NAMES <- toupper(added)
[18:02:33.607]                 for (kk in seq_along(NAMES)) {
[18:02:33.607]                   name <- added[[kk]]
[18:02:33.607]                   NAME <- NAMES[[kk]]
[18:02:33.607]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:33.607]                     next
[18:02:33.607]                   args[[name]] <- ""
[18:02:33.607]                 }
[18:02:33.607]                 NAMES <- toupper(removed)
[18:02:33.607]                 for (kk in seq_along(NAMES)) {
[18:02:33.607]                   name <- removed[[kk]]
[18:02:33.607]                   NAME <- NAMES[[kk]]
[18:02:33.607]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:33.607]                     next
[18:02:33.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:33.607]                 }
[18:02:33.607]                 if (length(args) > 0) 
[18:02:33.607]                   base::do.call(base::Sys.setenv, args = args)
[18:02:33.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:33.607]             }
[18:02:33.607]             else {
[18:02:33.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:33.607]             }
[18:02:33.607]             {
[18:02:33.607]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:33.607]                   0L) {
[18:02:33.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:33.607]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:33.607]                   base::options(opts)
[18:02:33.607]                 }
[18:02:33.607]                 {
[18:02:33.607]                   {
[18:02:33.607]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:33.607]                     NULL
[18:02:33.607]                   }
[18:02:33.607]                   options(future.plan = NULL)
[18:02:33.607]                   if (is.na(NA_character_)) 
[18:02:33.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:33.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:33.607]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:33.607]                     .init = FALSE)
[18:02:33.607]                 }
[18:02:33.607]             }
[18:02:33.607]         }
[18:02:33.607]     })
[18:02:33.607]     if (TRUE) {
[18:02:33.607]         base::sink(type = "output", split = FALSE)
[18:02:33.607]         if (TRUE) {
[18:02:33.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:33.607]         }
[18:02:33.607]         else {
[18:02:33.607]             ...future.result["stdout"] <- base::list(NULL)
[18:02:33.607]         }
[18:02:33.607]         base::close(...future.stdout)
[18:02:33.607]         ...future.stdout <- NULL
[18:02:33.607]     }
[18:02:33.607]     ...future.result$conditions <- ...future.conditions
[18:02:33.607]     ...future.result$finished <- base::Sys.time()
[18:02:33.607]     ...future.result
[18:02:33.607] }
[18:02:33.708] MultisessionFuture started
[18:02:33.711] result() for ClusterFuture ...
[18:02:33.712] receiveMessageFromWorker() for ClusterFuture ...
[18:02:33.713] - Validating connection of MultisessionFuture
[18:02:33.775] - received message: FutureResult
[18:02:33.776] - Received FutureResult
[18:02:33.776] - Erased future from FutureRegistry
[18:02:33.776] result() for ClusterFuture ...
[18:02:33.777] - result already collected: FutureResult
[18:02:33.777] result() for ClusterFuture ... done
[18:02:33.777] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:33.778] result() for ClusterFuture ... done
[18:02:33.778] result() for ClusterFuture ...
[18:02:33.778] - result already collected: FutureResult
[18:02:33.778] result() for ClusterFuture ... done
[18:02:33.779] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[18:02:33.786] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[18:02:33.787] future_lapply() ...
[18:02:33.795] Number of chunks: 2
[18:02:33.795] getGlobalsAndPackagesXApply() ...
[18:02:33.795]  - future.globals: TRUE
[18:02:33.796] getGlobalsAndPackages() ...
[18:02:33.796] Searching for globals...
[18:02:33.799] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:33.800] Searching for globals ... DONE
[18:02:33.800] Resolving globals: FALSE
[18:02:33.801] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:33.802] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:33.802] - globals: [1] ‘FUN’
[18:02:33.802] 
[18:02:33.802] getGlobalsAndPackages() ... DONE
[18:02:33.803]  - globals found/used: [n=1] ‘FUN’
[18:02:33.803]  - needed namespaces: [n=0] 
[18:02:33.803] Finding globals ... DONE
[18:02:33.803]  - use_args: TRUE
[18:02:33.804]  - Getting '...' globals ...
[18:02:33.804] resolve() on list ...
[18:02:33.805]  recursive: 0
[18:02:33.805]  length: 1
[18:02:33.805]  elements: ‘...’
[18:02:33.805]  length: 0 (resolved future 1)
[18:02:33.805] resolve() on list ... DONE
[18:02:33.806]    - '...' content: [n=0] 
[18:02:33.806] List of 1
[18:02:33.806]  $ ...: list()
[18:02:33.806]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:33.806]  - attr(*, "where")=List of 1
[18:02:33.806]   ..$ ...:<environment: 0x5e4f86745050> 
[18:02:33.806]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:33.806]  - attr(*, "resolved")= logi TRUE
[18:02:33.806]  - attr(*, "total_size")= num NA
[18:02:33.812]  - Getting '...' globals ... DONE
[18:02:33.812] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:33.813] List of 2
[18:02:33.813]  $ ...future.FUN:function (x)  
[18:02:33.813]  $ ...          : list()
[18:02:33.813]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:33.813]  - attr(*, "where")=List of 2
[18:02:33.813]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:33.813]   ..$ ...          :<environment: 0x5e4f86745050> 
[18:02:33.813]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:33.813]  - attr(*, "resolved")= logi FALSE
[18:02:33.813]  - attr(*, "total_size")= num 4720
[18:02:33.819] Packages to be attached in all futures: [n=0] 
[18:02:33.819] getGlobalsAndPackagesXApply() ... DONE
[18:02:33.820] Number of futures (= number of chunks): 2
[18:02:33.820] Launching 2 futures (chunks) ...
[18:02:33.821] Chunk #1 of 2 ...
[18:02:33.821]  - Finding globals in 'X' for chunk #1 ...
[18:02:33.821] getGlobalsAndPackages() ...
[18:02:33.821] Searching for globals...
[18:02:33.822] 
[18:02:33.822] Searching for globals ... DONE
[18:02:33.823] - globals: [0] <none>
[18:02:33.823] getGlobalsAndPackages() ... DONE
[18:02:33.823]    + additional globals found: [n=0] 
[18:02:33.823]    + additional namespaces needed: [n=0] 
[18:02:33.823]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:33.824]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:33.824]  - seeds: <none>
[18:02:33.824]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:33.824] getGlobalsAndPackages() ...
[18:02:33.825] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:33.825] Resolving globals: FALSE
[18:02:33.825] Tweak future expression to call with '...' arguments ...
[18:02:33.825] {
[18:02:33.825]     do.call(function(...) {
[18:02:33.825]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:33.825]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:33.825]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:33.825]             on.exit(options(oopts), add = TRUE)
[18:02:33.825]         }
[18:02:33.825]         {
[18:02:33.825]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:33.825]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:33.825]                 ...future.FUN(...future.X_jj, ...)
[18:02:33.825]             })
[18:02:33.825]         }
[18:02:33.825]     }, args = future.call.arguments)
[18:02:33.825] }
[18:02:33.826] Tweak future expression to call with '...' arguments ... DONE
[18:02:33.827] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:33.827] 
[18:02:33.827] getGlobalsAndPackages() ... DONE
[18:02:33.828] run() for ‘Future’ ...
[18:02:33.828] - state: ‘created’
[18:02:33.828] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:33.853] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:33.854] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:33.854]   - Field: ‘node’
[18:02:33.854]   - Field: ‘label’
[18:02:33.855]   - Field: ‘local’
[18:02:33.855]   - Field: ‘owner’
[18:02:33.855]   - Field: ‘envir’
[18:02:33.855]   - Field: ‘workers’
[18:02:33.855]   - Field: ‘packages’
[18:02:33.856]   - Field: ‘gc’
[18:02:33.856]   - Field: ‘conditions’
[18:02:33.856]   - Field: ‘persistent’
[18:02:33.856]   - Field: ‘expr’
[18:02:33.856]   - Field: ‘uuid’
[18:02:33.857]   - Field: ‘seed’
[18:02:33.857]   - Field: ‘version’
[18:02:33.857]   - Field: ‘result’
[18:02:33.857]   - Field: ‘asynchronous’
[18:02:33.858]   - Field: ‘calls’
[18:02:33.858]   - Field: ‘globals’
[18:02:33.858]   - Field: ‘stdout’
[18:02:33.858]   - Field: ‘earlySignal’
[18:02:33.859]   - Field: ‘lazy’
[18:02:33.859]   - Field: ‘state’
[18:02:33.859] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:33.859] - Launch lazy future ...
[18:02:33.860] Packages needed by the future expression (n = 0): <none>
[18:02:33.860] Packages needed by future strategies (n = 0): <none>
[18:02:33.861] {
[18:02:33.861]     {
[18:02:33.861]         {
[18:02:33.861]             ...future.startTime <- base::Sys.time()
[18:02:33.861]             {
[18:02:33.861]                 {
[18:02:33.861]                   {
[18:02:33.861]                     {
[18:02:33.861]                       base::local({
[18:02:33.861]                         has_future <- base::requireNamespace("future", 
[18:02:33.861]                           quietly = TRUE)
[18:02:33.861]                         if (has_future) {
[18:02:33.861]                           ns <- base::getNamespace("future")
[18:02:33.861]                           version <- ns[[".package"]][["version"]]
[18:02:33.861]                           if (is.null(version)) 
[18:02:33.861]                             version <- utils::packageVersion("future")
[18:02:33.861]                         }
[18:02:33.861]                         else {
[18:02:33.861]                           version <- NULL
[18:02:33.861]                         }
[18:02:33.861]                         if (!has_future || version < "1.8.0") {
[18:02:33.861]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:33.861]                             "", base::R.version$version.string), 
[18:02:33.861]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:33.861]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:33.861]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:33.861]                               "release", "version")], collapse = " "), 
[18:02:33.861]                             hostname = base::Sys.info()[["nodename"]])
[18:02:33.861]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:33.861]                             info)
[18:02:33.861]                           info <- base::paste(info, collapse = "; ")
[18:02:33.861]                           if (!has_future) {
[18:02:33.861]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:33.861]                               info)
[18:02:33.861]                           }
[18:02:33.861]                           else {
[18:02:33.861]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:33.861]                               info, version)
[18:02:33.861]                           }
[18:02:33.861]                           base::stop(msg)
[18:02:33.861]                         }
[18:02:33.861]                       })
[18:02:33.861]                     }
[18:02:33.861]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:33.861]                     base::options(mc.cores = 1L)
[18:02:33.861]                   }
[18:02:33.861]                   ...future.strategy.old <- future::plan("list")
[18:02:33.861]                   options(future.plan = NULL)
[18:02:33.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:33.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:33.861]                 }
[18:02:33.861]                 ...future.workdir <- getwd()
[18:02:33.861]             }
[18:02:33.861]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:33.861]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:33.861]         }
[18:02:33.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:33.861]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:33.861]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:33.861]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:33.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:33.861]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:33.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:33.861]             base::names(...future.oldOptions))
[18:02:33.861]     }
[18:02:33.861]     if (FALSE) {
[18:02:33.861]     }
[18:02:33.861]     else {
[18:02:33.861]         if (FALSE) {
[18:02:33.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:33.861]                 open = "w")
[18:02:33.861]         }
[18:02:33.861]         else {
[18:02:33.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:33.861]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:33.861]         }
[18:02:33.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:33.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:33.861]             base::sink(type = "output", split = FALSE)
[18:02:33.861]             base::close(...future.stdout)
[18:02:33.861]         }, add = TRUE)
[18:02:33.861]     }
[18:02:33.861]     ...future.frame <- base::sys.nframe()
[18:02:33.861]     ...future.conditions <- base::list()
[18:02:33.861]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:33.861]     if (FALSE) {
[18:02:33.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:33.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:33.861]     }
[18:02:33.861]     ...future.result <- base::tryCatch({
[18:02:33.861]         base::withCallingHandlers({
[18:02:33.861]             ...future.value <- base::withVisible(base::local({
[18:02:33.861]                 ...future.makeSendCondition <- base::local({
[18:02:33.861]                   sendCondition <- NULL
[18:02:33.861]                   function(frame = 1L) {
[18:02:33.861]                     if (is.function(sendCondition)) 
[18:02:33.861]                       return(sendCondition)
[18:02:33.861]                     ns <- getNamespace("parallel")
[18:02:33.861]                     if (exists("sendData", mode = "function", 
[18:02:33.861]                       envir = ns)) {
[18:02:33.861]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:33.861]                         envir = ns)
[18:02:33.861]                       envir <- sys.frame(frame)
[18:02:33.861]                       master <- NULL
[18:02:33.861]                       while (!identical(envir, .GlobalEnv) && 
[18:02:33.861]                         !identical(envir, emptyenv())) {
[18:02:33.861]                         if (exists("master", mode = "list", envir = envir, 
[18:02:33.861]                           inherits = FALSE)) {
[18:02:33.861]                           master <- get("master", mode = "list", 
[18:02:33.861]                             envir = envir, inherits = FALSE)
[18:02:33.861]                           if (inherits(master, c("SOCKnode", 
[18:02:33.861]                             "SOCK0node"))) {
[18:02:33.861]                             sendCondition <<- function(cond) {
[18:02:33.861]                               data <- list(type = "VALUE", value = cond, 
[18:02:33.861]                                 success = TRUE)
[18:02:33.861]                               parallel_sendData(master, data)
[18:02:33.861]                             }
[18:02:33.861]                             return(sendCondition)
[18:02:33.861]                           }
[18:02:33.861]                         }
[18:02:33.861]                         frame <- frame + 1L
[18:02:33.861]                         envir <- sys.frame(frame)
[18:02:33.861]                       }
[18:02:33.861]                     }
[18:02:33.861]                     sendCondition <<- function(cond) NULL
[18:02:33.861]                   }
[18:02:33.861]                 })
[18:02:33.861]                 withCallingHandlers({
[18:02:33.861]                   {
[18:02:33.861]                     do.call(function(...) {
[18:02:33.861]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:33.861]                       if (!identical(...future.globals.maxSize.org, 
[18:02:33.861]                         ...future.globals.maxSize)) {
[18:02:33.861]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:33.861]                         on.exit(options(oopts), add = TRUE)
[18:02:33.861]                       }
[18:02:33.861]                       {
[18:02:33.861]                         lapply(seq_along(...future.elements_ii), 
[18:02:33.861]                           FUN = function(jj) {
[18:02:33.861]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:33.861]                             ...future.FUN(...future.X_jj, ...)
[18:02:33.861]                           })
[18:02:33.861]                       }
[18:02:33.861]                     }, args = future.call.arguments)
[18:02:33.861]                   }
[18:02:33.861]                 }, immediateCondition = function(cond) {
[18:02:33.861]                   sendCondition <- ...future.makeSendCondition()
[18:02:33.861]                   sendCondition(cond)
[18:02:33.861]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:33.861]                   {
[18:02:33.861]                     inherits <- base::inherits
[18:02:33.861]                     invokeRestart <- base::invokeRestart
[18:02:33.861]                     is.null <- base::is.null
[18:02:33.861]                     muffled <- FALSE
[18:02:33.861]                     if (inherits(cond, "message")) {
[18:02:33.861]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:33.861]                       if (muffled) 
[18:02:33.861]                         invokeRestart("muffleMessage")
[18:02:33.861]                     }
[18:02:33.861]                     else if (inherits(cond, "warning")) {
[18:02:33.861]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:33.861]                       if (muffled) 
[18:02:33.861]                         invokeRestart("muffleWarning")
[18:02:33.861]                     }
[18:02:33.861]                     else if (inherits(cond, "condition")) {
[18:02:33.861]                       if (!is.null(pattern)) {
[18:02:33.861]                         computeRestarts <- base::computeRestarts
[18:02:33.861]                         grepl <- base::grepl
[18:02:33.861]                         restarts <- computeRestarts(cond)
[18:02:33.861]                         for (restart in restarts) {
[18:02:33.861]                           name <- restart$name
[18:02:33.861]                           if (is.null(name)) 
[18:02:33.861]                             next
[18:02:33.861]                           if (!grepl(pattern, name)) 
[18:02:33.861]                             next
[18:02:33.861]                           invokeRestart(restart)
[18:02:33.861]                           muffled <- TRUE
[18:02:33.861]                           break
[18:02:33.861]                         }
[18:02:33.861]                       }
[18:02:33.861]                     }
[18:02:33.861]                     invisible(muffled)
[18:02:33.861]                   }
[18:02:33.861]                   muffleCondition(cond)
[18:02:33.861]                 })
[18:02:33.861]             }))
[18:02:33.861]             future::FutureResult(value = ...future.value$value, 
[18:02:33.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:33.861]                   ...future.rng), globalenv = if (FALSE) 
[18:02:33.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:33.861]                     ...future.globalenv.names))
[18:02:33.861]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:33.861]         }, condition = base::local({
[18:02:33.861]             c <- base::c
[18:02:33.861]             inherits <- base::inherits
[18:02:33.861]             invokeRestart <- base::invokeRestart
[18:02:33.861]             length <- base::length
[18:02:33.861]             list <- base::list
[18:02:33.861]             seq.int <- base::seq.int
[18:02:33.861]             signalCondition <- base::signalCondition
[18:02:33.861]             sys.calls <- base::sys.calls
[18:02:33.861]             `[[` <- base::`[[`
[18:02:33.861]             `+` <- base::`+`
[18:02:33.861]             `<<-` <- base::`<<-`
[18:02:33.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:33.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:33.861]                   3L)]
[18:02:33.861]             }
[18:02:33.861]             function(cond) {
[18:02:33.861]                 is_error <- inherits(cond, "error")
[18:02:33.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:33.861]                   NULL)
[18:02:33.861]                 if (is_error) {
[18:02:33.861]                   sessionInformation <- function() {
[18:02:33.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:33.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:33.861]                       search = base::search(), system = base::Sys.info())
[18:02:33.861]                   }
[18:02:33.861]                   ...future.conditions[[length(...future.conditions) + 
[18:02:33.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:33.861]                     cond$call), session = sessionInformation(), 
[18:02:33.861]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:33.861]                   signalCondition(cond)
[18:02:33.861]                 }
[18:02:33.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:33.861]                 "immediateCondition"))) {
[18:02:33.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:33.861]                   ...future.conditions[[length(...future.conditions) + 
[18:02:33.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:33.861]                   if (TRUE && !signal) {
[18:02:33.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:33.861]                     {
[18:02:33.861]                       inherits <- base::inherits
[18:02:33.861]                       invokeRestart <- base::invokeRestart
[18:02:33.861]                       is.null <- base::is.null
[18:02:33.861]                       muffled <- FALSE
[18:02:33.861]                       if (inherits(cond, "message")) {
[18:02:33.861]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:33.861]                         if (muffled) 
[18:02:33.861]                           invokeRestart("muffleMessage")
[18:02:33.861]                       }
[18:02:33.861]                       else if (inherits(cond, "warning")) {
[18:02:33.861]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:33.861]                         if (muffled) 
[18:02:33.861]                           invokeRestart("muffleWarning")
[18:02:33.861]                       }
[18:02:33.861]                       else if (inherits(cond, "condition")) {
[18:02:33.861]                         if (!is.null(pattern)) {
[18:02:33.861]                           computeRestarts <- base::computeRestarts
[18:02:33.861]                           grepl <- base::grepl
[18:02:33.861]                           restarts <- computeRestarts(cond)
[18:02:33.861]                           for (restart in restarts) {
[18:02:33.861]                             name <- restart$name
[18:02:33.861]                             if (is.null(name)) 
[18:02:33.861]                               next
[18:02:33.861]                             if (!grepl(pattern, name)) 
[18:02:33.861]                               next
[18:02:33.861]                             invokeRestart(restart)
[18:02:33.861]                             muffled <- TRUE
[18:02:33.861]                             break
[18:02:33.861]                           }
[18:02:33.861]                         }
[18:02:33.861]                       }
[18:02:33.861]                       invisible(muffled)
[18:02:33.861]                     }
[18:02:33.861]                     muffleCondition(cond, pattern = "^muffle")
[18:02:33.861]                   }
[18:02:33.861]                 }
[18:02:33.861]                 else {
[18:02:33.861]                   if (TRUE) {
[18:02:33.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:33.861]                     {
[18:02:33.861]                       inherits <- base::inherits
[18:02:33.861]                       invokeRestart <- base::invokeRestart
[18:02:33.861]                       is.null <- base::is.null
[18:02:33.861]                       muffled <- FALSE
[18:02:33.861]                       if (inherits(cond, "message")) {
[18:02:33.861]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:33.861]                         if (muffled) 
[18:02:33.861]                           invokeRestart("muffleMessage")
[18:02:33.861]                       }
[18:02:33.861]                       else if (inherits(cond, "warning")) {
[18:02:33.861]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:33.861]                         if (muffled) 
[18:02:33.861]                           invokeRestart("muffleWarning")
[18:02:33.861]                       }
[18:02:33.861]                       else if (inherits(cond, "condition")) {
[18:02:33.861]                         if (!is.null(pattern)) {
[18:02:33.861]                           computeRestarts <- base::computeRestarts
[18:02:33.861]                           grepl <- base::grepl
[18:02:33.861]                           restarts <- computeRestarts(cond)
[18:02:33.861]                           for (restart in restarts) {
[18:02:33.861]                             name <- restart$name
[18:02:33.861]                             if (is.null(name)) 
[18:02:33.861]                               next
[18:02:33.861]                             if (!grepl(pattern, name)) 
[18:02:33.861]                               next
[18:02:33.861]                             invokeRestart(restart)
[18:02:33.861]                             muffled <- TRUE
[18:02:33.861]                             break
[18:02:33.861]                           }
[18:02:33.861]                         }
[18:02:33.861]                       }
[18:02:33.861]                       invisible(muffled)
[18:02:33.861]                     }
[18:02:33.861]                     muffleCondition(cond, pattern = "^muffle")
[18:02:33.861]                   }
[18:02:33.861]                 }
[18:02:33.861]             }
[18:02:33.861]         }))
[18:02:33.861]     }, error = function(ex) {
[18:02:33.861]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:33.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:33.861]                 ...future.rng), started = ...future.startTime, 
[18:02:33.861]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:33.861]             version = "1.8"), class = "FutureResult")
[18:02:33.861]     }, finally = {
[18:02:33.861]         if (!identical(...future.workdir, getwd())) 
[18:02:33.861]             setwd(...future.workdir)
[18:02:33.861]         {
[18:02:33.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:33.861]                 ...future.oldOptions$nwarnings <- NULL
[18:02:33.861]             }
[18:02:33.861]             base::options(...future.oldOptions)
[18:02:33.861]             if (.Platform$OS.type == "windows") {
[18:02:33.861]                 old_names <- names(...future.oldEnvVars)
[18:02:33.861]                 envs <- base::Sys.getenv()
[18:02:33.861]                 names <- names(envs)
[18:02:33.861]                 common <- intersect(names, old_names)
[18:02:33.861]                 added <- setdiff(names, old_names)
[18:02:33.861]                 removed <- setdiff(old_names, names)
[18:02:33.861]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:33.861]                   envs[common]]
[18:02:33.861]                 NAMES <- toupper(changed)
[18:02:33.861]                 args <- list()
[18:02:33.861]                 for (kk in seq_along(NAMES)) {
[18:02:33.861]                   name <- changed[[kk]]
[18:02:33.861]                   NAME <- NAMES[[kk]]
[18:02:33.861]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:33.861]                     next
[18:02:33.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:33.861]                 }
[18:02:33.861]                 NAMES <- toupper(added)
[18:02:33.861]                 for (kk in seq_along(NAMES)) {
[18:02:33.861]                   name <- added[[kk]]
[18:02:33.861]                   NAME <- NAMES[[kk]]
[18:02:33.861]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:33.861]                     next
[18:02:33.861]                   args[[name]] <- ""
[18:02:33.861]                 }
[18:02:33.861]                 NAMES <- toupper(removed)
[18:02:33.861]                 for (kk in seq_along(NAMES)) {
[18:02:33.861]                   name <- removed[[kk]]
[18:02:33.861]                   NAME <- NAMES[[kk]]
[18:02:33.861]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:33.861]                     next
[18:02:33.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:33.861]                 }
[18:02:33.861]                 if (length(args) > 0) 
[18:02:33.861]                   base::do.call(base::Sys.setenv, args = args)
[18:02:33.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:33.861]             }
[18:02:33.861]             else {
[18:02:33.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:33.861]             }
[18:02:33.861]             {
[18:02:33.861]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:33.861]                   0L) {
[18:02:33.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:33.861]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:33.861]                   base::options(opts)
[18:02:33.861]                 }
[18:02:33.861]                 {
[18:02:33.861]                   {
[18:02:33.861]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:33.861]                     NULL
[18:02:33.861]                   }
[18:02:33.861]                   options(future.plan = NULL)
[18:02:33.861]                   if (is.na(NA_character_)) 
[18:02:33.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:33.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:33.861]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:33.861]                     .init = FALSE)
[18:02:33.861]                 }
[18:02:33.861]             }
[18:02:33.861]         }
[18:02:33.861]     })
[18:02:33.861]     if (TRUE) {
[18:02:33.861]         base::sink(type = "output", split = FALSE)
[18:02:33.861]         if (FALSE) {
[18:02:33.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:33.861]         }
[18:02:33.861]         else {
[18:02:33.861]             ...future.result["stdout"] <- base::list(NULL)
[18:02:33.861]         }
[18:02:33.861]         base::close(...future.stdout)
[18:02:33.861]         ...future.stdout <- NULL
[18:02:33.861]     }
[18:02:33.861]     ...future.result$conditions <- ...future.conditions
[18:02:33.861]     ...future.result$finished <- base::Sys.time()
[18:02:33.861]     ...future.result
[18:02:33.861] }
[18:02:33.867] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[18:02:33.867] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[18:02:33.868] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[18:02:33.869] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:33.870] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:33.870] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[18:02:33.871] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[18:02:33.871] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:33.872] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:33.872] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:33.873] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:33.874] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[18:02:33.875] MultisessionFuture started
[18:02:33.875] - Launch lazy future ... done
[18:02:33.875] run() for ‘MultisessionFuture’ ... done
[18:02:33.875] Created future:
[18:02:33.876] MultisessionFuture:
[18:02:33.876] Label: ‘future_lapply-1’
[18:02:33.876] Expression:
[18:02:33.876] {
[18:02:33.876]     do.call(function(...) {
[18:02:33.876]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:33.876]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:33.876]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:33.876]             on.exit(options(oopts), add = TRUE)
[18:02:33.876]         }
[18:02:33.876]         {
[18:02:33.876]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:33.876]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:33.876]                 ...future.FUN(...future.X_jj, ...)
[18:02:33.876]             })
[18:02:33.876]         }
[18:02:33.876]     }, args = future.call.arguments)
[18:02:33.876] }
[18:02:33.876] Lazy evaluation: FALSE
[18:02:33.876] Asynchronous evaluation: TRUE
[18:02:33.876] Local evaluation: TRUE
[18:02:33.876] Environment: R_GlobalEnv
[18:02:33.876] Capture standard output: FALSE
[18:02:33.876] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:33.876] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:33.876] Packages: <none>
[18:02:33.876] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:33.876] Resolved: FALSE
[18:02:33.876] Value: <not collected>
[18:02:33.876] Conditions captured: <none>
[18:02:33.876] Early signaling: FALSE
[18:02:33.876] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:33.876] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:33.889] Chunk #1 of 2 ... DONE
[18:02:33.890] Chunk #2 of 2 ...
[18:02:33.890]  - Finding globals in 'X' for chunk #2 ...
[18:02:33.890] getGlobalsAndPackages() ...
[18:02:33.890] Searching for globals...
[18:02:33.891] 
[18:02:33.891] Searching for globals ... DONE
[18:02:33.892] - globals: [0] <none>
[18:02:33.892] getGlobalsAndPackages() ... DONE
[18:02:33.892]    + additional globals found: [n=0] 
[18:02:33.892]    + additional namespaces needed: [n=0] 
[18:02:33.893]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:33.893]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:33.893]  - seeds: <none>
[18:02:33.893]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:33.893] getGlobalsAndPackages() ...
[18:02:33.894] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:33.894] Resolving globals: FALSE
[18:02:33.894] Tweak future expression to call with '...' arguments ...
[18:02:33.895] {
[18:02:33.895]     do.call(function(...) {
[18:02:33.895]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:33.895]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:33.895]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:33.895]             on.exit(options(oopts), add = TRUE)
[18:02:33.895]         }
[18:02:33.895]         {
[18:02:33.895]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:33.895]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:33.895]                 ...future.FUN(...future.X_jj, ...)
[18:02:33.895]             })
[18:02:33.895]         }
[18:02:33.895]     }, args = future.call.arguments)
[18:02:33.895] }
[18:02:33.895] Tweak future expression to call with '...' arguments ... DONE
[18:02:33.896] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:33.897] 
[18:02:33.897] getGlobalsAndPackages() ... DONE
[18:02:33.898] run() for ‘Future’ ...
[18:02:33.898] - state: ‘created’
[18:02:33.898] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:33.924] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:33.924] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:33.925]   - Field: ‘node’
[18:02:33.925]   - Field: ‘label’
[18:02:33.925]   - Field: ‘local’
[18:02:33.925]   - Field: ‘owner’
[18:02:33.925]   - Field: ‘envir’
[18:02:33.926]   - Field: ‘workers’
[18:02:33.926]   - Field: ‘packages’
[18:02:33.926]   - Field: ‘gc’
[18:02:33.926]   - Field: ‘conditions’
[18:02:33.927]   - Field: ‘persistent’
[18:02:33.927]   - Field: ‘expr’
[18:02:33.927]   - Field: ‘uuid’
[18:02:33.927]   - Field: ‘seed’
[18:02:33.928]   - Field: ‘version’
[18:02:33.928]   - Field: ‘result’
[18:02:33.928]   - Field: ‘asynchronous’
[18:02:33.928]   - Field: ‘calls’
[18:02:33.928]   - Field: ‘globals’
[18:02:33.929]   - Field: ‘stdout’
[18:02:33.929]   - Field: ‘earlySignal’
[18:02:33.929]   - Field: ‘lazy’
[18:02:33.929]   - Field: ‘state’
[18:02:33.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:33.930] - Launch lazy future ...
[18:02:33.931] Packages needed by the future expression (n = 0): <none>
[18:02:33.931] Packages needed by future strategies (n = 0): <none>
[18:02:33.932] {
[18:02:33.932]     {
[18:02:33.932]         {
[18:02:33.932]             ...future.startTime <- base::Sys.time()
[18:02:33.932]             {
[18:02:33.932]                 {
[18:02:33.932]                   {
[18:02:33.932]                     {
[18:02:33.932]                       base::local({
[18:02:33.932]                         has_future <- base::requireNamespace("future", 
[18:02:33.932]                           quietly = TRUE)
[18:02:33.932]                         if (has_future) {
[18:02:33.932]                           ns <- base::getNamespace("future")
[18:02:33.932]                           version <- ns[[".package"]][["version"]]
[18:02:33.932]                           if (is.null(version)) 
[18:02:33.932]                             version <- utils::packageVersion("future")
[18:02:33.932]                         }
[18:02:33.932]                         else {
[18:02:33.932]                           version <- NULL
[18:02:33.932]                         }
[18:02:33.932]                         if (!has_future || version < "1.8.0") {
[18:02:33.932]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:33.932]                             "", base::R.version$version.string), 
[18:02:33.932]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:33.932]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:33.932]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:33.932]                               "release", "version")], collapse = " "), 
[18:02:33.932]                             hostname = base::Sys.info()[["nodename"]])
[18:02:33.932]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:33.932]                             info)
[18:02:33.932]                           info <- base::paste(info, collapse = "; ")
[18:02:33.932]                           if (!has_future) {
[18:02:33.932]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:33.932]                               info)
[18:02:33.932]                           }
[18:02:33.932]                           else {
[18:02:33.932]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:33.932]                               info, version)
[18:02:33.932]                           }
[18:02:33.932]                           base::stop(msg)
[18:02:33.932]                         }
[18:02:33.932]                       })
[18:02:33.932]                     }
[18:02:33.932]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:33.932]                     base::options(mc.cores = 1L)
[18:02:33.932]                   }
[18:02:33.932]                   ...future.strategy.old <- future::plan("list")
[18:02:33.932]                   options(future.plan = NULL)
[18:02:33.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:33.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:33.932]                 }
[18:02:33.932]                 ...future.workdir <- getwd()
[18:02:33.932]             }
[18:02:33.932]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:33.932]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:33.932]         }
[18:02:33.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:33.932]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:33.932]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:33.932]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:33.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:33.932]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:33.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:33.932]             base::names(...future.oldOptions))
[18:02:33.932]     }
[18:02:33.932]     if (FALSE) {
[18:02:33.932]     }
[18:02:33.932]     else {
[18:02:33.932]         if (FALSE) {
[18:02:33.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:33.932]                 open = "w")
[18:02:33.932]         }
[18:02:33.932]         else {
[18:02:33.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:33.932]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:33.932]         }
[18:02:33.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:33.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:33.932]             base::sink(type = "output", split = FALSE)
[18:02:33.932]             base::close(...future.stdout)
[18:02:33.932]         }, add = TRUE)
[18:02:33.932]     }
[18:02:33.932]     ...future.frame <- base::sys.nframe()
[18:02:33.932]     ...future.conditions <- base::list()
[18:02:33.932]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:33.932]     if (FALSE) {
[18:02:33.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:33.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:33.932]     }
[18:02:33.932]     ...future.result <- base::tryCatch({
[18:02:33.932]         base::withCallingHandlers({
[18:02:33.932]             ...future.value <- base::withVisible(base::local({
[18:02:33.932]                 ...future.makeSendCondition <- base::local({
[18:02:33.932]                   sendCondition <- NULL
[18:02:33.932]                   function(frame = 1L) {
[18:02:33.932]                     if (is.function(sendCondition)) 
[18:02:33.932]                       return(sendCondition)
[18:02:33.932]                     ns <- getNamespace("parallel")
[18:02:33.932]                     if (exists("sendData", mode = "function", 
[18:02:33.932]                       envir = ns)) {
[18:02:33.932]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:33.932]                         envir = ns)
[18:02:33.932]                       envir <- sys.frame(frame)
[18:02:33.932]                       master <- NULL
[18:02:33.932]                       while (!identical(envir, .GlobalEnv) && 
[18:02:33.932]                         !identical(envir, emptyenv())) {
[18:02:33.932]                         if (exists("master", mode = "list", envir = envir, 
[18:02:33.932]                           inherits = FALSE)) {
[18:02:33.932]                           master <- get("master", mode = "list", 
[18:02:33.932]                             envir = envir, inherits = FALSE)
[18:02:33.932]                           if (inherits(master, c("SOCKnode", 
[18:02:33.932]                             "SOCK0node"))) {
[18:02:33.932]                             sendCondition <<- function(cond) {
[18:02:33.932]                               data <- list(type = "VALUE", value = cond, 
[18:02:33.932]                                 success = TRUE)
[18:02:33.932]                               parallel_sendData(master, data)
[18:02:33.932]                             }
[18:02:33.932]                             return(sendCondition)
[18:02:33.932]                           }
[18:02:33.932]                         }
[18:02:33.932]                         frame <- frame + 1L
[18:02:33.932]                         envir <- sys.frame(frame)
[18:02:33.932]                       }
[18:02:33.932]                     }
[18:02:33.932]                     sendCondition <<- function(cond) NULL
[18:02:33.932]                   }
[18:02:33.932]                 })
[18:02:33.932]                 withCallingHandlers({
[18:02:33.932]                   {
[18:02:33.932]                     do.call(function(...) {
[18:02:33.932]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:33.932]                       if (!identical(...future.globals.maxSize.org, 
[18:02:33.932]                         ...future.globals.maxSize)) {
[18:02:33.932]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:33.932]                         on.exit(options(oopts), add = TRUE)
[18:02:33.932]                       }
[18:02:33.932]                       {
[18:02:33.932]                         lapply(seq_along(...future.elements_ii), 
[18:02:33.932]                           FUN = function(jj) {
[18:02:33.932]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:33.932]                             ...future.FUN(...future.X_jj, ...)
[18:02:33.932]                           })
[18:02:33.932]                       }
[18:02:33.932]                     }, args = future.call.arguments)
[18:02:33.932]                   }
[18:02:33.932]                 }, immediateCondition = function(cond) {
[18:02:33.932]                   sendCondition <- ...future.makeSendCondition()
[18:02:33.932]                   sendCondition(cond)
[18:02:33.932]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:33.932]                   {
[18:02:33.932]                     inherits <- base::inherits
[18:02:33.932]                     invokeRestart <- base::invokeRestart
[18:02:33.932]                     is.null <- base::is.null
[18:02:33.932]                     muffled <- FALSE
[18:02:33.932]                     if (inherits(cond, "message")) {
[18:02:33.932]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:33.932]                       if (muffled) 
[18:02:33.932]                         invokeRestart("muffleMessage")
[18:02:33.932]                     }
[18:02:33.932]                     else if (inherits(cond, "warning")) {
[18:02:33.932]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:33.932]                       if (muffled) 
[18:02:33.932]                         invokeRestart("muffleWarning")
[18:02:33.932]                     }
[18:02:33.932]                     else if (inherits(cond, "condition")) {
[18:02:33.932]                       if (!is.null(pattern)) {
[18:02:33.932]                         computeRestarts <- base::computeRestarts
[18:02:33.932]                         grepl <- base::grepl
[18:02:33.932]                         restarts <- computeRestarts(cond)
[18:02:33.932]                         for (restart in restarts) {
[18:02:33.932]                           name <- restart$name
[18:02:33.932]                           if (is.null(name)) 
[18:02:33.932]                             next
[18:02:33.932]                           if (!grepl(pattern, name)) 
[18:02:33.932]                             next
[18:02:33.932]                           invokeRestart(restart)
[18:02:33.932]                           muffled <- TRUE
[18:02:33.932]                           break
[18:02:33.932]                         }
[18:02:33.932]                       }
[18:02:33.932]                     }
[18:02:33.932]                     invisible(muffled)
[18:02:33.932]                   }
[18:02:33.932]                   muffleCondition(cond)
[18:02:33.932]                 })
[18:02:33.932]             }))
[18:02:33.932]             future::FutureResult(value = ...future.value$value, 
[18:02:33.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:33.932]                   ...future.rng), globalenv = if (FALSE) 
[18:02:33.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:33.932]                     ...future.globalenv.names))
[18:02:33.932]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:33.932]         }, condition = base::local({
[18:02:33.932]             c <- base::c
[18:02:33.932]             inherits <- base::inherits
[18:02:33.932]             invokeRestart <- base::invokeRestart
[18:02:33.932]             length <- base::length
[18:02:33.932]             list <- base::list
[18:02:33.932]             seq.int <- base::seq.int
[18:02:33.932]             signalCondition <- base::signalCondition
[18:02:33.932]             sys.calls <- base::sys.calls
[18:02:33.932]             `[[` <- base::`[[`
[18:02:33.932]             `+` <- base::`+`
[18:02:33.932]             `<<-` <- base::`<<-`
[18:02:33.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:33.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:33.932]                   3L)]
[18:02:33.932]             }
[18:02:33.932]             function(cond) {
[18:02:33.932]                 is_error <- inherits(cond, "error")
[18:02:33.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:33.932]                   NULL)
[18:02:33.932]                 if (is_error) {
[18:02:33.932]                   sessionInformation <- function() {
[18:02:33.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:33.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:33.932]                       search = base::search(), system = base::Sys.info())
[18:02:33.932]                   }
[18:02:33.932]                   ...future.conditions[[length(...future.conditions) + 
[18:02:33.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:33.932]                     cond$call), session = sessionInformation(), 
[18:02:33.932]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:33.932]                   signalCondition(cond)
[18:02:33.932]                 }
[18:02:33.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:33.932]                 "immediateCondition"))) {
[18:02:33.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:33.932]                   ...future.conditions[[length(...future.conditions) + 
[18:02:33.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:33.932]                   if (TRUE && !signal) {
[18:02:33.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:33.932]                     {
[18:02:33.932]                       inherits <- base::inherits
[18:02:33.932]                       invokeRestart <- base::invokeRestart
[18:02:33.932]                       is.null <- base::is.null
[18:02:33.932]                       muffled <- FALSE
[18:02:33.932]                       if (inherits(cond, "message")) {
[18:02:33.932]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:33.932]                         if (muffled) 
[18:02:33.932]                           invokeRestart("muffleMessage")
[18:02:33.932]                       }
[18:02:33.932]                       else if (inherits(cond, "warning")) {
[18:02:33.932]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:33.932]                         if (muffled) 
[18:02:33.932]                           invokeRestart("muffleWarning")
[18:02:33.932]                       }
[18:02:33.932]                       else if (inherits(cond, "condition")) {
[18:02:33.932]                         if (!is.null(pattern)) {
[18:02:33.932]                           computeRestarts <- base::computeRestarts
[18:02:33.932]                           grepl <- base::grepl
[18:02:33.932]                           restarts <- computeRestarts(cond)
[18:02:33.932]                           for (restart in restarts) {
[18:02:33.932]                             name <- restart$name
[18:02:33.932]                             if (is.null(name)) 
[18:02:33.932]                               next
[18:02:33.932]                             if (!grepl(pattern, name)) 
[18:02:33.932]                               next
[18:02:33.932]                             invokeRestart(restart)
[18:02:33.932]                             muffled <- TRUE
[18:02:33.932]                             break
[18:02:33.932]                           }
[18:02:33.932]                         }
[18:02:33.932]                       }
[18:02:33.932]                       invisible(muffled)
[18:02:33.932]                     }
[18:02:33.932]                     muffleCondition(cond, pattern = "^muffle")
[18:02:33.932]                   }
[18:02:33.932]                 }
[18:02:33.932]                 else {
[18:02:33.932]                   if (TRUE) {
[18:02:33.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:33.932]                     {
[18:02:33.932]                       inherits <- base::inherits
[18:02:33.932]                       invokeRestart <- base::invokeRestart
[18:02:33.932]                       is.null <- base::is.null
[18:02:33.932]                       muffled <- FALSE
[18:02:33.932]                       if (inherits(cond, "message")) {
[18:02:33.932]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:33.932]                         if (muffled) 
[18:02:33.932]                           invokeRestart("muffleMessage")
[18:02:33.932]                       }
[18:02:33.932]                       else if (inherits(cond, "warning")) {
[18:02:33.932]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:33.932]                         if (muffled) 
[18:02:33.932]                           invokeRestart("muffleWarning")
[18:02:33.932]                       }
[18:02:33.932]                       else if (inherits(cond, "condition")) {
[18:02:33.932]                         if (!is.null(pattern)) {
[18:02:33.932]                           computeRestarts <- base::computeRestarts
[18:02:33.932]                           grepl <- base::grepl
[18:02:33.932]                           restarts <- computeRestarts(cond)
[18:02:33.932]                           for (restart in restarts) {
[18:02:33.932]                             name <- restart$name
[18:02:33.932]                             if (is.null(name)) 
[18:02:33.932]                               next
[18:02:33.932]                             if (!grepl(pattern, name)) 
[18:02:33.932]                               next
[18:02:33.932]                             invokeRestart(restart)
[18:02:33.932]                             muffled <- TRUE
[18:02:33.932]                             break
[18:02:33.932]                           }
[18:02:33.932]                         }
[18:02:33.932]                       }
[18:02:33.932]                       invisible(muffled)
[18:02:33.932]                     }
[18:02:33.932]                     muffleCondition(cond, pattern = "^muffle")
[18:02:33.932]                   }
[18:02:33.932]                 }
[18:02:33.932]             }
[18:02:33.932]         }))
[18:02:33.932]     }, error = function(ex) {
[18:02:33.932]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:33.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:33.932]                 ...future.rng), started = ...future.startTime, 
[18:02:33.932]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:33.932]             version = "1.8"), class = "FutureResult")
[18:02:33.932]     }, finally = {
[18:02:33.932]         if (!identical(...future.workdir, getwd())) 
[18:02:33.932]             setwd(...future.workdir)
[18:02:33.932]         {
[18:02:33.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:33.932]                 ...future.oldOptions$nwarnings <- NULL
[18:02:33.932]             }
[18:02:33.932]             base::options(...future.oldOptions)
[18:02:33.932]             if (.Platform$OS.type == "windows") {
[18:02:33.932]                 old_names <- names(...future.oldEnvVars)
[18:02:33.932]                 envs <- base::Sys.getenv()
[18:02:33.932]                 names <- names(envs)
[18:02:33.932]                 common <- intersect(names, old_names)
[18:02:33.932]                 added <- setdiff(names, old_names)
[18:02:33.932]                 removed <- setdiff(old_names, names)
[18:02:33.932]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:33.932]                   envs[common]]
[18:02:33.932]                 NAMES <- toupper(changed)
[18:02:33.932]                 args <- list()
[18:02:33.932]                 for (kk in seq_along(NAMES)) {
[18:02:33.932]                   name <- changed[[kk]]
[18:02:33.932]                   NAME <- NAMES[[kk]]
[18:02:33.932]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:33.932]                     next
[18:02:33.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:33.932]                 }
[18:02:33.932]                 NAMES <- toupper(added)
[18:02:33.932]                 for (kk in seq_along(NAMES)) {
[18:02:33.932]                   name <- added[[kk]]
[18:02:33.932]                   NAME <- NAMES[[kk]]
[18:02:33.932]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:33.932]                     next
[18:02:33.932]                   args[[name]] <- ""
[18:02:33.932]                 }
[18:02:33.932]                 NAMES <- toupper(removed)
[18:02:33.932]                 for (kk in seq_along(NAMES)) {
[18:02:33.932]                   name <- removed[[kk]]
[18:02:33.932]                   NAME <- NAMES[[kk]]
[18:02:33.932]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:33.932]                     next
[18:02:33.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:33.932]                 }
[18:02:33.932]                 if (length(args) > 0) 
[18:02:33.932]                   base::do.call(base::Sys.setenv, args = args)
[18:02:33.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:33.932]             }
[18:02:33.932]             else {
[18:02:33.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:33.932]             }
[18:02:33.932]             {
[18:02:33.932]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:33.932]                   0L) {
[18:02:33.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:33.932]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:33.932]                   base::options(opts)
[18:02:33.932]                 }
[18:02:33.932]                 {
[18:02:33.932]                   {
[18:02:33.932]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:33.932]                     NULL
[18:02:33.932]                   }
[18:02:33.932]                   options(future.plan = NULL)
[18:02:33.932]                   if (is.na(NA_character_)) 
[18:02:33.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:33.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:33.932]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:33.932]                     .init = FALSE)
[18:02:33.932]                 }
[18:02:33.932]             }
[18:02:33.932]         }
[18:02:33.932]     })
[18:02:33.932]     if (TRUE) {
[18:02:33.932]         base::sink(type = "output", split = FALSE)
[18:02:33.932]         if (FALSE) {
[18:02:33.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:33.932]         }
[18:02:33.932]         else {
[18:02:33.932]             ...future.result["stdout"] <- base::list(NULL)
[18:02:33.932]         }
[18:02:33.932]         base::close(...future.stdout)
[18:02:33.932]         ...future.stdout <- NULL
[18:02:33.932]     }
[18:02:33.932]     ...future.result$conditions <- ...future.conditions
[18:02:33.932]     ...future.result$finished <- base::Sys.time()
[18:02:33.932]     ...future.result
[18:02:33.932] }
[18:02:34.031] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[18:02:34.031] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[18:02:34.032] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[18:02:34.032] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:34.033] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:34.034] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[18:02:34.034] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[18:02:34.035] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:34.036] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:34.037] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:34.038] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:34.038] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[18:02:34.040] MultisessionFuture started
[18:02:34.040] - Launch lazy future ... done
[18:02:34.041] run() for ‘MultisessionFuture’ ... done
[18:02:34.041] Created future:
[18:02:34.041] MultisessionFuture:
[18:02:34.041] Label: ‘future_lapply-2’
[18:02:34.041] Expression:
[18:02:34.041] {
[18:02:34.041]     do.call(function(...) {
[18:02:34.041]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:34.041]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:34.041]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:34.041]             on.exit(options(oopts), add = TRUE)
[18:02:34.041]         }
[18:02:34.041]         {
[18:02:34.041]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:34.041]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:34.041]                 ...future.FUN(...future.X_jj, ...)
[18:02:34.041]             })
[18:02:34.041]         }
[18:02:34.041]     }, args = future.call.arguments)
[18:02:34.041] }
[18:02:34.041] Lazy evaluation: FALSE
[18:02:34.041] Asynchronous evaluation: TRUE
[18:02:34.041] Local evaluation: TRUE
[18:02:34.041] Environment: R_GlobalEnv
[18:02:34.041] Capture standard output: FALSE
[18:02:34.041] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:34.041] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:34.041] Packages: <none>
[18:02:34.041] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:34.041] Resolved: FALSE
[18:02:34.041] Value: <not collected>
[18:02:34.041] Conditions captured: <none>
[18:02:34.041] Early signaling: FALSE
[18:02:34.041] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:34.041] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:34.057] Chunk #2 of 2 ... DONE
[18:02:34.057] Launching 2 futures (chunks) ... DONE
[18:02:34.057] Resolving 2 futures (chunks) ...
[18:02:34.058] resolve() on list ...
[18:02:34.058]  recursive: 0
[18:02:34.059]  length: 2
[18:02:34.059] 
[18:02:34.145] receiveMessageFromWorker() for ClusterFuture ...
[18:02:34.146] - Validating connection of MultisessionFuture
[18:02:34.146] - received message: FutureResult
[18:02:34.147] - Received FutureResult
[18:02:34.147] - Erased future from FutureRegistry
[18:02:34.147] result() for ClusterFuture ...
[18:02:34.148] - result already collected: FutureResult
[18:02:34.148] result() for ClusterFuture ... done
[18:02:34.148] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:34.149] Future #2
[18:02:34.149] result() for ClusterFuture ...
[18:02:34.149] - result already collected: FutureResult
[18:02:34.150] result() for ClusterFuture ... done
[18:02:34.150] result() for ClusterFuture ...
[18:02:34.150] - result already collected: FutureResult
[18:02:34.151] result() for ClusterFuture ... done
[18:02:34.151] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:34.151] - nx: 2
[18:02:34.151] - relay: TRUE
[18:02:34.152] - stdout: TRUE
[18:02:34.152] - signal: TRUE
[18:02:34.152] - resignal: FALSE
[18:02:34.153] - force: TRUE
[18:02:34.153] - relayed: [n=2] FALSE, FALSE
[18:02:34.153] - queued futures: [n=2] FALSE, FALSE
[18:02:34.154]  - until=1
[18:02:34.154]  - relaying element #1
[18:02:34.154] - relayed: [n=2] FALSE, FALSE
[18:02:34.154] - queued futures: [n=2] FALSE, TRUE
[18:02:34.155] signalConditionsASAP(NULL, pos=2) ... done
[18:02:34.155]  length: 1 (resolved future 2)
[18:02:34.423] receiveMessageFromWorker() for ClusterFuture ...
[18:02:34.424] - Validating connection of MultisessionFuture
[18:02:34.424] - received message: FutureResult
[18:02:34.425] - Received FutureResult
[18:02:34.425] - Erased future from FutureRegistry
[18:02:34.425] result() for ClusterFuture ...
[18:02:34.426] - result already collected: FutureResult
[18:02:34.426] result() for ClusterFuture ... done
[18:02:34.426] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:34.427] Future #1
[18:02:34.427] result() for ClusterFuture ...
[18:02:34.427] - result already collected: FutureResult
[18:02:34.428] result() for ClusterFuture ... done
[18:02:34.428] result() for ClusterFuture ...
[18:02:34.428] - result already collected: FutureResult
[18:02:34.428] result() for ClusterFuture ... done
[18:02:34.429] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:34.429] - nx: 2
[18:02:34.429] - relay: TRUE
[18:02:34.430] - stdout: TRUE
[18:02:34.430] - signal: TRUE
[18:02:34.430] - resignal: FALSE
[18:02:34.431] - force: TRUE
[18:02:34.431] - relayed: [n=2] FALSE, FALSE
[18:02:34.431] - queued futures: [n=2] FALSE, TRUE
[18:02:34.431]  - until=1
[18:02:34.432]  - relaying element #1
[18:02:34.432] result() for ClusterFuture ...
[18:02:34.432] - result already collected: FutureResult
[18:02:34.433] result() for ClusterFuture ... done
[18:02:34.433] result() for ClusterFuture ...
[18:02:34.433] - result already collected: FutureResult
[18:02:34.434] result() for ClusterFuture ... done
[18:02:34.434] result() for ClusterFuture ...
[18:02:34.434] - result already collected: FutureResult
[18:02:34.435] result() for ClusterFuture ... done
[18:02:34.435] result() for ClusterFuture ...
[18:02:34.435] - result already collected: FutureResult
[18:02:34.435] result() for ClusterFuture ... done
[18:02:34.436] - relayed: [n=2] TRUE, FALSE
[18:02:34.436] - queued futures: [n=2] TRUE, TRUE
[18:02:34.436] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:34.437]  length: 0 (resolved future 1)
[18:02:34.437] Relaying remaining futures
[18:02:34.437] signalConditionsASAP(NULL, pos=0) ...
[18:02:34.438] - nx: 2
[18:02:34.438] - relay: TRUE
[18:02:34.438] - stdout: TRUE
[18:02:34.439] - signal: TRUE
[18:02:34.439] - resignal: FALSE
[18:02:34.439] - force: TRUE
[18:02:34.439] - relayed: [n=2] TRUE, FALSE
[18:02:34.440] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:34.440]  - relaying element #2
[18:02:34.441] result() for ClusterFuture ...
[18:02:34.441] - result already collected: FutureResult
[18:02:34.441] result() for ClusterFuture ... done
[18:02:34.442] result() for ClusterFuture ...
[18:02:34.442] - result already collected: FutureResult
[18:02:34.442] result() for ClusterFuture ... done
[18:02:34.443] result() for ClusterFuture ...
[18:02:34.443] - result already collected: FutureResult
[18:02:34.443] result() for ClusterFuture ... done
[18:02:34.443] result() for ClusterFuture ...
[18:02:34.444] - result already collected: FutureResult
[18:02:34.444] result() for ClusterFuture ... done
[18:02:34.444] - relayed: [n=2] TRUE, TRUE
[18:02:34.445] - queued futures: [n=2] TRUE, TRUE
[18:02:34.445] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[18:02:34.445] resolve() on list ... DONE
[18:02:34.445] result() for ClusterFuture ...
[18:02:34.446] - result already collected: FutureResult
[18:02:34.446] result() for ClusterFuture ... done
[18:02:34.446] result() for ClusterFuture ...
[18:02:34.447] - result already collected: FutureResult
[18:02:34.447] result() for ClusterFuture ... done
[18:02:34.447] result() for ClusterFuture ...
[18:02:34.448] - result already collected: FutureResult
[18:02:34.448] result() for ClusterFuture ... done
[18:02:34.448] result() for ClusterFuture ...
[18:02:34.448] - result already collected: FutureResult
[18:02:34.449] result() for ClusterFuture ... done
[18:02:34.449]  - Number of value chunks collected: 2
[18:02:34.449] Resolving 2 futures (chunks) ... DONE
[18:02:34.450] Reducing values from 2 chunks ...
[18:02:34.450]  - Number of values collected after concatenation: 2
[18:02:34.450]  - Number of values expected: 2
[18:02:34.451] Reducing values from 2 chunks ... DONE
[18:02:34.451] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[18:02:34.452] future_lapply() ...
[18:02:34.461] Number of chunks: 2
[18:02:34.462] getGlobalsAndPackagesXApply() ...
[18:02:34.462]  - future.globals: TRUE
[18:02:34.462] getGlobalsAndPackages() ...
[18:02:34.462] Searching for globals...
[18:02:34.465] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:34.466] Searching for globals ... DONE
[18:02:34.466] Resolving globals: FALSE
[18:02:34.467] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:34.468] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:34.468] - globals: [1] ‘FUN’
[18:02:34.468] 
[18:02:34.468] getGlobalsAndPackages() ... DONE
[18:02:34.469]  - globals found/used: [n=1] ‘FUN’
[18:02:34.469]  - needed namespaces: [n=0] 
[18:02:34.469] Finding globals ... DONE
[18:02:34.469]  - use_args: TRUE
[18:02:34.469]  - Getting '...' globals ...
[18:02:34.470] resolve() on list ...
[18:02:34.470]  recursive: 0
[18:02:34.471]  length: 1
[18:02:34.471]  elements: ‘...’
[18:02:34.471]  length: 0 (resolved future 1)
[18:02:34.471] resolve() on list ... DONE
[18:02:34.472]    - '...' content: [n=0] 
[18:02:34.472] List of 1
[18:02:34.472]  $ ...: list()
[18:02:34.472]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:34.472]  - attr(*, "where")=List of 1
[18:02:34.472]   ..$ ...:<environment: 0x5e4f83c6a220> 
[18:02:34.472]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:34.472]  - attr(*, "resolved")= logi TRUE
[18:02:34.472]  - attr(*, "total_size")= num NA
[18:02:34.478]  - Getting '...' globals ... DONE
[18:02:34.478] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:34.478] List of 2
[18:02:34.478]  $ ...future.FUN:function (x)  
[18:02:34.478]  $ ...          : list()
[18:02:34.478]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:34.478]  - attr(*, "where")=List of 2
[18:02:34.478]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:34.478]   ..$ ...          :<environment: 0x5e4f83c6a220> 
[18:02:34.478]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:34.478]  - attr(*, "resolved")= logi FALSE
[18:02:34.478]  - attr(*, "total_size")= num 4720
[18:02:34.484] Packages to be attached in all futures: [n=0] 
[18:02:34.485] getGlobalsAndPackagesXApply() ... DONE
[18:02:34.485] Number of futures (= number of chunks): 2
[18:02:34.485] Launching 2 futures (chunks) ...
[18:02:34.485] Chunk #1 of 2 ...
[18:02:34.486]  - Finding globals in 'X' for chunk #1 ...
[18:02:34.486] getGlobalsAndPackages() ...
[18:02:34.486] Searching for globals...
[18:02:34.487] 
[18:02:34.487] Searching for globals ... DONE
[18:02:34.487] - globals: [0] <none>
[18:02:34.487] getGlobalsAndPackages() ... DONE
[18:02:34.488]    + additional globals found: [n=0] 
[18:02:34.488]    + additional namespaces needed: [n=0] 
[18:02:34.488]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:34.488]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:34.488]  - seeds: <none>
[18:02:34.489]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:34.489] getGlobalsAndPackages() ...
[18:02:34.489] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:34.489] Resolving globals: FALSE
[18:02:34.490] Tweak future expression to call with '...' arguments ...
[18:02:34.490] {
[18:02:34.490]     do.call(function(...) {
[18:02:34.490]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:34.490]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:34.490]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:34.490]             on.exit(options(oopts), add = TRUE)
[18:02:34.490]         }
[18:02:34.490]         {
[18:02:34.490]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:34.490]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:34.490]                 ...future.FUN(...future.X_jj, ...)
[18:02:34.490]             })
[18:02:34.490]         }
[18:02:34.490]     }, args = future.call.arguments)
[18:02:34.490] }
[18:02:34.491] Tweak future expression to call with '...' arguments ... DONE
[18:02:34.491] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:34.492] 
[18:02:34.492] getGlobalsAndPackages() ... DONE
[18:02:34.492] run() for ‘Future’ ...
[18:02:34.493] - state: ‘created’
[18:02:34.493] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:34.518] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:34.518] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:34.519]   - Field: ‘node’
[18:02:34.519]   - Field: ‘label’
[18:02:34.519]   - Field: ‘local’
[18:02:34.519]   - Field: ‘owner’
[18:02:34.519]   - Field: ‘envir’
[18:02:34.520]   - Field: ‘workers’
[18:02:34.520]   - Field: ‘packages’
[18:02:34.520]   - Field: ‘gc’
[18:02:34.520]   - Field: ‘conditions’
[18:02:34.520]   - Field: ‘persistent’
[18:02:34.521]   - Field: ‘expr’
[18:02:34.521]   - Field: ‘uuid’
[18:02:34.521]   - Field: ‘seed’
[18:02:34.521]   - Field: ‘version’
[18:02:34.521]   - Field: ‘result’
[18:02:34.522]   - Field: ‘asynchronous’
[18:02:34.522]   - Field: ‘calls’
[18:02:34.522]   - Field: ‘globals’
[18:02:34.522]   - Field: ‘stdout’
[18:02:34.522]   - Field: ‘earlySignal’
[18:02:34.523]   - Field: ‘lazy’
[18:02:34.523]   - Field: ‘state’
[18:02:34.523] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:34.523] - Launch lazy future ...
[18:02:34.524] Packages needed by the future expression (n = 0): <none>
[18:02:34.524] Packages needed by future strategies (n = 0): <none>
[18:02:34.525] {
[18:02:34.525]     {
[18:02:34.525]         {
[18:02:34.525]             ...future.startTime <- base::Sys.time()
[18:02:34.525]             {
[18:02:34.525]                 {
[18:02:34.525]                   {
[18:02:34.525]                     {
[18:02:34.525]                       base::local({
[18:02:34.525]                         has_future <- base::requireNamespace("future", 
[18:02:34.525]                           quietly = TRUE)
[18:02:34.525]                         if (has_future) {
[18:02:34.525]                           ns <- base::getNamespace("future")
[18:02:34.525]                           version <- ns[[".package"]][["version"]]
[18:02:34.525]                           if (is.null(version)) 
[18:02:34.525]                             version <- utils::packageVersion("future")
[18:02:34.525]                         }
[18:02:34.525]                         else {
[18:02:34.525]                           version <- NULL
[18:02:34.525]                         }
[18:02:34.525]                         if (!has_future || version < "1.8.0") {
[18:02:34.525]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:34.525]                             "", base::R.version$version.string), 
[18:02:34.525]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:34.525]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:34.525]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:34.525]                               "release", "version")], collapse = " "), 
[18:02:34.525]                             hostname = base::Sys.info()[["nodename"]])
[18:02:34.525]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:34.525]                             info)
[18:02:34.525]                           info <- base::paste(info, collapse = "; ")
[18:02:34.525]                           if (!has_future) {
[18:02:34.525]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:34.525]                               info)
[18:02:34.525]                           }
[18:02:34.525]                           else {
[18:02:34.525]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:34.525]                               info, version)
[18:02:34.525]                           }
[18:02:34.525]                           base::stop(msg)
[18:02:34.525]                         }
[18:02:34.525]                       })
[18:02:34.525]                     }
[18:02:34.525]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:34.525]                     base::options(mc.cores = 1L)
[18:02:34.525]                   }
[18:02:34.525]                   ...future.strategy.old <- future::plan("list")
[18:02:34.525]                   options(future.plan = NULL)
[18:02:34.525]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:34.525]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:34.525]                 }
[18:02:34.525]                 ...future.workdir <- getwd()
[18:02:34.525]             }
[18:02:34.525]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:34.525]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:34.525]         }
[18:02:34.525]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:34.525]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:34.525]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:34.525]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:34.525]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:34.525]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:34.525]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:34.525]             base::names(...future.oldOptions))
[18:02:34.525]     }
[18:02:34.525]     if (FALSE) {
[18:02:34.525]     }
[18:02:34.525]     else {
[18:02:34.525]         if (TRUE) {
[18:02:34.525]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:34.525]                 open = "w")
[18:02:34.525]         }
[18:02:34.525]         else {
[18:02:34.525]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:34.525]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:34.525]         }
[18:02:34.525]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:34.525]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:34.525]             base::sink(type = "output", split = FALSE)
[18:02:34.525]             base::close(...future.stdout)
[18:02:34.525]         }, add = TRUE)
[18:02:34.525]     }
[18:02:34.525]     ...future.frame <- base::sys.nframe()
[18:02:34.525]     ...future.conditions <- base::list()
[18:02:34.525]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:34.525]     if (FALSE) {
[18:02:34.525]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:34.525]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:34.525]     }
[18:02:34.525]     ...future.result <- base::tryCatch({
[18:02:34.525]         base::withCallingHandlers({
[18:02:34.525]             ...future.value <- base::withVisible(base::local({
[18:02:34.525]                 ...future.makeSendCondition <- base::local({
[18:02:34.525]                   sendCondition <- NULL
[18:02:34.525]                   function(frame = 1L) {
[18:02:34.525]                     if (is.function(sendCondition)) 
[18:02:34.525]                       return(sendCondition)
[18:02:34.525]                     ns <- getNamespace("parallel")
[18:02:34.525]                     if (exists("sendData", mode = "function", 
[18:02:34.525]                       envir = ns)) {
[18:02:34.525]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:34.525]                         envir = ns)
[18:02:34.525]                       envir <- sys.frame(frame)
[18:02:34.525]                       master <- NULL
[18:02:34.525]                       while (!identical(envir, .GlobalEnv) && 
[18:02:34.525]                         !identical(envir, emptyenv())) {
[18:02:34.525]                         if (exists("master", mode = "list", envir = envir, 
[18:02:34.525]                           inherits = FALSE)) {
[18:02:34.525]                           master <- get("master", mode = "list", 
[18:02:34.525]                             envir = envir, inherits = FALSE)
[18:02:34.525]                           if (inherits(master, c("SOCKnode", 
[18:02:34.525]                             "SOCK0node"))) {
[18:02:34.525]                             sendCondition <<- function(cond) {
[18:02:34.525]                               data <- list(type = "VALUE", value = cond, 
[18:02:34.525]                                 success = TRUE)
[18:02:34.525]                               parallel_sendData(master, data)
[18:02:34.525]                             }
[18:02:34.525]                             return(sendCondition)
[18:02:34.525]                           }
[18:02:34.525]                         }
[18:02:34.525]                         frame <- frame + 1L
[18:02:34.525]                         envir <- sys.frame(frame)
[18:02:34.525]                       }
[18:02:34.525]                     }
[18:02:34.525]                     sendCondition <<- function(cond) NULL
[18:02:34.525]                   }
[18:02:34.525]                 })
[18:02:34.525]                 withCallingHandlers({
[18:02:34.525]                   {
[18:02:34.525]                     do.call(function(...) {
[18:02:34.525]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:34.525]                       if (!identical(...future.globals.maxSize.org, 
[18:02:34.525]                         ...future.globals.maxSize)) {
[18:02:34.525]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:34.525]                         on.exit(options(oopts), add = TRUE)
[18:02:34.525]                       }
[18:02:34.525]                       {
[18:02:34.525]                         lapply(seq_along(...future.elements_ii), 
[18:02:34.525]                           FUN = function(jj) {
[18:02:34.525]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:34.525]                             ...future.FUN(...future.X_jj, ...)
[18:02:34.525]                           })
[18:02:34.525]                       }
[18:02:34.525]                     }, args = future.call.arguments)
[18:02:34.525]                   }
[18:02:34.525]                 }, immediateCondition = function(cond) {
[18:02:34.525]                   sendCondition <- ...future.makeSendCondition()
[18:02:34.525]                   sendCondition(cond)
[18:02:34.525]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:34.525]                   {
[18:02:34.525]                     inherits <- base::inherits
[18:02:34.525]                     invokeRestart <- base::invokeRestart
[18:02:34.525]                     is.null <- base::is.null
[18:02:34.525]                     muffled <- FALSE
[18:02:34.525]                     if (inherits(cond, "message")) {
[18:02:34.525]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:34.525]                       if (muffled) 
[18:02:34.525]                         invokeRestart("muffleMessage")
[18:02:34.525]                     }
[18:02:34.525]                     else if (inherits(cond, "warning")) {
[18:02:34.525]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:34.525]                       if (muffled) 
[18:02:34.525]                         invokeRestart("muffleWarning")
[18:02:34.525]                     }
[18:02:34.525]                     else if (inherits(cond, "condition")) {
[18:02:34.525]                       if (!is.null(pattern)) {
[18:02:34.525]                         computeRestarts <- base::computeRestarts
[18:02:34.525]                         grepl <- base::grepl
[18:02:34.525]                         restarts <- computeRestarts(cond)
[18:02:34.525]                         for (restart in restarts) {
[18:02:34.525]                           name <- restart$name
[18:02:34.525]                           if (is.null(name)) 
[18:02:34.525]                             next
[18:02:34.525]                           if (!grepl(pattern, name)) 
[18:02:34.525]                             next
[18:02:34.525]                           invokeRestart(restart)
[18:02:34.525]                           muffled <- TRUE
[18:02:34.525]                           break
[18:02:34.525]                         }
[18:02:34.525]                       }
[18:02:34.525]                     }
[18:02:34.525]                     invisible(muffled)
[18:02:34.525]                   }
[18:02:34.525]                   muffleCondition(cond)
[18:02:34.525]                 })
[18:02:34.525]             }))
[18:02:34.525]             future::FutureResult(value = ...future.value$value, 
[18:02:34.525]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:34.525]                   ...future.rng), globalenv = if (FALSE) 
[18:02:34.525]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:34.525]                     ...future.globalenv.names))
[18:02:34.525]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:34.525]         }, condition = base::local({
[18:02:34.525]             c <- base::c
[18:02:34.525]             inherits <- base::inherits
[18:02:34.525]             invokeRestart <- base::invokeRestart
[18:02:34.525]             length <- base::length
[18:02:34.525]             list <- base::list
[18:02:34.525]             seq.int <- base::seq.int
[18:02:34.525]             signalCondition <- base::signalCondition
[18:02:34.525]             sys.calls <- base::sys.calls
[18:02:34.525]             `[[` <- base::`[[`
[18:02:34.525]             `+` <- base::`+`
[18:02:34.525]             `<<-` <- base::`<<-`
[18:02:34.525]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:34.525]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:34.525]                   3L)]
[18:02:34.525]             }
[18:02:34.525]             function(cond) {
[18:02:34.525]                 is_error <- inherits(cond, "error")
[18:02:34.525]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:34.525]                   NULL)
[18:02:34.525]                 if (is_error) {
[18:02:34.525]                   sessionInformation <- function() {
[18:02:34.525]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:34.525]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:34.525]                       search = base::search(), system = base::Sys.info())
[18:02:34.525]                   }
[18:02:34.525]                   ...future.conditions[[length(...future.conditions) + 
[18:02:34.525]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:34.525]                     cond$call), session = sessionInformation(), 
[18:02:34.525]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:34.525]                   signalCondition(cond)
[18:02:34.525]                 }
[18:02:34.525]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:34.525]                 "immediateCondition"))) {
[18:02:34.525]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:34.525]                   ...future.conditions[[length(...future.conditions) + 
[18:02:34.525]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:34.525]                   if (TRUE && !signal) {
[18:02:34.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:34.525]                     {
[18:02:34.525]                       inherits <- base::inherits
[18:02:34.525]                       invokeRestart <- base::invokeRestart
[18:02:34.525]                       is.null <- base::is.null
[18:02:34.525]                       muffled <- FALSE
[18:02:34.525]                       if (inherits(cond, "message")) {
[18:02:34.525]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:34.525]                         if (muffled) 
[18:02:34.525]                           invokeRestart("muffleMessage")
[18:02:34.525]                       }
[18:02:34.525]                       else if (inherits(cond, "warning")) {
[18:02:34.525]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:34.525]                         if (muffled) 
[18:02:34.525]                           invokeRestart("muffleWarning")
[18:02:34.525]                       }
[18:02:34.525]                       else if (inherits(cond, "condition")) {
[18:02:34.525]                         if (!is.null(pattern)) {
[18:02:34.525]                           computeRestarts <- base::computeRestarts
[18:02:34.525]                           grepl <- base::grepl
[18:02:34.525]                           restarts <- computeRestarts(cond)
[18:02:34.525]                           for (restart in restarts) {
[18:02:34.525]                             name <- restart$name
[18:02:34.525]                             if (is.null(name)) 
[18:02:34.525]                               next
[18:02:34.525]                             if (!grepl(pattern, name)) 
[18:02:34.525]                               next
[18:02:34.525]                             invokeRestart(restart)
[18:02:34.525]                             muffled <- TRUE
[18:02:34.525]                             break
[18:02:34.525]                           }
[18:02:34.525]                         }
[18:02:34.525]                       }
[18:02:34.525]                       invisible(muffled)
[18:02:34.525]                     }
[18:02:34.525]                     muffleCondition(cond, pattern = "^muffle")
[18:02:34.525]                   }
[18:02:34.525]                 }
[18:02:34.525]                 else {
[18:02:34.525]                   if (TRUE) {
[18:02:34.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:34.525]                     {
[18:02:34.525]                       inherits <- base::inherits
[18:02:34.525]                       invokeRestart <- base::invokeRestart
[18:02:34.525]                       is.null <- base::is.null
[18:02:34.525]                       muffled <- FALSE
[18:02:34.525]                       if (inherits(cond, "message")) {
[18:02:34.525]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:34.525]                         if (muffled) 
[18:02:34.525]                           invokeRestart("muffleMessage")
[18:02:34.525]                       }
[18:02:34.525]                       else if (inherits(cond, "warning")) {
[18:02:34.525]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:34.525]                         if (muffled) 
[18:02:34.525]                           invokeRestart("muffleWarning")
[18:02:34.525]                       }
[18:02:34.525]                       else if (inherits(cond, "condition")) {
[18:02:34.525]                         if (!is.null(pattern)) {
[18:02:34.525]                           computeRestarts <- base::computeRestarts
[18:02:34.525]                           grepl <- base::grepl
[18:02:34.525]                           restarts <- computeRestarts(cond)
[18:02:34.525]                           for (restart in restarts) {
[18:02:34.525]                             name <- restart$name
[18:02:34.525]                             if (is.null(name)) 
[18:02:34.525]                               next
[18:02:34.525]                             if (!grepl(pattern, name)) 
[18:02:34.525]                               next
[18:02:34.525]                             invokeRestart(restart)
[18:02:34.525]                             muffled <- TRUE
[18:02:34.525]                             break
[18:02:34.525]                           }
[18:02:34.525]                         }
[18:02:34.525]                       }
[18:02:34.525]                       invisible(muffled)
[18:02:34.525]                     }
[18:02:34.525]                     muffleCondition(cond, pattern = "^muffle")
[18:02:34.525]                   }
[18:02:34.525]                 }
[18:02:34.525]             }
[18:02:34.525]         }))
[18:02:34.525]     }, error = function(ex) {
[18:02:34.525]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:34.525]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:34.525]                 ...future.rng), started = ...future.startTime, 
[18:02:34.525]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:34.525]             version = "1.8"), class = "FutureResult")
[18:02:34.525]     }, finally = {
[18:02:34.525]         if (!identical(...future.workdir, getwd())) 
[18:02:34.525]             setwd(...future.workdir)
[18:02:34.525]         {
[18:02:34.525]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:34.525]                 ...future.oldOptions$nwarnings <- NULL
[18:02:34.525]             }
[18:02:34.525]             base::options(...future.oldOptions)
[18:02:34.525]             if (.Platform$OS.type == "windows") {
[18:02:34.525]                 old_names <- names(...future.oldEnvVars)
[18:02:34.525]                 envs <- base::Sys.getenv()
[18:02:34.525]                 names <- names(envs)
[18:02:34.525]                 common <- intersect(names, old_names)
[18:02:34.525]                 added <- setdiff(names, old_names)
[18:02:34.525]                 removed <- setdiff(old_names, names)
[18:02:34.525]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:34.525]                   envs[common]]
[18:02:34.525]                 NAMES <- toupper(changed)
[18:02:34.525]                 args <- list()
[18:02:34.525]                 for (kk in seq_along(NAMES)) {
[18:02:34.525]                   name <- changed[[kk]]
[18:02:34.525]                   NAME <- NAMES[[kk]]
[18:02:34.525]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:34.525]                     next
[18:02:34.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:34.525]                 }
[18:02:34.525]                 NAMES <- toupper(added)
[18:02:34.525]                 for (kk in seq_along(NAMES)) {
[18:02:34.525]                   name <- added[[kk]]
[18:02:34.525]                   NAME <- NAMES[[kk]]
[18:02:34.525]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:34.525]                     next
[18:02:34.525]                   args[[name]] <- ""
[18:02:34.525]                 }
[18:02:34.525]                 NAMES <- toupper(removed)
[18:02:34.525]                 for (kk in seq_along(NAMES)) {
[18:02:34.525]                   name <- removed[[kk]]
[18:02:34.525]                   NAME <- NAMES[[kk]]
[18:02:34.525]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:34.525]                     next
[18:02:34.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:34.525]                 }
[18:02:34.525]                 if (length(args) > 0) 
[18:02:34.525]                   base::do.call(base::Sys.setenv, args = args)
[18:02:34.525]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:34.525]             }
[18:02:34.525]             else {
[18:02:34.525]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:34.525]             }
[18:02:34.525]             {
[18:02:34.525]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:34.525]                   0L) {
[18:02:34.525]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:34.525]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:34.525]                   base::options(opts)
[18:02:34.525]                 }
[18:02:34.525]                 {
[18:02:34.525]                   {
[18:02:34.525]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:34.525]                     NULL
[18:02:34.525]                   }
[18:02:34.525]                   options(future.plan = NULL)
[18:02:34.525]                   if (is.na(NA_character_)) 
[18:02:34.525]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:34.525]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:34.525]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:34.525]                     .init = FALSE)
[18:02:34.525]                 }
[18:02:34.525]             }
[18:02:34.525]         }
[18:02:34.525]     })
[18:02:34.525]     if (TRUE) {
[18:02:34.525]         base::sink(type = "output", split = FALSE)
[18:02:34.525]         if (TRUE) {
[18:02:34.525]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:34.525]         }
[18:02:34.525]         else {
[18:02:34.525]             ...future.result["stdout"] <- base::list(NULL)
[18:02:34.525]         }
[18:02:34.525]         base::close(...future.stdout)
[18:02:34.525]         ...future.stdout <- NULL
[18:02:34.525]     }
[18:02:34.525]     ...future.result$conditions <- ...future.conditions
[18:02:34.525]     ...future.result$finished <- base::Sys.time()
[18:02:34.525]     ...future.result
[18:02:34.525] }
[18:02:34.530] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[18:02:34.531] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[18:02:34.531] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[18:02:34.532] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:34.533] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:34.533] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[18:02:34.534] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[18:02:34.534] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:34.535] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:34.536] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:34.536] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:34.537] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[18:02:34.538] MultisessionFuture started
[18:02:34.538] - Launch lazy future ... done
[18:02:34.538] run() for ‘MultisessionFuture’ ... done
[18:02:34.539] Created future:
[18:02:34.539] MultisessionFuture:
[18:02:34.539] Label: ‘future_lapply-1’
[18:02:34.539] Expression:
[18:02:34.539] {
[18:02:34.539]     do.call(function(...) {
[18:02:34.539]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:34.539]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:34.539]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:34.539]             on.exit(options(oopts), add = TRUE)
[18:02:34.539]         }
[18:02:34.539]         {
[18:02:34.539]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:34.539]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:34.539]                 ...future.FUN(...future.X_jj, ...)
[18:02:34.539]             })
[18:02:34.539]         }
[18:02:34.539]     }, args = future.call.arguments)
[18:02:34.539] }
[18:02:34.539] Lazy evaluation: FALSE
[18:02:34.539] Asynchronous evaluation: TRUE
[18:02:34.539] Local evaluation: TRUE
[18:02:34.539] Environment: R_GlobalEnv
[18:02:34.539] Capture standard output: TRUE
[18:02:34.539] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:34.539] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:34.539] Packages: <none>
[18:02:34.539] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:34.539] Resolved: FALSE
[18:02:34.539] Value: <not collected>
[18:02:34.539] Conditions captured: <none>
[18:02:34.539] Early signaling: FALSE
[18:02:34.539] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:34.539] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:34.552] Chunk #1 of 2 ... DONE
[18:02:34.552] Chunk #2 of 2 ...
[18:02:34.553]  - Finding globals in 'X' for chunk #2 ...
[18:02:34.553] getGlobalsAndPackages() ...
[18:02:34.553] Searching for globals...
[18:02:34.554] 
[18:02:34.554] Searching for globals ... DONE
[18:02:34.554] - globals: [0] <none>
[18:02:34.554] getGlobalsAndPackages() ... DONE
[18:02:34.555]    + additional globals found: [n=0] 
[18:02:34.555]    + additional namespaces needed: [n=0] 
[18:02:34.555]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:34.555]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:34.555]  - seeds: <none>
[18:02:34.556]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:34.556] getGlobalsAndPackages() ...
[18:02:34.556] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:34.556] Resolving globals: FALSE
[18:02:34.557] Tweak future expression to call with '...' arguments ...
[18:02:34.557] {
[18:02:34.557]     do.call(function(...) {
[18:02:34.557]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:34.557]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:34.557]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:34.557]             on.exit(options(oopts), add = TRUE)
[18:02:34.557]         }
[18:02:34.557]         {
[18:02:34.557]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:34.557]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:34.557]                 ...future.FUN(...future.X_jj, ...)
[18:02:34.557]             })
[18:02:34.557]         }
[18:02:34.557]     }, args = future.call.arguments)
[18:02:34.557] }
[18:02:34.557] Tweak future expression to call with '...' arguments ... DONE
[18:02:34.558] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:34.558] 
[18:02:34.559] getGlobalsAndPackages() ... DONE
[18:02:34.559] run() for ‘Future’ ...
[18:02:34.559] - state: ‘created’
[18:02:34.560] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:34.585] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:34.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:34.586]   - Field: ‘node’
[18:02:34.586]   - Field: ‘label’
[18:02:34.586]   - Field: ‘local’
[18:02:34.587]   - Field: ‘owner’
[18:02:34.587]   - Field: ‘envir’
[18:02:34.587]   - Field: ‘workers’
[18:02:34.587]   - Field: ‘packages’
[18:02:34.587]   - Field: ‘gc’
[18:02:34.588]   - Field: ‘conditions’
[18:02:34.588]   - Field: ‘persistent’
[18:02:34.588]   - Field: ‘expr’
[18:02:34.588]   - Field: ‘uuid’
[18:02:34.588]   - Field: ‘seed’
[18:02:34.589]   - Field: ‘version’
[18:02:34.589]   - Field: ‘result’
[18:02:34.589]   - Field: ‘asynchronous’
[18:02:34.589]   - Field: ‘calls’
[18:02:34.589]   - Field: ‘globals’
[18:02:34.590]   - Field: ‘stdout’
[18:02:34.590]   - Field: ‘earlySignal’
[18:02:34.590]   - Field: ‘lazy’
[18:02:34.590]   - Field: ‘state’
[18:02:34.590] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:34.591] - Launch lazy future ...
[18:02:34.591] Packages needed by the future expression (n = 0): <none>
[18:02:34.591] Packages needed by future strategies (n = 0): <none>
[18:02:34.592] {
[18:02:34.592]     {
[18:02:34.592]         {
[18:02:34.592]             ...future.startTime <- base::Sys.time()
[18:02:34.592]             {
[18:02:34.592]                 {
[18:02:34.592]                   {
[18:02:34.592]                     {
[18:02:34.592]                       base::local({
[18:02:34.592]                         has_future <- base::requireNamespace("future", 
[18:02:34.592]                           quietly = TRUE)
[18:02:34.592]                         if (has_future) {
[18:02:34.592]                           ns <- base::getNamespace("future")
[18:02:34.592]                           version <- ns[[".package"]][["version"]]
[18:02:34.592]                           if (is.null(version)) 
[18:02:34.592]                             version <- utils::packageVersion("future")
[18:02:34.592]                         }
[18:02:34.592]                         else {
[18:02:34.592]                           version <- NULL
[18:02:34.592]                         }
[18:02:34.592]                         if (!has_future || version < "1.8.0") {
[18:02:34.592]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:34.592]                             "", base::R.version$version.string), 
[18:02:34.592]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:34.592]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:34.592]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:34.592]                               "release", "version")], collapse = " "), 
[18:02:34.592]                             hostname = base::Sys.info()[["nodename"]])
[18:02:34.592]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:34.592]                             info)
[18:02:34.592]                           info <- base::paste(info, collapse = "; ")
[18:02:34.592]                           if (!has_future) {
[18:02:34.592]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:34.592]                               info)
[18:02:34.592]                           }
[18:02:34.592]                           else {
[18:02:34.592]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:34.592]                               info, version)
[18:02:34.592]                           }
[18:02:34.592]                           base::stop(msg)
[18:02:34.592]                         }
[18:02:34.592]                       })
[18:02:34.592]                     }
[18:02:34.592]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:34.592]                     base::options(mc.cores = 1L)
[18:02:34.592]                   }
[18:02:34.592]                   ...future.strategy.old <- future::plan("list")
[18:02:34.592]                   options(future.plan = NULL)
[18:02:34.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:34.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:34.592]                 }
[18:02:34.592]                 ...future.workdir <- getwd()
[18:02:34.592]             }
[18:02:34.592]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:34.592]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:34.592]         }
[18:02:34.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:34.592]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:34.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:34.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:34.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:34.592]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:34.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:34.592]             base::names(...future.oldOptions))
[18:02:34.592]     }
[18:02:34.592]     if (FALSE) {
[18:02:34.592]     }
[18:02:34.592]     else {
[18:02:34.592]         if (TRUE) {
[18:02:34.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:34.592]                 open = "w")
[18:02:34.592]         }
[18:02:34.592]         else {
[18:02:34.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:34.592]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:34.592]         }
[18:02:34.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:34.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:34.592]             base::sink(type = "output", split = FALSE)
[18:02:34.592]             base::close(...future.stdout)
[18:02:34.592]         }, add = TRUE)
[18:02:34.592]     }
[18:02:34.592]     ...future.frame <- base::sys.nframe()
[18:02:34.592]     ...future.conditions <- base::list()
[18:02:34.592]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:34.592]     if (FALSE) {
[18:02:34.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:34.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:34.592]     }
[18:02:34.592]     ...future.result <- base::tryCatch({
[18:02:34.592]         base::withCallingHandlers({
[18:02:34.592]             ...future.value <- base::withVisible(base::local({
[18:02:34.592]                 ...future.makeSendCondition <- base::local({
[18:02:34.592]                   sendCondition <- NULL
[18:02:34.592]                   function(frame = 1L) {
[18:02:34.592]                     if (is.function(sendCondition)) 
[18:02:34.592]                       return(sendCondition)
[18:02:34.592]                     ns <- getNamespace("parallel")
[18:02:34.592]                     if (exists("sendData", mode = "function", 
[18:02:34.592]                       envir = ns)) {
[18:02:34.592]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:34.592]                         envir = ns)
[18:02:34.592]                       envir <- sys.frame(frame)
[18:02:34.592]                       master <- NULL
[18:02:34.592]                       while (!identical(envir, .GlobalEnv) && 
[18:02:34.592]                         !identical(envir, emptyenv())) {
[18:02:34.592]                         if (exists("master", mode = "list", envir = envir, 
[18:02:34.592]                           inherits = FALSE)) {
[18:02:34.592]                           master <- get("master", mode = "list", 
[18:02:34.592]                             envir = envir, inherits = FALSE)
[18:02:34.592]                           if (inherits(master, c("SOCKnode", 
[18:02:34.592]                             "SOCK0node"))) {
[18:02:34.592]                             sendCondition <<- function(cond) {
[18:02:34.592]                               data <- list(type = "VALUE", value = cond, 
[18:02:34.592]                                 success = TRUE)
[18:02:34.592]                               parallel_sendData(master, data)
[18:02:34.592]                             }
[18:02:34.592]                             return(sendCondition)
[18:02:34.592]                           }
[18:02:34.592]                         }
[18:02:34.592]                         frame <- frame + 1L
[18:02:34.592]                         envir <- sys.frame(frame)
[18:02:34.592]                       }
[18:02:34.592]                     }
[18:02:34.592]                     sendCondition <<- function(cond) NULL
[18:02:34.592]                   }
[18:02:34.592]                 })
[18:02:34.592]                 withCallingHandlers({
[18:02:34.592]                   {
[18:02:34.592]                     do.call(function(...) {
[18:02:34.592]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:34.592]                       if (!identical(...future.globals.maxSize.org, 
[18:02:34.592]                         ...future.globals.maxSize)) {
[18:02:34.592]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:34.592]                         on.exit(options(oopts), add = TRUE)
[18:02:34.592]                       }
[18:02:34.592]                       {
[18:02:34.592]                         lapply(seq_along(...future.elements_ii), 
[18:02:34.592]                           FUN = function(jj) {
[18:02:34.592]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:34.592]                             ...future.FUN(...future.X_jj, ...)
[18:02:34.592]                           })
[18:02:34.592]                       }
[18:02:34.592]                     }, args = future.call.arguments)
[18:02:34.592]                   }
[18:02:34.592]                 }, immediateCondition = function(cond) {
[18:02:34.592]                   sendCondition <- ...future.makeSendCondition()
[18:02:34.592]                   sendCondition(cond)
[18:02:34.592]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:34.592]                   {
[18:02:34.592]                     inherits <- base::inherits
[18:02:34.592]                     invokeRestart <- base::invokeRestart
[18:02:34.592]                     is.null <- base::is.null
[18:02:34.592]                     muffled <- FALSE
[18:02:34.592]                     if (inherits(cond, "message")) {
[18:02:34.592]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:34.592]                       if (muffled) 
[18:02:34.592]                         invokeRestart("muffleMessage")
[18:02:34.592]                     }
[18:02:34.592]                     else if (inherits(cond, "warning")) {
[18:02:34.592]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:34.592]                       if (muffled) 
[18:02:34.592]                         invokeRestart("muffleWarning")
[18:02:34.592]                     }
[18:02:34.592]                     else if (inherits(cond, "condition")) {
[18:02:34.592]                       if (!is.null(pattern)) {
[18:02:34.592]                         computeRestarts <- base::computeRestarts
[18:02:34.592]                         grepl <- base::grepl
[18:02:34.592]                         restarts <- computeRestarts(cond)
[18:02:34.592]                         for (restart in restarts) {
[18:02:34.592]                           name <- restart$name
[18:02:34.592]                           if (is.null(name)) 
[18:02:34.592]                             next
[18:02:34.592]                           if (!grepl(pattern, name)) 
[18:02:34.592]                             next
[18:02:34.592]                           invokeRestart(restart)
[18:02:34.592]                           muffled <- TRUE
[18:02:34.592]                           break
[18:02:34.592]                         }
[18:02:34.592]                       }
[18:02:34.592]                     }
[18:02:34.592]                     invisible(muffled)
[18:02:34.592]                   }
[18:02:34.592]                   muffleCondition(cond)
[18:02:34.592]                 })
[18:02:34.592]             }))
[18:02:34.592]             future::FutureResult(value = ...future.value$value, 
[18:02:34.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:34.592]                   ...future.rng), globalenv = if (FALSE) 
[18:02:34.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:34.592]                     ...future.globalenv.names))
[18:02:34.592]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:34.592]         }, condition = base::local({
[18:02:34.592]             c <- base::c
[18:02:34.592]             inherits <- base::inherits
[18:02:34.592]             invokeRestart <- base::invokeRestart
[18:02:34.592]             length <- base::length
[18:02:34.592]             list <- base::list
[18:02:34.592]             seq.int <- base::seq.int
[18:02:34.592]             signalCondition <- base::signalCondition
[18:02:34.592]             sys.calls <- base::sys.calls
[18:02:34.592]             `[[` <- base::`[[`
[18:02:34.592]             `+` <- base::`+`
[18:02:34.592]             `<<-` <- base::`<<-`
[18:02:34.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:34.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:34.592]                   3L)]
[18:02:34.592]             }
[18:02:34.592]             function(cond) {
[18:02:34.592]                 is_error <- inherits(cond, "error")
[18:02:34.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:34.592]                   NULL)
[18:02:34.592]                 if (is_error) {
[18:02:34.592]                   sessionInformation <- function() {
[18:02:34.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:34.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:34.592]                       search = base::search(), system = base::Sys.info())
[18:02:34.592]                   }
[18:02:34.592]                   ...future.conditions[[length(...future.conditions) + 
[18:02:34.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:34.592]                     cond$call), session = sessionInformation(), 
[18:02:34.592]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:34.592]                   signalCondition(cond)
[18:02:34.592]                 }
[18:02:34.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:34.592]                 "immediateCondition"))) {
[18:02:34.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:34.592]                   ...future.conditions[[length(...future.conditions) + 
[18:02:34.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:34.592]                   if (TRUE && !signal) {
[18:02:34.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:34.592]                     {
[18:02:34.592]                       inherits <- base::inherits
[18:02:34.592]                       invokeRestart <- base::invokeRestart
[18:02:34.592]                       is.null <- base::is.null
[18:02:34.592]                       muffled <- FALSE
[18:02:34.592]                       if (inherits(cond, "message")) {
[18:02:34.592]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:34.592]                         if (muffled) 
[18:02:34.592]                           invokeRestart("muffleMessage")
[18:02:34.592]                       }
[18:02:34.592]                       else if (inherits(cond, "warning")) {
[18:02:34.592]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:34.592]                         if (muffled) 
[18:02:34.592]                           invokeRestart("muffleWarning")
[18:02:34.592]                       }
[18:02:34.592]                       else if (inherits(cond, "condition")) {
[18:02:34.592]                         if (!is.null(pattern)) {
[18:02:34.592]                           computeRestarts <- base::computeRestarts
[18:02:34.592]                           grepl <- base::grepl
[18:02:34.592]                           restarts <- computeRestarts(cond)
[18:02:34.592]                           for (restart in restarts) {
[18:02:34.592]                             name <- restart$name
[18:02:34.592]                             if (is.null(name)) 
[18:02:34.592]                               next
[18:02:34.592]                             if (!grepl(pattern, name)) 
[18:02:34.592]                               next
[18:02:34.592]                             invokeRestart(restart)
[18:02:34.592]                             muffled <- TRUE
[18:02:34.592]                             break
[18:02:34.592]                           }
[18:02:34.592]                         }
[18:02:34.592]                       }
[18:02:34.592]                       invisible(muffled)
[18:02:34.592]                     }
[18:02:34.592]                     muffleCondition(cond, pattern = "^muffle")
[18:02:34.592]                   }
[18:02:34.592]                 }
[18:02:34.592]                 else {
[18:02:34.592]                   if (TRUE) {
[18:02:34.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:34.592]                     {
[18:02:34.592]                       inherits <- base::inherits
[18:02:34.592]                       invokeRestart <- base::invokeRestart
[18:02:34.592]                       is.null <- base::is.null
[18:02:34.592]                       muffled <- FALSE
[18:02:34.592]                       if (inherits(cond, "message")) {
[18:02:34.592]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:34.592]                         if (muffled) 
[18:02:34.592]                           invokeRestart("muffleMessage")
[18:02:34.592]                       }
[18:02:34.592]                       else if (inherits(cond, "warning")) {
[18:02:34.592]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:34.592]                         if (muffled) 
[18:02:34.592]                           invokeRestart("muffleWarning")
[18:02:34.592]                       }
[18:02:34.592]                       else if (inherits(cond, "condition")) {
[18:02:34.592]                         if (!is.null(pattern)) {
[18:02:34.592]                           computeRestarts <- base::computeRestarts
[18:02:34.592]                           grepl <- base::grepl
[18:02:34.592]                           restarts <- computeRestarts(cond)
[18:02:34.592]                           for (restart in restarts) {
[18:02:34.592]                             name <- restart$name
[18:02:34.592]                             if (is.null(name)) 
[18:02:34.592]                               next
[18:02:34.592]                             if (!grepl(pattern, name)) 
[18:02:34.592]                               next
[18:02:34.592]                             invokeRestart(restart)
[18:02:34.592]                             muffled <- TRUE
[18:02:34.592]                             break
[18:02:34.592]                           }
[18:02:34.592]                         }
[18:02:34.592]                       }
[18:02:34.592]                       invisible(muffled)
[18:02:34.592]                     }
[18:02:34.592]                     muffleCondition(cond, pattern = "^muffle")
[18:02:34.592]                   }
[18:02:34.592]                 }
[18:02:34.592]             }
[18:02:34.592]         }))
[18:02:34.592]     }, error = function(ex) {
[18:02:34.592]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:34.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:34.592]                 ...future.rng), started = ...future.startTime, 
[18:02:34.592]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:34.592]             version = "1.8"), class = "FutureResult")
[18:02:34.592]     }, finally = {
[18:02:34.592]         if (!identical(...future.workdir, getwd())) 
[18:02:34.592]             setwd(...future.workdir)
[18:02:34.592]         {
[18:02:34.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:34.592]                 ...future.oldOptions$nwarnings <- NULL
[18:02:34.592]             }
[18:02:34.592]             base::options(...future.oldOptions)
[18:02:34.592]             if (.Platform$OS.type == "windows") {
[18:02:34.592]                 old_names <- names(...future.oldEnvVars)
[18:02:34.592]                 envs <- base::Sys.getenv()
[18:02:34.592]                 names <- names(envs)
[18:02:34.592]                 common <- intersect(names, old_names)
[18:02:34.592]                 added <- setdiff(names, old_names)
[18:02:34.592]                 removed <- setdiff(old_names, names)
[18:02:34.592]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:34.592]                   envs[common]]
[18:02:34.592]                 NAMES <- toupper(changed)
[18:02:34.592]                 args <- list()
[18:02:34.592]                 for (kk in seq_along(NAMES)) {
[18:02:34.592]                   name <- changed[[kk]]
[18:02:34.592]                   NAME <- NAMES[[kk]]
[18:02:34.592]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:34.592]                     next
[18:02:34.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:34.592]                 }
[18:02:34.592]                 NAMES <- toupper(added)
[18:02:34.592]                 for (kk in seq_along(NAMES)) {
[18:02:34.592]                   name <- added[[kk]]
[18:02:34.592]                   NAME <- NAMES[[kk]]
[18:02:34.592]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:34.592]                     next
[18:02:34.592]                   args[[name]] <- ""
[18:02:34.592]                 }
[18:02:34.592]                 NAMES <- toupper(removed)
[18:02:34.592]                 for (kk in seq_along(NAMES)) {
[18:02:34.592]                   name <- removed[[kk]]
[18:02:34.592]                   NAME <- NAMES[[kk]]
[18:02:34.592]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:34.592]                     next
[18:02:34.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:34.592]                 }
[18:02:34.592]                 if (length(args) > 0) 
[18:02:34.592]                   base::do.call(base::Sys.setenv, args = args)
[18:02:34.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:34.592]             }
[18:02:34.592]             else {
[18:02:34.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:34.592]             }
[18:02:34.592]             {
[18:02:34.592]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:34.592]                   0L) {
[18:02:34.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:34.592]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:34.592]                   base::options(opts)
[18:02:34.592]                 }
[18:02:34.592]                 {
[18:02:34.592]                   {
[18:02:34.592]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:34.592]                     NULL
[18:02:34.592]                   }
[18:02:34.592]                   options(future.plan = NULL)
[18:02:34.592]                   if (is.na(NA_character_)) 
[18:02:34.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:34.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:34.592]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:34.592]                     .init = FALSE)
[18:02:34.592]                 }
[18:02:34.592]             }
[18:02:34.592]         }
[18:02:34.592]     })
[18:02:34.592]     if (TRUE) {
[18:02:34.592]         base::sink(type = "output", split = FALSE)
[18:02:34.592]         if (TRUE) {
[18:02:34.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:34.592]         }
[18:02:34.592]         else {
[18:02:34.592]             ...future.result["stdout"] <- base::list(NULL)
[18:02:34.592]         }
[18:02:34.592]         base::close(...future.stdout)
[18:02:34.592]         ...future.stdout <- NULL
[18:02:34.592]     }
[18:02:34.592]     ...future.result$conditions <- ...future.conditions
[18:02:34.592]     ...future.result$finished <- base::Sys.time()
[18:02:34.592]     ...future.result
[18:02:34.592] }
[18:02:34.597] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[18:02:34.597] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[18:02:34.598] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[18:02:34.599] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:34.600] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:34.600] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[18:02:34.601] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[18:02:34.601] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:34.602] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:34.602] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:34.603] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:34.604] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[18:02:34.604] MultisessionFuture started
[18:02:34.605] - Launch lazy future ... done
[18:02:34.605] run() for ‘MultisessionFuture’ ... done
[18:02:34.606] Created future:
[18:02:34.606] MultisessionFuture:
[18:02:34.606] Label: ‘future_lapply-2’
[18:02:34.606] Expression:
[18:02:34.606] {
[18:02:34.606]     do.call(function(...) {
[18:02:34.606]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:34.606]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:34.606]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:34.606]             on.exit(options(oopts), add = TRUE)
[18:02:34.606]         }
[18:02:34.606]         {
[18:02:34.606]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:34.606]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:34.606]                 ...future.FUN(...future.X_jj, ...)
[18:02:34.606]             })
[18:02:34.606]         }
[18:02:34.606]     }, args = future.call.arguments)
[18:02:34.606] }
[18:02:34.606] Lazy evaluation: FALSE
[18:02:34.606] Asynchronous evaluation: TRUE
[18:02:34.606] Local evaluation: TRUE
[18:02:34.606] Environment: R_GlobalEnv
[18:02:34.606] Capture standard output: TRUE
[18:02:34.606] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:34.606] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:34.606] Packages: <none>
[18:02:34.606] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:34.606] Resolved: FALSE
[18:02:34.606] Value: <not collected>
[18:02:34.606] Conditions captured: <none>
[18:02:34.606] Early signaling: FALSE
[18:02:34.606] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:34.606] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:34.619] Chunk #2 of 2 ... DONE
[18:02:34.619] Launching 2 futures (chunks) ... DONE
[18:02:34.619] Resolving 2 futures (chunks) ...
[18:02:34.619] resolve() on list ...
[18:02:34.620]  recursive: 0
[18:02:34.620]  length: 2
[18:02:34.620] 
[18:02:34.665] receiveMessageFromWorker() for ClusterFuture ...
[18:02:34.665] - Validating connection of MultisessionFuture
[18:02:34.665] - received message: FutureResult
[18:02:34.666] - Received FutureResult
[18:02:34.666] - Erased future from FutureRegistry
[18:02:34.666] result() for ClusterFuture ...
[18:02:34.667] - result already collected: FutureResult
[18:02:34.667] result() for ClusterFuture ... done
[18:02:34.667] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:34.667] Future #2
[18:02:34.668] result() for ClusterFuture ...
[18:02:34.668] - result already collected: FutureResult
[18:02:34.668] result() for ClusterFuture ... done
[18:02:34.668] result() for ClusterFuture ...
[18:02:34.669] - result already collected: FutureResult
[18:02:34.669] result() for ClusterFuture ... done
[18:02:34.669] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:34.669] - nx: 2
[18:02:34.670] - relay: TRUE
[18:02:34.670] - stdout: TRUE
[18:02:34.670] - signal: TRUE
[18:02:34.670] - resignal: FALSE
[18:02:34.671] - force: TRUE
[18:02:34.671] - relayed: [n=2] FALSE, FALSE
[18:02:34.671] - queued futures: [n=2] FALSE, FALSE
[18:02:34.671]  - until=1
[18:02:34.672]  - relaying element #1
[18:02:34.672] - relayed: [n=2] FALSE, FALSE
[18:02:34.672] - queued futures: [n=2] FALSE, TRUE
[18:02:34.672] signalConditionsASAP(NULL, pos=2) ... done
[18:02:34.673]  length: 1 (resolved future 2)
[18:02:35.090] receiveMessageFromWorker() for ClusterFuture ...
[18:02:35.091] - Validating connection of MultisessionFuture
[18:02:35.091] - received message: FutureResult
[18:02:35.092] - Received FutureResult
[18:02:35.092] - Erased future from FutureRegistry
[18:02:35.092] result() for ClusterFuture ...
[18:02:35.093] - result already collected: FutureResult
[18:02:35.093] result() for ClusterFuture ... done
[18:02:35.093] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:35.094] Future #1
[18:02:35.094] result() for ClusterFuture ...
[18:02:35.094] - result already collected: FutureResult
[18:02:35.095] result() for ClusterFuture ... done
[18:02:35.095] result() for ClusterFuture ...
[18:02:35.095] - result already collected: FutureResult
[18:02:35.095] result() for ClusterFuture ... done
[18:02:35.096] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:35.096] - nx: 2
[18:02:35.096] - relay: TRUE
[18:02:35.097] - stdout: TRUE
[18:02:35.097] - signal: TRUE
[18:02:35.097] - resignal: FALSE
[18:02:35.098] - force: TRUE
[18:02:35.098] - relayed: [n=2] FALSE, FALSE
[18:02:35.098] - queued futures: [n=2] FALSE, TRUE
[18:02:35.099]  - until=1
[18:02:35.099]  - relaying element #1
[18:02:35.099] result() for ClusterFuture ...
[18:02:35.099] - result already collected: FutureResult
[18:02:35.100] result() for ClusterFuture ... done
[18:02:35.100] result() for ClusterFuture ...
[18:02:35.100] - result already collected: FutureResult
[18:02:35.101] result() for ClusterFuture ... done
[18:02:35.101] result() for ClusterFuture ...
[18:02:35.101] - result already collected: FutureResult
[18:02:35.102] result() for ClusterFuture ... done
[18:02:35.102] result() for ClusterFuture ...
[18:02:35.102] - result already collected: FutureResult
[18:02:35.103] result() for ClusterFuture ... done
[18:02:35.103] - relayed: [n=2] TRUE, FALSE
[18:02:35.103] - queued futures: [n=2] TRUE, TRUE
[18:02:35.103] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:35.104]  length: 0 (resolved future 1)
[18:02:35.104] Relaying remaining futures
[18:02:35.104] signalConditionsASAP(NULL, pos=0) ...
[18:02:35.105] - nx: 2
[18:02:35.105] - relay: TRUE
[18:02:35.105] - stdout: TRUE
[18:02:35.106] - signal: TRUE
[18:02:35.106] - resignal: FALSE
[18:02:35.106] - force: TRUE
[18:02:35.106] - relayed: [n=2] TRUE, FALSE
[18:02:35.107] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:35.107]  - relaying element #2
[18:02:35.108] result() for ClusterFuture ...
[18:02:35.108] - result already collected: FutureResult
[18:02:35.108] result() for ClusterFuture ... done
[18:02:35.108] result() for ClusterFuture ...
[18:02:35.109] - result already collected: FutureResult
[18:02:35.109] result() for ClusterFuture ... done
[18:02:35.110] result() for ClusterFuture ...
[18:02:35.110] - result already collected: FutureResult
[18:02:35.110] result() for ClusterFuture ... done
[18:02:35.110] result() for ClusterFuture ...
[18:02:35.111] - result already collected: FutureResult
[18:02:35.111] result() for ClusterFuture ... done
[18:02:35.111] - relayed: [n=2] TRUE, TRUE
[18:02:35.112] - queued futures: [n=2] TRUE, TRUE
[18:02:35.112] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[18:02:35.112] resolve() on list ... DONE
[18:02:35.113] result() for ClusterFuture ...
[18:02:35.113] - result already collected: FutureResult
[18:02:35.113] result() for ClusterFuture ... done
[18:02:35.113] result() for ClusterFuture ...
[18:02:35.114] - result already collected: FutureResult
[18:02:35.114] result() for ClusterFuture ... done
[18:02:35.114] result() for ClusterFuture ...
[18:02:35.118] - result already collected: FutureResult
[18:02:35.118] result() for ClusterFuture ... done
[18:02:35.119] result() for ClusterFuture ...
[18:02:35.119] - result already collected: FutureResult
[18:02:35.119] result() for ClusterFuture ... done
[18:02:35.120]  - Number of value chunks collected: 2
[18:02:35.120] Resolving 2 futures (chunks) ... DONE
[18:02:35.120] Reducing values from 2 chunks ...
[18:02:35.121]  - Number of values collected after concatenation: 2
[18:02:35.121]  - Number of values expected: 2
[18:02:35.121] Reducing values from 2 chunks ... DONE
[18:02:35.122] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[18:02:35.123] future_lapply() ...
[18:02:35.133] Number of chunks: 2
[18:02:35.134] getGlobalsAndPackagesXApply() ...
[18:02:35.134]  - future.globals: TRUE
[18:02:35.134] getGlobalsAndPackages() ...
[18:02:35.134] Searching for globals...
[18:02:35.139] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[18:02:35.139] Searching for globals ... DONE
[18:02:35.140] Resolving globals: FALSE
[18:02:35.141] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[18:02:35.142] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[18:02:35.142] - globals: [1] ‘FUN’
[18:02:35.143] 
[18:02:35.143] getGlobalsAndPackages() ... DONE
[18:02:35.143]  - globals found/used: [n=1] ‘FUN’
[18:02:35.144]  - needed namespaces: [n=0] 
[18:02:35.144] Finding globals ... DONE
[18:02:35.144]  - use_args: TRUE
[18:02:35.145]  - Getting '...' globals ...
[18:02:35.146] resolve() on list ...
[18:02:35.146]  recursive: 0
[18:02:35.146]  length: 1
[18:02:35.147]  elements: ‘...’
[18:02:35.147]  length: 0 (resolved future 1)
[18:02:35.147] resolve() on list ... DONE
[18:02:35.148]    - '...' content: [n=0] 
[18:02:35.148] List of 1
[18:02:35.148]  $ ...: list()
[18:02:35.148]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:35.148]  - attr(*, "where")=List of 1
[18:02:35.148]   ..$ ...:<environment: 0x5e4f85df6498> 
[18:02:35.148]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:35.148]  - attr(*, "resolved")= logi TRUE
[18:02:35.148]  - attr(*, "total_size")= num NA
[18:02:35.156]  - Getting '...' globals ... DONE
[18:02:35.156] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[18:02:35.157] List of 2
[18:02:35.157]  $ ...future.FUN:function (x)  
[18:02:35.157]  $ ...          : list()
[18:02:35.157]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[18:02:35.157]  - attr(*, "where")=List of 2
[18:02:35.157]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:35.157]   ..$ ...          :<environment: 0x5e4f85df6498> 
[18:02:35.157]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:35.157]  - attr(*, "resolved")= logi FALSE
[18:02:35.157]  - attr(*, "total_size")= num 4720
[18:02:35.164] Packages to be attached in all futures: [n=0] 
[18:02:35.165] getGlobalsAndPackagesXApply() ... DONE
[18:02:35.165] Number of futures (= number of chunks): 2
[18:02:35.166] Launching 2 futures (chunks) ...
[18:02:35.166] Chunk #1 of 2 ...
[18:02:35.166]  - Finding globals in 'X' for chunk #1 ...
[18:02:35.166] getGlobalsAndPackages() ...
[18:02:35.167] Searching for globals...
[18:02:35.167] 
[18:02:35.168] Searching for globals ... DONE
[18:02:35.168] - globals: [0] <none>
[18:02:35.168] getGlobalsAndPackages() ... DONE
[18:02:35.168]    + additional globals found: [n=0] 
[18:02:35.169]    + additional namespaces needed: [n=0] 
[18:02:35.169]  - Finding globals in 'X' for chunk #1 ... DONE
[18:02:35.169]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:35.169]  - seeds: <none>
[18:02:35.170]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:35.170] getGlobalsAndPackages() ...
[18:02:35.170] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:35.171] Resolving globals: FALSE
[18:02:35.171] Tweak future expression to call with '...' arguments ...
[18:02:35.171] {
[18:02:35.171]     do.call(function(...) {
[18:02:35.171]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:35.171]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:35.171]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:35.171]             on.exit(options(oopts), add = TRUE)
[18:02:35.171]         }
[18:02:35.171]         {
[18:02:35.171]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:35.171]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:35.171]                 ...future.FUN(...future.X_jj, ...)
[18:02:35.171]             })
[18:02:35.171]         }
[18:02:35.171]     }, args = future.call.arguments)
[18:02:35.171] }
[18:02:35.172] Tweak future expression to call with '...' arguments ... DONE
[18:02:35.173] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:35.173] 
[18:02:35.173] getGlobalsAndPackages() ... DONE
[18:02:35.174] run() for ‘Future’ ...
[18:02:35.174] - state: ‘created’
[18:02:35.175] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:35.205] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:35.205] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:35.206]   - Field: ‘node’
[18:02:35.206]   - Field: ‘label’
[18:02:35.206]   - Field: ‘local’
[18:02:35.206]   - Field: ‘owner’
[18:02:35.207]   - Field: ‘envir’
[18:02:35.207]   - Field: ‘workers’
[18:02:35.207]   - Field: ‘packages’
[18:02:35.207]   - Field: ‘gc’
[18:02:35.208]   - Field: ‘conditions’
[18:02:35.208]   - Field: ‘persistent’
[18:02:35.208]   - Field: ‘expr’
[18:02:35.208]   - Field: ‘uuid’
[18:02:35.208]   - Field: ‘seed’
[18:02:35.209]   - Field: ‘version’
[18:02:35.209]   - Field: ‘result’
[18:02:35.209]   - Field: ‘asynchronous’
[18:02:35.209]   - Field: ‘calls’
[18:02:35.210]   - Field: ‘globals’
[18:02:35.210]   - Field: ‘stdout’
[18:02:35.210]   - Field: ‘earlySignal’
[18:02:35.210]   - Field: ‘lazy’
[18:02:35.211]   - Field: ‘state’
[18:02:35.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:35.211] - Launch lazy future ...
[18:02:35.212] Packages needed by the future expression (n = 0): <none>
[18:02:35.212] Packages needed by future strategies (n = 0): <none>
[18:02:35.213] {
[18:02:35.213]     {
[18:02:35.213]         {
[18:02:35.213]             ...future.startTime <- base::Sys.time()
[18:02:35.213]             {
[18:02:35.213]                 {
[18:02:35.213]                   {
[18:02:35.213]                     {
[18:02:35.213]                       base::local({
[18:02:35.213]                         has_future <- base::requireNamespace("future", 
[18:02:35.213]                           quietly = TRUE)
[18:02:35.213]                         if (has_future) {
[18:02:35.213]                           ns <- base::getNamespace("future")
[18:02:35.213]                           version <- ns[[".package"]][["version"]]
[18:02:35.213]                           if (is.null(version)) 
[18:02:35.213]                             version <- utils::packageVersion("future")
[18:02:35.213]                         }
[18:02:35.213]                         else {
[18:02:35.213]                           version <- NULL
[18:02:35.213]                         }
[18:02:35.213]                         if (!has_future || version < "1.8.0") {
[18:02:35.213]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:35.213]                             "", base::R.version$version.string), 
[18:02:35.213]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:35.213]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:35.213]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:35.213]                               "release", "version")], collapse = " "), 
[18:02:35.213]                             hostname = base::Sys.info()[["nodename"]])
[18:02:35.213]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:35.213]                             info)
[18:02:35.213]                           info <- base::paste(info, collapse = "; ")
[18:02:35.213]                           if (!has_future) {
[18:02:35.213]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:35.213]                               info)
[18:02:35.213]                           }
[18:02:35.213]                           else {
[18:02:35.213]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:35.213]                               info, version)
[18:02:35.213]                           }
[18:02:35.213]                           base::stop(msg)
[18:02:35.213]                         }
[18:02:35.213]                       })
[18:02:35.213]                     }
[18:02:35.213]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:35.213]                     base::options(mc.cores = 1L)
[18:02:35.213]                   }
[18:02:35.213]                   ...future.strategy.old <- future::plan("list")
[18:02:35.213]                   options(future.plan = NULL)
[18:02:35.213]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:35.213]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:35.213]                 }
[18:02:35.213]                 ...future.workdir <- getwd()
[18:02:35.213]             }
[18:02:35.213]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:35.213]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:35.213]         }
[18:02:35.213]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:35.213]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:35.213]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:35.213]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:35.213]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:35.213]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:35.213]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:35.213]             base::names(...future.oldOptions))
[18:02:35.213]     }
[18:02:35.213]     if (TRUE) {
[18:02:35.213]     }
[18:02:35.213]     else {
[18:02:35.213]         if (NA) {
[18:02:35.213]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:35.213]                 open = "w")
[18:02:35.213]         }
[18:02:35.213]         else {
[18:02:35.213]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:35.213]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:35.213]         }
[18:02:35.213]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:35.213]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:35.213]             base::sink(type = "output", split = FALSE)
[18:02:35.213]             base::close(...future.stdout)
[18:02:35.213]         }, add = TRUE)
[18:02:35.213]     }
[18:02:35.213]     ...future.frame <- base::sys.nframe()
[18:02:35.213]     ...future.conditions <- base::list()
[18:02:35.213]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:35.213]     if (FALSE) {
[18:02:35.213]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:35.213]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:35.213]     }
[18:02:35.213]     ...future.result <- base::tryCatch({
[18:02:35.213]         base::withCallingHandlers({
[18:02:35.213]             ...future.value <- base::withVisible(base::local({
[18:02:35.213]                 ...future.makeSendCondition <- base::local({
[18:02:35.213]                   sendCondition <- NULL
[18:02:35.213]                   function(frame = 1L) {
[18:02:35.213]                     if (is.function(sendCondition)) 
[18:02:35.213]                       return(sendCondition)
[18:02:35.213]                     ns <- getNamespace("parallel")
[18:02:35.213]                     if (exists("sendData", mode = "function", 
[18:02:35.213]                       envir = ns)) {
[18:02:35.213]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:35.213]                         envir = ns)
[18:02:35.213]                       envir <- sys.frame(frame)
[18:02:35.213]                       master <- NULL
[18:02:35.213]                       while (!identical(envir, .GlobalEnv) && 
[18:02:35.213]                         !identical(envir, emptyenv())) {
[18:02:35.213]                         if (exists("master", mode = "list", envir = envir, 
[18:02:35.213]                           inherits = FALSE)) {
[18:02:35.213]                           master <- get("master", mode = "list", 
[18:02:35.213]                             envir = envir, inherits = FALSE)
[18:02:35.213]                           if (inherits(master, c("SOCKnode", 
[18:02:35.213]                             "SOCK0node"))) {
[18:02:35.213]                             sendCondition <<- function(cond) {
[18:02:35.213]                               data <- list(type = "VALUE", value = cond, 
[18:02:35.213]                                 success = TRUE)
[18:02:35.213]                               parallel_sendData(master, data)
[18:02:35.213]                             }
[18:02:35.213]                             return(sendCondition)
[18:02:35.213]                           }
[18:02:35.213]                         }
[18:02:35.213]                         frame <- frame + 1L
[18:02:35.213]                         envir <- sys.frame(frame)
[18:02:35.213]                       }
[18:02:35.213]                     }
[18:02:35.213]                     sendCondition <<- function(cond) NULL
[18:02:35.213]                   }
[18:02:35.213]                 })
[18:02:35.213]                 withCallingHandlers({
[18:02:35.213]                   {
[18:02:35.213]                     do.call(function(...) {
[18:02:35.213]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:35.213]                       if (!identical(...future.globals.maxSize.org, 
[18:02:35.213]                         ...future.globals.maxSize)) {
[18:02:35.213]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:35.213]                         on.exit(options(oopts), add = TRUE)
[18:02:35.213]                       }
[18:02:35.213]                       {
[18:02:35.213]                         lapply(seq_along(...future.elements_ii), 
[18:02:35.213]                           FUN = function(jj) {
[18:02:35.213]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:35.213]                             ...future.FUN(...future.X_jj, ...)
[18:02:35.213]                           })
[18:02:35.213]                       }
[18:02:35.213]                     }, args = future.call.arguments)
[18:02:35.213]                   }
[18:02:35.213]                 }, immediateCondition = function(cond) {
[18:02:35.213]                   sendCondition <- ...future.makeSendCondition()
[18:02:35.213]                   sendCondition(cond)
[18:02:35.213]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:35.213]                   {
[18:02:35.213]                     inherits <- base::inherits
[18:02:35.213]                     invokeRestart <- base::invokeRestart
[18:02:35.213]                     is.null <- base::is.null
[18:02:35.213]                     muffled <- FALSE
[18:02:35.213]                     if (inherits(cond, "message")) {
[18:02:35.213]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:35.213]                       if (muffled) 
[18:02:35.213]                         invokeRestart("muffleMessage")
[18:02:35.213]                     }
[18:02:35.213]                     else if (inherits(cond, "warning")) {
[18:02:35.213]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:35.213]                       if (muffled) 
[18:02:35.213]                         invokeRestart("muffleWarning")
[18:02:35.213]                     }
[18:02:35.213]                     else if (inherits(cond, "condition")) {
[18:02:35.213]                       if (!is.null(pattern)) {
[18:02:35.213]                         computeRestarts <- base::computeRestarts
[18:02:35.213]                         grepl <- base::grepl
[18:02:35.213]                         restarts <- computeRestarts(cond)
[18:02:35.213]                         for (restart in restarts) {
[18:02:35.213]                           name <- restart$name
[18:02:35.213]                           if (is.null(name)) 
[18:02:35.213]                             next
[18:02:35.213]                           if (!grepl(pattern, name)) 
[18:02:35.213]                             next
[18:02:35.213]                           invokeRestart(restart)
[18:02:35.213]                           muffled <- TRUE
[18:02:35.213]                           break
[18:02:35.213]                         }
[18:02:35.213]                       }
[18:02:35.213]                     }
[18:02:35.213]                     invisible(muffled)
[18:02:35.213]                   }
[18:02:35.213]                   muffleCondition(cond)
[18:02:35.213]                 })
[18:02:35.213]             }))
[18:02:35.213]             future::FutureResult(value = ...future.value$value, 
[18:02:35.213]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:35.213]                   ...future.rng), globalenv = if (FALSE) 
[18:02:35.213]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:35.213]                     ...future.globalenv.names))
[18:02:35.213]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:35.213]         }, condition = base::local({
[18:02:35.213]             c <- base::c
[18:02:35.213]             inherits <- base::inherits
[18:02:35.213]             invokeRestart <- base::invokeRestart
[18:02:35.213]             length <- base::length
[18:02:35.213]             list <- base::list
[18:02:35.213]             seq.int <- base::seq.int
[18:02:35.213]             signalCondition <- base::signalCondition
[18:02:35.213]             sys.calls <- base::sys.calls
[18:02:35.213]             `[[` <- base::`[[`
[18:02:35.213]             `+` <- base::`+`
[18:02:35.213]             `<<-` <- base::`<<-`
[18:02:35.213]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:35.213]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:35.213]                   3L)]
[18:02:35.213]             }
[18:02:35.213]             function(cond) {
[18:02:35.213]                 is_error <- inherits(cond, "error")
[18:02:35.213]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:35.213]                   NULL)
[18:02:35.213]                 if (is_error) {
[18:02:35.213]                   sessionInformation <- function() {
[18:02:35.213]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:35.213]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:35.213]                       search = base::search(), system = base::Sys.info())
[18:02:35.213]                   }
[18:02:35.213]                   ...future.conditions[[length(...future.conditions) + 
[18:02:35.213]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:35.213]                     cond$call), session = sessionInformation(), 
[18:02:35.213]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:35.213]                   signalCondition(cond)
[18:02:35.213]                 }
[18:02:35.213]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:35.213]                 "immediateCondition"))) {
[18:02:35.213]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:35.213]                   ...future.conditions[[length(...future.conditions) + 
[18:02:35.213]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:35.213]                   if (TRUE && !signal) {
[18:02:35.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:35.213]                     {
[18:02:35.213]                       inherits <- base::inherits
[18:02:35.213]                       invokeRestart <- base::invokeRestart
[18:02:35.213]                       is.null <- base::is.null
[18:02:35.213]                       muffled <- FALSE
[18:02:35.213]                       if (inherits(cond, "message")) {
[18:02:35.213]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:35.213]                         if (muffled) 
[18:02:35.213]                           invokeRestart("muffleMessage")
[18:02:35.213]                       }
[18:02:35.213]                       else if (inherits(cond, "warning")) {
[18:02:35.213]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:35.213]                         if (muffled) 
[18:02:35.213]                           invokeRestart("muffleWarning")
[18:02:35.213]                       }
[18:02:35.213]                       else if (inherits(cond, "condition")) {
[18:02:35.213]                         if (!is.null(pattern)) {
[18:02:35.213]                           computeRestarts <- base::computeRestarts
[18:02:35.213]                           grepl <- base::grepl
[18:02:35.213]                           restarts <- computeRestarts(cond)
[18:02:35.213]                           for (restart in restarts) {
[18:02:35.213]                             name <- restart$name
[18:02:35.213]                             if (is.null(name)) 
[18:02:35.213]                               next
[18:02:35.213]                             if (!grepl(pattern, name)) 
[18:02:35.213]                               next
[18:02:35.213]                             invokeRestart(restart)
[18:02:35.213]                             muffled <- TRUE
[18:02:35.213]                             break
[18:02:35.213]                           }
[18:02:35.213]                         }
[18:02:35.213]                       }
[18:02:35.213]                       invisible(muffled)
[18:02:35.213]                     }
[18:02:35.213]                     muffleCondition(cond, pattern = "^muffle")
[18:02:35.213]                   }
[18:02:35.213]                 }
[18:02:35.213]                 else {
[18:02:35.213]                   if (TRUE) {
[18:02:35.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:35.213]                     {
[18:02:35.213]                       inherits <- base::inherits
[18:02:35.213]                       invokeRestart <- base::invokeRestart
[18:02:35.213]                       is.null <- base::is.null
[18:02:35.213]                       muffled <- FALSE
[18:02:35.213]                       if (inherits(cond, "message")) {
[18:02:35.213]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:35.213]                         if (muffled) 
[18:02:35.213]                           invokeRestart("muffleMessage")
[18:02:35.213]                       }
[18:02:35.213]                       else if (inherits(cond, "warning")) {
[18:02:35.213]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:35.213]                         if (muffled) 
[18:02:35.213]                           invokeRestart("muffleWarning")
[18:02:35.213]                       }
[18:02:35.213]                       else if (inherits(cond, "condition")) {
[18:02:35.213]                         if (!is.null(pattern)) {
[18:02:35.213]                           computeRestarts <- base::computeRestarts
[18:02:35.213]                           grepl <- base::grepl
[18:02:35.213]                           restarts <- computeRestarts(cond)
[18:02:35.213]                           for (restart in restarts) {
[18:02:35.213]                             name <- restart$name
[18:02:35.213]                             if (is.null(name)) 
[18:02:35.213]                               next
[18:02:35.213]                             if (!grepl(pattern, name)) 
[18:02:35.213]                               next
[18:02:35.213]                             invokeRestart(restart)
[18:02:35.213]                             muffled <- TRUE
[18:02:35.213]                             break
[18:02:35.213]                           }
[18:02:35.213]                         }
[18:02:35.213]                       }
[18:02:35.213]                       invisible(muffled)
[18:02:35.213]                     }
[18:02:35.213]                     muffleCondition(cond, pattern = "^muffle")
[18:02:35.213]                   }
[18:02:35.213]                 }
[18:02:35.213]             }
[18:02:35.213]         }))
[18:02:35.213]     }, error = function(ex) {
[18:02:35.213]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:35.213]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:35.213]                 ...future.rng), started = ...future.startTime, 
[18:02:35.213]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:35.213]             version = "1.8"), class = "FutureResult")
[18:02:35.213]     }, finally = {
[18:02:35.213]         if (!identical(...future.workdir, getwd())) 
[18:02:35.213]             setwd(...future.workdir)
[18:02:35.213]         {
[18:02:35.213]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:35.213]                 ...future.oldOptions$nwarnings <- NULL
[18:02:35.213]             }
[18:02:35.213]             base::options(...future.oldOptions)
[18:02:35.213]             if (.Platform$OS.type == "windows") {
[18:02:35.213]                 old_names <- names(...future.oldEnvVars)
[18:02:35.213]                 envs <- base::Sys.getenv()
[18:02:35.213]                 names <- names(envs)
[18:02:35.213]                 common <- intersect(names, old_names)
[18:02:35.213]                 added <- setdiff(names, old_names)
[18:02:35.213]                 removed <- setdiff(old_names, names)
[18:02:35.213]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:35.213]                   envs[common]]
[18:02:35.213]                 NAMES <- toupper(changed)
[18:02:35.213]                 args <- list()
[18:02:35.213]                 for (kk in seq_along(NAMES)) {
[18:02:35.213]                   name <- changed[[kk]]
[18:02:35.213]                   NAME <- NAMES[[kk]]
[18:02:35.213]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:35.213]                     next
[18:02:35.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:35.213]                 }
[18:02:35.213]                 NAMES <- toupper(added)
[18:02:35.213]                 for (kk in seq_along(NAMES)) {
[18:02:35.213]                   name <- added[[kk]]
[18:02:35.213]                   NAME <- NAMES[[kk]]
[18:02:35.213]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:35.213]                     next
[18:02:35.213]                   args[[name]] <- ""
[18:02:35.213]                 }
[18:02:35.213]                 NAMES <- toupper(removed)
[18:02:35.213]                 for (kk in seq_along(NAMES)) {
[18:02:35.213]                   name <- removed[[kk]]
[18:02:35.213]                   NAME <- NAMES[[kk]]
[18:02:35.213]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:35.213]                     next
[18:02:35.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:35.213]                 }
[18:02:35.213]                 if (length(args) > 0) 
[18:02:35.213]                   base::do.call(base::Sys.setenv, args = args)
[18:02:35.213]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:35.213]             }
[18:02:35.213]             else {
[18:02:35.213]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:35.213]             }
[18:02:35.213]             {
[18:02:35.213]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:35.213]                   0L) {
[18:02:35.213]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:35.213]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:35.213]                   base::options(opts)
[18:02:35.213]                 }
[18:02:35.213]                 {
[18:02:35.213]                   {
[18:02:35.213]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:35.213]                     NULL
[18:02:35.213]                   }
[18:02:35.213]                   options(future.plan = NULL)
[18:02:35.213]                   if (is.na(NA_character_)) 
[18:02:35.213]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:35.213]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:35.213]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:35.213]                     .init = FALSE)
[18:02:35.213]                 }
[18:02:35.213]             }
[18:02:35.213]         }
[18:02:35.213]     })
[18:02:35.213]     if (FALSE) {
[18:02:35.213]         base::sink(type = "output", split = FALSE)
[18:02:35.213]         if (NA) {
[18:02:35.213]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:35.213]         }
[18:02:35.213]         else {
[18:02:35.213]             ...future.result["stdout"] <- base::list(NULL)
[18:02:35.213]         }
[18:02:35.213]         base::close(...future.stdout)
[18:02:35.213]         ...future.stdout <- NULL
[18:02:35.213]     }
[18:02:35.213]     ...future.result$conditions <- ...future.conditions
[18:02:35.213]     ...future.result$finished <- base::Sys.time()
[18:02:35.213]     ...future.result
[18:02:35.213] }
[18:02:35.219] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[18:02:35.219] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[18:02:35.220] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[18:02:35.220] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[18:02:35.221] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[18:02:35.222] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[18:02:35.223] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[18:02:35.223] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:35.224] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:35.224] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:35.225] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:35.225] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[18:02:35.227] MultisessionFuture started
[18:02:35.227] - Launch lazy future ... done
[18:02:35.227] run() for ‘MultisessionFuture’ ... done
[18:02:35.227] Created future:
[18:02:35.228] MultisessionFuture:
[18:02:35.228] Label: ‘future_lapply-1’
[18:02:35.228] Expression:
[18:02:35.228] {
[18:02:35.228]     do.call(function(...) {
[18:02:35.228]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:35.228]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:35.228]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:35.228]             on.exit(options(oopts), add = TRUE)
[18:02:35.228]         }
[18:02:35.228]         {
[18:02:35.228]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:35.228]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:35.228]                 ...future.FUN(...future.X_jj, ...)
[18:02:35.228]             })
[18:02:35.228]         }
[18:02:35.228]     }, args = future.call.arguments)
[18:02:35.228] }
[18:02:35.228] Lazy evaluation: FALSE
[18:02:35.228] Asynchronous evaluation: TRUE
[18:02:35.228] Local evaluation: TRUE
[18:02:35.228] Environment: R_GlobalEnv
[18:02:35.228] Capture standard output: NA
[18:02:35.228] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:35.228] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:35.228] Packages: <none>
[18:02:35.228] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:35.228] Resolved: FALSE
[18:02:35.228] Value: <not collected>
[18:02:35.228] Conditions captured: <none>
[18:02:35.228] Early signaling: FALSE
[18:02:35.228] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:35.228] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:35.241] Chunk #1 of 2 ... DONE
[18:02:35.241] Chunk #2 of 2 ...
[18:02:35.242]  - Finding globals in 'X' for chunk #2 ...
[18:02:35.242] getGlobalsAndPackages() ...
[18:02:35.242] Searching for globals...
[18:02:35.243] 
[18:02:35.243] Searching for globals ... DONE
[18:02:35.243] - globals: [0] <none>
[18:02:35.243] getGlobalsAndPackages() ... DONE
[18:02:35.244]    + additional globals found: [n=0] 
[18:02:35.244]    + additional namespaces needed: [n=0] 
[18:02:35.244]  - Finding globals in 'X' for chunk #2 ... DONE
[18:02:35.244]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:35.245]  - seeds: <none>
[18:02:35.245]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:35.245] getGlobalsAndPackages() ...
[18:02:35.245] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:35.246] Resolving globals: FALSE
[18:02:35.246] Tweak future expression to call with '...' arguments ...
[18:02:35.246] {
[18:02:35.246]     do.call(function(...) {
[18:02:35.246]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:35.246]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:35.246]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:35.246]             on.exit(options(oopts), add = TRUE)
[18:02:35.246]         }
[18:02:35.246]         {
[18:02:35.246]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:35.246]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:35.246]                 ...future.FUN(...future.X_jj, ...)
[18:02:35.246]             })
[18:02:35.246]         }
[18:02:35.246]     }, args = future.call.arguments)
[18:02:35.246] }
[18:02:35.247] Tweak future expression to call with '...' arguments ... DONE
[18:02:35.248] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:35.248] 
[18:02:35.248] getGlobalsAndPackages() ... DONE
[18:02:35.249] run() for ‘Future’ ...
[18:02:35.249] - state: ‘created’
[18:02:35.249] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:35.276] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:35.276] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:35.277]   - Field: ‘node’
[18:02:35.277]   - Field: ‘label’
[18:02:35.277]   - Field: ‘local’
[18:02:35.277]   - Field: ‘owner’
[18:02:35.277]   - Field: ‘envir’
[18:02:35.278]   - Field: ‘workers’
[18:02:35.278]   - Field: ‘packages’
[18:02:35.278]   - Field: ‘gc’
[18:02:35.278]   - Field: ‘conditions’
[18:02:35.278]   - Field: ‘persistent’
[18:02:35.279]   - Field: ‘expr’
[18:02:35.279]   - Field: ‘uuid’
[18:02:35.279]   - Field: ‘seed’
[18:02:35.279]   - Field: ‘version’
[18:02:35.279]   - Field: ‘result’
[18:02:35.280]   - Field: ‘asynchronous’
[18:02:35.280]   - Field: ‘calls’
[18:02:35.280]   - Field: ‘globals’
[18:02:35.280]   - Field: ‘stdout’
[18:02:35.280]   - Field: ‘earlySignal’
[18:02:35.281]   - Field: ‘lazy’
[18:02:35.281]   - Field: ‘state’
[18:02:35.281] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:35.281] - Launch lazy future ...
[18:02:35.282] Packages needed by the future expression (n = 0): <none>
[18:02:35.282] Packages needed by future strategies (n = 0): <none>
[18:02:35.283] {
[18:02:35.283]     {
[18:02:35.283]         {
[18:02:35.283]             ...future.startTime <- base::Sys.time()
[18:02:35.283]             {
[18:02:35.283]                 {
[18:02:35.283]                   {
[18:02:35.283]                     {
[18:02:35.283]                       base::local({
[18:02:35.283]                         has_future <- base::requireNamespace("future", 
[18:02:35.283]                           quietly = TRUE)
[18:02:35.283]                         if (has_future) {
[18:02:35.283]                           ns <- base::getNamespace("future")
[18:02:35.283]                           version <- ns[[".package"]][["version"]]
[18:02:35.283]                           if (is.null(version)) 
[18:02:35.283]                             version <- utils::packageVersion("future")
[18:02:35.283]                         }
[18:02:35.283]                         else {
[18:02:35.283]                           version <- NULL
[18:02:35.283]                         }
[18:02:35.283]                         if (!has_future || version < "1.8.0") {
[18:02:35.283]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:35.283]                             "", base::R.version$version.string), 
[18:02:35.283]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:35.283]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:35.283]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:35.283]                               "release", "version")], collapse = " "), 
[18:02:35.283]                             hostname = base::Sys.info()[["nodename"]])
[18:02:35.283]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:35.283]                             info)
[18:02:35.283]                           info <- base::paste(info, collapse = "; ")
[18:02:35.283]                           if (!has_future) {
[18:02:35.283]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:35.283]                               info)
[18:02:35.283]                           }
[18:02:35.283]                           else {
[18:02:35.283]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:35.283]                               info, version)
[18:02:35.283]                           }
[18:02:35.283]                           base::stop(msg)
[18:02:35.283]                         }
[18:02:35.283]                       })
[18:02:35.283]                     }
[18:02:35.283]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:35.283]                     base::options(mc.cores = 1L)
[18:02:35.283]                   }
[18:02:35.283]                   ...future.strategy.old <- future::plan("list")
[18:02:35.283]                   options(future.plan = NULL)
[18:02:35.283]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:35.283]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:35.283]                 }
[18:02:35.283]                 ...future.workdir <- getwd()
[18:02:35.283]             }
[18:02:35.283]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:35.283]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:35.283]         }
[18:02:35.283]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:35.283]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:35.283]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:35.283]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:35.283]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:35.283]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:35.283]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:35.283]             base::names(...future.oldOptions))
[18:02:35.283]     }
[18:02:35.283]     if (TRUE) {
[18:02:35.283]     }
[18:02:35.283]     else {
[18:02:35.283]         if (NA) {
[18:02:35.283]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:35.283]                 open = "w")
[18:02:35.283]         }
[18:02:35.283]         else {
[18:02:35.283]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:35.283]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:35.283]         }
[18:02:35.283]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:35.283]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:35.283]             base::sink(type = "output", split = FALSE)
[18:02:35.283]             base::close(...future.stdout)
[18:02:35.283]         }, add = TRUE)
[18:02:35.283]     }
[18:02:35.283]     ...future.frame <- base::sys.nframe()
[18:02:35.283]     ...future.conditions <- base::list()
[18:02:35.283]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:35.283]     if (FALSE) {
[18:02:35.283]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:35.283]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:35.283]     }
[18:02:35.283]     ...future.result <- base::tryCatch({
[18:02:35.283]         base::withCallingHandlers({
[18:02:35.283]             ...future.value <- base::withVisible(base::local({
[18:02:35.283]                 ...future.makeSendCondition <- base::local({
[18:02:35.283]                   sendCondition <- NULL
[18:02:35.283]                   function(frame = 1L) {
[18:02:35.283]                     if (is.function(sendCondition)) 
[18:02:35.283]                       return(sendCondition)
[18:02:35.283]                     ns <- getNamespace("parallel")
[18:02:35.283]                     if (exists("sendData", mode = "function", 
[18:02:35.283]                       envir = ns)) {
[18:02:35.283]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:35.283]                         envir = ns)
[18:02:35.283]                       envir <- sys.frame(frame)
[18:02:35.283]                       master <- NULL
[18:02:35.283]                       while (!identical(envir, .GlobalEnv) && 
[18:02:35.283]                         !identical(envir, emptyenv())) {
[18:02:35.283]                         if (exists("master", mode = "list", envir = envir, 
[18:02:35.283]                           inherits = FALSE)) {
[18:02:35.283]                           master <- get("master", mode = "list", 
[18:02:35.283]                             envir = envir, inherits = FALSE)
[18:02:35.283]                           if (inherits(master, c("SOCKnode", 
[18:02:35.283]                             "SOCK0node"))) {
[18:02:35.283]                             sendCondition <<- function(cond) {
[18:02:35.283]                               data <- list(type = "VALUE", value = cond, 
[18:02:35.283]                                 success = TRUE)
[18:02:35.283]                               parallel_sendData(master, data)
[18:02:35.283]                             }
[18:02:35.283]                             return(sendCondition)
[18:02:35.283]                           }
[18:02:35.283]                         }
[18:02:35.283]                         frame <- frame + 1L
[18:02:35.283]                         envir <- sys.frame(frame)
[18:02:35.283]                       }
[18:02:35.283]                     }
[18:02:35.283]                     sendCondition <<- function(cond) NULL
[18:02:35.283]                   }
[18:02:35.283]                 })
[18:02:35.283]                 withCallingHandlers({
[18:02:35.283]                   {
[18:02:35.283]                     do.call(function(...) {
[18:02:35.283]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:35.283]                       if (!identical(...future.globals.maxSize.org, 
[18:02:35.283]                         ...future.globals.maxSize)) {
[18:02:35.283]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:35.283]                         on.exit(options(oopts), add = TRUE)
[18:02:35.283]                       }
[18:02:35.283]                       {
[18:02:35.283]                         lapply(seq_along(...future.elements_ii), 
[18:02:35.283]                           FUN = function(jj) {
[18:02:35.283]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:35.283]                             ...future.FUN(...future.X_jj, ...)
[18:02:35.283]                           })
[18:02:35.283]                       }
[18:02:35.283]                     }, args = future.call.arguments)
[18:02:35.283]                   }
[18:02:35.283]                 }, immediateCondition = function(cond) {
[18:02:35.283]                   sendCondition <- ...future.makeSendCondition()
[18:02:35.283]                   sendCondition(cond)
[18:02:35.283]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:35.283]                   {
[18:02:35.283]                     inherits <- base::inherits
[18:02:35.283]                     invokeRestart <- base::invokeRestart
[18:02:35.283]                     is.null <- base::is.null
[18:02:35.283]                     muffled <- FALSE
[18:02:35.283]                     if (inherits(cond, "message")) {
[18:02:35.283]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:35.283]                       if (muffled) 
[18:02:35.283]                         invokeRestart("muffleMessage")
[18:02:35.283]                     }
[18:02:35.283]                     else if (inherits(cond, "warning")) {
[18:02:35.283]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:35.283]                       if (muffled) 
[18:02:35.283]                         invokeRestart("muffleWarning")
[18:02:35.283]                     }
[18:02:35.283]                     else if (inherits(cond, "condition")) {
[18:02:35.283]                       if (!is.null(pattern)) {
[18:02:35.283]                         computeRestarts <- base::computeRestarts
[18:02:35.283]                         grepl <- base::grepl
[18:02:35.283]                         restarts <- computeRestarts(cond)
[18:02:35.283]                         for (restart in restarts) {
[18:02:35.283]                           name <- restart$name
[18:02:35.283]                           if (is.null(name)) 
[18:02:35.283]                             next
[18:02:35.283]                           if (!grepl(pattern, name)) 
[18:02:35.283]                             next
[18:02:35.283]                           invokeRestart(restart)
[18:02:35.283]                           muffled <- TRUE
[18:02:35.283]                           break
[18:02:35.283]                         }
[18:02:35.283]                       }
[18:02:35.283]                     }
[18:02:35.283]                     invisible(muffled)
[18:02:35.283]                   }
[18:02:35.283]                   muffleCondition(cond)
[18:02:35.283]                 })
[18:02:35.283]             }))
[18:02:35.283]             future::FutureResult(value = ...future.value$value, 
[18:02:35.283]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:35.283]                   ...future.rng), globalenv = if (FALSE) 
[18:02:35.283]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:35.283]                     ...future.globalenv.names))
[18:02:35.283]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:35.283]         }, condition = base::local({
[18:02:35.283]             c <- base::c
[18:02:35.283]             inherits <- base::inherits
[18:02:35.283]             invokeRestart <- base::invokeRestart
[18:02:35.283]             length <- base::length
[18:02:35.283]             list <- base::list
[18:02:35.283]             seq.int <- base::seq.int
[18:02:35.283]             signalCondition <- base::signalCondition
[18:02:35.283]             sys.calls <- base::sys.calls
[18:02:35.283]             `[[` <- base::`[[`
[18:02:35.283]             `+` <- base::`+`
[18:02:35.283]             `<<-` <- base::`<<-`
[18:02:35.283]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:35.283]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:35.283]                   3L)]
[18:02:35.283]             }
[18:02:35.283]             function(cond) {
[18:02:35.283]                 is_error <- inherits(cond, "error")
[18:02:35.283]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:35.283]                   NULL)
[18:02:35.283]                 if (is_error) {
[18:02:35.283]                   sessionInformation <- function() {
[18:02:35.283]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:35.283]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:35.283]                       search = base::search(), system = base::Sys.info())
[18:02:35.283]                   }
[18:02:35.283]                   ...future.conditions[[length(...future.conditions) + 
[18:02:35.283]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:35.283]                     cond$call), session = sessionInformation(), 
[18:02:35.283]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:35.283]                   signalCondition(cond)
[18:02:35.283]                 }
[18:02:35.283]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:35.283]                 "immediateCondition"))) {
[18:02:35.283]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:35.283]                   ...future.conditions[[length(...future.conditions) + 
[18:02:35.283]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:35.283]                   if (TRUE && !signal) {
[18:02:35.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:35.283]                     {
[18:02:35.283]                       inherits <- base::inherits
[18:02:35.283]                       invokeRestart <- base::invokeRestart
[18:02:35.283]                       is.null <- base::is.null
[18:02:35.283]                       muffled <- FALSE
[18:02:35.283]                       if (inherits(cond, "message")) {
[18:02:35.283]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:35.283]                         if (muffled) 
[18:02:35.283]                           invokeRestart("muffleMessage")
[18:02:35.283]                       }
[18:02:35.283]                       else if (inherits(cond, "warning")) {
[18:02:35.283]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:35.283]                         if (muffled) 
[18:02:35.283]                           invokeRestart("muffleWarning")
[18:02:35.283]                       }
[18:02:35.283]                       else if (inherits(cond, "condition")) {
[18:02:35.283]                         if (!is.null(pattern)) {
[18:02:35.283]                           computeRestarts <- base::computeRestarts
[18:02:35.283]                           grepl <- base::grepl
[18:02:35.283]                           restarts <- computeRestarts(cond)
[18:02:35.283]                           for (restart in restarts) {
[18:02:35.283]                             name <- restart$name
[18:02:35.283]                             if (is.null(name)) 
[18:02:35.283]                               next
[18:02:35.283]                             if (!grepl(pattern, name)) 
[18:02:35.283]                               next
[18:02:35.283]                             invokeRestart(restart)
[18:02:35.283]                             muffled <- TRUE
[18:02:35.283]                             break
[18:02:35.283]                           }
[18:02:35.283]                         }
[18:02:35.283]                       }
[18:02:35.283]                       invisible(muffled)
[18:02:35.283]                     }
[18:02:35.283]                     muffleCondition(cond, pattern = "^muffle")
[18:02:35.283]                   }
[18:02:35.283]                 }
[18:02:35.283]                 else {
[18:02:35.283]                   if (TRUE) {
[18:02:35.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:35.283]                     {
[18:02:35.283]                       inherits <- base::inherits
[18:02:35.283]                       invokeRestart <- base::invokeRestart
[18:02:35.283]                       is.null <- base::is.null
[18:02:35.283]                       muffled <- FALSE
[18:02:35.283]                       if (inherits(cond, "message")) {
[18:02:35.283]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:35.283]                         if (muffled) 
[18:02:35.283]                           invokeRestart("muffleMessage")
[18:02:35.283]                       }
[18:02:35.283]                       else if (inherits(cond, "warning")) {
[18:02:35.283]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:35.283]                         if (muffled) 
[18:02:35.283]                           invokeRestart("muffleWarning")
[18:02:35.283]                       }
[18:02:35.283]                       else if (inherits(cond, "condition")) {
[18:02:35.283]                         if (!is.null(pattern)) {
[18:02:35.283]                           computeRestarts <- base::computeRestarts
[18:02:35.283]                           grepl <- base::grepl
[18:02:35.283]                           restarts <- computeRestarts(cond)
[18:02:35.283]                           for (restart in restarts) {
[18:02:35.283]                             name <- restart$name
[18:02:35.283]                             if (is.null(name)) 
[18:02:35.283]                               next
[18:02:35.283]                             if (!grepl(pattern, name)) 
[18:02:35.283]                               next
[18:02:35.283]                             invokeRestart(restart)
[18:02:35.283]                             muffled <- TRUE
[18:02:35.283]                             break
[18:02:35.283]                           }
[18:02:35.283]                         }
[18:02:35.283]                       }
[18:02:35.283]                       invisible(muffled)
[18:02:35.283]                     }
[18:02:35.283]                     muffleCondition(cond, pattern = "^muffle")
[18:02:35.283]                   }
[18:02:35.283]                 }
[18:02:35.283]             }
[18:02:35.283]         }))
[18:02:35.283]     }, error = function(ex) {
[18:02:35.283]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:35.283]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:35.283]                 ...future.rng), started = ...future.startTime, 
[18:02:35.283]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:35.283]             version = "1.8"), class = "FutureResult")
[18:02:35.283]     }, finally = {
[18:02:35.283]         if (!identical(...future.workdir, getwd())) 
[18:02:35.283]             setwd(...future.workdir)
[18:02:35.283]         {
[18:02:35.283]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:35.283]                 ...future.oldOptions$nwarnings <- NULL
[18:02:35.283]             }
[18:02:35.283]             base::options(...future.oldOptions)
[18:02:35.283]             if (.Platform$OS.type == "windows") {
[18:02:35.283]                 old_names <- names(...future.oldEnvVars)
[18:02:35.283]                 envs <- base::Sys.getenv()
[18:02:35.283]                 names <- names(envs)
[18:02:35.283]                 common <- intersect(names, old_names)
[18:02:35.283]                 added <- setdiff(names, old_names)
[18:02:35.283]                 removed <- setdiff(old_names, names)
[18:02:35.283]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:35.283]                   envs[common]]
[18:02:35.283]                 NAMES <- toupper(changed)
[18:02:35.283]                 args <- list()
[18:02:35.283]                 for (kk in seq_along(NAMES)) {
[18:02:35.283]                   name <- changed[[kk]]
[18:02:35.283]                   NAME <- NAMES[[kk]]
[18:02:35.283]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:35.283]                     next
[18:02:35.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:35.283]                 }
[18:02:35.283]                 NAMES <- toupper(added)
[18:02:35.283]                 for (kk in seq_along(NAMES)) {
[18:02:35.283]                   name <- added[[kk]]
[18:02:35.283]                   NAME <- NAMES[[kk]]
[18:02:35.283]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:35.283]                     next
[18:02:35.283]                   args[[name]] <- ""
[18:02:35.283]                 }
[18:02:35.283]                 NAMES <- toupper(removed)
[18:02:35.283]                 for (kk in seq_along(NAMES)) {
[18:02:35.283]                   name <- removed[[kk]]
[18:02:35.283]                   NAME <- NAMES[[kk]]
[18:02:35.283]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:35.283]                     next
[18:02:35.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:35.283]                 }
[18:02:35.283]                 if (length(args) > 0) 
[18:02:35.283]                   base::do.call(base::Sys.setenv, args = args)
[18:02:35.283]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:35.283]             }
[18:02:35.283]             else {
[18:02:35.283]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:35.283]             }
[18:02:35.283]             {
[18:02:35.283]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:35.283]                   0L) {
[18:02:35.283]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:35.283]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:35.283]                   base::options(opts)
[18:02:35.283]                 }
[18:02:35.283]                 {
[18:02:35.283]                   {
[18:02:35.283]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:35.283]                     NULL
[18:02:35.283]                   }
[18:02:35.283]                   options(future.plan = NULL)
[18:02:35.283]                   if (is.na(NA_character_)) 
[18:02:35.283]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:35.283]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:35.283]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:35.283]                     .init = FALSE)
[18:02:35.283]                 }
[18:02:35.283]             }
[18:02:35.283]         }
[18:02:35.283]     })
[18:02:35.283]     if (FALSE) {
[18:02:35.283]         base::sink(type = "output", split = FALSE)
[18:02:35.283]         if (NA) {
[18:02:35.283]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:35.283]         }
[18:02:35.283]         else {
[18:02:35.283]             ...future.result["stdout"] <- base::list(NULL)
[18:02:35.283]         }
[18:02:35.283]         base::close(...future.stdout)
[18:02:35.283]         ...future.stdout <- NULL
[18:02:35.283]     }
[18:02:35.283]     ...future.result$conditions <- ...future.conditions
[18:02:35.283]     ...future.result$finished <- base::Sys.time()
[18:02:35.283]     ...future.result
[18:02:35.283] }
[18:02:35.288] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[18:02:35.288] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[18:02:35.289] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[18:02:35.289] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[18:02:35.294] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[18:02:35.294] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[18:02:35.295] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[18:02:35.295] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:35.296] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:35.297] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:35.297] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:35.298] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[18:02:35.299] MultisessionFuture started
[18:02:35.299] - Launch lazy future ... done
[18:02:35.299] run() for ‘MultisessionFuture’ ... done
[18:02:35.299] Created future:
[18:02:35.300] MultisessionFuture:
[18:02:35.300] Label: ‘future_lapply-2’
[18:02:35.300] Expression:
[18:02:35.300] {
[18:02:35.300]     do.call(function(...) {
[18:02:35.300]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:35.300]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:35.300]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:35.300]             on.exit(options(oopts), add = TRUE)
[18:02:35.300]         }
[18:02:35.300]         {
[18:02:35.300]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[18:02:35.300]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[18:02:35.300]                 ...future.FUN(...future.X_jj, ...)
[18:02:35.300]             })
[18:02:35.300]         }
[18:02:35.300]     }, args = future.call.arguments)
[18:02:35.300] }
[18:02:35.300] Lazy evaluation: FALSE
[18:02:35.300] Asynchronous evaluation: TRUE
[18:02:35.300] Local evaluation: TRUE
[18:02:35.300] Environment: R_GlobalEnv
[18:02:35.300] Capture standard output: NA
[18:02:35.300] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:35.300] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:35.300] Packages: <none>
[18:02:35.300] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:35.300] Resolved: FALSE
[18:02:35.300] Value: <not collected>
[18:02:35.300] Conditions captured: <none>
[18:02:35.300] Early signaling: FALSE
[18:02:35.300] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:35.300] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:35.312] Chunk #2 of 2 ... DONE
[18:02:35.313] Launching 2 futures (chunks) ... DONE
[18:02:35.313] Resolving 2 futures (chunks) ...
[18:02:35.313] resolve() on list ...
[18:02:35.313]  recursive: 0
[18:02:35.313]  length: 2
[18:02:35.314] 
[18:02:35.358] receiveMessageFromWorker() for ClusterFuture ...
[18:02:35.359] - Validating connection of MultisessionFuture
[18:02:35.359] - received message: FutureResult
[18:02:35.359] - Received FutureResult
[18:02:35.360] - Erased future from FutureRegistry
[18:02:35.360] result() for ClusterFuture ...
[18:02:35.360] - result already collected: FutureResult
[18:02:35.360] result() for ClusterFuture ... done
[18:02:35.361] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:35.361] Future #2
[18:02:35.361] result() for ClusterFuture ...
[18:02:35.361] - result already collected: FutureResult
[18:02:35.362] result() for ClusterFuture ... done
[18:02:35.362] result() for ClusterFuture ...
[18:02:35.362] - result already collected: FutureResult
[18:02:35.362] result() for ClusterFuture ... done
[18:02:35.363] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:35.363] - nx: 2
[18:02:35.363] - relay: TRUE
[18:02:35.363] - stdout: TRUE
[18:02:35.363] - signal: TRUE
[18:02:35.364] - resignal: FALSE
[18:02:35.364] - force: TRUE
[18:02:35.364] - relayed: [n=2] FALSE, FALSE
[18:02:35.364] - queued futures: [n=2] FALSE, FALSE
[18:02:35.364]  - until=1
[18:02:35.365]  - relaying element #1
[18:02:35.365] - relayed: [n=2] FALSE, FALSE
[18:02:35.365] - queued futures: [n=2] FALSE, TRUE
[18:02:35.365] signalConditionsASAP(NULL, pos=2) ... done
[18:02:35.366]  length: 1 (resolved future 2)
[18:02:35.771] receiveMessageFromWorker() for ClusterFuture ...
[18:02:35.772] - Validating connection of MultisessionFuture
[18:02:35.772] - received message: FutureResult
[18:02:35.773] - Received FutureResult
[18:02:35.773] - Erased future from FutureRegistry
[18:02:35.774] result() for ClusterFuture ...
[18:02:35.774] - result already collected: FutureResult
[18:02:35.774] result() for ClusterFuture ... done
[18:02:35.774] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:35.775] Future #1
[18:02:35.775] result() for ClusterFuture ...
[18:02:35.775] - result already collected: FutureResult
[18:02:35.776] result() for ClusterFuture ... done
[18:02:35.776] result() for ClusterFuture ...
[18:02:35.776] - result already collected: FutureResult
[18:02:35.777] result() for ClusterFuture ... done
[18:02:35.777] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:35.777] - nx: 2
[18:02:35.778] - relay: TRUE
[18:02:35.778] - stdout: TRUE
[18:02:35.778] - signal: TRUE
[18:02:35.778] - resignal: FALSE
[18:02:35.779] - force: TRUE
[18:02:35.779] - relayed: [n=2] FALSE, FALSE
[18:02:35.779] - queued futures: [n=2] FALSE, TRUE
[18:02:35.780]  - until=1
[18:02:35.780]  - relaying element #1
[18:02:35.780] result() for ClusterFuture ...
[18:02:35.780] - result already collected: FutureResult
[18:02:35.781] result() for ClusterFuture ... done
[18:02:35.781] result() for ClusterFuture ...
[18:02:35.781] - result already collected: FutureResult
[18:02:35.782] result() for ClusterFuture ... done
[18:02:35.782] result() for ClusterFuture ...
[18:02:35.782] - result already collected: FutureResult
[18:02:35.783] result() for ClusterFuture ... done
[18:02:35.783] result() for ClusterFuture ...
[18:02:35.783] - result already collected: FutureResult
[18:02:35.784] result() for ClusterFuture ... done
[18:02:35.784] - relayed: [n=2] TRUE, FALSE
[18:02:35.784] - queued futures: [n=2] TRUE, TRUE
[18:02:35.784] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:35.785]  length: 0 (resolved future 1)
[18:02:35.785] Relaying remaining futures
[18:02:35.785] signalConditionsASAP(NULL, pos=0) ...
[18:02:35.786] - nx: 2
[18:02:35.786] - relay: TRUE
[18:02:35.786] - stdout: TRUE
[18:02:35.786] - signal: TRUE
[18:02:35.787] - resignal: FALSE
[18:02:35.787] - force: TRUE
[18:02:35.787] - relayed: [n=2] TRUE, FALSE
[18:02:35.788] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:35.788]  - relaying element #2
[18:02:35.788] result() for ClusterFuture ...
[18:02:35.789] - result already collected: FutureResult
[18:02:35.789] result() for ClusterFuture ... done
[18:02:35.789] result() for ClusterFuture ...
[18:02:35.790] - result already collected: FutureResult
[18:02:35.790] result() for ClusterFuture ... done
[18:02:35.790] result() for ClusterFuture ...
[18:02:35.791] - result already collected: FutureResult
[18:02:35.791] result() for ClusterFuture ... done
[18:02:35.791] result() for ClusterFuture ...
[18:02:35.791] - result already collected: FutureResult
[18:02:35.792] result() for ClusterFuture ... done
[18:02:35.792] - relayed: [n=2] TRUE, TRUE
[18:02:35.792] - queued futures: [n=2] TRUE, TRUE
[18:02:35.793] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[18:02:35.793] resolve() on list ... DONE
[18:02:35.793] result() for ClusterFuture ...
[18:02:35.794] - result already collected: FutureResult
[18:02:35.794] result() for ClusterFuture ... done
[18:02:35.794] result() for ClusterFuture ...
[18:02:35.794] - result already collected: FutureResult
[18:02:35.795] result() for ClusterFuture ... done
[18:02:35.795] result() for ClusterFuture ...
[18:02:35.795] - result already collected: FutureResult
[18:02:35.796] result() for ClusterFuture ... done
[18:02:35.796] result() for ClusterFuture ...
[18:02:35.796] - result already collected: FutureResult
[18:02:35.797] result() for ClusterFuture ... done
[18:02:35.797]  - Number of value chunks collected: 2
[18:02:35.797] Resolving 2 futures (chunks) ... DONE
[18:02:35.797] Reducing values from 2 chunks ...
[18:02:35.798]  - Number of values collected after concatenation: 2
[18:02:35.798]  - Number of values expected: 2
[18:02:35.798] Reducing values from 2 chunks ... DONE
[18:02:35.799] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[18:02:35.800] future_mapply() ...
[18:02:35.807] Number of chunks: 2
[18:02:35.807] getGlobalsAndPackagesXApply() ...
[18:02:35.807]  - future.globals: TRUE
[18:02:35.808] getGlobalsAndPackages() ...
[18:02:35.808] Searching for globals...
[18:02:35.811] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:35.812] Searching for globals ... DONE
[18:02:35.812] Resolving globals: FALSE
[18:02:35.813] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:35.814] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:35.814] - globals: [1] ‘FUN’
[18:02:35.814] 
[18:02:35.814] getGlobalsAndPackages() ... DONE
[18:02:35.814]  - globals found/used: [n=1] ‘FUN’
[18:02:35.815]  - needed namespaces: [n=0] 
[18:02:35.815] Finding globals ... DONE
[18:02:35.815] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:35.815] List of 2
[18:02:35.815]  $ ...future.FUN:function (x, y)  
[18:02:35.815]  $ MoreArgs     : NULL
[18:02:35.815]  - attr(*, "where")=List of 2
[18:02:35.815]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:35.815]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:35.815]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:35.815]  - attr(*, "resolved")= logi FALSE
[18:02:35.815]  - attr(*, "total_size")= num NA
[18:02:35.820] Packages to be attached in all futures: [n=0] 
[18:02:35.821] getGlobalsAndPackagesXApply() ... DONE
[18:02:35.821] Number of futures (= number of chunks): 2
[18:02:35.821] Launching 2 futures (chunks) ...
[18:02:35.821] Chunk #1 of 2 ...
[18:02:35.822]  - Finding globals in '...' for chunk #1 ...
[18:02:35.822] getGlobalsAndPackages() ...
[18:02:35.822] Searching for globals...
[18:02:35.823] 
[18:02:35.823] Searching for globals ... DONE
[18:02:35.823] - globals: [0] <none>
[18:02:35.823] getGlobalsAndPackages() ... DONE
[18:02:35.824]    + additional globals found: [n=0] 
[18:02:35.824]    + additional namespaces needed: [n=0] 
[18:02:35.824]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:35.824]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:35.824]  - seeds: <none>
[18:02:35.825]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:35.825] getGlobalsAndPackages() ...
[18:02:35.825] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:35.825] Resolving globals: FALSE
[18:02:35.826] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[18:02:35.827] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:35.827] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:35.828] 
[18:02:35.828] getGlobalsAndPackages() ... DONE
[18:02:35.828] run() for ‘Future’ ...
[18:02:35.829] - state: ‘created’
[18:02:35.829] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:35.856] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:35.856] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:35.856]   - Field: ‘node’
[18:02:35.857]   - Field: ‘label’
[18:02:35.857]   - Field: ‘local’
[18:02:35.857]   - Field: ‘owner’
[18:02:35.857]   - Field: ‘envir’
[18:02:35.858]   - Field: ‘workers’
[18:02:35.858]   - Field: ‘packages’
[18:02:35.858]   - Field: ‘gc’
[18:02:35.858]   - Field: ‘conditions’
[18:02:35.858]   - Field: ‘persistent’
[18:02:35.859]   - Field: ‘expr’
[18:02:35.859]   - Field: ‘uuid’
[18:02:35.859]   - Field: ‘seed’
[18:02:35.859]   - Field: ‘version’
[18:02:35.859]   - Field: ‘result’
[18:02:35.860]   - Field: ‘asynchronous’
[18:02:35.860]   - Field: ‘calls’
[18:02:35.860]   - Field: ‘globals’
[18:02:35.860]   - Field: ‘stdout’
[18:02:35.860]   - Field: ‘earlySignal’
[18:02:35.861]   - Field: ‘lazy’
[18:02:35.861]   - Field: ‘state’
[18:02:35.861] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:35.861] - Launch lazy future ...
[18:02:35.862] Packages needed by the future expression (n = 0): <none>
[18:02:35.862] Packages needed by future strategies (n = 0): <none>
[18:02:35.863] {
[18:02:35.863]     {
[18:02:35.863]         {
[18:02:35.863]             ...future.startTime <- base::Sys.time()
[18:02:35.863]             {
[18:02:35.863]                 {
[18:02:35.863]                   {
[18:02:35.863]                     {
[18:02:35.863]                       base::local({
[18:02:35.863]                         has_future <- base::requireNamespace("future", 
[18:02:35.863]                           quietly = TRUE)
[18:02:35.863]                         if (has_future) {
[18:02:35.863]                           ns <- base::getNamespace("future")
[18:02:35.863]                           version <- ns[[".package"]][["version"]]
[18:02:35.863]                           if (is.null(version)) 
[18:02:35.863]                             version <- utils::packageVersion("future")
[18:02:35.863]                         }
[18:02:35.863]                         else {
[18:02:35.863]                           version <- NULL
[18:02:35.863]                         }
[18:02:35.863]                         if (!has_future || version < "1.8.0") {
[18:02:35.863]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:35.863]                             "", base::R.version$version.string), 
[18:02:35.863]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:35.863]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:35.863]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:35.863]                               "release", "version")], collapse = " "), 
[18:02:35.863]                             hostname = base::Sys.info()[["nodename"]])
[18:02:35.863]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:35.863]                             info)
[18:02:35.863]                           info <- base::paste(info, collapse = "; ")
[18:02:35.863]                           if (!has_future) {
[18:02:35.863]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:35.863]                               info)
[18:02:35.863]                           }
[18:02:35.863]                           else {
[18:02:35.863]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:35.863]                               info, version)
[18:02:35.863]                           }
[18:02:35.863]                           base::stop(msg)
[18:02:35.863]                         }
[18:02:35.863]                       })
[18:02:35.863]                     }
[18:02:35.863]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:35.863]                     base::options(mc.cores = 1L)
[18:02:35.863]                   }
[18:02:35.863]                   ...future.strategy.old <- future::plan("list")
[18:02:35.863]                   options(future.plan = NULL)
[18:02:35.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:35.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:35.863]                 }
[18:02:35.863]                 ...future.workdir <- getwd()
[18:02:35.863]             }
[18:02:35.863]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:35.863]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:35.863]         }
[18:02:35.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:35.863]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:35.863]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:35.863]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:35.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:35.863]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:35.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:35.863]             base::names(...future.oldOptions))
[18:02:35.863]     }
[18:02:35.863]     if (FALSE) {
[18:02:35.863]     }
[18:02:35.863]     else {
[18:02:35.863]         if (FALSE) {
[18:02:35.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:35.863]                 open = "w")
[18:02:35.863]         }
[18:02:35.863]         else {
[18:02:35.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:35.863]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:35.863]         }
[18:02:35.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:35.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:35.863]             base::sink(type = "output", split = FALSE)
[18:02:35.863]             base::close(...future.stdout)
[18:02:35.863]         }, add = TRUE)
[18:02:35.863]     }
[18:02:35.863]     ...future.frame <- base::sys.nframe()
[18:02:35.863]     ...future.conditions <- base::list()
[18:02:35.863]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:35.863]     if (FALSE) {
[18:02:35.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:35.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:35.863]     }
[18:02:35.863]     ...future.result <- base::tryCatch({
[18:02:35.863]         base::withCallingHandlers({
[18:02:35.863]             ...future.value <- base::withVisible(base::local({
[18:02:35.863]                 ...future.makeSendCondition <- base::local({
[18:02:35.863]                   sendCondition <- NULL
[18:02:35.863]                   function(frame = 1L) {
[18:02:35.863]                     if (is.function(sendCondition)) 
[18:02:35.863]                       return(sendCondition)
[18:02:35.863]                     ns <- getNamespace("parallel")
[18:02:35.863]                     if (exists("sendData", mode = "function", 
[18:02:35.863]                       envir = ns)) {
[18:02:35.863]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:35.863]                         envir = ns)
[18:02:35.863]                       envir <- sys.frame(frame)
[18:02:35.863]                       master <- NULL
[18:02:35.863]                       while (!identical(envir, .GlobalEnv) && 
[18:02:35.863]                         !identical(envir, emptyenv())) {
[18:02:35.863]                         if (exists("master", mode = "list", envir = envir, 
[18:02:35.863]                           inherits = FALSE)) {
[18:02:35.863]                           master <- get("master", mode = "list", 
[18:02:35.863]                             envir = envir, inherits = FALSE)
[18:02:35.863]                           if (inherits(master, c("SOCKnode", 
[18:02:35.863]                             "SOCK0node"))) {
[18:02:35.863]                             sendCondition <<- function(cond) {
[18:02:35.863]                               data <- list(type = "VALUE", value = cond, 
[18:02:35.863]                                 success = TRUE)
[18:02:35.863]                               parallel_sendData(master, data)
[18:02:35.863]                             }
[18:02:35.863]                             return(sendCondition)
[18:02:35.863]                           }
[18:02:35.863]                         }
[18:02:35.863]                         frame <- frame + 1L
[18:02:35.863]                         envir <- sys.frame(frame)
[18:02:35.863]                       }
[18:02:35.863]                     }
[18:02:35.863]                     sendCondition <<- function(cond) NULL
[18:02:35.863]                   }
[18:02:35.863]                 })
[18:02:35.863]                 withCallingHandlers({
[18:02:35.863]                   {
[18:02:35.863]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:35.863]                     if (!identical(...future.globals.maxSize.org, 
[18:02:35.863]                       ...future.globals.maxSize)) {
[18:02:35.863]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:35.863]                       on.exit(options(oopts), add = TRUE)
[18:02:35.863]                     }
[18:02:35.863]                     {
[18:02:35.863]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:35.863]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:35.863]                         USE.NAMES = FALSE)
[18:02:35.863]                       do.call(mapply, args = args)
[18:02:35.863]                     }
[18:02:35.863]                   }
[18:02:35.863]                 }, immediateCondition = function(cond) {
[18:02:35.863]                   sendCondition <- ...future.makeSendCondition()
[18:02:35.863]                   sendCondition(cond)
[18:02:35.863]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:35.863]                   {
[18:02:35.863]                     inherits <- base::inherits
[18:02:35.863]                     invokeRestart <- base::invokeRestart
[18:02:35.863]                     is.null <- base::is.null
[18:02:35.863]                     muffled <- FALSE
[18:02:35.863]                     if (inherits(cond, "message")) {
[18:02:35.863]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:35.863]                       if (muffled) 
[18:02:35.863]                         invokeRestart("muffleMessage")
[18:02:35.863]                     }
[18:02:35.863]                     else if (inherits(cond, "warning")) {
[18:02:35.863]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:35.863]                       if (muffled) 
[18:02:35.863]                         invokeRestart("muffleWarning")
[18:02:35.863]                     }
[18:02:35.863]                     else if (inherits(cond, "condition")) {
[18:02:35.863]                       if (!is.null(pattern)) {
[18:02:35.863]                         computeRestarts <- base::computeRestarts
[18:02:35.863]                         grepl <- base::grepl
[18:02:35.863]                         restarts <- computeRestarts(cond)
[18:02:35.863]                         for (restart in restarts) {
[18:02:35.863]                           name <- restart$name
[18:02:35.863]                           if (is.null(name)) 
[18:02:35.863]                             next
[18:02:35.863]                           if (!grepl(pattern, name)) 
[18:02:35.863]                             next
[18:02:35.863]                           invokeRestart(restart)
[18:02:35.863]                           muffled <- TRUE
[18:02:35.863]                           break
[18:02:35.863]                         }
[18:02:35.863]                       }
[18:02:35.863]                     }
[18:02:35.863]                     invisible(muffled)
[18:02:35.863]                   }
[18:02:35.863]                   muffleCondition(cond)
[18:02:35.863]                 })
[18:02:35.863]             }))
[18:02:35.863]             future::FutureResult(value = ...future.value$value, 
[18:02:35.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:35.863]                   ...future.rng), globalenv = if (FALSE) 
[18:02:35.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:35.863]                     ...future.globalenv.names))
[18:02:35.863]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:35.863]         }, condition = base::local({
[18:02:35.863]             c <- base::c
[18:02:35.863]             inherits <- base::inherits
[18:02:35.863]             invokeRestart <- base::invokeRestart
[18:02:35.863]             length <- base::length
[18:02:35.863]             list <- base::list
[18:02:35.863]             seq.int <- base::seq.int
[18:02:35.863]             signalCondition <- base::signalCondition
[18:02:35.863]             sys.calls <- base::sys.calls
[18:02:35.863]             `[[` <- base::`[[`
[18:02:35.863]             `+` <- base::`+`
[18:02:35.863]             `<<-` <- base::`<<-`
[18:02:35.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:35.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:35.863]                   3L)]
[18:02:35.863]             }
[18:02:35.863]             function(cond) {
[18:02:35.863]                 is_error <- inherits(cond, "error")
[18:02:35.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:35.863]                   NULL)
[18:02:35.863]                 if (is_error) {
[18:02:35.863]                   sessionInformation <- function() {
[18:02:35.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:35.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:35.863]                       search = base::search(), system = base::Sys.info())
[18:02:35.863]                   }
[18:02:35.863]                   ...future.conditions[[length(...future.conditions) + 
[18:02:35.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:35.863]                     cond$call), session = sessionInformation(), 
[18:02:35.863]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:35.863]                   signalCondition(cond)
[18:02:35.863]                 }
[18:02:35.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:35.863]                 "immediateCondition"))) {
[18:02:35.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:35.863]                   ...future.conditions[[length(...future.conditions) + 
[18:02:35.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:35.863]                   if (TRUE && !signal) {
[18:02:35.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:35.863]                     {
[18:02:35.863]                       inherits <- base::inherits
[18:02:35.863]                       invokeRestart <- base::invokeRestart
[18:02:35.863]                       is.null <- base::is.null
[18:02:35.863]                       muffled <- FALSE
[18:02:35.863]                       if (inherits(cond, "message")) {
[18:02:35.863]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:35.863]                         if (muffled) 
[18:02:35.863]                           invokeRestart("muffleMessage")
[18:02:35.863]                       }
[18:02:35.863]                       else if (inherits(cond, "warning")) {
[18:02:35.863]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:35.863]                         if (muffled) 
[18:02:35.863]                           invokeRestart("muffleWarning")
[18:02:35.863]                       }
[18:02:35.863]                       else if (inherits(cond, "condition")) {
[18:02:35.863]                         if (!is.null(pattern)) {
[18:02:35.863]                           computeRestarts <- base::computeRestarts
[18:02:35.863]                           grepl <- base::grepl
[18:02:35.863]                           restarts <- computeRestarts(cond)
[18:02:35.863]                           for (restart in restarts) {
[18:02:35.863]                             name <- restart$name
[18:02:35.863]                             if (is.null(name)) 
[18:02:35.863]                               next
[18:02:35.863]                             if (!grepl(pattern, name)) 
[18:02:35.863]                               next
[18:02:35.863]                             invokeRestart(restart)
[18:02:35.863]                             muffled <- TRUE
[18:02:35.863]                             break
[18:02:35.863]                           }
[18:02:35.863]                         }
[18:02:35.863]                       }
[18:02:35.863]                       invisible(muffled)
[18:02:35.863]                     }
[18:02:35.863]                     muffleCondition(cond, pattern = "^muffle")
[18:02:35.863]                   }
[18:02:35.863]                 }
[18:02:35.863]                 else {
[18:02:35.863]                   if (TRUE) {
[18:02:35.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:35.863]                     {
[18:02:35.863]                       inherits <- base::inherits
[18:02:35.863]                       invokeRestart <- base::invokeRestart
[18:02:35.863]                       is.null <- base::is.null
[18:02:35.863]                       muffled <- FALSE
[18:02:35.863]                       if (inherits(cond, "message")) {
[18:02:35.863]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:35.863]                         if (muffled) 
[18:02:35.863]                           invokeRestart("muffleMessage")
[18:02:35.863]                       }
[18:02:35.863]                       else if (inherits(cond, "warning")) {
[18:02:35.863]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:35.863]                         if (muffled) 
[18:02:35.863]                           invokeRestart("muffleWarning")
[18:02:35.863]                       }
[18:02:35.863]                       else if (inherits(cond, "condition")) {
[18:02:35.863]                         if (!is.null(pattern)) {
[18:02:35.863]                           computeRestarts <- base::computeRestarts
[18:02:35.863]                           grepl <- base::grepl
[18:02:35.863]                           restarts <- computeRestarts(cond)
[18:02:35.863]                           for (restart in restarts) {
[18:02:35.863]                             name <- restart$name
[18:02:35.863]                             if (is.null(name)) 
[18:02:35.863]                               next
[18:02:35.863]                             if (!grepl(pattern, name)) 
[18:02:35.863]                               next
[18:02:35.863]                             invokeRestart(restart)
[18:02:35.863]                             muffled <- TRUE
[18:02:35.863]                             break
[18:02:35.863]                           }
[18:02:35.863]                         }
[18:02:35.863]                       }
[18:02:35.863]                       invisible(muffled)
[18:02:35.863]                     }
[18:02:35.863]                     muffleCondition(cond, pattern = "^muffle")
[18:02:35.863]                   }
[18:02:35.863]                 }
[18:02:35.863]             }
[18:02:35.863]         }))
[18:02:35.863]     }, error = function(ex) {
[18:02:35.863]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:35.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:35.863]                 ...future.rng), started = ...future.startTime, 
[18:02:35.863]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:35.863]             version = "1.8"), class = "FutureResult")
[18:02:35.863]     }, finally = {
[18:02:35.863]         if (!identical(...future.workdir, getwd())) 
[18:02:35.863]             setwd(...future.workdir)
[18:02:35.863]         {
[18:02:35.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:35.863]                 ...future.oldOptions$nwarnings <- NULL
[18:02:35.863]             }
[18:02:35.863]             base::options(...future.oldOptions)
[18:02:35.863]             if (.Platform$OS.type == "windows") {
[18:02:35.863]                 old_names <- names(...future.oldEnvVars)
[18:02:35.863]                 envs <- base::Sys.getenv()
[18:02:35.863]                 names <- names(envs)
[18:02:35.863]                 common <- intersect(names, old_names)
[18:02:35.863]                 added <- setdiff(names, old_names)
[18:02:35.863]                 removed <- setdiff(old_names, names)
[18:02:35.863]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:35.863]                   envs[common]]
[18:02:35.863]                 NAMES <- toupper(changed)
[18:02:35.863]                 args <- list()
[18:02:35.863]                 for (kk in seq_along(NAMES)) {
[18:02:35.863]                   name <- changed[[kk]]
[18:02:35.863]                   NAME <- NAMES[[kk]]
[18:02:35.863]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:35.863]                     next
[18:02:35.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:35.863]                 }
[18:02:35.863]                 NAMES <- toupper(added)
[18:02:35.863]                 for (kk in seq_along(NAMES)) {
[18:02:35.863]                   name <- added[[kk]]
[18:02:35.863]                   NAME <- NAMES[[kk]]
[18:02:35.863]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:35.863]                     next
[18:02:35.863]                   args[[name]] <- ""
[18:02:35.863]                 }
[18:02:35.863]                 NAMES <- toupper(removed)
[18:02:35.863]                 for (kk in seq_along(NAMES)) {
[18:02:35.863]                   name <- removed[[kk]]
[18:02:35.863]                   NAME <- NAMES[[kk]]
[18:02:35.863]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:35.863]                     next
[18:02:35.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:35.863]                 }
[18:02:35.863]                 if (length(args) > 0) 
[18:02:35.863]                   base::do.call(base::Sys.setenv, args = args)
[18:02:35.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:35.863]             }
[18:02:35.863]             else {
[18:02:35.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:35.863]             }
[18:02:35.863]             {
[18:02:35.863]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:35.863]                   0L) {
[18:02:35.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:35.863]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:35.863]                   base::options(opts)
[18:02:35.863]                 }
[18:02:35.863]                 {
[18:02:35.863]                   {
[18:02:35.863]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:35.863]                     NULL
[18:02:35.863]                   }
[18:02:35.863]                   options(future.plan = NULL)
[18:02:35.863]                   if (is.na(NA_character_)) 
[18:02:35.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:35.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:35.863]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:35.863]                     .init = FALSE)
[18:02:35.863]                 }
[18:02:35.863]             }
[18:02:35.863]         }
[18:02:35.863]     })
[18:02:35.863]     if (TRUE) {
[18:02:35.863]         base::sink(type = "output", split = FALSE)
[18:02:35.863]         if (FALSE) {
[18:02:35.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:35.863]         }
[18:02:35.863]         else {
[18:02:35.863]             ...future.result["stdout"] <- base::list(NULL)
[18:02:35.863]         }
[18:02:35.863]         base::close(...future.stdout)
[18:02:35.863]         ...future.stdout <- NULL
[18:02:35.863]     }
[18:02:35.863]     ...future.result$conditions <- ...future.conditions
[18:02:35.863]     ...future.result$finished <- base::Sys.time()
[18:02:35.863]     ...future.result
[18:02:35.863] }
[18:02:35.868] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[18:02:35.868] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[18:02:35.869] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[18:02:35.870] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:02:35.870] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:02:35.871] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[18:02:35.872] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[18:02:35.872] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:35.873] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:35.873] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:35.874] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:35.874] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[18:02:35.875] MultisessionFuture started
[18:02:35.875] - Launch lazy future ... done
[18:02:35.876] run() for ‘MultisessionFuture’ ... done
[18:02:35.876] Created future:
[18:02:35.876] MultisessionFuture:
[18:02:35.876] Label: ‘future_mapply-1’
[18:02:35.876] Expression:
[18:02:35.876] {
[18:02:35.876]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:35.876]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:35.876]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:35.876]         on.exit(options(oopts), add = TRUE)
[18:02:35.876]     }
[18:02:35.876]     {
[18:02:35.876]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:35.876]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:35.876]         do.call(mapply, args = args)
[18:02:35.876]     }
[18:02:35.876] }
[18:02:35.876] Lazy evaluation: FALSE
[18:02:35.876] Asynchronous evaluation: TRUE
[18:02:35.876] Local evaluation: TRUE
[18:02:35.876] Environment: R_GlobalEnv
[18:02:35.876] Capture standard output: FALSE
[18:02:35.876] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:35.876] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:35.876] Packages: <none>
[18:02:35.876] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:35.876] Resolved: FALSE
[18:02:35.876] Value: <not collected>
[18:02:35.876] Conditions captured: <none>
[18:02:35.876] Early signaling: FALSE
[18:02:35.876] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:35.876] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:35.889] Chunk #1 of 2 ... DONE
[18:02:35.889] Chunk #2 of 2 ...
[18:02:35.889]  - Finding globals in '...' for chunk #2 ...
[18:02:35.889] getGlobalsAndPackages() ...
[18:02:35.890] Searching for globals...
[18:02:35.890] 
[18:02:35.891] Searching for globals ... DONE
[18:02:35.891] - globals: [0] <none>
[18:02:35.891] getGlobalsAndPackages() ... DONE
[18:02:35.891]    + additional globals found: [n=0] 
[18:02:35.891]    + additional namespaces needed: [n=0] 
[18:02:35.891]  - Finding globals in '...' for chunk #2 ... DONE
[18:02:35.892]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:35.892]  - seeds: <none>
[18:02:35.892]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:35.892] getGlobalsAndPackages() ...
[18:02:35.892] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:35.893] Resolving globals: FALSE
[18:02:35.894] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[18:02:35.895] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:35.895] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:35.895] 
[18:02:35.895] getGlobalsAndPackages() ... DONE
[18:02:35.896] run() for ‘Future’ ...
[18:02:35.896] - state: ‘created’
[18:02:35.896] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:35.920] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:35.921] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:35.921]   - Field: ‘node’
[18:02:35.921]   - Field: ‘label’
[18:02:35.921]   - Field: ‘local’
[18:02:35.922]   - Field: ‘owner’
[18:02:35.922]   - Field: ‘envir’
[18:02:35.922]   - Field: ‘workers’
[18:02:35.922]   - Field: ‘packages’
[18:02:35.922]   - Field: ‘gc’
[18:02:35.923]   - Field: ‘conditions’
[18:02:35.923]   - Field: ‘persistent’
[18:02:35.923]   - Field: ‘expr’
[18:02:35.923]   - Field: ‘uuid’
[18:02:35.923]   - Field: ‘seed’
[18:02:35.923]   - Field: ‘version’
[18:02:35.924]   - Field: ‘result’
[18:02:35.924]   - Field: ‘asynchronous’
[18:02:35.924]   - Field: ‘calls’
[18:02:35.924]   - Field: ‘globals’
[18:02:35.924]   - Field: ‘stdout’
[18:02:35.925]   - Field: ‘earlySignal’
[18:02:35.925]   - Field: ‘lazy’
[18:02:35.925]   - Field: ‘state’
[18:02:35.925] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:35.925] - Launch lazy future ...
[18:02:35.926] Packages needed by the future expression (n = 0): <none>
[18:02:35.926] Packages needed by future strategies (n = 0): <none>
[18:02:35.927] {
[18:02:35.927]     {
[18:02:35.927]         {
[18:02:35.927]             ...future.startTime <- base::Sys.time()
[18:02:35.927]             {
[18:02:35.927]                 {
[18:02:35.927]                   {
[18:02:35.927]                     {
[18:02:35.927]                       base::local({
[18:02:35.927]                         has_future <- base::requireNamespace("future", 
[18:02:35.927]                           quietly = TRUE)
[18:02:35.927]                         if (has_future) {
[18:02:35.927]                           ns <- base::getNamespace("future")
[18:02:35.927]                           version <- ns[[".package"]][["version"]]
[18:02:35.927]                           if (is.null(version)) 
[18:02:35.927]                             version <- utils::packageVersion("future")
[18:02:35.927]                         }
[18:02:35.927]                         else {
[18:02:35.927]                           version <- NULL
[18:02:35.927]                         }
[18:02:35.927]                         if (!has_future || version < "1.8.0") {
[18:02:35.927]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:35.927]                             "", base::R.version$version.string), 
[18:02:35.927]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:35.927]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:35.927]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:35.927]                               "release", "version")], collapse = " "), 
[18:02:35.927]                             hostname = base::Sys.info()[["nodename"]])
[18:02:35.927]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:35.927]                             info)
[18:02:35.927]                           info <- base::paste(info, collapse = "; ")
[18:02:35.927]                           if (!has_future) {
[18:02:35.927]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:35.927]                               info)
[18:02:35.927]                           }
[18:02:35.927]                           else {
[18:02:35.927]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:35.927]                               info, version)
[18:02:35.927]                           }
[18:02:35.927]                           base::stop(msg)
[18:02:35.927]                         }
[18:02:35.927]                       })
[18:02:35.927]                     }
[18:02:35.927]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:35.927]                     base::options(mc.cores = 1L)
[18:02:35.927]                   }
[18:02:35.927]                   ...future.strategy.old <- future::plan("list")
[18:02:35.927]                   options(future.plan = NULL)
[18:02:35.927]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:35.927]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:35.927]                 }
[18:02:35.927]                 ...future.workdir <- getwd()
[18:02:35.927]             }
[18:02:35.927]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:35.927]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:35.927]         }
[18:02:35.927]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:35.927]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:35.927]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:35.927]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:35.927]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:35.927]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:35.927]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:35.927]             base::names(...future.oldOptions))
[18:02:35.927]     }
[18:02:35.927]     if (FALSE) {
[18:02:35.927]     }
[18:02:35.927]     else {
[18:02:35.927]         if (FALSE) {
[18:02:35.927]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:35.927]                 open = "w")
[18:02:35.927]         }
[18:02:35.927]         else {
[18:02:35.927]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:35.927]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:35.927]         }
[18:02:35.927]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:35.927]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:35.927]             base::sink(type = "output", split = FALSE)
[18:02:35.927]             base::close(...future.stdout)
[18:02:35.927]         }, add = TRUE)
[18:02:35.927]     }
[18:02:35.927]     ...future.frame <- base::sys.nframe()
[18:02:35.927]     ...future.conditions <- base::list()
[18:02:35.927]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:35.927]     if (FALSE) {
[18:02:35.927]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:35.927]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:35.927]     }
[18:02:35.927]     ...future.result <- base::tryCatch({
[18:02:35.927]         base::withCallingHandlers({
[18:02:35.927]             ...future.value <- base::withVisible(base::local({
[18:02:35.927]                 ...future.makeSendCondition <- base::local({
[18:02:35.927]                   sendCondition <- NULL
[18:02:35.927]                   function(frame = 1L) {
[18:02:35.927]                     if (is.function(sendCondition)) 
[18:02:35.927]                       return(sendCondition)
[18:02:35.927]                     ns <- getNamespace("parallel")
[18:02:35.927]                     if (exists("sendData", mode = "function", 
[18:02:35.927]                       envir = ns)) {
[18:02:35.927]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:35.927]                         envir = ns)
[18:02:35.927]                       envir <- sys.frame(frame)
[18:02:35.927]                       master <- NULL
[18:02:35.927]                       while (!identical(envir, .GlobalEnv) && 
[18:02:35.927]                         !identical(envir, emptyenv())) {
[18:02:35.927]                         if (exists("master", mode = "list", envir = envir, 
[18:02:35.927]                           inherits = FALSE)) {
[18:02:35.927]                           master <- get("master", mode = "list", 
[18:02:35.927]                             envir = envir, inherits = FALSE)
[18:02:35.927]                           if (inherits(master, c("SOCKnode", 
[18:02:35.927]                             "SOCK0node"))) {
[18:02:35.927]                             sendCondition <<- function(cond) {
[18:02:35.927]                               data <- list(type = "VALUE", value = cond, 
[18:02:35.927]                                 success = TRUE)
[18:02:35.927]                               parallel_sendData(master, data)
[18:02:35.927]                             }
[18:02:35.927]                             return(sendCondition)
[18:02:35.927]                           }
[18:02:35.927]                         }
[18:02:35.927]                         frame <- frame + 1L
[18:02:35.927]                         envir <- sys.frame(frame)
[18:02:35.927]                       }
[18:02:35.927]                     }
[18:02:35.927]                     sendCondition <<- function(cond) NULL
[18:02:35.927]                   }
[18:02:35.927]                 })
[18:02:35.927]                 withCallingHandlers({
[18:02:35.927]                   {
[18:02:35.927]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:35.927]                     if (!identical(...future.globals.maxSize.org, 
[18:02:35.927]                       ...future.globals.maxSize)) {
[18:02:35.927]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:35.927]                       on.exit(options(oopts), add = TRUE)
[18:02:35.927]                     }
[18:02:35.927]                     {
[18:02:35.927]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:35.927]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:35.927]                         USE.NAMES = FALSE)
[18:02:35.927]                       do.call(mapply, args = args)
[18:02:35.927]                     }
[18:02:35.927]                   }
[18:02:35.927]                 }, immediateCondition = function(cond) {
[18:02:35.927]                   sendCondition <- ...future.makeSendCondition()
[18:02:35.927]                   sendCondition(cond)
[18:02:35.927]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:35.927]                   {
[18:02:35.927]                     inherits <- base::inherits
[18:02:35.927]                     invokeRestart <- base::invokeRestart
[18:02:35.927]                     is.null <- base::is.null
[18:02:35.927]                     muffled <- FALSE
[18:02:35.927]                     if (inherits(cond, "message")) {
[18:02:35.927]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:35.927]                       if (muffled) 
[18:02:35.927]                         invokeRestart("muffleMessage")
[18:02:35.927]                     }
[18:02:35.927]                     else if (inherits(cond, "warning")) {
[18:02:35.927]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:35.927]                       if (muffled) 
[18:02:35.927]                         invokeRestart("muffleWarning")
[18:02:35.927]                     }
[18:02:35.927]                     else if (inherits(cond, "condition")) {
[18:02:35.927]                       if (!is.null(pattern)) {
[18:02:35.927]                         computeRestarts <- base::computeRestarts
[18:02:35.927]                         grepl <- base::grepl
[18:02:35.927]                         restarts <- computeRestarts(cond)
[18:02:35.927]                         for (restart in restarts) {
[18:02:35.927]                           name <- restart$name
[18:02:35.927]                           if (is.null(name)) 
[18:02:35.927]                             next
[18:02:35.927]                           if (!grepl(pattern, name)) 
[18:02:35.927]                             next
[18:02:35.927]                           invokeRestart(restart)
[18:02:35.927]                           muffled <- TRUE
[18:02:35.927]                           break
[18:02:35.927]                         }
[18:02:35.927]                       }
[18:02:35.927]                     }
[18:02:35.927]                     invisible(muffled)
[18:02:35.927]                   }
[18:02:35.927]                   muffleCondition(cond)
[18:02:35.927]                 })
[18:02:35.927]             }))
[18:02:35.927]             future::FutureResult(value = ...future.value$value, 
[18:02:35.927]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:35.927]                   ...future.rng), globalenv = if (FALSE) 
[18:02:35.927]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:35.927]                     ...future.globalenv.names))
[18:02:35.927]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:35.927]         }, condition = base::local({
[18:02:35.927]             c <- base::c
[18:02:35.927]             inherits <- base::inherits
[18:02:35.927]             invokeRestart <- base::invokeRestart
[18:02:35.927]             length <- base::length
[18:02:35.927]             list <- base::list
[18:02:35.927]             seq.int <- base::seq.int
[18:02:35.927]             signalCondition <- base::signalCondition
[18:02:35.927]             sys.calls <- base::sys.calls
[18:02:35.927]             `[[` <- base::`[[`
[18:02:35.927]             `+` <- base::`+`
[18:02:35.927]             `<<-` <- base::`<<-`
[18:02:35.927]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:35.927]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:35.927]                   3L)]
[18:02:35.927]             }
[18:02:35.927]             function(cond) {
[18:02:35.927]                 is_error <- inherits(cond, "error")
[18:02:35.927]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:35.927]                   NULL)
[18:02:35.927]                 if (is_error) {
[18:02:35.927]                   sessionInformation <- function() {
[18:02:35.927]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:35.927]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:35.927]                       search = base::search(), system = base::Sys.info())
[18:02:35.927]                   }
[18:02:35.927]                   ...future.conditions[[length(...future.conditions) + 
[18:02:35.927]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:35.927]                     cond$call), session = sessionInformation(), 
[18:02:35.927]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:35.927]                   signalCondition(cond)
[18:02:35.927]                 }
[18:02:35.927]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:35.927]                 "immediateCondition"))) {
[18:02:35.927]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:35.927]                   ...future.conditions[[length(...future.conditions) + 
[18:02:35.927]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:35.927]                   if (TRUE && !signal) {
[18:02:35.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:35.927]                     {
[18:02:35.927]                       inherits <- base::inherits
[18:02:35.927]                       invokeRestart <- base::invokeRestart
[18:02:35.927]                       is.null <- base::is.null
[18:02:35.927]                       muffled <- FALSE
[18:02:35.927]                       if (inherits(cond, "message")) {
[18:02:35.927]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:35.927]                         if (muffled) 
[18:02:35.927]                           invokeRestart("muffleMessage")
[18:02:35.927]                       }
[18:02:35.927]                       else if (inherits(cond, "warning")) {
[18:02:35.927]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:35.927]                         if (muffled) 
[18:02:35.927]                           invokeRestart("muffleWarning")
[18:02:35.927]                       }
[18:02:35.927]                       else if (inherits(cond, "condition")) {
[18:02:35.927]                         if (!is.null(pattern)) {
[18:02:35.927]                           computeRestarts <- base::computeRestarts
[18:02:35.927]                           grepl <- base::grepl
[18:02:35.927]                           restarts <- computeRestarts(cond)
[18:02:35.927]                           for (restart in restarts) {
[18:02:35.927]                             name <- restart$name
[18:02:35.927]                             if (is.null(name)) 
[18:02:35.927]                               next
[18:02:35.927]                             if (!grepl(pattern, name)) 
[18:02:35.927]                               next
[18:02:35.927]                             invokeRestart(restart)
[18:02:35.927]                             muffled <- TRUE
[18:02:35.927]                             break
[18:02:35.927]                           }
[18:02:35.927]                         }
[18:02:35.927]                       }
[18:02:35.927]                       invisible(muffled)
[18:02:35.927]                     }
[18:02:35.927]                     muffleCondition(cond, pattern = "^muffle")
[18:02:35.927]                   }
[18:02:35.927]                 }
[18:02:35.927]                 else {
[18:02:35.927]                   if (TRUE) {
[18:02:35.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:35.927]                     {
[18:02:35.927]                       inherits <- base::inherits
[18:02:35.927]                       invokeRestart <- base::invokeRestart
[18:02:35.927]                       is.null <- base::is.null
[18:02:35.927]                       muffled <- FALSE
[18:02:35.927]                       if (inherits(cond, "message")) {
[18:02:35.927]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:35.927]                         if (muffled) 
[18:02:35.927]                           invokeRestart("muffleMessage")
[18:02:35.927]                       }
[18:02:35.927]                       else if (inherits(cond, "warning")) {
[18:02:35.927]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:35.927]                         if (muffled) 
[18:02:35.927]                           invokeRestart("muffleWarning")
[18:02:35.927]                       }
[18:02:35.927]                       else if (inherits(cond, "condition")) {
[18:02:35.927]                         if (!is.null(pattern)) {
[18:02:35.927]                           computeRestarts <- base::computeRestarts
[18:02:35.927]                           grepl <- base::grepl
[18:02:35.927]                           restarts <- computeRestarts(cond)
[18:02:35.927]                           for (restart in restarts) {
[18:02:35.927]                             name <- restart$name
[18:02:35.927]                             if (is.null(name)) 
[18:02:35.927]                               next
[18:02:35.927]                             if (!grepl(pattern, name)) 
[18:02:35.927]                               next
[18:02:35.927]                             invokeRestart(restart)
[18:02:35.927]                             muffled <- TRUE
[18:02:35.927]                             break
[18:02:35.927]                           }
[18:02:35.927]                         }
[18:02:35.927]                       }
[18:02:35.927]                       invisible(muffled)
[18:02:35.927]                     }
[18:02:35.927]                     muffleCondition(cond, pattern = "^muffle")
[18:02:35.927]                   }
[18:02:35.927]                 }
[18:02:35.927]             }
[18:02:35.927]         }))
[18:02:35.927]     }, error = function(ex) {
[18:02:35.927]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:35.927]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:35.927]                 ...future.rng), started = ...future.startTime, 
[18:02:35.927]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:35.927]             version = "1.8"), class = "FutureResult")
[18:02:35.927]     }, finally = {
[18:02:35.927]         if (!identical(...future.workdir, getwd())) 
[18:02:35.927]             setwd(...future.workdir)
[18:02:35.927]         {
[18:02:35.927]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:35.927]                 ...future.oldOptions$nwarnings <- NULL
[18:02:35.927]             }
[18:02:35.927]             base::options(...future.oldOptions)
[18:02:35.927]             if (.Platform$OS.type == "windows") {
[18:02:35.927]                 old_names <- names(...future.oldEnvVars)
[18:02:35.927]                 envs <- base::Sys.getenv()
[18:02:35.927]                 names <- names(envs)
[18:02:35.927]                 common <- intersect(names, old_names)
[18:02:35.927]                 added <- setdiff(names, old_names)
[18:02:35.927]                 removed <- setdiff(old_names, names)
[18:02:35.927]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:35.927]                   envs[common]]
[18:02:35.927]                 NAMES <- toupper(changed)
[18:02:35.927]                 args <- list()
[18:02:35.927]                 for (kk in seq_along(NAMES)) {
[18:02:35.927]                   name <- changed[[kk]]
[18:02:35.927]                   NAME <- NAMES[[kk]]
[18:02:35.927]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:35.927]                     next
[18:02:35.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:35.927]                 }
[18:02:35.927]                 NAMES <- toupper(added)
[18:02:35.927]                 for (kk in seq_along(NAMES)) {
[18:02:35.927]                   name <- added[[kk]]
[18:02:35.927]                   NAME <- NAMES[[kk]]
[18:02:35.927]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:35.927]                     next
[18:02:35.927]                   args[[name]] <- ""
[18:02:35.927]                 }
[18:02:35.927]                 NAMES <- toupper(removed)
[18:02:35.927]                 for (kk in seq_along(NAMES)) {
[18:02:35.927]                   name <- removed[[kk]]
[18:02:35.927]                   NAME <- NAMES[[kk]]
[18:02:35.927]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:35.927]                     next
[18:02:35.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:35.927]                 }
[18:02:35.927]                 if (length(args) > 0) 
[18:02:35.927]                   base::do.call(base::Sys.setenv, args = args)
[18:02:35.927]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:35.927]             }
[18:02:35.927]             else {
[18:02:35.927]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:35.927]             }
[18:02:35.927]             {
[18:02:35.927]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:35.927]                   0L) {
[18:02:35.927]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:35.927]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:35.927]                   base::options(opts)
[18:02:35.927]                 }
[18:02:35.927]                 {
[18:02:35.927]                   {
[18:02:35.927]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:35.927]                     NULL
[18:02:35.927]                   }
[18:02:35.927]                   options(future.plan = NULL)
[18:02:35.927]                   if (is.na(NA_character_)) 
[18:02:35.927]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:35.927]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:35.927]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:35.927]                     .init = FALSE)
[18:02:35.927]                 }
[18:02:35.927]             }
[18:02:35.927]         }
[18:02:35.927]     })
[18:02:35.927]     if (TRUE) {
[18:02:35.927]         base::sink(type = "output", split = FALSE)
[18:02:35.927]         if (FALSE) {
[18:02:35.927]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:35.927]         }
[18:02:35.927]         else {
[18:02:35.927]             ...future.result["stdout"] <- base::list(NULL)
[18:02:35.927]         }
[18:02:35.927]         base::close(...future.stdout)
[18:02:35.927]         ...future.stdout <- NULL
[18:02:35.927]     }
[18:02:35.927]     ...future.result$conditions <- ...future.conditions
[18:02:35.927]     ...future.result$finished <- base::Sys.time()
[18:02:35.927]     ...future.result
[18:02:35.927] }
[18:02:35.932] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[18:02:35.932] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[18:02:35.933] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[18:02:35.934] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:02:35.934] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:02:35.935] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[18:02:35.936] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[18:02:35.936] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:35.937] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:35.937] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:35.938] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:35.938] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[18:02:35.939] MultisessionFuture started
[18:02:35.939] - Launch lazy future ... done
[18:02:35.939] run() for ‘MultisessionFuture’ ... done
[18:02:35.940] Created future:
[18:02:35.940] MultisessionFuture:
[18:02:35.940] Label: ‘future_mapply-2’
[18:02:35.940] Expression:
[18:02:35.940] {
[18:02:35.940]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:35.940]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:35.940]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:35.940]         on.exit(options(oopts), add = TRUE)
[18:02:35.940]     }
[18:02:35.940]     {
[18:02:35.940]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:35.940]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:35.940]         do.call(mapply, args = args)
[18:02:35.940]     }
[18:02:35.940] }
[18:02:35.940] Lazy evaluation: FALSE
[18:02:35.940] Asynchronous evaluation: TRUE
[18:02:35.940] Local evaluation: TRUE
[18:02:35.940] Environment: R_GlobalEnv
[18:02:35.940] Capture standard output: FALSE
[18:02:35.940] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:35.940] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:35.940] Packages: <none>
[18:02:35.940] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:35.940] Resolved: FALSE
[18:02:35.940] Value: <not collected>
[18:02:35.940] Conditions captured: <none>
[18:02:35.940] Early signaling: FALSE
[18:02:35.940] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:35.940] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:35.953] Chunk #2 of 2 ... DONE
[18:02:35.953] Launching 2 futures (chunks) ... DONE
[18:02:35.953] Resolving 2 futures (chunks) ...
[18:02:35.953] resolve() on list ...
[18:02:35.953]  recursive: 0
[18:02:35.954]  length: 2
[18:02:35.954] 
[18:02:35.998] receiveMessageFromWorker() for ClusterFuture ...
[18:02:35.998] - Validating connection of MultisessionFuture
[18:02:35.999] - received message: FutureResult
[18:02:35.999] - Received FutureResult
[18:02:35.999] - Erased future from FutureRegistry
[18:02:35.999] result() for ClusterFuture ...
[18:02:36.000] - result already collected: FutureResult
[18:02:36.000] result() for ClusterFuture ... done
[18:02:36.000] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:36.000] Future #2
[18:02:36.001] result() for ClusterFuture ...
[18:02:36.001] - result already collected: FutureResult
[18:02:36.001] result() for ClusterFuture ... done
[18:02:36.001] result() for ClusterFuture ...
[18:02:36.002] - result already collected: FutureResult
[18:02:36.002] result() for ClusterFuture ... done
[18:02:36.002] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:36.002] - nx: 2
[18:02:36.003] - relay: TRUE
[18:02:36.003] - stdout: TRUE
[18:02:36.003] - signal: TRUE
[18:02:36.003] - resignal: FALSE
[18:02:36.004] - force: TRUE
[18:02:36.004] - relayed: [n=2] FALSE, FALSE
[18:02:36.004] - queued futures: [n=2] FALSE, FALSE
[18:02:36.004]  - until=1
[18:02:36.005]  - relaying element #1
[18:02:36.005] - relayed: [n=2] FALSE, FALSE
[18:02:36.005] - queued futures: [n=2] FALSE, TRUE
[18:02:36.005] signalConditionsASAP(NULL, pos=2) ... done
[18:02:36.006]  length: 1 (resolved future 2)
[18:02:36.423] receiveMessageFromWorker() for ClusterFuture ...
[18:02:36.424] - Validating connection of MultisessionFuture
[18:02:36.424] - received message: FutureResult
[18:02:36.425] - Received FutureResult
[18:02:36.425] - Erased future from FutureRegistry
[18:02:36.425] result() for ClusterFuture ...
[18:02:36.426] - result already collected: FutureResult
[18:02:36.426] result() for ClusterFuture ... done
[18:02:36.426] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:36.427] Future #1
[18:02:36.427] result() for ClusterFuture ...
[18:02:36.427] - result already collected: FutureResult
[18:02:36.428] result() for ClusterFuture ... done
[18:02:36.428] result() for ClusterFuture ...
[18:02:36.428] - result already collected: FutureResult
[18:02:36.428] result() for ClusterFuture ... done
[18:02:36.429] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:36.429] - nx: 2
[18:02:36.429] - relay: TRUE
[18:02:36.430] - stdout: TRUE
[18:02:36.430] - signal: TRUE
[18:02:36.430] - resignal: FALSE
[18:02:36.431] - force: TRUE
[18:02:36.431] - relayed: [n=2] FALSE, FALSE
[18:02:36.431] - queued futures: [n=2] FALSE, TRUE
[18:02:36.431]  - until=1
[18:02:36.432]  - relaying element #1
[18:02:36.432] result() for ClusterFuture ...
[18:02:36.432] - result already collected: FutureResult
[18:02:36.433] result() for ClusterFuture ... done
[18:02:36.433] result() for ClusterFuture ...
[18:02:36.433] - result already collected: FutureResult
[18:02:36.434] result() for ClusterFuture ... done
[18:02:36.434] result() for ClusterFuture ...
[18:02:36.434] - result already collected: FutureResult
[18:02:36.434] result() for ClusterFuture ... done
[18:02:36.435] result() for ClusterFuture ...
[18:02:36.435] - result already collected: FutureResult
[18:02:36.435] result() for ClusterFuture ... done
[18:02:36.436] - relayed: [n=2] TRUE, FALSE
[18:02:36.436] - queued futures: [n=2] TRUE, TRUE
[18:02:36.436] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:36.437]  length: 0 (resolved future 1)
[18:02:36.437] Relaying remaining futures
[18:02:36.437] signalConditionsASAP(NULL, pos=0) ...
[18:02:36.437] - nx: 2
[18:02:36.438] - relay: TRUE
[18:02:36.438] - stdout: TRUE
[18:02:36.438] - signal: TRUE
[18:02:36.439] - resignal: FALSE
[18:02:36.439] - force: TRUE
[18:02:36.439] - relayed: [n=2] TRUE, FALSE
[18:02:36.439] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:36.440]  - relaying element #2
[18:02:36.440] result() for ClusterFuture ...
[18:02:36.441] - result already collected: FutureResult
[18:02:36.441] result() for ClusterFuture ... done
[18:02:36.441] result() for ClusterFuture ...
[18:02:36.441] - result already collected: FutureResult
[18:02:36.442] result() for ClusterFuture ... done
[18:02:36.442] result() for ClusterFuture ...
[18:02:36.442] - result already collected: FutureResult
[18:02:36.443] result() for ClusterFuture ... done
[18:02:36.443] result() for ClusterFuture ...
[18:02:36.443] - result already collected: FutureResult
[18:02:36.444] result() for ClusterFuture ... done
[18:02:36.444] - relayed: [n=2] TRUE, TRUE
[18:02:36.444] - queued futures: [n=2] TRUE, TRUE
[18:02:36.445] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[18:02:36.445] resolve() on list ... DONE
[18:02:36.445] result() for ClusterFuture ...
[18:02:36.445] - result already collected: FutureResult
[18:02:36.446] result() for ClusterFuture ... done
[18:02:36.446] result() for ClusterFuture ...
[18:02:36.446] - result already collected: FutureResult
[18:02:36.447] result() for ClusterFuture ... done
[18:02:36.447] result() for ClusterFuture ...
[18:02:36.447] - result already collected: FutureResult
[18:02:36.448] result() for ClusterFuture ... done
[18:02:36.448] result() for ClusterFuture ...
[18:02:36.448] - result already collected: FutureResult
[18:02:36.448] result() for ClusterFuture ... done
[18:02:36.449]  - Number of value chunks collected: 2
[18:02:36.449] Resolving 2 futures (chunks) ... DONE
[18:02:36.449] Reducing values from 2 chunks ...
[18:02:36.450]  - Number of values collected after concatenation: 2
[18:02:36.450]  - Number of values expected: 2
[18:02:36.450] Reducing values from 2 chunks ... DONE
[18:02:36.451] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[18:02:36.452] future_mapply() ...
[18:02:36.460] Number of chunks: 2
[18:02:36.460] getGlobalsAndPackagesXApply() ...
[18:02:36.460]  - future.globals: TRUE
[18:02:36.461] getGlobalsAndPackages() ...
[18:02:36.461] Searching for globals...
[18:02:36.464] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:36.465] Searching for globals ... DONE
[18:02:36.465] Resolving globals: FALSE
[18:02:36.466] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:36.467] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:36.467] - globals: [1] ‘FUN’
[18:02:36.467] 
[18:02:36.467] getGlobalsAndPackages() ... DONE
[18:02:36.468]  - globals found/used: [n=1] ‘FUN’
[18:02:36.468]  - needed namespaces: [n=0] 
[18:02:36.468] Finding globals ... DONE
[18:02:36.468] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:36.469] List of 2
[18:02:36.469]  $ ...future.FUN:function (x, y)  
[18:02:36.469]  $ MoreArgs     : NULL
[18:02:36.469]  - attr(*, "where")=List of 2
[18:02:36.469]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:36.469]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:36.469]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:36.469]  - attr(*, "resolved")= logi FALSE
[18:02:36.469]  - attr(*, "total_size")= num NA
[18:02:36.474] Packages to be attached in all futures: [n=0] 
[18:02:36.475] getGlobalsAndPackagesXApply() ... DONE
[18:02:36.475] Number of futures (= number of chunks): 2
[18:02:36.475] Launching 2 futures (chunks) ...
[18:02:36.475] Chunk #1 of 2 ...
[18:02:36.476]  - Finding globals in '...' for chunk #1 ...
[18:02:36.476] getGlobalsAndPackages() ...
[18:02:36.476] Searching for globals...
[18:02:36.477] 
[18:02:36.477] Searching for globals ... DONE
[18:02:36.477] - globals: [0] <none>
[18:02:36.478] getGlobalsAndPackages() ... DONE
[18:02:36.478]    + additional globals found: [n=0] 
[18:02:36.478]    + additional namespaces needed: [n=0] 
[18:02:36.478]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:36.479]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:36.479]  - seeds: <none>
[18:02:36.479]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:36.479] getGlobalsAndPackages() ...
[18:02:36.479] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:36.480] Resolving globals: FALSE
[18:02:36.481] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[18:02:36.482] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:36.482] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:36.482] 
[18:02:36.483] getGlobalsAndPackages() ... DONE
[18:02:36.483] run() for ‘Future’ ...
[18:02:36.483] - state: ‘created’
[18:02:36.484] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:36.509] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:36.509] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:36.510]   - Field: ‘node’
[18:02:36.510]   - Field: ‘label’
[18:02:36.510]   - Field: ‘local’
[18:02:36.510]   - Field: ‘owner’
[18:02:36.511]   - Field: ‘envir’
[18:02:36.511]   - Field: ‘workers’
[18:02:36.511]   - Field: ‘packages’
[18:02:36.511]   - Field: ‘gc’
[18:02:36.511]   - Field: ‘conditions’
[18:02:36.512]   - Field: ‘persistent’
[18:02:36.512]   - Field: ‘expr’
[18:02:36.512]   - Field: ‘uuid’
[18:02:36.512]   - Field: ‘seed’
[18:02:36.512]   - Field: ‘version’
[18:02:36.513]   - Field: ‘result’
[18:02:36.513]   - Field: ‘asynchronous’
[18:02:36.513]   - Field: ‘calls’
[18:02:36.513]   - Field: ‘globals’
[18:02:36.513]   - Field: ‘stdout’
[18:02:36.514]   - Field: ‘earlySignal’
[18:02:36.514]   - Field: ‘lazy’
[18:02:36.514]   - Field: ‘state’
[18:02:36.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:36.514] - Launch lazy future ...
[18:02:36.515] Packages needed by the future expression (n = 0): <none>
[18:02:36.515] Packages needed by future strategies (n = 0): <none>
[18:02:36.516] {
[18:02:36.516]     {
[18:02:36.516]         {
[18:02:36.516]             ...future.startTime <- base::Sys.time()
[18:02:36.516]             {
[18:02:36.516]                 {
[18:02:36.516]                   {
[18:02:36.516]                     {
[18:02:36.516]                       base::local({
[18:02:36.516]                         has_future <- base::requireNamespace("future", 
[18:02:36.516]                           quietly = TRUE)
[18:02:36.516]                         if (has_future) {
[18:02:36.516]                           ns <- base::getNamespace("future")
[18:02:36.516]                           version <- ns[[".package"]][["version"]]
[18:02:36.516]                           if (is.null(version)) 
[18:02:36.516]                             version <- utils::packageVersion("future")
[18:02:36.516]                         }
[18:02:36.516]                         else {
[18:02:36.516]                           version <- NULL
[18:02:36.516]                         }
[18:02:36.516]                         if (!has_future || version < "1.8.0") {
[18:02:36.516]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:36.516]                             "", base::R.version$version.string), 
[18:02:36.516]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:36.516]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:36.516]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:36.516]                               "release", "version")], collapse = " "), 
[18:02:36.516]                             hostname = base::Sys.info()[["nodename"]])
[18:02:36.516]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:36.516]                             info)
[18:02:36.516]                           info <- base::paste(info, collapse = "; ")
[18:02:36.516]                           if (!has_future) {
[18:02:36.516]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:36.516]                               info)
[18:02:36.516]                           }
[18:02:36.516]                           else {
[18:02:36.516]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:36.516]                               info, version)
[18:02:36.516]                           }
[18:02:36.516]                           base::stop(msg)
[18:02:36.516]                         }
[18:02:36.516]                       })
[18:02:36.516]                     }
[18:02:36.516]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:36.516]                     base::options(mc.cores = 1L)
[18:02:36.516]                   }
[18:02:36.516]                   ...future.strategy.old <- future::plan("list")
[18:02:36.516]                   options(future.plan = NULL)
[18:02:36.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:36.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:36.516]                 }
[18:02:36.516]                 ...future.workdir <- getwd()
[18:02:36.516]             }
[18:02:36.516]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:36.516]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:36.516]         }
[18:02:36.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:36.516]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:36.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:36.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:36.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:36.516]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:36.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:36.516]             base::names(...future.oldOptions))
[18:02:36.516]     }
[18:02:36.516]     if (FALSE) {
[18:02:36.516]     }
[18:02:36.516]     else {
[18:02:36.516]         if (TRUE) {
[18:02:36.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:36.516]                 open = "w")
[18:02:36.516]         }
[18:02:36.516]         else {
[18:02:36.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:36.516]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:36.516]         }
[18:02:36.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:36.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:36.516]             base::sink(type = "output", split = FALSE)
[18:02:36.516]             base::close(...future.stdout)
[18:02:36.516]         }, add = TRUE)
[18:02:36.516]     }
[18:02:36.516]     ...future.frame <- base::sys.nframe()
[18:02:36.516]     ...future.conditions <- base::list()
[18:02:36.516]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:36.516]     if (FALSE) {
[18:02:36.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:36.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:36.516]     }
[18:02:36.516]     ...future.result <- base::tryCatch({
[18:02:36.516]         base::withCallingHandlers({
[18:02:36.516]             ...future.value <- base::withVisible(base::local({
[18:02:36.516]                 ...future.makeSendCondition <- base::local({
[18:02:36.516]                   sendCondition <- NULL
[18:02:36.516]                   function(frame = 1L) {
[18:02:36.516]                     if (is.function(sendCondition)) 
[18:02:36.516]                       return(sendCondition)
[18:02:36.516]                     ns <- getNamespace("parallel")
[18:02:36.516]                     if (exists("sendData", mode = "function", 
[18:02:36.516]                       envir = ns)) {
[18:02:36.516]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:36.516]                         envir = ns)
[18:02:36.516]                       envir <- sys.frame(frame)
[18:02:36.516]                       master <- NULL
[18:02:36.516]                       while (!identical(envir, .GlobalEnv) && 
[18:02:36.516]                         !identical(envir, emptyenv())) {
[18:02:36.516]                         if (exists("master", mode = "list", envir = envir, 
[18:02:36.516]                           inherits = FALSE)) {
[18:02:36.516]                           master <- get("master", mode = "list", 
[18:02:36.516]                             envir = envir, inherits = FALSE)
[18:02:36.516]                           if (inherits(master, c("SOCKnode", 
[18:02:36.516]                             "SOCK0node"))) {
[18:02:36.516]                             sendCondition <<- function(cond) {
[18:02:36.516]                               data <- list(type = "VALUE", value = cond, 
[18:02:36.516]                                 success = TRUE)
[18:02:36.516]                               parallel_sendData(master, data)
[18:02:36.516]                             }
[18:02:36.516]                             return(sendCondition)
[18:02:36.516]                           }
[18:02:36.516]                         }
[18:02:36.516]                         frame <- frame + 1L
[18:02:36.516]                         envir <- sys.frame(frame)
[18:02:36.516]                       }
[18:02:36.516]                     }
[18:02:36.516]                     sendCondition <<- function(cond) NULL
[18:02:36.516]                   }
[18:02:36.516]                 })
[18:02:36.516]                 withCallingHandlers({
[18:02:36.516]                   {
[18:02:36.516]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:36.516]                     if (!identical(...future.globals.maxSize.org, 
[18:02:36.516]                       ...future.globals.maxSize)) {
[18:02:36.516]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:36.516]                       on.exit(options(oopts), add = TRUE)
[18:02:36.516]                     }
[18:02:36.516]                     {
[18:02:36.516]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:36.516]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:36.516]                         USE.NAMES = FALSE)
[18:02:36.516]                       do.call(mapply, args = args)
[18:02:36.516]                     }
[18:02:36.516]                   }
[18:02:36.516]                 }, immediateCondition = function(cond) {
[18:02:36.516]                   sendCondition <- ...future.makeSendCondition()
[18:02:36.516]                   sendCondition(cond)
[18:02:36.516]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:36.516]                   {
[18:02:36.516]                     inherits <- base::inherits
[18:02:36.516]                     invokeRestart <- base::invokeRestart
[18:02:36.516]                     is.null <- base::is.null
[18:02:36.516]                     muffled <- FALSE
[18:02:36.516]                     if (inherits(cond, "message")) {
[18:02:36.516]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:36.516]                       if (muffled) 
[18:02:36.516]                         invokeRestart("muffleMessage")
[18:02:36.516]                     }
[18:02:36.516]                     else if (inherits(cond, "warning")) {
[18:02:36.516]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:36.516]                       if (muffled) 
[18:02:36.516]                         invokeRestart("muffleWarning")
[18:02:36.516]                     }
[18:02:36.516]                     else if (inherits(cond, "condition")) {
[18:02:36.516]                       if (!is.null(pattern)) {
[18:02:36.516]                         computeRestarts <- base::computeRestarts
[18:02:36.516]                         grepl <- base::grepl
[18:02:36.516]                         restarts <- computeRestarts(cond)
[18:02:36.516]                         for (restart in restarts) {
[18:02:36.516]                           name <- restart$name
[18:02:36.516]                           if (is.null(name)) 
[18:02:36.516]                             next
[18:02:36.516]                           if (!grepl(pattern, name)) 
[18:02:36.516]                             next
[18:02:36.516]                           invokeRestart(restart)
[18:02:36.516]                           muffled <- TRUE
[18:02:36.516]                           break
[18:02:36.516]                         }
[18:02:36.516]                       }
[18:02:36.516]                     }
[18:02:36.516]                     invisible(muffled)
[18:02:36.516]                   }
[18:02:36.516]                   muffleCondition(cond)
[18:02:36.516]                 })
[18:02:36.516]             }))
[18:02:36.516]             future::FutureResult(value = ...future.value$value, 
[18:02:36.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:36.516]                   ...future.rng), globalenv = if (FALSE) 
[18:02:36.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:36.516]                     ...future.globalenv.names))
[18:02:36.516]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:36.516]         }, condition = base::local({
[18:02:36.516]             c <- base::c
[18:02:36.516]             inherits <- base::inherits
[18:02:36.516]             invokeRestart <- base::invokeRestart
[18:02:36.516]             length <- base::length
[18:02:36.516]             list <- base::list
[18:02:36.516]             seq.int <- base::seq.int
[18:02:36.516]             signalCondition <- base::signalCondition
[18:02:36.516]             sys.calls <- base::sys.calls
[18:02:36.516]             `[[` <- base::`[[`
[18:02:36.516]             `+` <- base::`+`
[18:02:36.516]             `<<-` <- base::`<<-`
[18:02:36.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:36.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:36.516]                   3L)]
[18:02:36.516]             }
[18:02:36.516]             function(cond) {
[18:02:36.516]                 is_error <- inherits(cond, "error")
[18:02:36.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:36.516]                   NULL)
[18:02:36.516]                 if (is_error) {
[18:02:36.516]                   sessionInformation <- function() {
[18:02:36.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:36.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:36.516]                       search = base::search(), system = base::Sys.info())
[18:02:36.516]                   }
[18:02:36.516]                   ...future.conditions[[length(...future.conditions) + 
[18:02:36.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:36.516]                     cond$call), session = sessionInformation(), 
[18:02:36.516]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:36.516]                   signalCondition(cond)
[18:02:36.516]                 }
[18:02:36.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:36.516]                 "immediateCondition"))) {
[18:02:36.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:36.516]                   ...future.conditions[[length(...future.conditions) + 
[18:02:36.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:36.516]                   if (TRUE && !signal) {
[18:02:36.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:36.516]                     {
[18:02:36.516]                       inherits <- base::inherits
[18:02:36.516]                       invokeRestart <- base::invokeRestart
[18:02:36.516]                       is.null <- base::is.null
[18:02:36.516]                       muffled <- FALSE
[18:02:36.516]                       if (inherits(cond, "message")) {
[18:02:36.516]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:36.516]                         if (muffled) 
[18:02:36.516]                           invokeRestart("muffleMessage")
[18:02:36.516]                       }
[18:02:36.516]                       else if (inherits(cond, "warning")) {
[18:02:36.516]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:36.516]                         if (muffled) 
[18:02:36.516]                           invokeRestart("muffleWarning")
[18:02:36.516]                       }
[18:02:36.516]                       else if (inherits(cond, "condition")) {
[18:02:36.516]                         if (!is.null(pattern)) {
[18:02:36.516]                           computeRestarts <- base::computeRestarts
[18:02:36.516]                           grepl <- base::grepl
[18:02:36.516]                           restarts <- computeRestarts(cond)
[18:02:36.516]                           for (restart in restarts) {
[18:02:36.516]                             name <- restart$name
[18:02:36.516]                             if (is.null(name)) 
[18:02:36.516]                               next
[18:02:36.516]                             if (!grepl(pattern, name)) 
[18:02:36.516]                               next
[18:02:36.516]                             invokeRestart(restart)
[18:02:36.516]                             muffled <- TRUE
[18:02:36.516]                             break
[18:02:36.516]                           }
[18:02:36.516]                         }
[18:02:36.516]                       }
[18:02:36.516]                       invisible(muffled)
[18:02:36.516]                     }
[18:02:36.516]                     muffleCondition(cond, pattern = "^muffle")
[18:02:36.516]                   }
[18:02:36.516]                 }
[18:02:36.516]                 else {
[18:02:36.516]                   if (TRUE) {
[18:02:36.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:36.516]                     {
[18:02:36.516]                       inherits <- base::inherits
[18:02:36.516]                       invokeRestart <- base::invokeRestart
[18:02:36.516]                       is.null <- base::is.null
[18:02:36.516]                       muffled <- FALSE
[18:02:36.516]                       if (inherits(cond, "message")) {
[18:02:36.516]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:36.516]                         if (muffled) 
[18:02:36.516]                           invokeRestart("muffleMessage")
[18:02:36.516]                       }
[18:02:36.516]                       else if (inherits(cond, "warning")) {
[18:02:36.516]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:36.516]                         if (muffled) 
[18:02:36.516]                           invokeRestart("muffleWarning")
[18:02:36.516]                       }
[18:02:36.516]                       else if (inherits(cond, "condition")) {
[18:02:36.516]                         if (!is.null(pattern)) {
[18:02:36.516]                           computeRestarts <- base::computeRestarts
[18:02:36.516]                           grepl <- base::grepl
[18:02:36.516]                           restarts <- computeRestarts(cond)
[18:02:36.516]                           for (restart in restarts) {
[18:02:36.516]                             name <- restart$name
[18:02:36.516]                             if (is.null(name)) 
[18:02:36.516]                               next
[18:02:36.516]                             if (!grepl(pattern, name)) 
[18:02:36.516]                               next
[18:02:36.516]                             invokeRestart(restart)
[18:02:36.516]                             muffled <- TRUE
[18:02:36.516]                             break
[18:02:36.516]                           }
[18:02:36.516]                         }
[18:02:36.516]                       }
[18:02:36.516]                       invisible(muffled)
[18:02:36.516]                     }
[18:02:36.516]                     muffleCondition(cond, pattern = "^muffle")
[18:02:36.516]                   }
[18:02:36.516]                 }
[18:02:36.516]             }
[18:02:36.516]         }))
[18:02:36.516]     }, error = function(ex) {
[18:02:36.516]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:36.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:36.516]                 ...future.rng), started = ...future.startTime, 
[18:02:36.516]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:36.516]             version = "1.8"), class = "FutureResult")
[18:02:36.516]     }, finally = {
[18:02:36.516]         if (!identical(...future.workdir, getwd())) 
[18:02:36.516]             setwd(...future.workdir)
[18:02:36.516]         {
[18:02:36.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:36.516]                 ...future.oldOptions$nwarnings <- NULL
[18:02:36.516]             }
[18:02:36.516]             base::options(...future.oldOptions)
[18:02:36.516]             if (.Platform$OS.type == "windows") {
[18:02:36.516]                 old_names <- names(...future.oldEnvVars)
[18:02:36.516]                 envs <- base::Sys.getenv()
[18:02:36.516]                 names <- names(envs)
[18:02:36.516]                 common <- intersect(names, old_names)
[18:02:36.516]                 added <- setdiff(names, old_names)
[18:02:36.516]                 removed <- setdiff(old_names, names)
[18:02:36.516]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:36.516]                   envs[common]]
[18:02:36.516]                 NAMES <- toupper(changed)
[18:02:36.516]                 args <- list()
[18:02:36.516]                 for (kk in seq_along(NAMES)) {
[18:02:36.516]                   name <- changed[[kk]]
[18:02:36.516]                   NAME <- NAMES[[kk]]
[18:02:36.516]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:36.516]                     next
[18:02:36.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:36.516]                 }
[18:02:36.516]                 NAMES <- toupper(added)
[18:02:36.516]                 for (kk in seq_along(NAMES)) {
[18:02:36.516]                   name <- added[[kk]]
[18:02:36.516]                   NAME <- NAMES[[kk]]
[18:02:36.516]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:36.516]                     next
[18:02:36.516]                   args[[name]] <- ""
[18:02:36.516]                 }
[18:02:36.516]                 NAMES <- toupper(removed)
[18:02:36.516]                 for (kk in seq_along(NAMES)) {
[18:02:36.516]                   name <- removed[[kk]]
[18:02:36.516]                   NAME <- NAMES[[kk]]
[18:02:36.516]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:36.516]                     next
[18:02:36.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:36.516]                 }
[18:02:36.516]                 if (length(args) > 0) 
[18:02:36.516]                   base::do.call(base::Sys.setenv, args = args)
[18:02:36.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:36.516]             }
[18:02:36.516]             else {
[18:02:36.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:36.516]             }
[18:02:36.516]             {
[18:02:36.516]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:36.516]                   0L) {
[18:02:36.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:36.516]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:36.516]                   base::options(opts)
[18:02:36.516]                 }
[18:02:36.516]                 {
[18:02:36.516]                   {
[18:02:36.516]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:36.516]                     NULL
[18:02:36.516]                   }
[18:02:36.516]                   options(future.plan = NULL)
[18:02:36.516]                   if (is.na(NA_character_)) 
[18:02:36.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:36.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:36.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:36.516]                     .init = FALSE)
[18:02:36.516]                 }
[18:02:36.516]             }
[18:02:36.516]         }
[18:02:36.516]     })
[18:02:36.516]     if (TRUE) {
[18:02:36.516]         base::sink(type = "output", split = FALSE)
[18:02:36.516]         if (TRUE) {
[18:02:36.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:36.516]         }
[18:02:36.516]         else {
[18:02:36.516]             ...future.result["stdout"] <- base::list(NULL)
[18:02:36.516]         }
[18:02:36.516]         base::close(...future.stdout)
[18:02:36.516]         ...future.stdout <- NULL
[18:02:36.516]     }
[18:02:36.516]     ...future.result$conditions <- ...future.conditions
[18:02:36.516]     ...future.result$finished <- base::Sys.time()
[18:02:36.516]     ...future.result
[18:02:36.516] }
[18:02:36.522] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[18:02:36.522] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[18:02:36.523] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[18:02:36.523] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:02:36.524] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:02:36.524] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[18:02:36.525] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[18:02:36.526] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:36.526] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:36.527] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:36.528] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:36.528] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[18:02:36.529] MultisessionFuture started
[18:02:36.530] - Launch lazy future ... done
[18:02:36.530] run() for ‘MultisessionFuture’ ... done
[18:02:36.530] Created future:
[18:02:36.530] MultisessionFuture:
[18:02:36.530] Label: ‘future_mapply-1’
[18:02:36.530] Expression:
[18:02:36.530] {
[18:02:36.530]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:36.530]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:36.530]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:36.530]         on.exit(options(oopts), add = TRUE)
[18:02:36.530]     }
[18:02:36.530]     {
[18:02:36.530]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:36.530]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:36.530]         do.call(mapply, args = args)
[18:02:36.530]     }
[18:02:36.530] }
[18:02:36.530] Lazy evaluation: FALSE
[18:02:36.530] Asynchronous evaluation: TRUE
[18:02:36.530] Local evaluation: TRUE
[18:02:36.530] Environment: R_GlobalEnv
[18:02:36.530] Capture standard output: TRUE
[18:02:36.530] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:36.530] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:36.530] Packages: <none>
[18:02:36.530] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:36.530] Resolved: FALSE
[18:02:36.530] Value: <not collected>
[18:02:36.530] Conditions captured: <none>
[18:02:36.530] Early signaling: FALSE
[18:02:36.530] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:36.530] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:36.543] Chunk #1 of 2 ... DONE
[18:02:36.544] Chunk #2 of 2 ...
[18:02:36.544]  - Finding globals in '...' for chunk #2 ...
[18:02:36.544] getGlobalsAndPackages() ...
[18:02:36.544] Searching for globals...
[18:02:36.546] 
[18:02:36.546] Searching for globals ... DONE
[18:02:36.546] - globals: [0] <none>
[18:02:36.546] getGlobalsAndPackages() ... DONE
[18:02:36.546]    + additional globals found: [n=0] 
[18:02:36.547]    + additional namespaces needed: [n=0] 
[18:02:36.547]  - Finding globals in '...' for chunk #2 ... DONE
[18:02:36.547]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:36.547]  - seeds: <none>
[18:02:36.548]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:36.548] getGlobalsAndPackages() ...
[18:02:36.548] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:36.548] Resolving globals: FALSE
[18:02:36.549] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[18:02:36.550] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:36.551] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:36.551] 
[18:02:36.551] getGlobalsAndPackages() ... DONE
[18:02:36.552] run() for ‘Future’ ...
[18:02:36.552] - state: ‘created’
[18:02:36.552] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:36.576] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:36.576] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:36.577]   - Field: ‘node’
[18:02:36.577]   - Field: ‘label’
[18:02:36.577]   - Field: ‘local’
[18:02:36.577]   - Field: ‘owner’
[18:02:36.577]   - Field: ‘envir’
[18:02:36.578]   - Field: ‘workers’
[18:02:36.578]   - Field: ‘packages’
[18:02:36.578]   - Field: ‘gc’
[18:02:36.578]   - Field: ‘conditions’
[18:02:36.578]   - Field: ‘persistent’
[18:02:36.579]   - Field: ‘expr’
[18:02:36.579]   - Field: ‘uuid’
[18:02:36.579]   - Field: ‘seed’
[18:02:36.579]   - Field: ‘version’
[18:02:36.579]   - Field: ‘result’
[18:02:36.580]   - Field: ‘asynchronous’
[18:02:36.580]   - Field: ‘calls’
[18:02:36.580]   - Field: ‘globals’
[18:02:36.580]   - Field: ‘stdout’
[18:02:36.580]   - Field: ‘earlySignal’
[18:02:36.581]   - Field: ‘lazy’
[18:02:36.581]   - Field: ‘state’
[18:02:36.581] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:36.581] - Launch lazy future ...
[18:02:36.582] Packages needed by the future expression (n = 0): <none>
[18:02:36.582] Packages needed by future strategies (n = 0): <none>
[18:02:36.583] {
[18:02:36.583]     {
[18:02:36.583]         {
[18:02:36.583]             ...future.startTime <- base::Sys.time()
[18:02:36.583]             {
[18:02:36.583]                 {
[18:02:36.583]                   {
[18:02:36.583]                     {
[18:02:36.583]                       base::local({
[18:02:36.583]                         has_future <- base::requireNamespace("future", 
[18:02:36.583]                           quietly = TRUE)
[18:02:36.583]                         if (has_future) {
[18:02:36.583]                           ns <- base::getNamespace("future")
[18:02:36.583]                           version <- ns[[".package"]][["version"]]
[18:02:36.583]                           if (is.null(version)) 
[18:02:36.583]                             version <- utils::packageVersion("future")
[18:02:36.583]                         }
[18:02:36.583]                         else {
[18:02:36.583]                           version <- NULL
[18:02:36.583]                         }
[18:02:36.583]                         if (!has_future || version < "1.8.0") {
[18:02:36.583]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:36.583]                             "", base::R.version$version.string), 
[18:02:36.583]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:36.583]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:36.583]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:36.583]                               "release", "version")], collapse = " "), 
[18:02:36.583]                             hostname = base::Sys.info()[["nodename"]])
[18:02:36.583]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:36.583]                             info)
[18:02:36.583]                           info <- base::paste(info, collapse = "; ")
[18:02:36.583]                           if (!has_future) {
[18:02:36.583]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:36.583]                               info)
[18:02:36.583]                           }
[18:02:36.583]                           else {
[18:02:36.583]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:36.583]                               info, version)
[18:02:36.583]                           }
[18:02:36.583]                           base::stop(msg)
[18:02:36.583]                         }
[18:02:36.583]                       })
[18:02:36.583]                     }
[18:02:36.583]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:36.583]                     base::options(mc.cores = 1L)
[18:02:36.583]                   }
[18:02:36.583]                   ...future.strategy.old <- future::plan("list")
[18:02:36.583]                   options(future.plan = NULL)
[18:02:36.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:36.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:36.583]                 }
[18:02:36.583]                 ...future.workdir <- getwd()
[18:02:36.583]             }
[18:02:36.583]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:36.583]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:36.583]         }
[18:02:36.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:36.583]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:36.583]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:36.583]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:36.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:36.583]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:36.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:36.583]             base::names(...future.oldOptions))
[18:02:36.583]     }
[18:02:36.583]     if (FALSE) {
[18:02:36.583]     }
[18:02:36.583]     else {
[18:02:36.583]         if (TRUE) {
[18:02:36.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:36.583]                 open = "w")
[18:02:36.583]         }
[18:02:36.583]         else {
[18:02:36.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:36.583]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:36.583]         }
[18:02:36.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:36.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:36.583]             base::sink(type = "output", split = FALSE)
[18:02:36.583]             base::close(...future.stdout)
[18:02:36.583]         }, add = TRUE)
[18:02:36.583]     }
[18:02:36.583]     ...future.frame <- base::sys.nframe()
[18:02:36.583]     ...future.conditions <- base::list()
[18:02:36.583]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:36.583]     if (FALSE) {
[18:02:36.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:36.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:36.583]     }
[18:02:36.583]     ...future.result <- base::tryCatch({
[18:02:36.583]         base::withCallingHandlers({
[18:02:36.583]             ...future.value <- base::withVisible(base::local({
[18:02:36.583]                 ...future.makeSendCondition <- base::local({
[18:02:36.583]                   sendCondition <- NULL
[18:02:36.583]                   function(frame = 1L) {
[18:02:36.583]                     if (is.function(sendCondition)) 
[18:02:36.583]                       return(sendCondition)
[18:02:36.583]                     ns <- getNamespace("parallel")
[18:02:36.583]                     if (exists("sendData", mode = "function", 
[18:02:36.583]                       envir = ns)) {
[18:02:36.583]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:36.583]                         envir = ns)
[18:02:36.583]                       envir <- sys.frame(frame)
[18:02:36.583]                       master <- NULL
[18:02:36.583]                       while (!identical(envir, .GlobalEnv) && 
[18:02:36.583]                         !identical(envir, emptyenv())) {
[18:02:36.583]                         if (exists("master", mode = "list", envir = envir, 
[18:02:36.583]                           inherits = FALSE)) {
[18:02:36.583]                           master <- get("master", mode = "list", 
[18:02:36.583]                             envir = envir, inherits = FALSE)
[18:02:36.583]                           if (inherits(master, c("SOCKnode", 
[18:02:36.583]                             "SOCK0node"))) {
[18:02:36.583]                             sendCondition <<- function(cond) {
[18:02:36.583]                               data <- list(type = "VALUE", value = cond, 
[18:02:36.583]                                 success = TRUE)
[18:02:36.583]                               parallel_sendData(master, data)
[18:02:36.583]                             }
[18:02:36.583]                             return(sendCondition)
[18:02:36.583]                           }
[18:02:36.583]                         }
[18:02:36.583]                         frame <- frame + 1L
[18:02:36.583]                         envir <- sys.frame(frame)
[18:02:36.583]                       }
[18:02:36.583]                     }
[18:02:36.583]                     sendCondition <<- function(cond) NULL
[18:02:36.583]                   }
[18:02:36.583]                 })
[18:02:36.583]                 withCallingHandlers({
[18:02:36.583]                   {
[18:02:36.583]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:36.583]                     if (!identical(...future.globals.maxSize.org, 
[18:02:36.583]                       ...future.globals.maxSize)) {
[18:02:36.583]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:36.583]                       on.exit(options(oopts), add = TRUE)
[18:02:36.583]                     }
[18:02:36.583]                     {
[18:02:36.583]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:36.583]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:36.583]                         USE.NAMES = FALSE)
[18:02:36.583]                       do.call(mapply, args = args)
[18:02:36.583]                     }
[18:02:36.583]                   }
[18:02:36.583]                 }, immediateCondition = function(cond) {
[18:02:36.583]                   sendCondition <- ...future.makeSendCondition()
[18:02:36.583]                   sendCondition(cond)
[18:02:36.583]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:36.583]                   {
[18:02:36.583]                     inherits <- base::inherits
[18:02:36.583]                     invokeRestart <- base::invokeRestart
[18:02:36.583]                     is.null <- base::is.null
[18:02:36.583]                     muffled <- FALSE
[18:02:36.583]                     if (inherits(cond, "message")) {
[18:02:36.583]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:36.583]                       if (muffled) 
[18:02:36.583]                         invokeRestart("muffleMessage")
[18:02:36.583]                     }
[18:02:36.583]                     else if (inherits(cond, "warning")) {
[18:02:36.583]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:36.583]                       if (muffled) 
[18:02:36.583]                         invokeRestart("muffleWarning")
[18:02:36.583]                     }
[18:02:36.583]                     else if (inherits(cond, "condition")) {
[18:02:36.583]                       if (!is.null(pattern)) {
[18:02:36.583]                         computeRestarts <- base::computeRestarts
[18:02:36.583]                         grepl <- base::grepl
[18:02:36.583]                         restarts <- computeRestarts(cond)
[18:02:36.583]                         for (restart in restarts) {
[18:02:36.583]                           name <- restart$name
[18:02:36.583]                           if (is.null(name)) 
[18:02:36.583]                             next
[18:02:36.583]                           if (!grepl(pattern, name)) 
[18:02:36.583]                             next
[18:02:36.583]                           invokeRestart(restart)
[18:02:36.583]                           muffled <- TRUE
[18:02:36.583]                           break
[18:02:36.583]                         }
[18:02:36.583]                       }
[18:02:36.583]                     }
[18:02:36.583]                     invisible(muffled)
[18:02:36.583]                   }
[18:02:36.583]                   muffleCondition(cond)
[18:02:36.583]                 })
[18:02:36.583]             }))
[18:02:36.583]             future::FutureResult(value = ...future.value$value, 
[18:02:36.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:36.583]                   ...future.rng), globalenv = if (FALSE) 
[18:02:36.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:36.583]                     ...future.globalenv.names))
[18:02:36.583]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:36.583]         }, condition = base::local({
[18:02:36.583]             c <- base::c
[18:02:36.583]             inherits <- base::inherits
[18:02:36.583]             invokeRestart <- base::invokeRestart
[18:02:36.583]             length <- base::length
[18:02:36.583]             list <- base::list
[18:02:36.583]             seq.int <- base::seq.int
[18:02:36.583]             signalCondition <- base::signalCondition
[18:02:36.583]             sys.calls <- base::sys.calls
[18:02:36.583]             `[[` <- base::`[[`
[18:02:36.583]             `+` <- base::`+`
[18:02:36.583]             `<<-` <- base::`<<-`
[18:02:36.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:36.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:36.583]                   3L)]
[18:02:36.583]             }
[18:02:36.583]             function(cond) {
[18:02:36.583]                 is_error <- inherits(cond, "error")
[18:02:36.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:36.583]                   NULL)
[18:02:36.583]                 if (is_error) {
[18:02:36.583]                   sessionInformation <- function() {
[18:02:36.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:36.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:36.583]                       search = base::search(), system = base::Sys.info())
[18:02:36.583]                   }
[18:02:36.583]                   ...future.conditions[[length(...future.conditions) + 
[18:02:36.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:36.583]                     cond$call), session = sessionInformation(), 
[18:02:36.583]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:36.583]                   signalCondition(cond)
[18:02:36.583]                 }
[18:02:36.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:36.583]                 "immediateCondition"))) {
[18:02:36.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:36.583]                   ...future.conditions[[length(...future.conditions) + 
[18:02:36.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:36.583]                   if (TRUE && !signal) {
[18:02:36.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:36.583]                     {
[18:02:36.583]                       inherits <- base::inherits
[18:02:36.583]                       invokeRestart <- base::invokeRestart
[18:02:36.583]                       is.null <- base::is.null
[18:02:36.583]                       muffled <- FALSE
[18:02:36.583]                       if (inherits(cond, "message")) {
[18:02:36.583]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:36.583]                         if (muffled) 
[18:02:36.583]                           invokeRestart("muffleMessage")
[18:02:36.583]                       }
[18:02:36.583]                       else if (inherits(cond, "warning")) {
[18:02:36.583]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:36.583]                         if (muffled) 
[18:02:36.583]                           invokeRestart("muffleWarning")
[18:02:36.583]                       }
[18:02:36.583]                       else if (inherits(cond, "condition")) {
[18:02:36.583]                         if (!is.null(pattern)) {
[18:02:36.583]                           computeRestarts <- base::computeRestarts
[18:02:36.583]                           grepl <- base::grepl
[18:02:36.583]                           restarts <- computeRestarts(cond)
[18:02:36.583]                           for (restart in restarts) {
[18:02:36.583]                             name <- restart$name
[18:02:36.583]                             if (is.null(name)) 
[18:02:36.583]                               next
[18:02:36.583]                             if (!grepl(pattern, name)) 
[18:02:36.583]                               next
[18:02:36.583]                             invokeRestart(restart)
[18:02:36.583]                             muffled <- TRUE
[18:02:36.583]                             break
[18:02:36.583]                           }
[18:02:36.583]                         }
[18:02:36.583]                       }
[18:02:36.583]                       invisible(muffled)
[18:02:36.583]                     }
[18:02:36.583]                     muffleCondition(cond, pattern = "^muffle")
[18:02:36.583]                   }
[18:02:36.583]                 }
[18:02:36.583]                 else {
[18:02:36.583]                   if (TRUE) {
[18:02:36.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:36.583]                     {
[18:02:36.583]                       inherits <- base::inherits
[18:02:36.583]                       invokeRestart <- base::invokeRestart
[18:02:36.583]                       is.null <- base::is.null
[18:02:36.583]                       muffled <- FALSE
[18:02:36.583]                       if (inherits(cond, "message")) {
[18:02:36.583]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:36.583]                         if (muffled) 
[18:02:36.583]                           invokeRestart("muffleMessage")
[18:02:36.583]                       }
[18:02:36.583]                       else if (inherits(cond, "warning")) {
[18:02:36.583]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:36.583]                         if (muffled) 
[18:02:36.583]                           invokeRestart("muffleWarning")
[18:02:36.583]                       }
[18:02:36.583]                       else if (inherits(cond, "condition")) {
[18:02:36.583]                         if (!is.null(pattern)) {
[18:02:36.583]                           computeRestarts <- base::computeRestarts
[18:02:36.583]                           grepl <- base::grepl
[18:02:36.583]                           restarts <- computeRestarts(cond)
[18:02:36.583]                           for (restart in restarts) {
[18:02:36.583]                             name <- restart$name
[18:02:36.583]                             if (is.null(name)) 
[18:02:36.583]                               next
[18:02:36.583]                             if (!grepl(pattern, name)) 
[18:02:36.583]                               next
[18:02:36.583]                             invokeRestart(restart)
[18:02:36.583]                             muffled <- TRUE
[18:02:36.583]                             break
[18:02:36.583]                           }
[18:02:36.583]                         }
[18:02:36.583]                       }
[18:02:36.583]                       invisible(muffled)
[18:02:36.583]                     }
[18:02:36.583]                     muffleCondition(cond, pattern = "^muffle")
[18:02:36.583]                   }
[18:02:36.583]                 }
[18:02:36.583]             }
[18:02:36.583]         }))
[18:02:36.583]     }, error = function(ex) {
[18:02:36.583]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:36.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:36.583]                 ...future.rng), started = ...future.startTime, 
[18:02:36.583]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:36.583]             version = "1.8"), class = "FutureResult")
[18:02:36.583]     }, finally = {
[18:02:36.583]         if (!identical(...future.workdir, getwd())) 
[18:02:36.583]             setwd(...future.workdir)
[18:02:36.583]         {
[18:02:36.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:36.583]                 ...future.oldOptions$nwarnings <- NULL
[18:02:36.583]             }
[18:02:36.583]             base::options(...future.oldOptions)
[18:02:36.583]             if (.Platform$OS.type == "windows") {
[18:02:36.583]                 old_names <- names(...future.oldEnvVars)
[18:02:36.583]                 envs <- base::Sys.getenv()
[18:02:36.583]                 names <- names(envs)
[18:02:36.583]                 common <- intersect(names, old_names)
[18:02:36.583]                 added <- setdiff(names, old_names)
[18:02:36.583]                 removed <- setdiff(old_names, names)
[18:02:36.583]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:36.583]                   envs[common]]
[18:02:36.583]                 NAMES <- toupper(changed)
[18:02:36.583]                 args <- list()
[18:02:36.583]                 for (kk in seq_along(NAMES)) {
[18:02:36.583]                   name <- changed[[kk]]
[18:02:36.583]                   NAME <- NAMES[[kk]]
[18:02:36.583]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:36.583]                     next
[18:02:36.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:36.583]                 }
[18:02:36.583]                 NAMES <- toupper(added)
[18:02:36.583]                 for (kk in seq_along(NAMES)) {
[18:02:36.583]                   name <- added[[kk]]
[18:02:36.583]                   NAME <- NAMES[[kk]]
[18:02:36.583]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:36.583]                     next
[18:02:36.583]                   args[[name]] <- ""
[18:02:36.583]                 }
[18:02:36.583]                 NAMES <- toupper(removed)
[18:02:36.583]                 for (kk in seq_along(NAMES)) {
[18:02:36.583]                   name <- removed[[kk]]
[18:02:36.583]                   NAME <- NAMES[[kk]]
[18:02:36.583]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:36.583]                     next
[18:02:36.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:36.583]                 }
[18:02:36.583]                 if (length(args) > 0) 
[18:02:36.583]                   base::do.call(base::Sys.setenv, args = args)
[18:02:36.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:36.583]             }
[18:02:36.583]             else {
[18:02:36.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:36.583]             }
[18:02:36.583]             {
[18:02:36.583]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:36.583]                   0L) {
[18:02:36.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:36.583]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:36.583]                   base::options(opts)
[18:02:36.583]                 }
[18:02:36.583]                 {
[18:02:36.583]                   {
[18:02:36.583]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:36.583]                     NULL
[18:02:36.583]                   }
[18:02:36.583]                   options(future.plan = NULL)
[18:02:36.583]                   if (is.na(NA_character_)) 
[18:02:36.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:36.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:36.583]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:36.583]                     .init = FALSE)
[18:02:36.583]                 }
[18:02:36.583]             }
[18:02:36.583]         }
[18:02:36.583]     })
[18:02:36.583]     if (TRUE) {
[18:02:36.583]         base::sink(type = "output", split = FALSE)
[18:02:36.583]         if (TRUE) {
[18:02:36.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:36.583]         }
[18:02:36.583]         else {
[18:02:36.583]             ...future.result["stdout"] <- base::list(NULL)
[18:02:36.583]         }
[18:02:36.583]         base::close(...future.stdout)
[18:02:36.583]         ...future.stdout <- NULL
[18:02:36.583]     }
[18:02:36.583]     ...future.result$conditions <- ...future.conditions
[18:02:36.583]     ...future.result$finished <- base::Sys.time()
[18:02:36.583]     ...future.result
[18:02:36.583] }
[18:02:36.588] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[18:02:36.589] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[18:02:36.590] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[18:02:36.590] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:02:36.593] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:02:36.594] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[18:02:36.595] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[18:02:36.595] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:36.596] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:36.596] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:36.597] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:36.597] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[18:02:36.598] MultisessionFuture started
[18:02:36.599] - Launch lazy future ... done
[18:02:36.599] run() for ‘MultisessionFuture’ ... done
[18:02:36.599] Created future:
[18:02:36.599] MultisessionFuture:
[18:02:36.599] Label: ‘future_mapply-2’
[18:02:36.599] Expression:
[18:02:36.599] {
[18:02:36.599]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:36.599]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:36.599]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:36.599]         on.exit(options(oopts), add = TRUE)
[18:02:36.599]     }
[18:02:36.599]     {
[18:02:36.599]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:36.599]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:36.599]         do.call(mapply, args = args)
[18:02:36.599]     }
[18:02:36.599] }
[18:02:36.599] Lazy evaluation: FALSE
[18:02:36.599] Asynchronous evaluation: TRUE
[18:02:36.599] Local evaluation: TRUE
[18:02:36.599] Environment: R_GlobalEnv
[18:02:36.599] Capture standard output: TRUE
[18:02:36.599] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:36.599] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:36.599] Packages: <none>
[18:02:36.599] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:36.599] Resolved: FALSE
[18:02:36.599] Value: <not collected>
[18:02:36.599] Conditions captured: <none>
[18:02:36.599] Early signaling: FALSE
[18:02:36.599] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:36.599] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:36.612] Chunk #2 of 2 ... DONE
[18:02:36.612] Launching 2 futures (chunks) ... DONE
[18:02:36.612] Resolving 2 futures (chunks) ...
[18:02:36.612] resolve() on list ...
[18:02:36.613]  recursive: 0
[18:02:36.613]  length: 2
[18:02:36.613] 
[18:02:36.657] receiveMessageFromWorker() for ClusterFuture ...
[18:02:36.658] - Validating connection of MultisessionFuture
[18:02:36.658] - received message: FutureResult
[18:02:36.658] - Received FutureResult
[18:02:36.659] - Erased future from FutureRegistry
[18:02:36.659] result() for ClusterFuture ...
[18:02:36.659] - result already collected: FutureResult
[18:02:36.659] result() for ClusterFuture ... done
[18:02:36.660] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:36.660] Future #2
[18:02:36.660] result() for ClusterFuture ...
[18:02:36.660] - result already collected: FutureResult
[18:02:36.661] result() for ClusterFuture ... done
[18:02:36.661] result() for ClusterFuture ...
[18:02:36.661] - result already collected: FutureResult
[18:02:36.661] result() for ClusterFuture ... done
[18:02:36.662] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:36.662] - nx: 2
[18:02:36.662] - relay: TRUE
[18:02:36.662] - stdout: TRUE
[18:02:36.662] - signal: TRUE
[18:02:36.663] - resignal: FALSE
[18:02:36.663] - force: TRUE
[18:02:36.663] - relayed: [n=2] FALSE, FALSE
[18:02:36.663] - queued futures: [n=2] FALSE, FALSE
[18:02:36.664]  - until=1
[18:02:36.664]  - relaying element #1
[18:02:36.664] - relayed: [n=2] FALSE, FALSE
[18:02:36.664] - queued futures: [n=2] FALSE, TRUE
[18:02:36.664] signalConditionsASAP(NULL, pos=2) ... done
[18:02:36.665]  length: 1 (resolved future 2)
[18:02:37.082] receiveMessageFromWorker() for ClusterFuture ...
[18:02:37.082] - Validating connection of MultisessionFuture
[18:02:37.083] - received message: FutureResult
[18:02:37.083] - Received FutureResult
[18:02:37.084] - Erased future from FutureRegistry
[18:02:37.084] result() for ClusterFuture ...
[18:02:37.084] - result already collected: FutureResult
[18:02:37.085] result() for ClusterFuture ... done
[18:02:37.085] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:37.085] Future #1
[18:02:37.086] result() for ClusterFuture ...
[18:02:37.086] - result already collected: FutureResult
[18:02:37.086] result() for ClusterFuture ... done
[18:02:37.087] result() for ClusterFuture ...
[18:02:37.087] - result already collected: FutureResult
[18:02:37.087] result() for ClusterFuture ... done
[18:02:37.087] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:37.088] - nx: 2
[18:02:37.088] - relay: TRUE
[18:02:37.088] - stdout: TRUE
[18:02:37.089] - signal: TRUE
[18:02:37.089] - resignal: FALSE
[18:02:37.089] - force: TRUE
[18:02:37.089] - relayed: [n=2] FALSE, FALSE
[18:02:37.090] - queued futures: [n=2] FALSE, TRUE
[18:02:37.090]  - until=1
[18:02:37.090]  - relaying element #1
[18:02:37.091] result() for ClusterFuture ...
[18:02:37.091] - result already collected: FutureResult
[18:02:37.091] result() for ClusterFuture ... done
[18:02:37.092] result() for ClusterFuture ...
[18:02:37.092] - result already collected: FutureResult
[18:02:37.092] result() for ClusterFuture ... done
[18:02:37.093] result() for ClusterFuture ...
[18:02:37.093] - result already collected: FutureResult
[18:02:37.093] result() for ClusterFuture ... done
[18:02:37.094] result() for ClusterFuture ...
[18:02:37.094] - result already collected: FutureResult
[18:02:37.094] result() for ClusterFuture ... done
[18:02:37.094] - relayed: [n=2] TRUE, FALSE
[18:02:37.095] - queued futures: [n=2] TRUE, TRUE
[18:02:37.095] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:37.095]  length: 0 (resolved future 1)
[18:02:37.096] Relaying remaining futures
[18:02:37.096] signalConditionsASAP(NULL, pos=0) ...
[18:02:37.096] - nx: 2
[18:02:37.096] - relay: TRUE
[18:02:37.097] - stdout: TRUE
[18:02:37.097] - signal: TRUE
[18:02:37.097] - resignal: FALSE
[18:02:37.098] - force: TRUE
[18:02:37.098] - relayed: [n=2] TRUE, FALSE
[18:02:37.098] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:37.099]  - relaying element #2
[18:02:37.099] result() for ClusterFuture ...
[18:02:37.099] - result already collected: FutureResult
[18:02:37.100] result() for ClusterFuture ... done
[18:02:37.100] result() for ClusterFuture ...
[18:02:37.100] - result already collected: FutureResult
[18:02:37.101] result() for ClusterFuture ... done
[18:02:37.101] result() for ClusterFuture ...
[18:02:37.102] - result already collected: FutureResult
[18:02:37.102] result() for ClusterFuture ... done
[18:02:37.102] result() for ClusterFuture ...
[18:02:37.103] - result already collected: FutureResult
[18:02:37.103] result() for ClusterFuture ... done
[18:02:37.103] - relayed: [n=2] TRUE, TRUE
[18:02:37.103] - queued futures: [n=2] TRUE, TRUE
[18:02:37.104] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[18:02:37.104] resolve() on list ... DONE
[18:02:37.104] result() for ClusterFuture ...
[18:02:37.105] - result already collected: FutureResult
[18:02:37.105] result() for ClusterFuture ... done
[18:02:37.105] result() for ClusterFuture ...
[18:02:37.105] - result already collected: FutureResult
[18:02:37.106] result() for ClusterFuture ... done
[18:02:37.106] result() for ClusterFuture ...
[18:02:37.106] - result already collected: FutureResult
[18:02:37.107] result() for ClusterFuture ... done
[18:02:37.107] result() for ClusterFuture ...
[18:02:37.107] - result already collected: FutureResult
[18:02:37.108] result() for ClusterFuture ... done
[18:02:37.108]  - Number of value chunks collected: 2
[18:02:37.108] Resolving 2 futures (chunks) ... DONE
[18:02:37.109] Reducing values from 2 chunks ...
[18:02:37.109]  - Number of values collected after concatenation: 2
[18:02:37.109]  - Number of values expected: 2
[18:02:37.109] Reducing values from 2 chunks ... DONE
[18:02:37.110] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[18:02:37.111] future_mapply() ...
[18:02:37.120] Number of chunks: 2
[18:02:37.120] getGlobalsAndPackagesXApply() ...
[18:02:37.121]  - future.globals: TRUE
[18:02:37.121] getGlobalsAndPackages() ...
[18:02:37.121] Searching for globals...
[18:02:37.126] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[18:02:37.126] Searching for globals ... DONE
[18:02:37.127] Resolving globals: FALSE
[18:02:37.128] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[18:02:37.129] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[18:02:37.131] - globals: [1] ‘FUN’
[18:02:37.131] 
[18:02:37.131] getGlobalsAndPackages() ... DONE
[18:02:37.132]  - globals found/used: [n=1] ‘FUN’
[18:02:37.132]  - needed namespaces: [n=0] 
[18:02:37.132] Finding globals ... DONE
[18:02:37.133] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[18:02:37.133] List of 2
[18:02:37.133]  $ ...future.FUN:function (x, y)  
[18:02:37.133]  $ MoreArgs     : NULL
[18:02:37.133]  - attr(*, "where")=List of 2
[18:02:37.133]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[18:02:37.133]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[18:02:37.133]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[18:02:37.133]  - attr(*, "resolved")= logi FALSE
[18:02:37.133]  - attr(*, "total_size")= num NA
[18:02:37.141] Packages to be attached in all futures: [n=0] 
[18:02:37.141] getGlobalsAndPackagesXApply() ... DONE
[18:02:37.142] Number of futures (= number of chunks): 2
[18:02:37.142] Launching 2 futures (chunks) ...
[18:02:37.143] Chunk #1 of 2 ...
[18:02:37.143]  - Finding globals in '...' for chunk #1 ...
[18:02:37.143] getGlobalsAndPackages() ...
[18:02:37.144] Searching for globals...
[18:02:37.145] 
[18:02:37.145] Searching for globals ... DONE
[18:02:37.145] - globals: [0] <none>
[18:02:37.146] getGlobalsAndPackages() ... DONE
[18:02:37.146]    + additional globals found: [n=0] 
[18:02:37.146]    + additional namespaces needed: [n=0] 
[18:02:37.146]  - Finding globals in '...' for chunk #1 ... DONE
[18:02:37.147]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:37.147]  - seeds: <none>
[18:02:37.147]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:37.148] getGlobalsAndPackages() ...
[18:02:37.148] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:37.148] Resolving globals: FALSE
[18:02:37.150] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[18:02:37.151] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:37.151] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:37.152] 
[18:02:37.152] getGlobalsAndPackages() ... DONE
[18:02:37.153] run() for ‘Future’ ...
[18:02:37.153] - state: ‘created’
[18:02:37.153] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:37.187] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:37.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:37.187]   - Field: ‘node’
[18:02:37.188]   - Field: ‘label’
[18:02:37.188]   - Field: ‘local’
[18:02:37.188]   - Field: ‘owner’
[18:02:37.188]   - Field: ‘envir’
[18:02:37.189]   - Field: ‘workers’
[18:02:37.189]   - Field: ‘packages’
[18:02:37.189]   - Field: ‘gc’
[18:02:37.189]   - Field: ‘conditions’
[18:02:37.190]   - Field: ‘persistent’
[18:02:37.190]   - Field: ‘expr’
[18:02:37.190]   - Field: ‘uuid’
[18:02:37.190]   - Field: ‘seed’
[18:02:37.191]   - Field: ‘version’
[18:02:37.191]   - Field: ‘result’
[18:02:37.191]   - Field: ‘asynchronous’
[18:02:37.191]   - Field: ‘calls’
[18:02:37.192]   - Field: ‘globals’
[18:02:37.192]   - Field: ‘stdout’
[18:02:37.192]   - Field: ‘earlySignal’
[18:02:37.192]   - Field: ‘lazy’
[18:02:37.193]   - Field: ‘state’
[18:02:37.193] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:37.193] - Launch lazy future ...
[18:02:37.194] Packages needed by the future expression (n = 0): <none>
[18:02:37.194] Packages needed by future strategies (n = 0): <none>
[18:02:37.195] {
[18:02:37.195]     {
[18:02:37.195]         {
[18:02:37.195]             ...future.startTime <- base::Sys.time()
[18:02:37.195]             {
[18:02:37.195]                 {
[18:02:37.195]                   {
[18:02:37.195]                     {
[18:02:37.195]                       base::local({
[18:02:37.195]                         has_future <- base::requireNamespace("future", 
[18:02:37.195]                           quietly = TRUE)
[18:02:37.195]                         if (has_future) {
[18:02:37.195]                           ns <- base::getNamespace("future")
[18:02:37.195]                           version <- ns[[".package"]][["version"]]
[18:02:37.195]                           if (is.null(version)) 
[18:02:37.195]                             version <- utils::packageVersion("future")
[18:02:37.195]                         }
[18:02:37.195]                         else {
[18:02:37.195]                           version <- NULL
[18:02:37.195]                         }
[18:02:37.195]                         if (!has_future || version < "1.8.0") {
[18:02:37.195]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:37.195]                             "", base::R.version$version.string), 
[18:02:37.195]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:37.195]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:37.195]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:37.195]                               "release", "version")], collapse = " "), 
[18:02:37.195]                             hostname = base::Sys.info()[["nodename"]])
[18:02:37.195]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:37.195]                             info)
[18:02:37.195]                           info <- base::paste(info, collapse = "; ")
[18:02:37.195]                           if (!has_future) {
[18:02:37.195]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:37.195]                               info)
[18:02:37.195]                           }
[18:02:37.195]                           else {
[18:02:37.195]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:37.195]                               info, version)
[18:02:37.195]                           }
[18:02:37.195]                           base::stop(msg)
[18:02:37.195]                         }
[18:02:37.195]                       })
[18:02:37.195]                     }
[18:02:37.195]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:37.195]                     base::options(mc.cores = 1L)
[18:02:37.195]                   }
[18:02:37.195]                   ...future.strategy.old <- future::plan("list")
[18:02:37.195]                   options(future.plan = NULL)
[18:02:37.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:37.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:37.195]                 }
[18:02:37.195]                 ...future.workdir <- getwd()
[18:02:37.195]             }
[18:02:37.195]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:37.195]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:37.195]         }
[18:02:37.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:37.195]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:37.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:37.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:37.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:37.195]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:37.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:37.195]             base::names(...future.oldOptions))
[18:02:37.195]     }
[18:02:37.195]     if (TRUE) {
[18:02:37.195]     }
[18:02:37.195]     else {
[18:02:37.195]         if (NA) {
[18:02:37.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:37.195]                 open = "w")
[18:02:37.195]         }
[18:02:37.195]         else {
[18:02:37.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:37.195]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:37.195]         }
[18:02:37.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:37.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:37.195]             base::sink(type = "output", split = FALSE)
[18:02:37.195]             base::close(...future.stdout)
[18:02:37.195]         }, add = TRUE)
[18:02:37.195]     }
[18:02:37.195]     ...future.frame <- base::sys.nframe()
[18:02:37.195]     ...future.conditions <- base::list()
[18:02:37.195]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:37.195]     if (FALSE) {
[18:02:37.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:37.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:37.195]     }
[18:02:37.195]     ...future.result <- base::tryCatch({
[18:02:37.195]         base::withCallingHandlers({
[18:02:37.195]             ...future.value <- base::withVisible(base::local({
[18:02:37.195]                 ...future.makeSendCondition <- base::local({
[18:02:37.195]                   sendCondition <- NULL
[18:02:37.195]                   function(frame = 1L) {
[18:02:37.195]                     if (is.function(sendCondition)) 
[18:02:37.195]                       return(sendCondition)
[18:02:37.195]                     ns <- getNamespace("parallel")
[18:02:37.195]                     if (exists("sendData", mode = "function", 
[18:02:37.195]                       envir = ns)) {
[18:02:37.195]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:37.195]                         envir = ns)
[18:02:37.195]                       envir <- sys.frame(frame)
[18:02:37.195]                       master <- NULL
[18:02:37.195]                       while (!identical(envir, .GlobalEnv) && 
[18:02:37.195]                         !identical(envir, emptyenv())) {
[18:02:37.195]                         if (exists("master", mode = "list", envir = envir, 
[18:02:37.195]                           inherits = FALSE)) {
[18:02:37.195]                           master <- get("master", mode = "list", 
[18:02:37.195]                             envir = envir, inherits = FALSE)
[18:02:37.195]                           if (inherits(master, c("SOCKnode", 
[18:02:37.195]                             "SOCK0node"))) {
[18:02:37.195]                             sendCondition <<- function(cond) {
[18:02:37.195]                               data <- list(type = "VALUE", value = cond, 
[18:02:37.195]                                 success = TRUE)
[18:02:37.195]                               parallel_sendData(master, data)
[18:02:37.195]                             }
[18:02:37.195]                             return(sendCondition)
[18:02:37.195]                           }
[18:02:37.195]                         }
[18:02:37.195]                         frame <- frame + 1L
[18:02:37.195]                         envir <- sys.frame(frame)
[18:02:37.195]                       }
[18:02:37.195]                     }
[18:02:37.195]                     sendCondition <<- function(cond) NULL
[18:02:37.195]                   }
[18:02:37.195]                 })
[18:02:37.195]                 withCallingHandlers({
[18:02:37.195]                   {
[18:02:37.195]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:37.195]                     if (!identical(...future.globals.maxSize.org, 
[18:02:37.195]                       ...future.globals.maxSize)) {
[18:02:37.195]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:37.195]                       on.exit(options(oopts), add = TRUE)
[18:02:37.195]                     }
[18:02:37.195]                     {
[18:02:37.195]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:37.195]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:37.195]                         USE.NAMES = FALSE)
[18:02:37.195]                       do.call(mapply, args = args)
[18:02:37.195]                     }
[18:02:37.195]                   }
[18:02:37.195]                 }, immediateCondition = function(cond) {
[18:02:37.195]                   sendCondition <- ...future.makeSendCondition()
[18:02:37.195]                   sendCondition(cond)
[18:02:37.195]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:37.195]                   {
[18:02:37.195]                     inherits <- base::inherits
[18:02:37.195]                     invokeRestart <- base::invokeRestart
[18:02:37.195]                     is.null <- base::is.null
[18:02:37.195]                     muffled <- FALSE
[18:02:37.195]                     if (inherits(cond, "message")) {
[18:02:37.195]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:37.195]                       if (muffled) 
[18:02:37.195]                         invokeRestart("muffleMessage")
[18:02:37.195]                     }
[18:02:37.195]                     else if (inherits(cond, "warning")) {
[18:02:37.195]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:37.195]                       if (muffled) 
[18:02:37.195]                         invokeRestart("muffleWarning")
[18:02:37.195]                     }
[18:02:37.195]                     else if (inherits(cond, "condition")) {
[18:02:37.195]                       if (!is.null(pattern)) {
[18:02:37.195]                         computeRestarts <- base::computeRestarts
[18:02:37.195]                         grepl <- base::grepl
[18:02:37.195]                         restarts <- computeRestarts(cond)
[18:02:37.195]                         for (restart in restarts) {
[18:02:37.195]                           name <- restart$name
[18:02:37.195]                           if (is.null(name)) 
[18:02:37.195]                             next
[18:02:37.195]                           if (!grepl(pattern, name)) 
[18:02:37.195]                             next
[18:02:37.195]                           invokeRestart(restart)
[18:02:37.195]                           muffled <- TRUE
[18:02:37.195]                           break
[18:02:37.195]                         }
[18:02:37.195]                       }
[18:02:37.195]                     }
[18:02:37.195]                     invisible(muffled)
[18:02:37.195]                   }
[18:02:37.195]                   muffleCondition(cond)
[18:02:37.195]                 })
[18:02:37.195]             }))
[18:02:37.195]             future::FutureResult(value = ...future.value$value, 
[18:02:37.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:37.195]                   ...future.rng), globalenv = if (FALSE) 
[18:02:37.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:37.195]                     ...future.globalenv.names))
[18:02:37.195]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:37.195]         }, condition = base::local({
[18:02:37.195]             c <- base::c
[18:02:37.195]             inherits <- base::inherits
[18:02:37.195]             invokeRestart <- base::invokeRestart
[18:02:37.195]             length <- base::length
[18:02:37.195]             list <- base::list
[18:02:37.195]             seq.int <- base::seq.int
[18:02:37.195]             signalCondition <- base::signalCondition
[18:02:37.195]             sys.calls <- base::sys.calls
[18:02:37.195]             `[[` <- base::`[[`
[18:02:37.195]             `+` <- base::`+`
[18:02:37.195]             `<<-` <- base::`<<-`
[18:02:37.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:37.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:37.195]                   3L)]
[18:02:37.195]             }
[18:02:37.195]             function(cond) {
[18:02:37.195]                 is_error <- inherits(cond, "error")
[18:02:37.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:37.195]                   NULL)
[18:02:37.195]                 if (is_error) {
[18:02:37.195]                   sessionInformation <- function() {
[18:02:37.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:37.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:37.195]                       search = base::search(), system = base::Sys.info())
[18:02:37.195]                   }
[18:02:37.195]                   ...future.conditions[[length(...future.conditions) + 
[18:02:37.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:37.195]                     cond$call), session = sessionInformation(), 
[18:02:37.195]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:37.195]                   signalCondition(cond)
[18:02:37.195]                 }
[18:02:37.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:37.195]                 "immediateCondition"))) {
[18:02:37.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:37.195]                   ...future.conditions[[length(...future.conditions) + 
[18:02:37.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:37.195]                   if (TRUE && !signal) {
[18:02:37.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:37.195]                     {
[18:02:37.195]                       inherits <- base::inherits
[18:02:37.195]                       invokeRestart <- base::invokeRestart
[18:02:37.195]                       is.null <- base::is.null
[18:02:37.195]                       muffled <- FALSE
[18:02:37.195]                       if (inherits(cond, "message")) {
[18:02:37.195]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:37.195]                         if (muffled) 
[18:02:37.195]                           invokeRestart("muffleMessage")
[18:02:37.195]                       }
[18:02:37.195]                       else if (inherits(cond, "warning")) {
[18:02:37.195]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:37.195]                         if (muffled) 
[18:02:37.195]                           invokeRestart("muffleWarning")
[18:02:37.195]                       }
[18:02:37.195]                       else if (inherits(cond, "condition")) {
[18:02:37.195]                         if (!is.null(pattern)) {
[18:02:37.195]                           computeRestarts <- base::computeRestarts
[18:02:37.195]                           grepl <- base::grepl
[18:02:37.195]                           restarts <- computeRestarts(cond)
[18:02:37.195]                           for (restart in restarts) {
[18:02:37.195]                             name <- restart$name
[18:02:37.195]                             if (is.null(name)) 
[18:02:37.195]                               next
[18:02:37.195]                             if (!grepl(pattern, name)) 
[18:02:37.195]                               next
[18:02:37.195]                             invokeRestart(restart)
[18:02:37.195]                             muffled <- TRUE
[18:02:37.195]                             break
[18:02:37.195]                           }
[18:02:37.195]                         }
[18:02:37.195]                       }
[18:02:37.195]                       invisible(muffled)
[18:02:37.195]                     }
[18:02:37.195]                     muffleCondition(cond, pattern = "^muffle")
[18:02:37.195]                   }
[18:02:37.195]                 }
[18:02:37.195]                 else {
[18:02:37.195]                   if (TRUE) {
[18:02:37.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:37.195]                     {
[18:02:37.195]                       inherits <- base::inherits
[18:02:37.195]                       invokeRestart <- base::invokeRestart
[18:02:37.195]                       is.null <- base::is.null
[18:02:37.195]                       muffled <- FALSE
[18:02:37.195]                       if (inherits(cond, "message")) {
[18:02:37.195]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:37.195]                         if (muffled) 
[18:02:37.195]                           invokeRestart("muffleMessage")
[18:02:37.195]                       }
[18:02:37.195]                       else if (inherits(cond, "warning")) {
[18:02:37.195]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:37.195]                         if (muffled) 
[18:02:37.195]                           invokeRestart("muffleWarning")
[18:02:37.195]                       }
[18:02:37.195]                       else if (inherits(cond, "condition")) {
[18:02:37.195]                         if (!is.null(pattern)) {
[18:02:37.195]                           computeRestarts <- base::computeRestarts
[18:02:37.195]                           grepl <- base::grepl
[18:02:37.195]                           restarts <- computeRestarts(cond)
[18:02:37.195]                           for (restart in restarts) {
[18:02:37.195]                             name <- restart$name
[18:02:37.195]                             if (is.null(name)) 
[18:02:37.195]                               next
[18:02:37.195]                             if (!grepl(pattern, name)) 
[18:02:37.195]                               next
[18:02:37.195]                             invokeRestart(restart)
[18:02:37.195]                             muffled <- TRUE
[18:02:37.195]                             break
[18:02:37.195]                           }
[18:02:37.195]                         }
[18:02:37.195]                       }
[18:02:37.195]                       invisible(muffled)
[18:02:37.195]                     }
[18:02:37.195]                     muffleCondition(cond, pattern = "^muffle")
[18:02:37.195]                   }
[18:02:37.195]                 }
[18:02:37.195]             }
[18:02:37.195]         }))
[18:02:37.195]     }, error = function(ex) {
[18:02:37.195]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:37.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:37.195]                 ...future.rng), started = ...future.startTime, 
[18:02:37.195]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:37.195]             version = "1.8"), class = "FutureResult")
[18:02:37.195]     }, finally = {
[18:02:37.195]         if (!identical(...future.workdir, getwd())) 
[18:02:37.195]             setwd(...future.workdir)
[18:02:37.195]         {
[18:02:37.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:37.195]                 ...future.oldOptions$nwarnings <- NULL
[18:02:37.195]             }
[18:02:37.195]             base::options(...future.oldOptions)
[18:02:37.195]             if (.Platform$OS.type == "windows") {
[18:02:37.195]                 old_names <- names(...future.oldEnvVars)
[18:02:37.195]                 envs <- base::Sys.getenv()
[18:02:37.195]                 names <- names(envs)
[18:02:37.195]                 common <- intersect(names, old_names)
[18:02:37.195]                 added <- setdiff(names, old_names)
[18:02:37.195]                 removed <- setdiff(old_names, names)
[18:02:37.195]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:37.195]                   envs[common]]
[18:02:37.195]                 NAMES <- toupper(changed)
[18:02:37.195]                 args <- list()
[18:02:37.195]                 for (kk in seq_along(NAMES)) {
[18:02:37.195]                   name <- changed[[kk]]
[18:02:37.195]                   NAME <- NAMES[[kk]]
[18:02:37.195]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:37.195]                     next
[18:02:37.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:37.195]                 }
[18:02:37.195]                 NAMES <- toupper(added)
[18:02:37.195]                 for (kk in seq_along(NAMES)) {
[18:02:37.195]                   name <- added[[kk]]
[18:02:37.195]                   NAME <- NAMES[[kk]]
[18:02:37.195]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:37.195]                     next
[18:02:37.195]                   args[[name]] <- ""
[18:02:37.195]                 }
[18:02:37.195]                 NAMES <- toupper(removed)
[18:02:37.195]                 for (kk in seq_along(NAMES)) {
[18:02:37.195]                   name <- removed[[kk]]
[18:02:37.195]                   NAME <- NAMES[[kk]]
[18:02:37.195]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:37.195]                     next
[18:02:37.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:37.195]                 }
[18:02:37.195]                 if (length(args) > 0) 
[18:02:37.195]                   base::do.call(base::Sys.setenv, args = args)
[18:02:37.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:37.195]             }
[18:02:37.195]             else {
[18:02:37.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:37.195]             }
[18:02:37.195]             {
[18:02:37.195]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:37.195]                   0L) {
[18:02:37.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:37.195]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:37.195]                   base::options(opts)
[18:02:37.195]                 }
[18:02:37.195]                 {
[18:02:37.195]                   {
[18:02:37.195]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:37.195]                     NULL
[18:02:37.195]                   }
[18:02:37.195]                   options(future.plan = NULL)
[18:02:37.195]                   if (is.na(NA_character_)) 
[18:02:37.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:37.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:37.195]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:37.195]                     .init = FALSE)
[18:02:37.195]                 }
[18:02:37.195]             }
[18:02:37.195]         }
[18:02:37.195]     })
[18:02:37.195]     if (FALSE) {
[18:02:37.195]         base::sink(type = "output", split = FALSE)
[18:02:37.195]         if (NA) {
[18:02:37.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:37.195]         }
[18:02:37.195]         else {
[18:02:37.195]             ...future.result["stdout"] <- base::list(NULL)
[18:02:37.195]         }
[18:02:37.195]         base::close(...future.stdout)
[18:02:37.195]         ...future.stdout <- NULL
[18:02:37.195]     }
[18:02:37.195]     ...future.result$conditions <- ...future.conditions
[18:02:37.195]     ...future.result$finished <- base::Sys.time()
[18:02:37.195]     ...future.result
[18:02:37.195] }
[18:02:37.201] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[18:02:37.201] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[18:02:37.202] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[18:02:37.202] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[18:02:37.203] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[18:02:37.204] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[18:02:37.205] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[18:02:37.205] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[18:02:37.206] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[18:02:37.206] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[18:02:37.207] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[18:02:37.208] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[18:02:37.209] MultisessionFuture started
[18:02:37.209] - Launch lazy future ... done
[18:02:37.210] run() for ‘MultisessionFuture’ ... done
[18:02:37.210] Created future:
[18:02:37.210] MultisessionFuture:
[18:02:37.210] Label: ‘future_mapply-1’
[18:02:37.210] Expression:
[18:02:37.210] {
[18:02:37.210]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:37.210]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:37.210]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:37.210]         on.exit(options(oopts), add = TRUE)
[18:02:37.210]     }
[18:02:37.210]     {
[18:02:37.210]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:37.210]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:37.210]         do.call(mapply, args = args)
[18:02:37.210]     }
[18:02:37.210] }
[18:02:37.210] Lazy evaluation: FALSE
[18:02:37.210] Asynchronous evaluation: TRUE
[18:02:37.210] Local evaluation: TRUE
[18:02:37.210] Environment: R_GlobalEnv
[18:02:37.210] Capture standard output: NA
[18:02:37.210] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:37.210] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:37.210] Packages: <none>
[18:02:37.210] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:37.210] Resolved: FALSE
[18:02:37.210] Value: <not collected>
[18:02:37.210] Conditions captured: <none>
[18:02:37.210] Early signaling: FALSE
[18:02:37.210] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:37.210] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:37.224] Chunk #1 of 2 ... DONE
[18:02:37.226] Chunk #2 of 2 ...
[18:02:37.226]  - Finding globals in '...' for chunk #2 ...
[18:02:37.226] getGlobalsAndPackages() ...
[18:02:37.227] Searching for globals...
[18:02:37.228] 
[18:02:37.228] Searching for globals ... DONE
[18:02:37.228] - globals: [0] <none>
[18:02:37.228] getGlobalsAndPackages() ... DONE
[18:02:37.229]    + additional globals found: [n=0] 
[18:02:37.229]    + additional namespaces needed: [n=0] 
[18:02:37.229]  - Finding globals in '...' for chunk #2 ... DONE
[18:02:37.229]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[18:02:37.230]  - seeds: <none>
[18:02:37.230]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:37.230] getGlobalsAndPackages() ...
[18:02:37.231] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:37.231] Resolving globals: FALSE
[18:02:37.232] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[18:02:37.233] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[18:02:37.234] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[18:02:37.234] 
[18:02:37.234] getGlobalsAndPackages() ... DONE
[18:02:37.235] run() for ‘Future’ ...
[18:02:37.235] - state: ‘created’
[18:02:37.236] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[18:02:37.262] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:37.263] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[18:02:37.263]   - Field: ‘node’
[18:02:37.263]   - Field: ‘label’
[18:02:37.263]   - Field: ‘local’
[18:02:37.264]   - Field: ‘owner’
[18:02:37.264]   - Field: ‘envir’
[18:02:37.264]   - Field: ‘workers’
[18:02:37.264]   - Field: ‘packages’
[18:02:37.264]   - Field: ‘gc’
[18:02:37.265]   - Field: ‘conditions’
[18:02:37.265]   - Field: ‘persistent’
[18:02:37.265]   - Field: ‘expr’
[18:02:37.265]   - Field: ‘uuid’
[18:02:37.266]   - Field: ‘seed’
[18:02:37.266]   - Field: ‘version’
[18:02:37.266]   - Field: ‘result’
[18:02:37.266]   - Field: ‘asynchronous’
[18:02:37.266]   - Field: ‘calls’
[18:02:37.267]   - Field: ‘globals’
[18:02:37.267]   - Field: ‘stdout’
[18:02:37.267]   - Field: ‘earlySignal’
[18:02:37.267]   - Field: ‘lazy’
[18:02:37.267]   - Field: ‘state’
[18:02:37.268] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[18:02:37.268] - Launch lazy future ...
[18:02:37.268] Packages needed by the future expression (n = 0): <none>
[18:02:37.269] Packages needed by future strategies (n = 0): <none>
[18:02:37.270] {
[18:02:37.270]     {
[18:02:37.270]         {
[18:02:37.270]             ...future.startTime <- base::Sys.time()
[18:02:37.270]             {
[18:02:37.270]                 {
[18:02:37.270]                   {
[18:02:37.270]                     {
[18:02:37.270]                       base::local({
[18:02:37.270]                         has_future <- base::requireNamespace("future", 
[18:02:37.270]                           quietly = TRUE)
[18:02:37.270]                         if (has_future) {
[18:02:37.270]                           ns <- base::getNamespace("future")
[18:02:37.270]                           version <- ns[[".package"]][["version"]]
[18:02:37.270]                           if (is.null(version)) 
[18:02:37.270]                             version <- utils::packageVersion("future")
[18:02:37.270]                         }
[18:02:37.270]                         else {
[18:02:37.270]                           version <- NULL
[18:02:37.270]                         }
[18:02:37.270]                         if (!has_future || version < "1.8.0") {
[18:02:37.270]                           info <- base::c(r_version = base::gsub("R version ", 
[18:02:37.270]                             "", base::R.version$version.string), 
[18:02:37.270]                             platform = base::sprintf("%s (%s-bit)", 
[18:02:37.270]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[18:02:37.270]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[18:02:37.270]                               "release", "version")], collapse = " "), 
[18:02:37.270]                             hostname = base::Sys.info()[["nodename"]])
[18:02:37.270]                           info <- base::sprintf("%s: %s", base::names(info), 
[18:02:37.270]                             info)
[18:02:37.270]                           info <- base::paste(info, collapse = "; ")
[18:02:37.270]                           if (!has_future) {
[18:02:37.270]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[18:02:37.270]                               info)
[18:02:37.270]                           }
[18:02:37.270]                           else {
[18:02:37.270]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[18:02:37.270]                               info, version)
[18:02:37.270]                           }
[18:02:37.270]                           base::stop(msg)
[18:02:37.270]                         }
[18:02:37.270]                       })
[18:02:37.270]                     }
[18:02:37.270]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[18:02:37.270]                     base::options(mc.cores = 1L)
[18:02:37.270]                   }
[18:02:37.270]                   ...future.strategy.old <- future::plan("list")
[18:02:37.270]                   options(future.plan = NULL)
[18:02:37.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[18:02:37.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[18:02:37.270]                 }
[18:02:37.270]                 ...future.workdir <- getwd()
[18:02:37.270]             }
[18:02:37.270]             ...future.oldOptions <- base::as.list(base::.Options)
[18:02:37.270]             ...future.oldEnvVars <- base::Sys.getenv()
[18:02:37.270]         }
[18:02:37.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[18:02:37.270]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[18:02:37.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[18:02:37.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[18:02:37.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[18:02:37.270]             future.stdout.windows.reencode = NULL, width = 80L)
[18:02:37.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[18:02:37.270]             base::names(...future.oldOptions))
[18:02:37.270]     }
[18:02:37.270]     if (TRUE) {
[18:02:37.270]     }
[18:02:37.270]     else {
[18:02:37.270]         if (NA) {
[18:02:37.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[18:02:37.270]                 open = "w")
[18:02:37.270]         }
[18:02:37.270]         else {
[18:02:37.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[18:02:37.270]                 windows = "NUL", "/dev/null"), open = "w")
[18:02:37.270]         }
[18:02:37.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[18:02:37.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[18:02:37.270]             base::sink(type = "output", split = FALSE)
[18:02:37.270]             base::close(...future.stdout)
[18:02:37.270]         }, add = TRUE)
[18:02:37.270]     }
[18:02:37.270]     ...future.frame <- base::sys.nframe()
[18:02:37.270]     ...future.conditions <- base::list()
[18:02:37.270]     ...future.rng <- base::globalenv()$.Random.seed
[18:02:37.270]     if (FALSE) {
[18:02:37.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[18:02:37.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[18:02:37.270]     }
[18:02:37.270]     ...future.result <- base::tryCatch({
[18:02:37.270]         base::withCallingHandlers({
[18:02:37.270]             ...future.value <- base::withVisible(base::local({
[18:02:37.270]                 ...future.makeSendCondition <- base::local({
[18:02:37.270]                   sendCondition <- NULL
[18:02:37.270]                   function(frame = 1L) {
[18:02:37.270]                     if (is.function(sendCondition)) 
[18:02:37.270]                       return(sendCondition)
[18:02:37.270]                     ns <- getNamespace("parallel")
[18:02:37.270]                     if (exists("sendData", mode = "function", 
[18:02:37.270]                       envir = ns)) {
[18:02:37.270]                       parallel_sendData <- get("sendData", mode = "function", 
[18:02:37.270]                         envir = ns)
[18:02:37.270]                       envir <- sys.frame(frame)
[18:02:37.270]                       master <- NULL
[18:02:37.270]                       while (!identical(envir, .GlobalEnv) && 
[18:02:37.270]                         !identical(envir, emptyenv())) {
[18:02:37.270]                         if (exists("master", mode = "list", envir = envir, 
[18:02:37.270]                           inherits = FALSE)) {
[18:02:37.270]                           master <- get("master", mode = "list", 
[18:02:37.270]                             envir = envir, inherits = FALSE)
[18:02:37.270]                           if (inherits(master, c("SOCKnode", 
[18:02:37.270]                             "SOCK0node"))) {
[18:02:37.270]                             sendCondition <<- function(cond) {
[18:02:37.270]                               data <- list(type = "VALUE", value = cond, 
[18:02:37.270]                                 success = TRUE)
[18:02:37.270]                               parallel_sendData(master, data)
[18:02:37.270]                             }
[18:02:37.270]                             return(sendCondition)
[18:02:37.270]                           }
[18:02:37.270]                         }
[18:02:37.270]                         frame <- frame + 1L
[18:02:37.270]                         envir <- sys.frame(frame)
[18:02:37.270]                       }
[18:02:37.270]                     }
[18:02:37.270]                     sendCondition <<- function(cond) NULL
[18:02:37.270]                   }
[18:02:37.270]                 })
[18:02:37.270]                 withCallingHandlers({
[18:02:37.270]                   {
[18:02:37.270]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:37.270]                     if (!identical(...future.globals.maxSize.org, 
[18:02:37.270]                       ...future.globals.maxSize)) {
[18:02:37.270]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:37.270]                       on.exit(options(oopts), add = TRUE)
[18:02:37.270]                     }
[18:02:37.270]                     {
[18:02:37.270]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:37.270]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[18:02:37.270]                         USE.NAMES = FALSE)
[18:02:37.270]                       do.call(mapply, args = args)
[18:02:37.270]                     }
[18:02:37.270]                   }
[18:02:37.270]                 }, immediateCondition = function(cond) {
[18:02:37.270]                   sendCondition <- ...future.makeSendCondition()
[18:02:37.270]                   sendCondition(cond)
[18:02:37.270]                   muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:37.270]                   {
[18:02:37.270]                     inherits <- base::inherits
[18:02:37.270]                     invokeRestart <- base::invokeRestart
[18:02:37.270]                     is.null <- base::is.null
[18:02:37.270]                     muffled <- FALSE
[18:02:37.270]                     if (inherits(cond, "message")) {
[18:02:37.270]                       muffled <- grepl(pattern, "muffleMessage")
[18:02:37.270]                       if (muffled) 
[18:02:37.270]                         invokeRestart("muffleMessage")
[18:02:37.270]                     }
[18:02:37.270]                     else if (inherits(cond, "warning")) {
[18:02:37.270]                       muffled <- grepl(pattern, "muffleWarning")
[18:02:37.270]                       if (muffled) 
[18:02:37.270]                         invokeRestart("muffleWarning")
[18:02:37.270]                     }
[18:02:37.270]                     else if (inherits(cond, "condition")) {
[18:02:37.270]                       if (!is.null(pattern)) {
[18:02:37.270]                         computeRestarts <- base::computeRestarts
[18:02:37.270]                         grepl <- base::grepl
[18:02:37.270]                         restarts <- computeRestarts(cond)
[18:02:37.270]                         for (restart in restarts) {
[18:02:37.270]                           name <- restart$name
[18:02:37.270]                           if (is.null(name)) 
[18:02:37.270]                             next
[18:02:37.270]                           if (!grepl(pattern, name)) 
[18:02:37.270]                             next
[18:02:37.270]                           invokeRestart(restart)
[18:02:37.270]                           muffled <- TRUE
[18:02:37.270]                           break
[18:02:37.270]                         }
[18:02:37.270]                       }
[18:02:37.270]                     }
[18:02:37.270]                     invisible(muffled)
[18:02:37.270]                   }
[18:02:37.270]                   muffleCondition(cond)
[18:02:37.270]                 })
[18:02:37.270]             }))
[18:02:37.270]             future::FutureResult(value = ...future.value$value, 
[18:02:37.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:37.270]                   ...future.rng), globalenv = if (FALSE) 
[18:02:37.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[18:02:37.270]                     ...future.globalenv.names))
[18:02:37.270]                 else NULL, started = ...future.startTime, version = "1.8")
[18:02:37.270]         }, condition = base::local({
[18:02:37.270]             c <- base::c
[18:02:37.270]             inherits <- base::inherits
[18:02:37.270]             invokeRestart <- base::invokeRestart
[18:02:37.270]             length <- base::length
[18:02:37.270]             list <- base::list
[18:02:37.270]             seq.int <- base::seq.int
[18:02:37.270]             signalCondition <- base::signalCondition
[18:02:37.270]             sys.calls <- base::sys.calls
[18:02:37.270]             `[[` <- base::`[[`
[18:02:37.270]             `+` <- base::`+`
[18:02:37.270]             `<<-` <- base::`<<-`
[18:02:37.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[18:02:37.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[18:02:37.270]                   3L)]
[18:02:37.270]             }
[18:02:37.270]             function(cond) {
[18:02:37.270]                 is_error <- inherits(cond, "error")
[18:02:37.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[18:02:37.270]                   NULL)
[18:02:37.270]                 if (is_error) {
[18:02:37.270]                   sessionInformation <- function() {
[18:02:37.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[18:02:37.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[18:02:37.270]                       search = base::search(), system = base::Sys.info())
[18:02:37.270]                   }
[18:02:37.270]                   ...future.conditions[[length(...future.conditions) + 
[18:02:37.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[18:02:37.270]                     cond$call), session = sessionInformation(), 
[18:02:37.270]                     timestamp = base::Sys.time(), signaled = 0L)
[18:02:37.270]                   signalCondition(cond)
[18:02:37.270]                 }
[18:02:37.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[18:02:37.270]                 "immediateCondition"))) {
[18:02:37.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[18:02:37.270]                   ...future.conditions[[length(...future.conditions) + 
[18:02:37.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[18:02:37.270]                   if (TRUE && !signal) {
[18:02:37.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:37.270]                     {
[18:02:37.270]                       inherits <- base::inherits
[18:02:37.270]                       invokeRestart <- base::invokeRestart
[18:02:37.270]                       is.null <- base::is.null
[18:02:37.270]                       muffled <- FALSE
[18:02:37.270]                       if (inherits(cond, "message")) {
[18:02:37.270]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:37.270]                         if (muffled) 
[18:02:37.270]                           invokeRestart("muffleMessage")
[18:02:37.270]                       }
[18:02:37.270]                       else if (inherits(cond, "warning")) {
[18:02:37.270]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:37.270]                         if (muffled) 
[18:02:37.270]                           invokeRestart("muffleWarning")
[18:02:37.270]                       }
[18:02:37.270]                       else if (inherits(cond, "condition")) {
[18:02:37.270]                         if (!is.null(pattern)) {
[18:02:37.270]                           computeRestarts <- base::computeRestarts
[18:02:37.270]                           grepl <- base::grepl
[18:02:37.270]                           restarts <- computeRestarts(cond)
[18:02:37.270]                           for (restart in restarts) {
[18:02:37.270]                             name <- restart$name
[18:02:37.270]                             if (is.null(name)) 
[18:02:37.270]                               next
[18:02:37.270]                             if (!grepl(pattern, name)) 
[18:02:37.270]                               next
[18:02:37.270]                             invokeRestart(restart)
[18:02:37.270]                             muffled <- TRUE
[18:02:37.270]                             break
[18:02:37.270]                           }
[18:02:37.270]                         }
[18:02:37.270]                       }
[18:02:37.270]                       invisible(muffled)
[18:02:37.270]                     }
[18:02:37.270]                     muffleCondition(cond, pattern = "^muffle")
[18:02:37.270]                   }
[18:02:37.270]                 }
[18:02:37.270]                 else {
[18:02:37.270]                   if (TRUE) {
[18:02:37.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[18:02:37.270]                     {
[18:02:37.270]                       inherits <- base::inherits
[18:02:37.270]                       invokeRestart <- base::invokeRestart
[18:02:37.270]                       is.null <- base::is.null
[18:02:37.270]                       muffled <- FALSE
[18:02:37.270]                       if (inherits(cond, "message")) {
[18:02:37.270]                         muffled <- grepl(pattern, "muffleMessage")
[18:02:37.270]                         if (muffled) 
[18:02:37.270]                           invokeRestart("muffleMessage")
[18:02:37.270]                       }
[18:02:37.270]                       else if (inherits(cond, "warning")) {
[18:02:37.270]                         muffled <- grepl(pattern, "muffleWarning")
[18:02:37.270]                         if (muffled) 
[18:02:37.270]                           invokeRestart("muffleWarning")
[18:02:37.270]                       }
[18:02:37.270]                       else if (inherits(cond, "condition")) {
[18:02:37.270]                         if (!is.null(pattern)) {
[18:02:37.270]                           computeRestarts <- base::computeRestarts
[18:02:37.270]                           grepl <- base::grepl
[18:02:37.270]                           restarts <- computeRestarts(cond)
[18:02:37.270]                           for (restart in restarts) {
[18:02:37.270]                             name <- restart$name
[18:02:37.270]                             if (is.null(name)) 
[18:02:37.270]                               next
[18:02:37.270]                             if (!grepl(pattern, name)) 
[18:02:37.270]                               next
[18:02:37.270]                             invokeRestart(restart)
[18:02:37.270]                             muffled <- TRUE
[18:02:37.270]                             break
[18:02:37.270]                           }
[18:02:37.270]                         }
[18:02:37.270]                       }
[18:02:37.270]                       invisible(muffled)
[18:02:37.270]                     }
[18:02:37.270]                     muffleCondition(cond, pattern = "^muffle")
[18:02:37.270]                   }
[18:02:37.270]                 }
[18:02:37.270]             }
[18:02:37.270]         }))
[18:02:37.270]     }, error = function(ex) {
[18:02:37.270]         base::structure(base::list(value = NULL, visible = NULL, 
[18:02:37.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[18:02:37.270]                 ...future.rng), started = ...future.startTime, 
[18:02:37.270]             finished = Sys.time(), session_uuid = NA_character_, 
[18:02:37.270]             version = "1.8"), class = "FutureResult")
[18:02:37.270]     }, finally = {
[18:02:37.270]         if (!identical(...future.workdir, getwd())) 
[18:02:37.270]             setwd(...future.workdir)
[18:02:37.270]         {
[18:02:37.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[18:02:37.270]                 ...future.oldOptions$nwarnings <- NULL
[18:02:37.270]             }
[18:02:37.270]             base::options(...future.oldOptions)
[18:02:37.270]             if (.Platform$OS.type == "windows") {
[18:02:37.270]                 old_names <- names(...future.oldEnvVars)
[18:02:37.270]                 envs <- base::Sys.getenv()
[18:02:37.270]                 names <- names(envs)
[18:02:37.270]                 common <- intersect(names, old_names)
[18:02:37.270]                 added <- setdiff(names, old_names)
[18:02:37.270]                 removed <- setdiff(old_names, names)
[18:02:37.270]                 changed <- common[...future.oldEnvVars[common] != 
[18:02:37.270]                   envs[common]]
[18:02:37.270]                 NAMES <- toupper(changed)
[18:02:37.270]                 args <- list()
[18:02:37.270]                 for (kk in seq_along(NAMES)) {
[18:02:37.270]                   name <- changed[[kk]]
[18:02:37.270]                   NAME <- NAMES[[kk]]
[18:02:37.270]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:37.270]                     next
[18:02:37.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:37.270]                 }
[18:02:37.270]                 NAMES <- toupper(added)
[18:02:37.270]                 for (kk in seq_along(NAMES)) {
[18:02:37.270]                   name <- added[[kk]]
[18:02:37.270]                   NAME <- NAMES[[kk]]
[18:02:37.270]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:37.270]                     next
[18:02:37.270]                   args[[name]] <- ""
[18:02:37.270]                 }
[18:02:37.270]                 NAMES <- toupper(removed)
[18:02:37.270]                 for (kk in seq_along(NAMES)) {
[18:02:37.270]                   name <- removed[[kk]]
[18:02:37.270]                   NAME <- NAMES[[kk]]
[18:02:37.270]                   if (name != NAME && is.element(NAME, old_names)) 
[18:02:37.270]                     next
[18:02:37.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[18:02:37.270]                 }
[18:02:37.270]                 if (length(args) > 0) 
[18:02:37.270]                   base::do.call(base::Sys.setenv, args = args)
[18:02:37.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[18:02:37.270]             }
[18:02:37.270]             else {
[18:02:37.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[18:02:37.270]             }
[18:02:37.270]             {
[18:02:37.270]                 if (base::length(...future.futureOptionsAdded) > 
[18:02:37.270]                   0L) {
[18:02:37.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[18:02:37.270]                   base::names(opts) <- ...future.futureOptionsAdded
[18:02:37.270]                   base::options(opts)
[18:02:37.270]                 }
[18:02:37.270]                 {
[18:02:37.270]                   {
[18:02:37.270]                     base::options(mc.cores = ...future.mc.cores.old)
[18:02:37.270]                     NULL
[18:02:37.270]                   }
[18:02:37.270]                   options(future.plan = NULL)
[18:02:37.270]                   if (is.na(NA_character_)) 
[18:02:37.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[18:02:37.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[18:02:37.270]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[18:02:37.270]                     .init = FALSE)
[18:02:37.270]                 }
[18:02:37.270]             }
[18:02:37.270]         }
[18:02:37.270]     })
[18:02:37.270]     if (FALSE) {
[18:02:37.270]         base::sink(type = "output", split = FALSE)
[18:02:37.270]         if (NA) {
[18:02:37.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[18:02:37.270]         }
[18:02:37.270]         else {
[18:02:37.270]             ...future.result["stdout"] <- base::list(NULL)
[18:02:37.270]         }
[18:02:37.270]         base::close(...future.stdout)
[18:02:37.270]         ...future.stdout <- NULL
[18:02:37.270]     }
[18:02:37.270]     ...future.result$conditions <- ...future.conditions
[18:02:37.270]     ...future.result$finished <- base::Sys.time()
[18:02:37.270]     ...future.result
[18:02:37.270] }
[18:02:37.276] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[18:02:37.277] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[18:02:37.277] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[18:02:37.278] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[18:02:37.279] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[18:02:37.279] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[18:02:37.280] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[18:02:37.280] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[18:02:37.281] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[18:02:37.282] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[18:02:37.282] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[18:02:37.283] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[18:02:37.284] MultisessionFuture started
[18:02:37.285] - Launch lazy future ... done
[18:02:37.285] run() for ‘MultisessionFuture’ ... done
[18:02:37.285] Created future:
[18:02:37.285] MultisessionFuture:
[18:02:37.285] Label: ‘future_mapply-2’
[18:02:37.285] Expression:
[18:02:37.285] {
[18:02:37.285]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[18:02:37.285]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[18:02:37.285]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[18:02:37.285]         on.exit(options(oopts), add = TRUE)
[18:02:37.285]     }
[18:02:37.285]     {
[18:02:37.285]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[18:02:37.285]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[18:02:37.285]         do.call(mapply, args = args)
[18:02:37.285]     }
[18:02:37.285] }
[18:02:37.285] Lazy evaluation: FALSE
[18:02:37.285] Asynchronous evaluation: TRUE
[18:02:37.285] Local evaluation: TRUE
[18:02:37.285] Environment: R_GlobalEnv
[18:02:37.285] Capture standard output: NA
[18:02:37.285] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[18:02:37.285] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[18:02:37.285] Packages: <none>
[18:02:37.285] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[18:02:37.285] Resolved: FALSE
[18:02:37.285] Value: <not collected>
[18:02:37.285] Conditions captured: <none>
[18:02:37.285] Early signaling: FALSE
[18:02:37.285] Owner process: 0786f081-f131-a37a-6562-c3e7a47f4208
[18:02:37.285] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[18:02:37.298] Chunk #2 of 2 ... DONE
[18:02:37.299] Launching 2 futures (chunks) ... DONE
[18:02:37.299] Resolving 2 futures (chunks) ...
[18:02:37.299] resolve() on list ...
[18:02:37.299]  recursive: 0
[18:02:37.299]  length: 2
[18:02:37.300] 
[18:02:37.344] receiveMessageFromWorker() for ClusterFuture ...
[18:02:37.344] - Validating connection of MultisessionFuture
[18:02:37.345] - received message: FutureResult
[18:02:37.345] - Received FutureResult
[18:02:37.345] - Erased future from FutureRegistry
[18:02:37.345] result() for ClusterFuture ...
[18:02:37.346] - result already collected: FutureResult
[18:02:37.346] result() for ClusterFuture ... done
[18:02:37.346] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:37.346] Future #2
[18:02:37.346] result() for ClusterFuture ...
[18:02:37.347] - result already collected: FutureResult
[18:02:37.347] result() for ClusterFuture ... done
[18:02:37.347] result() for ClusterFuture ...
[18:02:37.347] - result already collected: FutureResult
[18:02:37.347] result() for ClusterFuture ... done
[18:02:37.348] signalConditionsASAP(MultisessionFuture, pos=2) ...
[18:02:37.348] - nx: 2
[18:02:37.348] - relay: TRUE
[18:02:37.348] - stdout: TRUE
[18:02:37.349] - signal: TRUE
[18:02:37.349] - resignal: FALSE
[18:02:37.349] - force: TRUE
[18:02:37.349] - relayed: [n=2] FALSE, FALSE
[18:02:37.349] - queued futures: [n=2] FALSE, FALSE
[18:02:37.350]  - until=1
[18:02:37.350]  - relaying element #1
[18:02:37.350] - relayed: [n=2] FALSE, FALSE
[18:02:37.350] - queued futures: [n=2] FALSE, TRUE
[18:02:37.350] signalConditionsASAP(NULL, pos=2) ... done
[18:02:37.351]  length: 1 (resolved future 2)
[18:02:37.753] receiveMessageFromWorker() for ClusterFuture ...
[18:02:37.754] - Validating connection of MultisessionFuture
[18:02:37.754] - received message: FutureResult
[18:02:37.755] - Received FutureResult
[18:02:37.755] - Erased future from FutureRegistry
[18:02:37.756] result() for ClusterFuture ...
[18:02:37.756] - result already collected: FutureResult
[18:02:37.756] result() for ClusterFuture ... done
[18:02:37.756] receiveMessageFromWorker() for ClusterFuture ... done
[18:02:37.757] Future #1
[18:02:37.757] result() for ClusterFuture ...
[18:02:37.757] - result already collected: FutureResult
[18:02:37.758] result() for ClusterFuture ... done
[18:02:37.758] result() for ClusterFuture ...
[18:02:37.758] - result already collected: FutureResult
[18:02:37.759] result() for ClusterFuture ... done
[18:02:37.759] signalConditionsASAP(MultisessionFuture, pos=1) ...
[18:02:37.759] - nx: 2
[18:02:37.760] - relay: TRUE
[18:02:37.760] - stdout: TRUE
[18:02:37.761] - signal: TRUE
[18:02:37.761] - resignal: FALSE
[18:02:37.761] - force: TRUE
[18:02:37.761] - relayed: [n=2] FALSE, FALSE
[18:02:37.762] - queued futures: [n=2] FALSE, TRUE
[18:02:37.762]  - until=1
[18:02:37.762]  - relaying element #1
[18:02:37.763] result() for ClusterFuture ...
[18:02:37.763] - result already collected: FutureResult
[18:02:37.763] result() for ClusterFuture ... done
[18:02:37.764] result() for ClusterFuture ...
[18:02:37.764] - result already collected: FutureResult
[18:02:37.764] result() for ClusterFuture ... done
[18:02:37.765] result() for ClusterFuture ...
[18:02:37.765] - result already collected: FutureResult
[18:02:37.765] result() for ClusterFuture ... done
[18:02:37.766] result() for ClusterFuture ...
[18:02:37.766] - result already collected: FutureResult
[18:02:37.766] result() for ClusterFuture ... done
[18:02:37.766] - relayed: [n=2] TRUE, FALSE
[18:02:37.767] - queued futures: [n=2] TRUE, TRUE
[18:02:37.767] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[18:02:37.767]  length: 0 (resolved future 1)
[18:02:37.768] Relaying remaining futures
[18:02:37.768] signalConditionsASAP(NULL, pos=0) ...
[18:02:37.768] - nx: 2
[18:02:37.769] - relay: TRUE
[18:02:37.769] - stdout: TRUE
[18:02:37.769] - signal: TRUE
[18:02:37.769] - resignal: FALSE
[18:02:37.770] - force: TRUE
[18:02:37.770] - relayed: [n=2] TRUE, FALSE
[18:02:37.770] - queued futures: [n=2] TRUE, TRUE
 - flush all
[18:02:37.771]  - relaying element #2
[18:02:37.771] result() for ClusterFuture ...
[18:02:37.771] - result already collected: FutureResult
[18:02:37.772] result() for ClusterFuture ... done
[18:02:37.776] result() for ClusterFuture ...
[18:02:37.776] - result already collected: FutureResult
[18:02:37.776] result() for ClusterFuture ... done
[18:02:37.777] result() for ClusterFuture ...
[18:02:37.777] - result already collected: FutureResult
[18:02:37.777] result() for ClusterFuture ... done
[18:02:37.778] result() for ClusterFuture ...
[18:02:37.778] - result already collected: FutureResult
[18:02:37.778] result() for ClusterFuture ... done
[18:02:37.778] - relayed: [n=2] TRUE, TRUE
[18:02:37.779] - queued futures: [n=2] TRUE, TRUE
[18:02:37.779] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[18:02:37.779] resolve() on list ... DONE
[18:02:37.780] result() for ClusterFuture ...
[18:02:37.780] - result already collected: FutureResult
[18:02:37.780] result() for ClusterFuture ... done
[18:02:37.781] result() for ClusterFuture ...
[18:02:37.781] - result already collected: FutureResult
[18:02:37.781] result() for ClusterFuture ... done
[18:02:37.782] result() for ClusterFuture ...
[18:02:37.782] - result already collected: FutureResult
[18:02:37.782] result() for ClusterFuture ... done
[18:02:37.782] result() for ClusterFuture ...
[18:02:37.783] - result already collected: FutureResult
[18:02:37.783] result() for ClusterFuture ... done
[18:02:37.783]  - Number of value chunks collected: 2
[18:02:37.784] Resolving 2 futures (chunks) ... DONE
[18:02:37.784] Reducing values from 2 chunks ...
[18:02:37.784]  - Number of values collected after concatenation: 2
[18:02:37.785]  - Number of values expected: 2
[18:02:37.785] Reducing values from 2 chunks ... DONE
[18:02:37.785] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[18:02:37.788] plan(): Setting new future strategy stack:
[18:02:37.788] List of future strategies:
[18:02:37.788] 1. FutureStrategy:
[18:02:37.788]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[18:02:37.788]    - tweaked: FALSE
[18:02:37.788]    - call: future::plan(oplan)
[18:02:37.790] plan(): nbrOfWorkers() = 1
> 
