
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:59:37.781] plan(): Setting new future strategy stack:
[16:59:37.782] List of future strategies:
[16:59:37.782] 1. sequential:
[16:59:37.782]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:37.782]    - tweaked: FALSE
[16:59:37.782]    - call: future::plan("sequential")
[16:59:37.796] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[16:59:37.818] plan(): Setting new future strategy stack:
[16:59:37.818] List of future strategies:
[16:59:37.818] 1. sequential:
[16:59:37.818]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:37.818]    - tweaked: FALSE
[16:59:37.818]    - call: plan(strategy)
[16:59:37.831] plan(): nbrOfWorkers() = 1
[16:59:37.831] future_lapply() ...
[16:59:37.835] Number of chunks: 1
[16:59:37.836] getGlobalsAndPackagesXApply() ...
[16:59:37.836]  - future.globals: TRUE
[16:59:37.836] getGlobalsAndPackages() ...
[16:59:37.836] Searching for globals...
[16:59:37.838] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:37.839] Searching for globals ... DONE
[16:59:37.839] Resolving globals: FALSE
[16:59:37.840] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:37.840] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:37.840] - globals: [1] ‘FUN’
[16:59:37.840] 
[16:59:37.840] getGlobalsAndPackages() ... DONE
[16:59:37.841]  - globals found/used: [n=1] ‘FUN’
[16:59:37.841]  - needed namespaces: [n=0] 
[16:59:37.841] Finding globals ... DONE
[16:59:37.841]  - use_args: TRUE
[16:59:37.841]  - Getting '...' globals ...
[16:59:37.842] resolve() on list ...
[16:59:37.842]  recursive: 0
[16:59:37.842]  length: 1
[16:59:37.842]  elements: ‘...’
[16:59:37.842]  length: 0 (resolved future 1)
[16:59:37.842] resolve() on list ... DONE
[16:59:37.842]    - '...' content: [n=0] 
[16:59:37.843] List of 1
[16:59:37.843]  $ ...: list()
[16:59:37.843]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.843]  - attr(*, "where")=List of 1
[16:59:37.843]   ..$ ...:<environment: 0x55c3468b1d78> 
[16:59:37.843]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.843]  - attr(*, "resolved")= logi TRUE
[16:59:37.843]  - attr(*, "total_size")= num NA
[16:59:37.847]  - Getting '...' globals ... DONE
[16:59:37.847] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:37.847] List of 2
[16:59:37.847]  $ ...future.FUN:function (x, ...)  
[16:59:37.847]  $ ...          : list()
[16:59:37.847]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.847]  - attr(*, "where")=List of 2
[16:59:37.847]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:37.847]   ..$ ...          :<environment: 0x55c3468b1d78> 
[16:59:37.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.847]  - attr(*, "resolved")= logi FALSE
[16:59:37.847]  - attr(*, "total_size")= num 1240
[16:59:37.850] Packages to be attached in all futures: [n=0] 
[16:59:37.850] getGlobalsAndPackagesXApply() ... DONE
[16:59:37.850] Number of futures (= number of chunks): 1
[16:59:37.851] Launching 1 futures (chunks) ...
[16:59:37.851] Chunk #1 of 1 ...
[16:59:37.851]  - Finding globals in 'X' for chunk #1 ...
[16:59:37.851] getGlobalsAndPackages() ...
[16:59:37.851] Searching for globals...
[16:59:37.851] 
[16:59:37.851] Searching for globals ... DONE
[16:59:37.852] - globals: [0] <none>
[16:59:37.852] getGlobalsAndPackages() ... DONE
[16:59:37.852]    + additional globals found: [n=0] 
[16:59:37.852]    + additional namespaces needed: [n=0] 
[16:59:37.852]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:37.852]  - seeds: <none>
[16:59:37.852]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.852] getGlobalsAndPackages() ...
[16:59:37.852] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.852] Resolving globals: FALSE
[16:59:37.853] Tweak future expression to call with '...' arguments ...
[16:59:37.853] {
[16:59:37.853]     do.call(function(...) {
[16:59:37.853]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.853]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.853]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.853]             on.exit(options(oopts), add = TRUE)
[16:59:37.853]         }
[16:59:37.853]         {
[16:59:37.853]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.853]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.853]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.853]             })
[16:59:37.853]         }
[16:59:37.853]     }, args = future.call.arguments)
[16:59:37.853] }
[16:59:37.853] Tweak future expression to call with '...' arguments ... DONE
[16:59:37.853] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.853] 
[16:59:37.853] getGlobalsAndPackages() ... DONE
[16:59:37.854] run() for ‘Future’ ...
[16:59:37.854] - state: ‘created’
[16:59:37.854] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:37.855] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:37.855] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:37.855]   - Field: ‘label’
[16:59:37.855]   - Field: ‘local’
[16:59:37.855]   - Field: ‘owner’
[16:59:37.855]   - Field: ‘envir’
[16:59:37.855]   - Field: ‘packages’
[16:59:37.855]   - Field: ‘gc’
[16:59:37.856]   - Field: ‘conditions’
[16:59:37.856]   - Field: ‘expr’
[16:59:37.856]   - Field: ‘uuid’
[16:59:37.856]   - Field: ‘seed’
[16:59:37.856]   - Field: ‘version’
[16:59:37.856]   - Field: ‘result’
[16:59:37.856]   - Field: ‘asynchronous’
[16:59:37.856]   - Field: ‘calls’
[16:59:37.856]   - Field: ‘globals’
[16:59:37.856]   - Field: ‘stdout’
[16:59:37.856]   - Field: ‘earlySignal’
[16:59:37.857]   - Field: ‘lazy’
[16:59:37.857]   - Field: ‘state’
[16:59:37.857] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:37.857] - Launch lazy future ...
[16:59:37.858] Packages needed by the future expression (n = 0): <none>
[16:59:37.858] Packages needed by future strategies (n = 0): <none>
[16:59:37.858] {
[16:59:37.858]     {
[16:59:37.858]         {
[16:59:37.858]             ...future.startTime <- base::Sys.time()
[16:59:37.858]             {
[16:59:37.858]                 {
[16:59:37.858]                   {
[16:59:37.858]                     base::local({
[16:59:37.858]                       has_future <- base::requireNamespace("future", 
[16:59:37.858]                         quietly = TRUE)
[16:59:37.858]                       if (has_future) {
[16:59:37.858]                         ns <- base::getNamespace("future")
[16:59:37.858]                         version <- ns[[".package"]][["version"]]
[16:59:37.858]                         if (is.null(version)) 
[16:59:37.858]                           version <- utils::packageVersion("future")
[16:59:37.858]                       }
[16:59:37.858]                       else {
[16:59:37.858]                         version <- NULL
[16:59:37.858]                       }
[16:59:37.858]                       if (!has_future || version < "1.8.0") {
[16:59:37.858]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:37.858]                           "", base::R.version$version.string), 
[16:59:37.858]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:37.858]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:37.858]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:37.858]                             "release", "version")], collapse = " "), 
[16:59:37.858]                           hostname = base::Sys.info()[["nodename"]])
[16:59:37.858]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:37.858]                           info)
[16:59:37.858]                         info <- base::paste(info, collapse = "; ")
[16:59:37.858]                         if (!has_future) {
[16:59:37.858]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:37.858]                             info)
[16:59:37.858]                         }
[16:59:37.858]                         else {
[16:59:37.858]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:37.858]                             info, version)
[16:59:37.858]                         }
[16:59:37.858]                         base::stop(msg)
[16:59:37.858]                       }
[16:59:37.858]                     })
[16:59:37.858]                   }
[16:59:37.858]                   ...future.strategy.old <- future::plan("list")
[16:59:37.858]                   options(future.plan = NULL)
[16:59:37.858]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.858]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:37.858]                 }
[16:59:37.858]                 ...future.workdir <- getwd()
[16:59:37.858]             }
[16:59:37.858]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:37.858]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:37.858]         }
[16:59:37.858]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:37.858]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:37.858]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:37.858]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:37.858]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:37.858]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:37.858]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:37.858]             base::names(...future.oldOptions))
[16:59:37.858]     }
[16:59:37.858]     if (FALSE) {
[16:59:37.858]     }
[16:59:37.858]     else {
[16:59:37.858]         if (TRUE) {
[16:59:37.858]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:37.858]                 open = "w")
[16:59:37.858]         }
[16:59:37.858]         else {
[16:59:37.858]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:37.858]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:37.858]         }
[16:59:37.858]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:37.858]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:37.858]             base::sink(type = "output", split = FALSE)
[16:59:37.858]             base::close(...future.stdout)
[16:59:37.858]         }, add = TRUE)
[16:59:37.858]     }
[16:59:37.858]     ...future.frame <- base::sys.nframe()
[16:59:37.858]     ...future.conditions <- base::list()
[16:59:37.858]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:37.858]     if (FALSE) {
[16:59:37.858]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:37.858]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:37.858]     }
[16:59:37.858]     ...future.result <- base::tryCatch({
[16:59:37.858]         base::withCallingHandlers({
[16:59:37.858]             ...future.value <- base::withVisible(base::local({
[16:59:37.858]                 do.call(function(...) {
[16:59:37.858]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.858]                   if (!identical(...future.globals.maxSize.org, 
[16:59:37.858]                     ...future.globals.maxSize)) {
[16:59:37.858]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.858]                     on.exit(options(oopts), add = TRUE)
[16:59:37.858]                   }
[16:59:37.858]                   {
[16:59:37.858]                     lapply(seq_along(...future.elements_ii), 
[16:59:37.858]                       FUN = function(jj) {
[16:59:37.858]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.858]                         ...future.FUN(...future.X_jj, ...)
[16:59:37.858]                       })
[16:59:37.858]                   }
[16:59:37.858]                 }, args = future.call.arguments)
[16:59:37.858]             }))
[16:59:37.858]             future::FutureResult(value = ...future.value$value, 
[16:59:37.858]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.858]                   ...future.rng), globalenv = if (FALSE) 
[16:59:37.858]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:37.858]                     ...future.globalenv.names))
[16:59:37.858]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:37.858]         }, condition = base::local({
[16:59:37.858]             c <- base::c
[16:59:37.858]             inherits <- base::inherits
[16:59:37.858]             invokeRestart <- base::invokeRestart
[16:59:37.858]             length <- base::length
[16:59:37.858]             list <- base::list
[16:59:37.858]             seq.int <- base::seq.int
[16:59:37.858]             signalCondition <- base::signalCondition
[16:59:37.858]             sys.calls <- base::sys.calls
[16:59:37.858]             `[[` <- base::`[[`
[16:59:37.858]             `+` <- base::`+`
[16:59:37.858]             `<<-` <- base::`<<-`
[16:59:37.858]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:37.858]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:37.858]                   3L)]
[16:59:37.858]             }
[16:59:37.858]             function(cond) {
[16:59:37.858]                 is_error <- inherits(cond, "error")
[16:59:37.858]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:37.858]                   NULL)
[16:59:37.858]                 if (is_error) {
[16:59:37.858]                   sessionInformation <- function() {
[16:59:37.858]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:37.858]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:37.858]                       search = base::search(), system = base::Sys.info())
[16:59:37.858]                   }
[16:59:37.858]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.858]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:37.858]                     cond$call), session = sessionInformation(), 
[16:59:37.858]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:37.858]                   signalCondition(cond)
[16:59:37.858]                 }
[16:59:37.858]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:37.858]                 "immediateCondition"))) {
[16:59:37.858]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:37.858]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.858]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:37.858]                   if (TRUE && !signal) {
[16:59:37.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.858]                     {
[16:59:37.858]                       inherits <- base::inherits
[16:59:37.858]                       invokeRestart <- base::invokeRestart
[16:59:37.858]                       is.null <- base::is.null
[16:59:37.858]                       muffled <- FALSE
[16:59:37.858]                       if (inherits(cond, "message")) {
[16:59:37.858]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.858]                         if (muffled) 
[16:59:37.858]                           invokeRestart("muffleMessage")
[16:59:37.858]                       }
[16:59:37.858]                       else if (inherits(cond, "warning")) {
[16:59:37.858]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.858]                         if (muffled) 
[16:59:37.858]                           invokeRestart("muffleWarning")
[16:59:37.858]                       }
[16:59:37.858]                       else if (inherits(cond, "condition")) {
[16:59:37.858]                         if (!is.null(pattern)) {
[16:59:37.858]                           computeRestarts <- base::computeRestarts
[16:59:37.858]                           grepl <- base::grepl
[16:59:37.858]                           restarts <- computeRestarts(cond)
[16:59:37.858]                           for (restart in restarts) {
[16:59:37.858]                             name <- restart$name
[16:59:37.858]                             if (is.null(name)) 
[16:59:37.858]                               next
[16:59:37.858]                             if (!grepl(pattern, name)) 
[16:59:37.858]                               next
[16:59:37.858]                             invokeRestart(restart)
[16:59:37.858]                             muffled <- TRUE
[16:59:37.858]                             break
[16:59:37.858]                           }
[16:59:37.858]                         }
[16:59:37.858]                       }
[16:59:37.858]                       invisible(muffled)
[16:59:37.858]                     }
[16:59:37.858]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.858]                   }
[16:59:37.858]                 }
[16:59:37.858]                 else {
[16:59:37.858]                   if (TRUE) {
[16:59:37.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.858]                     {
[16:59:37.858]                       inherits <- base::inherits
[16:59:37.858]                       invokeRestart <- base::invokeRestart
[16:59:37.858]                       is.null <- base::is.null
[16:59:37.858]                       muffled <- FALSE
[16:59:37.858]                       if (inherits(cond, "message")) {
[16:59:37.858]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.858]                         if (muffled) 
[16:59:37.858]                           invokeRestart("muffleMessage")
[16:59:37.858]                       }
[16:59:37.858]                       else if (inherits(cond, "warning")) {
[16:59:37.858]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.858]                         if (muffled) 
[16:59:37.858]                           invokeRestart("muffleWarning")
[16:59:37.858]                       }
[16:59:37.858]                       else if (inherits(cond, "condition")) {
[16:59:37.858]                         if (!is.null(pattern)) {
[16:59:37.858]                           computeRestarts <- base::computeRestarts
[16:59:37.858]                           grepl <- base::grepl
[16:59:37.858]                           restarts <- computeRestarts(cond)
[16:59:37.858]                           for (restart in restarts) {
[16:59:37.858]                             name <- restart$name
[16:59:37.858]                             if (is.null(name)) 
[16:59:37.858]                               next
[16:59:37.858]                             if (!grepl(pattern, name)) 
[16:59:37.858]                               next
[16:59:37.858]                             invokeRestart(restart)
[16:59:37.858]                             muffled <- TRUE
[16:59:37.858]                             break
[16:59:37.858]                           }
[16:59:37.858]                         }
[16:59:37.858]                       }
[16:59:37.858]                       invisible(muffled)
[16:59:37.858]                     }
[16:59:37.858]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.858]                   }
[16:59:37.858]                 }
[16:59:37.858]             }
[16:59:37.858]         }))
[16:59:37.858]     }, error = function(ex) {
[16:59:37.858]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:37.858]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.858]                 ...future.rng), started = ...future.startTime, 
[16:59:37.858]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:37.858]             version = "1.8"), class = "FutureResult")
[16:59:37.858]     }, finally = {
[16:59:37.858]         if (!identical(...future.workdir, getwd())) 
[16:59:37.858]             setwd(...future.workdir)
[16:59:37.858]         {
[16:59:37.858]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:37.858]                 ...future.oldOptions$nwarnings <- NULL
[16:59:37.858]             }
[16:59:37.858]             base::options(...future.oldOptions)
[16:59:37.858]             if (.Platform$OS.type == "windows") {
[16:59:37.858]                 old_names <- names(...future.oldEnvVars)
[16:59:37.858]                 envs <- base::Sys.getenv()
[16:59:37.858]                 names <- names(envs)
[16:59:37.858]                 common <- intersect(names, old_names)
[16:59:37.858]                 added <- setdiff(names, old_names)
[16:59:37.858]                 removed <- setdiff(old_names, names)
[16:59:37.858]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:37.858]                   envs[common]]
[16:59:37.858]                 NAMES <- toupper(changed)
[16:59:37.858]                 args <- list()
[16:59:37.858]                 for (kk in seq_along(NAMES)) {
[16:59:37.858]                   name <- changed[[kk]]
[16:59:37.858]                   NAME <- NAMES[[kk]]
[16:59:37.858]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.858]                     next
[16:59:37.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.858]                 }
[16:59:37.858]                 NAMES <- toupper(added)
[16:59:37.858]                 for (kk in seq_along(NAMES)) {
[16:59:37.858]                   name <- added[[kk]]
[16:59:37.858]                   NAME <- NAMES[[kk]]
[16:59:37.858]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.858]                     next
[16:59:37.858]                   args[[name]] <- ""
[16:59:37.858]                 }
[16:59:37.858]                 NAMES <- toupper(removed)
[16:59:37.858]                 for (kk in seq_along(NAMES)) {
[16:59:37.858]                   name <- removed[[kk]]
[16:59:37.858]                   NAME <- NAMES[[kk]]
[16:59:37.858]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.858]                     next
[16:59:37.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.858]                 }
[16:59:37.858]                 if (length(args) > 0) 
[16:59:37.858]                   base::do.call(base::Sys.setenv, args = args)
[16:59:37.858]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:37.858]             }
[16:59:37.858]             else {
[16:59:37.858]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:37.858]             }
[16:59:37.858]             {
[16:59:37.858]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:37.858]                   0L) {
[16:59:37.858]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:37.858]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:37.858]                   base::options(opts)
[16:59:37.858]                 }
[16:59:37.858]                 {
[16:59:37.858]                   {
[16:59:37.858]                     NULL
[16:59:37.858]                     RNGkind("Mersenne-Twister")
[16:59:37.858]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:37.858]                       inherits = FALSE)
[16:59:37.858]                   }
[16:59:37.858]                   options(future.plan = NULL)
[16:59:37.858]                   if (is.na(NA_character_)) 
[16:59:37.858]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.858]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:37.858]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:37.858]                     .init = FALSE)
[16:59:37.858]                 }
[16:59:37.858]             }
[16:59:37.858]         }
[16:59:37.858]     })
[16:59:37.858]     if (TRUE) {
[16:59:37.858]         base::sink(type = "output", split = FALSE)
[16:59:37.858]         if (TRUE) {
[16:59:37.858]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:37.858]         }
[16:59:37.858]         else {
[16:59:37.858]             ...future.result["stdout"] <- base::list(NULL)
[16:59:37.858]         }
[16:59:37.858]         base::close(...future.stdout)
[16:59:37.858]         ...future.stdout <- NULL
[16:59:37.858]     }
[16:59:37.858]     ...future.result$conditions <- ...future.conditions
[16:59:37.858]     ...future.result$finished <- base::Sys.time()
[16:59:37.858]     ...future.result
[16:59:37.858] }
[16:59:37.860] assign_globals() ...
[16:59:37.860] List of 5
[16:59:37.860]  $ ...future.FUN            :function (x, ...)  
[16:59:37.860]  $ future.call.arguments    : list()
[16:59:37.860]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.860]  $ ...future.elements_ii    :List of 3
[16:59:37.860]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[16:59:37.860]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:59:37.860]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:59:37.860]  $ ...future.seeds_ii       : NULL
[16:59:37.860]  $ ...future.globals.maxSize: NULL
[16:59:37.860]  - attr(*, "where")=List of 5
[16:59:37.860]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:37.860]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:37.860]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:37.860]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:37.860]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:37.860]  - attr(*, "resolved")= logi FALSE
[16:59:37.860]  - attr(*, "total_size")= num 1240
[16:59:37.860]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.860]  - attr(*, "already-done")= logi TRUE
[16:59:37.868] - copied ‘...future.FUN’ to environment
[16:59:37.868] - copied ‘future.call.arguments’ to environment
[16:59:37.868] - copied ‘...future.elements_ii’ to environment
[16:59:37.869] - copied ‘...future.seeds_ii’ to environment
[16:59:37.869] - copied ‘...future.globals.maxSize’ to environment
[16:59:37.869] assign_globals() ... done
[16:59:37.869] plan(): Setting new future strategy stack:
[16:59:37.869] List of future strategies:
[16:59:37.869] 1. sequential:
[16:59:37.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:37.869]    - tweaked: FALSE
[16:59:37.869]    - call: NULL
[16:59:37.870] plan(): nbrOfWorkers() = 1
[16:59:37.871] plan(): Setting new future strategy stack:
[16:59:37.871] List of future strategies:
[16:59:37.871] 1. sequential:
[16:59:37.871]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:37.871]    - tweaked: FALSE
[16:59:37.871]    - call: plan(strategy)
[16:59:37.871] plan(): nbrOfWorkers() = 1
[16:59:37.872] SequentialFuture started (and completed)
[16:59:37.872] - Launch lazy future ... done
[16:59:37.872] run() for ‘SequentialFuture’ ... done
[16:59:37.872] Created future:
[16:59:37.872] SequentialFuture:
[16:59:37.872] Label: ‘future_eapply-1’
[16:59:37.872] Expression:
[16:59:37.872] {
[16:59:37.872]     do.call(function(...) {
[16:59:37.872]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.872]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.872]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.872]             on.exit(options(oopts), add = TRUE)
[16:59:37.872]         }
[16:59:37.872]         {
[16:59:37.872]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.872]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.872]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.872]             })
[16:59:37.872]         }
[16:59:37.872]     }, args = future.call.arguments)
[16:59:37.872] }
[16:59:37.872] Lazy evaluation: FALSE
[16:59:37.872] Asynchronous evaluation: FALSE
[16:59:37.872] Local evaluation: TRUE
[16:59:37.872] Environment: R_GlobalEnv
[16:59:37.872] Capture standard output: TRUE
[16:59:37.872] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:37.872] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:37.872] Packages: <none>
[16:59:37.872] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:37.872] Resolved: TRUE
[16:59:37.872] Value: 168 bytes of class ‘list’
[16:59:37.872] Early signaling: FALSE
[16:59:37.872] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:37.872] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:37.874] Chunk #1 of 1 ... DONE
[16:59:37.874] Launching 1 futures (chunks) ... DONE
[16:59:37.874] Resolving 1 futures (chunks) ...
[16:59:37.874] resolve() on list ...
[16:59:37.874]  recursive: 0
[16:59:37.874]  length: 1
[16:59:37.874] 
[16:59:37.874] resolved() for ‘SequentialFuture’ ...
[16:59:37.875] - state: ‘finished’
[16:59:37.875] - run: TRUE
[16:59:37.875] - result: ‘FutureResult’
[16:59:37.875] resolved() for ‘SequentialFuture’ ... done
[16:59:37.875] Future #1
[16:59:37.875] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:37.875] - nx: 1
[16:59:37.876] - relay: TRUE
[16:59:37.876] - stdout: TRUE
[16:59:37.876] - signal: TRUE
[16:59:37.876] - resignal: FALSE
[16:59:37.876] - force: TRUE
[16:59:37.876] - relayed: [n=1] FALSE
[16:59:37.876] - queued futures: [n=1] FALSE
[16:59:37.876]  - until=1
[16:59:37.876]  - relaying element #1
[16:59:37.876] - relayed: [n=1] TRUE
[16:59:37.876] - queued futures: [n=1] TRUE
[16:59:37.877] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:37.877]  length: 0 (resolved future 1)
[16:59:37.877] Relaying remaining futures
[16:59:37.877] signalConditionsASAP(NULL, pos=0) ...
[16:59:37.877] - nx: 1
[16:59:37.877] - relay: TRUE
[16:59:37.877] - stdout: TRUE
[16:59:37.877] - signal: TRUE
[16:59:37.877] - resignal: FALSE
[16:59:37.877] - force: TRUE
[16:59:37.877] - relayed: [n=1] TRUE
[16:59:37.878] - queued futures: [n=1] TRUE
 - flush all
[16:59:37.878] - relayed: [n=1] TRUE
[16:59:37.878] - queued futures: [n=1] TRUE
[16:59:37.878] signalConditionsASAP(NULL, pos=0) ... done
[16:59:37.878] resolve() on list ... DONE
[16:59:37.878]  - Number of value chunks collected: 1
[16:59:37.878] Resolving 1 futures (chunks) ... DONE
[16:59:37.878] Reducing values from 1 chunks ...
[16:59:37.878]  - Number of values collected after concatenation: 3
[16:59:37.878]  - Number of values expected: 3
[16:59:37.879] Reducing values from 1 chunks ... DONE
[16:59:37.879] future_lapply() ... DONE
[16:59:37.881] future_lapply() ...
[16:59:37.881] Number of chunks: 1
[16:59:37.881] getGlobalsAndPackagesXApply() ...
[16:59:37.881]  - future.globals: TRUE
[16:59:37.881] getGlobalsAndPackages() ...
[16:59:37.881] Searching for globals...
[16:59:37.882] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:37.883] Searching for globals ... DONE
[16:59:37.883] Resolving globals: FALSE
[16:59:37.883] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:59:37.883] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:59:37.883] - globals: [1] ‘FUN’
[16:59:37.884] - packages: [1] ‘stats’
[16:59:37.884] getGlobalsAndPackages() ... DONE
[16:59:37.884]  - globals found/used: [n=1] ‘FUN’
[16:59:37.884]  - needed namespaces: [n=1] ‘stats’
[16:59:37.884] Finding globals ... DONE
[16:59:37.884]  - use_args: TRUE
[16:59:37.884]  - Getting '...' globals ...
[16:59:37.884] resolve() on list ...
[16:59:37.885]  recursive: 0
[16:59:37.885]  length: 1
[16:59:37.885]  elements: ‘...’
[16:59:37.885]  length: 0 (resolved future 1)
[16:59:37.885] resolve() on list ... DONE
[16:59:37.885]    - '...' content: [n=1] ‘probs’
[16:59:37.885] List of 1
[16:59:37.885]  $ ...:List of 1
[16:59:37.885]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:59:37.885]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.885]  - attr(*, "where")=List of 1
[16:59:37.885]   ..$ ...:<environment: 0x55c34870d8f8> 
[16:59:37.885]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.885]  - attr(*, "resolved")= logi TRUE
[16:59:37.885]  - attr(*, "total_size")= num NA
[16:59:37.888]  - Getting '...' globals ... DONE
[16:59:37.888] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:37.888] List of 2
[16:59:37.888]  $ ...future.FUN:function (x, ...)  
[16:59:37.888]  $ ...          :List of 1
[16:59:37.888]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:59:37.888]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.888]  - attr(*, "where")=List of 2
[16:59:37.888]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:37.888]   ..$ ...          :<environment: 0x55c34870d8f8> 
[16:59:37.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.888]  - attr(*, "resolved")= logi FALSE
[16:59:37.888]  - attr(*, "total_size")= num 1328
[16:59:37.891] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:37.891] getGlobalsAndPackagesXApply() ... DONE
[16:59:37.891] Number of futures (= number of chunks): 1
[16:59:37.892] Launching 1 futures (chunks) ...
[16:59:37.892] Chunk #1 of 1 ...
[16:59:37.892]  - Finding globals in 'X' for chunk #1 ...
[16:59:37.892] getGlobalsAndPackages() ...
[16:59:37.892] Searching for globals...
[16:59:37.892] 
[16:59:37.892] Searching for globals ... DONE
[16:59:37.892] - globals: [0] <none>
[16:59:37.892] getGlobalsAndPackages() ... DONE
[16:59:37.893]    + additional globals found: [n=0] 
[16:59:37.894]    + additional namespaces needed: [n=0] 
[16:59:37.894]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:37.894]  - seeds: <none>
[16:59:37.895]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.895] getGlobalsAndPackages() ...
[16:59:37.895] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.895] Resolving globals: FALSE
[16:59:37.895] Tweak future expression to call with '...' arguments ...
[16:59:37.895] {
[16:59:37.895]     do.call(function(...) {
[16:59:37.895]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.895]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.895]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.895]             on.exit(options(oopts), add = TRUE)
[16:59:37.895]         }
[16:59:37.895]         {
[16:59:37.895]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.895]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.895]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.895]             })
[16:59:37.895]         }
[16:59:37.895]     }, args = future.call.arguments)
[16:59:37.895] }
[16:59:37.895] Tweak future expression to call with '...' arguments ... DONE
[16:59:37.896] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.896] - packages: [1] ‘stats’
[16:59:37.896] getGlobalsAndPackages() ... DONE
[16:59:37.896] run() for ‘Future’ ...
[16:59:37.896] - state: ‘created’
[16:59:37.896] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:37.897] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:37.897] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:37.897]   - Field: ‘label’
[16:59:37.897]   - Field: ‘local’
[16:59:37.897]   - Field: ‘owner’
[16:59:37.897]   - Field: ‘envir’
[16:59:37.897]   - Field: ‘packages’
[16:59:37.897]   - Field: ‘gc’
[16:59:37.897]   - Field: ‘conditions’
[16:59:37.898]   - Field: ‘expr’
[16:59:37.898]   - Field: ‘uuid’
[16:59:37.898]   - Field: ‘seed’
[16:59:37.898]   - Field: ‘version’
[16:59:37.898]   - Field: ‘result’
[16:59:37.898]   - Field: ‘asynchronous’
[16:59:37.898]   - Field: ‘calls’
[16:59:37.898]   - Field: ‘globals’
[16:59:37.898]   - Field: ‘stdout’
[16:59:37.898]   - Field: ‘earlySignal’
[16:59:37.898]   - Field: ‘lazy’
[16:59:37.898]   - Field: ‘state’
[16:59:37.899] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:37.899] - Launch lazy future ...
[16:59:37.899] Packages needed by the future expression (n = 1): ‘stats’
[16:59:37.899] Packages needed by future strategies (n = 0): <none>
[16:59:37.899] {
[16:59:37.899]     {
[16:59:37.899]         {
[16:59:37.899]             ...future.startTime <- base::Sys.time()
[16:59:37.899]             {
[16:59:37.899]                 {
[16:59:37.899]                   {
[16:59:37.899]                     {
[16:59:37.899]                       base::local({
[16:59:37.899]                         has_future <- base::requireNamespace("future", 
[16:59:37.899]                           quietly = TRUE)
[16:59:37.899]                         if (has_future) {
[16:59:37.899]                           ns <- base::getNamespace("future")
[16:59:37.899]                           version <- ns[[".package"]][["version"]]
[16:59:37.899]                           if (is.null(version)) 
[16:59:37.899]                             version <- utils::packageVersion("future")
[16:59:37.899]                         }
[16:59:37.899]                         else {
[16:59:37.899]                           version <- NULL
[16:59:37.899]                         }
[16:59:37.899]                         if (!has_future || version < "1.8.0") {
[16:59:37.899]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:37.899]                             "", base::R.version$version.string), 
[16:59:37.899]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:37.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:37.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:37.899]                               "release", "version")], collapse = " "), 
[16:59:37.899]                             hostname = base::Sys.info()[["nodename"]])
[16:59:37.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:37.899]                             info)
[16:59:37.899]                           info <- base::paste(info, collapse = "; ")
[16:59:37.899]                           if (!has_future) {
[16:59:37.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:37.899]                               info)
[16:59:37.899]                           }
[16:59:37.899]                           else {
[16:59:37.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:37.899]                               info, version)
[16:59:37.899]                           }
[16:59:37.899]                           base::stop(msg)
[16:59:37.899]                         }
[16:59:37.899]                       })
[16:59:37.899]                     }
[16:59:37.899]                     base::local({
[16:59:37.899]                       for (pkg in "stats") {
[16:59:37.899]                         base::loadNamespace(pkg)
[16:59:37.899]                         base::library(pkg, character.only = TRUE)
[16:59:37.899]                       }
[16:59:37.899]                     })
[16:59:37.899]                   }
[16:59:37.899]                   ...future.strategy.old <- future::plan("list")
[16:59:37.899]                   options(future.plan = NULL)
[16:59:37.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:37.899]                 }
[16:59:37.899]                 ...future.workdir <- getwd()
[16:59:37.899]             }
[16:59:37.899]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:37.899]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:37.899]         }
[16:59:37.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:37.899]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:37.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:37.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:37.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:37.899]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:37.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:37.899]             base::names(...future.oldOptions))
[16:59:37.899]     }
[16:59:37.899]     if (FALSE) {
[16:59:37.899]     }
[16:59:37.899]     else {
[16:59:37.899]         if (TRUE) {
[16:59:37.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:37.899]                 open = "w")
[16:59:37.899]         }
[16:59:37.899]         else {
[16:59:37.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:37.899]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:37.899]         }
[16:59:37.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:37.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:37.899]             base::sink(type = "output", split = FALSE)
[16:59:37.899]             base::close(...future.stdout)
[16:59:37.899]         }, add = TRUE)
[16:59:37.899]     }
[16:59:37.899]     ...future.frame <- base::sys.nframe()
[16:59:37.899]     ...future.conditions <- base::list()
[16:59:37.899]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:37.899]     if (FALSE) {
[16:59:37.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:37.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:37.899]     }
[16:59:37.899]     ...future.result <- base::tryCatch({
[16:59:37.899]         base::withCallingHandlers({
[16:59:37.899]             ...future.value <- base::withVisible(base::local({
[16:59:37.899]                 do.call(function(...) {
[16:59:37.899]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.899]                   if (!identical(...future.globals.maxSize.org, 
[16:59:37.899]                     ...future.globals.maxSize)) {
[16:59:37.899]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.899]                     on.exit(options(oopts), add = TRUE)
[16:59:37.899]                   }
[16:59:37.899]                   {
[16:59:37.899]                     lapply(seq_along(...future.elements_ii), 
[16:59:37.899]                       FUN = function(jj) {
[16:59:37.899]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.899]                         ...future.FUN(...future.X_jj, ...)
[16:59:37.899]                       })
[16:59:37.899]                   }
[16:59:37.899]                 }, args = future.call.arguments)
[16:59:37.899]             }))
[16:59:37.899]             future::FutureResult(value = ...future.value$value, 
[16:59:37.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.899]                   ...future.rng), globalenv = if (FALSE) 
[16:59:37.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:37.899]                     ...future.globalenv.names))
[16:59:37.899]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:37.899]         }, condition = base::local({
[16:59:37.899]             c <- base::c
[16:59:37.899]             inherits <- base::inherits
[16:59:37.899]             invokeRestart <- base::invokeRestart
[16:59:37.899]             length <- base::length
[16:59:37.899]             list <- base::list
[16:59:37.899]             seq.int <- base::seq.int
[16:59:37.899]             signalCondition <- base::signalCondition
[16:59:37.899]             sys.calls <- base::sys.calls
[16:59:37.899]             `[[` <- base::`[[`
[16:59:37.899]             `+` <- base::`+`
[16:59:37.899]             `<<-` <- base::`<<-`
[16:59:37.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:37.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:37.899]                   3L)]
[16:59:37.899]             }
[16:59:37.899]             function(cond) {
[16:59:37.899]                 is_error <- inherits(cond, "error")
[16:59:37.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:37.899]                   NULL)
[16:59:37.899]                 if (is_error) {
[16:59:37.899]                   sessionInformation <- function() {
[16:59:37.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:37.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:37.899]                       search = base::search(), system = base::Sys.info())
[16:59:37.899]                   }
[16:59:37.899]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:37.899]                     cond$call), session = sessionInformation(), 
[16:59:37.899]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:37.899]                   signalCondition(cond)
[16:59:37.899]                 }
[16:59:37.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:37.899]                 "immediateCondition"))) {
[16:59:37.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:37.899]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:37.899]                   if (TRUE && !signal) {
[16:59:37.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.899]                     {
[16:59:37.899]                       inherits <- base::inherits
[16:59:37.899]                       invokeRestart <- base::invokeRestart
[16:59:37.899]                       is.null <- base::is.null
[16:59:37.899]                       muffled <- FALSE
[16:59:37.899]                       if (inherits(cond, "message")) {
[16:59:37.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.899]                         if (muffled) 
[16:59:37.899]                           invokeRestart("muffleMessage")
[16:59:37.899]                       }
[16:59:37.899]                       else if (inherits(cond, "warning")) {
[16:59:37.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.899]                         if (muffled) 
[16:59:37.899]                           invokeRestart("muffleWarning")
[16:59:37.899]                       }
[16:59:37.899]                       else if (inherits(cond, "condition")) {
[16:59:37.899]                         if (!is.null(pattern)) {
[16:59:37.899]                           computeRestarts <- base::computeRestarts
[16:59:37.899]                           grepl <- base::grepl
[16:59:37.899]                           restarts <- computeRestarts(cond)
[16:59:37.899]                           for (restart in restarts) {
[16:59:37.899]                             name <- restart$name
[16:59:37.899]                             if (is.null(name)) 
[16:59:37.899]                               next
[16:59:37.899]                             if (!grepl(pattern, name)) 
[16:59:37.899]                               next
[16:59:37.899]                             invokeRestart(restart)
[16:59:37.899]                             muffled <- TRUE
[16:59:37.899]                             break
[16:59:37.899]                           }
[16:59:37.899]                         }
[16:59:37.899]                       }
[16:59:37.899]                       invisible(muffled)
[16:59:37.899]                     }
[16:59:37.899]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.899]                   }
[16:59:37.899]                 }
[16:59:37.899]                 else {
[16:59:37.899]                   if (TRUE) {
[16:59:37.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.899]                     {
[16:59:37.899]                       inherits <- base::inherits
[16:59:37.899]                       invokeRestart <- base::invokeRestart
[16:59:37.899]                       is.null <- base::is.null
[16:59:37.899]                       muffled <- FALSE
[16:59:37.899]                       if (inherits(cond, "message")) {
[16:59:37.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.899]                         if (muffled) 
[16:59:37.899]                           invokeRestart("muffleMessage")
[16:59:37.899]                       }
[16:59:37.899]                       else if (inherits(cond, "warning")) {
[16:59:37.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.899]                         if (muffled) 
[16:59:37.899]                           invokeRestart("muffleWarning")
[16:59:37.899]                       }
[16:59:37.899]                       else if (inherits(cond, "condition")) {
[16:59:37.899]                         if (!is.null(pattern)) {
[16:59:37.899]                           computeRestarts <- base::computeRestarts
[16:59:37.899]                           grepl <- base::grepl
[16:59:37.899]                           restarts <- computeRestarts(cond)
[16:59:37.899]                           for (restart in restarts) {
[16:59:37.899]                             name <- restart$name
[16:59:37.899]                             if (is.null(name)) 
[16:59:37.899]                               next
[16:59:37.899]                             if (!grepl(pattern, name)) 
[16:59:37.899]                               next
[16:59:37.899]                             invokeRestart(restart)
[16:59:37.899]                             muffled <- TRUE
[16:59:37.899]                             break
[16:59:37.899]                           }
[16:59:37.899]                         }
[16:59:37.899]                       }
[16:59:37.899]                       invisible(muffled)
[16:59:37.899]                     }
[16:59:37.899]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.899]                   }
[16:59:37.899]                 }
[16:59:37.899]             }
[16:59:37.899]         }))
[16:59:37.899]     }, error = function(ex) {
[16:59:37.899]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:37.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.899]                 ...future.rng), started = ...future.startTime, 
[16:59:37.899]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:37.899]             version = "1.8"), class = "FutureResult")
[16:59:37.899]     }, finally = {
[16:59:37.899]         if (!identical(...future.workdir, getwd())) 
[16:59:37.899]             setwd(...future.workdir)
[16:59:37.899]         {
[16:59:37.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:37.899]                 ...future.oldOptions$nwarnings <- NULL
[16:59:37.899]             }
[16:59:37.899]             base::options(...future.oldOptions)
[16:59:37.899]             if (.Platform$OS.type == "windows") {
[16:59:37.899]                 old_names <- names(...future.oldEnvVars)
[16:59:37.899]                 envs <- base::Sys.getenv()
[16:59:37.899]                 names <- names(envs)
[16:59:37.899]                 common <- intersect(names, old_names)
[16:59:37.899]                 added <- setdiff(names, old_names)
[16:59:37.899]                 removed <- setdiff(old_names, names)
[16:59:37.899]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:37.899]                   envs[common]]
[16:59:37.899]                 NAMES <- toupper(changed)
[16:59:37.899]                 args <- list()
[16:59:37.899]                 for (kk in seq_along(NAMES)) {
[16:59:37.899]                   name <- changed[[kk]]
[16:59:37.899]                   NAME <- NAMES[[kk]]
[16:59:37.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.899]                     next
[16:59:37.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.899]                 }
[16:59:37.899]                 NAMES <- toupper(added)
[16:59:37.899]                 for (kk in seq_along(NAMES)) {
[16:59:37.899]                   name <- added[[kk]]
[16:59:37.899]                   NAME <- NAMES[[kk]]
[16:59:37.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.899]                     next
[16:59:37.899]                   args[[name]] <- ""
[16:59:37.899]                 }
[16:59:37.899]                 NAMES <- toupper(removed)
[16:59:37.899]                 for (kk in seq_along(NAMES)) {
[16:59:37.899]                   name <- removed[[kk]]
[16:59:37.899]                   NAME <- NAMES[[kk]]
[16:59:37.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.899]                     next
[16:59:37.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.899]                 }
[16:59:37.899]                 if (length(args) > 0) 
[16:59:37.899]                   base::do.call(base::Sys.setenv, args = args)
[16:59:37.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:37.899]             }
[16:59:37.899]             else {
[16:59:37.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:37.899]             }
[16:59:37.899]             {
[16:59:37.899]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:37.899]                   0L) {
[16:59:37.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:37.899]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:37.899]                   base::options(opts)
[16:59:37.899]                 }
[16:59:37.899]                 {
[16:59:37.899]                   {
[16:59:37.899]                     NULL
[16:59:37.899]                     RNGkind("Mersenne-Twister")
[16:59:37.899]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:37.899]                       inherits = FALSE)
[16:59:37.899]                   }
[16:59:37.899]                   options(future.plan = NULL)
[16:59:37.899]                   if (is.na(NA_character_)) 
[16:59:37.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:37.899]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:37.899]                     .init = FALSE)
[16:59:37.899]                 }
[16:59:37.899]             }
[16:59:37.899]         }
[16:59:37.899]     })
[16:59:37.899]     if (TRUE) {
[16:59:37.899]         base::sink(type = "output", split = FALSE)
[16:59:37.899]         if (TRUE) {
[16:59:37.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:37.899]         }
[16:59:37.899]         else {
[16:59:37.899]             ...future.result["stdout"] <- base::list(NULL)
[16:59:37.899]         }
[16:59:37.899]         base::close(...future.stdout)
[16:59:37.899]         ...future.stdout <- NULL
[16:59:37.899]     }
[16:59:37.899]     ...future.result$conditions <- ...future.conditions
[16:59:37.899]     ...future.result$finished <- base::Sys.time()
[16:59:37.899]     ...future.result
[16:59:37.899] }
[16:59:37.901] assign_globals() ...
[16:59:37.901] List of 5
[16:59:37.901]  $ ...future.FUN            :function (x, ...)  
[16:59:37.901]  $ future.call.arguments    :List of 1
[16:59:37.901]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:59:37.901]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.901]  $ ...future.elements_ii    :List of 3
[16:59:37.901]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:59:37.901]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:59:37.901]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:59:37.901]  $ ...future.seeds_ii       : NULL
[16:59:37.901]  $ ...future.globals.maxSize: NULL
[16:59:37.901]  - attr(*, "where")=List of 5
[16:59:37.901]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:37.901]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:37.901]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:37.901]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:37.901]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:37.901]  - attr(*, "resolved")= logi FALSE
[16:59:37.901]  - attr(*, "total_size")= num 1328
[16:59:37.901]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.901]  - attr(*, "already-done")= logi TRUE
[16:59:37.907] - copied ‘...future.FUN’ to environment
[16:59:37.907] - copied ‘future.call.arguments’ to environment
[16:59:37.907] - copied ‘...future.elements_ii’ to environment
[16:59:37.907] - copied ‘...future.seeds_ii’ to environment
[16:59:37.907] - copied ‘...future.globals.maxSize’ to environment
[16:59:37.907] assign_globals() ... done
[16:59:37.908] plan(): Setting new future strategy stack:
[16:59:37.908] List of future strategies:
[16:59:37.908] 1. sequential:
[16:59:37.908]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:37.908]    - tweaked: FALSE
[16:59:37.908]    - call: NULL
[16:59:37.908] plan(): nbrOfWorkers() = 1
[16:59:37.909] plan(): Setting new future strategy stack:
[16:59:37.909] List of future strategies:
[16:59:37.909] 1. sequential:
[16:59:37.909]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:37.909]    - tweaked: FALSE
[16:59:37.909]    - call: plan(strategy)
[16:59:37.910] plan(): nbrOfWorkers() = 1
[16:59:37.910] SequentialFuture started (and completed)
[16:59:37.910] - Launch lazy future ... done
[16:59:37.910] run() for ‘SequentialFuture’ ... done
[16:59:37.910] Created future:
[16:59:37.910] SequentialFuture:
[16:59:37.910] Label: ‘future_eapply-1’
[16:59:37.910] Expression:
[16:59:37.910] {
[16:59:37.910]     do.call(function(...) {
[16:59:37.910]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.910]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.910]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.910]             on.exit(options(oopts), add = TRUE)
[16:59:37.910]         }
[16:59:37.910]         {
[16:59:37.910]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.910]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.910]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.910]             })
[16:59:37.910]         }
[16:59:37.910]     }, args = future.call.arguments)
[16:59:37.910] }
[16:59:37.910] Lazy evaluation: FALSE
[16:59:37.910] Asynchronous evaluation: FALSE
[16:59:37.910] Local evaluation: TRUE
[16:59:37.910] Environment: R_GlobalEnv
[16:59:37.910] Capture standard output: TRUE
[16:59:37.910] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:37.910] Globals: 5 objects totaling 1.56 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:37.910] Packages: 1 packages (‘stats’)
[16:59:37.910] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:37.910] Resolved: TRUE
[16:59:37.910] Value: 1.29 KiB of class ‘list’
[16:59:37.910] Early signaling: FALSE
[16:59:37.910] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:37.910] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:37.911] Chunk #1 of 1 ... DONE
[16:59:37.911] Launching 1 futures (chunks) ... DONE
[16:59:37.911] Resolving 1 futures (chunks) ...
[16:59:37.912] resolve() on list ...
[16:59:37.912]  recursive: 0
[16:59:37.912]  length: 1
[16:59:37.912] 
[16:59:37.912] resolved() for ‘SequentialFuture’ ...
[16:59:37.912] - state: ‘finished’
[16:59:37.912] - run: TRUE
[16:59:37.912] - result: ‘FutureResult’
[16:59:37.912] resolved() for ‘SequentialFuture’ ... done
[16:59:37.912] Future #1
[16:59:37.913] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:37.913] - nx: 1
[16:59:37.913] - relay: TRUE
[16:59:37.913] - stdout: TRUE
[16:59:37.913] - signal: TRUE
[16:59:37.913] - resignal: FALSE
[16:59:37.913] - force: TRUE
[16:59:37.913] - relayed: [n=1] FALSE
[16:59:37.913] - queued futures: [n=1] FALSE
[16:59:37.913]  - until=1
[16:59:37.913]  - relaying element #1
[16:59:37.914] - relayed: [n=1] TRUE
[16:59:37.914] - queued futures: [n=1] TRUE
[16:59:37.914] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:37.914]  length: 0 (resolved future 1)
[16:59:37.914] Relaying remaining futures
[16:59:37.914] signalConditionsASAP(NULL, pos=0) ...
[16:59:37.914] - nx: 1
[16:59:37.914] - relay: TRUE
[16:59:37.914] - stdout: TRUE
[16:59:37.914] - signal: TRUE
[16:59:37.914] - resignal: FALSE
[16:59:37.914] - force: TRUE
[16:59:37.915] - relayed: [n=1] TRUE
[16:59:37.915] - queued futures: [n=1] TRUE
 - flush all
[16:59:37.915] - relayed: [n=1] TRUE
[16:59:37.915] - queued futures: [n=1] TRUE
[16:59:37.915] signalConditionsASAP(NULL, pos=0) ... done
[16:59:37.915] resolve() on list ... DONE
[16:59:37.915]  - Number of value chunks collected: 1
[16:59:37.915] Resolving 1 futures (chunks) ... DONE
[16:59:37.915] Reducing values from 1 chunks ...
[16:59:37.915]  - Number of values collected after concatenation: 3
[16:59:37.916]  - Number of values expected: 3
[16:59:37.916] Reducing values from 1 chunks ... DONE
[16:59:37.916] future_lapply() ... DONE
[16:59:37.917] future_lapply() ...
[16:59:37.917] Number of chunks: 1
[16:59:37.917] getGlobalsAndPackagesXApply() ...
[16:59:37.918]  - future.globals: TRUE
[16:59:37.918] getGlobalsAndPackages() ...
[16:59:37.918] Searching for globals...
[16:59:37.919] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:37.919] Searching for globals ... DONE
[16:59:37.919] Resolving globals: FALSE
[16:59:37.921] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:59:37.921] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:59:37.921] - globals: [1] ‘FUN’
[16:59:37.921] - packages: [1] ‘stats’
[16:59:37.922] getGlobalsAndPackages() ... DONE
[16:59:37.922]  - globals found/used: [n=1] ‘FUN’
[16:59:37.922]  - needed namespaces: [n=1] ‘stats’
[16:59:37.922] Finding globals ... DONE
[16:59:37.922]  - use_args: TRUE
[16:59:37.922]  - Getting '...' globals ...
[16:59:37.922] resolve() on list ...
[16:59:37.922]  recursive: 0
[16:59:37.922]  length: 1
[16:59:37.923]  elements: ‘...’
[16:59:37.923]  length: 0 (resolved future 1)
[16:59:37.923] resolve() on list ... DONE
[16:59:37.923]    - '...' content: [n=0] 
[16:59:37.923] List of 1
[16:59:37.923]  $ ...: list()
[16:59:37.923]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.923]  - attr(*, "where")=List of 1
[16:59:37.923]   ..$ ...:<environment: 0x55c348d73ee0> 
[16:59:37.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.923]  - attr(*, "resolved")= logi TRUE
[16:59:37.923]  - attr(*, "total_size")= num NA
[16:59:37.925]  - Getting '...' globals ... DONE
[16:59:37.926] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:37.926] List of 2
[16:59:37.926]  $ ...future.FUN:function (x, ...)  
[16:59:37.926]  $ ...          : list()
[16:59:37.926]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.926]  - attr(*, "where")=List of 2
[16:59:37.926]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:37.926]   ..$ ...          :<environment: 0x55c348d73ee0> 
[16:59:37.926]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.926]  - attr(*, "resolved")= logi FALSE
[16:59:37.926]  - attr(*, "total_size")= num 1248
[16:59:37.928] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:37.928] getGlobalsAndPackagesXApply() ... DONE
[16:59:37.929] Number of futures (= number of chunks): 1
[16:59:37.929] Launching 1 futures (chunks) ...
[16:59:37.929] Chunk #1 of 1 ...
[16:59:37.929]  - Finding globals in 'X' for chunk #1 ...
[16:59:37.929] getGlobalsAndPackages() ...
[16:59:37.929] Searching for globals...
[16:59:37.929] 
[16:59:37.929] Searching for globals ... DONE
[16:59:37.929] - globals: [0] <none>
[16:59:37.930] getGlobalsAndPackages() ... DONE
[16:59:37.930]    + additional globals found: [n=0] 
[16:59:37.930]    + additional namespaces needed: [n=0] 
[16:59:37.930]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:37.930]  - seeds: <none>
[16:59:37.930]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.930] getGlobalsAndPackages() ...
[16:59:37.930] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.930] Resolving globals: FALSE
[16:59:37.930] Tweak future expression to call with '...' arguments ...
[16:59:37.930] {
[16:59:37.930]     do.call(function(...) {
[16:59:37.930]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.930]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.930]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.930]             on.exit(options(oopts), add = TRUE)
[16:59:37.930]         }
[16:59:37.930]         {
[16:59:37.930]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.930]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.930]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.930]             })
[16:59:37.930]         }
[16:59:37.930]     }, args = future.call.arguments)
[16:59:37.930] }
[16:59:37.931] Tweak future expression to call with '...' arguments ... DONE
[16:59:37.931] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.931] - packages: [1] ‘stats’
[16:59:37.931] getGlobalsAndPackages() ... DONE
[16:59:37.932] run() for ‘Future’ ...
[16:59:37.932] - state: ‘created’
[16:59:37.932] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:37.932] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:37.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:37.932]   - Field: ‘label’
[16:59:37.932]   - Field: ‘local’
[16:59:37.932]   - Field: ‘owner’
[16:59:37.933]   - Field: ‘envir’
[16:59:37.933]   - Field: ‘packages’
[16:59:37.933]   - Field: ‘gc’
[16:59:37.933]   - Field: ‘conditions’
[16:59:37.933]   - Field: ‘expr’
[16:59:37.933]   - Field: ‘uuid’
[16:59:37.933]   - Field: ‘seed’
[16:59:37.933]   - Field: ‘version’
[16:59:37.933]   - Field: ‘result’
[16:59:37.933]   - Field: ‘asynchronous’
[16:59:37.933]   - Field: ‘calls’
[16:59:37.934]   - Field: ‘globals’
[16:59:37.934]   - Field: ‘stdout’
[16:59:37.934]   - Field: ‘earlySignal’
[16:59:37.934]   - Field: ‘lazy’
[16:59:37.934]   - Field: ‘state’
[16:59:37.934] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:37.934] - Launch lazy future ...
[16:59:37.934] Packages needed by the future expression (n = 1): ‘stats’
[16:59:37.934] Packages needed by future strategies (n = 0): <none>
[16:59:37.935] {
[16:59:37.935]     {
[16:59:37.935]         {
[16:59:37.935]             ...future.startTime <- base::Sys.time()
[16:59:37.935]             {
[16:59:37.935]                 {
[16:59:37.935]                   {
[16:59:37.935]                     {
[16:59:37.935]                       base::local({
[16:59:37.935]                         has_future <- base::requireNamespace("future", 
[16:59:37.935]                           quietly = TRUE)
[16:59:37.935]                         if (has_future) {
[16:59:37.935]                           ns <- base::getNamespace("future")
[16:59:37.935]                           version <- ns[[".package"]][["version"]]
[16:59:37.935]                           if (is.null(version)) 
[16:59:37.935]                             version <- utils::packageVersion("future")
[16:59:37.935]                         }
[16:59:37.935]                         else {
[16:59:37.935]                           version <- NULL
[16:59:37.935]                         }
[16:59:37.935]                         if (!has_future || version < "1.8.0") {
[16:59:37.935]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:37.935]                             "", base::R.version$version.string), 
[16:59:37.935]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:37.935]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:37.935]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:37.935]                               "release", "version")], collapse = " "), 
[16:59:37.935]                             hostname = base::Sys.info()[["nodename"]])
[16:59:37.935]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:37.935]                             info)
[16:59:37.935]                           info <- base::paste(info, collapse = "; ")
[16:59:37.935]                           if (!has_future) {
[16:59:37.935]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:37.935]                               info)
[16:59:37.935]                           }
[16:59:37.935]                           else {
[16:59:37.935]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:37.935]                               info, version)
[16:59:37.935]                           }
[16:59:37.935]                           base::stop(msg)
[16:59:37.935]                         }
[16:59:37.935]                       })
[16:59:37.935]                     }
[16:59:37.935]                     base::local({
[16:59:37.935]                       for (pkg in "stats") {
[16:59:37.935]                         base::loadNamespace(pkg)
[16:59:37.935]                         base::library(pkg, character.only = TRUE)
[16:59:37.935]                       }
[16:59:37.935]                     })
[16:59:37.935]                   }
[16:59:37.935]                   ...future.strategy.old <- future::plan("list")
[16:59:37.935]                   options(future.plan = NULL)
[16:59:37.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:37.935]                 }
[16:59:37.935]                 ...future.workdir <- getwd()
[16:59:37.935]             }
[16:59:37.935]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:37.935]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:37.935]         }
[16:59:37.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:37.935]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:37.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:37.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:37.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:37.935]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:37.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:37.935]             base::names(...future.oldOptions))
[16:59:37.935]     }
[16:59:37.935]     if (FALSE) {
[16:59:37.935]     }
[16:59:37.935]     else {
[16:59:37.935]         if (TRUE) {
[16:59:37.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:37.935]                 open = "w")
[16:59:37.935]         }
[16:59:37.935]         else {
[16:59:37.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:37.935]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:37.935]         }
[16:59:37.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:37.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:37.935]             base::sink(type = "output", split = FALSE)
[16:59:37.935]             base::close(...future.stdout)
[16:59:37.935]         }, add = TRUE)
[16:59:37.935]     }
[16:59:37.935]     ...future.frame <- base::sys.nframe()
[16:59:37.935]     ...future.conditions <- base::list()
[16:59:37.935]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:37.935]     if (FALSE) {
[16:59:37.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:37.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:37.935]     }
[16:59:37.935]     ...future.result <- base::tryCatch({
[16:59:37.935]         base::withCallingHandlers({
[16:59:37.935]             ...future.value <- base::withVisible(base::local({
[16:59:37.935]                 do.call(function(...) {
[16:59:37.935]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.935]                   if (!identical(...future.globals.maxSize.org, 
[16:59:37.935]                     ...future.globals.maxSize)) {
[16:59:37.935]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.935]                     on.exit(options(oopts), add = TRUE)
[16:59:37.935]                   }
[16:59:37.935]                   {
[16:59:37.935]                     lapply(seq_along(...future.elements_ii), 
[16:59:37.935]                       FUN = function(jj) {
[16:59:37.935]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.935]                         ...future.FUN(...future.X_jj, ...)
[16:59:37.935]                       })
[16:59:37.935]                   }
[16:59:37.935]                 }, args = future.call.arguments)
[16:59:37.935]             }))
[16:59:37.935]             future::FutureResult(value = ...future.value$value, 
[16:59:37.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.935]                   ...future.rng), globalenv = if (FALSE) 
[16:59:37.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:37.935]                     ...future.globalenv.names))
[16:59:37.935]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:37.935]         }, condition = base::local({
[16:59:37.935]             c <- base::c
[16:59:37.935]             inherits <- base::inherits
[16:59:37.935]             invokeRestart <- base::invokeRestart
[16:59:37.935]             length <- base::length
[16:59:37.935]             list <- base::list
[16:59:37.935]             seq.int <- base::seq.int
[16:59:37.935]             signalCondition <- base::signalCondition
[16:59:37.935]             sys.calls <- base::sys.calls
[16:59:37.935]             `[[` <- base::`[[`
[16:59:37.935]             `+` <- base::`+`
[16:59:37.935]             `<<-` <- base::`<<-`
[16:59:37.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:37.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:37.935]                   3L)]
[16:59:37.935]             }
[16:59:37.935]             function(cond) {
[16:59:37.935]                 is_error <- inherits(cond, "error")
[16:59:37.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:37.935]                   NULL)
[16:59:37.935]                 if (is_error) {
[16:59:37.935]                   sessionInformation <- function() {
[16:59:37.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:37.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:37.935]                       search = base::search(), system = base::Sys.info())
[16:59:37.935]                   }
[16:59:37.935]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:37.935]                     cond$call), session = sessionInformation(), 
[16:59:37.935]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:37.935]                   signalCondition(cond)
[16:59:37.935]                 }
[16:59:37.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:37.935]                 "immediateCondition"))) {
[16:59:37.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:37.935]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:37.935]                   if (TRUE && !signal) {
[16:59:37.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.935]                     {
[16:59:37.935]                       inherits <- base::inherits
[16:59:37.935]                       invokeRestart <- base::invokeRestart
[16:59:37.935]                       is.null <- base::is.null
[16:59:37.935]                       muffled <- FALSE
[16:59:37.935]                       if (inherits(cond, "message")) {
[16:59:37.935]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.935]                         if (muffled) 
[16:59:37.935]                           invokeRestart("muffleMessage")
[16:59:37.935]                       }
[16:59:37.935]                       else if (inherits(cond, "warning")) {
[16:59:37.935]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.935]                         if (muffled) 
[16:59:37.935]                           invokeRestart("muffleWarning")
[16:59:37.935]                       }
[16:59:37.935]                       else if (inherits(cond, "condition")) {
[16:59:37.935]                         if (!is.null(pattern)) {
[16:59:37.935]                           computeRestarts <- base::computeRestarts
[16:59:37.935]                           grepl <- base::grepl
[16:59:37.935]                           restarts <- computeRestarts(cond)
[16:59:37.935]                           for (restart in restarts) {
[16:59:37.935]                             name <- restart$name
[16:59:37.935]                             if (is.null(name)) 
[16:59:37.935]                               next
[16:59:37.935]                             if (!grepl(pattern, name)) 
[16:59:37.935]                               next
[16:59:37.935]                             invokeRestart(restart)
[16:59:37.935]                             muffled <- TRUE
[16:59:37.935]                             break
[16:59:37.935]                           }
[16:59:37.935]                         }
[16:59:37.935]                       }
[16:59:37.935]                       invisible(muffled)
[16:59:37.935]                     }
[16:59:37.935]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.935]                   }
[16:59:37.935]                 }
[16:59:37.935]                 else {
[16:59:37.935]                   if (TRUE) {
[16:59:37.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.935]                     {
[16:59:37.935]                       inherits <- base::inherits
[16:59:37.935]                       invokeRestart <- base::invokeRestart
[16:59:37.935]                       is.null <- base::is.null
[16:59:37.935]                       muffled <- FALSE
[16:59:37.935]                       if (inherits(cond, "message")) {
[16:59:37.935]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.935]                         if (muffled) 
[16:59:37.935]                           invokeRestart("muffleMessage")
[16:59:37.935]                       }
[16:59:37.935]                       else if (inherits(cond, "warning")) {
[16:59:37.935]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.935]                         if (muffled) 
[16:59:37.935]                           invokeRestart("muffleWarning")
[16:59:37.935]                       }
[16:59:37.935]                       else if (inherits(cond, "condition")) {
[16:59:37.935]                         if (!is.null(pattern)) {
[16:59:37.935]                           computeRestarts <- base::computeRestarts
[16:59:37.935]                           grepl <- base::grepl
[16:59:37.935]                           restarts <- computeRestarts(cond)
[16:59:37.935]                           for (restart in restarts) {
[16:59:37.935]                             name <- restart$name
[16:59:37.935]                             if (is.null(name)) 
[16:59:37.935]                               next
[16:59:37.935]                             if (!grepl(pattern, name)) 
[16:59:37.935]                               next
[16:59:37.935]                             invokeRestart(restart)
[16:59:37.935]                             muffled <- TRUE
[16:59:37.935]                             break
[16:59:37.935]                           }
[16:59:37.935]                         }
[16:59:37.935]                       }
[16:59:37.935]                       invisible(muffled)
[16:59:37.935]                     }
[16:59:37.935]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.935]                   }
[16:59:37.935]                 }
[16:59:37.935]             }
[16:59:37.935]         }))
[16:59:37.935]     }, error = function(ex) {
[16:59:37.935]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:37.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.935]                 ...future.rng), started = ...future.startTime, 
[16:59:37.935]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:37.935]             version = "1.8"), class = "FutureResult")
[16:59:37.935]     }, finally = {
[16:59:37.935]         if (!identical(...future.workdir, getwd())) 
[16:59:37.935]             setwd(...future.workdir)
[16:59:37.935]         {
[16:59:37.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:37.935]                 ...future.oldOptions$nwarnings <- NULL
[16:59:37.935]             }
[16:59:37.935]             base::options(...future.oldOptions)
[16:59:37.935]             if (.Platform$OS.type == "windows") {
[16:59:37.935]                 old_names <- names(...future.oldEnvVars)
[16:59:37.935]                 envs <- base::Sys.getenv()
[16:59:37.935]                 names <- names(envs)
[16:59:37.935]                 common <- intersect(names, old_names)
[16:59:37.935]                 added <- setdiff(names, old_names)
[16:59:37.935]                 removed <- setdiff(old_names, names)
[16:59:37.935]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:37.935]                   envs[common]]
[16:59:37.935]                 NAMES <- toupper(changed)
[16:59:37.935]                 args <- list()
[16:59:37.935]                 for (kk in seq_along(NAMES)) {
[16:59:37.935]                   name <- changed[[kk]]
[16:59:37.935]                   NAME <- NAMES[[kk]]
[16:59:37.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.935]                     next
[16:59:37.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.935]                 }
[16:59:37.935]                 NAMES <- toupper(added)
[16:59:37.935]                 for (kk in seq_along(NAMES)) {
[16:59:37.935]                   name <- added[[kk]]
[16:59:37.935]                   NAME <- NAMES[[kk]]
[16:59:37.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.935]                     next
[16:59:37.935]                   args[[name]] <- ""
[16:59:37.935]                 }
[16:59:37.935]                 NAMES <- toupper(removed)
[16:59:37.935]                 for (kk in seq_along(NAMES)) {
[16:59:37.935]                   name <- removed[[kk]]
[16:59:37.935]                   NAME <- NAMES[[kk]]
[16:59:37.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.935]                     next
[16:59:37.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.935]                 }
[16:59:37.935]                 if (length(args) > 0) 
[16:59:37.935]                   base::do.call(base::Sys.setenv, args = args)
[16:59:37.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:37.935]             }
[16:59:37.935]             else {
[16:59:37.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:37.935]             }
[16:59:37.935]             {
[16:59:37.935]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:37.935]                   0L) {
[16:59:37.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:37.935]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:37.935]                   base::options(opts)
[16:59:37.935]                 }
[16:59:37.935]                 {
[16:59:37.935]                   {
[16:59:37.935]                     NULL
[16:59:37.935]                     RNGkind("Mersenne-Twister")
[16:59:37.935]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:37.935]                       inherits = FALSE)
[16:59:37.935]                   }
[16:59:37.935]                   options(future.plan = NULL)
[16:59:37.935]                   if (is.na(NA_character_)) 
[16:59:37.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:37.935]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:37.935]                     .init = FALSE)
[16:59:37.935]                 }
[16:59:37.935]             }
[16:59:37.935]         }
[16:59:37.935]     })
[16:59:37.935]     if (TRUE) {
[16:59:37.935]         base::sink(type = "output", split = FALSE)
[16:59:37.935]         if (TRUE) {
[16:59:37.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:37.935]         }
[16:59:37.935]         else {
[16:59:37.935]             ...future.result["stdout"] <- base::list(NULL)
[16:59:37.935]         }
[16:59:37.935]         base::close(...future.stdout)
[16:59:37.935]         ...future.stdout <- NULL
[16:59:37.935]     }
[16:59:37.935]     ...future.result$conditions <- ...future.conditions
[16:59:37.935]     ...future.result$finished <- base::Sys.time()
[16:59:37.935]     ...future.result
[16:59:37.935] }
[16:59:37.937] assign_globals() ...
[16:59:37.937] List of 5
[16:59:37.937]  $ ...future.FUN            :function (x, ...)  
[16:59:37.937]  $ future.call.arguments    : list()
[16:59:37.937]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.937]  $ ...future.elements_ii    :List of 3
[16:59:37.937]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:59:37.937]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:59:37.937]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:59:37.937]  $ ...future.seeds_ii       : NULL
[16:59:37.937]  $ ...future.globals.maxSize: NULL
[16:59:37.937]  - attr(*, "where")=List of 5
[16:59:37.937]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:37.937]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:37.937]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:37.937]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:37.937]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:37.937]  - attr(*, "resolved")= logi FALSE
[16:59:37.937]  - attr(*, "total_size")= num 1248
[16:59:37.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.937]  - attr(*, "already-done")= logi TRUE
[16:59:37.942] - copied ‘...future.FUN’ to environment
[16:59:37.942] - copied ‘future.call.arguments’ to environment
[16:59:37.942] - copied ‘...future.elements_ii’ to environment
[16:59:37.942] - copied ‘...future.seeds_ii’ to environment
[16:59:37.942] - copied ‘...future.globals.maxSize’ to environment
[16:59:37.942] assign_globals() ... done
[16:59:37.942] plan(): Setting new future strategy stack:
[16:59:37.943] List of future strategies:
[16:59:37.943] 1. sequential:
[16:59:37.943]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:37.943]    - tweaked: FALSE
[16:59:37.943]    - call: NULL
[16:59:37.943] plan(): nbrOfWorkers() = 1
[16:59:37.944] plan(): Setting new future strategy stack:
[16:59:37.944] List of future strategies:
[16:59:37.944] 1. sequential:
[16:59:37.944]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:37.944]    - tweaked: FALSE
[16:59:37.944]    - call: plan(strategy)
[16:59:37.945] plan(): nbrOfWorkers() = 1
[16:59:37.946] SequentialFuture started (and completed)
[16:59:37.946] - Launch lazy future ... done
[16:59:37.947] run() for ‘SequentialFuture’ ... done
[16:59:37.947] Created future:
[16:59:37.947] SequentialFuture:
[16:59:37.947] Label: ‘future_eapply-1’
[16:59:37.947] Expression:
[16:59:37.947] {
[16:59:37.947]     do.call(function(...) {
[16:59:37.947]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.947]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.947]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.947]             on.exit(options(oopts), add = TRUE)
[16:59:37.947]         }
[16:59:37.947]         {
[16:59:37.947]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.947]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.947]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.947]             })
[16:59:37.947]         }
[16:59:37.947]     }, args = future.call.arguments)
[16:59:37.947] }
[16:59:37.947] Lazy evaluation: FALSE
[16:59:37.947] Asynchronous evaluation: FALSE
[16:59:37.947] Local evaluation: TRUE
[16:59:37.947] Environment: R_GlobalEnv
[16:59:37.947] Capture standard output: TRUE
[16:59:37.947] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:37.947] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:37.947] Packages: 1 packages (‘stats’)
[16:59:37.947] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:37.947] Resolved: TRUE
[16:59:37.947] Value: 1.71 KiB of class ‘list’
[16:59:37.947] Early signaling: FALSE
[16:59:37.947] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:37.947] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:37.948] Chunk #1 of 1 ... DONE
[16:59:37.948] Launching 1 futures (chunks) ... DONE
[16:59:37.948] Resolving 1 futures (chunks) ...
[16:59:37.948] resolve() on list ...
[16:59:37.948]  recursive: 0
[16:59:37.948]  length: 1
[16:59:37.948] 
[16:59:37.948] resolved() for ‘SequentialFuture’ ...
[16:59:37.949] - state: ‘finished’
[16:59:37.949] - run: TRUE
[16:59:37.949] - result: ‘FutureResult’
[16:59:37.949] resolved() for ‘SequentialFuture’ ... done
[16:59:37.949] Future #1
[16:59:37.949] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:37.949] - nx: 1
[16:59:37.949] - relay: TRUE
[16:59:37.949] - stdout: TRUE
[16:59:37.949] - signal: TRUE
[16:59:37.949] - resignal: FALSE
[16:59:37.950] - force: TRUE
[16:59:37.950] - relayed: [n=1] FALSE
[16:59:37.950] - queued futures: [n=1] FALSE
[16:59:37.950]  - until=1
[16:59:37.950]  - relaying element #1
[16:59:37.950] - relayed: [n=1] TRUE
[16:59:37.950] - queued futures: [n=1] TRUE
[16:59:37.950] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:37.950]  length: 0 (resolved future 1)
[16:59:37.950] Relaying remaining futures
[16:59:37.951] signalConditionsASAP(NULL, pos=0) ...
[16:59:37.951] - nx: 1
[16:59:37.951] - relay: TRUE
[16:59:37.951] - stdout: TRUE
[16:59:37.951] - signal: TRUE
[16:59:37.951] - resignal: FALSE
[16:59:37.951] - force: TRUE
[16:59:37.951] - relayed: [n=1] TRUE
[16:59:37.951] - queued futures: [n=1] TRUE
 - flush all
[16:59:37.951] - relayed: [n=1] TRUE
[16:59:37.951] - queued futures: [n=1] TRUE
[16:59:37.952] signalConditionsASAP(NULL, pos=0) ... done
[16:59:37.952] resolve() on list ... DONE
[16:59:37.952]  - Number of value chunks collected: 1
[16:59:37.952] Resolving 1 futures (chunks) ... DONE
[16:59:37.952] Reducing values from 1 chunks ...
[16:59:37.952]  - Number of values collected after concatenation: 3
[16:59:37.952]  - Number of values expected: 3
[16:59:37.952] Reducing values from 1 chunks ... DONE
[16:59:37.952] future_lapply() ... DONE
[16:59:37.953] future_lapply() ...
[16:59:37.953] Number of chunks: 1
[16:59:37.953] getGlobalsAndPackagesXApply() ...
[16:59:37.953]  - future.globals: TRUE
[16:59:37.953] getGlobalsAndPackages() ...
[16:59:37.953] Searching for globals...
[16:59:37.954] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:37.954] Searching for globals ... DONE
[16:59:37.955] Resolving globals: FALSE
[16:59:37.955] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:59:37.955] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:59:37.955] - globals: [1] ‘FUN’
[16:59:37.956] - packages: [1] ‘stats’
[16:59:37.956] getGlobalsAndPackages() ... DONE
[16:59:37.956]  - globals found/used: [n=1] ‘FUN’
[16:59:37.956]  - needed namespaces: [n=1] ‘stats’
[16:59:37.956] Finding globals ... DONE
[16:59:37.956]  - use_args: TRUE
[16:59:37.956]  - Getting '...' globals ...
[16:59:37.956] resolve() on list ...
[16:59:37.956]  recursive: 0
[16:59:37.957]  length: 1
[16:59:37.957]  elements: ‘...’
[16:59:37.957]  length: 0 (resolved future 1)
[16:59:37.957] resolve() on list ... DONE
[16:59:37.957]    - '...' content: [n=0] 
[16:59:37.957] List of 1
[16:59:37.957]  $ ...: list()
[16:59:37.957]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.957]  - attr(*, "where")=List of 1
[16:59:37.957]   ..$ ...:<environment: 0x55c347aa7770> 
[16:59:37.957]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.957]  - attr(*, "resolved")= logi TRUE
[16:59:37.957]  - attr(*, "total_size")= num NA
[16:59:37.959]  - Getting '...' globals ... DONE
[16:59:37.960] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:37.960] List of 2
[16:59:37.960]  $ ...future.FUN:function (x, ...)  
[16:59:37.960]  $ ...          : list()
[16:59:37.960]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.960]  - attr(*, "where")=List of 2
[16:59:37.960]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:37.960]   ..$ ...          :<environment: 0x55c347aa7770> 
[16:59:37.960]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.960]  - attr(*, "resolved")= logi FALSE
[16:59:37.960]  - attr(*, "total_size")= num 1248
[16:59:37.962] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:37.962] getGlobalsAndPackagesXApply() ... DONE
[16:59:37.962] Number of futures (= number of chunks): 1
[16:59:37.963] Launching 1 futures (chunks) ...
[16:59:37.963] Chunk #1 of 1 ...
[16:59:37.963]  - Finding globals in 'X' for chunk #1 ...
[16:59:37.963] getGlobalsAndPackages() ...
[16:59:37.963] Searching for globals...
[16:59:37.963] 
[16:59:37.963] Searching for globals ... DONE
[16:59:37.963] - globals: [0] <none>
[16:59:37.963] getGlobalsAndPackages() ... DONE
[16:59:37.964]    + additional globals found: [n=0] 
[16:59:37.964]    + additional namespaces needed: [n=0] 
[16:59:37.964]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:37.964]  - seeds: <none>
[16:59:37.964]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.964] getGlobalsAndPackages() ...
[16:59:37.964] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.964] Resolving globals: FALSE
[16:59:37.964] Tweak future expression to call with '...' arguments ...
[16:59:37.964] {
[16:59:37.964]     do.call(function(...) {
[16:59:37.964]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.964]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.964]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.964]             on.exit(options(oopts), add = TRUE)
[16:59:37.964]         }
[16:59:37.964]         {
[16:59:37.964]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.964]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.964]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.964]             })
[16:59:37.964]         }
[16:59:37.964]     }, args = future.call.arguments)
[16:59:37.964] }
[16:59:37.965] Tweak future expression to call with '...' arguments ... DONE
[16:59:37.965] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.965] - packages: [1] ‘stats’
[16:59:37.965] getGlobalsAndPackages() ... DONE
[16:59:37.965] run() for ‘Future’ ...
[16:59:37.966] - state: ‘created’
[16:59:37.966] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:37.966] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:37.966] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:37.966]   - Field: ‘label’
[16:59:37.966]   - Field: ‘local’
[16:59:37.966]   - Field: ‘owner’
[16:59:37.966]   - Field: ‘envir’
[16:59:37.967]   - Field: ‘packages’
[16:59:37.967]   - Field: ‘gc’
[16:59:37.967]   - Field: ‘conditions’
[16:59:37.967]   - Field: ‘expr’
[16:59:37.967]   - Field: ‘uuid’
[16:59:37.967]   - Field: ‘seed’
[16:59:37.967]   - Field: ‘version’
[16:59:37.967]   - Field: ‘result’
[16:59:37.967]   - Field: ‘asynchronous’
[16:59:37.967]   - Field: ‘calls’
[16:59:37.967]   - Field: ‘globals’
[16:59:37.968]   - Field: ‘stdout’
[16:59:37.968]   - Field: ‘earlySignal’
[16:59:37.968]   - Field: ‘lazy’
[16:59:37.968]   - Field: ‘state’
[16:59:37.968] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:37.968] - Launch lazy future ...
[16:59:37.968] Packages needed by the future expression (n = 1): ‘stats’
[16:59:37.968] Packages needed by future strategies (n = 0): <none>
[16:59:37.969] {
[16:59:37.969]     {
[16:59:37.969]         {
[16:59:37.969]             ...future.startTime <- base::Sys.time()
[16:59:37.969]             {
[16:59:37.969]                 {
[16:59:37.969]                   {
[16:59:37.969]                     {
[16:59:37.969]                       base::local({
[16:59:37.969]                         has_future <- base::requireNamespace("future", 
[16:59:37.969]                           quietly = TRUE)
[16:59:37.969]                         if (has_future) {
[16:59:37.969]                           ns <- base::getNamespace("future")
[16:59:37.969]                           version <- ns[[".package"]][["version"]]
[16:59:37.969]                           if (is.null(version)) 
[16:59:37.969]                             version <- utils::packageVersion("future")
[16:59:37.969]                         }
[16:59:37.969]                         else {
[16:59:37.969]                           version <- NULL
[16:59:37.969]                         }
[16:59:37.969]                         if (!has_future || version < "1.8.0") {
[16:59:37.969]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:37.969]                             "", base::R.version$version.string), 
[16:59:37.969]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:37.969]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:37.969]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:37.969]                               "release", "version")], collapse = " "), 
[16:59:37.969]                             hostname = base::Sys.info()[["nodename"]])
[16:59:37.969]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:37.969]                             info)
[16:59:37.969]                           info <- base::paste(info, collapse = "; ")
[16:59:37.969]                           if (!has_future) {
[16:59:37.969]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:37.969]                               info)
[16:59:37.969]                           }
[16:59:37.969]                           else {
[16:59:37.969]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:37.969]                               info, version)
[16:59:37.969]                           }
[16:59:37.969]                           base::stop(msg)
[16:59:37.969]                         }
[16:59:37.969]                       })
[16:59:37.969]                     }
[16:59:37.969]                     base::local({
[16:59:37.969]                       for (pkg in "stats") {
[16:59:37.969]                         base::loadNamespace(pkg)
[16:59:37.969]                         base::library(pkg, character.only = TRUE)
[16:59:37.969]                       }
[16:59:37.969]                     })
[16:59:37.969]                   }
[16:59:37.969]                   ...future.strategy.old <- future::plan("list")
[16:59:37.969]                   options(future.plan = NULL)
[16:59:37.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:37.969]                 }
[16:59:37.969]                 ...future.workdir <- getwd()
[16:59:37.969]             }
[16:59:37.969]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:37.969]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:37.969]         }
[16:59:37.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:37.969]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:37.969]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:37.969]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:37.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:37.969]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:37.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:37.969]             base::names(...future.oldOptions))
[16:59:37.969]     }
[16:59:37.969]     if (FALSE) {
[16:59:37.969]     }
[16:59:37.969]     else {
[16:59:37.969]         if (TRUE) {
[16:59:37.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:37.969]                 open = "w")
[16:59:37.969]         }
[16:59:37.969]         else {
[16:59:37.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:37.969]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:37.969]         }
[16:59:37.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:37.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:37.969]             base::sink(type = "output", split = FALSE)
[16:59:37.969]             base::close(...future.stdout)
[16:59:37.969]         }, add = TRUE)
[16:59:37.969]     }
[16:59:37.969]     ...future.frame <- base::sys.nframe()
[16:59:37.969]     ...future.conditions <- base::list()
[16:59:37.969]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:37.969]     if (FALSE) {
[16:59:37.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:37.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:37.969]     }
[16:59:37.969]     ...future.result <- base::tryCatch({
[16:59:37.969]         base::withCallingHandlers({
[16:59:37.969]             ...future.value <- base::withVisible(base::local({
[16:59:37.969]                 do.call(function(...) {
[16:59:37.969]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.969]                   if (!identical(...future.globals.maxSize.org, 
[16:59:37.969]                     ...future.globals.maxSize)) {
[16:59:37.969]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.969]                     on.exit(options(oopts), add = TRUE)
[16:59:37.969]                   }
[16:59:37.969]                   {
[16:59:37.969]                     lapply(seq_along(...future.elements_ii), 
[16:59:37.969]                       FUN = function(jj) {
[16:59:37.969]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.969]                         ...future.FUN(...future.X_jj, ...)
[16:59:37.969]                       })
[16:59:37.969]                   }
[16:59:37.969]                 }, args = future.call.arguments)
[16:59:37.969]             }))
[16:59:37.969]             future::FutureResult(value = ...future.value$value, 
[16:59:37.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.969]                   ...future.rng), globalenv = if (FALSE) 
[16:59:37.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:37.969]                     ...future.globalenv.names))
[16:59:37.969]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:37.969]         }, condition = base::local({
[16:59:37.969]             c <- base::c
[16:59:37.969]             inherits <- base::inherits
[16:59:37.969]             invokeRestart <- base::invokeRestart
[16:59:37.969]             length <- base::length
[16:59:37.969]             list <- base::list
[16:59:37.969]             seq.int <- base::seq.int
[16:59:37.969]             signalCondition <- base::signalCondition
[16:59:37.969]             sys.calls <- base::sys.calls
[16:59:37.969]             `[[` <- base::`[[`
[16:59:37.969]             `+` <- base::`+`
[16:59:37.969]             `<<-` <- base::`<<-`
[16:59:37.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:37.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:37.969]                   3L)]
[16:59:37.969]             }
[16:59:37.969]             function(cond) {
[16:59:37.969]                 is_error <- inherits(cond, "error")
[16:59:37.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:37.969]                   NULL)
[16:59:37.969]                 if (is_error) {
[16:59:37.969]                   sessionInformation <- function() {
[16:59:37.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:37.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:37.969]                       search = base::search(), system = base::Sys.info())
[16:59:37.969]                   }
[16:59:37.969]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:37.969]                     cond$call), session = sessionInformation(), 
[16:59:37.969]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:37.969]                   signalCondition(cond)
[16:59:37.969]                 }
[16:59:37.969]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:37.969]                 "immediateCondition"))) {
[16:59:37.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:37.969]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:37.969]                   if (TRUE && !signal) {
[16:59:37.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.969]                     {
[16:59:37.969]                       inherits <- base::inherits
[16:59:37.969]                       invokeRestart <- base::invokeRestart
[16:59:37.969]                       is.null <- base::is.null
[16:59:37.969]                       muffled <- FALSE
[16:59:37.969]                       if (inherits(cond, "message")) {
[16:59:37.969]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.969]                         if (muffled) 
[16:59:37.969]                           invokeRestart("muffleMessage")
[16:59:37.969]                       }
[16:59:37.969]                       else if (inherits(cond, "warning")) {
[16:59:37.969]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.969]                         if (muffled) 
[16:59:37.969]                           invokeRestart("muffleWarning")
[16:59:37.969]                       }
[16:59:37.969]                       else if (inherits(cond, "condition")) {
[16:59:37.969]                         if (!is.null(pattern)) {
[16:59:37.969]                           computeRestarts <- base::computeRestarts
[16:59:37.969]                           grepl <- base::grepl
[16:59:37.969]                           restarts <- computeRestarts(cond)
[16:59:37.969]                           for (restart in restarts) {
[16:59:37.969]                             name <- restart$name
[16:59:37.969]                             if (is.null(name)) 
[16:59:37.969]                               next
[16:59:37.969]                             if (!grepl(pattern, name)) 
[16:59:37.969]                               next
[16:59:37.969]                             invokeRestart(restart)
[16:59:37.969]                             muffled <- TRUE
[16:59:37.969]                             break
[16:59:37.969]                           }
[16:59:37.969]                         }
[16:59:37.969]                       }
[16:59:37.969]                       invisible(muffled)
[16:59:37.969]                     }
[16:59:37.969]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.969]                   }
[16:59:37.969]                 }
[16:59:37.969]                 else {
[16:59:37.969]                   if (TRUE) {
[16:59:37.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.969]                     {
[16:59:37.969]                       inherits <- base::inherits
[16:59:37.969]                       invokeRestart <- base::invokeRestart
[16:59:37.969]                       is.null <- base::is.null
[16:59:37.969]                       muffled <- FALSE
[16:59:37.969]                       if (inherits(cond, "message")) {
[16:59:37.969]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.969]                         if (muffled) 
[16:59:37.969]                           invokeRestart("muffleMessage")
[16:59:37.969]                       }
[16:59:37.969]                       else if (inherits(cond, "warning")) {
[16:59:37.969]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.969]                         if (muffled) 
[16:59:37.969]                           invokeRestart("muffleWarning")
[16:59:37.969]                       }
[16:59:37.969]                       else if (inherits(cond, "condition")) {
[16:59:37.969]                         if (!is.null(pattern)) {
[16:59:37.969]                           computeRestarts <- base::computeRestarts
[16:59:37.969]                           grepl <- base::grepl
[16:59:37.969]                           restarts <- computeRestarts(cond)
[16:59:37.969]                           for (restart in restarts) {
[16:59:37.969]                             name <- restart$name
[16:59:37.969]                             if (is.null(name)) 
[16:59:37.969]                               next
[16:59:37.969]                             if (!grepl(pattern, name)) 
[16:59:37.969]                               next
[16:59:37.969]                             invokeRestart(restart)
[16:59:37.969]                             muffled <- TRUE
[16:59:37.969]                             break
[16:59:37.969]                           }
[16:59:37.969]                         }
[16:59:37.969]                       }
[16:59:37.969]                       invisible(muffled)
[16:59:37.969]                     }
[16:59:37.969]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.969]                   }
[16:59:37.969]                 }
[16:59:37.969]             }
[16:59:37.969]         }))
[16:59:37.969]     }, error = function(ex) {
[16:59:37.969]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:37.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.969]                 ...future.rng), started = ...future.startTime, 
[16:59:37.969]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:37.969]             version = "1.8"), class = "FutureResult")
[16:59:37.969]     }, finally = {
[16:59:37.969]         if (!identical(...future.workdir, getwd())) 
[16:59:37.969]             setwd(...future.workdir)
[16:59:37.969]         {
[16:59:37.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:37.969]                 ...future.oldOptions$nwarnings <- NULL
[16:59:37.969]             }
[16:59:37.969]             base::options(...future.oldOptions)
[16:59:37.969]             if (.Platform$OS.type == "windows") {
[16:59:37.969]                 old_names <- names(...future.oldEnvVars)
[16:59:37.969]                 envs <- base::Sys.getenv()
[16:59:37.969]                 names <- names(envs)
[16:59:37.969]                 common <- intersect(names, old_names)
[16:59:37.969]                 added <- setdiff(names, old_names)
[16:59:37.969]                 removed <- setdiff(old_names, names)
[16:59:37.969]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:37.969]                   envs[common]]
[16:59:37.969]                 NAMES <- toupper(changed)
[16:59:37.969]                 args <- list()
[16:59:37.969]                 for (kk in seq_along(NAMES)) {
[16:59:37.969]                   name <- changed[[kk]]
[16:59:37.969]                   NAME <- NAMES[[kk]]
[16:59:37.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.969]                     next
[16:59:37.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.969]                 }
[16:59:37.969]                 NAMES <- toupper(added)
[16:59:37.969]                 for (kk in seq_along(NAMES)) {
[16:59:37.969]                   name <- added[[kk]]
[16:59:37.969]                   NAME <- NAMES[[kk]]
[16:59:37.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.969]                     next
[16:59:37.969]                   args[[name]] <- ""
[16:59:37.969]                 }
[16:59:37.969]                 NAMES <- toupper(removed)
[16:59:37.969]                 for (kk in seq_along(NAMES)) {
[16:59:37.969]                   name <- removed[[kk]]
[16:59:37.969]                   NAME <- NAMES[[kk]]
[16:59:37.969]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.969]                     next
[16:59:37.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.969]                 }
[16:59:37.969]                 if (length(args) > 0) 
[16:59:37.969]                   base::do.call(base::Sys.setenv, args = args)
[16:59:37.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:37.969]             }
[16:59:37.969]             else {
[16:59:37.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:37.969]             }
[16:59:37.969]             {
[16:59:37.969]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:37.969]                   0L) {
[16:59:37.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:37.969]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:37.969]                   base::options(opts)
[16:59:37.969]                 }
[16:59:37.969]                 {
[16:59:37.969]                   {
[16:59:37.969]                     NULL
[16:59:37.969]                     RNGkind("Mersenne-Twister")
[16:59:37.969]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:37.969]                       inherits = FALSE)
[16:59:37.969]                   }
[16:59:37.969]                   options(future.plan = NULL)
[16:59:37.969]                   if (is.na(NA_character_)) 
[16:59:37.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:37.969]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:37.969]                     .init = FALSE)
[16:59:37.969]                 }
[16:59:37.969]             }
[16:59:37.969]         }
[16:59:37.969]     })
[16:59:37.969]     if (TRUE) {
[16:59:37.969]         base::sink(type = "output", split = FALSE)
[16:59:37.969]         if (TRUE) {
[16:59:37.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:37.969]         }
[16:59:37.969]         else {
[16:59:37.969]             ...future.result["stdout"] <- base::list(NULL)
[16:59:37.969]         }
[16:59:37.969]         base::close(...future.stdout)
[16:59:37.969]         ...future.stdout <- NULL
[16:59:37.969]     }
[16:59:37.969]     ...future.result$conditions <- ...future.conditions
[16:59:37.969]     ...future.result$finished <- base::Sys.time()
[16:59:37.969]     ...future.result
[16:59:37.969] }
[16:59:37.972] assign_globals() ...
[16:59:37.972] List of 5
[16:59:37.972]  $ ...future.FUN            :function (x, ...)  
[16:59:37.972]  $ future.call.arguments    : list()
[16:59:37.972]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.972]  $ ...future.elements_ii    :List of 3
[16:59:37.972]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:59:37.972]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:59:37.972]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:59:37.972]  $ ...future.seeds_ii       : NULL
[16:59:37.972]  $ ...future.globals.maxSize: NULL
[16:59:37.972]  - attr(*, "where")=List of 5
[16:59:37.972]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:37.972]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:37.972]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:37.972]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:37.972]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:37.972]  - attr(*, "resolved")= logi FALSE
[16:59:37.972]  - attr(*, "total_size")= num 1248
[16:59:37.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.972]  - attr(*, "already-done")= logi TRUE
[16:59:37.977] - copied ‘...future.FUN’ to environment
[16:59:37.977] - copied ‘future.call.arguments’ to environment
[16:59:37.977] - copied ‘...future.elements_ii’ to environment
[16:59:37.977] - copied ‘...future.seeds_ii’ to environment
[16:59:37.978] - copied ‘...future.globals.maxSize’ to environment
[16:59:37.978] assign_globals() ... done
[16:59:37.978] plan(): Setting new future strategy stack:
[16:59:37.978] List of future strategies:
[16:59:37.978] 1. sequential:
[16:59:37.978]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:37.978]    - tweaked: FALSE
[16:59:37.978]    - call: NULL
[16:59:37.979] plan(): nbrOfWorkers() = 1
[16:59:37.980] plan(): Setting new future strategy stack:
[16:59:37.980] List of future strategies:
[16:59:37.980] 1. sequential:
[16:59:37.980]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:37.980]    - tweaked: FALSE
[16:59:37.980]    - call: plan(strategy)
[16:59:37.980] plan(): nbrOfWorkers() = 1
[16:59:37.980] SequentialFuture started (and completed)
[16:59:37.981] - Launch lazy future ... done
[16:59:37.981] run() for ‘SequentialFuture’ ... done
[16:59:37.981] Created future:
[16:59:37.981] SequentialFuture:
[16:59:37.981] Label: ‘future_eapply-1’
[16:59:37.981] Expression:
[16:59:37.981] {
[16:59:37.981]     do.call(function(...) {
[16:59:37.981]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.981]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.981]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.981]             on.exit(options(oopts), add = TRUE)
[16:59:37.981]         }
[16:59:37.981]         {
[16:59:37.981]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.981]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.981]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.981]             })
[16:59:37.981]         }
[16:59:37.981]     }, args = future.call.arguments)
[16:59:37.981] }
[16:59:37.981] Lazy evaluation: FALSE
[16:59:37.981] Asynchronous evaluation: FALSE
[16:59:37.981] Local evaluation: TRUE
[16:59:37.981] Environment: R_GlobalEnv
[16:59:37.981] Capture standard output: TRUE
[16:59:37.981] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:37.981] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:37.981] Packages: 1 packages (‘stats’)
[16:59:37.981] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:37.981] Resolved: TRUE
[16:59:37.981] Value: 1.71 KiB of class ‘list’
[16:59:37.981] Early signaling: FALSE
[16:59:37.981] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:37.981] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:37.982] Chunk #1 of 1 ... DONE
[16:59:37.982] Launching 1 futures (chunks) ... DONE
[16:59:37.982] Resolving 1 futures (chunks) ...
[16:59:37.982] resolve() on list ...
[16:59:37.982]  recursive: 0
[16:59:37.982]  length: 1
[16:59:37.982] 
[16:59:37.982] resolved() for ‘SequentialFuture’ ...
[16:59:37.983] - state: ‘finished’
[16:59:37.983] - run: TRUE
[16:59:37.983] - result: ‘FutureResult’
[16:59:37.983] resolved() for ‘SequentialFuture’ ... done
[16:59:37.983] Future #1
[16:59:37.983] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:37.983] - nx: 1
[16:59:37.983] - relay: TRUE
[16:59:37.983] - stdout: TRUE
[16:59:37.983] - signal: TRUE
[16:59:37.983] - resignal: FALSE
[16:59:37.984] - force: TRUE
[16:59:37.984] - relayed: [n=1] FALSE
[16:59:37.984] - queued futures: [n=1] FALSE
[16:59:37.984]  - until=1
[16:59:37.984]  - relaying element #1
[16:59:37.984] - relayed: [n=1] TRUE
[16:59:37.984] - queued futures: [n=1] TRUE
[16:59:37.984] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:37.984]  length: 0 (resolved future 1)
[16:59:37.984] Relaying remaining futures
[16:59:37.985] signalConditionsASAP(NULL, pos=0) ...
[16:59:37.985] - nx: 1
[16:59:37.985] - relay: TRUE
[16:59:37.985] - stdout: TRUE
[16:59:37.985] - signal: TRUE
[16:59:37.985] - resignal: FALSE
[16:59:37.985] - force: TRUE
[16:59:37.985] - relayed: [n=1] TRUE
[16:59:37.985] - queued futures: [n=1] TRUE
 - flush all
[16:59:37.985] - relayed: [n=1] TRUE
[16:59:37.985] - queued futures: [n=1] TRUE
[16:59:37.986] signalConditionsASAP(NULL, pos=0) ... done
[16:59:37.986] resolve() on list ... DONE
[16:59:37.986]  - Number of value chunks collected: 1
[16:59:37.986] Resolving 1 futures (chunks) ... DONE
[16:59:37.986] Reducing values from 1 chunks ...
[16:59:37.986]  - Number of values collected after concatenation: 3
[16:59:37.986]  - Number of values expected: 3
[16:59:37.986] Reducing values from 1 chunks ... DONE
[16:59:37.986] future_lapply() ... DONE
[16:59:37.986] plan(): Setting new future strategy stack:
[16:59:37.987] List of future strategies:
[16:59:37.987] 1. sequential:
[16:59:37.987]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:37.987]    - tweaked: FALSE
[16:59:37.987]    - call: plan(sequential)
[16:59:37.987] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[16:59:37.987] plan(): Setting new future strategy stack:
[16:59:37.988] List of future strategies:
[16:59:37.988] 1. multicore:
[16:59:37.988]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:37.988]    - tweaked: FALSE
[16:59:37.988]    - call: plan(strategy)
[16:59:37.991] plan(): nbrOfWorkers() = 2
[16:59:37.992] future_lapply() ...
[16:59:37.996] Number of chunks: 2
[16:59:37.996] getGlobalsAndPackagesXApply() ...
[16:59:37.996]  - future.globals: TRUE
[16:59:37.996] getGlobalsAndPackages() ...
[16:59:37.996] Searching for globals...
[16:59:37.997] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:37.997] Searching for globals ... DONE
[16:59:37.997] Resolving globals: FALSE
[16:59:37.998] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:37.998] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:37.998] - globals: [1] ‘FUN’
[16:59:37.998] 
[16:59:37.998] getGlobalsAndPackages() ... DONE
[16:59:37.998]  - globals found/used: [n=1] ‘FUN’
[16:59:37.998]  - needed namespaces: [n=0] 
[16:59:37.998] Finding globals ... DONE
[16:59:37.999]  - use_args: TRUE
[16:59:37.999]  - Getting '...' globals ...
[16:59:37.999] resolve() on list ...
[16:59:37.999]  recursive: 0
[16:59:37.999]  length: 1
[16:59:37.999]  elements: ‘...’
[16:59:37.999]  length: 0 (resolved future 1)
[16:59:38.000] resolve() on list ... DONE
[16:59:38.000]    - '...' content: [n=0] 
[16:59:38.001] List of 1
[16:59:38.001]  $ ...: list()
[16:59:38.001]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.001]  - attr(*, "where")=List of 1
[16:59:38.001]   ..$ ...:<environment: 0x55c348ae3da0> 
[16:59:38.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.001]  - attr(*, "resolved")= logi TRUE
[16:59:38.001]  - attr(*, "total_size")= num NA
[16:59:38.004]  - Getting '...' globals ... DONE
[16:59:38.004] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:38.004] List of 2
[16:59:38.004]  $ ...future.FUN:function (x, ...)  
[16:59:38.004]  $ ...          : list()
[16:59:38.004]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.004]  - attr(*, "where")=List of 2
[16:59:38.004]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:38.004]   ..$ ...          :<environment: 0x55c348ae3da0> 
[16:59:38.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.004]  - attr(*, "resolved")= logi FALSE
[16:59:38.004]  - attr(*, "total_size")= num 1240
[16:59:38.007] Packages to be attached in all futures: [n=0] 
[16:59:38.007] getGlobalsAndPackagesXApply() ... DONE
[16:59:38.007] Number of futures (= number of chunks): 2
[16:59:38.007] Launching 2 futures (chunks) ...
[16:59:38.007] Chunk #1 of 2 ...
[16:59:38.007]  - Finding globals in 'X' for chunk #1 ...
[16:59:38.007] getGlobalsAndPackages() ...
[16:59:38.007] Searching for globals...
[16:59:38.008] 
[16:59:38.008] Searching for globals ... DONE
[16:59:38.008] - globals: [0] <none>
[16:59:38.008] getGlobalsAndPackages() ... DONE
[16:59:38.008]    + additional globals found: [n=0] 
[16:59:38.008]    + additional namespaces needed: [n=0] 
[16:59:38.008]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:38.008]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:38.008]  - seeds: <none>
[16:59:38.008]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.009] getGlobalsAndPackages() ...
[16:59:38.009] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.009] Resolving globals: FALSE
[16:59:38.009] Tweak future expression to call with '...' arguments ...
[16:59:38.009] {
[16:59:38.009]     do.call(function(...) {
[16:59:38.009]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.009]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.009]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.009]             on.exit(options(oopts), add = TRUE)
[16:59:38.009]         }
[16:59:38.009]         {
[16:59:38.009]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.009]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.009]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.009]             })
[16:59:38.009]         }
[16:59:38.009]     }, args = future.call.arguments)
[16:59:38.009] }
[16:59:38.009] Tweak future expression to call with '...' arguments ... DONE
[16:59:38.010] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.010] 
[16:59:38.010] getGlobalsAndPackages() ... DONE
[16:59:38.010] run() for ‘Future’ ...
[16:59:38.010] - state: ‘created’
[16:59:38.010] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:38.014] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.014] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:38.014]   - Field: ‘label’
[16:59:38.014]   - Field: ‘local’
[16:59:38.014]   - Field: ‘owner’
[16:59:38.014]   - Field: ‘envir’
[16:59:38.014]   - Field: ‘workers’
[16:59:38.015]   - Field: ‘packages’
[16:59:38.015]   - Field: ‘gc’
[16:59:38.015]   - Field: ‘job’
[16:59:38.015]   - Field: ‘conditions’
[16:59:38.015]   - Field: ‘expr’
[16:59:38.015]   - Field: ‘uuid’
[16:59:38.015]   - Field: ‘seed’
[16:59:38.015]   - Field: ‘version’
[16:59:38.015]   - Field: ‘result’
[16:59:38.015]   - Field: ‘asynchronous’
[16:59:38.016]   - Field: ‘calls’
[16:59:38.016]   - Field: ‘globals’
[16:59:38.016]   - Field: ‘stdout’
[16:59:38.016]   - Field: ‘earlySignal’
[16:59:38.016]   - Field: ‘lazy’
[16:59:38.016]   - Field: ‘state’
[16:59:38.016] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:38.016] - Launch lazy future ...
[16:59:38.017] Packages needed by the future expression (n = 0): <none>
[16:59:38.017] Packages needed by future strategies (n = 0): <none>
[16:59:38.018] {
[16:59:38.018]     {
[16:59:38.018]         {
[16:59:38.018]             ...future.startTime <- base::Sys.time()
[16:59:38.018]             {
[16:59:38.018]                 {
[16:59:38.018]                   {
[16:59:38.018]                     {
[16:59:38.018]                       base::local({
[16:59:38.018]                         has_future <- base::requireNamespace("future", 
[16:59:38.018]                           quietly = TRUE)
[16:59:38.018]                         if (has_future) {
[16:59:38.018]                           ns <- base::getNamespace("future")
[16:59:38.018]                           version <- ns[[".package"]][["version"]]
[16:59:38.018]                           if (is.null(version)) 
[16:59:38.018]                             version <- utils::packageVersion("future")
[16:59:38.018]                         }
[16:59:38.018]                         else {
[16:59:38.018]                           version <- NULL
[16:59:38.018]                         }
[16:59:38.018]                         if (!has_future || version < "1.8.0") {
[16:59:38.018]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:38.018]                             "", base::R.version$version.string), 
[16:59:38.018]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:38.018]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:38.018]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:38.018]                               "release", "version")], collapse = " "), 
[16:59:38.018]                             hostname = base::Sys.info()[["nodename"]])
[16:59:38.018]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:38.018]                             info)
[16:59:38.018]                           info <- base::paste(info, collapse = "; ")
[16:59:38.018]                           if (!has_future) {
[16:59:38.018]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:38.018]                               info)
[16:59:38.018]                           }
[16:59:38.018]                           else {
[16:59:38.018]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:38.018]                               info, version)
[16:59:38.018]                           }
[16:59:38.018]                           base::stop(msg)
[16:59:38.018]                         }
[16:59:38.018]                       })
[16:59:38.018]                     }
[16:59:38.018]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:38.018]                     base::options(mc.cores = 1L)
[16:59:38.018]                   }
[16:59:38.018]                   ...future.strategy.old <- future::plan("list")
[16:59:38.018]                   options(future.plan = NULL)
[16:59:38.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:38.018]                 }
[16:59:38.018]                 ...future.workdir <- getwd()
[16:59:38.018]             }
[16:59:38.018]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:38.018]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:38.018]         }
[16:59:38.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:38.018]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:38.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:38.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:38.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:38.018]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:38.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:38.018]             base::names(...future.oldOptions))
[16:59:38.018]     }
[16:59:38.018]     if (FALSE) {
[16:59:38.018]     }
[16:59:38.018]     else {
[16:59:38.018]         if (TRUE) {
[16:59:38.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:38.018]                 open = "w")
[16:59:38.018]         }
[16:59:38.018]         else {
[16:59:38.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:38.018]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:38.018]         }
[16:59:38.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:38.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:38.018]             base::sink(type = "output", split = FALSE)
[16:59:38.018]             base::close(...future.stdout)
[16:59:38.018]         }, add = TRUE)
[16:59:38.018]     }
[16:59:38.018]     ...future.frame <- base::sys.nframe()
[16:59:38.018]     ...future.conditions <- base::list()
[16:59:38.018]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:38.018]     if (FALSE) {
[16:59:38.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:38.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:38.018]     }
[16:59:38.018]     ...future.result <- base::tryCatch({
[16:59:38.018]         base::withCallingHandlers({
[16:59:38.018]             ...future.value <- base::withVisible(base::local({
[16:59:38.018]                 withCallingHandlers({
[16:59:38.018]                   {
[16:59:38.018]                     do.call(function(...) {
[16:59:38.018]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.018]                       if (!identical(...future.globals.maxSize.org, 
[16:59:38.018]                         ...future.globals.maxSize)) {
[16:59:38.018]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.018]                         on.exit(options(oopts), add = TRUE)
[16:59:38.018]                       }
[16:59:38.018]                       {
[16:59:38.018]                         lapply(seq_along(...future.elements_ii), 
[16:59:38.018]                           FUN = function(jj) {
[16:59:38.018]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.018]                             ...future.FUN(...future.X_jj, ...)
[16:59:38.018]                           })
[16:59:38.018]                       }
[16:59:38.018]                     }, args = future.call.arguments)
[16:59:38.018]                   }
[16:59:38.018]                 }, immediateCondition = function(cond) {
[16:59:38.018]                   save_rds <- function (object, pathname, ...) 
[16:59:38.018]                   {
[16:59:38.018]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:38.018]                     if (file_test("-f", pathname_tmp)) {
[16:59:38.018]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.018]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:38.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.018]                         fi_tmp[["mtime"]])
[16:59:38.018]                     }
[16:59:38.018]                     tryCatch({
[16:59:38.018]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:38.018]                     }, error = function(ex) {
[16:59:38.018]                       msg <- conditionMessage(ex)
[16:59:38.018]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.018]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:38.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.018]                         fi_tmp[["mtime"]], msg)
[16:59:38.018]                       ex$message <- msg
[16:59:38.018]                       stop(ex)
[16:59:38.018]                     })
[16:59:38.018]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:38.018]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:38.018]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:38.018]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.018]                       fi <- file.info(pathname)
[16:59:38.018]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:38.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.018]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:38.018]                         fi[["size"]], fi[["mtime"]])
[16:59:38.018]                       stop(msg)
[16:59:38.018]                     }
[16:59:38.018]                     invisible(pathname)
[16:59:38.018]                   }
[16:59:38.018]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:38.018]                     rootPath = tempdir()) 
[16:59:38.018]                   {
[16:59:38.018]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:38.018]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:38.018]                       tmpdir = path, fileext = ".rds")
[16:59:38.018]                     save_rds(obj, file)
[16:59:38.018]                   }
[16:59:38.018]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0io6nB/.future/immediateConditions")
[16:59:38.018]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.018]                   {
[16:59:38.018]                     inherits <- base::inherits
[16:59:38.018]                     invokeRestart <- base::invokeRestart
[16:59:38.018]                     is.null <- base::is.null
[16:59:38.018]                     muffled <- FALSE
[16:59:38.018]                     if (inherits(cond, "message")) {
[16:59:38.018]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:38.018]                       if (muffled) 
[16:59:38.018]                         invokeRestart("muffleMessage")
[16:59:38.018]                     }
[16:59:38.018]                     else if (inherits(cond, "warning")) {
[16:59:38.018]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:38.018]                       if (muffled) 
[16:59:38.018]                         invokeRestart("muffleWarning")
[16:59:38.018]                     }
[16:59:38.018]                     else if (inherits(cond, "condition")) {
[16:59:38.018]                       if (!is.null(pattern)) {
[16:59:38.018]                         computeRestarts <- base::computeRestarts
[16:59:38.018]                         grepl <- base::grepl
[16:59:38.018]                         restarts <- computeRestarts(cond)
[16:59:38.018]                         for (restart in restarts) {
[16:59:38.018]                           name <- restart$name
[16:59:38.018]                           if (is.null(name)) 
[16:59:38.018]                             next
[16:59:38.018]                           if (!grepl(pattern, name)) 
[16:59:38.018]                             next
[16:59:38.018]                           invokeRestart(restart)
[16:59:38.018]                           muffled <- TRUE
[16:59:38.018]                           break
[16:59:38.018]                         }
[16:59:38.018]                       }
[16:59:38.018]                     }
[16:59:38.018]                     invisible(muffled)
[16:59:38.018]                   }
[16:59:38.018]                   muffleCondition(cond)
[16:59:38.018]                 })
[16:59:38.018]             }))
[16:59:38.018]             future::FutureResult(value = ...future.value$value, 
[16:59:38.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.018]                   ...future.rng), globalenv = if (FALSE) 
[16:59:38.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:38.018]                     ...future.globalenv.names))
[16:59:38.018]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:38.018]         }, condition = base::local({
[16:59:38.018]             c <- base::c
[16:59:38.018]             inherits <- base::inherits
[16:59:38.018]             invokeRestart <- base::invokeRestart
[16:59:38.018]             length <- base::length
[16:59:38.018]             list <- base::list
[16:59:38.018]             seq.int <- base::seq.int
[16:59:38.018]             signalCondition <- base::signalCondition
[16:59:38.018]             sys.calls <- base::sys.calls
[16:59:38.018]             `[[` <- base::`[[`
[16:59:38.018]             `+` <- base::`+`
[16:59:38.018]             `<<-` <- base::`<<-`
[16:59:38.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:38.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:38.018]                   3L)]
[16:59:38.018]             }
[16:59:38.018]             function(cond) {
[16:59:38.018]                 is_error <- inherits(cond, "error")
[16:59:38.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:38.018]                   NULL)
[16:59:38.018]                 if (is_error) {
[16:59:38.018]                   sessionInformation <- function() {
[16:59:38.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:38.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:38.018]                       search = base::search(), system = base::Sys.info())
[16:59:38.018]                   }
[16:59:38.018]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:38.018]                     cond$call), session = sessionInformation(), 
[16:59:38.018]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:38.018]                   signalCondition(cond)
[16:59:38.018]                 }
[16:59:38.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:38.018]                 "immediateCondition"))) {
[16:59:38.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:38.018]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:38.018]                   if (TRUE && !signal) {
[16:59:38.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.018]                     {
[16:59:38.018]                       inherits <- base::inherits
[16:59:38.018]                       invokeRestart <- base::invokeRestart
[16:59:38.018]                       is.null <- base::is.null
[16:59:38.018]                       muffled <- FALSE
[16:59:38.018]                       if (inherits(cond, "message")) {
[16:59:38.018]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.018]                         if (muffled) 
[16:59:38.018]                           invokeRestart("muffleMessage")
[16:59:38.018]                       }
[16:59:38.018]                       else if (inherits(cond, "warning")) {
[16:59:38.018]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.018]                         if (muffled) 
[16:59:38.018]                           invokeRestart("muffleWarning")
[16:59:38.018]                       }
[16:59:38.018]                       else if (inherits(cond, "condition")) {
[16:59:38.018]                         if (!is.null(pattern)) {
[16:59:38.018]                           computeRestarts <- base::computeRestarts
[16:59:38.018]                           grepl <- base::grepl
[16:59:38.018]                           restarts <- computeRestarts(cond)
[16:59:38.018]                           for (restart in restarts) {
[16:59:38.018]                             name <- restart$name
[16:59:38.018]                             if (is.null(name)) 
[16:59:38.018]                               next
[16:59:38.018]                             if (!grepl(pattern, name)) 
[16:59:38.018]                               next
[16:59:38.018]                             invokeRestart(restart)
[16:59:38.018]                             muffled <- TRUE
[16:59:38.018]                             break
[16:59:38.018]                           }
[16:59:38.018]                         }
[16:59:38.018]                       }
[16:59:38.018]                       invisible(muffled)
[16:59:38.018]                     }
[16:59:38.018]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.018]                   }
[16:59:38.018]                 }
[16:59:38.018]                 else {
[16:59:38.018]                   if (TRUE) {
[16:59:38.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.018]                     {
[16:59:38.018]                       inherits <- base::inherits
[16:59:38.018]                       invokeRestart <- base::invokeRestart
[16:59:38.018]                       is.null <- base::is.null
[16:59:38.018]                       muffled <- FALSE
[16:59:38.018]                       if (inherits(cond, "message")) {
[16:59:38.018]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.018]                         if (muffled) 
[16:59:38.018]                           invokeRestart("muffleMessage")
[16:59:38.018]                       }
[16:59:38.018]                       else if (inherits(cond, "warning")) {
[16:59:38.018]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.018]                         if (muffled) 
[16:59:38.018]                           invokeRestart("muffleWarning")
[16:59:38.018]                       }
[16:59:38.018]                       else if (inherits(cond, "condition")) {
[16:59:38.018]                         if (!is.null(pattern)) {
[16:59:38.018]                           computeRestarts <- base::computeRestarts
[16:59:38.018]                           grepl <- base::grepl
[16:59:38.018]                           restarts <- computeRestarts(cond)
[16:59:38.018]                           for (restart in restarts) {
[16:59:38.018]                             name <- restart$name
[16:59:38.018]                             if (is.null(name)) 
[16:59:38.018]                               next
[16:59:38.018]                             if (!grepl(pattern, name)) 
[16:59:38.018]                               next
[16:59:38.018]                             invokeRestart(restart)
[16:59:38.018]                             muffled <- TRUE
[16:59:38.018]                             break
[16:59:38.018]                           }
[16:59:38.018]                         }
[16:59:38.018]                       }
[16:59:38.018]                       invisible(muffled)
[16:59:38.018]                     }
[16:59:38.018]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.018]                   }
[16:59:38.018]                 }
[16:59:38.018]             }
[16:59:38.018]         }))
[16:59:38.018]     }, error = function(ex) {
[16:59:38.018]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:38.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.018]                 ...future.rng), started = ...future.startTime, 
[16:59:38.018]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:38.018]             version = "1.8"), class = "FutureResult")
[16:59:38.018]     }, finally = {
[16:59:38.018]         if (!identical(...future.workdir, getwd())) 
[16:59:38.018]             setwd(...future.workdir)
[16:59:38.018]         {
[16:59:38.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:38.018]                 ...future.oldOptions$nwarnings <- NULL
[16:59:38.018]             }
[16:59:38.018]             base::options(...future.oldOptions)
[16:59:38.018]             if (.Platform$OS.type == "windows") {
[16:59:38.018]                 old_names <- names(...future.oldEnvVars)
[16:59:38.018]                 envs <- base::Sys.getenv()
[16:59:38.018]                 names <- names(envs)
[16:59:38.018]                 common <- intersect(names, old_names)
[16:59:38.018]                 added <- setdiff(names, old_names)
[16:59:38.018]                 removed <- setdiff(old_names, names)
[16:59:38.018]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:38.018]                   envs[common]]
[16:59:38.018]                 NAMES <- toupper(changed)
[16:59:38.018]                 args <- list()
[16:59:38.018]                 for (kk in seq_along(NAMES)) {
[16:59:38.018]                   name <- changed[[kk]]
[16:59:38.018]                   NAME <- NAMES[[kk]]
[16:59:38.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.018]                     next
[16:59:38.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.018]                 }
[16:59:38.018]                 NAMES <- toupper(added)
[16:59:38.018]                 for (kk in seq_along(NAMES)) {
[16:59:38.018]                   name <- added[[kk]]
[16:59:38.018]                   NAME <- NAMES[[kk]]
[16:59:38.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.018]                     next
[16:59:38.018]                   args[[name]] <- ""
[16:59:38.018]                 }
[16:59:38.018]                 NAMES <- toupper(removed)
[16:59:38.018]                 for (kk in seq_along(NAMES)) {
[16:59:38.018]                   name <- removed[[kk]]
[16:59:38.018]                   NAME <- NAMES[[kk]]
[16:59:38.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.018]                     next
[16:59:38.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.018]                 }
[16:59:38.018]                 if (length(args) > 0) 
[16:59:38.018]                   base::do.call(base::Sys.setenv, args = args)
[16:59:38.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:38.018]             }
[16:59:38.018]             else {
[16:59:38.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:38.018]             }
[16:59:38.018]             {
[16:59:38.018]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:38.018]                   0L) {
[16:59:38.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:38.018]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:38.018]                   base::options(opts)
[16:59:38.018]                 }
[16:59:38.018]                 {
[16:59:38.018]                   {
[16:59:38.018]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:38.018]                     NULL
[16:59:38.018]                   }
[16:59:38.018]                   options(future.plan = NULL)
[16:59:38.018]                   if (is.na(NA_character_)) 
[16:59:38.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:38.018]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:38.018]                     .init = FALSE)
[16:59:38.018]                 }
[16:59:38.018]             }
[16:59:38.018]         }
[16:59:38.018]     })
[16:59:38.018]     if (TRUE) {
[16:59:38.018]         base::sink(type = "output", split = FALSE)
[16:59:38.018]         if (TRUE) {
[16:59:38.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:38.018]         }
[16:59:38.018]         else {
[16:59:38.018]             ...future.result["stdout"] <- base::list(NULL)
[16:59:38.018]         }
[16:59:38.018]         base::close(...future.stdout)
[16:59:38.018]         ...future.stdout <- NULL
[16:59:38.018]     }
[16:59:38.018]     ...future.result$conditions <- ...future.conditions
[16:59:38.018]     ...future.result$finished <- base::Sys.time()
[16:59:38.018]     ...future.result
[16:59:38.018] }
[16:59:38.020] assign_globals() ...
[16:59:38.020] List of 5
[16:59:38.020]  $ ...future.FUN            :function (x, ...)  
[16:59:38.020]  $ future.call.arguments    : list()
[16:59:38.020]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.020]  $ ...future.elements_ii    :List of 1
[16:59:38.020]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[16:59:38.020]  $ ...future.seeds_ii       : NULL
[16:59:38.020]  $ ...future.globals.maxSize: NULL
[16:59:38.020]  - attr(*, "where")=List of 5
[16:59:38.020]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:38.020]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:38.020]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:38.020]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:38.020]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:38.020]  - attr(*, "resolved")= logi FALSE
[16:59:38.020]  - attr(*, "total_size")= num 1240
[16:59:38.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.020]  - attr(*, "already-done")= logi TRUE
[16:59:38.024] - copied ‘...future.FUN’ to environment
[16:59:38.025] - copied ‘future.call.arguments’ to environment
[16:59:38.025] - copied ‘...future.elements_ii’ to environment
[16:59:38.025] - copied ‘...future.seeds_ii’ to environment
[16:59:38.025] - copied ‘...future.globals.maxSize’ to environment
[16:59:38.025] assign_globals() ... done
[16:59:38.025] requestCore(): workers = 2
[16:59:38.028] MulticoreFuture started
[16:59:38.028] - Launch lazy future ... done
[16:59:38.029] plan(): Setting new future strategy stack:
[16:59:38.029] run() for ‘MulticoreFuture’ ... done
[16:59:38.029] Created future:
[16:59:38.029] List of future strategies:
[16:59:38.029] 1. sequential:
[16:59:38.029]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:38.029]    - tweaked: FALSE
[16:59:38.029]    - call: NULL
[16:59:38.030] plan(): nbrOfWorkers() = 1
[16:59:38.032] plan(): Setting new future strategy stack:
[16:59:38.032] List of future strategies:
[16:59:38.032] 1. multicore:
[16:59:38.032]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:38.032]    - tweaked: FALSE
[16:59:38.032]    - call: plan(strategy)
[16:59:38.041] plan(): nbrOfWorkers() = 2
[16:59:38.029] MulticoreFuture:
[16:59:38.029] Label: ‘future_eapply-1’
[16:59:38.029] Expression:
[16:59:38.029] {
[16:59:38.029]     do.call(function(...) {
[16:59:38.029]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.029]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.029]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.029]             on.exit(options(oopts), add = TRUE)
[16:59:38.029]         }
[16:59:38.029]         {
[16:59:38.029]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.029]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.029]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.029]             })
[16:59:38.029]         }
[16:59:38.029]     }, args = future.call.arguments)
[16:59:38.029] }
[16:59:38.029] Lazy evaluation: FALSE
[16:59:38.029] Asynchronous evaluation: TRUE
[16:59:38.029] Local evaluation: TRUE
[16:59:38.029] Environment: R_GlobalEnv
[16:59:38.029] Capture standard output: TRUE
[16:59:38.029] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:38.029] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:38.029] Packages: <none>
[16:59:38.029] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:38.029] Resolved: TRUE
[16:59:38.029] Value: <not collected>
[16:59:38.029] Conditions captured: <none>
[16:59:38.029] Early signaling: FALSE
[16:59:38.029] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:38.029] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.042] Chunk #1 of 2 ... DONE
[16:59:38.043] Chunk #2 of 2 ...
[16:59:38.043]  - Finding globals in 'X' for chunk #2 ...
[16:59:38.043] getGlobalsAndPackages() ...
[16:59:38.043] Searching for globals...
[16:59:38.043] 
[16:59:38.044] Searching for globals ... DONE
[16:59:38.046] - globals: [0] <none>
[16:59:38.046] getGlobalsAndPackages() ... DONE
[16:59:38.046]    + additional globals found: [n=0] 
[16:59:38.046]    + additional namespaces needed: [n=0] 
[16:59:38.047]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:38.047]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:38.047]  - seeds: <none>
[16:59:38.047]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.047] getGlobalsAndPackages() ...
[16:59:38.047] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.048] Resolving globals: FALSE
[16:59:38.048] Tweak future expression to call with '...' arguments ...
[16:59:38.048] {
[16:59:38.048]     do.call(function(...) {
[16:59:38.048]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.048]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.048]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.048]             on.exit(options(oopts), add = TRUE)
[16:59:38.048]         }
[16:59:38.048]         {
[16:59:38.048]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.048]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.048]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.048]             })
[16:59:38.048]         }
[16:59:38.048]     }, args = future.call.arguments)
[16:59:38.048] }
[16:59:38.048] Tweak future expression to call with '...' arguments ... DONE
[16:59:38.049] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.050] 
[16:59:38.050] getGlobalsAndPackages() ... DONE
[16:59:38.050] run() for ‘Future’ ...
[16:59:38.051] - state: ‘created’
[16:59:38.051] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:38.055] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.056] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:38.056]   - Field: ‘label’
[16:59:38.056]   - Field: ‘local’
[16:59:38.056]   - Field: ‘owner’
[16:59:38.056]   - Field: ‘envir’
[16:59:38.056]   - Field: ‘workers’
[16:59:38.057]   - Field: ‘packages’
[16:59:38.057]   - Field: ‘gc’
[16:59:38.057]   - Field: ‘job’
[16:59:38.057]   - Field: ‘conditions’
[16:59:38.057]   - Field: ‘expr’
[16:59:38.057]   - Field: ‘uuid’
[16:59:38.058]   - Field: ‘seed’
[16:59:38.058]   - Field: ‘version’
[16:59:38.058]   - Field: ‘result’
[16:59:38.058]   - Field: ‘asynchronous’
[16:59:38.058]   - Field: ‘calls’
[16:59:38.058]   - Field: ‘globals’
[16:59:38.059]   - Field: ‘stdout’
[16:59:38.059]   - Field: ‘earlySignal’
[16:59:38.059]   - Field: ‘lazy’
[16:59:38.059]   - Field: ‘state’
[16:59:38.059] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:38.059] - Launch lazy future ...
[16:59:38.060] Packages needed by the future expression (n = 0): <none>
[16:59:38.060] Packages needed by future strategies (n = 0): <none>
[16:59:38.060] {
[16:59:38.060]     {
[16:59:38.060]         {
[16:59:38.060]             ...future.startTime <- base::Sys.time()
[16:59:38.060]             {
[16:59:38.060]                 {
[16:59:38.060]                   {
[16:59:38.060]                     {
[16:59:38.060]                       base::local({
[16:59:38.060]                         has_future <- base::requireNamespace("future", 
[16:59:38.060]                           quietly = TRUE)
[16:59:38.060]                         if (has_future) {
[16:59:38.060]                           ns <- base::getNamespace("future")
[16:59:38.060]                           version <- ns[[".package"]][["version"]]
[16:59:38.060]                           if (is.null(version)) 
[16:59:38.060]                             version <- utils::packageVersion("future")
[16:59:38.060]                         }
[16:59:38.060]                         else {
[16:59:38.060]                           version <- NULL
[16:59:38.060]                         }
[16:59:38.060]                         if (!has_future || version < "1.8.0") {
[16:59:38.060]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:38.060]                             "", base::R.version$version.string), 
[16:59:38.060]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:38.060]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:38.060]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:38.060]                               "release", "version")], collapse = " "), 
[16:59:38.060]                             hostname = base::Sys.info()[["nodename"]])
[16:59:38.060]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:38.060]                             info)
[16:59:38.060]                           info <- base::paste(info, collapse = "; ")
[16:59:38.060]                           if (!has_future) {
[16:59:38.060]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:38.060]                               info)
[16:59:38.060]                           }
[16:59:38.060]                           else {
[16:59:38.060]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:38.060]                               info, version)
[16:59:38.060]                           }
[16:59:38.060]                           base::stop(msg)
[16:59:38.060]                         }
[16:59:38.060]                       })
[16:59:38.060]                     }
[16:59:38.060]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:38.060]                     base::options(mc.cores = 1L)
[16:59:38.060]                   }
[16:59:38.060]                   ...future.strategy.old <- future::plan("list")
[16:59:38.060]                   options(future.plan = NULL)
[16:59:38.060]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.060]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:38.060]                 }
[16:59:38.060]                 ...future.workdir <- getwd()
[16:59:38.060]             }
[16:59:38.060]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:38.060]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:38.060]         }
[16:59:38.060]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:38.060]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:38.060]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:38.060]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:38.060]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:38.060]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:38.060]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:38.060]             base::names(...future.oldOptions))
[16:59:38.060]     }
[16:59:38.060]     if (FALSE) {
[16:59:38.060]     }
[16:59:38.060]     else {
[16:59:38.060]         if (TRUE) {
[16:59:38.060]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:38.060]                 open = "w")
[16:59:38.060]         }
[16:59:38.060]         else {
[16:59:38.060]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:38.060]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:38.060]         }
[16:59:38.060]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:38.060]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:38.060]             base::sink(type = "output", split = FALSE)
[16:59:38.060]             base::close(...future.stdout)
[16:59:38.060]         }, add = TRUE)
[16:59:38.060]     }
[16:59:38.060]     ...future.frame <- base::sys.nframe()
[16:59:38.060]     ...future.conditions <- base::list()
[16:59:38.060]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:38.060]     if (FALSE) {
[16:59:38.060]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:38.060]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:38.060]     }
[16:59:38.060]     ...future.result <- base::tryCatch({
[16:59:38.060]         base::withCallingHandlers({
[16:59:38.060]             ...future.value <- base::withVisible(base::local({
[16:59:38.060]                 withCallingHandlers({
[16:59:38.060]                   {
[16:59:38.060]                     do.call(function(...) {
[16:59:38.060]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.060]                       if (!identical(...future.globals.maxSize.org, 
[16:59:38.060]                         ...future.globals.maxSize)) {
[16:59:38.060]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.060]                         on.exit(options(oopts), add = TRUE)
[16:59:38.060]                       }
[16:59:38.060]                       {
[16:59:38.060]                         lapply(seq_along(...future.elements_ii), 
[16:59:38.060]                           FUN = function(jj) {
[16:59:38.060]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.060]                             ...future.FUN(...future.X_jj, ...)
[16:59:38.060]                           })
[16:59:38.060]                       }
[16:59:38.060]                     }, args = future.call.arguments)
[16:59:38.060]                   }
[16:59:38.060]                 }, immediateCondition = function(cond) {
[16:59:38.060]                   save_rds <- function (object, pathname, ...) 
[16:59:38.060]                   {
[16:59:38.060]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:38.060]                     if (file_test("-f", pathname_tmp)) {
[16:59:38.060]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.060]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:38.060]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.060]                         fi_tmp[["mtime"]])
[16:59:38.060]                     }
[16:59:38.060]                     tryCatch({
[16:59:38.060]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:38.060]                     }, error = function(ex) {
[16:59:38.060]                       msg <- conditionMessage(ex)
[16:59:38.060]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.060]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:38.060]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.060]                         fi_tmp[["mtime"]], msg)
[16:59:38.060]                       ex$message <- msg
[16:59:38.060]                       stop(ex)
[16:59:38.060]                     })
[16:59:38.060]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:38.060]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:38.060]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:38.060]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.060]                       fi <- file.info(pathname)
[16:59:38.060]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:38.060]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.060]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:38.060]                         fi[["size"]], fi[["mtime"]])
[16:59:38.060]                       stop(msg)
[16:59:38.060]                     }
[16:59:38.060]                     invisible(pathname)
[16:59:38.060]                   }
[16:59:38.060]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:38.060]                     rootPath = tempdir()) 
[16:59:38.060]                   {
[16:59:38.060]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:38.060]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:38.060]                       tmpdir = path, fileext = ".rds")
[16:59:38.060]                     save_rds(obj, file)
[16:59:38.060]                   }
[16:59:38.060]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0io6nB/.future/immediateConditions")
[16:59:38.060]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.060]                   {
[16:59:38.060]                     inherits <- base::inherits
[16:59:38.060]                     invokeRestart <- base::invokeRestart
[16:59:38.060]                     is.null <- base::is.null
[16:59:38.060]                     muffled <- FALSE
[16:59:38.060]                     if (inherits(cond, "message")) {
[16:59:38.060]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:38.060]                       if (muffled) 
[16:59:38.060]                         invokeRestart("muffleMessage")
[16:59:38.060]                     }
[16:59:38.060]                     else if (inherits(cond, "warning")) {
[16:59:38.060]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:38.060]                       if (muffled) 
[16:59:38.060]                         invokeRestart("muffleWarning")
[16:59:38.060]                     }
[16:59:38.060]                     else if (inherits(cond, "condition")) {
[16:59:38.060]                       if (!is.null(pattern)) {
[16:59:38.060]                         computeRestarts <- base::computeRestarts
[16:59:38.060]                         grepl <- base::grepl
[16:59:38.060]                         restarts <- computeRestarts(cond)
[16:59:38.060]                         for (restart in restarts) {
[16:59:38.060]                           name <- restart$name
[16:59:38.060]                           if (is.null(name)) 
[16:59:38.060]                             next
[16:59:38.060]                           if (!grepl(pattern, name)) 
[16:59:38.060]                             next
[16:59:38.060]                           invokeRestart(restart)
[16:59:38.060]                           muffled <- TRUE
[16:59:38.060]                           break
[16:59:38.060]                         }
[16:59:38.060]                       }
[16:59:38.060]                     }
[16:59:38.060]                     invisible(muffled)
[16:59:38.060]                   }
[16:59:38.060]                   muffleCondition(cond)
[16:59:38.060]                 })
[16:59:38.060]             }))
[16:59:38.060]             future::FutureResult(value = ...future.value$value, 
[16:59:38.060]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.060]                   ...future.rng), globalenv = if (FALSE) 
[16:59:38.060]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:38.060]                     ...future.globalenv.names))
[16:59:38.060]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:38.060]         }, condition = base::local({
[16:59:38.060]             c <- base::c
[16:59:38.060]             inherits <- base::inherits
[16:59:38.060]             invokeRestart <- base::invokeRestart
[16:59:38.060]             length <- base::length
[16:59:38.060]             list <- base::list
[16:59:38.060]             seq.int <- base::seq.int
[16:59:38.060]             signalCondition <- base::signalCondition
[16:59:38.060]             sys.calls <- base::sys.calls
[16:59:38.060]             `[[` <- base::`[[`
[16:59:38.060]             `+` <- base::`+`
[16:59:38.060]             `<<-` <- base::`<<-`
[16:59:38.060]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:38.060]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:38.060]                   3L)]
[16:59:38.060]             }
[16:59:38.060]             function(cond) {
[16:59:38.060]                 is_error <- inherits(cond, "error")
[16:59:38.060]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:38.060]                   NULL)
[16:59:38.060]                 if (is_error) {
[16:59:38.060]                   sessionInformation <- function() {
[16:59:38.060]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:38.060]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:38.060]                       search = base::search(), system = base::Sys.info())
[16:59:38.060]                   }
[16:59:38.060]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.060]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:38.060]                     cond$call), session = sessionInformation(), 
[16:59:38.060]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:38.060]                   signalCondition(cond)
[16:59:38.060]                 }
[16:59:38.060]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:38.060]                 "immediateCondition"))) {
[16:59:38.060]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:38.060]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.060]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:38.060]                   if (TRUE && !signal) {
[16:59:38.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.060]                     {
[16:59:38.060]                       inherits <- base::inherits
[16:59:38.060]                       invokeRestart <- base::invokeRestart
[16:59:38.060]                       is.null <- base::is.null
[16:59:38.060]                       muffled <- FALSE
[16:59:38.060]                       if (inherits(cond, "message")) {
[16:59:38.060]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.060]                         if (muffled) 
[16:59:38.060]                           invokeRestart("muffleMessage")
[16:59:38.060]                       }
[16:59:38.060]                       else if (inherits(cond, "warning")) {
[16:59:38.060]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.060]                         if (muffled) 
[16:59:38.060]                           invokeRestart("muffleWarning")
[16:59:38.060]                       }
[16:59:38.060]                       else if (inherits(cond, "condition")) {
[16:59:38.060]                         if (!is.null(pattern)) {
[16:59:38.060]                           computeRestarts <- base::computeRestarts
[16:59:38.060]                           grepl <- base::grepl
[16:59:38.060]                           restarts <- computeRestarts(cond)
[16:59:38.060]                           for (restart in restarts) {
[16:59:38.060]                             name <- restart$name
[16:59:38.060]                             if (is.null(name)) 
[16:59:38.060]                               next
[16:59:38.060]                             if (!grepl(pattern, name)) 
[16:59:38.060]                               next
[16:59:38.060]                             invokeRestart(restart)
[16:59:38.060]                             muffled <- TRUE
[16:59:38.060]                             break
[16:59:38.060]                           }
[16:59:38.060]                         }
[16:59:38.060]                       }
[16:59:38.060]                       invisible(muffled)
[16:59:38.060]                     }
[16:59:38.060]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.060]                   }
[16:59:38.060]                 }
[16:59:38.060]                 else {
[16:59:38.060]                   if (TRUE) {
[16:59:38.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.060]                     {
[16:59:38.060]                       inherits <- base::inherits
[16:59:38.060]                       invokeRestart <- base::invokeRestart
[16:59:38.060]                       is.null <- base::is.null
[16:59:38.060]                       muffled <- FALSE
[16:59:38.060]                       if (inherits(cond, "message")) {
[16:59:38.060]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.060]                         if (muffled) 
[16:59:38.060]                           invokeRestart("muffleMessage")
[16:59:38.060]                       }
[16:59:38.060]                       else if (inherits(cond, "warning")) {
[16:59:38.060]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.060]                         if (muffled) 
[16:59:38.060]                           invokeRestart("muffleWarning")
[16:59:38.060]                       }
[16:59:38.060]                       else if (inherits(cond, "condition")) {
[16:59:38.060]                         if (!is.null(pattern)) {
[16:59:38.060]                           computeRestarts <- base::computeRestarts
[16:59:38.060]                           grepl <- base::grepl
[16:59:38.060]                           restarts <- computeRestarts(cond)
[16:59:38.060]                           for (restart in restarts) {
[16:59:38.060]                             name <- restart$name
[16:59:38.060]                             if (is.null(name)) 
[16:59:38.060]                               next
[16:59:38.060]                             if (!grepl(pattern, name)) 
[16:59:38.060]                               next
[16:59:38.060]                             invokeRestart(restart)
[16:59:38.060]                             muffled <- TRUE
[16:59:38.060]                             break
[16:59:38.060]                           }
[16:59:38.060]                         }
[16:59:38.060]                       }
[16:59:38.060]                       invisible(muffled)
[16:59:38.060]                     }
[16:59:38.060]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.060]                   }
[16:59:38.060]                 }
[16:59:38.060]             }
[16:59:38.060]         }))
[16:59:38.060]     }, error = function(ex) {
[16:59:38.060]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:38.060]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.060]                 ...future.rng), started = ...future.startTime, 
[16:59:38.060]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:38.060]             version = "1.8"), class = "FutureResult")
[16:59:38.060]     }, finally = {
[16:59:38.060]         if (!identical(...future.workdir, getwd())) 
[16:59:38.060]             setwd(...future.workdir)
[16:59:38.060]         {
[16:59:38.060]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:38.060]                 ...future.oldOptions$nwarnings <- NULL
[16:59:38.060]             }
[16:59:38.060]             base::options(...future.oldOptions)
[16:59:38.060]             if (.Platform$OS.type == "windows") {
[16:59:38.060]                 old_names <- names(...future.oldEnvVars)
[16:59:38.060]                 envs <- base::Sys.getenv()
[16:59:38.060]                 names <- names(envs)
[16:59:38.060]                 common <- intersect(names, old_names)
[16:59:38.060]                 added <- setdiff(names, old_names)
[16:59:38.060]                 removed <- setdiff(old_names, names)
[16:59:38.060]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:38.060]                   envs[common]]
[16:59:38.060]                 NAMES <- toupper(changed)
[16:59:38.060]                 args <- list()
[16:59:38.060]                 for (kk in seq_along(NAMES)) {
[16:59:38.060]                   name <- changed[[kk]]
[16:59:38.060]                   NAME <- NAMES[[kk]]
[16:59:38.060]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.060]                     next
[16:59:38.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.060]                 }
[16:59:38.060]                 NAMES <- toupper(added)
[16:59:38.060]                 for (kk in seq_along(NAMES)) {
[16:59:38.060]                   name <- added[[kk]]
[16:59:38.060]                   NAME <- NAMES[[kk]]
[16:59:38.060]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.060]                     next
[16:59:38.060]                   args[[name]] <- ""
[16:59:38.060]                 }
[16:59:38.060]                 NAMES <- toupper(removed)
[16:59:38.060]                 for (kk in seq_along(NAMES)) {
[16:59:38.060]                   name <- removed[[kk]]
[16:59:38.060]                   NAME <- NAMES[[kk]]
[16:59:38.060]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.060]                     next
[16:59:38.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.060]                 }
[16:59:38.060]                 if (length(args) > 0) 
[16:59:38.060]                   base::do.call(base::Sys.setenv, args = args)
[16:59:38.060]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:38.060]             }
[16:59:38.060]             else {
[16:59:38.060]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:38.060]             }
[16:59:38.060]             {
[16:59:38.060]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:38.060]                   0L) {
[16:59:38.060]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:38.060]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:38.060]                   base::options(opts)
[16:59:38.060]                 }
[16:59:38.060]                 {
[16:59:38.060]                   {
[16:59:38.060]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:38.060]                     NULL
[16:59:38.060]                   }
[16:59:38.060]                   options(future.plan = NULL)
[16:59:38.060]                   if (is.na(NA_character_)) 
[16:59:38.060]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.060]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:38.060]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:38.060]                     .init = FALSE)
[16:59:38.060]                 }
[16:59:38.060]             }
[16:59:38.060]         }
[16:59:38.060]     })
[16:59:38.060]     if (TRUE) {
[16:59:38.060]         base::sink(type = "output", split = FALSE)
[16:59:38.060]         if (TRUE) {
[16:59:38.060]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:38.060]         }
[16:59:38.060]         else {
[16:59:38.060]             ...future.result["stdout"] <- base::list(NULL)
[16:59:38.060]         }
[16:59:38.060]         base::close(...future.stdout)
[16:59:38.060]         ...future.stdout <- NULL
[16:59:38.060]     }
[16:59:38.060]     ...future.result$conditions <- ...future.conditions
[16:59:38.060]     ...future.result$finished <- base::Sys.time()
[16:59:38.060]     ...future.result
[16:59:38.060] }
[16:59:38.063] assign_globals() ...
[16:59:38.063] List of 5
[16:59:38.063]  $ ...future.FUN            :function (x, ...)  
[16:59:38.063]  $ future.call.arguments    : list()
[16:59:38.063]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.063]  $ ...future.elements_ii    :List of 2
[16:59:38.063]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:59:38.063]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:59:38.063]  $ ...future.seeds_ii       : NULL
[16:59:38.063]  $ ...future.globals.maxSize: NULL
[16:59:38.063]  - attr(*, "where")=List of 5
[16:59:38.063]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:38.063]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:38.063]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:38.063]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:38.063]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:38.063]  - attr(*, "resolved")= logi FALSE
[16:59:38.063]  - attr(*, "total_size")= num 1240
[16:59:38.063]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.063]  - attr(*, "already-done")= logi TRUE
[16:59:38.070] - copied ‘...future.FUN’ to environment
[16:59:38.070] - copied ‘future.call.arguments’ to environment
[16:59:38.071] - copied ‘...future.elements_ii’ to environment
[16:59:38.071] - copied ‘...future.seeds_ii’ to environment
[16:59:38.071] - copied ‘...future.globals.maxSize’ to environment
[16:59:38.071] assign_globals() ... done
[16:59:38.071] requestCore(): workers = 2
[16:59:38.076] MulticoreFuture started
[16:59:38.077] - Launch lazy future ... done
[16:59:38.077] run() for ‘MulticoreFuture’ ... done
[16:59:38.077] Created future:
[16:59:38.077] plan(): Setting new future strategy stack:
[16:59:38.078] List of future strategies:
[16:59:38.078] 1. sequential:
[16:59:38.078]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:38.078]    - tweaked: FALSE
[16:59:38.078]    - call: NULL
[16:59:38.079] plan(): nbrOfWorkers() = 1
[16:59:38.081] plan(): Setting new future strategy stack:
[16:59:38.081] List of future strategies:
[16:59:38.081] 1. multicore:
[16:59:38.081]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:38.081]    - tweaked: FALSE
[16:59:38.081]    - call: plan(strategy)
[16:59:38.086] plan(): nbrOfWorkers() = 2
[16:59:38.077] MulticoreFuture:
[16:59:38.077] Label: ‘future_eapply-2’
[16:59:38.077] Expression:
[16:59:38.077] {
[16:59:38.077]     do.call(function(...) {
[16:59:38.077]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.077]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.077]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.077]             on.exit(options(oopts), add = TRUE)
[16:59:38.077]         }
[16:59:38.077]         {
[16:59:38.077]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.077]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.077]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.077]             })
[16:59:38.077]         }
[16:59:38.077]     }, args = future.call.arguments)
[16:59:38.077] }
[16:59:38.077] Lazy evaluation: FALSE
[16:59:38.077] Asynchronous evaluation: TRUE
[16:59:38.077] Local evaluation: TRUE
[16:59:38.077] Environment: R_GlobalEnv
[16:59:38.077] Capture standard output: TRUE
[16:59:38.077] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:38.077] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:38.077] Packages: <none>
[16:59:38.077] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:38.077] Resolved: TRUE
[16:59:38.077] Value: <not collected>
[16:59:38.077] Conditions captured: <none>
[16:59:38.077] Early signaling: FALSE
[16:59:38.077] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:38.077] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.087] Chunk #2 of 2 ... DONE
[16:59:38.087] Launching 2 futures (chunks) ... DONE
[16:59:38.087] Resolving 2 futures (chunks) ...
[16:59:38.087] resolve() on list ...
[16:59:38.087]  recursive: 0
[16:59:38.088]  length: 2
[16:59:38.088] 
[16:59:38.088] Future #1
[16:59:38.089] result() for MulticoreFuture ...
[16:59:38.090] result() for MulticoreFuture ...
[16:59:38.091] result() for MulticoreFuture ... done
[16:59:38.091] result() for MulticoreFuture ... done
[16:59:38.091] result() for MulticoreFuture ...
[16:59:38.091] result() for MulticoreFuture ... done
[16:59:38.091] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:38.091] - nx: 2
[16:59:38.092] - relay: TRUE
[16:59:38.092] - stdout: TRUE
[16:59:38.092] - signal: TRUE
[16:59:38.092] - resignal: FALSE
[16:59:38.092] - force: TRUE
[16:59:38.092] - relayed: [n=2] FALSE, FALSE
[16:59:38.092] - queued futures: [n=2] FALSE, FALSE
[16:59:38.093]  - until=1
[16:59:38.093]  - relaying element #1
[16:59:38.093] result() for MulticoreFuture ...
[16:59:38.093] result() for MulticoreFuture ... done
[16:59:38.093] result() for MulticoreFuture ...
[16:59:38.093] result() for MulticoreFuture ... done
[16:59:38.093] result() for MulticoreFuture ...
[16:59:38.094] result() for MulticoreFuture ... done
[16:59:38.094] result() for MulticoreFuture ...
[16:59:38.094] result() for MulticoreFuture ... done
[16:59:38.094] - relayed: [n=2] TRUE, FALSE
[16:59:38.094] - queued futures: [n=2] TRUE, FALSE
[16:59:38.094] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:38.094]  length: 1 (resolved future 1)
[16:59:38.095] Future #2
[16:59:38.095] result() for MulticoreFuture ...
[16:59:38.095] result() for MulticoreFuture ...
[16:59:38.096] result() for MulticoreFuture ... done
[16:59:38.096] result() for MulticoreFuture ... done
[16:59:38.098] result() for MulticoreFuture ...
[16:59:38.098] result() for MulticoreFuture ... done
[16:59:38.099] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:38.099] - nx: 2
[16:59:38.099] - relay: TRUE
[16:59:38.099] - stdout: TRUE
[16:59:38.099] - signal: TRUE
[16:59:38.099] - resignal: FALSE
[16:59:38.099] - force: TRUE
[16:59:38.099] - relayed: [n=2] TRUE, FALSE
[16:59:38.099] - queued futures: [n=2] TRUE, FALSE
[16:59:38.100]  - until=2
[16:59:38.100]  - relaying element #2
[16:59:38.100] result() for MulticoreFuture ...
[16:59:38.100] result() for MulticoreFuture ... done
[16:59:38.100] result() for MulticoreFuture ...
[16:59:38.100] result() for MulticoreFuture ... done
[16:59:38.100] result() for MulticoreFuture ...
[16:59:38.101] result() for MulticoreFuture ... done
[16:59:38.101] result() for MulticoreFuture ...
[16:59:38.101] result() for MulticoreFuture ... done
[16:59:38.101] - relayed: [n=2] TRUE, TRUE
[16:59:38.101] - queued futures: [n=2] TRUE, TRUE
[16:59:38.101] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:38.101]  length: 0 (resolved future 2)
[16:59:38.101] Relaying remaining futures
[16:59:38.102] signalConditionsASAP(NULL, pos=0) ...
[16:59:38.102] - nx: 2
[16:59:38.102] - relay: TRUE
[16:59:38.102] - stdout: TRUE
[16:59:38.102] - signal: TRUE
[16:59:38.102] - resignal: FALSE
[16:59:38.102] - force: TRUE
[16:59:38.102] - relayed: [n=2] TRUE, TRUE
[16:59:38.102] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:38.103] - relayed: [n=2] TRUE, TRUE
[16:59:38.103] - queued futures: [n=2] TRUE, TRUE
[16:59:38.103] signalConditionsASAP(NULL, pos=0) ... done
[16:59:38.103] resolve() on list ... DONE
[16:59:38.103] result() for MulticoreFuture ...
[16:59:38.103] result() for MulticoreFuture ... done
[16:59:38.103] result() for MulticoreFuture ...
[16:59:38.103] result() for MulticoreFuture ... done
[16:59:38.104] result() for MulticoreFuture ...
[16:59:38.104] result() for MulticoreFuture ... done
[16:59:38.104] result() for MulticoreFuture ...
[16:59:38.104] result() for MulticoreFuture ... done
[16:59:38.104]  - Number of value chunks collected: 2
[16:59:38.104] Resolving 2 futures (chunks) ... DONE
[16:59:38.104] Reducing values from 2 chunks ...
[16:59:38.104]  - Number of values collected after concatenation: 3
[16:59:38.105]  - Number of values expected: 3
[16:59:38.105] Reducing values from 2 chunks ... DONE
[16:59:38.105] future_lapply() ... DONE
[16:59:38.106] future_lapply() ...
[16:59:38.110] Number of chunks: 2
[16:59:38.110] getGlobalsAndPackagesXApply() ...
[16:59:38.110]  - future.globals: TRUE
[16:59:38.111] getGlobalsAndPackages() ...
[16:59:38.111] Searching for globals...
[16:59:38.112] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:38.112] Searching for globals ... DONE
[16:59:38.112] Resolving globals: FALSE
[16:59:38.113] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:59:38.113] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:59:38.113] - globals: [1] ‘FUN’
[16:59:38.113] - packages: [1] ‘stats’
[16:59:38.113] getGlobalsAndPackages() ... DONE
[16:59:38.114]  - globals found/used: [n=1] ‘FUN’
[16:59:38.114]  - needed namespaces: [n=1] ‘stats’
[16:59:38.114] Finding globals ... DONE
[16:59:38.114]  - use_args: TRUE
[16:59:38.114]  - Getting '...' globals ...
[16:59:38.114] resolve() on list ...
[16:59:38.115]  recursive: 0
[16:59:38.115]  length: 1
[16:59:38.115]  elements: ‘...’
[16:59:38.115]  length: 0 (resolved future 1)
[16:59:38.115] resolve() on list ... DONE
[16:59:38.115]    - '...' content: [n=1] ‘probs’
[16:59:38.115] List of 1
[16:59:38.115]  $ ...:List of 1
[16:59:38.115]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:59:38.115]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.115]  - attr(*, "where")=List of 1
[16:59:38.115]   ..$ ...:<environment: 0x55c34716caa8> 
[16:59:38.115]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.115]  - attr(*, "resolved")= logi TRUE
[16:59:38.115]  - attr(*, "total_size")= num NA
[16:59:38.119]  - Getting '...' globals ... DONE
[16:59:38.119] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:38.119] List of 2
[16:59:38.119]  $ ...future.FUN:function (x, ...)  
[16:59:38.119]  $ ...          :List of 1
[16:59:38.119]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:59:38.119]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.119]  - attr(*, "where")=List of 2
[16:59:38.119]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:38.119]   ..$ ...          :<environment: 0x55c34716caa8> 
[16:59:38.119]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.119]  - attr(*, "resolved")= logi FALSE
[16:59:38.119]  - attr(*, "total_size")= num 1328
[16:59:38.122] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:38.122] getGlobalsAndPackagesXApply() ... DONE
[16:59:38.122] Number of futures (= number of chunks): 2
[16:59:38.123] Launching 2 futures (chunks) ...
[16:59:38.123] Chunk #1 of 2 ...
[16:59:38.123]  - Finding globals in 'X' for chunk #1 ...
[16:59:38.123] getGlobalsAndPackages() ...
[16:59:38.123] Searching for globals...
[16:59:38.123] 
[16:59:38.123] Searching for globals ... DONE
[16:59:38.123] - globals: [0] <none>
[16:59:38.124] getGlobalsAndPackages() ... DONE
[16:59:38.124]    + additional globals found: [n=0] 
[16:59:38.124]    + additional namespaces needed: [n=0] 
[16:59:38.124]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:38.124]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:38.124]  - seeds: <none>
[16:59:38.124]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.124] getGlobalsAndPackages() ...
[16:59:38.124] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.124] Resolving globals: FALSE
[16:59:38.125] Tweak future expression to call with '...' arguments ...
[16:59:38.125] {
[16:59:38.125]     do.call(function(...) {
[16:59:38.125]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.125]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.125]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.125]             on.exit(options(oopts), add = TRUE)
[16:59:38.125]         }
[16:59:38.125]         {
[16:59:38.125]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.125]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.125]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.125]             })
[16:59:38.125]         }
[16:59:38.125]     }, args = future.call.arguments)
[16:59:38.125] }
[16:59:38.125] Tweak future expression to call with '...' arguments ... DONE
[16:59:38.125] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.125] - packages: [1] ‘stats’
[16:59:38.126] getGlobalsAndPackages() ... DONE
[16:59:38.126] run() for ‘Future’ ...
[16:59:38.126] - state: ‘created’
[16:59:38.126] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:38.131] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.131] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:38.131]   - Field: ‘label’
[16:59:38.131]   - Field: ‘local’
[16:59:38.132]   - Field: ‘owner’
[16:59:38.132]   - Field: ‘envir’
[16:59:38.132]   - Field: ‘workers’
[16:59:38.132]   - Field: ‘packages’
[16:59:38.132]   - Field: ‘gc’
[16:59:38.132]   - Field: ‘job’
[16:59:38.132]   - Field: ‘conditions’
[16:59:38.132]   - Field: ‘expr’
[16:59:38.132]   - Field: ‘uuid’
[16:59:38.132]   - Field: ‘seed’
[16:59:38.132]   - Field: ‘version’
[16:59:38.133]   - Field: ‘result’
[16:59:38.133]   - Field: ‘asynchronous’
[16:59:38.133]   - Field: ‘calls’
[16:59:38.133]   - Field: ‘globals’
[16:59:38.133]   - Field: ‘stdout’
[16:59:38.133]   - Field: ‘earlySignal’
[16:59:38.133]   - Field: ‘lazy’
[16:59:38.133]   - Field: ‘state’
[16:59:38.133] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:38.133] - Launch lazy future ...
[16:59:38.134] Packages needed by the future expression (n = 1): ‘stats’
[16:59:38.134] Packages needed by future strategies (n = 0): <none>
[16:59:38.134] {
[16:59:38.134]     {
[16:59:38.134]         {
[16:59:38.134]             ...future.startTime <- base::Sys.time()
[16:59:38.134]             {
[16:59:38.134]                 {
[16:59:38.134]                   {
[16:59:38.134]                     {
[16:59:38.134]                       {
[16:59:38.134]                         base::local({
[16:59:38.134]                           has_future <- base::requireNamespace("future", 
[16:59:38.134]                             quietly = TRUE)
[16:59:38.134]                           if (has_future) {
[16:59:38.134]                             ns <- base::getNamespace("future")
[16:59:38.134]                             version <- ns[[".package"]][["version"]]
[16:59:38.134]                             if (is.null(version)) 
[16:59:38.134]                               version <- utils::packageVersion("future")
[16:59:38.134]                           }
[16:59:38.134]                           else {
[16:59:38.134]                             version <- NULL
[16:59:38.134]                           }
[16:59:38.134]                           if (!has_future || version < "1.8.0") {
[16:59:38.134]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:38.134]                               "", base::R.version$version.string), 
[16:59:38.134]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:38.134]                                 base::R.version$platform, 8 * 
[16:59:38.134]                                   base::.Machine$sizeof.pointer), 
[16:59:38.134]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:38.134]                                 "release", "version")], collapse = " "), 
[16:59:38.134]                               hostname = base::Sys.info()[["nodename"]])
[16:59:38.134]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:38.134]                               info)
[16:59:38.134]                             info <- base::paste(info, collapse = "; ")
[16:59:38.134]                             if (!has_future) {
[16:59:38.134]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:38.134]                                 info)
[16:59:38.134]                             }
[16:59:38.134]                             else {
[16:59:38.134]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:38.134]                                 info, version)
[16:59:38.134]                             }
[16:59:38.134]                             base::stop(msg)
[16:59:38.134]                           }
[16:59:38.134]                         })
[16:59:38.134]                       }
[16:59:38.134]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:38.134]                       base::options(mc.cores = 1L)
[16:59:38.134]                     }
[16:59:38.134]                     base::local({
[16:59:38.134]                       for (pkg in "stats") {
[16:59:38.134]                         base::loadNamespace(pkg)
[16:59:38.134]                         base::library(pkg, character.only = TRUE)
[16:59:38.134]                       }
[16:59:38.134]                     })
[16:59:38.134]                   }
[16:59:38.134]                   ...future.strategy.old <- future::plan("list")
[16:59:38.134]                   options(future.plan = NULL)
[16:59:38.134]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.134]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:38.134]                 }
[16:59:38.134]                 ...future.workdir <- getwd()
[16:59:38.134]             }
[16:59:38.134]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:38.134]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:38.134]         }
[16:59:38.134]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:38.134]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:38.134]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:38.134]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:38.134]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:38.134]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:38.134]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:38.134]             base::names(...future.oldOptions))
[16:59:38.134]     }
[16:59:38.134]     if (FALSE) {
[16:59:38.134]     }
[16:59:38.134]     else {
[16:59:38.134]         if (TRUE) {
[16:59:38.134]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:38.134]                 open = "w")
[16:59:38.134]         }
[16:59:38.134]         else {
[16:59:38.134]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:38.134]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:38.134]         }
[16:59:38.134]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:38.134]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:38.134]             base::sink(type = "output", split = FALSE)
[16:59:38.134]             base::close(...future.stdout)
[16:59:38.134]         }, add = TRUE)
[16:59:38.134]     }
[16:59:38.134]     ...future.frame <- base::sys.nframe()
[16:59:38.134]     ...future.conditions <- base::list()
[16:59:38.134]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:38.134]     if (FALSE) {
[16:59:38.134]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:38.134]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:38.134]     }
[16:59:38.134]     ...future.result <- base::tryCatch({
[16:59:38.134]         base::withCallingHandlers({
[16:59:38.134]             ...future.value <- base::withVisible(base::local({
[16:59:38.134]                 withCallingHandlers({
[16:59:38.134]                   {
[16:59:38.134]                     do.call(function(...) {
[16:59:38.134]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.134]                       if (!identical(...future.globals.maxSize.org, 
[16:59:38.134]                         ...future.globals.maxSize)) {
[16:59:38.134]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.134]                         on.exit(options(oopts), add = TRUE)
[16:59:38.134]                       }
[16:59:38.134]                       {
[16:59:38.134]                         lapply(seq_along(...future.elements_ii), 
[16:59:38.134]                           FUN = function(jj) {
[16:59:38.134]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.134]                             ...future.FUN(...future.X_jj, ...)
[16:59:38.134]                           })
[16:59:38.134]                       }
[16:59:38.134]                     }, args = future.call.arguments)
[16:59:38.134]                   }
[16:59:38.134]                 }, immediateCondition = function(cond) {
[16:59:38.134]                   save_rds <- function (object, pathname, ...) 
[16:59:38.134]                   {
[16:59:38.134]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:38.134]                     if (file_test("-f", pathname_tmp)) {
[16:59:38.134]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.134]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:38.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.134]                         fi_tmp[["mtime"]])
[16:59:38.134]                     }
[16:59:38.134]                     tryCatch({
[16:59:38.134]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:38.134]                     }, error = function(ex) {
[16:59:38.134]                       msg <- conditionMessage(ex)
[16:59:38.134]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.134]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:38.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.134]                         fi_tmp[["mtime"]], msg)
[16:59:38.134]                       ex$message <- msg
[16:59:38.134]                       stop(ex)
[16:59:38.134]                     })
[16:59:38.134]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:38.134]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:38.134]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:38.134]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.134]                       fi <- file.info(pathname)
[16:59:38.134]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:38.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.134]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:38.134]                         fi[["size"]], fi[["mtime"]])
[16:59:38.134]                       stop(msg)
[16:59:38.134]                     }
[16:59:38.134]                     invisible(pathname)
[16:59:38.134]                   }
[16:59:38.134]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:38.134]                     rootPath = tempdir()) 
[16:59:38.134]                   {
[16:59:38.134]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:38.134]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:38.134]                       tmpdir = path, fileext = ".rds")
[16:59:38.134]                     save_rds(obj, file)
[16:59:38.134]                   }
[16:59:38.134]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0io6nB/.future/immediateConditions")
[16:59:38.134]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.134]                   {
[16:59:38.134]                     inherits <- base::inherits
[16:59:38.134]                     invokeRestart <- base::invokeRestart
[16:59:38.134]                     is.null <- base::is.null
[16:59:38.134]                     muffled <- FALSE
[16:59:38.134]                     if (inherits(cond, "message")) {
[16:59:38.134]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:38.134]                       if (muffled) 
[16:59:38.134]                         invokeRestart("muffleMessage")
[16:59:38.134]                     }
[16:59:38.134]                     else if (inherits(cond, "warning")) {
[16:59:38.134]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:38.134]                       if (muffled) 
[16:59:38.134]                         invokeRestart("muffleWarning")
[16:59:38.134]                     }
[16:59:38.134]                     else if (inherits(cond, "condition")) {
[16:59:38.134]                       if (!is.null(pattern)) {
[16:59:38.134]                         computeRestarts <- base::computeRestarts
[16:59:38.134]                         grepl <- base::grepl
[16:59:38.134]                         restarts <- computeRestarts(cond)
[16:59:38.134]                         for (restart in restarts) {
[16:59:38.134]                           name <- restart$name
[16:59:38.134]                           if (is.null(name)) 
[16:59:38.134]                             next
[16:59:38.134]                           if (!grepl(pattern, name)) 
[16:59:38.134]                             next
[16:59:38.134]                           invokeRestart(restart)
[16:59:38.134]                           muffled <- TRUE
[16:59:38.134]                           break
[16:59:38.134]                         }
[16:59:38.134]                       }
[16:59:38.134]                     }
[16:59:38.134]                     invisible(muffled)
[16:59:38.134]                   }
[16:59:38.134]                   muffleCondition(cond)
[16:59:38.134]                 })
[16:59:38.134]             }))
[16:59:38.134]             future::FutureResult(value = ...future.value$value, 
[16:59:38.134]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.134]                   ...future.rng), globalenv = if (FALSE) 
[16:59:38.134]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:38.134]                     ...future.globalenv.names))
[16:59:38.134]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:38.134]         }, condition = base::local({
[16:59:38.134]             c <- base::c
[16:59:38.134]             inherits <- base::inherits
[16:59:38.134]             invokeRestart <- base::invokeRestart
[16:59:38.134]             length <- base::length
[16:59:38.134]             list <- base::list
[16:59:38.134]             seq.int <- base::seq.int
[16:59:38.134]             signalCondition <- base::signalCondition
[16:59:38.134]             sys.calls <- base::sys.calls
[16:59:38.134]             `[[` <- base::`[[`
[16:59:38.134]             `+` <- base::`+`
[16:59:38.134]             `<<-` <- base::`<<-`
[16:59:38.134]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:38.134]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:38.134]                   3L)]
[16:59:38.134]             }
[16:59:38.134]             function(cond) {
[16:59:38.134]                 is_error <- inherits(cond, "error")
[16:59:38.134]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:38.134]                   NULL)
[16:59:38.134]                 if (is_error) {
[16:59:38.134]                   sessionInformation <- function() {
[16:59:38.134]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:38.134]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:38.134]                       search = base::search(), system = base::Sys.info())
[16:59:38.134]                   }
[16:59:38.134]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.134]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:38.134]                     cond$call), session = sessionInformation(), 
[16:59:38.134]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:38.134]                   signalCondition(cond)
[16:59:38.134]                 }
[16:59:38.134]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:38.134]                 "immediateCondition"))) {
[16:59:38.134]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:38.134]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.134]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:38.134]                   if (TRUE && !signal) {
[16:59:38.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.134]                     {
[16:59:38.134]                       inherits <- base::inherits
[16:59:38.134]                       invokeRestart <- base::invokeRestart
[16:59:38.134]                       is.null <- base::is.null
[16:59:38.134]                       muffled <- FALSE
[16:59:38.134]                       if (inherits(cond, "message")) {
[16:59:38.134]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.134]                         if (muffled) 
[16:59:38.134]                           invokeRestart("muffleMessage")
[16:59:38.134]                       }
[16:59:38.134]                       else if (inherits(cond, "warning")) {
[16:59:38.134]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.134]                         if (muffled) 
[16:59:38.134]                           invokeRestart("muffleWarning")
[16:59:38.134]                       }
[16:59:38.134]                       else if (inherits(cond, "condition")) {
[16:59:38.134]                         if (!is.null(pattern)) {
[16:59:38.134]                           computeRestarts <- base::computeRestarts
[16:59:38.134]                           grepl <- base::grepl
[16:59:38.134]                           restarts <- computeRestarts(cond)
[16:59:38.134]                           for (restart in restarts) {
[16:59:38.134]                             name <- restart$name
[16:59:38.134]                             if (is.null(name)) 
[16:59:38.134]                               next
[16:59:38.134]                             if (!grepl(pattern, name)) 
[16:59:38.134]                               next
[16:59:38.134]                             invokeRestart(restart)
[16:59:38.134]                             muffled <- TRUE
[16:59:38.134]                             break
[16:59:38.134]                           }
[16:59:38.134]                         }
[16:59:38.134]                       }
[16:59:38.134]                       invisible(muffled)
[16:59:38.134]                     }
[16:59:38.134]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.134]                   }
[16:59:38.134]                 }
[16:59:38.134]                 else {
[16:59:38.134]                   if (TRUE) {
[16:59:38.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.134]                     {
[16:59:38.134]                       inherits <- base::inherits
[16:59:38.134]                       invokeRestart <- base::invokeRestart
[16:59:38.134]                       is.null <- base::is.null
[16:59:38.134]                       muffled <- FALSE
[16:59:38.134]                       if (inherits(cond, "message")) {
[16:59:38.134]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.134]                         if (muffled) 
[16:59:38.134]                           invokeRestart("muffleMessage")
[16:59:38.134]                       }
[16:59:38.134]                       else if (inherits(cond, "warning")) {
[16:59:38.134]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.134]                         if (muffled) 
[16:59:38.134]                           invokeRestart("muffleWarning")
[16:59:38.134]                       }
[16:59:38.134]                       else if (inherits(cond, "condition")) {
[16:59:38.134]                         if (!is.null(pattern)) {
[16:59:38.134]                           computeRestarts <- base::computeRestarts
[16:59:38.134]                           grepl <- base::grepl
[16:59:38.134]                           restarts <- computeRestarts(cond)
[16:59:38.134]                           for (restart in restarts) {
[16:59:38.134]                             name <- restart$name
[16:59:38.134]                             if (is.null(name)) 
[16:59:38.134]                               next
[16:59:38.134]                             if (!grepl(pattern, name)) 
[16:59:38.134]                               next
[16:59:38.134]                             invokeRestart(restart)
[16:59:38.134]                             muffled <- TRUE
[16:59:38.134]                             break
[16:59:38.134]                           }
[16:59:38.134]                         }
[16:59:38.134]                       }
[16:59:38.134]                       invisible(muffled)
[16:59:38.134]                     }
[16:59:38.134]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.134]                   }
[16:59:38.134]                 }
[16:59:38.134]             }
[16:59:38.134]         }))
[16:59:38.134]     }, error = function(ex) {
[16:59:38.134]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:38.134]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.134]                 ...future.rng), started = ...future.startTime, 
[16:59:38.134]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:38.134]             version = "1.8"), class = "FutureResult")
[16:59:38.134]     }, finally = {
[16:59:38.134]         if (!identical(...future.workdir, getwd())) 
[16:59:38.134]             setwd(...future.workdir)
[16:59:38.134]         {
[16:59:38.134]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:38.134]                 ...future.oldOptions$nwarnings <- NULL
[16:59:38.134]             }
[16:59:38.134]             base::options(...future.oldOptions)
[16:59:38.134]             if (.Platform$OS.type == "windows") {
[16:59:38.134]                 old_names <- names(...future.oldEnvVars)
[16:59:38.134]                 envs <- base::Sys.getenv()
[16:59:38.134]                 names <- names(envs)
[16:59:38.134]                 common <- intersect(names, old_names)
[16:59:38.134]                 added <- setdiff(names, old_names)
[16:59:38.134]                 removed <- setdiff(old_names, names)
[16:59:38.134]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:38.134]                   envs[common]]
[16:59:38.134]                 NAMES <- toupper(changed)
[16:59:38.134]                 args <- list()
[16:59:38.134]                 for (kk in seq_along(NAMES)) {
[16:59:38.134]                   name <- changed[[kk]]
[16:59:38.134]                   NAME <- NAMES[[kk]]
[16:59:38.134]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.134]                     next
[16:59:38.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.134]                 }
[16:59:38.134]                 NAMES <- toupper(added)
[16:59:38.134]                 for (kk in seq_along(NAMES)) {
[16:59:38.134]                   name <- added[[kk]]
[16:59:38.134]                   NAME <- NAMES[[kk]]
[16:59:38.134]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.134]                     next
[16:59:38.134]                   args[[name]] <- ""
[16:59:38.134]                 }
[16:59:38.134]                 NAMES <- toupper(removed)
[16:59:38.134]                 for (kk in seq_along(NAMES)) {
[16:59:38.134]                   name <- removed[[kk]]
[16:59:38.134]                   NAME <- NAMES[[kk]]
[16:59:38.134]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.134]                     next
[16:59:38.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.134]                 }
[16:59:38.134]                 if (length(args) > 0) 
[16:59:38.134]                   base::do.call(base::Sys.setenv, args = args)
[16:59:38.134]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:38.134]             }
[16:59:38.134]             else {
[16:59:38.134]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:38.134]             }
[16:59:38.134]             {
[16:59:38.134]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:38.134]                   0L) {
[16:59:38.134]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:38.134]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:38.134]                   base::options(opts)
[16:59:38.134]                 }
[16:59:38.134]                 {
[16:59:38.134]                   {
[16:59:38.134]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:38.134]                     NULL
[16:59:38.134]                   }
[16:59:38.134]                   options(future.plan = NULL)
[16:59:38.134]                   if (is.na(NA_character_)) 
[16:59:38.134]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.134]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:38.134]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:38.134]                     .init = FALSE)
[16:59:38.134]                 }
[16:59:38.134]             }
[16:59:38.134]         }
[16:59:38.134]     })
[16:59:38.134]     if (TRUE) {
[16:59:38.134]         base::sink(type = "output", split = FALSE)
[16:59:38.134]         if (TRUE) {
[16:59:38.134]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:38.134]         }
[16:59:38.134]         else {
[16:59:38.134]             ...future.result["stdout"] <- base::list(NULL)
[16:59:38.134]         }
[16:59:38.134]         base::close(...future.stdout)
[16:59:38.134]         ...future.stdout <- NULL
[16:59:38.134]     }
[16:59:38.134]     ...future.result$conditions <- ...future.conditions
[16:59:38.134]     ...future.result$finished <- base::Sys.time()
[16:59:38.134]     ...future.result
[16:59:38.134] }
[16:59:38.137] assign_globals() ...
[16:59:38.137] List of 5
[16:59:38.137]  $ ...future.FUN            :function (x, ...)  
[16:59:38.137]  $ future.call.arguments    :List of 1
[16:59:38.137]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:59:38.137]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.137]  $ ...future.elements_ii    :List of 1
[16:59:38.137]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:59:38.137]  $ ...future.seeds_ii       : NULL
[16:59:38.137]  $ ...future.globals.maxSize: NULL
[16:59:38.137]  - attr(*, "where")=List of 5
[16:59:38.137]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:38.137]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:38.137]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:38.137]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:38.137]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:38.137]  - attr(*, "resolved")= logi FALSE
[16:59:38.137]  - attr(*, "total_size")= num 1328
[16:59:38.137]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.137]  - attr(*, "already-done")= logi TRUE
[16:59:38.142] - copied ‘...future.FUN’ to environment
[16:59:38.142] - copied ‘future.call.arguments’ to environment
[16:59:38.142] - copied ‘...future.elements_ii’ to environment
[16:59:38.142] - copied ‘...future.seeds_ii’ to environment
[16:59:38.142] - copied ‘...future.globals.maxSize’ to environment
[16:59:38.142] assign_globals() ... done
[16:59:38.142] requestCore(): workers = 2
[16:59:38.144] MulticoreFuture started
[16:59:38.145] - Launch lazy future ... done
[16:59:38.145] run() for ‘MulticoreFuture’ ... done
[16:59:38.145] Created future:
[16:59:38.146] plan(): Setting new future strategy stack:
[16:59:38.146] List of future strategies:
[16:59:38.146] 1. sequential:
[16:59:38.146]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:38.146]    - tweaked: FALSE
[16:59:38.146]    - call: NULL
[16:59:38.147] plan(): nbrOfWorkers() = 1
[16:59:38.149] plan(): Setting new future strategy stack:
[16:59:38.149] List of future strategies:
[16:59:38.149] 1. multicore:
[16:59:38.149]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:38.149]    - tweaked: FALSE
[16:59:38.149]    - call: plan(strategy)
[16:59:38.154] plan(): nbrOfWorkers() = 2
[16:59:38.145] MulticoreFuture:
[16:59:38.145] Label: ‘future_eapply-1’
[16:59:38.145] Expression:
[16:59:38.145] {
[16:59:38.145]     do.call(function(...) {
[16:59:38.145]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.145]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.145]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.145]             on.exit(options(oopts), add = TRUE)
[16:59:38.145]         }
[16:59:38.145]         {
[16:59:38.145]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.145]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.145]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.145]             })
[16:59:38.145]         }
[16:59:38.145]     }, args = future.call.arguments)
[16:59:38.145] }
[16:59:38.145] Lazy evaluation: FALSE
[16:59:38.145] Asynchronous evaluation: TRUE
[16:59:38.145] Local evaluation: TRUE
[16:59:38.145] Environment: R_GlobalEnv
[16:59:38.145] Capture standard output: TRUE
[16:59:38.145] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:38.145] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:38.145] Packages: 1 packages (‘stats’)
[16:59:38.145] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:38.145] Resolved: TRUE
[16:59:38.145] Value: <not collected>
[16:59:38.145] Conditions captured: <none>
[16:59:38.145] Early signaling: FALSE
[16:59:38.145] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:38.145] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.155] Chunk #1 of 2 ... DONE
[16:59:38.156] Chunk #2 of 2 ...
[16:59:38.156]  - Finding globals in 'X' for chunk #2 ...
[16:59:38.156] getGlobalsAndPackages() ...
[16:59:38.156] Searching for globals...
[16:59:38.157] 
[16:59:38.157] Searching for globals ... DONE
[16:59:38.157] - globals: [0] <none>
[16:59:38.157] getGlobalsAndPackages() ... DONE
[16:59:38.157]    + additional globals found: [n=0] 
[16:59:38.157]    + additional namespaces needed: [n=0] 
[16:59:38.157]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:38.157]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:38.158]  - seeds: <none>
[16:59:38.158]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.158] getGlobalsAndPackages() ...
[16:59:38.158] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.158] Resolving globals: FALSE
[16:59:38.158] Tweak future expression to call with '...' arguments ...
[16:59:38.159] {
[16:59:38.159]     do.call(function(...) {
[16:59:38.159]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.159]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.159]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.159]             on.exit(options(oopts), add = TRUE)
[16:59:38.159]         }
[16:59:38.159]         {
[16:59:38.159]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.159]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.159]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.159]             })
[16:59:38.159]         }
[16:59:38.159]     }, args = future.call.arguments)
[16:59:38.159] }
[16:59:38.159] Tweak future expression to call with '...' arguments ... DONE
[16:59:38.160] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.160] - packages: [1] ‘stats’
[16:59:38.160] getGlobalsAndPackages() ... DONE
[16:59:38.161] run() for ‘Future’ ...
[16:59:38.161] - state: ‘created’
[16:59:38.161] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:38.165] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:38.166]   - Field: ‘label’
[16:59:38.166]   - Field: ‘local’
[16:59:38.166]   - Field: ‘owner’
[16:59:38.166]   - Field: ‘envir’
[16:59:38.166]   - Field: ‘workers’
[16:59:38.166]   - Field: ‘packages’
[16:59:38.167]   - Field: ‘gc’
[16:59:38.167]   - Field: ‘job’
[16:59:38.167]   - Field: ‘conditions’
[16:59:38.167]   - Field: ‘expr’
[16:59:38.167]   - Field: ‘uuid’
[16:59:38.167]   - Field: ‘seed’
[16:59:38.167]   - Field: ‘version’
[16:59:38.168]   - Field: ‘result’
[16:59:38.168]   - Field: ‘asynchronous’
[16:59:38.168]   - Field: ‘calls’
[16:59:38.168]   - Field: ‘globals’
[16:59:38.168]   - Field: ‘stdout’
[16:59:38.168]   - Field: ‘earlySignal’
[16:59:38.168]   - Field: ‘lazy’
[16:59:38.169]   - Field: ‘state’
[16:59:38.169] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:38.169] - Launch lazy future ...
[16:59:38.169] Packages needed by the future expression (n = 1): ‘stats’
[16:59:38.169] Packages needed by future strategies (n = 0): <none>
[16:59:38.170] {
[16:59:38.170]     {
[16:59:38.170]         {
[16:59:38.170]             ...future.startTime <- base::Sys.time()
[16:59:38.170]             {
[16:59:38.170]                 {
[16:59:38.170]                   {
[16:59:38.170]                     {
[16:59:38.170]                       {
[16:59:38.170]                         base::local({
[16:59:38.170]                           has_future <- base::requireNamespace("future", 
[16:59:38.170]                             quietly = TRUE)
[16:59:38.170]                           if (has_future) {
[16:59:38.170]                             ns <- base::getNamespace("future")
[16:59:38.170]                             version <- ns[[".package"]][["version"]]
[16:59:38.170]                             if (is.null(version)) 
[16:59:38.170]                               version <- utils::packageVersion("future")
[16:59:38.170]                           }
[16:59:38.170]                           else {
[16:59:38.170]                             version <- NULL
[16:59:38.170]                           }
[16:59:38.170]                           if (!has_future || version < "1.8.0") {
[16:59:38.170]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:38.170]                               "", base::R.version$version.string), 
[16:59:38.170]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:38.170]                                 base::R.version$platform, 8 * 
[16:59:38.170]                                   base::.Machine$sizeof.pointer), 
[16:59:38.170]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:38.170]                                 "release", "version")], collapse = " "), 
[16:59:38.170]                               hostname = base::Sys.info()[["nodename"]])
[16:59:38.170]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:38.170]                               info)
[16:59:38.170]                             info <- base::paste(info, collapse = "; ")
[16:59:38.170]                             if (!has_future) {
[16:59:38.170]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:38.170]                                 info)
[16:59:38.170]                             }
[16:59:38.170]                             else {
[16:59:38.170]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:38.170]                                 info, version)
[16:59:38.170]                             }
[16:59:38.170]                             base::stop(msg)
[16:59:38.170]                           }
[16:59:38.170]                         })
[16:59:38.170]                       }
[16:59:38.170]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:38.170]                       base::options(mc.cores = 1L)
[16:59:38.170]                     }
[16:59:38.170]                     base::local({
[16:59:38.170]                       for (pkg in "stats") {
[16:59:38.170]                         base::loadNamespace(pkg)
[16:59:38.170]                         base::library(pkg, character.only = TRUE)
[16:59:38.170]                       }
[16:59:38.170]                     })
[16:59:38.170]                   }
[16:59:38.170]                   ...future.strategy.old <- future::plan("list")
[16:59:38.170]                   options(future.plan = NULL)
[16:59:38.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:38.170]                 }
[16:59:38.170]                 ...future.workdir <- getwd()
[16:59:38.170]             }
[16:59:38.170]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:38.170]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:38.170]         }
[16:59:38.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:38.170]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:38.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:38.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:38.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:38.170]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:38.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:38.170]             base::names(...future.oldOptions))
[16:59:38.170]     }
[16:59:38.170]     if (FALSE) {
[16:59:38.170]     }
[16:59:38.170]     else {
[16:59:38.170]         if (TRUE) {
[16:59:38.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:38.170]                 open = "w")
[16:59:38.170]         }
[16:59:38.170]         else {
[16:59:38.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:38.170]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:38.170]         }
[16:59:38.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:38.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:38.170]             base::sink(type = "output", split = FALSE)
[16:59:38.170]             base::close(...future.stdout)
[16:59:38.170]         }, add = TRUE)
[16:59:38.170]     }
[16:59:38.170]     ...future.frame <- base::sys.nframe()
[16:59:38.170]     ...future.conditions <- base::list()
[16:59:38.170]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:38.170]     if (FALSE) {
[16:59:38.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:38.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:38.170]     }
[16:59:38.170]     ...future.result <- base::tryCatch({
[16:59:38.170]         base::withCallingHandlers({
[16:59:38.170]             ...future.value <- base::withVisible(base::local({
[16:59:38.170]                 withCallingHandlers({
[16:59:38.170]                   {
[16:59:38.170]                     do.call(function(...) {
[16:59:38.170]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.170]                       if (!identical(...future.globals.maxSize.org, 
[16:59:38.170]                         ...future.globals.maxSize)) {
[16:59:38.170]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.170]                         on.exit(options(oopts), add = TRUE)
[16:59:38.170]                       }
[16:59:38.170]                       {
[16:59:38.170]                         lapply(seq_along(...future.elements_ii), 
[16:59:38.170]                           FUN = function(jj) {
[16:59:38.170]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.170]                             ...future.FUN(...future.X_jj, ...)
[16:59:38.170]                           })
[16:59:38.170]                       }
[16:59:38.170]                     }, args = future.call.arguments)
[16:59:38.170]                   }
[16:59:38.170]                 }, immediateCondition = function(cond) {
[16:59:38.170]                   save_rds <- function (object, pathname, ...) 
[16:59:38.170]                   {
[16:59:38.170]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:38.170]                     if (file_test("-f", pathname_tmp)) {
[16:59:38.170]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.170]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:38.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.170]                         fi_tmp[["mtime"]])
[16:59:38.170]                     }
[16:59:38.170]                     tryCatch({
[16:59:38.170]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:38.170]                     }, error = function(ex) {
[16:59:38.170]                       msg <- conditionMessage(ex)
[16:59:38.170]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.170]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:38.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.170]                         fi_tmp[["mtime"]], msg)
[16:59:38.170]                       ex$message <- msg
[16:59:38.170]                       stop(ex)
[16:59:38.170]                     })
[16:59:38.170]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:38.170]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:38.170]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:38.170]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.170]                       fi <- file.info(pathname)
[16:59:38.170]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:38.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.170]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:38.170]                         fi[["size"]], fi[["mtime"]])
[16:59:38.170]                       stop(msg)
[16:59:38.170]                     }
[16:59:38.170]                     invisible(pathname)
[16:59:38.170]                   }
[16:59:38.170]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:38.170]                     rootPath = tempdir()) 
[16:59:38.170]                   {
[16:59:38.170]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:38.170]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:38.170]                       tmpdir = path, fileext = ".rds")
[16:59:38.170]                     save_rds(obj, file)
[16:59:38.170]                   }
[16:59:38.170]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0io6nB/.future/immediateConditions")
[16:59:38.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.170]                   {
[16:59:38.170]                     inherits <- base::inherits
[16:59:38.170]                     invokeRestart <- base::invokeRestart
[16:59:38.170]                     is.null <- base::is.null
[16:59:38.170]                     muffled <- FALSE
[16:59:38.170]                     if (inherits(cond, "message")) {
[16:59:38.170]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:38.170]                       if (muffled) 
[16:59:38.170]                         invokeRestart("muffleMessage")
[16:59:38.170]                     }
[16:59:38.170]                     else if (inherits(cond, "warning")) {
[16:59:38.170]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:38.170]                       if (muffled) 
[16:59:38.170]                         invokeRestart("muffleWarning")
[16:59:38.170]                     }
[16:59:38.170]                     else if (inherits(cond, "condition")) {
[16:59:38.170]                       if (!is.null(pattern)) {
[16:59:38.170]                         computeRestarts <- base::computeRestarts
[16:59:38.170]                         grepl <- base::grepl
[16:59:38.170]                         restarts <- computeRestarts(cond)
[16:59:38.170]                         for (restart in restarts) {
[16:59:38.170]                           name <- restart$name
[16:59:38.170]                           if (is.null(name)) 
[16:59:38.170]                             next
[16:59:38.170]                           if (!grepl(pattern, name)) 
[16:59:38.170]                             next
[16:59:38.170]                           invokeRestart(restart)
[16:59:38.170]                           muffled <- TRUE
[16:59:38.170]                           break
[16:59:38.170]                         }
[16:59:38.170]                       }
[16:59:38.170]                     }
[16:59:38.170]                     invisible(muffled)
[16:59:38.170]                   }
[16:59:38.170]                   muffleCondition(cond)
[16:59:38.170]                 })
[16:59:38.170]             }))
[16:59:38.170]             future::FutureResult(value = ...future.value$value, 
[16:59:38.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.170]                   ...future.rng), globalenv = if (FALSE) 
[16:59:38.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:38.170]                     ...future.globalenv.names))
[16:59:38.170]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:38.170]         }, condition = base::local({
[16:59:38.170]             c <- base::c
[16:59:38.170]             inherits <- base::inherits
[16:59:38.170]             invokeRestart <- base::invokeRestart
[16:59:38.170]             length <- base::length
[16:59:38.170]             list <- base::list
[16:59:38.170]             seq.int <- base::seq.int
[16:59:38.170]             signalCondition <- base::signalCondition
[16:59:38.170]             sys.calls <- base::sys.calls
[16:59:38.170]             `[[` <- base::`[[`
[16:59:38.170]             `+` <- base::`+`
[16:59:38.170]             `<<-` <- base::`<<-`
[16:59:38.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:38.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:38.170]                   3L)]
[16:59:38.170]             }
[16:59:38.170]             function(cond) {
[16:59:38.170]                 is_error <- inherits(cond, "error")
[16:59:38.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:38.170]                   NULL)
[16:59:38.170]                 if (is_error) {
[16:59:38.170]                   sessionInformation <- function() {
[16:59:38.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:38.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:38.170]                       search = base::search(), system = base::Sys.info())
[16:59:38.170]                   }
[16:59:38.170]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:38.170]                     cond$call), session = sessionInformation(), 
[16:59:38.170]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:38.170]                   signalCondition(cond)
[16:59:38.170]                 }
[16:59:38.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:38.170]                 "immediateCondition"))) {
[16:59:38.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:38.170]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:38.170]                   if (TRUE && !signal) {
[16:59:38.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.170]                     {
[16:59:38.170]                       inherits <- base::inherits
[16:59:38.170]                       invokeRestart <- base::invokeRestart
[16:59:38.170]                       is.null <- base::is.null
[16:59:38.170]                       muffled <- FALSE
[16:59:38.170]                       if (inherits(cond, "message")) {
[16:59:38.170]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.170]                         if (muffled) 
[16:59:38.170]                           invokeRestart("muffleMessage")
[16:59:38.170]                       }
[16:59:38.170]                       else if (inherits(cond, "warning")) {
[16:59:38.170]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.170]                         if (muffled) 
[16:59:38.170]                           invokeRestart("muffleWarning")
[16:59:38.170]                       }
[16:59:38.170]                       else if (inherits(cond, "condition")) {
[16:59:38.170]                         if (!is.null(pattern)) {
[16:59:38.170]                           computeRestarts <- base::computeRestarts
[16:59:38.170]                           grepl <- base::grepl
[16:59:38.170]                           restarts <- computeRestarts(cond)
[16:59:38.170]                           for (restart in restarts) {
[16:59:38.170]                             name <- restart$name
[16:59:38.170]                             if (is.null(name)) 
[16:59:38.170]                               next
[16:59:38.170]                             if (!grepl(pattern, name)) 
[16:59:38.170]                               next
[16:59:38.170]                             invokeRestart(restart)
[16:59:38.170]                             muffled <- TRUE
[16:59:38.170]                             break
[16:59:38.170]                           }
[16:59:38.170]                         }
[16:59:38.170]                       }
[16:59:38.170]                       invisible(muffled)
[16:59:38.170]                     }
[16:59:38.170]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.170]                   }
[16:59:38.170]                 }
[16:59:38.170]                 else {
[16:59:38.170]                   if (TRUE) {
[16:59:38.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.170]                     {
[16:59:38.170]                       inherits <- base::inherits
[16:59:38.170]                       invokeRestart <- base::invokeRestart
[16:59:38.170]                       is.null <- base::is.null
[16:59:38.170]                       muffled <- FALSE
[16:59:38.170]                       if (inherits(cond, "message")) {
[16:59:38.170]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.170]                         if (muffled) 
[16:59:38.170]                           invokeRestart("muffleMessage")
[16:59:38.170]                       }
[16:59:38.170]                       else if (inherits(cond, "warning")) {
[16:59:38.170]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.170]                         if (muffled) 
[16:59:38.170]                           invokeRestart("muffleWarning")
[16:59:38.170]                       }
[16:59:38.170]                       else if (inherits(cond, "condition")) {
[16:59:38.170]                         if (!is.null(pattern)) {
[16:59:38.170]                           computeRestarts <- base::computeRestarts
[16:59:38.170]                           grepl <- base::grepl
[16:59:38.170]                           restarts <- computeRestarts(cond)
[16:59:38.170]                           for (restart in restarts) {
[16:59:38.170]                             name <- restart$name
[16:59:38.170]                             if (is.null(name)) 
[16:59:38.170]                               next
[16:59:38.170]                             if (!grepl(pattern, name)) 
[16:59:38.170]                               next
[16:59:38.170]                             invokeRestart(restart)
[16:59:38.170]                             muffled <- TRUE
[16:59:38.170]                             break
[16:59:38.170]                           }
[16:59:38.170]                         }
[16:59:38.170]                       }
[16:59:38.170]                       invisible(muffled)
[16:59:38.170]                     }
[16:59:38.170]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.170]                   }
[16:59:38.170]                 }
[16:59:38.170]             }
[16:59:38.170]         }))
[16:59:38.170]     }, error = function(ex) {
[16:59:38.170]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:38.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.170]                 ...future.rng), started = ...future.startTime, 
[16:59:38.170]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:38.170]             version = "1.8"), class = "FutureResult")
[16:59:38.170]     }, finally = {
[16:59:38.170]         if (!identical(...future.workdir, getwd())) 
[16:59:38.170]             setwd(...future.workdir)
[16:59:38.170]         {
[16:59:38.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:38.170]                 ...future.oldOptions$nwarnings <- NULL
[16:59:38.170]             }
[16:59:38.170]             base::options(...future.oldOptions)
[16:59:38.170]             if (.Platform$OS.type == "windows") {
[16:59:38.170]                 old_names <- names(...future.oldEnvVars)
[16:59:38.170]                 envs <- base::Sys.getenv()
[16:59:38.170]                 names <- names(envs)
[16:59:38.170]                 common <- intersect(names, old_names)
[16:59:38.170]                 added <- setdiff(names, old_names)
[16:59:38.170]                 removed <- setdiff(old_names, names)
[16:59:38.170]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:38.170]                   envs[common]]
[16:59:38.170]                 NAMES <- toupper(changed)
[16:59:38.170]                 args <- list()
[16:59:38.170]                 for (kk in seq_along(NAMES)) {
[16:59:38.170]                   name <- changed[[kk]]
[16:59:38.170]                   NAME <- NAMES[[kk]]
[16:59:38.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.170]                     next
[16:59:38.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.170]                 }
[16:59:38.170]                 NAMES <- toupper(added)
[16:59:38.170]                 for (kk in seq_along(NAMES)) {
[16:59:38.170]                   name <- added[[kk]]
[16:59:38.170]                   NAME <- NAMES[[kk]]
[16:59:38.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.170]                     next
[16:59:38.170]                   args[[name]] <- ""
[16:59:38.170]                 }
[16:59:38.170]                 NAMES <- toupper(removed)
[16:59:38.170]                 for (kk in seq_along(NAMES)) {
[16:59:38.170]                   name <- removed[[kk]]
[16:59:38.170]                   NAME <- NAMES[[kk]]
[16:59:38.170]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.170]                     next
[16:59:38.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.170]                 }
[16:59:38.170]                 if (length(args) > 0) 
[16:59:38.170]                   base::do.call(base::Sys.setenv, args = args)
[16:59:38.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:38.170]             }
[16:59:38.170]             else {
[16:59:38.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:38.170]             }
[16:59:38.170]             {
[16:59:38.170]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:38.170]                   0L) {
[16:59:38.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:38.170]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:38.170]                   base::options(opts)
[16:59:38.170]                 }
[16:59:38.170]                 {
[16:59:38.170]                   {
[16:59:38.170]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:38.170]                     NULL
[16:59:38.170]                   }
[16:59:38.170]                   options(future.plan = NULL)
[16:59:38.170]                   if (is.na(NA_character_)) 
[16:59:38.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:38.170]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:38.170]                     .init = FALSE)
[16:59:38.170]                 }
[16:59:38.170]             }
[16:59:38.170]         }
[16:59:38.170]     })
[16:59:38.170]     if (TRUE) {
[16:59:38.170]         base::sink(type = "output", split = FALSE)
[16:59:38.170]         if (TRUE) {
[16:59:38.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:38.170]         }
[16:59:38.170]         else {
[16:59:38.170]             ...future.result["stdout"] <- base::list(NULL)
[16:59:38.170]         }
[16:59:38.170]         base::close(...future.stdout)
[16:59:38.170]         ...future.stdout <- NULL
[16:59:38.170]     }
[16:59:38.170]     ...future.result$conditions <- ...future.conditions
[16:59:38.170]     ...future.result$finished <- base::Sys.time()
[16:59:38.170]     ...future.result
[16:59:38.170] }
[16:59:38.173] assign_globals() ...
[16:59:38.173] List of 5
[16:59:38.173]  $ ...future.FUN            :function (x, ...)  
[16:59:38.173]  $ future.call.arguments    :List of 1
[16:59:38.173]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:59:38.173]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.173]  $ ...future.elements_ii    :List of 2
[16:59:38.173]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:59:38.173]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:59:38.173]  $ ...future.seeds_ii       : NULL
[16:59:38.173]  $ ...future.globals.maxSize: NULL
[16:59:38.173]  - attr(*, "where")=List of 5
[16:59:38.173]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:38.173]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:38.173]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:38.173]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:38.173]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:38.173]  - attr(*, "resolved")= logi FALSE
[16:59:38.173]  - attr(*, "total_size")= num 1328
[16:59:38.173]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.173]  - attr(*, "already-done")= logi TRUE
[16:59:38.185] - copied ‘...future.FUN’ to environment
[16:59:38.185] - copied ‘future.call.arguments’ to environment
[16:59:38.186] - copied ‘...future.elements_ii’ to environment
[16:59:38.186] - copied ‘...future.seeds_ii’ to environment
[16:59:38.186] - copied ‘...future.globals.maxSize’ to environment
[16:59:38.186] assign_globals() ... done
[16:59:38.186] requestCore(): workers = 2
[16:59:38.189] MulticoreFuture started
[16:59:38.189] - Launch lazy future ... done
[16:59:38.189] run() for ‘MulticoreFuture’ ... done
[16:59:38.190] Created future:
[16:59:38.190] plan(): Setting new future strategy stack:
[16:59:38.190] List of future strategies:
[16:59:38.190] 1. sequential:
[16:59:38.190]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:38.190]    - tweaked: FALSE
[16:59:38.190]    - call: NULL
[16:59:38.191] plan(): nbrOfWorkers() = 1
[16:59:38.194] plan(): Setting new future strategy stack:
[16:59:38.194] List of future strategies:
[16:59:38.194] 1. multicore:
[16:59:38.194]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:38.194]    - tweaked: FALSE
[16:59:38.194]    - call: plan(strategy)
[16:59:38.199] plan(): nbrOfWorkers() = 2
[16:59:38.190] MulticoreFuture:
[16:59:38.190] Label: ‘future_eapply-2’
[16:59:38.190] Expression:
[16:59:38.190] {
[16:59:38.190]     do.call(function(...) {
[16:59:38.190]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.190]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.190]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.190]             on.exit(options(oopts), add = TRUE)
[16:59:38.190]         }
[16:59:38.190]         {
[16:59:38.190]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.190]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.190]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.190]             })
[16:59:38.190]         }
[16:59:38.190]     }, args = future.call.arguments)
[16:59:38.190] }
[16:59:38.190] Lazy evaluation: FALSE
[16:59:38.190] Asynchronous evaluation: TRUE
[16:59:38.190] Local evaluation: TRUE
[16:59:38.190] Environment: R_GlobalEnv
[16:59:38.190] Capture standard output: TRUE
[16:59:38.190] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:38.190] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:38.190] Packages: 1 packages (‘stats’)
[16:59:38.190] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:38.190] Resolved: TRUE
[16:59:38.190] Value: <not collected>
[16:59:38.190] Conditions captured: <none>
[16:59:38.190] Early signaling: FALSE
[16:59:38.190] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:38.190] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.201] Chunk #2 of 2 ... DONE
[16:59:38.201] Launching 2 futures (chunks) ... DONE
[16:59:38.201] Resolving 2 futures (chunks) ...
[16:59:38.201] resolve() on list ...
[16:59:38.201]  recursive: 0
[16:59:38.201]  length: 2
[16:59:38.201] 
[16:59:38.202] Future #1
[16:59:38.202] result() for MulticoreFuture ...
[16:59:38.203] result() for MulticoreFuture ...
[16:59:38.203] result() for MulticoreFuture ... done
[16:59:38.203] result() for MulticoreFuture ... done
[16:59:38.203] result() for MulticoreFuture ...
[16:59:38.204] result() for MulticoreFuture ... done
[16:59:38.204] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:38.204] - nx: 2
[16:59:38.204] - relay: TRUE
[16:59:38.204] - stdout: TRUE
[16:59:38.204] - signal: TRUE
[16:59:38.204] - resignal: FALSE
[16:59:38.205] - force: TRUE
[16:59:38.205] - relayed: [n=2] FALSE, FALSE
[16:59:38.205] - queued futures: [n=2] FALSE, FALSE
[16:59:38.205]  - until=1
[16:59:38.205]  - relaying element #1
[16:59:38.205] result() for MulticoreFuture ...
[16:59:38.205] result() for MulticoreFuture ... done
[16:59:38.206] result() for MulticoreFuture ...
[16:59:38.206] result() for MulticoreFuture ... done
[16:59:38.206] result() for MulticoreFuture ...
[16:59:38.206] result() for MulticoreFuture ... done
[16:59:38.206] result() for MulticoreFuture ...
[16:59:38.206] result() for MulticoreFuture ... done
[16:59:38.207] - relayed: [n=2] TRUE, FALSE
[16:59:38.207] - queued futures: [n=2] TRUE, FALSE
[16:59:38.207] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:38.207]  length: 1 (resolved future 1)
[16:59:38.207] Future #2
[16:59:38.207] result() for MulticoreFuture ...
[16:59:38.208] result() for MulticoreFuture ...
[16:59:38.208] result() for MulticoreFuture ... done
[16:59:38.208] result() for MulticoreFuture ... done
[16:59:38.209] result() for MulticoreFuture ...
[16:59:38.209] result() for MulticoreFuture ... done
[16:59:38.209] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:38.209] - nx: 2
[16:59:38.209] - relay: TRUE
[16:59:38.209] - stdout: TRUE
[16:59:38.209] - signal: TRUE
[16:59:38.210] - resignal: FALSE
[16:59:38.210] - force: TRUE
[16:59:38.210] - relayed: [n=2] TRUE, FALSE
[16:59:38.210] - queued futures: [n=2] TRUE, FALSE
[16:59:38.210]  - until=2
[16:59:38.210]  - relaying element #2
[16:59:38.210] result() for MulticoreFuture ...
[16:59:38.210] result() for MulticoreFuture ... done
[16:59:38.210] result() for MulticoreFuture ...
[16:59:38.211] result() for MulticoreFuture ... done
[16:59:38.211] result() for MulticoreFuture ...
[16:59:38.211] result() for MulticoreFuture ... done
[16:59:38.211] result() for MulticoreFuture ...
[16:59:38.211] result() for MulticoreFuture ... done
[16:59:38.211] - relayed: [n=2] TRUE, TRUE
[16:59:38.211] - queued futures: [n=2] TRUE, TRUE
[16:59:38.212] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:38.212]  length: 0 (resolved future 2)
[16:59:38.212] Relaying remaining futures
[16:59:38.212] signalConditionsASAP(NULL, pos=0) ...
[16:59:38.212] - nx: 2
[16:59:38.212] - relay: TRUE
[16:59:38.212] - stdout: TRUE
[16:59:38.212] - signal: TRUE
[16:59:38.212] - resignal: FALSE
[16:59:38.212] - force: TRUE
[16:59:38.213] - relayed: [n=2] TRUE, TRUE
[16:59:38.213] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:38.213] - relayed: [n=2] TRUE, TRUE
[16:59:38.213] - queued futures: [n=2] TRUE, TRUE
[16:59:38.213] signalConditionsASAP(NULL, pos=0) ... done
[16:59:38.213] resolve() on list ... DONE
[16:59:38.213] result() for MulticoreFuture ...
[16:59:38.213] result() for MulticoreFuture ... done
[16:59:38.213] result() for MulticoreFuture ...
[16:59:38.214] result() for MulticoreFuture ... done
[16:59:38.214] result() for MulticoreFuture ...
[16:59:38.214] result() for MulticoreFuture ... done
[16:59:38.214] result() for MulticoreFuture ...
[16:59:38.214] result() for MulticoreFuture ... done
[16:59:38.214]  - Number of value chunks collected: 2
[16:59:38.214] Resolving 2 futures (chunks) ... DONE
[16:59:38.214] Reducing values from 2 chunks ...
[16:59:38.214]  - Number of values collected after concatenation: 3
[16:59:38.215]  - Number of values expected: 3
[16:59:38.215] Reducing values from 2 chunks ... DONE
[16:59:38.215] future_lapply() ... DONE
[16:59:38.216] future_lapply() ...
[16:59:38.221] Number of chunks: 2
[16:59:38.221] getGlobalsAndPackagesXApply() ...
[16:59:38.221]  - future.globals: TRUE
[16:59:38.221] getGlobalsAndPackages() ...
[16:59:38.222] Searching for globals...
[16:59:38.223] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:38.223] Searching for globals ... DONE
[16:59:38.223] Resolving globals: FALSE
[16:59:38.224] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:59:38.224] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:59:38.224] - globals: [1] ‘FUN’
[16:59:38.224] - packages: [1] ‘stats’
[16:59:38.225] getGlobalsAndPackages() ... DONE
[16:59:38.225]  - globals found/used: [n=1] ‘FUN’
[16:59:38.225]  - needed namespaces: [n=1] ‘stats’
[16:59:38.225] Finding globals ... DONE
[16:59:38.225]  - use_args: TRUE
[16:59:38.227]  - Getting '...' globals ...
[16:59:38.227] resolve() on list ...
[16:59:38.228]  recursive: 0
[16:59:38.228]  length: 1
[16:59:38.228]  elements: ‘...’
[16:59:38.228]  length: 0 (resolved future 1)
[16:59:38.228] resolve() on list ... DONE
[16:59:38.228]    - '...' content: [n=0] 
[16:59:38.228] List of 1
[16:59:38.228]  $ ...: list()
[16:59:38.228]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.228]  - attr(*, "where")=List of 1
[16:59:38.228]   ..$ ...:<environment: 0x55c348a90f88> 
[16:59:38.228]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.228]  - attr(*, "resolved")= logi TRUE
[16:59:38.228]  - attr(*, "total_size")= num NA
[16:59:38.232]  - Getting '...' globals ... DONE
[16:59:38.232] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:38.232] List of 2
[16:59:38.232]  $ ...future.FUN:function (x, ...)  
[16:59:38.232]  $ ...          : list()
[16:59:38.232]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.232]  - attr(*, "where")=List of 2
[16:59:38.232]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:38.232]   ..$ ...          :<environment: 0x55c348a90f88> 
[16:59:38.232]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.232]  - attr(*, "resolved")= logi FALSE
[16:59:38.232]  - attr(*, "total_size")= num 1248
[16:59:38.235] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:38.235] getGlobalsAndPackagesXApply() ... DONE
[16:59:38.235] Number of futures (= number of chunks): 2
[16:59:38.236] Launching 2 futures (chunks) ...
[16:59:38.236] Chunk #1 of 2 ...
[16:59:38.236]  - Finding globals in 'X' for chunk #1 ...
[16:59:38.236] getGlobalsAndPackages() ...
[16:59:38.236] Searching for globals...
[16:59:38.236] 
[16:59:38.236] Searching for globals ... DONE
[16:59:38.236] - globals: [0] <none>
[16:59:38.237] getGlobalsAndPackages() ... DONE
[16:59:38.237]    + additional globals found: [n=0] 
[16:59:38.237]    + additional namespaces needed: [n=0] 
[16:59:38.237]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:38.237]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:38.237]  - seeds: <none>
[16:59:38.237]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.237] getGlobalsAndPackages() ...
[16:59:38.237] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.237] Resolving globals: FALSE
[16:59:38.238] Tweak future expression to call with '...' arguments ...
[16:59:38.238] {
[16:59:38.238]     do.call(function(...) {
[16:59:38.238]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.238]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.238]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.238]             on.exit(options(oopts), add = TRUE)
[16:59:38.238]         }
[16:59:38.238]         {
[16:59:38.238]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.238]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.238]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.238]             })
[16:59:38.238]         }
[16:59:38.238]     }, args = future.call.arguments)
[16:59:38.238] }
[16:59:38.238] Tweak future expression to call with '...' arguments ... DONE
[16:59:38.238] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.238] - packages: [1] ‘stats’
[16:59:38.239] getGlobalsAndPackages() ... DONE
[16:59:38.239] run() for ‘Future’ ...
[16:59:38.239] - state: ‘created’
[16:59:38.239] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:38.243] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.243] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:38.243]   - Field: ‘label’
[16:59:38.243]   - Field: ‘local’
[16:59:38.243]   - Field: ‘owner’
[16:59:38.243]   - Field: ‘envir’
[16:59:38.243]   - Field: ‘workers’
[16:59:38.243]   - Field: ‘packages’
[16:59:38.244]   - Field: ‘gc’
[16:59:38.244]   - Field: ‘job’
[16:59:38.244]   - Field: ‘conditions’
[16:59:38.244]   - Field: ‘expr’
[16:59:38.244]   - Field: ‘uuid’
[16:59:38.244]   - Field: ‘seed’
[16:59:38.244]   - Field: ‘version’
[16:59:38.244]   - Field: ‘result’
[16:59:38.244]   - Field: ‘asynchronous’
[16:59:38.244]   - Field: ‘calls’
[16:59:38.244]   - Field: ‘globals’
[16:59:38.245]   - Field: ‘stdout’
[16:59:38.245]   - Field: ‘earlySignal’
[16:59:38.245]   - Field: ‘lazy’
[16:59:38.245]   - Field: ‘state’
[16:59:38.245] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:38.245] - Launch lazy future ...
[16:59:38.245] Packages needed by the future expression (n = 1): ‘stats’
[16:59:38.245] Packages needed by future strategies (n = 0): <none>
[16:59:38.246] {
[16:59:38.246]     {
[16:59:38.246]         {
[16:59:38.246]             ...future.startTime <- base::Sys.time()
[16:59:38.246]             {
[16:59:38.246]                 {
[16:59:38.246]                   {
[16:59:38.246]                     {
[16:59:38.246]                       {
[16:59:38.246]                         base::local({
[16:59:38.246]                           has_future <- base::requireNamespace("future", 
[16:59:38.246]                             quietly = TRUE)
[16:59:38.246]                           if (has_future) {
[16:59:38.246]                             ns <- base::getNamespace("future")
[16:59:38.246]                             version <- ns[[".package"]][["version"]]
[16:59:38.246]                             if (is.null(version)) 
[16:59:38.246]                               version <- utils::packageVersion("future")
[16:59:38.246]                           }
[16:59:38.246]                           else {
[16:59:38.246]                             version <- NULL
[16:59:38.246]                           }
[16:59:38.246]                           if (!has_future || version < "1.8.0") {
[16:59:38.246]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:38.246]                               "", base::R.version$version.string), 
[16:59:38.246]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:38.246]                                 base::R.version$platform, 8 * 
[16:59:38.246]                                   base::.Machine$sizeof.pointer), 
[16:59:38.246]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:38.246]                                 "release", "version")], collapse = " "), 
[16:59:38.246]                               hostname = base::Sys.info()[["nodename"]])
[16:59:38.246]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:38.246]                               info)
[16:59:38.246]                             info <- base::paste(info, collapse = "; ")
[16:59:38.246]                             if (!has_future) {
[16:59:38.246]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:38.246]                                 info)
[16:59:38.246]                             }
[16:59:38.246]                             else {
[16:59:38.246]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:38.246]                                 info, version)
[16:59:38.246]                             }
[16:59:38.246]                             base::stop(msg)
[16:59:38.246]                           }
[16:59:38.246]                         })
[16:59:38.246]                       }
[16:59:38.246]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:38.246]                       base::options(mc.cores = 1L)
[16:59:38.246]                     }
[16:59:38.246]                     base::local({
[16:59:38.246]                       for (pkg in "stats") {
[16:59:38.246]                         base::loadNamespace(pkg)
[16:59:38.246]                         base::library(pkg, character.only = TRUE)
[16:59:38.246]                       }
[16:59:38.246]                     })
[16:59:38.246]                   }
[16:59:38.246]                   ...future.strategy.old <- future::plan("list")
[16:59:38.246]                   options(future.plan = NULL)
[16:59:38.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:38.246]                 }
[16:59:38.246]                 ...future.workdir <- getwd()
[16:59:38.246]             }
[16:59:38.246]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:38.246]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:38.246]         }
[16:59:38.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:38.246]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:38.246]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:38.246]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:38.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:38.246]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:38.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:38.246]             base::names(...future.oldOptions))
[16:59:38.246]     }
[16:59:38.246]     if (FALSE) {
[16:59:38.246]     }
[16:59:38.246]     else {
[16:59:38.246]         if (TRUE) {
[16:59:38.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:38.246]                 open = "w")
[16:59:38.246]         }
[16:59:38.246]         else {
[16:59:38.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:38.246]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:38.246]         }
[16:59:38.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:38.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:38.246]             base::sink(type = "output", split = FALSE)
[16:59:38.246]             base::close(...future.stdout)
[16:59:38.246]         }, add = TRUE)
[16:59:38.246]     }
[16:59:38.246]     ...future.frame <- base::sys.nframe()
[16:59:38.246]     ...future.conditions <- base::list()
[16:59:38.246]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:38.246]     if (FALSE) {
[16:59:38.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:38.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:38.246]     }
[16:59:38.246]     ...future.result <- base::tryCatch({
[16:59:38.246]         base::withCallingHandlers({
[16:59:38.246]             ...future.value <- base::withVisible(base::local({
[16:59:38.246]                 withCallingHandlers({
[16:59:38.246]                   {
[16:59:38.246]                     do.call(function(...) {
[16:59:38.246]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.246]                       if (!identical(...future.globals.maxSize.org, 
[16:59:38.246]                         ...future.globals.maxSize)) {
[16:59:38.246]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.246]                         on.exit(options(oopts), add = TRUE)
[16:59:38.246]                       }
[16:59:38.246]                       {
[16:59:38.246]                         lapply(seq_along(...future.elements_ii), 
[16:59:38.246]                           FUN = function(jj) {
[16:59:38.246]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.246]                             ...future.FUN(...future.X_jj, ...)
[16:59:38.246]                           })
[16:59:38.246]                       }
[16:59:38.246]                     }, args = future.call.arguments)
[16:59:38.246]                   }
[16:59:38.246]                 }, immediateCondition = function(cond) {
[16:59:38.246]                   save_rds <- function (object, pathname, ...) 
[16:59:38.246]                   {
[16:59:38.246]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:38.246]                     if (file_test("-f", pathname_tmp)) {
[16:59:38.246]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.246]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:38.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.246]                         fi_tmp[["mtime"]])
[16:59:38.246]                     }
[16:59:38.246]                     tryCatch({
[16:59:38.246]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:38.246]                     }, error = function(ex) {
[16:59:38.246]                       msg <- conditionMessage(ex)
[16:59:38.246]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.246]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:38.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.246]                         fi_tmp[["mtime"]], msg)
[16:59:38.246]                       ex$message <- msg
[16:59:38.246]                       stop(ex)
[16:59:38.246]                     })
[16:59:38.246]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:38.246]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:38.246]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:38.246]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.246]                       fi <- file.info(pathname)
[16:59:38.246]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:38.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.246]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:38.246]                         fi[["size"]], fi[["mtime"]])
[16:59:38.246]                       stop(msg)
[16:59:38.246]                     }
[16:59:38.246]                     invisible(pathname)
[16:59:38.246]                   }
[16:59:38.246]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:38.246]                     rootPath = tempdir()) 
[16:59:38.246]                   {
[16:59:38.246]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:38.246]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:38.246]                       tmpdir = path, fileext = ".rds")
[16:59:38.246]                     save_rds(obj, file)
[16:59:38.246]                   }
[16:59:38.246]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0io6nB/.future/immediateConditions")
[16:59:38.246]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.246]                   {
[16:59:38.246]                     inherits <- base::inherits
[16:59:38.246]                     invokeRestart <- base::invokeRestart
[16:59:38.246]                     is.null <- base::is.null
[16:59:38.246]                     muffled <- FALSE
[16:59:38.246]                     if (inherits(cond, "message")) {
[16:59:38.246]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:38.246]                       if (muffled) 
[16:59:38.246]                         invokeRestart("muffleMessage")
[16:59:38.246]                     }
[16:59:38.246]                     else if (inherits(cond, "warning")) {
[16:59:38.246]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:38.246]                       if (muffled) 
[16:59:38.246]                         invokeRestart("muffleWarning")
[16:59:38.246]                     }
[16:59:38.246]                     else if (inherits(cond, "condition")) {
[16:59:38.246]                       if (!is.null(pattern)) {
[16:59:38.246]                         computeRestarts <- base::computeRestarts
[16:59:38.246]                         grepl <- base::grepl
[16:59:38.246]                         restarts <- computeRestarts(cond)
[16:59:38.246]                         for (restart in restarts) {
[16:59:38.246]                           name <- restart$name
[16:59:38.246]                           if (is.null(name)) 
[16:59:38.246]                             next
[16:59:38.246]                           if (!grepl(pattern, name)) 
[16:59:38.246]                             next
[16:59:38.246]                           invokeRestart(restart)
[16:59:38.246]                           muffled <- TRUE
[16:59:38.246]                           break
[16:59:38.246]                         }
[16:59:38.246]                       }
[16:59:38.246]                     }
[16:59:38.246]                     invisible(muffled)
[16:59:38.246]                   }
[16:59:38.246]                   muffleCondition(cond)
[16:59:38.246]                 })
[16:59:38.246]             }))
[16:59:38.246]             future::FutureResult(value = ...future.value$value, 
[16:59:38.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.246]                   ...future.rng), globalenv = if (FALSE) 
[16:59:38.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:38.246]                     ...future.globalenv.names))
[16:59:38.246]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:38.246]         }, condition = base::local({
[16:59:38.246]             c <- base::c
[16:59:38.246]             inherits <- base::inherits
[16:59:38.246]             invokeRestart <- base::invokeRestart
[16:59:38.246]             length <- base::length
[16:59:38.246]             list <- base::list
[16:59:38.246]             seq.int <- base::seq.int
[16:59:38.246]             signalCondition <- base::signalCondition
[16:59:38.246]             sys.calls <- base::sys.calls
[16:59:38.246]             `[[` <- base::`[[`
[16:59:38.246]             `+` <- base::`+`
[16:59:38.246]             `<<-` <- base::`<<-`
[16:59:38.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:38.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:38.246]                   3L)]
[16:59:38.246]             }
[16:59:38.246]             function(cond) {
[16:59:38.246]                 is_error <- inherits(cond, "error")
[16:59:38.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:38.246]                   NULL)
[16:59:38.246]                 if (is_error) {
[16:59:38.246]                   sessionInformation <- function() {
[16:59:38.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:38.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:38.246]                       search = base::search(), system = base::Sys.info())
[16:59:38.246]                   }
[16:59:38.246]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:38.246]                     cond$call), session = sessionInformation(), 
[16:59:38.246]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:38.246]                   signalCondition(cond)
[16:59:38.246]                 }
[16:59:38.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:38.246]                 "immediateCondition"))) {
[16:59:38.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:38.246]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:38.246]                   if (TRUE && !signal) {
[16:59:38.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.246]                     {
[16:59:38.246]                       inherits <- base::inherits
[16:59:38.246]                       invokeRestart <- base::invokeRestart
[16:59:38.246]                       is.null <- base::is.null
[16:59:38.246]                       muffled <- FALSE
[16:59:38.246]                       if (inherits(cond, "message")) {
[16:59:38.246]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.246]                         if (muffled) 
[16:59:38.246]                           invokeRestart("muffleMessage")
[16:59:38.246]                       }
[16:59:38.246]                       else if (inherits(cond, "warning")) {
[16:59:38.246]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.246]                         if (muffled) 
[16:59:38.246]                           invokeRestart("muffleWarning")
[16:59:38.246]                       }
[16:59:38.246]                       else if (inherits(cond, "condition")) {
[16:59:38.246]                         if (!is.null(pattern)) {
[16:59:38.246]                           computeRestarts <- base::computeRestarts
[16:59:38.246]                           grepl <- base::grepl
[16:59:38.246]                           restarts <- computeRestarts(cond)
[16:59:38.246]                           for (restart in restarts) {
[16:59:38.246]                             name <- restart$name
[16:59:38.246]                             if (is.null(name)) 
[16:59:38.246]                               next
[16:59:38.246]                             if (!grepl(pattern, name)) 
[16:59:38.246]                               next
[16:59:38.246]                             invokeRestart(restart)
[16:59:38.246]                             muffled <- TRUE
[16:59:38.246]                             break
[16:59:38.246]                           }
[16:59:38.246]                         }
[16:59:38.246]                       }
[16:59:38.246]                       invisible(muffled)
[16:59:38.246]                     }
[16:59:38.246]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.246]                   }
[16:59:38.246]                 }
[16:59:38.246]                 else {
[16:59:38.246]                   if (TRUE) {
[16:59:38.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.246]                     {
[16:59:38.246]                       inherits <- base::inherits
[16:59:38.246]                       invokeRestart <- base::invokeRestart
[16:59:38.246]                       is.null <- base::is.null
[16:59:38.246]                       muffled <- FALSE
[16:59:38.246]                       if (inherits(cond, "message")) {
[16:59:38.246]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.246]                         if (muffled) 
[16:59:38.246]                           invokeRestart("muffleMessage")
[16:59:38.246]                       }
[16:59:38.246]                       else if (inherits(cond, "warning")) {
[16:59:38.246]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.246]                         if (muffled) 
[16:59:38.246]                           invokeRestart("muffleWarning")
[16:59:38.246]                       }
[16:59:38.246]                       else if (inherits(cond, "condition")) {
[16:59:38.246]                         if (!is.null(pattern)) {
[16:59:38.246]                           computeRestarts <- base::computeRestarts
[16:59:38.246]                           grepl <- base::grepl
[16:59:38.246]                           restarts <- computeRestarts(cond)
[16:59:38.246]                           for (restart in restarts) {
[16:59:38.246]                             name <- restart$name
[16:59:38.246]                             if (is.null(name)) 
[16:59:38.246]                               next
[16:59:38.246]                             if (!grepl(pattern, name)) 
[16:59:38.246]                               next
[16:59:38.246]                             invokeRestart(restart)
[16:59:38.246]                             muffled <- TRUE
[16:59:38.246]                             break
[16:59:38.246]                           }
[16:59:38.246]                         }
[16:59:38.246]                       }
[16:59:38.246]                       invisible(muffled)
[16:59:38.246]                     }
[16:59:38.246]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.246]                   }
[16:59:38.246]                 }
[16:59:38.246]             }
[16:59:38.246]         }))
[16:59:38.246]     }, error = function(ex) {
[16:59:38.246]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:38.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.246]                 ...future.rng), started = ...future.startTime, 
[16:59:38.246]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:38.246]             version = "1.8"), class = "FutureResult")
[16:59:38.246]     }, finally = {
[16:59:38.246]         if (!identical(...future.workdir, getwd())) 
[16:59:38.246]             setwd(...future.workdir)
[16:59:38.246]         {
[16:59:38.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:38.246]                 ...future.oldOptions$nwarnings <- NULL
[16:59:38.246]             }
[16:59:38.246]             base::options(...future.oldOptions)
[16:59:38.246]             if (.Platform$OS.type == "windows") {
[16:59:38.246]                 old_names <- names(...future.oldEnvVars)
[16:59:38.246]                 envs <- base::Sys.getenv()
[16:59:38.246]                 names <- names(envs)
[16:59:38.246]                 common <- intersect(names, old_names)
[16:59:38.246]                 added <- setdiff(names, old_names)
[16:59:38.246]                 removed <- setdiff(old_names, names)
[16:59:38.246]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:38.246]                   envs[common]]
[16:59:38.246]                 NAMES <- toupper(changed)
[16:59:38.246]                 args <- list()
[16:59:38.246]                 for (kk in seq_along(NAMES)) {
[16:59:38.246]                   name <- changed[[kk]]
[16:59:38.246]                   NAME <- NAMES[[kk]]
[16:59:38.246]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.246]                     next
[16:59:38.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.246]                 }
[16:59:38.246]                 NAMES <- toupper(added)
[16:59:38.246]                 for (kk in seq_along(NAMES)) {
[16:59:38.246]                   name <- added[[kk]]
[16:59:38.246]                   NAME <- NAMES[[kk]]
[16:59:38.246]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.246]                     next
[16:59:38.246]                   args[[name]] <- ""
[16:59:38.246]                 }
[16:59:38.246]                 NAMES <- toupper(removed)
[16:59:38.246]                 for (kk in seq_along(NAMES)) {
[16:59:38.246]                   name <- removed[[kk]]
[16:59:38.246]                   NAME <- NAMES[[kk]]
[16:59:38.246]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.246]                     next
[16:59:38.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.246]                 }
[16:59:38.246]                 if (length(args) > 0) 
[16:59:38.246]                   base::do.call(base::Sys.setenv, args = args)
[16:59:38.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:38.246]             }
[16:59:38.246]             else {
[16:59:38.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:38.246]             }
[16:59:38.246]             {
[16:59:38.246]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:38.246]                   0L) {
[16:59:38.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:38.246]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:38.246]                   base::options(opts)
[16:59:38.246]                 }
[16:59:38.246]                 {
[16:59:38.246]                   {
[16:59:38.246]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:38.246]                     NULL
[16:59:38.246]                   }
[16:59:38.246]                   options(future.plan = NULL)
[16:59:38.246]                   if (is.na(NA_character_)) 
[16:59:38.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:38.246]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:38.246]                     .init = FALSE)
[16:59:38.246]                 }
[16:59:38.246]             }
[16:59:38.246]         }
[16:59:38.246]     })
[16:59:38.246]     if (TRUE) {
[16:59:38.246]         base::sink(type = "output", split = FALSE)
[16:59:38.246]         if (TRUE) {
[16:59:38.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:38.246]         }
[16:59:38.246]         else {
[16:59:38.246]             ...future.result["stdout"] <- base::list(NULL)
[16:59:38.246]         }
[16:59:38.246]         base::close(...future.stdout)
[16:59:38.246]         ...future.stdout <- NULL
[16:59:38.246]     }
[16:59:38.246]     ...future.result$conditions <- ...future.conditions
[16:59:38.246]     ...future.result$finished <- base::Sys.time()
[16:59:38.246]     ...future.result
[16:59:38.246] }
[16:59:38.248] assign_globals() ...
[16:59:38.249] List of 5
[16:59:38.249]  $ ...future.FUN            :function (x, ...)  
[16:59:38.249]  $ future.call.arguments    : list()
[16:59:38.249]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.249]  $ ...future.elements_ii    :List of 1
[16:59:38.249]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:59:38.249]  $ ...future.seeds_ii       : NULL
[16:59:38.249]  $ ...future.globals.maxSize: NULL
[16:59:38.249]  - attr(*, "where")=List of 5
[16:59:38.249]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:38.249]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:38.249]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:38.249]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:38.249]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:38.249]  - attr(*, "resolved")= logi FALSE
[16:59:38.249]  - attr(*, "total_size")= num 1248
[16:59:38.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.249]  - attr(*, "already-done")= logi TRUE
[16:59:38.253] - copied ‘...future.FUN’ to environment
[16:59:38.253] - copied ‘future.call.arguments’ to environment
[16:59:38.253] - copied ‘...future.elements_ii’ to environment
[16:59:38.253] - copied ‘...future.seeds_ii’ to environment
[16:59:38.254] - copied ‘...future.globals.maxSize’ to environment
[16:59:38.254] assign_globals() ... done
[16:59:38.254] requestCore(): workers = 2
[16:59:38.256] MulticoreFuture started
[16:59:38.256] - Launch lazy future ... done
[16:59:38.256] run() for ‘MulticoreFuture’ ... done
[16:59:38.257] Created future:
[16:59:38.260] plan(): Setting new future strategy stack:
[16:59:38.260] List of future strategies:
[16:59:38.260] 1. sequential:
[16:59:38.260]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:38.260]    - tweaked: FALSE
[16:59:38.260]    - call: NULL
[16:59:38.261] plan(): nbrOfWorkers() = 1
[16:59:38.264] plan(): Setting new future strategy stack:
[16:59:38.264] List of future strategies:
[16:59:38.264] 1. multicore:
[16:59:38.264]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:38.264]    - tweaked: FALSE
[16:59:38.264]    - call: plan(strategy)
[16:59:38.269] plan(): nbrOfWorkers() = 2
[16:59:38.260] MulticoreFuture:
[16:59:38.260] Label: ‘future_eapply-1’
[16:59:38.260] Expression:
[16:59:38.260] {
[16:59:38.260]     do.call(function(...) {
[16:59:38.260]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.260]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.260]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.260]             on.exit(options(oopts), add = TRUE)
[16:59:38.260]         }
[16:59:38.260]         {
[16:59:38.260]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.260]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.260]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.260]             })
[16:59:38.260]         }
[16:59:38.260]     }, args = future.call.arguments)
[16:59:38.260] }
[16:59:38.260] Lazy evaluation: FALSE
[16:59:38.260] Asynchronous evaluation: TRUE
[16:59:38.260] Local evaluation: TRUE
[16:59:38.260] Environment: R_GlobalEnv
[16:59:38.260] Capture standard output: TRUE
[16:59:38.260] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:38.260] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:38.260] Packages: 1 packages (‘stats’)
[16:59:38.260] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:38.260] Resolved: TRUE
[16:59:38.260] Value: <not collected>
[16:59:38.260] Conditions captured: <none>
[16:59:38.260] Early signaling: FALSE
[16:59:38.260] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:38.260] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.270] Chunk #1 of 2 ... DONE
[16:59:38.270] Chunk #2 of 2 ...
[16:59:38.271]  - Finding globals in 'X' for chunk #2 ...
[16:59:38.271] getGlobalsAndPackages() ...
[16:59:38.271] Searching for globals...
[16:59:38.271] 
[16:59:38.272] Searching for globals ... DONE
[16:59:38.272] - globals: [0] <none>
[16:59:38.272] getGlobalsAndPackages() ... DONE
[16:59:38.272]    + additional globals found: [n=0] 
[16:59:38.272]    + additional namespaces needed: [n=0] 
[16:59:38.272]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:38.273]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:38.273]  - seeds: <none>
[16:59:38.273]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.273] getGlobalsAndPackages() ...
[16:59:38.273] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.273] Resolving globals: FALSE
[16:59:38.274] Tweak future expression to call with '...' arguments ...
[16:59:38.274] {
[16:59:38.274]     do.call(function(...) {
[16:59:38.274]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.274]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.274]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.274]             on.exit(options(oopts), add = TRUE)
[16:59:38.274]         }
[16:59:38.274]         {
[16:59:38.274]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.274]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.274]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.274]             })
[16:59:38.274]         }
[16:59:38.274]     }, args = future.call.arguments)
[16:59:38.274] }
[16:59:38.274] Tweak future expression to call with '...' arguments ... DONE
[16:59:38.275] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.275] - packages: [1] ‘stats’
[16:59:38.275] getGlobalsAndPackages() ... DONE
[16:59:38.276] run() for ‘Future’ ...
[16:59:38.276] - state: ‘created’
[16:59:38.276] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:38.281] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.281] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:38.281]   - Field: ‘label’
[16:59:38.281]   - Field: ‘local’
[16:59:38.282]   - Field: ‘owner’
[16:59:38.282]   - Field: ‘envir’
[16:59:38.282]   - Field: ‘workers’
[16:59:38.282]   - Field: ‘packages’
[16:59:38.282]   - Field: ‘gc’
[16:59:38.282]   - Field: ‘job’
[16:59:38.282]   - Field: ‘conditions’
[16:59:38.282]   - Field: ‘expr’
[16:59:38.283]   - Field: ‘uuid’
[16:59:38.283]   - Field: ‘seed’
[16:59:38.283]   - Field: ‘version’
[16:59:38.283]   - Field: ‘result’
[16:59:38.283]   - Field: ‘asynchronous’
[16:59:38.283]   - Field: ‘calls’
[16:59:38.284]   - Field: ‘globals’
[16:59:38.284]   - Field: ‘stdout’
[16:59:38.284]   - Field: ‘earlySignal’
[16:59:38.284]   - Field: ‘lazy’
[16:59:38.284]   - Field: ‘state’
[16:59:38.284] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:38.284] - Launch lazy future ...
[16:59:38.285] Packages needed by the future expression (n = 1): ‘stats’
[16:59:38.285] Packages needed by future strategies (n = 0): <none>
[16:59:38.286] {
[16:59:38.286]     {
[16:59:38.286]         {
[16:59:38.286]             ...future.startTime <- base::Sys.time()
[16:59:38.286]             {
[16:59:38.286]                 {
[16:59:38.286]                   {
[16:59:38.286]                     {
[16:59:38.286]                       {
[16:59:38.286]                         base::local({
[16:59:38.286]                           has_future <- base::requireNamespace("future", 
[16:59:38.286]                             quietly = TRUE)
[16:59:38.286]                           if (has_future) {
[16:59:38.286]                             ns <- base::getNamespace("future")
[16:59:38.286]                             version <- ns[[".package"]][["version"]]
[16:59:38.286]                             if (is.null(version)) 
[16:59:38.286]                               version <- utils::packageVersion("future")
[16:59:38.286]                           }
[16:59:38.286]                           else {
[16:59:38.286]                             version <- NULL
[16:59:38.286]                           }
[16:59:38.286]                           if (!has_future || version < "1.8.0") {
[16:59:38.286]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:38.286]                               "", base::R.version$version.string), 
[16:59:38.286]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:38.286]                                 base::R.version$platform, 8 * 
[16:59:38.286]                                   base::.Machine$sizeof.pointer), 
[16:59:38.286]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:38.286]                                 "release", "version")], collapse = " "), 
[16:59:38.286]                               hostname = base::Sys.info()[["nodename"]])
[16:59:38.286]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:38.286]                               info)
[16:59:38.286]                             info <- base::paste(info, collapse = "; ")
[16:59:38.286]                             if (!has_future) {
[16:59:38.286]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:38.286]                                 info)
[16:59:38.286]                             }
[16:59:38.286]                             else {
[16:59:38.286]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:38.286]                                 info, version)
[16:59:38.286]                             }
[16:59:38.286]                             base::stop(msg)
[16:59:38.286]                           }
[16:59:38.286]                         })
[16:59:38.286]                       }
[16:59:38.286]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:38.286]                       base::options(mc.cores = 1L)
[16:59:38.286]                     }
[16:59:38.286]                     base::local({
[16:59:38.286]                       for (pkg in "stats") {
[16:59:38.286]                         base::loadNamespace(pkg)
[16:59:38.286]                         base::library(pkg, character.only = TRUE)
[16:59:38.286]                       }
[16:59:38.286]                     })
[16:59:38.286]                   }
[16:59:38.286]                   ...future.strategy.old <- future::plan("list")
[16:59:38.286]                   options(future.plan = NULL)
[16:59:38.286]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.286]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:38.286]                 }
[16:59:38.286]                 ...future.workdir <- getwd()
[16:59:38.286]             }
[16:59:38.286]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:38.286]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:38.286]         }
[16:59:38.286]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:38.286]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:38.286]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:38.286]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:38.286]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:38.286]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:38.286]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:38.286]             base::names(...future.oldOptions))
[16:59:38.286]     }
[16:59:38.286]     if (FALSE) {
[16:59:38.286]     }
[16:59:38.286]     else {
[16:59:38.286]         if (TRUE) {
[16:59:38.286]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:38.286]                 open = "w")
[16:59:38.286]         }
[16:59:38.286]         else {
[16:59:38.286]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:38.286]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:38.286]         }
[16:59:38.286]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:38.286]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:38.286]             base::sink(type = "output", split = FALSE)
[16:59:38.286]             base::close(...future.stdout)
[16:59:38.286]         }, add = TRUE)
[16:59:38.286]     }
[16:59:38.286]     ...future.frame <- base::sys.nframe()
[16:59:38.286]     ...future.conditions <- base::list()
[16:59:38.286]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:38.286]     if (FALSE) {
[16:59:38.286]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:38.286]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:38.286]     }
[16:59:38.286]     ...future.result <- base::tryCatch({
[16:59:38.286]         base::withCallingHandlers({
[16:59:38.286]             ...future.value <- base::withVisible(base::local({
[16:59:38.286]                 withCallingHandlers({
[16:59:38.286]                   {
[16:59:38.286]                     do.call(function(...) {
[16:59:38.286]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.286]                       if (!identical(...future.globals.maxSize.org, 
[16:59:38.286]                         ...future.globals.maxSize)) {
[16:59:38.286]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.286]                         on.exit(options(oopts), add = TRUE)
[16:59:38.286]                       }
[16:59:38.286]                       {
[16:59:38.286]                         lapply(seq_along(...future.elements_ii), 
[16:59:38.286]                           FUN = function(jj) {
[16:59:38.286]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.286]                             ...future.FUN(...future.X_jj, ...)
[16:59:38.286]                           })
[16:59:38.286]                       }
[16:59:38.286]                     }, args = future.call.arguments)
[16:59:38.286]                   }
[16:59:38.286]                 }, immediateCondition = function(cond) {
[16:59:38.286]                   save_rds <- function (object, pathname, ...) 
[16:59:38.286]                   {
[16:59:38.286]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:38.286]                     if (file_test("-f", pathname_tmp)) {
[16:59:38.286]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.286]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:38.286]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.286]                         fi_tmp[["mtime"]])
[16:59:38.286]                     }
[16:59:38.286]                     tryCatch({
[16:59:38.286]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:38.286]                     }, error = function(ex) {
[16:59:38.286]                       msg <- conditionMessage(ex)
[16:59:38.286]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.286]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:38.286]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.286]                         fi_tmp[["mtime"]], msg)
[16:59:38.286]                       ex$message <- msg
[16:59:38.286]                       stop(ex)
[16:59:38.286]                     })
[16:59:38.286]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:38.286]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:38.286]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:38.286]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.286]                       fi <- file.info(pathname)
[16:59:38.286]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:38.286]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.286]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:38.286]                         fi[["size"]], fi[["mtime"]])
[16:59:38.286]                       stop(msg)
[16:59:38.286]                     }
[16:59:38.286]                     invisible(pathname)
[16:59:38.286]                   }
[16:59:38.286]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:38.286]                     rootPath = tempdir()) 
[16:59:38.286]                   {
[16:59:38.286]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:38.286]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:38.286]                       tmpdir = path, fileext = ".rds")
[16:59:38.286]                     save_rds(obj, file)
[16:59:38.286]                   }
[16:59:38.286]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0io6nB/.future/immediateConditions")
[16:59:38.286]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.286]                   {
[16:59:38.286]                     inherits <- base::inherits
[16:59:38.286]                     invokeRestart <- base::invokeRestart
[16:59:38.286]                     is.null <- base::is.null
[16:59:38.286]                     muffled <- FALSE
[16:59:38.286]                     if (inherits(cond, "message")) {
[16:59:38.286]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:38.286]                       if (muffled) 
[16:59:38.286]                         invokeRestart("muffleMessage")
[16:59:38.286]                     }
[16:59:38.286]                     else if (inherits(cond, "warning")) {
[16:59:38.286]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:38.286]                       if (muffled) 
[16:59:38.286]                         invokeRestart("muffleWarning")
[16:59:38.286]                     }
[16:59:38.286]                     else if (inherits(cond, "condition")) {
[16:59:38.286]                       if (!is.null(pattern)) {
[16:59:38.286]                         computeRestarts <- base::computeRestarts
[16:59:38.286]                         grepl <- base::grepl
[16:59:38.286]                         restarts <- computeRestarts(cond)
[16:59:38.286]                         for (restart in restarts) {
[16:59:38.286]                           name <- restart$name
[16:59:38.286]                           if (is.null(name)) 
[16:59:38.286]                             next
[16:59:38.286]                           if (!grepl(pattern, name)) 
[16:59:38.286]                             next
[16:59:38.286]                           invokeRestart(restart)
[16:59:38.286]                           muffled <- TRUE
[16:59:38.286]                           break
[16:59:38.286]                         }
[16:59:38.286]                       }
[16:59:38.286]                     }
[16:59:38.286]                     invisible(muffled)
[16:59:38.286]                   }
[16:59:38.286]                   muffleCondition(cond)
[16:59:38.286]                 })
[16:59:38.286]             }))
[16:59:38.286]             future::FutureResult(value = ...future.value$value, 
[16:59:38.286]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.286]                   ...future.rng), globalenv = if (FALSE) 
[16:59:38.286]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:38.286]                     ...future.globalenv.names))
[16:59:38.286]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:38.286]         }, condition = base::local({
[16:59:38.286]             c <- base::c
[16:59:38.286]             inherits <- base::inherits
[16:59:38.286]             invokeRestart <- base::invokeRestart
[16:59:38.286]             length <- base::length
[16:59:38.286]             list <- base::list
[16:59:38.286]             seq.int <- base::seq.int
[16:59:38.286]             signalCondition <- base::signalCondition
[16:59:38.286]             sys.calls <- base::sys.calls
[16:59:38.286]             `[[` <- base::`[[`
[16:59:38.286]             `+` <- base::`+`
[16:59:38.286]             `<<-` <- base::`<<-`
[16:59:38.286]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:38.286]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:38.286]                   3L)]
[16:59:38.286]             }
[16:59:38.286]             function(cond) {
[16:59:38.286]                 is_error <- inherits(cond, "error")
[16:59:38.286]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:38.286]                   NULL)
[16:59:38.286]                 if (is_error) {
[16:59:38.286]                   sessionInformation <- function() {
[16:59:38.286]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:38.286]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:38.286]                       search = base::search(), system = base::Sys.info())
[16:59:38.286]                   }
[16:59:38.286]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.286]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:38.286]                     cond$call), session = sessionInformation(), 
[16:59:38.286]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:38.286]                   signalCondition(cond)
[16:59:38.286]                 }
[16:59:38.286]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:38.286]                 "immediateCondition"))) {
[16:59:38.286]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:38.286]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.286]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:38.286]                   if (TRUE && !signal) {
[16:59:38.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.286]                     {
[16:59:38.286]                       inherits <- base::inherits
[16:59:38.286]                       invokeRestart <- base::invokeRestart
[16:59:38.286]                       is.null <- base::is.null
[16:59:38.286]                       muffled <- FALSE
[16:59:38.286]                       if (inherits(cond, "message")) {
[16:59:38.286]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.286]                         if (muffled) 
[16:59:38.286]                           invokeRestart("muffleMessage")
[16:59:38.286]                       }
[16:59:38.286]                       else if (inherits(cond, "warning")) {
[16:59:38.286]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.286]                         if (muffled) 
[16:59:38.286]                           invokeRestart("muffleWarning")
[16:59:38.286]                       }
[16:59:38.286]                       else if (inherits(cond, "condition")) {
[16:59:38.286]                         if (!is.null(pattern)) {
[16:59:38.286]                           computeRestarts <- base::computeRestarts
[16:59:38.286]                           grepl <- base::grepl
[16:59:38.286]                           restarts <- computeRestarts(cond)
[16:59:38.286]                           for (restart in restarts) {
[16:59:38.286]                             name <- restart$name
[16:59:38.286]                             if (is.null(name)) 
[16:59:38.286]                               next
[16:59:38.286]                             if (!grepl(pattern, name)) 
[16:59:38.286]                               next
[16:59:38.286]                             invokeRestart(restart)
[16:59:38.286]                             muffled <- TRUE
[16:59:38.286]                             break
[16:59:38.286]                           }
[16:59:38.286]                         }
[16:59:38.286]                       }
[16:59:38.286]                       invisible(muffled)
[16:59:38.286]                     }
[16:59:38.286]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.286]                   }
[16:59:38.286]                 }
[16:59:38.286]                 else {
[16:59:38.286]                   if (TRUE) {
[16:59:38.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.286]                     {
[16:59:38.286]                       inherits <- base::inherits
[16:59:38.286]                       invokeRestart <- base::invokeRestart
[16:59:38.286]                       is.null <- base::is.null
[16:59:38.286]                       muffled <- FALSE
[16:59:38.286]                       if (inherits(cond, "message")) {
[16:59:38.286]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.286]                         if (muffled) 
[16:59:38.286]                           invokeRestart("muffleMessage")
[16:59:38.286]                       }
[16:59:38.286]                       else if (inherits(cond, "warning")) {
[16:59:38.286]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.286]                         if (muffled) 
[16:59:38.286]                           invokeRestart("muffleWarning")
[16:59:38.286]                       }
[16:59:38.286]                       else if (inherits(cond, "condition")) {
[16:59:38.286]                         if (!is.null(pattern)) {
[16:59:38.286]                           computeRestarts <- base::computeRestarts
[16:59:38.286]                           grepl <- base::grepl
[16:59:38.286]                           restarts <- computeRestarts(cond)
[16:59:38.286]                           for (restart in restarts) {
[16:59:38.286]                             name <- restart$name
[16:59:38.286]                             if (is.null(name)) 
[16:59:38.286]                               next
[16:59:38.286]                             if (!grepl(pattern, name)) 
[16:59:38.286]                               next
[16:59:38.286]                             invokeRestart(restart)
[16:59:38.286]                             muffled <- TRUE
[16:59:38.286]                             break
[16:59:38.286]                           }
[16:59:38.286]                         }
[16:59:38.286]                       }
[16:59:38.286]                       invisible(muffled)
[16:59:38.286]                     }
[16:59:38.286]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.286]                   }
[16:59:38.286]                 }
[16:59:38.286]             }
[16:59:38.286]         }))
[16:59:38.286]     }, error = function(ex) {
[16:59:38.286]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:38.286]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.286]                 ...future.rng), started = ...future.startTime, 
[16:59:38.286]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:38.286]             version = "1.8"), class = "FutureResult")
[16:59:38.286]     }, finally = {
[16:59:38.286]         if (!identical(...future.workdir, getwd())) 
[16:59:38.286]             setwd(...future.workdir)
[16:59:38.286]         {
[16:59:38.286]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:38.286]                 ...future.oldOptions$nwarnings <- NULL
[16:59:38.286]             }
[16:59:38.286]             base::options(...future.oldOptions)
[16:59:38.286]             if (.Platform$OS.type == "windows") {
[16:59:38.286]                 old_names <- names(...future.oldEnvVars)
[16:59:38.286]                 envs <- base::Sys.getenv()
[16:59:38.286]                 names <- names(envs)
[16:59:38.286]                 common <- intersect(names, old_names)
[16:59:38.286]                 added <- setdiff(names, old_names)
[16:59:38.286]                 removed <- setdiff(old_names, names)
[16:59:38.286]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:38.286]                   envs[common]]
[16:59:38.286]                 NAMES <- toupper(changed)
[16:59:38.286]                 args <- list()
[16:59:38.286]                 for (kk in seq_along(NAMES)) {
[16:59:38.286]                   name <- changed[[kk]]
[16:59:38.286]                   NAME <- NAMES[[kk]]
[16:59:38.286]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.286]                     next
[16:59:38.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.286]                 }
[16:59:38.286]                 NAMES <- toupper(added)
[16:59:38.286]                 for (kk in seq_along(NAMES)) {
[16:59:38.286]                   name <- added[[kk]]
[16:59:38.286]                   NAME <- NAMES[[kk]]
[16:59:38.286]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.286]                     next
[16:59:38.286]                   args[[name]] <- ""
[16:59:38.286]                 }
[16:59:38.286]                 NAMES <- toupper(removed)
[16:59:38.286]                 for (kk in seq_along(NAMES)) {
[16:59:38.286]                   name <- removed[[kk]]
[16:59:38.286]                   NAME <- NAMES[[kk]]
[16:59:38.286]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.286]                     next
[16:59:38.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.286]                 }
[16:59:38.286]                 if (length(args) > 0) 
[16:59:38.286]                   base::do.call(base::Sys.setenv, args = args)
[16:59:38.286]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:38.286]             }
[16:59:38.286]             else {
[16:59:38.286]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:38.286]             }
[16:59:38.286]             {
[16:59:38.286]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:38.286]                   0L) {
[16:59:38.286]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:38.286]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:38.286]                   base::options(opts)
[16:59:38.286]                 }
[16:59:38.286]                 {
[16:59:38.286]                   {
[16:59:38.286]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:38.286]                     NULL
[16:59:38.286]                   }
[16:59:38.286]                   options(future.plan = NULL)
[16:59:38.286]                   if (is.na(NA_character_)) 
[16:59:38.286]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.286]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:38.286]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:38.286]                     .init = FALSE)
[16:59:38.286]                 }
[16:59:38.286]             }
[16:59:38.286]         }
[16:59:38.286]     })
[16:59:38.286]     if (TRUE) {
[16:59:38.286]         base::sink(type = "output", split = FALSE)
[16:59:38.286]         if (TRUE) {
[16:59:38.286]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:38.286]         }
[16:59:38.286]         else {
[16:59:38.286]             ...future.result["stdout"] <- base::list(NULL)
[16:59:38.286]         }
[16:59:38.286]         base::close(...future.stdout)
[16:59:38.286]         ...future.stdout <- NULL
[16:59:38.286]     }
[16:59:38.286]     ...future.result$conditions <- ...future.conditions
[16:59:38.286]     ...future.result$finished <- base::Sys.time()
[16:59:38.286]     ...future.result
[16:59:38.286] }
[16:59:38.289] assign_globals() ...
[16:59:38.289] List of 5
[16:59:38.289]  $ ...future.FUN            :function (x, ...)  
[16:59:38.289]  $ future.call.arguments    : list()
[16:59:38.289]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.289]  $ ...future.elements_ii    :List of 2
[16:59:38.289]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:59:38.289]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:59:38.289]  $ ...future.seeds_ii       : NULL
[16:59:38.289]  $ ...future.globals.maxSize: NULL
[16:59:38.289]  - attr(*, "where")=List of 5
[16:59:38.289]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:38.289]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:38.289]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:38.289]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:38.289]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:38.289]  - attr(*, "resolved")= logi FALSE
[16:59:38.289]  - attr(*, "total_size")= num 1248
[16:59:38.289]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.289]  - attr(*, "already-done")= logi TRUE
[16:59:38.296] - copied ‘...future.FUN’ to environment
[16:59:38.296] - copied ‘future.call.arguments’ to environment
[16:59:38.296] - copied ‘...future.elements_ii’ to environment
[16:59:38.296] - copied ‘...future.seeds_ii’ to environment
[16:59:38.297] - copied ‘...future.globals.maxSize’ to environment
[16:59:38.297] assign_globals() ... done
[16:59:38.297] requestCore(): workers = 2
[16:59:38.299] MulticoreFuture started
[16:59:38.299] - Launch lazy future ... done
[16:59:38.300] run() for ‘MulticoreFuture’ ... done
[16:59:38.300] Created future:
[16:59:38.301] plan(): Setting new future strategy stack:
[16:59:38.301] List of future strategies:
[16:59:38.301] 1. sequential:
[16:59:38.301]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:38.301]    - tweaked: FALSE
[16:59:38.301]    - call: NULL
[16:59:38.302] plan(): nbrOfWorkers() = 1
[16:59:38.304] plan(): Setting new future strategy stack:
[16:59:38.305] List of future strategies:
[16:59:38.305] 1. multicore:
[16:59:38.305]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:38.305]    - tweaked: FALSE
[16:59:38.305]    - call: plan(strategy)
[16:59:38.310] plan(): nbrOfWorkers() = 2
[16:59:38.300] MulticoreFuture:
[16:59:38.300] Label: ‘future_eapply-2’
[16:59:38.300] Expression:
[16:59:38.300] {
[16:59:38.300]     do.call(function(...) {
[16:59:38.300]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.300]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.300]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.300]             on.exit(options(oopts), add = TRUE)
[16:59:38.300]         }
[16:59:38.300]         {
[16:59:38.300]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.300]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.300]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.300]             })
[16:59:38.300]         }
[16:59:38.300]     }, args = future.call.arguments)
[16:59:38.300] }
[16:59:38.300] Lazy evaluation: FALSE
[16:59:38.300] Asynchronous evaluation: TRUE
[16:59:38.300] Local evaluation: TRUE
[16:59:38.300] Environment: R_GlobalEnv
[16:59:38.300] Capture standard output: TRUE
[16:59:38.300] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:38.300] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:38.300] Packages: 1 packages (‘stats’)
[16:59:38.300] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:38.300] Resolved: TRUE
[16:59:38.300] Value: <not collected>
[16:59:38.300] Conditions captured: <none>
[16:59:38.300] Early signaling: FALSE
[16:59:38.300] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:38.300] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.311] Chunk #2 of 2 ... DONE
[16:59:38.311] Launching 2 futures (chunks) ... DONE
[16:59:38.311] Resolving 2 futures (chunks) ...
[16:59:38.311] resolve() on list ...
[16:59:38.311]  recursive: 0
[16:59:38.311]  length: 2
[16:59:38.312] 
[16:59:38.312] Future #1
[16:59:38.312] result() for MulticoreFuture ...
[16:59:38.313] result() for MulticoreFuture ...
[16:59:38.313] result() for MulticoreFuture ... done
[16:59:38.313] result() for MulticoreFuture ... done
[16:59:38.313] result() for MulticoreFuture ...
[16:59:38.313] result() for MulticoreFuture ... done
[16:59:38.314] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:38.314] - nx: 2
[16:59:38.314] - relay: TRUE
[16:59:38.314] - stdout: TRUE
[16:59:38.314] - signal: TRUE
[16:59:38.314] - resignal: FALSE
[16:59:38.314] - force: TRUE
[16:59:38.315] - relayed: [n=2] FALSE, FALSE
[16:59:38.315] - queued futures: [n=2] FALSE, FALSE
[16:59:38.315]  - until=1
[16:59:38.315]  - relaying element #1
[16:59:38.315] result() for MulticoreFuture ...
[16:59:38.315] result() for MulticoreFuture ... done
[16:59:38.315] result() for MulticoreFuture ...
[16:59:38.316] result() for MulticoreFuture ... done
[16:59:38.316] result() for MulticoreFuture ...
[16:59:38.316] result() for MulticoreFuture ... done
[16:59:38.316] result() for MulticoreFuture ...
[16:59:38.316] result() for MulticoreFuture ... done
[16:59:38.316] - relayed: [n=2] TRUE, FALSE
[16:59:38.316] - queued futures: [n=2] TRUE, FALSE
[16:59:38.317] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:38.317]  length: 1 (resolved future 1)
[16:59:38.317] Future #2
[16:59:38.317] result() for MulticoreFuture ...
[16:59:38.318] result() for MulticoreFuture ...
[16:59:38.318] result() for MulticoreFuture ... done
[16:59:38.318] result() for MulticoreFuture ... done
[16:59:38.318] result() for MulticoreFuture ...
[16:59:38.319] result() for MulticoreFuture ... done
[16:59:38.322] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:38.322] - nx: 2
[16:59:38.322] - relay: TRUE
[16:59:38.322] - stdout: TRUE
[16:59:38.322] - signal: TRUE
[16:59:38.322] - resignal: FALSE
[16:59:38.322] - force: TRUE
[16:59:38.323] - relayed: [n=2] TRUE, FALSE
[16:59:38.323] - queued futures: [n=2] TRUE, FALSE
[16:59:38.323]  - until=2
[16:59:38.323]  - relaying element #2
[16:59:38.323] result() for MulticoreFuture ...
[16:59:38.323] result() for MulticoreFuture ... done
[16:59:38.323] result() for MulticoreFuture ...
[16:59:38.323] result() for MulticoreFuture ... done
[16:59:38.324] result() for MulticoreFuture ...
[16:59:38.324] result() for MulticoreFuture ... done
[16:59:38.324] result() for MulticoreFuture ...
[16:59:38.324] result() for MulticoreFuture ... done
[16:59:38.324] - relayed: [n=2] TRUE, TRUE
[16:59:38.324] - queued futures: [n=2] TRUE, TRUE
[16:59:38.324] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:38.325]  length: 0 (resolved future 2)
[16:59:38.325] Relaying remaining futures
[16:59:38.325] signalConditionsASAP(NULL, pos=0) ...
[16:59:38.325] - nx: 2
[16:59:38.325] - relay: TRUE
[16:59:38.325] - stdout: TRUE
[16:59:38.325] - signal: TRUE
[16:59:38.325] - resignal: FALSE
[16:59:38.325] - force: TRUE
[16:59:38.326] - relayed: [n=2] TRUE, TRUE
[16:59:38.326] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:38.326] - relayed: [n=2] TRUE, TRUE
[16:59:38.326] - queued futures: [n=2] TRUE, TRUE
[16:59:38.326] signalConditionsASAP(NULL, pos=0) ... done
[16:59:38.326] resolve() on list ... DONE
[16:59:38.326] result() for MulticoreFuture ...
[16:59:38.326] result() for MulticoreFuture ... done
[16:59:38.327] result() for MulticoreFuture ...
[16:59:38.327] result() for MulticoreFuture ... done
[16:59:38.327] result() for MulticoreFuture ...
[16:59:38.327] result() for MulticoreFuture ... done
[16:59:38.327] result() for MulticoreFuture ...
[16:59:38.327] result() for MulticoreFuture ... done
[16:59:38.327]  - Number of value chunks collected: 2
[16:59:38.328] Resolving 2 futures (chunks) ... DONE
[16:59:38.328] Reducing values from 2 chunks ...
[16:59:38.328]  - Number of values collected after concatenation: 3
[16:59:38.328]  - Number of values expected: 3
[16:59:38.328] Reducing values from 2 chunks ... DONE
[16:59:38.328] future_lapply() ... DONE
[16:59:38.329] future_lapply() ...
[16:59:38.333] Number of chunks: 2
[16:59:38.333] getGlobalsAndPackagesXApply() ...
[16:59:38.333]  - future.globals: TRUE
[16:59:38.333] getGlobalsAndPackages() ...
[16:59:38.334] Searching for globals...
[16:59:38.335] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:38.335] Searching for globals ... DONE
[16:59:38.335] Resolving globals: FALSE
[16:59:38.335] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:59:38.336] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:59:38.336] - globals: [1] ‘FUN’
[16:59:38.336] - packages: [1] ‘stats’
[16:59:38.336] getGlobalsAndPackages() ... DONE
[16:59:38.336]  - globals found/used: [n=1] ‘FUN’
[16:59:38.337]  - needed namespaces: [n=1] ‘stats’
[16:59:38.337] Finding globals ... DONE
[16:59:38.337]  - use_args: TRUE
[16:59:38.337]  - Getting '...' globals ...
[16:59:38.337] resolve() on list ...
[16:59:38.337]  recursive: 0
[16:59:38.337]  length: 1
[16:59:38.338]  elements: ‘...’
[16:59:38.338]  length: 0 (resolved future 1)
[16:59:38.338] resolve() on list ... DONE
[16:59:38.338]    - '...' content: [n=0] 
[16:59:38.338] List of 1
[16:59:38.338]  $ ...: list()
[16:59:38.338]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.338]  - attr(*, "where")=List of 1
[16:59:38.338]   ..$ ...:<environment: 0x55c3464d0b58> 
[16:59:38.338]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.338]  - attr(*, "resolved")= logi TRUE
[16:59:38.338]  - attr(*, "total_size")= num NA
[16:59:38.341]  - Getting '...' globals ... DONE
[16:59:38.341] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:38.341] List of 2
[16:59:38.341]  $ ...future.FUN:function (x, ...)  
[16:59:38.341]  $ ...          : list()
[16:59:38.341]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.341]  - attr(*, "where")=List of 2
[16:59:38.341]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:38.341]   ..$ ...          :<environment: 0x55c3464d0b58> 
[16:59:38.341]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.341]  - attr(*, "resolved")= logi FALSE
[16:59:38.341]  - attr(*, "total_size")= num 1248
[16:59:38.344] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:38.344] getGlobalsAndPackagesXApply() ... DONE
[16:59:38.345] Number of futures (= number of chunks): 2
[16:59:38.345] Launching 2 futures (chunks) ...
[16:59:38.345] Chunk #1 of 2 ...
[16:59:38.345]  - Finding globals in 'X' for chunk #1 ...
[16:59:38.345] getGlobalsAndPackages() ...
[16:59:38.345] Searching for globals...
[16:59:38.345] 
[16:59:38.345] Searching for globals ... DONE
[16:59:38.346] - globals: [0] <none>
[16:59:38.346] getGlobalsAndPackages() ... DONE
[16:59:38.346]    + additional globals found: [n=0] 
[16:59:38.346]    + additional namespaces needed: [n=0] 
[16:59:38.346]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:38.346]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:38.346]  - seeds: <none>
[16:59:38.346]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.346] getGlobalsAndPackages() ...
[16:59:38.346] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.347] Resolving globals: FALSE
[16:59:38.347] Tweak future expression to call with '...' arguments ...
[16:59:38.347] {
[16:59:38.347]     do.call(function(...) {
[16:59:38.347]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.347]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.347]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.347]             on.exit(options(oopts), add = TRUE)
[16:59:38.347]         }
[16:59:38.347]         {
[16:59:38.347]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.347]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.347]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.347]             })
[16:59:38.347]         }
[16:59:38.347]     }, args = future.call.arguments)
[16:59:38.347] }
[16:59:38.347] Tweak future expression to call with '...' arguments ... DONE
[16:59:38.347] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.348] - packages: [1] ‘stats’
[16:59:38.348] getGlobalsAndPackages() ... DONE
[16:59:38.348] run() for ‘Future’ ...
[16:59:38.348] - state: ‘created’
[16:59:38.348] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:38.353] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.353] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:38.354]   - Field: ‘label’
[16:59:38.354]   - Field: ‘local’
[16:59:38.354]   - Field: ‘owner’
[16:59:38.354]   - Field: ‘envir’
[16:59:38.354]   - Field: ‘workers’
[16:59:38.354]   - Field: ‘packages’
[16:59:38.354]   - Field: ‘gc’
[16:59:38.354]   - Field: ‘job’
[16:59:38.354]   - Field: ‘conditions’
[16:59:38.354]   - Field: ‘expr’
[16:59:38.354]   - Field: ‘uuid’
[16:59:38.355]   - Field: ‘seed’
[16:59:38.355]   - Field: ‘version’
[16:59:38.355]   - Field: ‘result’
[16:59:38.355]   - Field: ‘asynchronous’
[16:59:38.355]   - Field: ‘calls’
[16:59:38.355]   - Field: ‘globals’
[16:59:38.355]   - Field: ‘stdout’
[16:59:38.355]   - Field: ‘earlySignal’
[16:59:38.355]   - Field: ‘lazy’
[16:59:38.355]   - Field: ‘state’
[16:59:38.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:38.356] - Launch lazy future ...
[16:59:38.356] Packages needed by the future expression (n = 1): ‘stats’
[16:59:38.356] Packages needed by future strategies (n = 0): <none>
[16:59:38.357] {
[16:59:38.357]     {
[16:59:38.357]         {
[16:59:38.357]             ...future.startTime <- base::Sys.time()
[16:59:38.357]             {
[16:59:38.357]                 {
[16:59:38.357]                   {
[16:59:38.357]                     {
[16:59:38.357]                       {
[16:59:38.357]                         base::local({
[16:59:38.357]                           has_future <- base::requireNamespace("future", 
[16:59:38.357]                             quietly = TRUE)
[16:59:38.357]                           if (has_future) {
[16:59:38.357]                             ns <- base::getNamespace("future")
[16:59:38.357]                             version <- ns[[".package"]][["version"]]
[16:59:38.357]                             if (is.null(version)) 
[16:59:38.357]                               version <- utils::packageVersion("future")
[16:59:38.357]                           }
[16:59:38.357]                           else {
[16:59:38.357]                             version <- NULL
[16:59:38.357]                           }
[16:59:38.357]                           if (!has_future || version < "1.8.0") {
[16:59:38.357]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:38.357]                               "", base::R.version$version.string), 
[16:59:38.357]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:38.357]                                 base::R.version$platform, 8 * 
[16:59:38.357]                                   base::.Machine$sizeof.pointer), 
[16:59:38.357]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:38.357]                                 "release", "version")], collapse = " "), 
[16:59:38.357]                               hostname = base::Sys.info()[["nodename"]])
[16:59:38.357]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:38.357]                               info)
[16:59:38.357]                             info <- base::paste(info, collapse = "; ")
[16:59:38.357]                             if (!has_future) {
[16:59:38.357]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:38.357]                                 info)
[16:59:38.357]                             }
[16:59:38.357]                             else {
[16:59:38.357]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:38.357]                                 info, version)
[16:59:38.357]                             }
[16:59:38.357]                             base::stop(msg)
[16:59:38.357]                           }
[16:59:38.357]                         })
[16:59:38.357]                       }
[16:59:38.357]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:38.357]                       base::options(mc.cores = 1L)
[16:59:38.357]                     }
[16:59:38.357]                     base::local({
[16:59:38.357]                       for (pkg in "stats") {
[16:59:38.357]                         base::loadNamespace(pkg)
[16:59:38.357]                         base::library(pkg, character.only = TRUE)
[16:59:38.357]                       }
[16:59:38.357]                     })
[16:59:38.357]                   }
[16:59:38.357]                   ...future.strategy.old <- future::plan("list")
[16:59:38.357]                   options(future.plan = NULL)
[16:59:38.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:38.357]                 }
[16:59:38.357]                 ...future.workdir <- getwd()
[16:59:38.357]             }
[16:59:38.357]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:38.357]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:38.357]         }
[16:59:38.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:38.357]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:38.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:38.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:38.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:38.357]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:38.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:38.357]             base::names(...future.oldOptions))
[16:59:38.357]     }
[16:59:38.357]     if (FALSE) {
[16:59:38.357]     }
[16:59:38.357]     else {
[16:59:38.357]         if (TRUE) {
[16:59:38.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:38.357]                 open = "w")
[16:59:38.357]         }
[16:59:38.357]         else {
[16:59:38.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:38.357]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:38.357]         }
[16:59:38.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:38.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:38.357]             base::sink(type = "output", split = FALSE)
[16:59:38.357]             base::close(...future.stdout)
[16:59:38.357]         }, add = TRUE)
[16:59:38.357]     }
[16:59:38.357]     ...future.frame <- base::sys.nframe()
[16:59:38.357]     ...future.conditions <- base::list()
[16:59:38.357]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:38.357]     if (FALSE) {
[16:59:38.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:38.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:38.357]     }
[16:59:38.357]     ...future.result <- base::tryCatch({
[16:59:38.357]         base::withCallingHandlers({
[16:59:38.357]             ...future.value <- base::withVisible(base::local({
[16:59:38.357]                 withCallingHandlers({
[16:59:38.357]                   {
[16:59:38.357]                     do.call(function(...) {
[16:59:38.357]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.357]                       if (!identical(...future.globals.maxSize.org, 
[16:59:38.357]                         ...future.globals.maxSize)) {
[16:59:38.357]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.357]                         on.exit(options(oopts), add = TRUE)
[16:59:38.357]                       }
[16:59:38.357]                       {
[16:59:38.357]                         lapply(seq_along(...future.elements_ii), 
[16:59:38.357]                           FUN = function(jj) {
[16:59:38.357]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.357]                             ...future.FUN(...future.X_jj, ...)
[16:59:38.357]                           })
[16:59:38.357]                       }
[16:59:38.357]                     }, args = future.call.arguments)
[16:59:38.357]                   }
[16:59:38.357]                 }, immediateCondition = function(cond) {
[16:59:38.357]                   save_rds <- function (object, pathname, ...) 
[16:59:38.357]                   {
[16:59:38.357]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:38.357]                     if (file_test("-f", pathname_tmp)) {
[16:59:38.357]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.357]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:38.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.357]                         fi_tmp[["mtime"]])
[16:59:38.357]                     }
[16:59:38.357]                     tryCatch({
[16:59:38.357]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:38.357]                     }, error = function(ex) {
[16:59:38.357]                       msg <- conditionMessage(ex)
[16:59:38.357]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.357]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:38.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.357]                         fi_tmp[["mtime"]], msg)
[16:59:38.357]                       ex$message <- msg
[16:59:38.357]                       stop(ex)
[16:59:38.357]                     })
[16:59:38.357]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:38.357]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:38.357]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:38.357]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.357]                       fi <- file.info(pathname)
[16:59:38.357]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:38.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.357]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:38.357]                         fi[["size"]], fi[["mtime"]])
[16:59:38.357]                       stop(msg)
[16:59:38.357]                     }
[16:59:38.357]                     invisible(pathname)
[16:59:38.357]                   }
[16:59:38.357]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:38.357]                     rootPath = tempdir()) 
[16:59:38.357]                   {
[16:59:38.357]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:38.357]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:38.357]                       tmpdir = path, fileext = ".rds")
[16:59:38.357]                     save_rds(obj, file)
[16:59:38.357]                   }
[16:59:38.357]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0io6nB/.future/immediateConditions")
[16:59:38.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.357]                   {
[16:59:38.357]                     inherits <- base::inherits
[16:59:38.357]                     invokeRestart <- base::invokeRestart
[16:59:38.357]                     is.null <- base::is.null
[16:59:38.357]                     muffled <- FALSE
[16:59:38.357]                     if (inherits(cond, "message")) {
[16:59:38.357]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:38.357]                       if (muffled) 
[16:59:38.357]                         invokeRestart("muffleMessage")
[16:59:38.357]                     }
[16:59:38.357]                     else if (inherits(cond, "warning")) {
[16:59:38.357]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:38.357]                       if (muffled) 
[16:59:38.357]                         invokeRestart("muffleWarning")
[16:59:38.357]                     }
[16:59:38.357]                     else if (inherits(cond, "condition")) {
[16:59:38.357]                       if (!is.null(pattern)) {
[16:59:38.357]                         computeRestarts <- base::computeRestarts
[16:59:38.357]                         grepl <- base::grepl
[16:59:38.357]                         restarts <- computeRestarts(cond)
[16:59:38.357]                         for (restart in restarts) {
[16:59:38.357]                           name <- restart$name
[16:59:38.357]                           if (is.null(name)) 
[16:59:38.357]                             next
[16:59:38.357]                           if (!grepl(pattern, name)) 
[16:59:38.357]                             next
[16:59:38.357]                           invokeRestart(restart)
[16:59:38.357]                           muffled <- TRUE
[16:59:38.357]                           break
[16:59:38.357]                         }
[16:59:38.357]                       }
[16:59:38.357]                     }
[16:59:38.357]                     invisible(muffled)
[16:59:38.357]                   }
[16:59:38.357]                   muffleCondition(cond)
[16:59:38.357]                 })
[16:59:38.357]             }))
[16:59:38.357]             future::FutureResult(value = ...future.value$value, 
[16:59:38.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.357]                   ...future.rng), globalenv = if (FALSE) 
[16:59:38.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:38.357]                     ...future.globalenv.names))
[16:59:38.357]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:38.357]         }, condition = base::local({
[16:59:38.357]             c <- base::c
[16:59:38.357]             inherits <- base::inherits
[16:59:38.357]             invokeRestart <- base::invokeRestart
[16:59:38.357]             length <- base::length
[16:59:38.357]             list <- base::list
[16:59:38.357]             seq.int <- base::seq.int
[16:59:38.357]             signalCondition <- base::signalCondition
[16:59:38.357]             sys.calls <- base::sys.calls
[16:59:38.357]             `[[` <- base::`[[`
[16:59:38.357]             `+` <- base::`+`
[16:59:38.357]             `<<-` <- base::`<<-`
[16:59:38.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:38.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:38.357]                   3L)]
[16:59:38.357]             }
[16:59:38.357]             function(cond) {
[16:59:38.357]                 is_error <- inherits(cond, "error")
[16:59:38.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:38.357]                   NULL)
[16:59:38.357]                 if (is_error) {
[16:59:38.357]                   sessionInformation <- function() {
[16:59:38.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:38.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:38.357]                       search = base::search(), system = base::Sys.info())
[16:59:38.357]                   }
[16:59:38.357]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:38.357]                     cond$call), session = sessionInformation(), 
[16:59:38.357]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:38.357]                   signalCondition(cond)
[16:59:38.357]                 }
[16:59:38.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:38.357]                 "immediateCondition"))) {
[16:59:38.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:38.357]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:38.357]                   if (TRUE && !signal) {
[16:59:38.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.357]                     {
[16:59:38.357]                       inherits <- base::inherits
[16:59:38.357]                       invokeRestart <- base::invokeRestart
[16:59:38.357]                       is.null <- base::is.null
[16:59:38.357]                       muffled <- FALSE
[16:59:38.357]                       if (inherits(cond, "message")) {
[16:59:38.357]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.357]                         if (muffled) 
[16:59:38.357]                           invokeRestart("muffleMessage")
[16:59:38.357]                       }
[16:59:38.357]                       else if (inherits(cond, "warning")) {
[16:59:38.357]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.357]                         if (muffled) 
[16:59:38.357]                           invokeRestart("muffleWarning")
[16:59:38.357]                       }
[16:59:38.357]                       else if (inherits(cond, "condition")) {
[16:59:38.357]                         if (!is.null(pattern)) {
[16:59:38.357]                           computeRestarts <- base::computeRestarts
[16:59:38.357]                           grepl <- base::grepl
[16:59:38.357]                           restarts <- computeRestarts(cond)
[16:59:38.357]                           for (restart in restarts) {
[16:59:38.357]                             name <- restart$name
[16:59:38.357]                             if (is.null(name)) 
[16:59:38.357]                               next
[16:59:38.357]                             if (!grepl(pattern, name)) 
[16:59:38.357]                               next
[16:59:38.357]                             invokeRestart(restart)
[16:59:38.357]                             muffled <- TRUE
[16:59:38.357]                             break
[16:59:38.357]                           }
[16:59:38.357]                         }
[16:59:38.357]                       }
[16:59:38.357]                       invisible(muffled)
[16:59:38.357]                     }
[16:59:38.357]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.357]                   }
[16:59:38.357]                 }
[16:59:38.357]                 else {
[16:59:38.357]                   if (TRUE) {
[16:59:38.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.357]                     {
[16:59:38.357]                       inherits <- base::inherits
[16:59:38.357]                       invokeRestart <- base::invokeRestart
[16:59:38.357]                       is.null <- base::is.null
[16:59:38.357]                       muffled <- FALSE
[16:59:38.357]                       if (inherits(cond, "message")) {
[16:59:38.357]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.357]                         if (muffled) 
[16:59:38.357]                           invokeRestart("muffleMessage")
[16:59:38.357]                       }
[16:59:38.357]                       else if (inherits(cond, "warning")) {
[16:59:38.357]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.357]                         if (muffled) 
[16:59:38.357]                           invokeRestart("muffleWarning")
[16:59:38.357]                       }
[16:59:38.357]                       else if (inherits(cond, "condition")) {
[16:59:38.357]                         if (!is.null(pattern)) {
[16:59:38.357]                           computeRestarts <- base::computeRestarts
[16:59:38.357]                           grepl <- base::grepl
[16:59:38.357]                           restarts <- computeRestarts(cond)
[16:59:38.357]                           for (restart in restarts) {
[16:59:38.357]                             name <- restart$name
[16:59:38.357]                             if (is.null(name)) 
[16:59:38.357]                               next
[16:59:38.357]                             if (!grepl(pattern, name)) 
[16:59:38.357]                               next
[16:59:38.357]                             invokeRestart(restart)
[16:59:38.357]                             muffled <- TRUE
[16:59:38.357]                             break
[16:59:38.357]                           }
[16:59:38.357]                         }
[16:59:38.357]                       }
[16:59:38.357]                       invisible(muffled)
[16:59:38.357]                     }
[16:59:38.357]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.357]                   }
[16:59:38.357]                 }
[16:59:38.357]             }
[16:59:38.357]         }))
[16:59:38.357]     }, error = function(ex) {
[16:59:38.357]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:38.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.357]                 ...future.rng), started = ...future.startTime, 
[16:59:38.357]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:38.357]             version = "1.8"), class = "FutureResult")
[16:59:38.357]     }, finally = {
[16:59:38.357]         if (!identical(...future.workdir, getwd())) 
[16:59:38.357]             setwd(...future.workdir)
[16:59:38.357]         {
[16:59:38.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:38.357]                 ...future.oldOptions$nwarnings <- NULL
[16:59:38.357]             }
[16:59:38.357]             base::options(...future.oldOptions)
[16:59:38.357]             if (.Platform$OS.type == "windows") {
[16:59:38.357]                 old_names <- names(...future.oldEnvVars)
[16:59:38.357]                 envs <- base::Sys.getenv()
[16:59:38.357]                 names <- names(envs)
[16:59:38.357]                 common <- intersect(names, old_names)
[16:59:38.357]                 added <- setdiff(names, old_names)
[16:59:38.357]                 removed <- setdiff(old_names, names)
[16:59:38.357]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:38.357]                   envs[common]]
[16:59:38.357]                 NAMES <- toupper(changed)
[16:59:38.357]                 args <- list()
[16:59:38.357]                 for (kk in seq_along(NAMES)) {
[16:59:38.357]                   name <- changed[[kk]]
[16:59:38.357]                   NAME <- NAMES[[kk]]
[16:59:38.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.357]                     next
[16:59:38.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.357]                 }
[16:59:38.357]                 NAMES <- toupper(added)
[16:59:38.357]                 for (kk in seq_along(NAMES)) {
[16:59:38.357]                   name <- added[[kk]]
[16:59:38.357]                   NAME <- NAMES[[kk]]
[16:59:38.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.357]                     next
[16:59:38.357]                   args[[name]] <- ""
[16:59:38.357]                 }
[16:59:38.357]                 NAMES <- toupper(removed)
[16:59:38.357]                 for (kk in seq_along(NAMES)) {
[16:59:38.357]                   name <- removed[[kk]]
[16:59:38.357]                   NAME <- NAMES[[kk]]
[16:59:38.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.357]                     next
[16:59:38.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.357]                 }
[16:59:38.357]                 if (length(args) > 0) 
[16:59:38.357]                   base::do.call(base::Sys.setenv, args = args)
[16:59:38.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:38.357]             }
[16:59:38.357]             else {
[16:59:38.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:38.357]             }
[16:59:38.357]             {
[16:59:38.357]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:38.357]                   0L) {
[16:59:38.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:38.357]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:38.357]                   base::options(opts)
[16:59:38.357]                 }
[16:59:38.357]                 {
[16:59:38.357]                   {
[16:59:38.357]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:38.357]                     NULL
[16:59:38.357]                   }
[16:59:38.357]                   options(future.plan = NULL)
[16:59:38.357]                   if (is.na(NA_character_)) 
[16:59:38.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:38.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:38.357]                     .init = FALSE)
[16:59:38.357]                 }
[16:59:38.357]             }
[16:59:38.357]         }
[16:59:38.357]     })
[16:59:38.357]     if (TRUE) {
[16:59:38.357]         base::sink(type = "output", split = FALSE)
[16:59:38.357]         if (TRUE) {
[16:59:38.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:38.357]         }
[16:59:38.357]         else {
[16:59:38.357]             ...future.result["stdout"] <- base::list(NULL)
[16:59:38.357]         }
[16:59:38.357]         base::close(...future.stdout)
[16:59:38.357]         ...future.stdout <- NULL
[16:59:38.357]     }
[16:59:38.357]     ...future.result$conditions <- ...future.conditions
[16:59:38.357]     ...future.result$finished <- base::Sys.time()
[16:59:38.357]     ...future.result
[16:59:38.357] }
[16:59:38.359] assign_globals() ...
[16:59:38.359] List of 5
[16:59:38.359]  $ ...future.FUN            :function (x, ...)  
[16:59:38.359]  $ future.call.arguments    : list()
[16:59:38.359]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.359]  $ ...future.elements_ii    :List of 1
[16:59:38.359]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:59:38.359]  $ ...future.seeds_ii       : NULL
[16:59:38.359]  $ ...future.globals.maxSize: NULL
[16:59:38.359]  - attr(*, "where")=List of 5
[16:59:38.359]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:38.359]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:38.359]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:38.359]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:38.359]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:38.359]  - attr(*, "resolved")= logi FALSE
[16:59:38.359]  - attr(*, "total_size")= num 1248
[16:59:38.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.359]  - attr(*, "already-done")= logi TRUE
[16:59:38.363] - copied ‘...future.FUN’ to environment
[16:59:38.364] - copied ‘future.call.arguments’ to environment
[16:59:38.364] - copied ‘...future.elements_ii’ to environment
[16:59:38.364] - copied ‘...future.seeds_ii’ to environment
[16:59:38.364] - copied ‘...future.globals.maxSize’ to environment
[16:59:38.364] assign_globals() ... done
[16:59:38.364] requestCore(): workers = 2
[16:59:38.366] MulticoreFuture started
[16:59:38.366] - Launch lazy future ... done
[16:59:38.367] run() for ‘MulticoreFuture’ ... done
[16:59:38.367] Created future:
[16:59:38.368] plan(): Setting new future strategy stack:
[16:59:38.368] List of future strategies:
[16:59:38.368] 1. sequential:
[16:59:38.368]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:38.368]    - tweaked: FALSE
[16:59:38.368]    - call: NULL
[16:59:38.369] plan(): nbrOfWorkers() = 1
[16:59:38.371] plan(): Setting new future strategy stack:
[16:59:38.371] List of future strategies:
[16:59:38.371] 1. multicore:
[16:59:38.371]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:38.371]    - tweaked: FALSE
[16:59:38.371]    - call: plan(strategy)
[16:59:38.376] plan(): nbrOfWorkers() = 2
[16:59:38.367] MulticoreFuture:
[16:59:38.367] Label: ‘future_eapply-1’
[16:59:38.367] Expression:
[16:59:38.367] {
[16:59:38.367]     do.call(function(...) {
[16:59:38.367]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.367]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.367]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.367]             on.exit(options(oopts), add = TRUE)
[16:59:38.367]         }
[16:59:38.367]         {
[16:59:38.367]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.367]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.367]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.367]             })
[16:59:38.367]         }
[16:59:38.367]     }, args = future.call.arguments)
[16:59:38.367] }
[16:59:38.367] Lazy evaluation: FALSE
[16:59:38.367] Asynchronous evaluation: TRUE
[16:59:38.367] Local evaluation: TRUE
[16:59:38.367] Environment: R_GlobalEnv
[16:59:38.367] Capture standard output: TRUE
[16:59:38.367] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:38.367] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:38.367] Packages: 1 packages (‘stats’)
[16:59:38.367] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:38.367] Resolved: TRUE
[16:59:38.367] Value: <not collected>
[16:59:38.367] Conditions captured: <none>
[16:59:38.367] Early signaling: FALSE
[16:59:38.367] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:38.367] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.377] Chunk #1 of 2 ... DONE
[16:59:38.377] Chunk #2 of 2 ...
[16:59:38.378]  - Finding globals in 'X' for chunk #2 ...
[16:59:38.378] getGlobalsAndPackages() ...
[16:59:38.378] Searching for globals...
[16:59:38.378] 
[16:59:38.378] Searching for globals ... DONE
[16:59:38.379] - globals: [0] <none>
[16:59:38.379] getGlobalsAndPackages() ... DONE
[16:59:38.379]    + additional globals found: [n=0] 
[16:59:38.379]    + additional namespaces needed: [n=0] 
[16:59:38.379]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:38.379]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:38.379]  - seeds: <none>
[16:59:38.379]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.380] getGlobalsAndPackages() ...
[16:59:38.380] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.380] Resolving globals: FALSE
[16:59:38.380] Tweak future expression to call with '...' arguments ...
[16:59:38.380] {
[16:59:38.380]     do.call(function(...) {
[16:59:38.380]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.380]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.380]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.380]             on.exit(options(oopts), add = TRUE)
[16:59:38.380]         }
[16:59:38.380]         {
[16:59:38.380]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.380]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.380]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.380]             })
[16:59:38.380]         }
[16:59:38.380]     }, args = future.call.arguments)
[16:59:38.380] }
[16:59:38.381] Tweak future expression to call with '...' arguments ... DONE
[16:59:38.381] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:38.381] - packages: [1] ‘stats’
[16:59:38.382] getGlobalsAndPackages() ... DONE
[16:59:38.382] run() for ‘Future’ ...
[16:59:38.382] - state: ‘created’
[16:59:38.382] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:38.387] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.387] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:38.387]   - Field: ‘label’
[16:59:38.387]   - Field: ‘local’
[16:59:38.388]   - Field: ‘owner’
[16:59:38.388]   - Field: ‘envir’
[16:59:38.388]   - Field: ‘workers’
[16:59:38.388]   - Field: ‘packages’
[16:59:38.388]   - Field: ‘gc’
[16:59:38.388]   - Field: ‘job’
[16:59:38.388]   - Field: ‘conditions’
[16:59:38.389]   - Field: ‘expr’
[16:59:38.389]   - Field: ‘uuid’
[16:59:38.389]   - Field: ‘seed’
[16:59:38.389]   - Field: ‘version’
[16:59:38.389]   - Field: ‘result’
[16:59:38.389]   - Field: ‘asynchronous’
[16:59:38.389]   - Field: ‘calls’
[16:59:38.389]   - Field: ‘globals’
[16:59:38.390]   - Field: ‘stdout’
[16:59:38.390]   - Field: ‘earlySignal’
[16:59:38.390]   - Field: ‘lazy’
[16:59:38.390]   - Field: ‘state’
[16:59:38.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:38.390] - Launch lazy future ...
[16:59:38.391] Packages needed by the future expression (n = 1): ‘stats’
[16:59:38.391] Packages needed by future strategies (n = 0): <none>
[16:59:38.392] {
[16:59:38.392]     {
[16:59:38.392]         {
[16:59:38.392]             ...future.startTime <- base::Sys.time()
[16:59:38.392]             {
[16:59:38.392]                 {
[16:59:38.392]                   {
[16:59:38.392]                     {
[16:59:38.392]                       {
[16:59:38.392]                         base::local({
[16:59:38.392]                           has_future <- base::requireNamespace("future", 
[16:59:38.392]                             quietly = TRUE)
[16:59:38.392]                           if (has_future) {
[16:59:38.392]                             ns <- base::getNamespace("future")
[16:59:38.392]                             version <- ns[[".package"]][["version"]]
[16:59:38.392]                             if (is.null(version)) 
[16:59:38.392]                               version <- utils::packageVersion("future")
[16:59:38.392]                           }
[16:59:38.392]                           else {
[16:59:38.392]                             version <- NULL
[16:59:38.392]                           }
[16:59:38.392]                           if (!has_future || version < "1.8.0") {
[16:59:38.392]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:38.392]                               "", base::R.version$version.string), 
[16:59:38.392]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:38.392]                                 base::R.version$platform, 8 * 
[16:59:38.392]                                   base::.Machine$sizeof.pointer), 
[16:59:38.392]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:38.392]                                 "release", "version")], collapse = " "), 
[16:59:38.392]                               hostname = base::Sys.info()[["nodename"]])
[16:59:38.392]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:38.392]                               info)
[16:59:38.392]                             info <- base::paste(info, collapse = "; ")
[16:59:38.392]                             if (!has_future) {
[16:59:38.392]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:38.392]                                 info)
[16:59:38.392]                             }
[16:59:38.392]                             else {
[16:59:38.392]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:38.392]                                 info, version)
[16:59:38.392]                             }
[16:59:38.392]                             base::stop(msg)
[16:59:38.392]                           }
[16:59:38.392]                         })
[16:59:38.392]                       }
[16:59:38.392]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:38.392]                       base::options(mc.cores = 1L)
[16:59:38.392]                     }
[16:59:38.392]                     base::local({
[16:59:38.392]                       for (pkg in "stats") {
[16:59:38.392]                         base::loadNamespace(pkg)
[16:59:38.392]                         base::library(pkg, character.only = TRUE)
[16:59:38.392]                       }
[16:59:38.392]                     })
[16:59:38.392]                   }
[16:59:38.392]                   ...future.strategy.old <- future::plan("list")
[16:59:38.392]                   options(future.plan = NULL)
[16:59:38.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:38.392]                 }
[16:59:38.392]                 ...future.workdir <- getwd()
[16:59:38.392]             }
[16:59:38.392]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:38.392]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:38.392]         }
[16:59:38.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:38.392]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:38.392]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:38.392]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:38.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:38.392]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:38.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:38.392]             base::names(...future.oldOptions))
[16:59:38.392]     }
[16:59:38.392]     if (FALSE) {
[16:59:38.392]     }
[16:59:38.392]     else {
[16:59:38.392]         if (TRUE) {
[16:59:38.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:38.392]                 open = "w")
[16:59:38.392]         }
[16:59:38.392]         else {
[16:59:38.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:38.392]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:38.392]         }
[16:59:38.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:38.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:38.392]             base::sink(type = "output", split = FALSE)
[16:59:38.392]             base::close(...future.stdout)
[16:59:38.392]         }, add = TRUE)
[16:59:38.392]     }
[16:59:38.392]     ...future.frame <- base::sys.nframe()
[16:59:38.392]     ...future.conditions <- base::list()
[16:59:38.392]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:38.392]     if (FALSE) {
[16:59:38.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:38.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:38.392]     }
[16:59:38.392]     ...future.result <- base::tryCatch({
[16:59:38.392]         base::withCallingHandlers({
[16:59:38.392]             ...future.value <- base::withVisible(base::local({
[16:59:38.392]                 withCallingHandlers({
[16:59:38.392]                   {
[16:59:38.392]                     do.call(function(...) {
[16:59:38.392]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.392]                       if (!identical(...future.globals.maxSize.org, 
[16:59:38.392]                         ...future.globals.maxSize)) {
[16:59:38.392]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.392]                         on.exit(options(oopts), add = TRUE)
[16:59:38.392]                       }
[16:59:38.392]                       {
[16:59:38.392]                         lapply(seq_along(...future.elements_ii), 
[16:59:38.392]                           FUN = function(jj) {
[16:59:38.392]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.392]                             ...future.FUN(...future.X_jj, ...)
[16:59:38.392]                           })
[16:59:38.392]                       }
[16:59:38.392]                     }, args = future.call.arguments)
[16:59:38.392]                   }
[16:59:38.392]                 }, immediateCondition = function(cond) {
[16:59:38.392]                   save_rds <- function (object, pathname, ...) 
[16:59:38.392]                   {
[16:59:38.392]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:38.392]                     if (file_test("-f", pathname_tmp)) {
[16:59:38.392]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.392]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:38.392]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.392]                         fi_tmp[["mtime"]])
[16:59:38.392]                     }
[16:59:38.392]                     tryCatch({
[16:59:38.392]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:38.392]                     }, error = function(ex) {
[16:59:38.392]                       msg <- conditionMessage(ex)
[16:59:38.392]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.392]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:38.392]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.392]                         fi_tmp[["mtime"]], msg)
[16:59:38.392]                       ex$message <- msg
[16:59:38.392]                       stop(ex)
[16:59:38.392]                     })
[16:59:38.392]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:38.392]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:38.392]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:38.392]                       fi_tmp <- file.info(pathname_tmp)
[16:59:38.392]                       fi <- file.info(pathname)
[16:59:38.392]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:38.392]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:38.392]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:38.392]                         fi[["size"]], fi[["mtime"]])
[16:59:38.392]                       stop(msg)
[16:59:38.392]                     }
[16:59:38.392]                     invisible(pathname)
[16:59:38.392]                   }
[16:59:38.392]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:38.392]                     rootPath = tempdir()) 
[16:59:38.392]                   {
[16:59:38.392]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:38.392]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:38.392]                       tmpdir = path, fileext = ".rds")
[16:59:38.392]                     save_rds(obj, file)
[16:59:38.392]                   }
[16:59:38.392]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0io6nB/.future/immediateConditions")
[16:59:38.392]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.392]                   {
[16:59:38.392]                     inherits <- base::inherits
[16:59:38.392]                     invokeRestart <- base::invokeRestart
[16:59:38.392]                     is.null <- base::is.null
[16:59:38.392]                     muffled <- FALSE
[16:59:38.392]                     if (inherits(cond, "message")) {
[16:59:38.392]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:38.392]                       if (muffled) 
[16:59:38.392]                         invokeRestart("muffleMessage")
[16:59:38.392]                     }
[16:59:38.392]                     else if (inherits(cond, "warning")) {
[16:59:38.392]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:38.392]                       if (muffled) 
[16:59:38.392]                         invokeRestart("muffleWarning")
[16:59:38.392]                     }
[16:59:38.392]                     else if (inherits(cond, "condition")) {
[16:59:38.392]                       if (!is.null(pattern)) {
[16:59:38.392]                         computeRestarts <- base::computeRestarts
[16:59:38.392]                         grepl <- base::grepl
[16:59:38.392]                         restarts <- computeRestarts(cond)
[16:59:38.392]                         for (restart in restarts) {
[16:59:38.392]                           name <- restart$name
[16:59:38.392]                           if (is.null(name)) 
[16:59:38.392]                             next
[16:59:38.392]                           if (!grepl(pattern, name)) 
[16:59:38.392]                             next
[16:59:38.392]                           invokeRestart(restart)
[16:59:38.392]                           muffled <- TRUE
[16:59:38.392]                           break
[16:59:38.392]                         }
[16:59:38.392]                       }
[16:59:38.392]                     }
[16:59:38.392]                     invisible(muffled)
[16:59:38.392]                   }
[16:59:38.392]                   muffleCondition(cond)
[16:59:38.392]                 })
[16:59:38.392]             }))
[16:59:38.392]             future::FutureResult(value = ...future.value$value, 
[16:59:38.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.392]                   ...future.rng), globalenv = if (FALSE) 
[16:59:38.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:38.392]                     ...future.globalenv.names))
[16:59:38.392]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:38.392]         }, condition = base::local({
[16:59:38.392]             c <- base::c
[16:59:38.392]             inherits <- base::inherits
[16:59:38.392]             invokeRestart <- base::invokeRestart
[16:59:38.392]             length <- base::length
[16:59:38.392]             list <- base::list
[16:59:38.392]             seq.int <- base::seq.int
[16:59:38.392]             signalCondition <- base::signalCondition
[16:59:38.392]             sys.calls <- base::sys.calls
[16:59:38.392]             `[[` <- base::`[[`
[16:59:38.392]             `+` <- base::`+`
[16:59:38.392]             `<<-` <- base::`<<-`
[16:59:38.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:38.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:38.392]                   3L)]
[16:59:38.392]             }
[16:59:38.392]             function(cond) {
[16:59:38.392]                 is_error <- inherits(cond, "error")
[16:59:38.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:38.392]                   NULL)
[16:59:38.392]                 if (is_error) {
[16:59:38.392]                   sessionInformation <- function() {
[16:59:38.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:38.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:38.392]                       search = base::search(), system = base::Sys.info())
[16:59:38.392]                   }
[16:59:38.392]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:38.392]                     cond$call), session = sessionInformation(), 
[16:59:38.392]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:38.392]                   signalCondition(cond)
[16:59:38.392]                 }
[16:59:38.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:38.392]                 "immediateCondition"))) {
[16:59:38.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:38.392]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:38.392]                   if (TRUE && !signal) {
[16:59:38.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.392]                     {
[16:59:38.392]                       inherits <- base::inherits
[16:59:38.392]                       invokeRestart <- base::invokeRestart
[16:59:38.392]                       is.null <- base::is.null
[16:59:38.392]                       muffled <- FALSE
[16:59:38.392]                       if (inherits(cond, "message")) {
[16:59:38.392]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.392]                         if (muffled) 
[16:59:38.392]                           invokeRestart("muffleMessage")
[16:59:38.392]                       }
[16:59:38.392]                       else if (inherits(cond, "warning")) {
[16:59:38.392]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.392]                         if (muffled) 
[16:59:38.392]                           invokeRestart("muffleWarning")
[16:59:38.392]                       }
[16:59:38.392]                       else if (inherits(cond, "condition")) {
[16:59:38.392]                         if (!is.null(pattern)) {
[16:59:38.392]                           computeRestarts <- base::computeRestarts
[16:59:38.392]                           grepl <- base::grepl
[16:59:38.392]                           restarts <- computeRestarts(cond)
[16:59:38.392]                           for (restart in restarts) {
[16:59:38.392]                             name <- restart$name
[16:59:38.392]                             if (is.null(name)) 
[16:59:38.392]                               next
[16:59:38.392]                             if (!grepl(pattern, name)) 
[16:59:38.392]                               next
[16:59:38.392]                             invokeRestart(restart)
[16:59:38.392]                             muffled <- TRUE
[16:59:38.392]                             break
[16:59:38.392]                           }
[16:59:38.392]                         }
[16:59:38.392]                       }
[16:59:38.392]                       invisible(muffled)
[16:59:38.392]                     }
[16:59:38.392]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.392]                   }
[16:59:38.392]                 }
[16:59:38.392]                 else {
[16:59:38.392]                   if (TRUE) {
[16:59:38.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.392]                     {
[16:59:38.392]                       inherits <- base::inherits
[16:59:38.392]                       invokeRestart <- base::invokeRestart
[16:59:38.392]                       is.null <- base::is.null
[16:59:38.392]                       muffled <- FALSE
[16:59:38.392]                       if (inherits(cond, "message")) {
[16:59:38.392]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.392]                         if (muffled) 
[16:59:38.392]                           invokeRestart("muffleMessage")
[16:59:38.392]                       }
[16:59:38.392]                       else if (inherits(cond, "warning")) {
[16:59:38.392]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.392]                         if (muffled) 
[16:59:38.392]                           invokeRestart("muffleWarning")
[16:59:38.392]                       }
[16:59:38.392]                       else if (inherits(cond, "condition")) {
[16:59:38.392]                         if (!is.null(pattern)) {
[16:59:38.392]                           computeRestarts <- base::computeRestarts
[16:59:38.392]                           grepl <- base::grepl
[16:59:38.392]                           restarts <- computeRestarts(cond)
[16:59:38.392]                           for (restart in restarts) {
[16:59:38.392]                             name <- restart$name
[16:59:38.392]                             if (is.null(name)) 
[16:59:38.392]                               next
[16:59:38.392]                             if (!grepl(pattern, name)) 
[16:59:38.392]                               next
[16:59:38.392]                             invokeRestart(restart)
[16:59:38.392]                             muffled <- TRUE
[16:59:38.392]                             break
[16:59:38.392]                           }
[16:59:38.392]                         }
[16:59:38.392]                       }
[16:59:38.392]                       invisible(muffled)
[16:59:38.392]                     }
[16:59:38.392]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.392]                   }
[16:59:38.392]                 }
[16:59:38.392]             }
[16:59:38.392]         }))
[16:59:38.392]     }, error = function(ex) {
[16:59:38.392]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:38.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.392]                 ...future.rng), started = ...future.startTime, 
[16:59:38.392]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:38.392]             version = "1.8"), class = "FutureResult")
[16:59:38.392]     }, finally = {
[16:59:38.392]         if (!identical(...future.workdir, getwd())) 
[16:59:38.392]             setwd(...future.workdir)
[16:59:38.392]         {
[16:59:38.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:38.392]                 ...future.oldOptions$nwarnings <- NULL
[16:59:38.392]             }
[16:59:38.392]             base::options(...future.oldOptions)
[16:59:38.392]             if (.Platform$OS.type == "windows") {
[16:59:38.392]                 old_names <- names(...future.oldEnvVars)
[16:59:38.392]                 envs <- base::Sys.getenv()
[16:59:38.392]                 names <- names(envs)
[16:59:38.392]                 common <- intersect(names, old_names)
[16:59:38.392]                 added <- setdiff(names, old_names)
[16:59:38.392]                 removed <- setdiff(old_names, names)
[16:59:38.392]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:38.392]                   envs[common]]
[16:59:38.392]                 NAMES <- toupper(changed)
[16:59:38.392]                 args <- list()
[16:59:38.392]                 for (kk in seq_along(NAMES)) {
[16:59:38.392]                   name <- changed[[kk]]
[16:59:38.392]                   NAME <- NAMES[[kk]]
[16:59:38.392]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.392]                     next
[16:59:38.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.392]                 }
[16:59:38.392]                 NAMES <- toupper(added)
[16:59:38.392]                 for (kk in seq_along(NAMES)) {
[16:59:38.392]                   name <- added[[kk]]
[16:59:38.392]                   NAME <- NAMES[[kk]]
[16:59:38.392]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.392]                     next
[16:59:38.392]                   args[[name]] <- ""
[16:59:38.392]                 }
[16:59:38.392]                 NAMES <- toupper(removed)
[16:59:38.392]                 for (kk in seq_along(NAMES)) {
[16:59:38.392]                   name <- removed[[kk]]
[16:59:38.392]                   NAME <- NAMES[[kk]]
[16:59:38.392]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.392]                     next
[16:59:38.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.392]                 }
[16:59:38.392]                 if (length(args) > 0) 
[16:59:38.392]                   base::do.call(base::Sys.setenv, args = args)
[16:59:38.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:38.392]             }
[16:59:38.392]             else {
[16:59:38.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:38.392]             }
[16:59:38.392]             {
[16:59:38.392]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:38.392]                   0L) {
[16:59:38.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:38.392]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:38.392]                   base::options(opts)
[16:59:38.392]                 }
[16:59:38.392]                 {
[16:59:38.392]                   {
[16:59:38.392]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:38.392]                     NULL
[16:59:38.392]                   }
[16:59:38.392]                   options(future.plan = NULL)
[16:59:38.392]                   if (is.na(NA_character_)) 
[16:59:38.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:38.392]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:38.392]                     .init = FALSE)
[16:59:38.392]                 }
[16:59:38.392]             }
[16:59:38.392]         }
[16:59:38.392]     })
[16:59:38.392]     if (TRUE) {
[16:59:38.392]         base::sink(type = "output", split = FALSE)
[16:59:38.392]         if (TRUE) {
[16:59:38.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:38.392]         }
[16:59:38.392]         else {
[16:59:38.392]             ...future.result["stdout"] <- base::list(NULL)
[16:59:38.392]         }
[16:59:38.392]         base::close(...future.stdout)
[16:59:38.392]         ...future.stdout <- NULL
[16:59:38.392]     }
[16:59:38.392]     ...future.result$conditions <- ...future.conditions
[16:59:38.392]     ...future.result$finished <- base::Sys.time()
[16:59:38.392]     ...future.result
[16:59:38.392] }
[16:59:38.395] assign_globals() ...
[16:59:38.395] List of 5
[16:59:38.395]  $ ...future.FUN            :function (x, ...)  
[16:59:38.395]  $ future.call.arguments    : list()
[16:59:38.395]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:38.395]  $ ...future.elements_ii    :List of 2
[16:59:38.395]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:59:38.395]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:59:38.395]  $ ...future.seeds_ii       : NULL
[16:59:38.395]  $ ...future.globals.maxSize: NULL
[16:59:38.395]  - attr(*, "where")=List of 5
[16:59:38.395]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:38.395]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:38.395]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:38.395]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:38.395]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:38.395]  - attr(*, "resolved")= logi FALSE
[16:59:38.395]  - attr(*, "total_size")= num 1248
[16:59:38.395]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:38.395]  - attr(*, "already-done")= logi TRUE
[16:59:38.406] - copied ‘...future.FUN’ to environment
[16:59:38.406] - copied ‘future.call.arguments’ to environment
[16:59:38.406] - copied ‘...future.elements_ii’ to environment
[16:59:38.406] - copied ‘...future.seeds_ii’ to environment
[16:59:38.407] - copied ‘...future.globals.maxSize’ to environment
[16:59:38.407] assign_globals() ... done
[16:59:38.407] requestCore(): workers = 2
[16:59:38.409] MulticoreFuture started
[16:59:38.410] - Launch lazy future ... done
[16:59:38.410] run() for ‘MulticoreFuture’ ... done
[16:59:38.410] Created future:
[16:59:38.411] plan(): Setting new future strategy stack:
[16:59:38.411] List of future strategies:
[16:59:38.411] 1. sequential:
[16:59:38.411]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:38.411]    - tweaked: FALSE
[16:59:38.411]    - call: NULL
[16:59:38.412] plan(): nbrOfWorkers() = 1
[16:59:38.415] plan(): Setting new future strategy stack:
[16:59:38.415] List of future strategies:
[16:59:38.415] 1. multicore:
[16:59:38.415]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:38.415]    - tweaked: FALSE
[16:59:38.415]    - call: plan(strategy)
[16:59:38.420] plan(): nbrOfWorkers() = 2
[16:59:38.410] MulticoreFuture:
[16:59:38.410] Label: ‘future_eapply-2’
[16:59:38.410] Expression:
[16:59:38.410] {
[16:59:38.410]     do.call(function(...) {
[16:59:38.410]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:38.410]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:38.410]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:38.410]             on.exit(options(oopts), add = TRUE)
[16:59:38.410]         }
[16:59:38.410]         {
[16:59:38.410]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:38.410]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:38.410]                 ...future.FUN(...future.X_jj, ...)
[16:59:38.410]             })
[16:59:38.410]         }
[16:59:38.410]     }, args = future.call.arguments)
[16:59:38.410] }
[16:59:38.410] Lazy evaluation: FALSE
[16:59:38.410] Asynchronous evaluation: TRUE
[16:59:38.410] Local evaluation: TRUE
[16:59:38.410] Environment: R_GlobalEnv
[16:59:38.410] Capture standard output: TRUE
[16:59:38.410] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:38.410] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:38.410] Packages: 1 packages (‘stats’)
[16:59:38.410] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:38.410] Resolved: TRUE
[16:59:38.410] Value: <not collected>
[16:59:38.410] Conditions captured: <none>
[16:59:38.410] Early signaling: FALSE
[16:59:38.410] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:38.410] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:38.421] Chunk #2 of 2 ... DONE
[16:59:38.421] Launching 2 futures (chunks) ... DONE
[16:59:38.421] Resolving 2 futures (chunks) ...
[16:59:38.421] resolve() on list ...
[16:59:38.422]  recursive: 0
[16:59:38.422]  length: 2
[16:59:38.422] 
[16:59:38.422] Future #1
[16:59:38.422] result() for MulticoreFuture ...
[16:59:38.423] result() for MulticoreFuture ...
[16:59:38.423] result() for MulticoreFuture ... done
[16:59:38.424] result() for MulticoreFuture ... done
[16:59:38.424] result() for MulticoreFuture ...
[16:59:38.424] result() for MulticoreFuture ... done
[16:59:38.424] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:38.424] - nx: 2
[16:59:38.425] - relay: TRUE
[16:59:38.425] - stdout: TRUE
[16:59:38.425] - signal: TRUE
[16:59:38.425] - resignal: FALSE
[16:59:38.425] - force: TRUE
[16:59:38.425] - relayed: [n=2] FALSE, FALSE
[16:59:38.426] - queued futures: [n=2] FALSE, FALSE
[16:59:38.426]  - until=1
[16:59:38.426]  - relaying element #1
[16:59:38.426] result() for MulticoreFuture ...
[16:59:38.426] result() for MulticoreFuture ... done
[16:59:38.427] result() for MulticoreFuture ...
[16:59:38.427] result() for MulticoreFuture ... done
[16:59:38.427] result() for MulticoreFuture ...
[16:59:38.427] result() for MulticoreFuture ... done
[16:59:38.427] result() for MulticoreFuture ...
[16:59:38.428] result() for MulticoreFuture ... done
[16:59:38.428] - relayed: [n=2] TRUE, FALSE
[16:59:38.428] - queued futures: [n=2] TRUE, FALSE
[16:59:38.428] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:38.428]  length: 1 (resolved future 1)
[16:59:38.429] Future #2
[16:59:38.429] result() for MulticoreFuture ...
[16:59:38.429] result() for MulticoreFuture ...
[16:59:38.430] result() for MulticoreFuture ... done
[16:59:38.430] result() for MulticoreFuture ... done
[16:59:38.430] result() for MulticoreFuture ...
[16:59:38.430] result() for MulticoreFuture ... done
[16:59:38.430] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:38.431] - nx: 2
[16:59:38.431] - relay: TRUE
[16:59:38.431] - stdout: TRUE
[16:59:38.431] - signal: TRUE
[16:59:38.431] - resignal: FALSE
[16:59:38.431] - force: TRUE
[16:59:38.432] - relayed: [n=2] TRUE, FALSE
[16:59:38.432] - queued futures: [n=2] TRUE, FALSE
[16:59:38.432]  - until=2
[16:59:38.432]  - relaying element #2
[16:59:38.432] result() for MulticoreFuture ...
[16:59:38.432] result() for MulticoreFuture ... done
[16:59:38.432] result() for MulticoreFuture ...
[16:59:38.433] result() for MulticoreFuture ... done
[16:59:38.433] result() for MulticoreFuture ...
[16:59:38.433] result() for MulticoreFuture ... done
[16:59:38.433] result() for MulticoreFuture ...
[16:59:38.433] result() for MulticoreFuture ... done
[16:59:38.433] - relayed: [n=2] TRUE, TRUE
[16:59:38.433] - queued futures: [n=2] TRUE, TRUE
[16:59:38.433] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:38.433]  length: 0 (resolved future 2)
[16:59:38.434] Relaying remaining futures
[16:59:38.434] signalConditionsASAP(NULL, pos=0) ...
[16:59:38.434] - nx: 2
[16:59:38.434] - relay: TRUE
[16:59:38.434] - stdout: TRUE
[16:59:38.434] - signal: TRUE
[16:59:38.434] - resignal: FALSE
[16:59:38.434] - force: TRUE
[16:59:38.434] - relayed: [n=2] TRUE, TRUE
[16:59:38.434] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:38.435] - relayed: [n=2] TRUE, TRUE
[16:59:38.435] - queued futures: [n=2] TRUE, TRUE
[16:59:38.435] signalConditionsASAP(NULL, pos=0) ... done
[16:59:38.435] resolve() on list ... DONE
[16:59:38.435] result() for MulticoreFuture ...
[16:59:38.435] result() for MulticoreFuture ... done
[16:59:38.435] result() for MulticoreFuture ...
[16:59:38.435] result() for MulticoreFuture ... done
[16:59:38.436] result() for MulticoreFuture ...
[16:59:38.436] result() for MulticoreFuture ... done
[16:59:38.436] result() for MulticoreFuture ...
[16:59:38.436] result() for MulticoreFuture ... done
[16:59:38.436]  - Number of value chunks collected: 2
[16:59:38.436] Resolving 2 futures (chunks) ... DONE
[16:59:38.436] Reducing values from 2 chunks ...
[16:59:38.436]  - Number of values collected after concatenation: 3
[16:59:38.436]  - Number of values expected: 3
[16:59:38.436] Reducing values from 2 chunks ... DONE
[16:59:38.437] future_lapply() ... DONE
[16:59:38.437] plan(): Setting new future strategy stack:
[16:59:38.437] List of future strategies:
[16:59:38.437] 1. sequential:
[16:59:38.437]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:38.437]    - tweaked: FALSE
[16:59:38.437]    - call: plan(sequential)
[16:59:38.438] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[16:59:38.438] plan(): Setting new future strategy stack:
[16:59:38.438] List of future strategies:
[16:59:38.438] 1. multisession:
[16:59:38.438]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:38.438]    - tweaked: FALSE
[16:59:38.438]    - call: plan(strategy)
[16:59:38.439] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:59:38.439] multisession:
[16:59:38.439] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:38.439] - tweaked: FALSE
[16:59:38.439] - call: plan(strategy)
[16:59:38.445] getGlobalsAndPackages() ...
[16:59:38.445] Not searching for globals
[16:59:38.445] - globals: [0] <none>
[16:59:38.445] getGlobalsAndPackages() ... DONE
[16:59:38.446] [local output] makeClusterPSOCK() ...
[16:59:38.489] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:59:38.490] [local output] Base port: 11085
[16:59:38.491] [local output] Getting setup options for 2 cluster nodes ...
[16:59:38.491] [local output]  - Node 1 of 2 ...
[16:59:38.491] [local output] localMachine=TRUE => revtunnel=FALSE

[16:59:38.492] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0io6nB/worker.rank=1.parallelly.parent=29079.7197799a3683.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp0io6nB/worker.rank=1.parallelly.parent=29079.7197799a3683.pid")'’
[16:59:38.680] - Possible to infer worker's PID: TRUE
[16:59:38.680] [local output] Rscript port: 11085

[16:59:38.681] [local output]  - Node 2 of 2 ...
[16:59:38.681] [local output] localMachine=TRUE => revtunnel=FALSE

[16:59:38.682] [local output] Rscript port: 11085

[16:59:38.682] [local output] Getting setup options for 2 cluster nodes ... done
[16:59:38.682] [local output]  - Parallel setup requested for some PSOCK nodes
[16:59:38.683] [local output] Setting up PSOCK nodes in parallel
[16:59:38.683] List of 36
[16:59:38.683]  $ worker          : chr "localhost"
[16:59:38.683]   ..- attr(*, "localhost")= logi TRUE
[16:59:38.683]  $ master          : chr "localhost"
[16:59:38.683]  $ port            : int 11085
[16:59:38.683]  $ connectTimeout  : num 120
[16:59:38.683]  $ timeout         : num 2592000
[16:59:38.683]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:59:38.683]  $ homogeneous     : logi TRUE
[16:59:38.683]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:59:38.683]  $ rscript_envs    : NULL
[16:59:38.683]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:59:38.683]  $ rscript_startup : NULL
[16:59:38.683]  $ rscript_sh      : chr "sh"
[16:59:38.683]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:59:38.683]  $ methods         : logi TRUE
[16:59:38.683]  $ socketOptions   : chr "no-delay"
[16:59:38.683]  $ useXDR          : logi FALSE
[16:59:38.683]  $ outfile         : chr "/dev/null"
[16:59:38.683]  $ renice          : int NA
[16:59:38.683]  $ rshcmd          : NULL
[16:59:38.683]  $ user            : chr(0) 
[16:59:38.683]  $ revtunnel       : logi FALSE
[16:59:38.683]  $ rshlogfile      : NULL
[16:59:38.683]  $ rshopts         : chr(0) 
[16:59:38.683]  $ rank            : int 1
[16:59:38.683]  $ manual          : logi FALSE
[16:59:38.683]  $ dryrun          : logi FALSE
[16:59:38.683]  $ quiet           : logi FALSE
[16:59:38.683]  $ setup_strategy  : chr "parallel"
[16:59:38.683]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:59:38.683]  $ pidfile         : chr "/tmp/Rtmp0io6nB/worker.rank=1.parallelly.parent=29079.7197799a3683.pid"
[16:59:38.683]  $ rshcmd_label    : NULL
[16:59:38.683]  $ rsh_call        : NULL
[16:59:38.683]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:59:38.683]  $ localMachine    : logi TRUE
[16:59:38.683]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:59:38.683]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:59:38.683]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:59:38.683]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:59:38.683]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:59:38.683]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:59:38.683]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:59:38.683]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:59:38.683]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:59:38.683]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:59:38.683]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:59:38.683]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:59:38.683]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:59:38.683]  $ arguments       :List of 28
[16:59:38.683]   ..$ worker          : chr "localhost"
[16:59:38.683]   ..$ master          : NULL
[16:59:38.683]   ..$ port            : int 11085
[16:59:38.683]   ..$ connectTimeout  : num 120
[16:59:38.683]   ..$ timeout         : num 2592000
[16:59:38.683]   ..$ rscript         : NULL
[16:59:38.683]   ..$ homogeneous     : NULL
[16:59:38.683]   ..$ rscript_args    : NULL
[16:59:38.683]   ..$ rscript_envs    : NULL
[16:59:38.683]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:59:38.683]   ..$ rscript_startup : NULL
[16:59:38.683]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:59:38.683]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:59:38.683]   ..$ methods         : logi TRUE
[16:59:38.683]   ..$ socketOptions   : chr "no-delay"
[16:59:38.683]   ..$ useXDR          : logi FALSE
[16:59:38.683]   ..$ outfile         : chr "/dev/null"
[16:59:38.683]   ..$ renice          : int NA
[16:59:38.683]   ..$ rshcmd          : NULL
[16:59:38.683]   ..$ user            : NULL
[16:59:38.683]   ..$ revtunnel       : logi NA
[16:59:38.683]   ..$ rshlogfile      : NULL
[16:59:38.683]   ..$ rshopts         : NULL
[16:59:38.683]   ..$ rank            : int 1
[16:59:38.683]   ..$ manual          : logi FALSE
[16:59:38.683]   ..$ dryrun          : logi FALSE
[16:59:38.683]   ..$ quiet           : logi FALSE
[16:59:38.683]   ..$ setup_strategy  : chr "parallel"
[16:59:38.683]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:59:38.699] [local output] System call to launch all workers:
[16:59:38.700] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0io6nB/worker.rank=1.parallelly.parent=29079.7197799a3683.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11085 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:59:38.700] [local output] Starting PSOCK main server
[16:59:38.705] [local output] Workers launched
[16:59:38.705] [local output] Waiting for workers to connect back
[16:59:38.706]  - [local output] 0 workers out of 2 ready
[16:59:38.941]  - [local output] 0 workers out of 2 ready
[16:59:38.941]  - [local output] 1 workers out of 2 ready
[16:59:38.946]  - [local output] 1 workers out of 2 ready
[16:59:38.946]  - [local output] 2 workers out of 2 ready
[16:59:38.946] [local output] Launching of workers completed
[16:59:38.946] [local output] Collecting session information from workers
[16:59:38.947] [local output]  - Worker #1 of 2
[16:59:38.948] [local output]  - Worker #2 of 2
[16:59:38.948] [local output] makeClusterPSOCK() ... done
[16:59:38.959] Packages needed by the future expression (n = 0): <none>
[16:59:38.960] Packages needed by future strategies (n = 0): <none>
[16:59:38.960] {
[16:59:38.960]     {
[16:59:38.960]         {
[16:59:38.960]             ...future.startTime <- base::Sys.time()
[16:59:38.960]             {
[16:59:38.960]                 {
[16:59:38.960]                   {
[16:59:38.960]                     {
[16:59:38.960]                       base::local({
[16:59:38.960]                         has_future <- base::requireNamespace("future", 
[16:59:38.960]                           quietly = TRUE)
[16:59:38.960]                         if (has_future) {
[16:59:38.960]                           ns <- base::getNamespace("future")
[16:59:38.960]                           version <- ns[[".package"]][["version"]]
[16:59:38.960]                           if (is.null(version)) 
[16:59:38.960]                             version <- utils::packageVersion("future")
[16:59:38.960]                         }
[16:59:38.960]                         else {
[16:59:38.960]                           version <- NULL
[16:59:38.960]                         }
[16:59:38.960]                         if (!has_future || version < "1.8.0") {
[16:59:38.960]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:38.960]                             "", base::R.version$version.string), 
[16:59:38.960]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:38.960]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:38.960]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:38.960]                               "release", "version")], collapse = " "), 
[16:59:38.960]                             hostname = base::Sys.info()[["nodename"]])
[16:59:38.960]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:38.960]                             info)
[16:59:38.960]                           info <- base::paste(info, collapse = "; ")
[16:59:38.960]                           if (!has_future) {
[16:59:38.960]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:38.960]                               info)
[16:59:38.960]                           }
[16:59:38.960]                           else {
[16:59:38.960]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:38.960]                               info, version)
[16:59:38.960]                           }
[16:59:38.960]                           base::stop(msg)
[16:59:38.960]                         }
[16:59:38.960]                       })
[16:59:38.960]                     }
[16:59:38.960]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:38.960]                     base::options(mc.cores = 1L)
[16:59:38.960]                   }
[16:59:38.960]                   ...future.strategy.old <- future::plan("list")
[16:59:38.960]                   options(future.plan = NULL)
[16:59:38.960]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.960]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:38.960]                 }
[16:59:38.960]                 ...future.workdir <- getwd()
[16:59:38.960]             }
[16:59:38.960]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:38.960]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:38.960]         }
[16:59:38.960]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:38.960]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:38.960]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:38.960]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:38.960]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:38.960]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:38.960]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:38.960]             base::names(...future.oldOptions))
[16:59:38.960]     }
[16:59:38.960]     if (FALSE) {
[16:59:38.960]     }
[16:59:38.960]     else {
[16:59:38.960]         if (TRUE) {
[16:59:38.960]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:38.960]                 open = "w")
[16:59:38.960]         }
[16:59:38.960]         else {
[16:59:38.960]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:38.960]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:38.960]         }
[16:59:38.960]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:38.960]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:38.960]             base::sink(type = "output", split = FALSE)
[16:59:38.960]             base::close(...future.stdout)
[16:59:38.960]         }, add = TRUE)
[16:59:38.960]     }
[16:59:38.960]     ...future.frame <- base::sys.nframe()
[16:59:38.960]     ...future.conditions <- base::list()
[16:59:38.960]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:38.960]     if (FALSE) {
[16:59:38.960]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:38.960]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:38.960]     }
[16:59:38.960]     ...future.result <- base::tryCatch({
[16:59:38.960]         base::withCallingHandlers({
[16:59:38.960]             ...future.value <- base::withVisible(base::local({
[16:59:38.960]                 ...future.makeSendCondition <- base::local({
[16:59:38.960]                   sendCondition <- NULL
[16:59:38.960]                   function(frame = 1L) {
[16:59:38.960]                     if (is.function(sendCondition)) 
[16:59:38.960]                       return(sendCondition)
[16:59:38.960]                     ns <- getNamespace("parallel")
[16:59:38.960]                     if (exists("sendData", mode = "function", 
[16:59:38.960]                       envir = ns)) {
[16:59:38.960]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:38.960]                         envir = ns)
[16:59:38.960]                       envir <- sys.frame(frame)
[16:59:38.960]                       master <- NULL
[16:59:38.960]                       while (!identical(envir, .GlobalEnv) && 
[16:59:38.960]                         !identical(envir, emptyenv())) {
[16:59:38.960]                         if (exists("master", mode = "list", envir = envir, 
[16:59:38.960]                           inherits = FALSE)) {
[16:59:38.960]                           master <- get("master", mode = "list", 
[16:59:38.960]                             envir = envir, inherits = FALSE)
[16:59:38.960]                           if (inherits(master, c("SOCKnode", 
[16:59:38.960]                             "SOCK0node"))) {
[16:59:38.960]                             sendCondition <<- function(cond) {
[16:59:38.960]                               data <- list(type = "VALUE", value = cond, 
[16:59:38.960]                                 success = TRUE)
[16:59:38.960]                               parallel_sendData(master, data)
[16:59:38.960]                             }
[16:59:38.960]                             return(sendCondition)
[16:59:38.960]                           }
[16:59:38.960]                         }
[16:59:38.960]                         frame <- frame + 1L
[16:59:38.960]                         envir <- sys.frame(frame)
[16:59:38.960]                       }
[16:59:38.960]                     }
[16:59:38.960]                     sendCondition <<- function(cond) NULL
[16:59:38.960]                   }
[16:59:38.960]                 })
[16:59:38.960]                 withCallingHandlers({
[16:59:38.960]                   NA
[16:59:38.960]                 }, immediateCondition = function(cond) {
[16:59:38.960]                   sendCondition <- ...future.makeSendCondition()
[16:59:38.960]                   sendCondition(cond)
[16:59:38.960]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.960]                   {
[16:59:38.960]                     inherits <- base::inherits
[16:59:38.960]                     invokeRestart <- base::invokeRestart
[16:59:38.960]                     is.null <- base::is.null
[16:59:38.960]                     muffled <- FALSE
[16:59:38.960]                     if (inherits(cond, "message")) {
[16:59:38.960]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:38.960]                       if (muffled) 
[16:59:38.960]                         invokeRestart("muffleMessage")
[16:59:38.960]                     }
[16:59:38.960]                     else if (inherits(cond, "warning")) {
[16:59:38.960]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:38.960]                       if (muffled) 
[16:59:38.960]                         invokeRestart("muffleWarning")
[16:59:38.960]                     }
[16:59:38.960]                     else if (inherits(cond, "condition")) {
[16:59:38.960]                       if (!is.null(pattern)) {
[16:59:38.960]                         computeRestarts <- base::computeRestarts
[16:59:38.960]                         grepl <- base::grepl
[16:59:38.960]                         restarts <- computeRestarts(cond)
[16:59:38.960]                         for (restart in restarts) {
[16:59:38.960]                           name <- restart$name
[16:59:38.960]                           if (is.null(name)) 
[16:59:38.960]                             next
[16:59:38.960]                           if (!grepl(pattern, name)) 
[16:59:38.960]                             next
[16:59:38.960]                           invokeRestart(restart)
[16:59:38.960]                           muffled <- TRUE
[16:59:38.960]                           break
[16:59:38.960]                         }
[16:59:38.960]                       }
[16:59:38.960]                     }
[16:59:38.960]                     invisible(muffled)
[16:59:38.960]                   }
[16:59:38.960]                   muffleCondition(cond)
[16:59:38.960]                 })
[16:59:38.960]             }))
[16:59:38.960]             future::FutureResult(value = ...future.value$value, 
[16:59:38.960]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.960]                   ...future.rng), globalenv = if (FALSE) 
[16:59:38.960]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:38.960]                     ...future.globalenv.names))
[16:59:38.960]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:38.960]         }, condition = base::local({
[16:59:38.960]             c <- base::c
[16:59:38.960]             inherits <- base::inherits
[16:59:38.960]             invokeRestart <- base::invokeRestart
[16:59:38.960]             length <- base::length
[16:59:38.960]             list <- base::list
[16:59:38.960]             seq.int <- base::seq.int
[16:59:38.960]             signalCondition <- base::signalCondition
[16:59:38.960]             sys.calls <- base::sys.calls
[16:59:38.960]             `[[` <- base::`[[`
[16:59:38.960]             `+` <- base::`+`
[16:59:38.960]             `<<-` <- base::`<<-`
[16:59:38.960]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:38.960]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:38.960]                   3L)]
[16:59:38.960]             }
[16:59:38.960]             function(cond) {
[16:59:38.960]                 is_error <- inherits(cond, "error")
[16:59:38.960]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:38.960]                   NULL)
[16:59:38.960]                 if (is_error) {
[16:59:38.960]                   sessionInformation <- function() {
[16:59:38.960]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:38.960]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:38.960]                       search = base::search(), system = base::Sys.info())
[16:59:38.960]                   }
[16:59:38.960]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.960]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:38.960]                     cond$call), session = sessionInformation(), 
[16:59:38.960]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:38.960]                   signalCondition(cond)
[16:59:38.960]                 }
[16:59:38.960]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:38.960]                 "immediateCondition"))) {
[16:59:38.960]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:38.960]                   ...future.conditions[[length(...future.conditions) + 
[16:59:38.960]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:38.960]                   if (TRUE && !signal) {
[16:59:38.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.960]                     {
[16:59:38.960]                       inherits <- base::inherits
[16:59:38.960]                       invokeRestart <- base::invokeRestart
[16:59:38.960]                       is.null <- base::is.null
[16:59:38.960]                       muffled <- FALSE
[16:59:38.960]                       if (inherits(cond, "message")) {
[16:59:38.960]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.960]                         if (muffled) 
[16:59:38.960]                           invokeRestart("muffleMessage")
[16:59:38.960]                       }
[16:59:38.960]                       else if (inherits(cond, "warning")) {
[16:59:38.960]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.960]                         if (muffled) 
[16:59:38.960]                           invokeRestart("muffleWarning")
[16:59:38.960]                       }
[16:59:38.960]                       else if (inherits(cond, "condition")) {
[16:59:38.960]                         if (!is.null(pattern)) {
[16:59:38.960]                           computeRestarts <- base::computeRestarts
[16:59:38.960]                           grepl <- base::grepl
[16:59:38.960]                           restarts <- computeRestarts(cond)
[16:59:38.960]                           for (restart in restarts) {
[16:59:38.960]                             name <- restart$name
[16:59:38.960]                             if (is.null(name)) 
[16:59:38.960]                               next
[16:59:38.960]                             if (!grepl(pattern, name)) 
[16:59:38.960]                               next
[16:59:38.960]                             invokeRestart(restart)
[16:59:38.960]                             muffled <- TRUE
[16:59:38.960]                             break
[16:59:38.960]                           }
[16:59:38.960]                         }
[16:59:38.960]                       }
[16:59:38.960]                       invisible(muffled)
[16:59:38.960]                     }
[16:59:38.960]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.960]                   }
[16:59:38.960]                 }
[16:59:38.960]                 else {
[16:59:38.960]                   if (TRUE) {
[16:59:38.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:38.960]                     {
[16:59:38.960]                       inherits <- base::inherits
[16:59:38.960]                       invokeRestart <- base::invokeRestart
[16:59:38.960]                       is.null <- base::is.null
[16:59:38.960]                       muffled <- FALSE
[16:59:38.960]                       if (inherits(cond, "message")) {
[16:59:38.960]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:38.960]                         if (muffled) 
[16:59:38.960]                           invokeRestart("muffleMessage")
[16:59:38.960]                       }
[16:59:38.960]                       else if (inherits(cond, "warning")) {
[16:59:38.960]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:38.960]                         if (muffled) 
[16:59:38.960]                           invokeRestart("muffleWarning")
[16:59:38.960]                       }
[16:59:38.960]                       else if (inherits(cond, "condition")) {
[16:59:38.960]                         if (!is.null(pattern)) {
[16:59:38.960]                           computeRestarts <- base::computeRestarts
[16:59:38.960]                           grepl <- base::grepl
[16:59:38.960]                           restarts <- computeRestarts(cond)
[16:59:38.960]                           for (restart in restarts) {
[16:59:38.960]                             name <- restart$name
[16:59:38.960]                             if (is.null(name)) 
[16:59:38.960]                               next
[16:59:38.960]                             if (!grepl(pattern, name)) 
[16:59:38.960]                               next
[16:59:38.960]                             invokeRestart(restart)
[16:59:38.960]                             muffled <- TRUE
[16:59:38.960]                             break
[16:59:38.960]                           }
[16:59:38.960]                         }
[16:59:38.960]                       }
[16:59:38.960]                       invisible(muffled)
[16:59:38.960]                     }
[16:59:38.960]                     muffleCondition(cond, pattern = "^muffle")
[16:59:38.960]                   }
[16:59:38.960]                 }
[16:59:38.960]             }
[16:59:38.960]         }))
[16:59:38.960]     }, error = function(ex) {
[16:59:38.960]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:38.960]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:38.960]                 ...future.rng), started = ...future.startTime, 
[16:59:38.960]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:38.960]             version = "1.8"), class = "FutureResult")
[16:59:38.960]     }, finally = {
[16:59:38.960]         if (!identical(...future.workdir, getwd())) 
[16:59:38.960]             setwd(...future.workdir)
[16:59:38.960]         {
[16:59:38.960]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:38.960]                 ...future.oldOptions$nwarnings <- NULL
[16:59:38.960]             }
[16:59:38.960]             base::options(...future.oldOptions)
[16:59:38.960]             if (.Platform$OS.type == "windows") {
[16:59:38.960]                 old_names <- names(...future.oldEnvVars)
[16:59:38.960]                 envs <- base::Sys.getenv()
[16:59:38.960]                 names <- names(envs)
[16:59:38.960]                 common <- intersect(names, old_names)
[16:59:38.960]                 added <- setdiff(names, old_names)
[16:59:38.960]                 removed <- setdiff(old_names, names)
[16:59:38.960]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:38.960]                   envs[common]]
[16:59:38.960]                 NAMES <- toupper(changed)
[16:59:38.960]                 args <- list()
[16:59:38.960]                 for (kk in seq_along(NAMES)) {
[16:59:38.960]                   name <- changed[[kk]]
[16:59:38.960]                   NAME <- NAMES[[kk]]
[16:59:38.960]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.960]                     next
[16:59:38.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.960]                 }
[16:59:38.960]                 NAMES <- toupper(added)
[16:59:38.960]                 for (kk in seq_along(NAMES)) {
[16:59:38.960]                   name <- added[[kk]]
[16:59:38.960]                   NAME <- NAMES[[kk]]
[16:59:38.960]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.960]                     next
[16:59:38.960]                   args[[name]] <- ""
[16:59:38.960]                 }
[16:59:38.960]                 NAMES <- toupper(removed)
[16:59:38.960]                 for (kk in seq_along(NAMES)) {
[16:59:38.960]                   name <- removed[[kk]]
[16:59:38.960]                   NAME <- NAMES[[kk]]
[16:59:38.960]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:38.960]                     next
[16:59:38.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:38.960]                 }
[16:59:38.960]                 if (length(args) > 0) 
[16:59:38.960]                   base::do.call(base::Sys.setenv, args = args)
[16:59:38.960]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:38.960]             }
[16:59:38.960]             else {
[16:59:38.960]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:38.960]             }
[16:59:38.960]             {
[16:59:38.960]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:38.960]                   0L) {
[16:59:38.960]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:38.960]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:38.960]                   base::options(opts)
[16:59:38.960]                 }
[16:59:38.960]                 {
[16:59:38.960]                   {
[16:59:38.960]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:38.960]                     NULL
[16:59:38.960]                   }
[16:59:38.960]                   options(future.plan = NULL)
[16:59:38.960]                   if (is.na(NA_character_)) 
[16:59:38.960]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:38.960]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:38.960]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:38.960]                     .init = FALSE)
[16:59:38.960]                 }
[16:59:38.960]             }
[16:59:38.960]         }
[16:59:38.960]     })
[16:59:38.960]     if (TRUE) {
[16:59:38.960]         base::sink(type = "output", split = FALSE)
[16:59:38.960]         if (TRUE) {
[16:59:38.960]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:38.960]         }
[16:59:38.960]         else {
[16:59:38.960]             ...future.result["stdout"] <- base::list(NULL)
[16:59:38.960]         }
[16:59:38.960]         base::close(...future.stdout)
[16:59:38.960]         ...future.stdout <- NULL
[16:59:38.960]     }
[16:59:38.960]     ...future.result$conditions <- ...future.conditions
[16:59:38.960]     ...future.result$finished <- base::Sys.time()
[16:59:38.960]     ...future.result
[16:59:38.960] }
[16:59:39.012] MultisessionFuture started
[16:59:39.012] result() for ClusterFuture ...
[16:59:39.013] receiveMessageFromWorker() for ClusterFuture ...
[16:59:39.013] - Validating connection of MultisessionFuture
[16:59:39.044] - received message: FutureResult
[16:59:39.044] - Received FutureResult
[16:59:39.044] - Erased future from FutureRegistry
[16:59:39.044] result() for ClusterFuture ...
[16:59:39.044] - result already collected: FutureResult
[16:59:39.045] result() for ClusterFuture ... done
[16:59:39.045] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:39.045] result() for ClusterFuture ... done
[16:59:39.045] result() for ClusterFuture ...
[16:59:39.045] - result already collected: FutureResult
[16:59:39.045] result() for ClusterFuture ... done
[16:59:39.045] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:59:39.049] plan(): nbrOfWorkers() = 2
[16:59:39.050] future_lapply() ...
[16:59:39.054] Number of chunks: 2
[16:59:39.054] getGlobalsAndPackagesXApply() ...
[16:59:39.054]  - future.globals: TRUE
[16:59:39.054] getGlobalsAndPackages() ...
[16:59:39.054] Searching for globals...
[16:59:39.056] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:39.056] Searching for globals ... DONE
[16:59:39.056] Resolving globals: FALSE
[16:59:39.056] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:39.057] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:39.057] - globals: [1] ‘FUN’
[16:59:39.057] 
[16:59:39.057] getGlobalsAndPackages() ... DONE
[16:59:39.057]  - globals found/used: [n=1] ‘FUN’
[16:59:39.057]  - needed namespaces: [n=0] 
[16:59:39.057] Finding globals ... DONE
[16:59:39.057]  - use_args: TRUE
[16:59:39.058]  - Getting '...' globals ...
[16:59:39.058] resolve() on list ...
[16:59:39.058]  recursive: 0
[16:59:39.058]  length: 1
[16:59:39.058]  elements: ‘...’
[16:59:39.059]  length: 0 (resolved future 1)
[16:59:39.059] resolve() on list ... DONE
[16:59:39.059]    - '...' content: [n=0] 
[16:59:39.059] List of 1
[16:59:39.059]  $ ...: list()
[16:59:39.059]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:39.059]  - attr(*, "where")=List of 1
[16:59:39.059]   ..$ ...:<environment: 0x55c349baa8c0> 
[16:59:39.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:39.059]  - attr(*, "resolved")= logi TRUE
[16:59:39.059]  - attr(*, "total_size")= num NA
[16:59:39.062]  - Getting '...' globals ... DONE
[16:59:39.062] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:39.062] List of 2
[16:59:39.062]  $ ...future.FUN:function (x, ...)  
[16:59:39.062]  $ ...          : list()
[16:59:39.062]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:39.062]  - attr(*, "where")=List of 2
[16:59:39.062]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:39.062]   ..$ ...          :<environment: 0x55c349baa8c0> 
[16:59:39.062]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:39.062]  - attr(*, "resolved")= logi FALSE
[16:59:39.062]  - attr(*, "total_size")= num 1240
[16:59:39.066] Packages to be attached in all futures: [n=0] 
[16:59:39.066] getGlobalsAndPackagesXApply() ... DONE
[16:59:39.066] Number of futures (= number of chunks): 2
[16:59:39.066] Launching 2 futures (chunks) ...
[16:59:39.066] Chunk #1 of 2 ...
[16:59:39.066]  - Finding globals in 'X' for chunk #1 ...
[16:59:39.067] getGlobalsAndPackages() ...
[16:59:39.067] Searching for globals...
[16:59:39.067] 
[16:59:39.067] Searching for globals ... DONE
[16:59:39.067] - globals: [0] <none>
[16:59:39.067] getGlobalsAndPackages() ... DONE
[16:59:39.067]    + additional globals found: [n=0] 
[16:59:39.068]    + additional namespaces needed: [n=0] 
[16:59:39.068]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:39.068]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:39.068]  - seeds: <none>
[16:59:39.068]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.068] getGlobalsAndPackages() ...
[16:59:39.068] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.068] Resolving globals: FALSE
[16:59:39.069] Tweak future expression to call with '...' arguments ...
[16:59:39.069] {
[16:59:39.069]     do.call(function(...) {
[16:59:39.069]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.069]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.069]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.069]             on.exit(options(oopts), add = TRUE)
[16:59:39.069]         }
[16:59:39.069]         {
[16:59:39.069]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.069]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.069]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.069]             })
[16:59:39.069]         }
[16:59:39.069]     }, args = future.call.arguments)
[16:59:39.069] }
[16:59:39.069] Tweak future expression to call with '...' arguments ... DONE
[16:59:39.069] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.070] 
[16:59:39.070] getGlobalsAndPackages() ... DONE
[16:59:39.070] run() for ‘Future’ ...
[16:59:39.070] - state: ‘created’
[16:59:39.070] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:39.084] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:39.085]   - Field: ‘node’
[16:59:39.085]   - Field: ‘label’
[16:59:39.085]   - Field: ‘local’
[16:59:39.085]   - Field: ‘owner’
[16:59:39.085]   - Field: ‘envir’
[16:59:39.085]   - Field: ‘workers’
[16:59:39.085]   - Field: ‘packages’
[16:59:39.085]   - Field: ‘gc’
[16:59:39.085]   - Field: ‘conditions’
[16:59:39.086]   - Field: ‘persistent’
[16:59:39.086]   - Field: ‘expr’
[16:59:39.086]   - Field: ‘uuid’
[16:59:39.086]   - Field: ‘seed’
[16:59:39.086]   - Field: ‘version’
[16:59:39.086]   - Field: ‘result’
[16:59:39.086]   - Field: ‘asynchronous’
[16:59:39.086]   - Field: ‘calls’
[16:59:39.086]   - Field: ‘globals’
[16:59:39.087]   - Field: ‘stdout’
[16:59:39.087]   - Field: ‘earlySignal’
[16:59:39.087]   - Field: ‘lazy’
[16:59:39.087]   - Field: ‘state’
[16:59:39.087] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:39.087] - Launch lazy future ...
[16:59:39.088] Packages needed by the future expression (n = 0): <none>
[16:59:39.088] Packages needed by future strategies (n = 0): <none>
[16:59:39.088] {
[16:59:39.088]     {
[16:59:39.088]         {
[16:59:39.088]             ...future.startTime <- base::Sys.time()
[16:59:39.088]             {
[16:59:39.088]                 {
[16:59:39.088]                   {
[16:59:39.088]                     {
[16:59:39.088]                       base::local({
[16:59:39.088]                         has_future <- base::requireNamespace("future", 
[16:59:39.088]                           quietly = TRUE)
[16:59:39.088]                         if (has_future) {
[16:59:39.088]                           ns <- base::getNamespace("future")
[16:59:39.088]                           version <- ns[[".package"]][["version"]]
[16:59:39.088]                           if (is.null(version)) 
[16:59:39.088]                             version <- utils::packageVersion("future")
[16:59:39.088]                         }
[16:59:39.088]                         else {
[16:59:39.088]                           version <- NULL
[16:59:39.088]                         }
[16:59:39.088]                         if (!has_future || version < "1.8.0") {
[16:59:39.088]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:39.088]                             "", base::R.version$version.string), 
[16:59:39.088]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:39.088]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:39.088]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:39.088]                               "release", "version")], collapse = " "), 
[16:59:39.088]                             hostname = base::Sys.info()[["nodename"]])
[16:59:39.088]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:39.088]                             info)
[16:59:39.088]                           info <- base::paste(info, collapse = "; ")
[16:59:39.088]                           if (!has_future) {
[16:59:39.088]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:39.088]                               info)
[16:59:39.088]                           }
[16:59:39.088]                           else {
[16:59:39.088]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:39.088]                               info, version)
[16:59:39.088]                           }
[16:59:39.088]                           base::stop(msg)
[16:59:39.088]                         }
[16:59:39.088]                       })
[16:59:39.088]                     }
[16:59:39.088]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:39.088]                     base::options(mc.cores = 1L)
[16:59:39.088]                   }
[16:59:39.088]                   ...future.strategy.old <- future::plan("list")
[16:59:39.088]                   options(future.plan = NULL)
[16:59:39.088]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.088]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:39.088]                 }
[16:59:39.088]                 ...future.workdir <- getwd()
[16:59:39.088]             }
[16:59:39.088]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:39.088]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:39.088]         }
[16:59:39.088]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:39.088]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:39.088]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:39.088]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:39.088]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:39.088]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:39.088]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:39.088]             base::names(...future.oldOptions))
[16:59:39.088]     }
[16:59:39.088]     if (FALSE) {
[16:59:39.088]     }
[16:59:39.088]     else {
[16:59:39.088]         if (TRUE) {
[16:59:39.088]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:39.088]                 open = "w")
[16:59:39.088]         }
[16:59:39.088]         else {
[16:59:39.088]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:39.088]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:39.088]         }
[16:59:39.088]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:39.088]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:39.088]             base::sink(type = "output", split = FALSE)
[16:59:39.088]             base::close(...future.stdout)
[16:59:39.088]         }, add = TRUE)
[16:59:39.088]     }
[16:59:39.088]     ...future.frame <- base::sys.nframe()
[16:59:39.088]     ...future.conditions <- base::list()
[16:59:39.088]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:39.088]     if (FALSE) {
[16:59:39.088]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:39.088]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:39.088]     }
[16:59:39.088]     ...future.result <- base::tryCatch({
[16:59:39.088]         base::withCallingHandlers({
[16:59:39.088]             ...future.value <- base::withVisible(base::local({
[16:59:39.088]                 ...future.makeSendCondition <- base::local({
[16:59:39.088]                   sendCondition <- NULL
[16:59:39.088]                   function(frame = 1L) {
[16:59:39.088]                     if (is.function(sendCondition)) 
[16:59:39.088]                       return(sendCondition)
[16:59:39.088]                     ns <- getNamespace("parallel")
[16:59:39.088]                     if (exists("sendData", mode = "function", 
[16:59:39.088]                       envir = ns)) {
[16:59:39.088]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:39.088]                         envir = ns)
[16:59:39.088]                       envir <- sys.frame(frame)
[16:59:39.088]                       master <- NULL
[16:59:39.088]                       while (!identical(envir, .GlobalEnv) && 
[16:59:39.088]                         !identical(envir, emptyenv())) {
[16:59:39.088]                         if (exists("master", mode = "list", envir = envir, 
[16:59:39.088]                           inherits = FALSE)) {
[16:59:39.088]                           master <- get("master", mode = "list", 
[16:59:39.088]                             envir = envir, inherits = FALSE)
[16:59:39.088]                           if (inherits(master, c("SOCKnode", 
[16:59:39.088]                             "SOCK0node"))) {
[16:59:39.088]                             sendCondition <<- function(cond) {
[16:59:39.088]                               data <- list(type = "VALUE", value = cond, 
[16:59:39.088]                                 success = TRUE)
[16:59:39.088]                               parallel_sendData(master, data)
[16:59:39.088]                             }
[16:59:39.088]                             return(sendCondition)
[16:59:39.088]                           }
[16:59:39.088]                         }
[16:59:39.088]                         frame <- frame + 1L
[16:59:39.088]                         envir <- sys.frame(frame)
[16:59:39.088]                       }
[16:59:39.088]                     }
[16:59:39.088]                     sendCondition <<- function(cond) NULL
[16:59:39.088]                   }
[16:59:39.088]                 })
[16:59:39.088]                 withCallingHandlers({
[16:59:39.088]                   {
[16:59:39.088]                     do.call(function(...) {
[16:59:39.088]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.088]                       if (!identical(...future.globals.maxSize.org, 
[16:59:39.088]                         ...future.globals.maxSize)) {
[16:59:39.088]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.088]                         on.exit(options(oopts), add = TRUE)
[16:59:39.088]                       }
[16:59:39.088]                       {
[16:59:39.088]                         lapply(seq_along(...future.elements_ii), 
[16:59:39.088]                           FUN = function(jj) {
[16:59:39.088]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.088]                             ...future.FUN(...future.X_jj, ...)
[16:59:39.088]                           })
[16:59:39.088]                       }
[16:59:39.088]                     }, args = future.call.arguments)
[16:59:39.088]                   }
[16:59:39.088]                 }, immediateCondition = function(cond) {
[16:59:39.088]                   sendCondition <- ...future.makeSendCondition()
[16:59:39.088]                   sendCondition(cond)
[16:59:39.088]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.088]                   {
[16:59:39.088]                     inherits <- base::inherits
[16:59:39.088]                     invokeRestart <- base::invokeRestart
[16:59:39.088]                     is.null <- base::is.null
[16:59:39.088]                     muffled <- FALSE
[16:59:39.088]                     if (inherits(cond, "message")) {
[16:59:39.088]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:39.088]                       if (muffled) 
[16:59:39.088]                         invokeRestart("muffleMessage")
[16:59:39.088]                     }
[16:59:39.088]                     else if (inherits(cond, "warning")) {
[16:59:39.088]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:39.088]                       if (muffled) 
[16:59:39.088]                         invokeRestart("muffleWarning")
[16:59:39.088]                     }
[16:59:39.088]                     else if (inherits(cond, "condition")) {
[16:59:39.088]                       if (!is.null(pattern)) {
[16:59:39.088]                         computeRestarts <- base::computeRestarts
[16:59:39.088]                         grepl <- base::grepl
[16:59:39.088]                         restarts <- computeRestarts(cond)
[16:59:39.088]                         for (restart in restarts) {
[16:59:39.088]                           name <- restart$name
[16:59:39.088]                           if (is.null(name)) 
[16:59:39.088]                             next
[16:59:39.088]                           if (!grepl(pattern, name)) 
[16:59:39.088]                             next
[16:59:39.088]                           invokeRestart(restart)
[16:59:39.088]                           muffled <- TRUE
[16:59:39.088]                           break
[16:59:39.088]                         }
[16:59:39.088]                       }
[16:59:39.088]                     }
[16:59:39.088]                     invisible(muffled)
[16:59:39.088]                   }
[16:59:39.088]                   muffleCondition(cond)
[16:59:39.088]                 })
[16:59:39.088]             }))
[16:59:39.088]             future::FutureResult(value = ...future.value$value, 
[16:59:39.088]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.088]                   ...future.rng), globalenv = if (FALSE) 
[16:59:39.088]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:39.088]                     ...future.globalenv.names))
[16:59:39.088]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:39.088]         }, condition = base::local({
[16:59:39.088]             c <- base::c
[16:59:39.088]             inherits <- base::inherits
[16:59:39.088]             invokeRestart <- base::invokeRestart
[16:59:39.088]             length <- base::length
[16:59:39.088]             list <- base::list
[16:59:39.088]             seq.int <- base::seq.int
[16:59:39.088]             signalCondition <- base::signalCondition
[16:59:39.088]             sys.calls <- base::sys.calls
[16:59:39.088]             `[[` <- base::`[[`
[16:59:39.088]             `+` <- base::`+`
[16:59:39.088]             `<<-` <- base::`<<-`
[16:59:39.088]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:39.088]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:39.088]                   3L)]
[16:59:39.088]             }
[16:59:39.088]             function(cond) {
[16:59:39.088]                 is_error <- inherits(cond, "error")
[16:59:39.088]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:39.088]                   NULL)
[16:59:39.088]                 if (is_error) {
[16:59:39.088]                   sessionInformation <- function() {
[16:59:39.088]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:39.088]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:39.088]                       search = base::search(), system = base::Sys.info())
[16:59:39.088]                   }
[16:59:39.088]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.088]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:39.088]                     cond$call), session = sessionInformation(), 
[16:59:39.088]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:39.088]                   signalCondition(cond)
[16:59:39.088]                 }
[16:59:39.088]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:39.088]                 "immediateCondition"))) {
[16:59:39.088]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:39.088]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.088]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:39.088]                   if (TRUE && !signal) {
[16:59:39.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.088]                     {
[16:59:39.088]                       inherits <- base::inherits
[16:59:39.088]                       invokeRestart <- base::invokeRestart
[16:59:39.088]                       is.null <- base::is.null
[16:59:39.088]                       muffled <- FALSE
[16:59:39.088]                       if (inherits(cond, "message")) {
[16:59:39.088]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.088]                         if (muffled) 
[16:59:39.088]                           invokeRestart("muffleMessage")
[16:59:39.088]                       }
[16:59:39.088]                       else if (inherits(cond, "warning")) {
[16:59:39.088]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.088]                         if (muffled) 
[16:59:39.088]                           invokeRestart("muffleWarning")
[16:59:39.088]                       }
[16:59:39.088]                       else if (inherits(cond, "condition")) {
[16:59:39.088]                         if (!is.null(pattern)) {
[16:59:39.088]                           computeRestarts <- base::computeRestarts
[16:59:39.088]                           grepl <- base::grepl
[16:59:39.088]                           restarts <- computeRestarts(cond)
[16:59:39.088]                           for (restart in restarts) {
[16:59:39.088]                             name <- restart$name
[16:59:39.088]                             if (is.null(name)) 
[16:59:39.088]                               next
[16:59:39.088]                             if (!grepl(pattern, name)) 
[16:59:39.088]                               next
[16:59:39.088]                             invokeRestart(restart)
[16:59:39.088]                             muffled <- TRUE
[16:59:39.088]                             break
[16:59:39.088]                           }
[16:59:39.088]                         }
[16:59:39.088]                       }
[16:59:39.088]                       invisible(muffled)
[16:59:39.088]                     }
[16:59:39.088]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.088]                   }
[16:59:39.088]                 }
[16:59:39.088]                 else {
[16:59:39.088]                   if (TRUE) {
[16:59:39.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.088]                     {
[16:59:39.088]                       inherits <- base::inherits
[16:59:39.088]                       invokeRestart <- base::invokeRestart
[16:59:39.088]                       is.null <- base::is.null
[16:59:39.088]                       muffled <- FALSE
[16:59:39.088]                       if (inherits(cond, "message")) {
[16:59:39.088]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.088]                         if (muffled) 
[16:59:39.088]                           invokeRestart("muffleMessage")
[16:59:39.088]                       }
[16:59:39.088]                       else if (inherits(cond, "warning")) {
[16:59:39.088]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.088]                         if (muffled) 
[16:59:39.088]                           invokeRestart("muffleWarning")
[16:59:39.088]                       }
[16:59:39.088]                       else if (inherits(cond, "condition")) {
[16:59:39.088]                         if (!is.null(pattern)) {
[16:59:39.088]                           computeRestarts <- base::computeRestarts
[16:59:39.088]                           grepl <- base::grepl
[16:59:39.088]                           restarts <- computeRestarts(cond)
[16:59:39.088]                           for (restart in restarts) {
[16:59:39.088]                             name <- restart$name
[16:59:39.088]                             if (is.null(name)) 
[16:59:39.088]                               next
[16:59:39.088]                             if (!grepl(pattern, name)) 
[16:59:39.088]                               next
[16:59:39.088]                             invokeRestart(restart)
[16:59:39.088]                             muffled <- TRUE
[16:59:39.088]                             break
[16:59:39.088]                           }
[16:59:39.088]                         }
[16:59:39.088]                       }
[16:59:39.088]                       invisible(muffled)
[16:59:39.088]                     }
[16:59:39.088]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.088]                   }
[16:59:39.088]                 }
[16:59:39.088]             }
[16:59:39.088]         }))
[16:59:39.088]     }, error = function(ex) {
[16:59:39.088]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:39.088]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.088]                 ...future.rng), started = ...future.startTime, 
[16:59:39.088]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:39.088]             version = "1.8"), class = "FutureResult")
[16:59:39.088]     }, finally = {
[16:59:39.088]         if (!identical(...future.workdir, getwd())) 
[16:59:39.088]             setwd(...future.workdir)
[16:59:39.088]         {
[16:59:39.088]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:39.088]                 ...future.oldOptions$nwarnings <- NULL
[16:59:39.088]             }
[16:59:39.088]             base::options(...future.oldOptions)
[16:59:39.088]             if (.Platform$OS.type == "windows") {
[16:59:39.088]                 old_names <- names(...future.oldEnvVars)
[16:59:39.088]                 envs <- base::Sys.getenv()
[16:59:39.088]                 names <- names(envs)
[16:59:39.088]                 common <- intersect(names, old_names)
[16:59:39.088]                 added <- setdiff(names, old_names)
[16:59:39.088]                 removed <- setdiff(old_names, names)
[16:59:39.088]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:39.088]                   envs[common]]
[16:59:39.088]                 NAMES <- toupper(changed)
[16:59:39.088]                 args <- list()
[16:59:39.088]                 for (kk in seq_along(NAMES)) {
[16:59:39.088]                   name <- changed[[kk]]
[16:59:39.088]                   NAME <- NAMES[[kk]]
[16:59:39.088]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.088]                     next
[16:59:39.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.088]                 }
[16:59:39.088]                 NAMES <- toupper(added)
[16:59:39.088]                 for (kk in seq_along(NAMES)) {
[16:59:39.088]                   name <- added[[kk]]
[16:59:39.088]                   NAME <- NAMES[[kk]]
[16:59:39.088]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.088]                     next
[16:59:39.088]                   args[[name]] <- ""
[16:59:39.088]                 }
[16:59:39.088]                 NAMES <- toupper(removed)
[16:59:39.088]                 for (kk in seq_along(NAMES)) {
[16:59:39.088]                   name <- removed[[kk]]
[16:59:39.088]                   NAME <- NAMES[[kk]]
[16:59:39.088]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.088]                     next
[16:59:39.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.088]                 }
[16:59:39.088]                 if (length(args) > 0) 
[16:59:39.088]                   base::do.call(base::Sys.setenv, args = args)
[16:59:39.088]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:39.088]             }
[16:59:39.088]             else {
[16:59:39.088]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:39.088]             }
[16:59:39.088]             {
[16:59:39.088]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:39.088]                   0L) {
[16:59:39.088]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:39.088]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:39.088]                   base::options(opts)
[16:59:39.088]                 }
[16:59:39.088]                 {
[16:59:39.088]                   {
[16:59:39.088]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:39.088]                     NULL
[16:59:39.088]                   }
[16:59:39.088]                   options(future.plan = NULL)
[16:59:39.088]                   if (is.na(NA_character_)) 
[16:59:39.088]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.088]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:39.088]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:39.088]                     .init = FALSE)
[16:59:39.088]                 }
[16:59:39.088]             }
[16:59:39.088]         }
[16:59:39.088]     })
[16:59:39.088]     if (TRUE) {
[16:59:39.088]         base::sink(type = "output", split = FALSE)
[16:59:39.088]         if (TRUE) {
[16:59:39.088]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:39.088]         }
[16:59:39.088]         else {
[16:59:39.088]             ...future.result["stdout"] <- base::list(NULL)
[16:59:39.088]         }
[16:59:39.088]         base::close(...future.stdout)
[16:59:39.088]         ...future.stdout <- NULL
[16:59:39.088]     }
[16:59:39.088]     ...future.result$conditions <- ...future.conditions
[16:59:39.088]     ...future.result$finished <- base::Sys.time()
[16:59:39.088]     ...future.result
[16:59:39.088] }
[16:59:39.091] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:59:39.091] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:59:39.092] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:59:39.092] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:39.092] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:39.093] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:59:39.093] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:59:39.093] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:39.093] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:39.094] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:59:39.094] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:59:39.094] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:59:39.095] MultisessionFuture started
[16:59:39.095] - Launch lazy future ... done
[16:59:39.095] run() for ‘MultisessionFuture’ ... done
[16:59:39.095] Created future:
[16:59:39.095] MultisessionFuture:
[16:59:39.095] Label: ‘future_eapply-1’
[16:59:39.095] Expression:
[16:59:39.095] {
[16:59:39.095]     do.call(function(...) {
[16:59:39.095]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.095]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.095]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.095]             on.exit(options(oopts), add = TRUE)
[16:59:39.095]         }
[16:59:39.095]         {
[16:59:39.095]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.095]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.095]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.095]             })
[16:59:39.095]         }
[16:59:39.095]     }, args = future.call.arguments)
[16:59:39.095] }
[16:59:39.095] Lazy evaluation: FALSE
[16:59:39.095] Asynchronous evaluation: TRUE
[16:59:39.095] Local evaluation: TRUE
[16:59:39.095] Environment: R_GlobalEnv
[16:59:39.095] Capture standard output: TRUE
[16:59:39.095] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:39.095] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:39.095] Packages: <none>
[16:59:39.095] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:39.095] Resolved: FALSE
[16:59:39.095] Value: <not collected>
[16:59:39.095] Conditions captured: <none>
[16:59:39.095] Early signaling: FALSE
[16:59:39.095] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:39.095] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.107] Chunk #1 of 2 ... DONE
[16:59:39.107] Chunk #2 of 2 ...
[16:59:39.108]  - Finding globals in 'X' for chunk #2 ...
[16:59:39.108] getGlobalsAndPackages() ...
[16:59:39.108] Searching for globals...
[16:59:39.108] 
[16:59:39.108] Searching for globals ... DONE
[16:59:39.108] - globals: [0] <none>
[16:59:39.108] getGlobalsAndPackages() ... DONE
[16:59:39.109]    + additional globals found: [n=0] 
[16:59:39.109]    + additional namespaces needed: [n=0] 
[16:59:39.109]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:39.109]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:39.109]  - seeds: <none>
[16:59:39.109]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.109] getGlobalsAndPackages() ...
[16:59:39.109] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.110] Resolving globals: FALSE
[16:59:39.110] Tweak future expression to call with '...' arguments ...
[16:59:39.110] {
[16:59:39.110]     do.call(function(...) {
[16:59:39.110]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.110]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.110]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.110]             on.exit(options(oopts), add = TRUE)
[16:59:39.110]         }
[16:59:39.110]         {
[16:59:39.110]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.110]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.110]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.110]             })
[16:59:39.110]         }
[16:59:39.110]     }, args = future.call.arguments)
[16:59:39.110] }
[16:59:39.110] Tweak future expression to call with '...' arguments ... DONE
[16:59:39.111] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.111] 
[16:59:39.111] getGlobalsAndPackages() ... DONE
[16:59:39.111] run() for ‘Future’ ...
[16:59:39.111] - state: ‘created’
[16:59:39.111] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:39.125] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.125] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:39.126]   - Field: ‘node’
[16:59:39.126]   - Field: ‘label’
[16:59:39.126]   - Field: ‘local’
[16:59:39.126]   - Field: ‘owner’
[16:59:39.126]   - Field: ‘envir’
[16:59:39.126]   - Field: ‘workers’
[16:59:39.126]   - Field: ‘packages’
[16:59:39.126]   - Field: ‘gc’
[16:59:39.126]   - Field: ‘conditions’
[16:59:39.126]   - Field: ‘persistent’
[16:59:39.127]   - Field: ‘expr’
[16:59:39.127]   - Field: ‘uuid’
[16:59:39.127]   - Field: ‘seed’
[16:59:39.127]   - Field: ‘version’
[16:59:39.127]   - Field: ‘result’
[16:59:39.127]   - Field: ‘asynchronous’
[16:59:39.127]   - Field: ‘calls’
[16:59:39.127]   - Field: ‘globals’
[16:59:39.128]   - Field: ‘stdout’
[16:59:39.128]   - Field: ‘earlySignal’
[16:59:39.128]   - Field: ‘lazy’
[16:59:39.128]   - Field: ‘state’
[16:59:39.128] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:39.128] - Launch lazy future ...
[16:59:39.128] Packages needed by the future expression (n = 0): <none>
[16:59:39.129] Packages needed by future strategies (n = 0): <none>
[16:59:39.129] {
[16:59:39.129]     {
[16:59:39.129]         {
[16:59:39.129]             ...future.startTime <- base::Sys.time()
[16:59:39.129]             {
[16:59:39.129]                 {
[16:59:39.129]                   {
[16:59:39.129]                     {
[16:59:39.129]                       base::local({
[16:59:39.129]                         has_future <- base::requireNamespace("future", 
[16:59:39.129]                           quietly = TRUE)
[16:59:39.129]                         if (has_future) {
[16:59:39.129]                           ns <- base::getNamespace("future")
[16:59:39.129]                           version <- ns[[".package"]][["version"]]
[16:59:39.129]                           if (is.null(version)) 
[16:59:39.129]                             version <- utils::packageVersion("future")
[16:59:39.129]                         }
[16:59:39.129]                         else {
[16:59:39.129]                           version <- NULL
[16:59:39.129]                         }
[16:59:39.129]                         if (!has_future || version < "1.8.0") {
[16:59:39.129]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:39.129]                             "", base::R.version$version.string), 
[16:59:39.129]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:39.129]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:39.129]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:39.129]                               "release", "version")], collapse = " "), 
[16:59:39.129]                             hostname = base::Sys.info()[["nodename"]])
[16:59:39.129]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:39.129]                             info)
[16:59:39.129]                           info <- base::paste(info, collapse = "; ")
[16:59:39.129]                           if (!has_future) {
[16:59:39.129]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:39.129]                               info)
[16:59:39.129]                           }
[16:59:39.129]                           else {
[16:59:39.129]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:39.129]                               info, version)
[16:59:39.129]                           }
[16:59:39.129]                           base::stop(msg)
[16:59:39.129]                         }
[16:59:39.129]                       })
[16:59:39.129]                     }
[16:59:39.129]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:39.129]                     base::options(mc.cores = 1L)
[16:59:39.129]                   }
[16:59:39.129]                   ...future.strategy.old <- future::plan("list")
[16:59:39.129]                   options(future.plan = NULL)
[16:59:39.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:39.129]                 }
[16:59:39.129]                 ...future.workdir <- getwd()
[16:59:39.129]             }
[16:59:39.129]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:39.129]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:39.129]         }
[16:59:39.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:39.129]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:39.129]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:39.129]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:39.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:39.129]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:39.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:39.129]             base::names(...future.oldOptions))
[16:59:39.129]     }
[16:59:39.129]     if (FALSE) {
[16:59:39.129]     }
[16:59:39.129]     else {
[16:59:39.129]         if (TRUE) {
[16:59:39.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:39.129]                 open = "w")
[16:59:39.129]         }
[16:59:39.129]         else {
[16:59:39.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:39.129]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:39.129]         }
[16:59:39.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:39.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:39.129]             base::sink(type = "output", split = FALSE)
[16:59:39.129]             base::close(...future.stdout)
[16:59:39.129]         }, add = TRUE)
[16:59:39.129]     }
[16:59:39.129]     ...future.frame <- base::sys.nframe()
[16:59:39.129]     ...future.conditions <- base::list()
[16:59:39.129]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:39.129]     if (FALSE) {
[16:59:39.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:39.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:39.129]     }
[16:59:39.129]     ...future.result <- base::tryCatch({
[16:59:39.129]         base::withCallingHandlers({
[16:59:39.129]             ...future.value <- base::withVisible(base::local({
[16:59:39.129]                 ...future.makeSendCondition <- base::local({
[16:59:39.129]                   sendCondition <- NULL
[16:59:39.129]                   function(frame = 1L) {
[16:59:39.129]                     if (is.function(sendCondition)) 
[16:59:39.129]                       return(sendCondition)
[16:59:39.129]                     ns <- getNamespace("parallel")
[16:59:39.129]                     if (exists("sendData", mode = "function", 
[16:59:39.129]                       envir = ns)) {
[16:59:39.129]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:39.129]                         envir = ns)
[16:59:39.129]                       envir <- sys.frame(frame)
[16:59:39.129]                       master <- NULL
[16:59:39.129]                       while (!identical(envir, .GlobalEnv) && 
[16:59:39.129]                         !identical(envir, emptyenv())) {
[16:59:39.129]                         if (exists("master", mode = "list", envir = envir, 
[16:59:39.129]                           inherits = FALSE)) {
[16:59:39.129]                           master <- get("master", mode = "list", 
[16:59:39.129]                             envir = envir, inherits = FALSE)
[16:59:39.129]                           if (inherits(master, c("SOCKnode", 
[16:59:39.129]                             "SOCK0node"))) {
[16:59:39.129]                             sendCondition <<- function(cond) {
[16:59:39.129]                               data <- list(type = "VALUE", value = cond, 
[16:59:39.129]                                 success = TRUE)
[16:59:39.129]                               parallel_sendData(master, data)
[16:59:39.129]                             }
[16:59:39.129]                             return(sendCondition)
[16:59:39.129]                           }
[16:59:39.129]                         }
[16:59:39.129]                         frame <- frame + 1L
[16:59:39.129]                         envir <- sys.frame(frame)
[16:59:39.129]                       }
[16:59:39.129]                     }
[16:59:39.129]                     sendCondition <<- function(cond) NULL
[16:59:39.129]                   }
[16:59:39.129]                 })
[16:59:39.129]                 withCallingHandlers({
[16:59:39.129]                   {
[16:59:39.129]                     do.call(function(...) {
[16:59:39.129]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.129]                       if (!identical(...future.globals.maxSize.org, 
[16:59:39.129]                         ...future.globals.maxSize)) {
[16:59:39.129]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.129]                         on.exit(options(oopts), add = TRUE)
[16:59:39.129]                       }
[16:59:39.129]                       {
[16:59:39.129]                         lapply(seq_along(...future.elements_ii), 
[16:59:39.129]                           FUN = function(jj) {
[16:59:39.129]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.129]                             ...future.FUN(...future.X_jj, ...)
[16:59:39.129]                           })
[16:59:39.129]                       }
[16:59:39.129]                     }, args = future.call.arguments)
[16:59:39.129]                   }
[16:59:39.129]                 }, immediateCondition = function(cond) {
[16:59:39.129]                   sendCondition <- ...future.makeSendCondition()
[16:59:39.129]                   sendCondition(cond)
[16:59:39.129]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.129]                   {
[16:59:39.129]                     inherits <- base::inherits
[16:59:39.129]                     invokeRestart <- base::invokeRestart
[16:59:39.129]                     is.null <- base::is.null
[16:59:39.129]                     muffled <- FALSE
[16:59:39.129]                     if (inherits(cond, "message")) {
[16:59:39.129]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:39.129]                       if (muffled) 
[16:59:39.129]                         invokeRestart("muffleMessage")
[16:59:39.129]                     }
[16:59:39.129]                     else if (inherits(cond, "warning")) {
[16:59:39.129]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:39.129]                       if (muffled) 
[16:59:39.129]                         invokeRestart("muffleWarning")
[16:59:39.129]                     }
[16:59:39.129]                     else if (inherits(cond, "condition")) {
[16:59:39.129]                       if (!is.null(pattern)) {
[16:59:39.129]                         computeRestarts <- base::computeRestarts
[16:59:39.129]                         grepl <- base::grepl
[16:59:39.129]                         restarts <- computeRestarts(cond)
[16:59:39.129]                         for (restart in restarts) {
[16:59:39.129]                           name <- restart$name
[16:59:39.129]                           if (is.null(name)) 
[16:59:39.129]                             next
[16:59:39.129]                           if (!grepl(pattern, name)) 
[16:59:39.129]                             next
[16:59:39.129]                           invokeRestart(restart)
[16:59:39.129]                           muffled <- TRUE
[16:59:39.129]                           break
[16:59:39.129]                         }
[16:59:39.129]                       }
[16:59:39.129]                     }
[16:59:39.129]                     invisible(muffled)
[16:59:39.129]                   }
[16:59:39.129]                   muffleCondition(cond)
[16:59:39.129]                 })
[16:59:39.129]             }))
[16:59:39.129]             future::FutureResult(value = ...future.value$value, 
[16:59:39.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.129]                   ...future.rng), globalenv = if (FALSE) 
[16:59:39.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:39.129]                     ...future.globalenv.names))
[16:59:39.129]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:39.129]         }, condition = base::local({
[16:59:39.129]             c <- base::c
[16:59:39.129]             inherits <- base::inherits
[16:59:39.129]             invokeRestart <- base::invokeRestart
[16:59:39.129]             length <- base::length
[16:59:39.129]             list <- base::list
[16:59:39.129]             seq.int <- base::seq.int
[16:59:39.129]             signalCondition <- base::signalCondition
[16:59:39.129]             sys.calls <- base::sys.calls
[16:59:39.129]             `[[` <- base::`[[`
[16:59:39.129]             `+` <- base::`+`
[16:59:39.129]             `<<-` <- base::`<<-`
[16:59:39.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:39.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:39.129]                   3L)]
[16:59:39.129]             }
[16:59:39.129]             function(cond) {
[16:59:39.129]                 is_error <- inherits(cond, "error")
[16:59:39.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:39.129]                   NULL)
[16:59:39.129]                 if (is_error) {
[16:59:39.129]                   sessionInformation <- function() {
[16:59:39.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:39.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:39.129]                       search = base::search(), system = base::Sys.info())
[16:59:39.129]                   }
[16:59:39.129]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:39.129]                     cond$call), session = sessionInformation(), 
[16:59:39.129]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:39.129]                   signalCondition(cond)
[16:59:39.129]                 }
[16:59:39.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:39.129]                 "immediateCondition"))) {
[16:59:39.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:39.129]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:39.129]                   if (TRUE && !signal) {
[16:59:39.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.129]                     {
[16:59:39.129]                       inherits <- base::inherits
[16:59:39.129]                       invokeRestart <- base::invokeRestart
[16:59:39.129]                       is.null <- base::is.null
[16:59:39.129]                       muffled <- FALSE
[16:59:39.129]                       if (inherits(cond, "message")) {
[16:59:39.129]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.129]                         if (muffled) 
[16:59:39.129]                           invokeRestart("muffleMessage")
[16:59:39.129]                       }
[16:59:39.129]                       else if (inherits(cond, "warning")) {
[16:59:39.129]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.129]                         if (muffled) 
[16:59:39.129]                           invokeRestart("muffleWarning")
[16:59:39.129]                       }
[16:59:39.129]                       else if (inherits(cond, "condition")) {
[16:59:39.129]                         if (!is.null(pattern)) {
[16:59:39.129]                           computeRestarts <- base::computeRestarts
[16:59:39.129]                           grepl <- base::grepl
[16:59:39.129]                           restarts <- computeRestarts(cond)
[16:59:39.129]                           for (restart in restarts) {
[16:59:39.129]                             name <- restart$name
[16:59:39.129]                             if (is.null(name)) 
[16:59:39.129]                               next
[16:59:39.129]                             if (!grepl(pattern, name)) 
[16:59:39.129]                               next
[16:59:39.129]                             invokeRestart(restart)
[16:59:39.129]                             muffled <- TRUE
[16:59:39.129]                             break
[16:59:39.129]                           }
[16:59:39.129]                         }
[16:59:39.129]                       }
[16:59:39.129]                       invisible(muffled)
[16:59:39.129]                     }
[16:59:39.129]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.129]                   }
[16:59:39.129]                 }
[16:59:39.129]                 else {
[16:59:39.129]                   if (TRUE) {
[16:59:39.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.129]                     {
[16:59:39.129]                       inherits <- base::inherits
[16:59:39.129]                       invokeRestart <- base::invokeRestart
[16:59:39.129]                       is.null <- base::is.null
[16:59:39.129]                       muffled <- FALSE
[16:59:39.129]                       if (inherits(cond, "message")) {
[16:59:39.129]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.129]                         if (muffled) 
[16:59:39.129]                           invokeRestart("muffleMessage")
[16:59:39.129]                       }
[16:59:39.129]                       else if (inherits(cond, "warning")) {
[16:59:39.129]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.129]                         if (muffled) 
[16:59:39.129]                           invokeRestart("muffleWarning")
[16:59:39.129]                       }
[16:59:39.129]                       else if (inherits(cond, "condition")) {
[16:59:39.129]                         if (!is.null(pattern)) {
[16:59:39.129]                           computeRestarts <- base::computeRestarts
[16:59:39.129]                           grepl <- base::grepl
[16:59:39.129]                           restarts <- computeRestarts(cond)
[16:59:39.129]                           for (restart in restarts) {
[16:59:39.129]                             name <- restart$name
[16:59:39.129]                             if (is.null(name)) 
[16:59:39.129]                               next
[16:59:39.129]                             if (!grepl(pattern, name)) 
[16:59:39.129]                               next
[16:59:39.129]                             invokeRestart(restart)
[16:59:39.129]                             muffled <- TRUE
[16:59:39.129]                             break
[16:59:39.129]                           }
[16:59:39.129]                         }
[16:59:39.129]                       }
[16:59:39.129]                       invisible(muffled)
[16:59:39.129]                     }
[16:59:39.129]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.129]                   }
[16:59:39.129]                 }
[16:59:39.129]             }
[16:59:39.129]         }))
[16:59:39.129]     }, error = function(ex) {
[16:59:39.129]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:39.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.129]                 ...future.rng), started = ...future.startTime, 
[16:59:39.129]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:39.129]             version = "1.8"), class = "FutureResult")
[16:59:39.129]     }, finally = {
[16:59:39.129]         if (!identical(...future.workdir, getwd())) 
[16:59:39.129]             setwd(...future.workdir)
[16:59:39.129]         {
[16:59:39.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:39.129]                 ...future.oldOptions$nwarnings <- NULL
[16:59:39.129]             }
[16:59:39.129]             base::options(...future.oldOptions)
[16:59:39.129]             if (.Platform$OS.type == "windows") {
[16:59:39.129]                 old_names <- names(...future.oldEnvVars)
[16:59:39.129]                 envs <- base::Sys.getenv()
[16:59:39.129]                 names <- names(envs)
[16:59:39.129]                 common <- intersect(names, old_names)
[16:59:39.129]                 added <- setdiff(names, old_names)
[16:59:39.129]                 removed <- setdiff(old_names, names)
[16:59:39.129]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:39.129]                   envs[common]]
[16:59:39.129]                 NAMES <- toupper(changed)
[16:59:39.129]                 args <- list()
[16:59:39.129]                 for (kk in seq_along(NAMES)) {
[16:59:39.129]                   name <- changed[[kk]]
[16:59:39.129]                   NAME <- NAMES[[kk]]
[16:59:39.129]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.129]                     next
[16:59:39.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.129]                 }
[16:59:39.129]                 NAMES <- toupper(added)
[16:59:39.129]                 for (kk in seq_along(NAMES)) {
[16:59:39.129]                   name <- added[[kk]]
[16:59:39.129]                   NAME <- NAMES[[kk]]
[16:59:39.129]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.129]                     next
[16:59:39.129]                   args[[name]] <- ""
[16:59:39.129]                 }
[16:59:39.129]                 NAMES <- toupper(removed)
[16:59:39.129]                 for (kk in seq_along(NAMES)) {
[16:59:39.129]                   name <- removed[[kk]]
[16:59:39.129]                   NAME <- NAMES[[kk]]
[16:59:39.129]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.129]                     next
[16:59:39.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.129]                 }
[16:59:39.129]                 if (length(args) > 0) 
[16:59:39.129]                   base::do.call(base::Sys.setenv, args = args)
[16:59:39.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:39.129]             }
[16:59:39.129]             else {
[16:59:39.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:39.129]             }
[16:59:39.129]             {
[16:59:39.129]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:39.129]                   0L) {
[16:59:39.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:39.129]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:39.129]                   base::options(opts)
[16:59:39.129]                 }
[16:59:39.129]                 {
[16:59:39.129]                   {
[16:59:39.129]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:39.129]                     NULL
[16:59:39.129]                   }
[16:59:39.129]                   options(future.plan = NULL)
[16:59:39.129]                   if (is.na(NA_character_)) 
[16:59:39.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:39.129]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:39.129]                     .init = FALSE)
[16:59:39.129]                 }
[16:59:39.129]             }
[16:59:39.129]         }
[16:59:39.129]     })
[16:59:39.129]     if (TRUE) {
[16:59:39.129]         base::sink(type = "output", split = FALSE)
[16:59:39.129]         if (TRUE) {
[16:59:39.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:39.129]         }
[16:59:39.129]         else {
[16:59:39.129]             ...future.result["stdout"] <- base::list(NULL)
[16:59:39.129]         }
[16:59:39.129]         base::close(...future.stdout)
[16:59:39.129]         ...future.stdout <- NULL
[16:59:39.129]     }
[16:59:39.129]     ...future.result$conditions <- ...future.conditions
[16:59:39.129]     ...future.result$finished <- base::Sys.time()
[16:59:39.129]     ...future.result
[16:59:39.129] }
[16:59:39.180] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:59:39.180] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:59:39.181] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:59:39.181] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:59:39.182] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:59:39.182] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:59:39.182] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:59:39.183] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:39.183] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:39.183] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:59:39.183] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:59:39.184] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:59:39.184] MultisessionFuture started
[16:59:39.185] - Launch lazy future ... done
[16:59:39.185] run() for ‘MultisessionFuture’ ... done
[16:59:39.185] Created future:
[16:59:39.185] MultisessionFuture:
[16:59:39.185] Label: ‘future_eapply-2’
[16:59:39.185] Expression:
[16:59:39.185] {
[16:59:39.185]     do.call(function(...) {
[16:59:39.185]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.185]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.185]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.185]             on.exit(options(oopts), add = TRUE)
[16:59:39.185]         }
[16:59:39.185]         {
[16:59:39.185]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.185]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.185]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.185]             })
[16:59:39.185]         }
[16:59:39.185]     }, args = future.call.arguments)
[16:59:39.185] }
[16:59:39.185] Lazy evaluation: FALSE
[16:59:39.185] Asynchronous evaluation: TRUE
[16:59:39.185] Local evaluation: TRUE
[16:59:39.185] Environment: R_GlobalEnv
[16:59:39.185] Capture standard output: TRUE
[16:59:39.185] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:39.185] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:39.185] Packages: <none>
[16:59:39.185] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:39.185] Resolved: FALSE
[16:59:39.185] Value: <not collected>
[16:59:39.185] Conditions captured: <none>
[16:59:39.185] Early signaling: FALSE
[16:59:39.185] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:39.185] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.197] Chunk #2 of 2 ... DONE
[16:59:39.197] Launching 2 futures (chunks) ... DONE
[16:59:39.197] Resolving 2 futures (chunks) ...
[16:59:39.197] resolve() on list ...
[16:59:39.197]  recursive: 0
[16:59:39.197]  length: 2
[16:59:39.198] 
[16:59:39.198] receiveMessageFromWorker() for ClusterFuture ...
[16:59:39.198] - Validating connection of MultisessionFuture
[16:59:39.198] - received message: FutureResult
[16:59:39.199] - Received FutureResult
[16:59:39.199] - Erased future from FutureRegistry
[16:59:39.199] result() for ClusterFuture ...
[16:59:39.199] - result already collected: FutureResult
[16:59:39.199] result() for ClusterFuture ... done
[16:59:39.199] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:39.199] Future #1
[16:59:39.199] result() for ClusterFuture ...
[16:59:39.200] - result already collected: FutureResult
[16:59:39.200] result() for ClusterFuture ... done
[16:59:39.200] result() for ClusterFuture ...
[16:59:39.200] - result already collected: FutureResult
[16:59:39.200] result() for ClusterFuture ... done
[16:59:39.200] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:39.200] - nx: 2
[16:59:39.202] - relay: TRUE
[16:59:39.203] - stdout: TRUE
[16:59:39.203] - signal: TRUE
[16:59:39.203] - resignal: FALSE
[16:59:39.203] - force: TRUE
[16:59:39.203] - relayed: [n=2] FALSE, FALSE
[16:59:39.203] - queued futures: [n=2] FALSE, FALSE
[16:59:39.203]  - until=1
[16:59:39.203]  - relaying element #1
[16:59:39.203] result() for ClusterFuture ...
[16:59:39.203] - result already collected: FutureResult
[16:59:39.203] result() for ClusterFuture ... done
[16:59:39.204] result() for ClusterFuture ...
[16:59:39.204] - result already collected: FutureResult
[16:59:39.204] result() for ClusterFuture ... done
[16:59:39.204] result() for ClusterFuture ...
[16:59:39.204] - result already collected: FutureResult
[16:59:39.204] result() for ClusterFuture ... done
[16:59:39.204] result() for ClusterFuture ...
[16:59:39.204] - result already collected: FutureResult
[16:59:39.204] result() for ClusterFuture ... done
[16:59:39.204] - relayed: [n=2] TRUE, FALSE
[16:59:39.204] - queued futures: [n=2] TRUE, FALSE
[16:59:39.204] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:39.205]  length: 1 (resolved future 1)
[16:59:39.267] receiveMessageFromWorker() for ClusterFuture ...
[16:59:39.267] - Validating connection of MultisessionFuture
[16:59:39.267] - received message: FutureResult
[16:59:39.268] - Received FutureResult
[16:59:39.268] - Erased future from FutureRegistry
[16:59:39.268] result() for ClusterFuture ...
[16:59:39.268] - result already collected: FutureResult
[16:59:39.268] result() for ClusterFuture ... done
[16:59:39.268] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:39.268] Future #2
[16:59:39.268] result() for ClusterFuture ...
[16:59:39.268] - result already collected: FutureResult
[16:59:39.268] result() for ClusterFuture ... done
[16:59:39.269] result() for ClusterFuture ...
[16:59:39.269] - result already collected: FutureResult
[16:59:39.269] result() for ClusterFuture ... done
[16:59:39.269] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:39.269] - nx: 2
[16:59:39.269] - relay: TRUE
[16:59:39.269] - stdout: TRUE
[16:59:39.269] - signal: TRUE
[16:59:39.269] - resignal: FALSE
[16:59:39.269] - force: TRUE
[16:59:39.269] - relayed: [n=2] TRUE, FALSE
[16:59:39.269] - queued futures: [n=2] TRUE, FALSE
[16:59:39.270]  - until=2
[16:59:39.270]  - relaying element #2
[16:59:39.270] result() for ClusterFuture ...
[16:59:39.270] - result already collected: FutureResult
[16:59:39.270] result() for ClusterFuture ... done
[16:59:39.270] result() for ClusterFuture ...
[16:59:39.270] - result already collected: FutureResult
[16:59:39.270] result() for ClusterFuture ... done
[16:59:39.270] result() for ClusterFuture ...
[16:59:39.270] - result already collected: FutureResult
[16:59:39.270] result() for ClusterFuture ... done
[16:59:39.270] result() for ClusterFuture ...
[16:59:39.271] - result already collected: FutureResult
[16:59:39.271] result() for ClusterFuture ... done
[16:59:39.271] - relayed: [n=2] TRUE, TRUE
[16:59:39.271] - queued futures: [n=2] TRUE, TRUE
[16:59:39.271] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:39.271]  length: 0 (resolved future 2)
[16:59:39.271] Relaying remaining futures
[16:59:39.271] signalConditionsASAP(NULL, pos=0) ...
[16:59:39.271] - nx: 2
[16:59:39.271] - relay: TRUE
[16:59:39.271] - stdout: TRUE
[16:59:39.272] - signal: TRUE
[16:59:39.272] - resignal: FALSE
[16:59:39.272] - force: TRUE
[16:59:39.272] - relayed: [n=2] TRUE, TRUE
[16:59:39.272] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:39.272] - relayed: [n=2] TRUE, TRUE
[16:59:39.272] - queued futures: [n=2] TRUE, TRUE
[16:59:39.272] signalConditionsASAP(NULL, pos=0) ... done
[16:59:39.272] resolve() on list ... DONE
[16:59:39.272] result() for ClusterFuture ...
[16:59:39.272] - result already collected: FutureResult
[16:59:39.273] result() for ClusterFuture ... done
[16:59:39.273] result() for ClusterFuture ...
[16:59:39.273] - result already collected: FutureResult
[16:59:39.273] result() for ClusterFuture ... done
[16:59:39.273] result() for ClusterFuture ...
[16:59:39.273] - result already collected: FutureResult
[16:59:39.273] result() for ClusterFuture ... done
[16:59:39.273] result() for ClusterFuture ...
[16:59:39.273] - result already collected: FutureResult
[16:59:39.273] result() for ClusterFuture ... done
[16:59:39.273]  - Number of value chunks collected: 2
[16:59:39.274] Resolving 2 futures (chunks) ... DONE
[16:59:39.274] Reducing values from 2 chunks ...
[16:59:39.274]  - Number of values collected after concatenation: 3
[16:59:39.274]  - Number of values expected: 3
[16:59:39.274] Reducing values from 2 chunks ... DONE
[16:59:39.274] future_lapply() ... DONE
[16:59:39.274] future_lapply() ...
[16:59:39.278] Number of chunks: 2
[16:59:39.279] getGlobalsAndPackagesXApply() ...
[16:59:39.279]  - future.globals: TRUE
[16:59:39.279] getGlobalsAndPackages() ...
[16:59:39.279] Searching for globals...
[16:59:39.280] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:39.280] Searching for globals ... DONE
[16:59:39.280] Resolving globals: FALSE
[16:59:39.281] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:59:39.281] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:59:39.281] - globals: [1] ‘FUN’
[16:59:39.281] - packages: [1] ‘stats’
[16:59:39.281] getGlobalsAndPackages() ... DONE
[16:59:39.281]  - globals found/used: [n=1] ‘FUN’
[16:59:39.281]  - needed namespaces: [n=1] ‘stats’
[16:59:39.282] Finding globals ... DONE
[16:59:39.282]  - use_args: TRUE
[16:59:39.282]  - Getting '...' globals ...
[16:59:39.282] resolve() on list ...
[16:59:39.282]  recursive: 0
[16:59:39.282]  length: 1
[16:59:39.282]  elements: ‘...’
[16:59:39.282]  length: 0 (resolved future 1)
[16:59:39.282] resolve() on list ... DONE
[16:59:39.283]    - '...' content: [n=1] ‘probs’
[16:59:39.283] List of 1
[16:59:39.283]  $ ...:List of 1
[16:59:39.283]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:59:39.283]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:39.283]  - attr(*, "where")=List of 1
[16:59:39.283]   ..$ ...:<environment: 0x55c3489c6e60> 
[16:59:39.283]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:39.283]  - attr(*, "resolved")= logi TRUE
[16:59:39.283]  - attr(*, "total_size")= num NA
[16:59:39.286]  - Getting '...' globals ... DONE
[16:59:39.286] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:39.286] List of 2
[16:59:39.286]  $ ...future.FUN:function (x, ...)  
[16:59:39.286]  $ ...          :List of 1
[16:59:39.286]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:59:39.286]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:39.286]  - attr(*, "where")=List of 2
[16:59:39.286]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:39.286]   ..$ ...          :<environment: 0x55c3489c6e60> 
[16:59:39.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:39.286]  - attr(*, "resolved")= logi FALSE
[16:59:39.286]  - attr(*, "total_size")= num 1328
[16:59:39.289] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:39.289] getGlobalsAndPackagesXApply() ... DONE
[16:59:39.289] Number of futures (= number of chunks): 2
[16:59:39.289] Launching 2 futures (chunks) ...
[16:59:39.289] Chunk #1 of 2 ...
[16:59:39.289]  - Finding globals in 'X' for chunk #1 ...
[16:59:39.290] getGlobalsAndPackages() ...
[16:59:39.290] Searching for globals...
[16:59:39.290] 
[16:59:39.290] Searching for globals ... DONE
[16:59:39.290] - globals: [0] <none>
[16:59:39.290] getGlobalsAndPackages() ... DONE
[16:59:39.290]    + additional globals found: [n=0] 
[16:59:39.290]    + additional namespaces needed: [n=0] 
[16:59:39.290]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:39.290]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:39.291]  - seeds: <none>
[16:59:39.291]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.291] getGlobalsAndPackages() ...
[16:59:39.291] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.291] Resolving globals: FALSE
[16:59:39.291] Tweak future expression to call with '...' arguments ...
[16:59:39.291] {
[16:59:39.291]     do.call(function(...) {
[16:59:39.291]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.291]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.291]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.291]             on.exit(options(oopts), add = TRUE)
[16:59:39.291]         }
[16:59:39.291]         {
[16:59:39.291]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.291]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.291]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.291]             })
[16:59:39.291]         }
[16:59:39.291]     }, args = future.call.arguments)
[16:59:39.291] }
[16:59:39.292] Tweak future expression to call with '...' arguments ... DONE
[16:59:39.292] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.292] - packages: [1] ‘stats’
[16:59:39.292] getGlobalsAndPackages() ... DONE
[16:59:39.292] run() for ‘Future’ ...
[16:59:39.292] - state: ‘created’
[16:59:39.293] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:39.306] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.306] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:39.306]   - Field: ‘node’
[16:59:39.306]   - Field: ‘label’
[16:59:39.307]   - Field: ‘local’
[16:59:39.307]   - Field: ‘owner’
[16:59:39.307]   - Field: ‘envir’
[16:59:39.307]   - Field: ‘workers’
[16:59:39.307]   - Field: ‘packages’
[16:59:39.307]   - Field: ‘gc’
[16:59:39.307]   - Field: ‘conditions’
[16:59:39.307]   - Field: ‘persistent’
[16:59:39.307]   - Field: ‘expr’
[16:59:39.307]   - Field: ‘uuid’
[16:59:39.307]   - Field: ‘seed’
[16:59:39.308]   - Field: ‘version’
[16:59:39.308]   - Field: ‘result’
[16:59:39.308]   - Field: ‘asynchronous’
[16:59:39.308]   - Field: ‘calls’
[16:59:39.308]   - Field: ‘globals’
[16:59:39.308]   - Field: ‘stdout’
[16:59:39.308]   - Field: ‘earlySignal’
[16:59:39.308]   - Field: ‘lazy’
[16:59:39.308]   - Field: ‘state’
[16:59:39.308] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:39.308] - Launch lazy future ...
[16:59:39.309] Packages needed by the future expression (n = 1): ‘stats’
[16:59:39.309] Packages needed by future strategies (n = 0): <none>
[16:59:39.309] {
[16:59:39.309]     {
[16:59:39.309]         {
[16:59:39.309]             ...future.startTime <- base::Sys.time()
[16:59:39.309]             {
[16:59:39.309]                 {
[16:59:39.309]                   {
[16:59:39.309]                     {
[16:59:39.309]                       {
[16:59:39.309]                         base::local({
[16:59:39.309]                           has_future <- base::requireNamespace("future", 
[16:59:39.309]                             quietly = TRUE)
[16:59:39.309]                           if (has_future) {
[16:59:39.309]                             ns <- base::getNamespace("future")
[16:59:39.309]                             version <- ns[[".package"]][["version"]]
[16:59:39.309]                             if (is.null(version)) 
[16:59:39.309]                               version <- utils::packageVersion("future")
[16:59:39.309]                           }
[16:59:39.309]                           else {
[16:59:39.309]                             version <- NULL
[16:59:39.309]                           }
[16:59:39.309]                           if (!has_future || version < "1.8.0") {
[16:59:39.309]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:39.309]                               "", base::R.version$version.string), 
[16:59:39.309]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:39.309]                                 base::R.version$platform, 8 * 
[16:59:39.309]                                   base::.Machine$sizeof.pointer), 
[16:59:39.309]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:39.309]                                 "release", "version")], collapse = " "), 
[16:59:39.309]                               hostname = base::Sys.info()[["nodename"]])
[16:59:39.309]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:39.309]                               info)
[16:59:39.309]                             info <- base::paste(info, collapse = "; ")
[16:59:39.309]                             if (!has_future) {
[16:59:39.309]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:39.309]                                 info)
[16:59:39.309]                             }
[16:59:39.309]                             else {
[16:59:39.309]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:39.309]                                 info, version)
[16:59:39.309]                             }
[16:59:39.309]                             base::stop(msg)
[16:59:39.309]                           }
[16:59:39.309]                         })
[16:59:39.309]                       }
[16:59:39.309]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:39.309]                       base::options(mc.cores = 1L)
[16:59:39.309]                     }
[16:59:39.309]                     base::local({
[16:59:39.309]                       for (pkg in "stats") {
[16:59:39.309]                         base::loadNamespace(pkg)
[16:59:39.309]                         base::library(pkg, character.only = TRUE)
[16:59:39.309]                       }
[16:59:39.309]                     })
[16:59:39.309]                   }
[16:59:39.309]                   ...future.strategy.old <- future::plan("list")
[16:59:39.309]                   options(future.plan = NULL)
[16:59:39.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:39.309]                 }
[16:59:39.309]                 ...future.workdir <- getwd()
[16:59:39.309]             }
[16:59:39.309]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:39.309]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:39.309]         }
[16:59:39.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:39.309]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:39.309]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:39.309]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:39.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:39.309]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:39.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:39.309]             base::names(...future.oldOptions))
[16:59:39.309]     }
[16:59:39.309]     if (FALSE) {
[16:59:39.309]     }
[16:59:39.309]     else {
[16:59:39.309]         if (TRUE) {
[16:59:39.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:39.309]                 open = "w")
[16:59:39.309]         }
[16:59:39.309]         else {
[16:59:39.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:39.309]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:39.309]         }
[16:59:39.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:39.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:39.309]             base::sink(type = "output", split = FALSE)
[16:59:39.309]             base::close(...future.stdout)
[16:59:39.309]         }, add = TRUE)
[16:59:39.309]     }
[16:59:39.309]     ...future.frame <- base::sys.nframe()
[16:59:39.309]     ...future.conditions <- base::list()
[16:59:39.309]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:39.309]     if (FALSE) {
[16:59:39.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:39.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:39.309]     }
[16:59:39.309]     ...future.result <- base::tryCatch({
[16:59:39.309]         base::withCallingHandlers({
[16:59:39.309]             ...future.value <- base::withVisible(base::local({
[16:59:39.309]                 ...future.makeSendCondition <- base::local({
[16:59:39.309]                   sendCondition <- NULL
[16:59:39.309]                   function(frame = 1L) {
[16:59:39.309]                     if (is.function(sendCondition)) 
[16:59:39.309]                       return(sendCondition)
[16:59:39.309]                     ns <- getNamespace("parallel")
[16:59:39.309]                     if (exists("sendData", mode = "function", 
[16:59:39.309]                       envir = ns)) {
[16:59:39.309]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:39.309]                         envir = ns)
[16:59:39.309]                       envir <- sys.frame(frame)
[16:59:39.309]                       master <- NULL
[16:59:39.309]                       while (!identical(envir, .GlobalEnv) && 
[16:59:39.309]                         !identical(envir, emptyenv())) {
[16:59:39.309]                         if (exists("master", mode = "list", envir = envir, 
[16:59:39.309]                           inherits = FALSE)) {
[16:59:39.309]                           master <- get("master", mode = "list", 
[16:59:39.309]                             envir = envir, inherits = FALSE)
[16:59:39.309]                           if (inherits(master, c("SOCKnode", 
[16:59:39.309]                             "SOCK0node"))) {
[16:59:39.309]                             sendCondition <<- function(cond) {
[16:59:39.309]                               data <- list(type = "VALUE", value = cond, 
[16:59:39.309]                                 success = TRUE)
[16:59:39.309]                               parallel_sendData(master, data)
[16:59:39.309]                             }
[16:59:39.309]                             return(sendCondition)
[16:59:39.309]                           }
[16:59:39.309]                         }
[16:59:39.309]                         frame <- frame + 1L
[16:59:39.309]                         envir <- sys.frame(frame)
[16:59:39.309]                       }
[16:59:39.309]                     }
[16:59:39.309]                     sendCondition <<- function(cond) NULL
[16:59:39.309]                   }
[16:59:39.309]                 })
[16:59:39.309]                 withCallingHandlers({
[16:59:39.309]                   {
[16:59:39.309]                     do.call(function(...) {
[16:59:39.309]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.309]                       if (!identical(...future.globals.maxSize.org, 
[16:59:39.309]                         ...future.globals.maxSize)) {
[16:59:39.309]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.309]                         on.exit(options(oopts), add = TRUE)
[16:59:39.309]                       }
[16:59:39.309]                       {
[16:59:39.309]                         lapply(seq_along(...future.elements_ii), 
[16:59:39.309]                           FUN = function(jj) {
[16:59:39.309]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.309]                             ...future.FUN(...future.X_jj, ...)
[16:59:39.309]                           })
[16:59:39.309]                       }
[16:59:39.309]                     }, args = future.call.arguments)
[16:59:39.309]                   }
[16:59:39.309]                 }, immediateCondition = function(cond) {
[16:59:39.309]                   sendCondition <- ...future.makeSendCondition()
[16:59:39.309]                   sendCondition(cond)
[16:59:39.309]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.309]                   {
[16:59:39.309]                     inherits <- base::inherits
[16:59:39.309]                     invokeRestart <- base::invokeRestart
[16:59:39.309]                     is.null <- base::is.null
[16:59:39.309]                     muffled <- FALSE
[16:59:39.309]                     if (inherits(cond, "message")) {
[16:59:39.309]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:39.309]                       if (muffled) 
[16:59:39.309]                         invokeRestart("muffleMessage")
[16:59:39.309]                     }
[16:59:39.309]                     else if (inherits(cond, "warning")) {
[16:59:39.309]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:39.309]                       if (muffled) 
[16:59:39.309]                         invokeRestart("muffleWarning")
[16:59:39.309]                     }
[16:59:39.309]                     else if (inherits(cond, "condition")) {
[16:59:39.309]                       if (!is.null(pattern)) {
[16:59:39.309]                         computeRestarts <- base::computeRestarts
[16:59:39.309]                         grepl <- base::grepl
[16:59:39.309]                         restarts <- computeRestarts(cond)
[16:59:39.309]                         for (restart in restarts) {
[16:59:39.309]                           name <- restart$name
[16:59:39.309]                           if (is.null(name)) 
[16:59:39.309]                             next
[16:59:39.309]                           if (!grepl(pattern, name)) 
[16:59:39.309]                             next
[16:59:39.309]                           invokeRestart(restart)
[16:59:39.309]                           muffled <- TRUE
[16:59:39.309]                           break
[16:59:39.309]                         }
[16:59:39.309]                       }
[16:59:39.309]                     }
[16:59:39.309]                     invisible(muffled)
[16:59:39.309]                   }
[16:59:39.309]                   muffleCondition(cond)
[16:59:39.309]                 })
[16:59:39.309]             }))
[16:59:39.309]             future::FutureResult(value = ...future.value$value, 
[16:59:39.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.309]                   ...future.rng), globalenv = if (FALSE) 
[16:59:39.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:39.309]                     ...future.globalenv.names))
[16:59:39.309]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:39.309]         }, condition = base::local({
[16:59:39.309]             c <- base::c
[16:59:39.309]             inherits <- base::inherits
[16:59:39.309]             invokeRestart <- base::invokeRestart
[16:59:39.309]             length <- base::length
[16:59:39.309]             list <- base::list
[16:59:39.309]             seq.int <- base::seq.int
[16:59:39.309]             signalCondition <- base::signalCondition
[16:59:39.309]             sys.calls <- base::sys.calls
[16:59:39.309]             `[[` <- base::`[[`
[16:59:39.309]             `+` <- base::`+`
[16:59:39.309]             `<<-` <- base::`<<-`
[16:59:39.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:39.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:39.309]                   3L)]
[16:59:39.309]             }
[16:59:39.309]             function(cond) {
[16:59:39.309]                 is_error <- inherits(cond, "error")
[16:59:39.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:39.309]                   NULL)
[16:59:39.309]                 if (is_error) {
[16:59:39.309]                   sessionInformation <- function() {
[16:59:39.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:39.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:39.309]                       search = base::search(), system = base::Sys.info())
[16:59:39.309]                   }
[16:59:39.309]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:39.309]                     cond$call), session = sessionInformation(), 
[16:59:39.309]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:39.309]                   signalCondition(cond)
[16:59:39.309]                 }
[16:59:39.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:39.309]                 "immediateCondition"))) {
[16:59:39.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:39.309]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:39.309]                   if (TRUE && !signal) {
[16:59:39.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.309]                     {
[16:59:39.309]                       inherits <- base::inherits
[16:59:39.309]                       invokeRestart <- base::invokeRestart
[16:59:39.309]                       is.null <- base::is.null
[16:59:39.309]                       muffled <- FALSE
[16:59:39.309]                       if (inherits(cond, "message")) {
[16:59:39.309]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.309]                         if (muffled) 
[16:59:39.309]                           invokeRestart("muffleMessage")
[16:59:39.309]                       }
[16:59:39.309]                       else if (inherits(cond, "warning")) {
[16:59:39.309]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.309]                         if (muffled) 
[16:59:39.309]                           invokeRestart("muffleWarning")
[16:59:39.309]                       }
[16:59:39.309]                       else if (inherits(cond, "condition")) {
[16:59:39.309]                         if (!is.null(pattern)) {
[16:59:39.309]                           computeRestarts <- base::computeRestarts
[16:59:39.309]                           grepl <- base::grepl
[16:59:39.309]                           restarts <- computeRestarts(cond)
[16:59:39.309]                           for (restart in restarts) {
[16:59:39.309]                             name <- restart$name
[16:59:39.309]                             if (is.null(name)) 
[16:59:39.309]                               next
[16:59:39.309]                             if (!grepl(pattern, name)) 
[16:59:39.309]                               next
[16:59:39.309]                             invokeRestart(restart)
[16:59:39.309]                             muffled <- TRUE
[16:59:39.309]                             break
[16:59:39.309]                           }
[16:59:39.309]                         }
[16:59:39.309]                       }
[16:59:39.309]                       invisible(muffled)
[16:59:39.309]                     }
[16:59:39.309]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.309]                   }
[16:59:39.309]                 }
[16:59:39.309]                 else {
[16:59:39.309]                   if (TRUE) {
[16:59:39.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.309]                     {
[16:59:39.309]                       inherits <- base::inherits
[16:59:39.309]                       invokeRestart <- base::invokeRestart
[16:59:39.309]                       is.null <- base::is.null
[16:59:39.309]                       muffled <- FALSE
[16:59:39.309]                       if (inherits(cond, "message")) {
[16:59:39.309]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.309]                         if (muffled) 
[16:59:39.309]                           invokeRestart("muffleMessage")
[16:59:39.309]                       }
[16:59:39.309]                       else if (inherits(cond, "warning")) {
[16:59:39.309]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.309]                         if (muffled) 
[16:59:39.309]                           invokeRestart("muffleWarning")
[16:59:39.309]                       }
[16:59:39.309]                       else if (inherits(cond, "condition")) {
[16:59:39.309]                         if (!is.null(pattern)) {
[16:59:39.309]                           computeRestarts <- base::computeRestarts
[16:59:39.309]                           grepl <- base::grepl
[16:59:39.309]                           restarts <- computeRestarts(cond)
[16:59:39.309]                           for (restart in restarts) {
[16:59:39.309]                             name <- restart$name
[16:59:39.309]                             if (is.null(name)) 
[16:59:39.309]                               next
[16:59:39.309]                             if (!grepl(pattern, name)) 
[16:59:39.309]                               next
[16:59:39.309]                             invokeRestart(restart)
[16:59:39.309]                             muffled <- TRUE
[16:59:39.309]                             break
[16:59:39.309]                           }
[16:59:39.309]                         }
[16:59:39.309]                       }
[16:59:39.309]                       invisible(muffled)
[16:59:39.309]                     }
[16:59:39.309]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.309]                   }
[16:59:39.309]                 }
[16:59:39.309]             }
[16:59:39.309]         }))
[16:59:39.309]     }, error = function(ex) {
[16:59:39.309]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:39.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.309]                 ...future.rng), started = ...future.startTime, 
[16:59:39.309]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:39.309]             version = "1.8"), class = "FutureResult")
[16:59:39.309]     }, finally = {
[16:59:39.309]         if (!identical(...future.workdir, getwd())) 
[16:59:39.309]             setwd(...future.workdir)
[16:59:39.309]         {
[16:59:39.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:39.309]                 ...future.oldOptions$nwarnings <- NULL
[16:59:39.309]             }
[16:59:39.309]             base::options(...future.oldOptions)
[16:59:39.309]             if (.Platform$OS.type == "windows") {
[16:59:39.309]                 old_names <- names(...future.oldEnvVars)
[16:59:39.309]                 envs <- base::Sys.getenv()
[16:59:39.309]                 names <- names(envs)
[16:59:39.309]                 common <- intersect(names, old_names)
[16:59:39.309]                 added <- setdiff(names, old_names)
[16:59:39.309]                 removed <- setdiff(old_names, names)
[16:59:39.309]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:39.309]                   envs[common]]
[16:59:39.309]                 NAMES <- toupper(changed)
[16:59:39.309]                 args <- list()
[16:59:39.309]                 for (kk in seq_along(NAMES)) {
[16:59:39.309]                   name <- changed[[kk]]
[16:59:39.309]                   NAME <- NAMES[[kk]]
[16:59:39.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.309]                     next
[16:59:39.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.309]                 }
[16:59:39.309]                 NAMES <- toupper(added)
[16:59:39.309]                 for (kk in seq_along(NAMES)) {
[16:59:39.309]                   name <- added[[kk]]
[16:59:39.309]                   NAME <- NAMES[[kk]]
[16:59:39.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.309]                     next
[16:59:39.309]                   args[[name]] <- ""
[16:59:39.309]                 }
[16:59:39.309]                 NAMES <- toupper(removed)
[16:59:39.309]                 for (kk in seq_along(NAMES)) {
[16:59:39.309]                   name <- removed[[kk]]
[16:59:39.309]                   NAME <- NAMES[[kk]]
[16:59:39.309]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.309]                     next
[16:59:39.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.309]                 }
[16:59:39.309]                 if (length(args) > 0) 
[16:59:39.309]                   base::do.call(base::Sys.setenv, args = args)
[16:59:39.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:39.309]             }
[16:59:39.309]             else {
[16:59:39.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:39.309]             }
[16:59:39.309]             {
[16:59:39.309]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:39.309]                   0L) {
[16:59:39.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:39.309]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:39.309]                   base::options(opts)
[16:59:39.309]                 }
[16:59:39.309]                 {
[16:59:39.309]                   {
[16:59:39.309]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:39.309]                     NULL
[16:59:39.309]                   }
[16:59:39.309]                   options(future.plan = NULL)
[16:59:39.309]                   if (is.na(NA_character_)) 
[16:59:39.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:39.309]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:39.309]                     .init = FALSE)
[16:59:39.309]                 }
[16:59:39.309]             }
[16:59:39.309]         }
[16:59:39.309]     })
[16:59:39.309]     if (TRUE) {
[16:59:39.309]         base::sink(type = "output", split = FALSE)
[16:59:39.309]         if (TRUE) {
[16:59:39.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:39.309]         }
[16:59:39.309]         else {
[16:59:39.309]             ...future.result["stdout"] <- base::list(NULL)
[16:59:39.309]         }
[16:59:39.309]         base::close(...future.stdout)
[16:59:39.309]         ...future.stdout <- NULL
[16:59:39.309]     }
[16:59:39.309]     ...future.result$conditions <- ...future.conditions
[16:59:39.309]     ...future.result$finished <- base::Sys.time()
[16:59:39.309]     ...future.result
[16:59:39.309] }
[16:59:39.312] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[16:59:39.312] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:59:39.312] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:59:39.313] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ...
[16:59:39.313] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ... DONE
[16:59:39.313] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:59:39.313] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:59:39.314] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:39.314] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:39.314] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:59:39.314] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:59:39.314] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[16:59:39.315] MultisessionFuture started
[16:59:39.315] - Launch lazy future ... done
[16:59:39.315] run() for ‘MultisessionFuture’ ... done
[16:59:39.315] Created future:
[16:59:39.315] MultisessionFuture:
[16:59:39.315] Label: ‘future_eapply-1’
[16:59:39.315] Expression:
[16:59:39.315] {
[16:59:39.315]     do.call(function(...) {
[16:59:39.315]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.315]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.315]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.315]             on.exit(options(oopts), add = TRUE)
[16:59:39.315]         }
[16:59:39.315]         {
[16:59:39.315]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.315]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.315]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.315]             })
[16:59:39.315]         }
[16:59:39.315]     }, args = future.call.arguments)
[16:59:39.315] }
[16:59:39.315] Lazy evaluation: FALSE
[16:59:39.315] Asynchronous evaluation: TRUE
[16:59:39.315] Local evaluation: TRUE
[16:59:39.315] Environment: R_GlobalEnv
[16:59:39.315] Capture standard output: TRUE
[16:59:39.315] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:39.315] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:39.315] Packages: 1 packages (‘stats’)
[16:59:39.315] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:39.315] Resolved: FALSE
[16:59:39.315] Value: <not collected>
[16:59:39.315] Conditions captured: <none>
[16:59:39.315] Early signaling: FALSE
[16:59:39.315] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:39.315] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.327] Chunk #1 of 2 ... DONE
[16:59:39.327] Chunk #2 of 2 ...
[16:59:39.327]  - Finding globals in 'X' for chunk #2 ...
[16:59:39.327] getGlobalsAndPackages() ...
[16:59:39.327] Searching for globals...
[16:59:39.328] 
[16:59:39.328] Searching for globals ... DONE
[16:59:39.328] - globals: [0] <none>
[16:59:39.328] getGlobalsAndPackages() ... DONE
[16:59:39.328]    + additional globals found: [n=0] 
[16:59:39.328]    + additional namespaces needed: [n=0] 
[16:59:39.328]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:39.328]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:39.328]  - seeds: <none>
[16:59:39.328]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.329] getGlobalsAndPackages() ...
[16:59:39.329] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.329] Resolving globals: FALSE
[16:59:39.329] Tweak future expression to call with '...' arguments ...
[16:59:39.329] {
[16:59:39.329]     do.call(function(...) {
[16:59:39.329]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.329]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.329]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.329]             on.exit(options(oopts), add = TRUE)
[16:59:39.329]         }
[16:59:39.329]         {
[16:59:39.329]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.329]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.329]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.329]             })
[16:59:39.329]         }
[16:59:39.329]     }, args = future.call.arguments)
[16:59:39.329] }
[16:59:39.329] Tweak future expression to call with '...' arguments ... DONE
[16:59:39.330] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.330] - packages: [1] ‘stats’
[16:59:39.330] getGlobalsAndPackages() ... DONE
[16:59:39.330] run() for ‘Future’ ...
[16:59:39.330] - state: ‘created’
[16:59:39.330] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:39.344] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.344] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:39.344]   - Field: ‘node’
[16:59:39.344]   - Field: ‘label’
[16:59:39.344]   - Field: ‘local’
[16:59:39.344]   - Field: ‘owner’
[16:59:39.344]   - Field: ‘envir’
[16:59:39.345]   - Field: ‘workers’
[16:59:39.345]   - Field: ‘packages’
[16:59:39.345]   - Field: ‘gc’
[16:59:39.345]   - Field: ‘conditions’
[16:59:39.345]   - Field: ‘persistent’
[16:59:39.345]   - Field: ‘expr’
[16:59:39.345]   - Field: ‘uuid’
[16:59:39.345]   - Field: ‘seed’
[16:59:39.345]   - Field: ‘version’
[16:59:39.345]   - Field: ‘result’
[16:59:39.345]   - Field: ‘asynchronous’
[16:59:39.345]   - Field: ‘calls’
[16:59:39.346]   - Field: ‘globals’
[16:59:39.346]   - Field: ‘stdout’
[16:59:39.346]   - Field: ‘earlySignal’
[16:59:39.346]   - Field: ‘lazy’
[16:59:39.346]   - Field: ‘state’
[16:59:39.346] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:39.346] - Launch lazy future ...
[16:59:39.346] Packages needed by the future expression (n = 1): ‘stats’
[16:59:39.347] Packages needed by future strategies (n = 0): <none>
[16:59:39.347] {
[16:59:39.347]     {
[16:59:39.347]         {
[16:59:39.347]             ...future.startTime <- base::Sys.time()
[16:59:39.347]             {
[16:59:39.347]                 {
[16:59:39.347]                   {
[16:59:39.347]                     {
[16:59:39.347]                       {
[16:59:39.347]                         base::local({
[16:59:39.347]                           has_future <- base::requireNamespace("future", 
[16:59:39.347]                             quietly = TRUE)
[16:59:39.347]                           if (has_future) {
[16:59:39.347]                             ns <- base::getNamespace("future")
[16:59:39.347]                             version <- ns[[".package"]][["version"]]
[16:59:39.347]                             if (is.null(version)) 
[16:59:39.347]                               version <- utils::packageVersion("future")
[16:59:39.347]                           }
[16:59:39.347]                           else {
[16:59:39.347]                             version <- NULL
[16:59:39.347]                           }
[16:59:39.347]                           if (!has_future || version < "1.8.0") {
[16:59:39.347]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:39.347]                               "", base::R.version$version.string), 
[16:59:39.347]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:39.347]                                 base::R.version$platform, 8 * 
[16:59:39.347]                                   base::.Machine$sizeof.pointer), 
[16:59:39.347]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:39.347]                                 "release", "version")], collapse = " "), 
[16:59:39.347]                               hostname = base::Sys.info()[["nodename"]])
[16:59:39.347]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:39.347]                               info)
[16:59:39.347]                             info <- base::paste(info, collapse = "; ")
[16:59:39.347]                             if (!has_future) {
[16:59:39.347]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:39.347]                                 info)
[16:59:39.347]                             }
[16:59:39.347]                             else {
[16:59:39.347]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:39.347]                                 info, version)
[16:59:39.347]                             }
[16:59:39.347]                             base::stop(msg)
[16:59:39.347]                           }
[16:59:39.347]                         })
[16:59:39.347]                       }
[16:59:39.347]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:39.347]                       base::options(mc.cores = 1L)
[16:59:39.347]                     }
[16:59:39.347]                     base::local({
[16:59:39.347]                       for (pkg in "stats") {
[16:59:39.347]                         base::loadNamespace(pkg)
[16:59:39.347]                         base::library(pkg, character.only = TRUE)
[16:59:39.347]                       }
[16:59:39.347]                     })
[16:59:39.347]                   }
[16:59:39.347]                   ...future.strategy.old <- future::plan("list")
[16:59:39.347]                   options(future.plan = NULL)
[16:59:39.347]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.347]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:39.347]                 }
[16:59:39.347]                 ...future.workdir <- getwd()
[16:59:39.347]             }
[16:59:39.347]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:39.347]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:39.347]         }
[16:59:39.347]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:39.347]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:39.347]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:39.347]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:39.347]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:39.347]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:39.347]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:39.347]             base::names(...future.oldOptions))
[16:59:39.347]     }
[16:59:39.347]     if (FALSE) {
[16:59:39.347]     }
[16:59:39.347]     else {
[16:59:39.347]         if (TRUE) {
[16:59:39.347]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:39.347]                 open = "w")
[16:59:39.347]         }
[16:59:39.347]         else {
[16:59:39.347]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:39.347]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:39.347]         }
[16:59:39.347]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:39.347]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:39.347]             base::sink(type = "output", split = FALSE)
[16:59:39.347]             base::close(...future.stdout)
[16:59:39.347]         }, add = TRUE)
[16:59:39.347]     }
[16:59:39.347]     ...future.frame <- base::sys.nframe()
[16:59:39.347]     ...future.conditions <- base::list()
[16:59:39.347]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:39.347]     if (FALSE) {
[16:59:39.347]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:39.347]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:39.347]     }
[16:59:39.347]     ...future.result <- base::tryCatch({
[16:59:39.347]         base::withCallingHandlers({
[16:59:39.347]             ...future.value <- base::withVisible(base::local({
[16:59:39.347]                 ...future.makeSendCondition <- base::local({
[16:59:39.347]                   sendCondition <- NULL
[16:59:39.347]                   function(frame = 1L) {
[16:59:39.347]                     if (is.function(sendCondition)) 
[16:59:39.347]                       return(sendCondition)
[16:59:39.347]                     ns <- getNamespace("parallel")
[16:59:39.347]                     if (exists("sendData", mode = "function", 
[16:59:39.347]                       envir = ns)) {
[16:59:39.347]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:39.347]                         envir = ns)
[16:59:39.347]                       envir <- sys.frame(frame)
[16:59:39.347]                       master <- NULL
[16:59:39.347]                       while (!identical(envir, .GlobalEnv) && 
[16:59:39.347]                         !identical(envir, emptyenv())) {
[16:59:39.347]                         if (exists("master", mode = "list", envir = envir, 
[16:59:39.347]                           inherits = FALSE)) {
[16:59:39.347]                           master <- get("master", mode = "list", 
[16:59:39.347]                             envir = envir, inherits = FALSE)
[16:59:39.347]                           if (inherits(master, c("SOCKnode", 
[16:59:39.347]                             "SOCK0node"))) {
[16:59:39.347]                             sendCondition <<- function(cond) {
[16:59:39.347]                               data <- list(type = "VALUE", value = cond, 
[16:59:39.347]                                 success = TRUE)
[16:59:39.347]                               parallel_sendData(master, data)
[16:59:39.347]                             }
[16:59:39.347]                             return(sendCondition)
[16:59:39.347]                           }
[16:59:39.347]                         }
[16:59:39.347]                         frame <- frame + 1L
[16:59:39.347]                         envir <- sys.frame(frame)
[16:59:39.347]                       }
[16:59:39.347]                     }
[16:59:39.347]                     sendCondition <<- function(cond) NULL
[16:59:39.347]                   }
[16:59:39.347]                 })
[16:59:39.347]                 withCallingHandlers({
[16:59:39.347]                   {
[16:59:39.347]                     do.call(function(...) {
[16:59:39.347]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.347]                       if (!identical(...future.globals.maxSize.org, 
[16:59:39.347]                         ...future.globals.maxSize)) {
[16:59:39.347]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.347]                         on.exit(options(oopts), add = TRUE)
[16:59:39.347]                       }
[16:59:39.347]                       {
[16:59:39.347]                         lapply(seq_along(...future.elements_ii), 
[16:59:39.347]                           FUN = function(jj) {
[16:59:39.347]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.347]                             ...future.FUN(...future.X_jj, ...)
[16:59:39.347]                           })
[16:59:39.347]                       }
[16:59:39.347]                     }, args = future.call.arguments)
[16:59:39.347]                   }
[16:59:39.347]                 }, immediateCondition = function(cond) {
[16:59:39.347]                   sendCondition <- ...future.makeSendCondition()
[16:59:39.347]                   sendCondition(cond)
[16:59:39.347]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.347]                   {
[16:59:39.347]                     inherits <- base::inherits
[16:59:39.347]                     invokeRestart <- base::invokeRestart
[16:59:39.347]                     is.null <- base::is.null
[16:59:39.347]                     muffled <- FALSE
[16:59:39.347]                     if (inherits(cond, "message")) {
[16:59:39.347]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:39.347]                       if (muffled) 
[16:59:39.347]                         invokeRestart("muffleMessage")
[16:59:39.347]                     }
[16:59:39.347]                     else if (inherits(cond, "warning")) {
[16:59:39.347]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:39.347]                       if (muffled) 
[16:59:39.347]                         invokeRestart("muffleWarning")
[16:59:39.347]                     }
[16:59:39.347]                     else if (inherits(cond, "condition")) {
[16:59:39.347]                       if (!is.null(pattern)) {
[16:59:39.347]                         computeRestarts <- base::computeRestarts
[16:59:39.347]                         grepl <- base::grepl
[16:59:39.347]                         restarts <- computeRestarts(cond)
[16:59:39.347]                         for (restart in restarts) {
[16:59:39.347]                           name <- restart$name
[16:59:39.347]                           if (is.null(name)) 
[16:59:39.347]                             next
[16:59:39.347]                           if (!grepl(pattern, name)) 
[16:59:39.347]                             next
[16:59:39.347]                           invokeRestart(restart)
[16:59:39.347]                           muffled <- TRUE
[16:59:39.347]                           break
[16:59:39.347]                         }
[16:59:39.347]                       }
[16:59:39.347]                     }
[16:59:39.347]                     invisible(muffled)
[16:59:39.347]                   }
[16:59:39.347]                   muffleCondition(cond)
[16:59:39.347]                 })
[16:59:39.347]             }))
[16:59:39.347]             future::FutureResult(value = ...future.value$value, 
[16:59:39.347]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.347]                   ...future.rng), globalenv = if (FALSE) 
[16:59:39.347]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:39.347]                     ...future.globalenv.names))
[16:59:39.347]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:39.347]         }, condition = base::local({
[16:59:39.347]             c <- base::c
[16:59:39.347]             inherits <- base::inherits
[16:59:39.347]             invokeRestart <- base::invokeRestart
[16:59:39.347]             length <- base::length
[16:59:39.347]             list <- base::list
[16:59:39.347]             seq.int <- base::seq.int
[16:59:39.347]             signalCondition <- base::signalCondition
[16:59:39.347]             sys.calls <- base::sys.calls
[16:59:39.347]             `[[` <- base::`[[`
[16:59:39.347]             `+` <- base::`+`
[16:59:39.347]             `<<-` <- base::`<<-`
[16:59:39.347]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:39.347]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:39.347]                   3L)]
[16:59:39.347]             }
[16:59:39.347]             function(cond) {
[16:59:39.347]                 is_error <- inherits(cond, "error")
[16:59:39.347]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:39.347]                   NULL)
[16:59:39.347]                 if (is_error) {
[16:59:39.347]                   sessionInformation <- function() {
[16:59:39.347]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:39.347]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:39.347]                       search = base::search(), system = base::Sys.info())
[16:59:39.347]                   }
[16:59:39.347]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.347]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:39.347]                     cond$call), session = sessionInformation(), 
[16:59:39.347]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:39.347]                   signalCondition(cond)
[16:59:39.347]                 }
[16:59:39.347]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:39.347]                 "immediateCondition"))) {
[16:59:39.347]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:39.347]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.347]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:39.347]                   if (TRUE && !signal) {
[16:59:39.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.347]                     {
[16:59:39.347]                       inherits <- base::inherits
[16:59:39.347]                       invokeRestart <- base::invokeRestart
[16:59:39.347]                       is.null <- base::is.null
[16:59:39.347]                       muffled <- FALSE
[16:59:39.347]                       if (inherits(cond, "message")) {
[16:59:39.347]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.347]                         if (muffled) 
[16:59:39.347]                           invokeRestart("muffleMessage")
[16:59:39.347]                       }
[16:59:39.347]                       else if (inherits(cond, "warning")) {
[16:59:39.347]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.347]                         if (muffled) 
[16:59:39.347]                           invokeRestart("muffleWarning")
[16:59:39.347]                       }
[16:59:39.347]                       else if (inherits(cond, "condition")) {
[16:59:39.347]                         if (!is.null(pattern)) {
[16:59:39.347]                           computeRestarts <- base::computeRestarts
[16:59:39.347]                           grepl <- base::grepl
[16:59:39.347]                           restarts <- computeRestarts(cond)
[16:59:39.347]                           for (restart in restarts) {
[16:59:39.347]                             name <- restart$name
[16:59:39.347]                             if (is.null(name)) 
[16:59:39.347]                               next
[16:59:39.347]                             if (!grepl(pattern, name)) 
[16:59:39.347]                               next
[16:59:39.347]                             invokeRestart(restart)
[16:59:39.347]                             muffled <- TRUE
[16:59:39.347]                             break
[16:59:39.347]                           }
[16:59:39.347]                         }
[16:59:39.347]                       }
[16:59:39.347]                       invisible(muffled)
[16:59:39.347]                     }
[16:59:39.347]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.347]                   }
[16:59:39.347]                 }
[16:59:39.347]                 else {
[16:59:39.347]                   if (TRUE) {
[16:59:39.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.347]                     {
[16:59:39.347]                       inherits <- base::inherits
[16:59:39.347]                       invokeRestart <- base::invokeRestart
[16:59:39.347]                       is.null <- base::is.null
[16:59:39.347]                       muffled <- FALSE
[16:59:39.347]                       if (inherits(cond, "message")) {
[16:59:39.347]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.347]                         if (muffled) 
[16:59:39.347]                           invokeRestart("muffleMessage")
[16:59:39.347]                       }
[16:59:39.347]                       else if (inherits(cond, "warning")) {
[16:59:39.347]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.347]                         if (muffled) 
[16:59:39.347]                           invokeRestart("muffleWarning")
[16:59:39.347]                       }
[16:59:39.347]                       else if (inherits(cond, "condition")) {
[16:59:39.347]                         if (!is.null(pattern)) {
[16:59:39.347]                           computeRestarts <- base::computeRestarts
[16:59:39.347]                           grepl <- base::grepl
[16:59:39.347]                           restarts <- computeRestarts(cond)
[16:59:39.347]                           for (restart in restarts) {
[16:59:39.347]                             name <- restart$name
[16:59:39.347]                             if (is.null(name)) 
[16:59:39.347]                               next
[16:59:39.347]                             if (!grepl(pattern, name)) 
[16:59:39.347]                               next
[16:59:39.347]                             invokeRestart(restart)
[16:59:39.347]                             muffled <- TRUE
[16:59:39.347]                             break
[16:59:39.347]                           }
[16:59:39.347]                         }
[16:59:39.347]                       }
[16:59:39.347]                       invisible(muffled)
[16:59:39.347]                     }
[16:59:39.347]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.347]                   }
[16:59:39.347]                 }
[16:59:39.347]             }
[16:59:39.347]         }))
[16:59:39.347]     }, error = function(ex) {
[16:59:39.347]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:39.347]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.347]                 ...future.rng), started = ...future.startTime, 
[16:59:39.347]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:39.347]             version = "1.8"), class = "FutureResult")
[16:59:39.347]     }, finally = {
[16:59:39.347]         if (!identical(...future.workdir, getwd())) 
[16:59:39.347]             setwd(...future.workdir)
[16:59:39.347]         {
[16:59:39.347]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:39.347]                 ...future.oldOptions$nwarnings <- NULL
[16:59:39.347]             }
[16:59:39.347]             base::options(...future.oldOptions)
[16:59:39.347]             if (.Platform$OS.type == "windows") {
[16:59:39.347]                 old_names <- names(...future.oldEnvVars)
[16:59:39.347]                 envs <- base::Sys.getenv()
[16:59:39.347]                 names <- names(envs)
[16:59:39.347]                 common <- intersect(names, old_names)
[16:59:39.347]                 added <- setdiff(names, old_names)
[16:59:39.347]                 removed <- setdiff(old_names, names)
[16:59:39.347]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:39.347]                   envs[common]]
[16:59:39.347]                 NAMES <- toupper(changed)
[16:59:39.347]                 args <- list()
[16:59:39.347]                 for (kk in seq_along(NAMES)) {
[16:59:39.347]                   name <- changed[[kk]]
[16:59:39.347]                   NAME <- NAMES[[kk]]
[16:59:39.347]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.347]                     next
[16:59:39.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.347]                 }
[16:59:39.347]                 NAMES <- toupper(added)
[16:59:39.347]                 for (kk in seq_along(NAMES)) {
[16:59:39.347]                   name <- added[[kk]]
[16:59:39.347]                   NAME <- NAMES[[kk]]
[16:59:39.347]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.347]                     next
[16:59:39.347]                   args[[name]] <- ""
[16:59:39.347]                 }
[16:59:39.347]                 NAMES <- toupper(removed)
[16:59:39.347]                 for (kk in seq_along(NAMES)) {
[16:59:39.347]                   name <- removed[[kk]]
[16:59:39.347]                   NAME <- NAMES[[kk]]
[16:59:39.347]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.347]                     next
[16:59:39.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.347]                 }
[16:59:39.347]                 if (length(args) > 0) 
[16:59:39.347]                   base::do.call(base::Sys.setenv, args = args)
[16:59:39.347]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:39.347]             }
[16:59:39.347]             else {
[16:59:39.347]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:39.347]             }
[16:59:39.347]             {
[16:59:39.347]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:39.347]                   0L) {
[16:59:39.347]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:39.347]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:39.347]                   base::options(opts)
[16:59:39.347]                 }
[16:59:39.347]                 {
[16:59:39.347]                   {
[16:59:39.347]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:39.347]                     NULL
[16:59:39.347]                   }
[16:59:39.347]                   options(future.plan = NULL)
[16:59:39.347]                   if (is.na(NA_character_)) 
[16:59:39.347]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.347]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:39.347]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:39.347]                     .init = FALSE)
[16:59:39.347]                 }
[16:59:39.347]             }
[16:59:39.347]         }
[16:59:39.347]     })
[16:59:39.347]     if (TRUE) {
[16:59:39.347]         base::sink(type = "output", split = FALSE)
[16:59:39.347]         if (TRUE) {
[16:59:39.347]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:39.347]         }
[16:59:39.347]         else {
[16:59:39.347]             ...future.result["stdout"] <- base::list(NULL)
[16:59:39.347]         }
[16:59:39.347]         base::close(...future.stdout)
[16:59:39.347]         ...future.stdout <- NULL
[16:59:39.347]     }
[16:59:39.347]     ...future.result$conditions <- ...future.conditions
[16:59:39.347]     ...future.result$finished <- base::Sys.time()
[16:59:39.347]     ...future.result
[16:59:39.347] }
[16:59:39.350] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[16:59:39.350] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:59:39.350] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:59:39.350] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ...
[16:59:39.351] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ... DONE
[16:59:39.351] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:59:39.351] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:59:39.351] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:39.352] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:39.352] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:59:39.352] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:59:39.352] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[16:59:39.353] MultisessionFuture started
[16:59:39.353] - Launch lazy future ... done
[16:59:39.353] run() for ‘MultisessionFuture’ ... done
[16:59:39.353] Created future:
[16:59:39.353] MultisessionFuture:
[16:59:39.353] Label: ‘future_eapply-2’
[16:59:39.353] Expression:
[16:59:39.353] {
[16:59:39.353]     do.call(function(...) {
[16:59:39.353]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.353]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.353]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.353]             on.exit(options(oopts), add = TRUE)
[16:59:39.353]         }
[16:59:39.353]         {
[16:59:39.353]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.353]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.353]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.353]             })
[16:59:39.353]         }
[16:59:39.353]     }, args = future.call.arguments)
[16:59:39.353] }
[16:59:39.353] Lazy evaluation: FALSE
[16:59:39.353] Asynchronous evaluation: TRUE
[16:59:39.353] Local evaluation: TRUE
[16:59:39.353] Environment: R_GlobalEnv
[16:59:39.353] Capture standard output: TRUE
[16:59:39.353] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:39.353] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:39.353] Packages: 1 packages (‘stats’)
[16:59:39.353] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:39.353] Resolved: FALSE
[16:59:39.353] Value: <not collected>
[16:59:39.353] Conditions captured: <none>
[16:59:39.353] Early signaling: FALSE
[16:59:39.353] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:39.353] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.365] Chunk #2 of 2 ... DONE
[16:59:39.365] Launching 2 futures (chunks) ... DONE
[16:59:39.365] Resolving 2 futures (chunks) ...
[16:59:39.365] resolve() on list ...
[16:59:39.365]  recursive: 0
[16:59:39.365]  length: 2
[16:59:39.365] 
[16:59:39.366] receiveMessageFromWorker() for ClusterFuture ...
[16:59:39.366] - Validating connection of MultisessionFuture
[16:59:39.366] - received message: FutureResult
[16:59:39.366] - Received FutureResult
[16:59:39.366] - Erased future from FutureRegistry
[16:59:39.366] result() for ClusterFuture ...
[16:59:39.367] - result already collected: FutureResult
[16:59:39.367] result() for ClusterFuture ... done
[16:59:39.367] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:39.367] Future #1
[16:59:39.367] result() for ClusterFuture ...
[16:59:39.367] - result already collected: FutureResult
[16:59:39.367] result() for ClusterFuture ... done
[16:59:39.367] result() for ClusterFuture ...
[16:59:39.367] - result already collected: FutureResult
[16:59:39.367] result() for ClusterFuture ... done
[16:59:39.367] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:39.368] - nx: 2
[16:59:39.368] - relay: TRUE
[16:59:39.368] - stdout: TRUE
[16:59:39.368] - signal: TRUE
[16:59:39.368] - resignal: FALSE
[16:59:39.368] - force: TRUE
[16:59:39.368] - relayed: [n=2] FALSE, FALSE
[16:59:39.368] - queued futures: [n=2] FALSE, FALSE
[16:59:39.368]  - until=1
[16:59:39.368]  - relaying element #1
[16:59:39.368] result() for ClusterFuture ...
[16:59:39.368] - result already collected: FutureResult
[16:59:39.369] result() for ClusterFuture ... done
[16:59:39.369] result() for ClusterFuture ...
[16:59:39.369] - result already collected: FutureResult
[16:59:39.369] result() for ClusterFuture ... done
[16:59:39.369] result() for ClusterFuture ...
[16:59:39.369] - result already collected: FutureResult
[16:59:39.369] result() for ClusterFuture ... done
[16:59:39.369] result() for ClusterFuture ...
[16:59:39.369] - result already collected: FutureResult
[16:59:39.369] result() for ClusterFuture ... done
[16:59:39.369] - relayed: [n=2] TRUE, FALSE
[16:59:39.370] - queued futures: [n=2] TRUE, FALSE
[16:59:39.370] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:39.370]  length: 1 (resolved future 1)
[16:59:39.411] receiveMessageFromWorker() for ClusterFuture ...
[16:59:39.412] - Validating connection of MultisessionFuture
[16:59:39.412] - received message: FutureResult
[16:59:39.412] - Received FutureResult
[16:59:39.412] - Erased future from FutureRegistry
[16:59:39.412] result() for ClusterFuture ...
[16:59:39.412] - result already collected: FutureResult
[16:59:39.412] result() for ClusterFuture ... done
[16:59:39.412] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:39.412] Future #2
[16:59:39.412] result() for ClusterFuture ...
[16:59:39.413] - result already collected: FutureResult
[16:59:39.413] result() for ClusterFuture ... done
[16:59:39.413] result() for ClusterFuture ...
[16:59:39.413] - result already collected: FutureResult
[16:59:39.413] result() for ClusterFuture ... done
[16:59:39.413] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:39.413] - nx: 2
[16:59:39.413] - relay: TRUE
[16:59:39.413] - stdout: TRUE
[16:59:39.413] - signal: TRUE
[16:59:39.413] - resignal: FALSE
[16:59:39.413] - force: TRUE
[16:59:39.414] - relayed: [n=2] TRUE, FALSE
[16:59:39.414] - queued futures: [n=2] TRUE, FALSE
[16:59:39.414]  - until=2
[16:59:39.414]  - relaying element #2
[16:59:39.414] result() for ClusterFuture ...
[16:59:39.414] - result already collected: FutureResult
[16:59:39.414] result() for ClusterFuture ... done
[16:59:39.414] result() for ClusterFuture ...
[16:59:39.414] - result already collected: FutureResult
[16:59:39.414] result() for ClusterFuture ... done
[16:59:39.414] result() for ClusterFuture ...
[16:59:39.415] - result already collected: FutureResult
[16:59:39.415] result() for ClusterFuture ... done
[16:59:39.415] result() for ClusterFuture ...
[16:59:39.415] - result already collected: FutureResult
[16:59:39.415] result() for ClusterFuture ... done
[16:59:39.415] - relayed: [n=2] TRUE, TRUE
[16:59:39.415] - queued futures: [n=2] TRUE, TRUE
[16:59:39.415] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:39.415]  length: 0 (resolved future 2)
[16:59:39.415] Relaying remaining futures
[16:59:39.415] signalConditionsASAP(NULL, pos=0) ...
[16:59:39.416] - nx: 2
[16:59:39.416] - relay: TRUE
[16:59:39.416] - stdout: TRUE
[16:59:39.416] - signal: TRUE
[16:59:39.416] - resignal: FALSE
[16:59:39.416] - force: TRUE
[16:59:39.416] - relayed: [n=2] TRUE, TRUE
[16:59:39.416] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:39.416] - relayed: [n=2] TRUE, TRUE
[16:59:39.416] - queued futures: [n=2] TRUE, TRUE
[16:59:39.416] signalConditionsASAP(NULL, pos=0) ... done
[16:59:39.416] resolve() on list ... DONE
[16:59:39.417] result() for ClusterFuture ...
[16:59:39.417] - result already collected: FutureResult
[16:59:39.417] result() for ClusterFuture ... done
[16:59:39.417] result() for ClusterFuture ...
[16:59:39.417] - result already collected: FutureResult
[16:59:39.417] result() for ClusterFuture ... done
[16:59:39.417] result() for ClusterFuture ...
[16:59:39.417] - result already collected: FutureResult
[16:59:39.417] result() for ClusterFuture ... done
[16:59:39.417] result() for ClusterFuture ...
[16:59:39.417] - result already collected: FutureResult
[16:59:39.418] result() for ClusterFuture ... done
[16:59:39.418]  - Number of value chunks collected: 2
[16:59:39.418] Resolving 2 futures (chunks) ... DONE
[16:59:39.418] Reducing values from 2 chunks ...
[16:59:39.418]  - Number of values collected after concatenation: 3
[16:59:39.418]  - Number of values expected: 3
[16:59:39.418] Reducing values from 2 chunks ... DONE
[16:59:39.418] future_lapply() ... DONE
[16:59:39.419] future_lapply() ...
[16:59:39.423] Number of chunks: 2
[16:59:39.423] getGlobalsAndPackagesXApply() ...
[16:59:39.423]  - future.globals: TRUE
[16:59:39.423] getGlobalsAndPackages() ...
[16:59:39.423] Searching for globals...
[16:59:39.424] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:39.424] Searching for globals ... DONE
[16:59:39.425] Resolving globals: FALSE
[16:59:39.425] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:59:39.425] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:59:39.425] - globals: [1] ‘FUN’
[16:59:39.426] - packages: [1] ‘stats’
[16:59:39.426] getGlobalsAndPackages() ... DONE
[16:59:39.426]  - globals found/used: [n=1] ‘FUN’
[16:59:39.426]  - needed namespaces: [n=1] ‘stats’
[16:59:39.426] Finding globals ... DONE
[16:59:39.426]  - use_args: TRUE
[16:59:39.426]  - Getting '...' globals ...
[16:59:39.426] resolve() on list ...
[16:59:39.426]  recursive: 0
[16:59:39.427]  length: 1
[16:59:39.427]  elements: ‘...’
[16:59:39.427]  length: 0 (resolved future 1)
[16:59:39.427] resolve() on list ... DONE
[16:59:39.427]    - '...' content: [n=0] 
[16:59:39.427] List of 1
[16:59:39.427]  $ ...: list()
[16:59:39.427]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:39.427]  - attr(*, "where")=List of 1
[16:59:39.427]   ..$ ...:<environment: 0x55c34aa99330> 
[16:59:39.427]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:39.427]  - attr(*, "resolved")= logi TRUE
[16:59:39.427]  - attr(*, "total_size")= num NA
[16:59:39.429]  - Getting '...' globals ... DONE
[16:59:39.435] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:39.435] List of 2
[16:59:39.435]  $ ...future.FUN:function (x, ...)  
[16:59:39.435]  $ ...          : list()
[16:59:39.435]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:39.435]  - attr(*, "where")=List of 2
[16:59:39.435]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:39.435]   ..$ ...          :<environment: 0x55c34aa99330> 
[16:59:39.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:39.435]  - attr(*, "resolved")= logi FALSE
[16:59:39.435]  - attr(*, "total_size")= num 1248
[16:59:39.437] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:39.438] getGlobalsAndPackagesXApply() ... DONE
[16:59:39.438] Number of futures (= number of chunks): 2
[16:59:39.438] Launching 2 futures (chunks) ...
[16:59:39.438] Chunk #1 of 2 ...
[16:59:39.438]  - Finding globals in 'X' for chunk #1 ...
[16:59:39.438] getGlobalsAndPackages() ...
[16:59:39.438] Searching for globals...
[16:59:39.439] 
[16:59:39.439] Searching for globals ... DONE
[16:59:39.439] - globals: [0] <none>
[16:59:39.439] getGlobalsAndPackages() ... DONE
[16:59:39.439]    + additional globals found: [n=0] 
[16:59:39.439]    + additional namespaces needed: [n=0] 
[16:59:39.439]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:39.439]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:39.439]  - seeds: <none>
[16:59:39.439]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.439] getGlobalsAndPackages() ...
[16:59:39.440] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.440] Resolving globals: FALSE
[16:59:39.440] Tweak future expression to call with '...' arguments ...
[16:59:39.440] {
[16:59:39.440]     do.call(function(...) {
[16:59:39.440]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.440]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.440]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.440]             on.exit(options(oopts), add = TRUE)
[16:59:39.440]         }
[16:59:39.440]         {
[16:59:39.440]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.440]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.440]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.440]             })
[16:59:39.440]         }
[16:59:39.440]     }, args = future.call.arguments)
[16:59:39.440] }
[16:59:39.440] Tweak future expression to call with '...' arguments ... DONE
[16:59:39.440] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.441] - packages: [1] ‘stats’
[16:59:39.441] getGlobalsAndPackages() ... DONE
[16:59:39.441] run() for ‘Future’ ...
[16:59:39.441] - state: ‘created’
[16:59:39.441] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:39.454] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:39.455]   - Field: ‘node’
[16:59:39.455]   - Field: ‘label’
[16:59:39.455]   - Field: ‘local’
[16:59:39.455]   - Field: ‘owner’
[16:59:39.455]   - Field: ‘envir’
[16:59:39.455]   - Field: ‘workers’
[16:59:39.455]   - Field: ‘packages’
[16:59:39.455]   - Field: ‘gc’
[16:59:39.456]   - Field: ‘conditions’
[16:59:39.456]   - Field: ‘persistent’
[16:59:39.456]   - Field: ‘expr’
[16:59:39.456]   - Field: ‘uuid’
[16:59:39.456]   - Field: ‘seed’
[16:59:39.456]   - Field: ‘version’
[16:59:39.456]   - Field: ‘result’
[16:59:39.456]   - Field: ‘asynchronous’
[16:59:39.456]   - Field: ‘calls’
[16:59:39.456]   - Field: ‘globals’
[16:59:39.456]   - Field: ‘stdout’
[16:59:39.456]   - Field: ‘earlySignal’
[16:59:39.457]   - Field: ‘lazy’
[16:59:39.457]   - Field: ‘state’
[16:59:39.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:39.457] - Launch lazy future ...
[16:59:39.457] Packages needed by the future expression (n = 1): ‘stats’
[16:59:39.457] Packages needed by future strategies (n = 0): <none>
[16:59:39.458] {
[16:59:39.458]     {
[16:59:39.458]         {
[16:59:39.458]             ...future.startTime <- base::Sys.time()
[16:59:39.458]             {
[16:59:39.458]                 {
[16:59:39.458]                   {
[16:59:39.458]                     {
[16:59:39.458]                       {
[16:59:39.458]                         base::local({
[16:59:39.458]                           has_future <- base::requireNamespace("future", 
[16:59:39.458]                             quietly = TRUE)
[16:59:39.458]                           if (has_future) {
[16:59:39.458]                             ns <- base::getNamespace("future")
[16:59:39.458]                             version <- ns[[".package"]][["version"]]
[16:59:39.458]                             if (is.null(version)) 
[16:59:39.458]                               version <- utils::packageVersion("future")
[16:59:39.458]                           }
[16:59:39.458]                           else {
[16:59:39.458]                             version <- NULL
[16:59:39.458]                           }
[16:59:39.458]                           if (!has_future || version < "1.8.0") {
[16:59:39.458]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:39.458]                               "", base::R.version$version.string), 
[16:59:39.458]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:39.458]                                 base::R.version$platform, 8 * 
[16:59:39.458]                                   base::.Machine$sizeof.pointer), 
[16:59:39.458]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:39.458]                                 "release", "version")], collapse = " "), 
[16:59:39.458]                               hostname = base::Sys.info()[["nodename"]])
[16:59:39.458]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:39.458]                               info)
[16:59:39.458]                             info <- base::paste(info, collapse = "; ")
[16:59:39.458]                             if (!has_future) {
[16:59:39.458]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:39.458]                                 info)
[16:59:39.458]                             }
[16:59:39.458]                             else {
[16:59:39.458]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:39.458]                                 info, version)
[16:59:39.458]                             }
[16:59:39.458]                             base::stop(msg)
[16:59:39.458]                           }
[16:59:39.458]                         })
[16:59:39.458]                       }
[16:59:39.458]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:39.458]                       base::options(mc.cores = 1L)
[16:59:39.458]                     }
[16:59:39.458]                     base::local({
[16:59:39.458]                       for (pkg in "stats") {
[16:59:39.458]                         base::loadNamespace(pkg)
[16:59:39.458]                         base::library(pkg, character.only = TRUE)
[16:59:39.458]                       }
[16:59:39.458]                     })
[16:59:39.458]                   }
[16:59:39.458]                   ...future.strategy.old <- future::plan("list")
[16:59:39.458]                   options(future.plan = NULL)
[16:59:39.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:39.458]                 }
[16:59:39.458]                 ...future.workdir <- getwd()
[16:59:39.458]             }
[16:59:39.458]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:39.458]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:39.458]         }
[16:59:39.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:39.458]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:39.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:39.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:39.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:39.458]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:39.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:39.458]             base::names(...future.oldOptions))
[16:59:39.458]     }
[16:59:39.458]     if (FALSE) {
[16:59:39.458]     }
[16:59:39.458]     else {
[16:59:39.458]         if (TRUE) {
[16:59:39.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:39.458]                 open = "w")
[16:59:39.458]         }
[16:59:39.458]         else {
[16:59:39.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:39.458]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:39.458]         }
[16:59:39.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:39.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:39.458]             base::sink(type = "output", split = FALSE)
[16:59:39.458]             base::close(...future.stdout)
[16:59:39.458]         }, add = TRUE)
[16:59:39.458]     }
[16:59:39.458]     ...future.frame <- base::sys.nframe()
[16:59:39.458]     ...future.conditions <- base::list()
[16:59:39.458]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:39.458]     if (FALSE) {
[16:59:39.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:39.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:39.458]     }
[16:59:39.458]     ...future.result <- base::tryCatch({
[16:59:39.458]         base::withCallingHandlers({
[16:59:39.458]             ...future.value <- base::withVisible(base::local({
[16:59:39.458]                 ...future.makeSendCondition <- base::local({
[16:59:39.458]                   sendCondition <- NULL
[16:59:39.458]                   function(frame = 1L) {
[16:59:39.458]                     if (is.function(sendCondition)) 
[16:59:39.458]                       return(sendCondition)
[16:59:39.458]                     ns <- getNamespace("parallel")
[16:59:39.458]                     if (exists("sendData", mode = "function", 
[16:59:39.458]                       envir = ns)) {
[16:59:39.458]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:39.458]                         envir = ns)
[16:59:39.458]                       envir <- sys.frame(frame)
[16:59:39.458]                       master <- NULL
[16:59:39.458]                       while (!identical(envir, .GlobalEnv) && 
[16:59:39.458]                         !identical(envir, emptyenv())) {
[16:59:39.458]                         if (exists("master", mode = "list", envir = envir, 
[16:59:39.458]                           inherits = FALSE)) {
[16:59:39.458]                           master <- get("master", mode = "list", 
[16:59:39.458]                             envir = envir, inherits = FALSE)
[16:59:39.458]                           if (inherits(master, c("SOCKnode", 
[16:59:39.458]                             "SOCK0node"))) {
[16:59:39.458]                             sendCondition <<- function(cond) {
[16:59:39.458]                               data <- list(type = "VALUE", value = cond, 
[16:59:39.458]                                 success = TRUE)
[16:59:39.458]                               parallel_sendData(master, data)
[16:59:39.458]                             }
[16:59:39.458]                             return(sendCondition)
[16:59:39.458]                           }
[16:59:39.458]                         }
[16:59:39.458]                         frame <- frame + 1L
[16:59:39.458]                         envir <- sys.frame(frame)
[16:59:39.458]                       }
[16:59:39.458]                     }
[16:59:39.458]                     sendCondition <<- function(cond) NULL
[16:59:39.458]                   }
[16:59:39.458]                 })
[16:59:39.458]                 withCallingHandlers({
[16:59:39.458]                   {
[16:59:39.458]                     do.call(function(...) {
[16:59:39.458]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.458]                       if (!identical(...future.globals.maxSize.org, 
[16:59:39.458]                         ...future.globals.maxSize)) {
[16:59:39.458]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.458]                         on.exit(options(oopts), add = TRUE)
[16:59:39.458]                       }
[16:59:39.458]                       {
[16:59:39.458]                         lapply(seq_along(...future.elements_ii), 
[16:59:39.458]                           FUN = function(jj) {
[16:59:39.458]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.458]                             ...future.FUN(...future.X_jj, ...)
[16:59:39.458]                           })
[16:59:39.458]                       }
[16:59:39.458]                     }, args = future.call.arguments)
[16:59:39.458]                   }
[16:59:39.458]                 }, immediateCondition = function(cond) {
[16:59:39.458]                   sendCondition <- ...future.makeSendCondition()
[16:59:39.458]                   sendCondition(cond)
[16:59:39.458]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.458]                   {
[16:59:39.458]                     inherits <- base::inherits
[16:59:39.458]                     invokeRestart <- base::invokeRestart
[16:59:39.458]                     is.null <- base::is.null
[16:59:39.458]                     muffled <- FALSE
[16:59:39.458]                     if (inherits(cond, "message")) {
[16:59:39.458]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:39.458]                       if (muffled) 
[16:59:39.458]                         invokeRestart("muffleMessage")
[16:59:39.458]                     }
[16:59:39.458]                     else if (inherits(cond, "warning")) {
[16:59:39.458]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:39.458]                       if (muffled) 
[16:59:39.458]                         invokeRestart("muffleWarning")
[16:59:39.458]                     }
[16:59:39.458]                     else if (inherits(cond, "condition")) {
[16:59:39.458]                       if (!is.null(pattern)) {
[16:59:39.458]                         computeRestarts <- base::computeRestarts
[16:59:39.458]                         grepl <- base::grepl
[16:59:39.458]                         restarts <- computeRestarts(cond)
[16:59:39.458]                         for (restart in restarts) {
[16:59:39.458]                           name <- restart$name
[16:59:39.458]                           if (is.null(name)) 
[16:59:39.458]                             next
[16:59:39.458]                           if (!grepl(pattern, name)) 
[16:59:39.458]                             next
[16:59:39.458]                           invokeRestart(restart)
[16:59:39.458]                           muffled <- TRUE
[16:59:39.458]                           break
[16:59:39.458]                         }
[16:59:39.458]                       }
[16:59:39.458]                     }
[16:59:39.458]                     invisible(muffled)
[16:59:39.458]                   }
[16:59:39.458]                   muffleCondition(cond)
[16:59:39.458]                 })
[16:59:39.458]             }))
[16:59:39.458]             future::FutureResult(value = ...future.value$value, 
[16:59:39.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.458]                   ...future.rng), globalenv = if (FALSE) 
[16:59:39.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:39.458]                     ...future.globalenv.names))
[16:59:39.458]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:39.458]         }, condition = base::local({
[16:59:39.458]             c <- base::c
[16:59:39.458]             inherits <- base::inherits
[16:59:39.458]             invokeRestart <- base::invokeRestart
[16:59:39.458]             length <- base::length
[16:59:39.458]             list <- base::list
[16:59:39.458]             seq.int <- base::seq.int
[16:59:39.458]             signalCondition <- base::signalCondition
[16:59:39.458]             sys.calls <- base::sys.calls
[16:59:39.458]             `[[` <- base::`[[`
[16:59:39.458]             `+` <- base::`+`
[16:59:39.458]             `<<-` <- base::`<<-`
[16:59:39.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:39.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:39.458]                   3L)]
[16:59:39.458]             }
[16:59:39.458]             function(cond) {
[16:59:39.458]                 is_error <- inherits(cond, "error")
[16:59:39.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:39.458]                   NULL)
[16:59:39.458]                 if (is_error) {
[16:59:39.458]                   sessionInformation <- function() {
[16:59:39.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:39.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:39.458]                       search = base::search(), system = base::Sys.info())
[16:59:39.458]                   }
[16:59:39.458]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:39.458]                     cond$call), session = sessionInformation(), 
[16:59:39.458]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:39.458]                   signalCondition(cond)
[16:59:39.458]                 }
[16:59:39.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:39.458]                 "immediateCondition"))) {
[16:59:39.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:39.458]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:39.458]                   if (TRUE && !signal) {
[16:59:39.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.458]                     {
[16:59:39.458]                       inherits <- base::inherits
[16:59:39.458]                       invokeRestart <- base::invokeRestart
[16:59:39.458]                       is.null <- base::is.null
[16:59:39.458]                       muffled <- FALSE
[16:59:39.458]                       if (inherits(cond, "message")) {
[16:59:39.458]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.458]                         if (muffled) 
[16:59:39.458]                           invokeRestart("muffleMessage")
[16:59:39.458]                       }
[16:59:39.458]                       else if (inherits(cond, "warning")) {
[16:59:39.458]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.458]                         if (muffled) 
[16:59:39.458]                           invokeRestart("muffleWarning")
[16:59:39.458]                       }
[16:59:39.458]                       else if (inherits(cond, "condition")) {
[16:59:39.458]                         if (!is.null(pattern)) {
[16:59:39.458]                           computeRestarts <- base::computeRestarts
[16:59:39.458]                           grepl <- base::grepl
[16:59:39.458]                           restarts <- computeRestarts(cond)
[16:59:39.458]                           for (restart in restarts) {
[16:59:39.458]                             name <- restart$name
[16:59:39.458]                             if (is.null(name)) 
[16:59:39.458]                               next
[16:59:39.458]                             if (!grepl(pattern, name)) 
[16:59:39.458]                               next
[16:59:39.458]                             invokeRestart(restart)
[16:59:39.458]                             muffled <- TRUE
[16:59:39.458]                             break
[16:59:39.458]                           }
[16:59:39.458]                         }
[16:59:39.458]                       }
[16:59:39.458]                       invisible(muffled)
[16:59:39.458]                     }
[16:59:39.458]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.458]                   }
[16:59:39.458]                 }
[16:59:39.458]                 else {
[16:59:39.458]                   if (TRUE) {
[16:59:39.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.458]                     {
[16:59:39.458]                       inherits <- base::inherits
[16:59:39.458]                       invokeRestart <- base::invokeRestart
[16:59:39.458]                       is.null <- base::is.null
[16:59:39.458]                       muffled <- FALSE
[16:59:39.458]                       if (inherits(cond, "message")) {
[16:59:39.458]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.458]                         if (muffled) 
[16:59:39.458]                           invokeRestart("muffleMessage")
[16:59:39.458]                       }
[16:59:39.458]                       else if (inherits(cond, "warning")) {
[16:59:39.458]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.458]                         if (muffled) 
[16:59:39.458]                           invokeRestart("muffleWarning")
[16:59:39.458]                       }
[16:59:39.458]                       else if (inherits(cond, "condition")) {
[16:59:39.458]                         if (!is.null(pattern)) {
[16:59:39.458]                           computeRestarts <- base::computeRestarts
[16:59:39.458]                           grepl <- base::grepl
[16:59:39.458]                           restarts <- computeRestarts(cond)
[16:59:39.458]                           for (restart in restarts) {
[16:59:39.458]                             name <- restart$name
[16:59:39.458]                             if (is.null(name)) 
[16:59:39.458]                               next
[16:59:39.458]                             if (!grepl(pattern, name)) 
[16:59:39.458]                               next
[16:59:39.458]                             invokeRestart(restart)
[16:59:39.458]                             muffled <- TRUE
[16:59:39.458]                             break
[16:59:39.458]                           }
[16:59:39.458]                         }
[16:59:39.458]                       }
[16:59:39.458]                       invisible(muffled)
[16:59:39.458]                     }
[16:59:39.458]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.458]                   }
[16:59:39.458]                 }
[16:59:39.458]             }
[16:59:39.458]         }))
[16:59:39.458]     }, error = function(ex) {
[16:59:39.458]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:39.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.458]                 ...future.rng), started = ...future.startTime, 
[16:59:39.458]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:39.458]             version = "1.8"), class = "FutureResult")
[16:59:39.458]     }, finally = {
[16:59:39.458]         if (!identical(...future.workdir, getwd())) 
[16:59:39.458]             setwd(...future.workdir)
[16:59:39.458]         {
[16:59:39.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:39.458]                 ...future.oldOptions$nwarnings <- NULL
[16:59:39.458]             }
[16:59:39.458]             base::options(...future.oldOptions)
[16:59:39.458]             if (.Platform$OS.type == "windows") {
[16:59:39.458]                 old_names <- names(...future.oldEnvVars)
[16:59:39.458]                 envs <- base::Sys.getenv()
[16:59:39.458]                 names <- names(envs)
[16:59:39.458]                 common <- intersect(names, old_names)
[16:59:39.458]                 added <- setdiff(names, old_names)
[16:59:39.458]                 removed <- setdiff(old_names, names)
[16:59:39.458]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:39.458]                   envs[common]]
[16:59:39.458]                 NAMES <- toupper(changed)
[16:59:39.458]                 args <- list()
[16:59:39.458]                 for (kk in seq_along(NAMES)) {
[16:59:39.458]                   name <- changed[[kk]]
[16:59:39.458]                   NAME <- NAMES[[kk]]
[16:59:39.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.458]                     next
[16:59:39.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.458]                 }
[16:59:39.458]                 NAMES <- toupper(added)
[16:59:39.458]                 for (kk in seq_along(NAMES)) {
[16:59:39.458]                   name <- added[[kk]]
[16:59:39.458]                   NAME <- NAMES[[kk]]
[16:59:39.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.458]                     next
[16:59:39.458]                   args[[name]] <- ""
[16:59:39.458]                 }
[16:59:39.458]                 NAMES <- toupper(removed)
[16:59:39.458]                 for (kk in seq_along(NAMES)) {
[16:59:39.458]                   name <- removed[[kk]]
[16:59:39.458]                   NAME <- NAMES[[kk]]
[16:59:39.458]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.458]                     next
[16:59:39.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.458]                 }
[16:59:39.458]                 if (length(args) > 0) 
[16:59:39.458]                   base::do.call(base::Sys.setenv, args = args)
[16:59:39.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:39.458]             }
[16:59:39.458]             else {
[16:59:39.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:39.458]             }
[16:59:39.458]             {
[16:59:39.458]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:39.458]                   0L) {
[16:59:39.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:39.458]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:39.458]                   base::options(opts)
[16:59:39.458]                 }
[16:59:39.458]                 {
[16:59:39.458]                   {
[16:59:39.458]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:39.458]                     NULL
[16:59:39.458]                   }
[16:59:39.458]                   options(future.plan = NULL)
[16:59:39.458]                   if (is.na(NA_character_)) 
[16:59:39.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:39.458]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:39.458]                     .init = FALSE)
[16:59:39.458]                 }
[16:59:39.458]             }
[16:59:39.458]         }
[16:59:39.458]     })
[16:59:39.458]     if (TRUE) {
[16:59:39.458]         base::sink(type = "output", split = FALSE)
[16:59:39.458]         if (TRUE) {
[16:59:39.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:39.458]         }
[16:59:39.458]         else {
[16:59:39.458]             ...future.result["stdout"] <- base::list(NULL)
[16:59:39.458]         }
[16:59:39.458]         base::close(...future.stdout)
[16:59:39.458]         ...future.stdout <- NULL
[16:59:39.458]     }
[16:59:39.458]     ...future.result$conditions <- ...future.conditions
[16:59:39.458]     ...future.result$finished <- base::Sys.time()
[16:59:39.458]     ...future.result
[16:59:39.458] }
[16:59:39.460] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[16:59:39.460] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:59:39.461] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:59:39.461] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:39.461] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:39.462] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:59:39.462] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:59:39.462] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:39.462] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:39.463] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:59:39.463] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:59:39.463] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[16:59:39.463] MultisessionFuture started
[16:59:39.464] - Launch lazy future ... done
[16:59:39.464] run() for ‘MultisessionFuture’ ... done
[16:59:39.464] Created future:
[16:59:39.466] receiveMessageFromWorker() for ClusterFuture ...
[16:59:39.466] - Validating connection of MultisessionFuture
[16:59:39.466] - received message: FutureResult
[16:59:39.466] - Received FutureResult
[16:59:39.466] - Erased future from FutureRegistry
[16:59:39.466] result() for ClusterFuture ...
[16:59:39.466] - result already collected: FutureResult
[16:59:39.467] result() for ClusterFuture ... done
[16:59:39.467] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:39.464] MultisessionFuture:
[16:59:39.464] Label: ‘future_eapply-1’
[16:59:39.464] Expression:
[16:59:39.464] {
[16:59:39.464]     do.call(function(...) {
[16:59:39.464]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.464]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.464]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.464]             on.exit(options(oopts), add = TRUE)
[16:59:39.464]         }
[16:59:39.464]         {
[16:59:39.464]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.464]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.464]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.464]             })
[16:59:39.464]         }
[16:59:39.464]     }, args = future.call.arguments)
[16:59:39.464] }
[16:59:39.464] Lazy evaluation: FALSE
[16:59:39.464] Asynchronous evaluation: TRUE
[16:59:39.464] Local evaluation: TRUE
[16:59:39.464] Environment: R_GlobalEnv
[16:59:39.464] Capture standard output: TRUE
[16:59:39.464] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:39.464] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:39.464] Packages: 1 packages (‘stats’)
[16:59:39.464] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:39.464] Resolved: TRUE
[16:59:39.464] Value: <not collected>
[16:59:39.464] Conditions captured: <none>
[16:59:39.464] Early signaling: FALSE
[16:59:39.464] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:39.464] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.467] Chunk #1 of 2 ... DONE
[16:59:39.467] Chunk #2 of 2 ...
[16:59:39.467]  - Finding globals in 'X' for chunk #2 ...
[16:59:39.467] getGlobalsAndPackages() ...
[16:59:39.467] Searching for globals...
[16:59:39.468] 
[16:59:39.468] Searching for globals ... DONE
[16:59:39.468] - globals: [0] <none>
[16:59:39.468] getGlobalsAndPackages() ... DONE
[16:59:39.468]    + additional globals found: [n=0] 
[16:59:39.468]    + additional namespaces needed: [n=0] 
[16:59:39.468]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:39.468]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:39.468]  - seeds: <none>
[16:59:39.468]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.468] getGlobalsAndPackages() ...
[16:59:39.469] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.469] Resolving globals: FALSE
[16:59:39.469] Tweak future expression to call with '...' arguments ...
[16:59:39.469] {
[16:59:39.469]     do.call(function(...) {
[16:59:39.469]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.469]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.469]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.469]             on.exit(options(oopts), add = TRUE)
[16:59:39.469]         }
[16:59:39.469]         {
[16:59:39.469]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.469]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.469]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.469]             })
[16:59:39.469]         }
[16:59:39.469]     }, args = future.call.arguments)
[16:59:39.469] }
[16:59:39.469] Tweak future expression to call with '...' arguments ... DONE
[16:59:39.469] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.470] - packages: [1] ‘stats’
[16:59:39.470] getGlobalsAndPackages() ... DONE
[16:59:39.470] run() for ‘Future’ ...
[16:59:39.470] - state: ‘created’
[16:59:39.470] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:39.486] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.486] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:39.486]   - Field: ‘node’
[16:59:39.486]   - Field: ‘label’
[16:59:39.486]   - Field: ‘local’
[16:59:39.487]   - Field: ‘owner’
[16:59:39.487]   - Field: ‘envir’
[16:59:39.487]   - Field: ‘workers’
[16:59:39.487]   - Field: ‘packages’
[16:59:39.487]   - Field: ‘gc’
[16:59:39.487]   - Field: ‘conditions’
[16:59:39.487]   - Field: ‘persistent’
[16:59:39.487]   - Field: ‘expr’
[16:59:39.487]   - Field: ‘uuid’
[16:59:39.487]   - Field: ‘seed’
[16:59:39.487]   - Field: ‘version’
[16:59:39.488]   - Field: ‘result’
[16:59:39.488]   - Field: ‘asynchronous’
[16:59:39.488]   - Field: ‘calls’
[16:59:39.488]   - Field: ‘globals’
[16:59:39.488]   - Field: ‘stdout’
[16:59:39.488]   - Field: ‘earlySignal’
[16:59:39.488]   - Field: ‘lazy’
[16:59:39.488]   - Field: ‘state’
[16:59:39.488] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:39.488] - Launch lazy future ...
[16:59:39.489] Packages needed by the future expression (n = 1): ‘stats’
[16:59:39.489] Packages needed by future strategies (n = 0): <none>
[16:59:39.489] {
[16:59:39.489]     {
[16:59:39.489]         {
[16:59:39.489]             ...future.startTime <- base::Sys.time()
[16:59:39.489]             {
[16:59:39.489]                 {
[16:59:39.489]                   {
[16:59:39.489]                     {
[16:59:39.489]                       {
[16:59:39.489]                         base::local({
[16:59:39.489]                           has_future <- base::requireNamespace("future", 
[16:59:39.489]                             quietly = TRUE)
[16:59:39.489]                           if (has_future) {
[16:59:39.489]                             ns <- base::getNamespace("future")
[16:59:39.489]                             version <- ns[[".package"]][["version"]]
[16:59:39.489]                             if (is.null(version)) 
[16:59:39.489]                               version <- utils::packageVersion("future")
[16:59:39.489]                           }
[16:59:39.489]                           else {
[16:59:39.489]                             version <- NULL
[16:59:39.489]                           }
[16:59:39.489]                           if (!has_future || version < "1.8.0") {
[16:59:39.489]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:39.489]                               "", base::R.version$version.string), 
[16:59:39.489]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:39.489]                                 base::R.version$platform, 8 * 
[16:59:39.489]                                   base::.Machine$sizeof.pointer), 
[16:59:39.489]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:39.489]                                 "release", "version")], collapse = " "), 
[16:59:39.489]                               hostname = base::Sys.info()[["nodename"]])
[16:59:39.489]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:39.489]                               info)
[16:59:39.489]                             info <- base::paste(info, collapse = "; ")
[16:59:39.489]                             if (!has_future) {
[16:59:39.489]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:39.489]                                 info)
[16:59:39.489]                             }
[16:59:39.489]                             else {
[16:59:39.489]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:39.489]                                 info, version)
[16:59:39.489]                             }
[16:59:39.489]                             base::stop(msg)
[16:59:39.489]                           }
[16:59:39.489]                         })
[16:59:39.489]                       }
[16:59:39.489]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:39.489]                       base::options(mc.cores = 1L)
[16:59:39.489]                     }
[16:59:39.489]                     base::local({
[16:59:39.489]                       for (pkg in "stats") {
[16:59:39.489]                         base::loadNamespace(pkg)
[16:59:39.489]                         base::library(pkg, character.only = TRUE)
[16:59:39.489]                       }
[16:59:39.489]                     })
[16:59:39.489]                   }
[16:59:39.489]                   ...future.strategy.old <- future::plan("list")
[16:59:39.489]                   options(future.plan = NULL)
[16:59:39.489]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.489]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:39.489]                 }
[16:59:39.489]                 ...future.workdir <- getwd()
[16:59:39.489]             }
[16:59:39.489]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:39.489]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:39.489]         }
[16:59:39.489]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:39.489]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:39.489]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:39.489]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:39.489]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:39.489]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:39.489]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:39.489]             base::names(...future.oldOptions))
[16:59:39.489]     }
[16:59:39.489]     if (FALSE) {
[16:59:39.489]     }
[16:59:39.489]     else {
[16:59:39.489]         if (TRUE) {
[16:59:39.489]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:39.489]                 open = "w")
[16:59:39.489]         }
[16:59:39.489]         else {
[16:59:39.489]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:39.489]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:39.489]         }
[16:59:39.489]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:39.489]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:39.489]             base::sink(type = "output", split = FALSE)
[16:59:39.489]             base::close(...future.stdout)
[16:59:39.489]         }, add = TRUE)
[16:59:39.489]     }
[16:59:39.489]     ...future.frame <- base::sys.nframe()
[16:59:39.489]     ...future.conditions <- base::list()
[16:59:39.489]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:39.489]     if (FALSE) {
[16:59:39.489]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:39.489]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:39.489]     }
[16:59:39.489]     ...future.result <- base::tryCatch({
[16:59:39.489]         base::withCallingHandlers({
[16:59:39.489]             ...future.value <- base::withVisible(base::local({
[16:59:39.489]                 ...future.makeSendCondition <- base::local({
[16:59:39.489]                   sendCondition <- NULL
[16:59:39.489]                   function(frame = 1L) {
[16:59:39.489]                     if (is.function(sendCondition)) 
[16:59:39.489]                       return(sendCondition)
[16:59:39.489]                     ns <- getNamespace("parallel")
[16:59:39.489]                     if (exists("sendData", mode = "function", 
[16:59:39.489]                       envir = ns)) {
[16:59:39.489]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:39.489]                         envir = ns)
[16:59:39.489]                       envir <- sys.frame(frame)
[16:59:39.489]                       master <- NULL
[16:59:39.489]                       while (!identical(envir, .GlobalEnv) && 
[16:59:39.489]                         !identical(envir, emptyenv())) {
[16:59:39.489]                         if (exists("master", mode = "list", envir = envir, 
[16:59:39.489]                           inherits = FALSE)) {
[16:59:39.489]                           master <- get("master", mode = "list", 
[16:59:39.489]                             envir = envir, inherits = FALSE)
[16:59:39.489]                           if (inherits(master, c("SOCKnode", 
[16:59:39.489]                             "SOCK0node"))) {
[16:59:39.489]                             sendCondition <<- function(cond) {
[16:59:39.489]                               data <- list(type = "VALUE", value = cond, 
[16:59:39.489]                                 success = TRUE)
[16:59:39.489]                               parallel_sendData(master, data)
[16:59:39.489]                             }
[16:59:39.489]                             return(sendCondition)
[16:59:39.489]                           }
[16:59:39.489]                         }
[16:59:39.489]                         frame <- frame + 1L
[16:59:39.489]                         envir <- sys.frame(frame)
[16:59:39.489]                       }
[16:59:39.489]                     }
[16:59:39.489]                     sendCondition <<- function(cond) NULL
[16:59:39.489]                   }
[16:59:39.489]                 })
[16:59:39.489]                 withCallingHandlers({
[16:59:39.489]                   {
[16:59:39.489]                     do.call(function(...) {
[16:59:39.489]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.489]                       if (!identical(...future.globals.maxSize.org, 
[16:59:39.489]                         ...future.globals.maxSize)) {
[16:59:39.489]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.489]                         on.exit(options(oopts), add = TRUE)
[16:59:39.489]                       }
[16:59:39.489]                       {
[16:59:39.489]                         lapply(seq_along(...future.elements_ii), 
[16:59:39.489]                           FUN = function(jj) {
[16:59:39.489]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.489]                             ...future.FUN(...future.X_jj, ...)
[16:59:39.489]                           })
[16:59:39.489]                       }
[16:59:39.489]                     }, args = future.call.arguments)
[16:59:39.489]                   }
[16:59:39.489]                 }, immediateCondition = function(cond) {
[16:59:39.489]                   sendCondition <- ...future.makeSendCondition()
[16:59:39.489]                   sendCondition(cond)
[16:59:39.489]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.489]                   {
[16:59:39.489]                     inherits <- base::inherits
[16:59:39.489]                     invokeRestart <- base::invokeRestart
[16:59:39.489]                     is.null <- base::is.null
[16:59:39.489]                     muffled <- FALSE
[16:59:39.489]                     if (inherits(cond, "message")) {
[16:59:39.489]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:39.489]                       if (muffled) 
[16:59:39.489]                         invokeRestart("muffleMessage")
[16:59:39.489]                     }
[16:59:39.489]                     else if (inherits(cond, "warning")) {
[16:59:39.489]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:39.489]                       if (muffled) 
[16:59:39.489]                         invokeRestart("muffleWarning")
[16:59:39.489]                     }
[16:59:39.489]                     else if (inherits(cond, "condition")) {
[16:59:39.489]                       if (!is.null(pattern)) {
[16:59:39.489]                         computeRestarts <- base::computeRestarts
[16:59:39.489]                         grepl <- base::grepl
[16:59:39.489]                         restarts <- computeRestarts(cond)
[16:59:39.489]                         for (restart in restarts) {
[16:59:39.489]                           name <- restart$name
[16:59:39.489]                           if (is.null(name)) 
[16:59:39.489]                             next
[16:59:39.489]                           if (!grepl(pattern, name)) 
[16:59:39.489]                             next
[16:59:39.489]                           invokeRestart(restart)
[16:59:39.489]                           muffled <- TRUE
[16:59:39.489]                           break
[16:59:39.489]                         }
[16:59:39.489]                       }
[16:59:39.489]                     }
[16:59:39.489]                     invisible(muffled)
[16:59:39.489]                   }
[16:59:39.489]                   muffleCondition(cond)
[16:59:39.489]                 })
[16:59:39.489]             }))
[16:59:39.489]             future::FutureResult(value = ...future.value$value, 
[16:59:39.489]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.489]                   ...future.rng), globalenv = if (FALSE) 
[16:59:39.489]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:39.489]                     ...future.globalenv.names))
[16:59:39.489]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:39.489]         }, condition = base::local({
[16:59:39.489]             c <- base::c
[16:59:39.489]             inherits <- base::inherits
[16:59:39.489]             invokeRestart <- base::invokeRestart
[16:59:39.489]             length <- base::length
[16:59:39.489]             list <- base::list
[16:59:39.489]             seq.int <- base::seq.int
[16:59:39.489]             signalCondition <- base::signalCondition
[16:59:39.489]             sys.calls <- base::sys.calls
[16:59:39.489]             `[[` <- base::`[[`
[16:59:39.489]             `+` <- base::`+`
[16:59:39.489]             `<<-` <- base::`<<-`
[16:59:39.489]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:39.489]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:39.489]                   3L)]
[16:59:39.489]             }
[16:59:39.489]             function(cond) {
[16:59:39.489]                 is_error <- inherits(cond, "error")
[16:59:39.489]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:39.489]                   NULL)
[16:59:39.489]                 if (is_error) {
[16:59:39.489]                   sessionInformation <- function() {
[16:59:39.489]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:39.489]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:39.489]                       search = base::search(), system = base::Sys.info())
[16:59:39.489]                   }
[16:59:39.489]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.489]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:39.489]                     cond$call), session = sessionInformation(), 
[16:59:39.489]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:39.489]                   signalCondition(cond)
[16:59:39.489]                 }
[16:59:39.489]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:39.489]                 "immediateCondition"))) {
[16:59:39.489]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:39.489]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.489]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:39.489]                   if (TRUE && !signal) {
[16:59:39.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.489]                     {
[16:59:39.489]                       inherits <- base::inherits
[16:59:39.489]                       invokeRestart <- base::invokeRestart
[16:59:39.489]                       is.null <- base::is.null
[16:59:39.489]                       muffled <- FALSE
[16:59:39.489]                       if (inherits(cond, "message")) {
[16:59:39.489]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.489]                         if (muffled) 
[16:59:39.489]                           invokeRestart("muffleMessage")
[16:59:39.489]                       }
[16:59:39.489]                       else if (inherits(cond, "warning")) {
[16:59:39.489]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.489]                         if (muffled) 
[16:59:39.489]                           invokeRestart("muffleWarning")
[16:59:39.489]                       }
[16:59:39.489]                       else if (inherits(cond, "condition")) {
[16:59:39.489]                         if (!is.null(pattern)) {
[16:59:39.489]                           computeRestarts <- base::computeRestarts
[16:59:39.489]                           grepl <- base::grepl
[16:59:39.489]                           restarts <- computeRestarts(cond)
[16:59:39.489]                           for (restart in restarts) {
[16:59:39.489]                             name <- restart$name
[16:59:39.489]                             if (is.null(name)) 
[16:59:39.489]                               next
[16:59:39.489]                             if (!grepl(pattern, name)) 
[16:59:39.489]                               next
[16:59:39.489]                             invokeRestart(restart)
[16:59:39.489]                             muffled <- TRUE
[16:59:39.489]                             break
[16:59:39.489]                           }
[16:59:39.489]                         }
[16:59:39.489]                       }
[16:59:39.489]                       invisible(muffled)
[16:59:39.489]                     }
[16:59:39.489]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.489]                   }
[16:59:39.489]                 }
[16:59:39.489]                 else {
[16:59:39.489]                   if (TRUE) {
[16:59:39.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.489]                     {
[16:59:39.489]                       inherits <- base::inherits
[16:59:39.489]                       invokeRestart <- base::invokeRestart
[16:59:39.489]                       is.null <- base::is.null
[16:59:39.489]                       muffled <- FALSE
[16:59:39.489]                       if (inherits(cond, "message")) {
[16:59:39.489]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.489]                         if (muffled) 
[16:59:39.489]                           invokeRestart("muffleMessage")
[16:59:39.489]                       }
[16:59:39.489]                       else if (inherits(cond, "warning")) {
[16:59:39.489]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.489]                         if (muffled) 
[16:59:39.489]                           invokeRestart("muffleWarning")
[16:59:39.489]                       }
[16:59:39.489]                       else if (inherits(cond, "condition")) {
[16:59:39.489]                         if (!is.null(pattern)) {
[16:59:39.489]                           computeRestarts <- base::computeRestarts
[16:59:39.489]                           grepl <- base::grepl
[16:59:39.489]                           restarts <- computeRestarts(cond)
[16:59:39.489]                           for (restart in restarts) {
[16:59:39.489]                             name <- restart$name
[16:59:39.489]                             if (is.null(name)) 
[16:59:39.489]                               next
[16:59:39.489]                             if (!grepl(pattern, name)) 
[16:59:39.489]                               next
[16:59:39.489]                             invokeRestart(restart)
[16:59:39.489]                             muffled <- TRUE
[16:59:39.489]                             break
[16:59:39.489]                           }
[16:59:39.489]                         }
[16:59:39.489]                       }
[16:59:39.489]                       invisible(muffled)
[16:59:39.489]                     }
[16:59:39.489]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.489]                   }
[16:59:39.489]                 }
[16:59:39.489]             }
[16:59:39.489]         }))
[16:59:39.489]     }, error = function(ex) {
[16:59:39.489]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:39.489]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.489]                 ...future.rng), started = ...future.startTime, 
[16:59:39.489]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:39.489]             version = "1.8"), class = "FutureResult")
[16:59:39.489]     }, finally = {
[16:59:39.489]         if (!identical(...future.workdir, getwd())) 
[16:59:39.489]             setwd(...future.workdir)
[16:59:39.489]         {
[16:59:39.489]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:39.489]                 ...future.oldOptions$nwarnings <- NULL
[16:59:39.489]             }
[16:59:39.489]             base::options(...future.oldOptions)
[16:59:39.489]             if (.Platform$OS.type == "windows") {
[16:59:39.489]                 old_names <- names(...future.oldEnvVars)
[16:59:39.489]                 envs <- base::Sys.getenv()
[16:59:39.489]                 names <- names(envs)
[16:59:39.489]                 common <- intersect(names, old_names)
[16:59:39.489]                 added <- setdiff(names, old_names)
[16:59:39.489]                 removed <- setdiff(old_names, names)
[16:59:39.489]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:39.489]                   envs[common]]
[16:59:39.489]                 NAMES <- toupper(changed)
[16:59:39.489]                 args <- list()
[16:59:39.489]                 for (kk in seq_along(NAMES)) {
[16:59:39.489]                   name <- changed[[kk]]
[16:59:39.489]                   NAME <- NAMES[[kk]]
[16:59:39.489]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.489]                     next
[16:59:39.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.489]                 }
[16:59:39.489]                 NAMES <- toupper(added)
[16:59:39.489]                 for (kk in seq_along(NAMES)) {
[16:59:39.489]                   name <- added[[kk]]
[16:59:39.489]                   NAME <- NAMES[[kk]]
[16:59:39.489]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.489]                     next
[16:59:39.489]                   args[[name]] <- ""
[16:59:39.489]                 }
[16:59:39.489]                 NAMES <- toupper(removed)
[16:59:39.489]                 for (kk in seq_along(NAMES)) {
[16:59:39.489]                   name <- removed[[kk]]
[16:59:39.489]                   NAME <- NAMES[[kk]]
[16:59:39.489]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.489]                     next
[16:59:39.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.489]                 }
[16:59:39.489]                 if (length(args) > 0) 
[16:59:39.489]                   base::do.call(base::Sys.setenv, args = args)
[16:59:39.489]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:39.489]             }
[16:59:39.489]             else {
[16:59:39.489]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:39.489]             }
[16:59:39.489]             {
[16:59:39.489]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:39.489]                   0L) {
[16:59:39.489]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:39.489]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:39.489]                   base::options(opts)
[16:59:39.489]                 }
[16:59:39.489]                 {
[16:59:39.489]                   {
[16:59:39.489]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:39.489]                     NULL
[16:59:39.489]                   }
[16:59:39.489]                   options(future.plan = NULL)
[16:59:39.489]                   if (is.na(NA_character_)) 
[16:59:39.489]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.489]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:39.489]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:39.489]                     .init = FALSE)
[16:59:39.489]                 }
[16:59:39.489]             }
[16:59:39.489]         }
[16:59:39.489]     })
[16:59:39.489]     if (TRUE) {
[16:59:39.489]         base::sink(type = "output", split = FALSE)
[16:59:39.489]         if (TRUE) {
[16:59:39.489]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:39.489]         }
[16:59:39.489]         else {
[16:59:39.489]             ...future.result["stdout"] <- base::list(NULL)
[16:59:39.489]         }
[16:59:39.489]         base::close(...future.stdout)
[16:59:39.489]         ...future.stdout <- NULL
[16:59:39.489]     }
[16:59:39.489]     ...future.result$conditions <- ...future.conditions
[16:59:39.489]     ...future.result$finished <- base::Sys.time()
[16:59:39.489]     ...future.result
[16:59:39.489] }
[16:59:39.492] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[16:59:39.492] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:59:39.492] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:59:39.492] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:39.493] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:39.493] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #1 ...
[16:59:39.493] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #1 ... DONE
[16:59:39.494] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:39.494] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:39.494] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:59:39.494] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:59:39.494] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[16:59:39.495] MultisessionFuture started
[16:59:39.495] - Launch lazy future ... done
[16:59:39.495] run() for ‘MultisessionFuture’ ... done
[16:59:39.495] Created future:
[16:59:39.496] MultisessionFuture:
[16:59:39.496] Label: ‘future_eapply-2’
[16:59:39.496] Expression:
[16:59:39.496] {
[16:59:39.496]     do.call(function(...) {
[16:59:39.496]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.496]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.496]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.496]             on.exit(options(oopts), add = TRUE)
[16:59:39.496]         }
[16:59:39.496]         {
[16:59:39.496]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.496]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.496]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.496]             })
[16:59:39.496]         }
[16:59:39.496]     }, args = future.call.arguments)
[16:59:39.496] }
[16:59:39.496] Lazy evaluation: FALSE
[16:59:39.496] Asynchronous evaluation: TRUE
[16:59:39.496] Local evaluation: TRUE
[16:59:39.496] Environment: R_GlobalEnv
[16:59:39.496] Capture standard output: TRUE
[16:59:39.496] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:39.496] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:39.496] Packages: 1 packages (‘stats’)
[16:59:39.496] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:39.496] Resolved: FALSE
[16:59:39.496] Value: <not collected>
[16:59:39.496] Conditions captured: <none>
[16:59:39.496] Early signaling: FALSE
[16:59:39.496] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:39.496] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.507] Chunk #2 of 2 ... DONE
[16:59:39.507] Launching 2 futures (chunks) ... DONE
[16:59:39.507] Resolving 2 futures (chunks) ...
[16:59:39.507] resolve() on list ...
[16:59:39.508]  recursive: 0
[16:59:39.508]  length: 2
[16:59:39.508] 
[16:59:39.508] Future #1
[16:59:39.508] result() for ClusterFuture ...
[16:59:39.508] - result already collected: FutureResult
[16:59:39.508] result() for ClusterFuture ... done
[16:59:39.508] result() for ClusterFuture ...
[16:59:39.508] - result already collected: FutureResult
[16:59:39.508] result() for ClusterFuture ... done
[16:59:39.509] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:39.509] - nx: 2
[16:59:39.509] - relay: TRUE
[16:59:39.509] - stdout: TRUE
[16:59:39.509] - signal: TRUE
[16:59:39.509] - resignal: FALSE
[16:59:39.509] - force: TRUE
[16:59:39.509] - relayed: [n=2] FALSE, FALSE
[16:59:39.509] - queued futures: [n=2] FALSE, FALSE
[16:59:39.509]  - until=1
[16:59:39.509]  - relaying element #1
[16:59:39.509] result() for ClusterFuture ...
[16:59:39.510] - result already collected: FutureResult
[16:59:39.510] result() for ClusterFuture ... done
[16:59:39.510] result() for ClusterFuture ...
[16:59:39.510] - result already collected: FutureResult
[16:59:39.510] result() for ClusterFuture ... done
[16:59:39.510] result() for ClusterFuture ...
[16:59:39.510] - result already collected: FutureResult
[16:59:39.510] result() for ClusterFuture ... done
[16:59:39.510] result() for ClusterFuture ...
[16:59:39.510] - result already collected: FutureResult
[16:59:39.510] result() for ClusterFuture ... done
[16:59:39.510] - relayed: [n=2] TRUE, FALSE
[16:59:39.511] - queued futures: [n=2] TRUE, FALSE
[16:59:39.511] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:39.511]  length: 1 (resolved future 1)
[16:59:39.537] receiveMessageFromWorker() for ClusterFuture ...
[16:59:39.537] - Validating connection of MultisessionFuture
[16:59:39.538] - received message: FutureResult
[16:59:39.538] - Received FutureResult
[16:59:39.538] - Erased future from FutureRegistry
[16:59:39.538] result() for ClusterFuture ...
[16:59:39.538] - result already collected: FutureResult
[16:59:39.538] result() for ClusterFuture ... done
[16:59:39.538] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:39.538] Future #2
[16:59:39.538] result() for ClusterFuture ...
[16:59:39.538] - result already collected: FutureResult
[16:59:39.538] result() for ClusterFuture ... done
[16:59:39.539] result() for ClusterFuture ...
[16:59:39.539] - result already collected: FutureResult
[16:59:39.539] result() for ClusterFuture ... done
[16:59:39.539] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:39.539] - nx: 2
[16:59:39.539] - relay: TRUE
[16:59:39.539] - stdout: TRUE
[16:59:39.539] - signal: TRUE
[16:59:39.539] - resignal: FALSE
[16:59:39.539] - force: TRUE
[16:59:39.539] - relayed: [n=2] TRUE, FALSE
[16:59:39.540] - queued futures: [n=2] TRUE, FALSE
[16:59:39.540]  - until=2
[16:59:39.540]  - relaying element #2
[16:59:39.540] result() for ClusterFuture ...
[16:59:39.540] - result already collected: FutureResult
[16:59:39.540] result() for ClusterFuture ... done
[16:59:39.540] result() for ClusterFuture ...
[16:59:39.540] - result already collected: FutureResult
[16:59:39.540] result() for ClusterFuture ... done
[16:59:39.540] result() for ClusterFuture ...
[16:59:39.540] - result already collected: FutureResult
[16:59:39.541] result() for ClusterFuture ... done
[16:59:39.541] result() for ClusterFuture ...
[16:59:39.541] - result already collected: FutureResult
[16:59:39.541] result() for ClusterFuture ... done
[16:59:39.541] - relayed: [n=2] TRUE, TRUE
[16:59:39.541] - queued futures: [n=2] TRUE, TRUE
[16:59:39.541] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:39.541]  length: 0 (resolved future 2)
[16:59:39.541] Relaying remaining futures
[16:59:39.541] signalConditionsASAP(NULL, pos=0) ...
[16:59:39.541] - nx: 2
[16:59:39.541] - relay: TRUE
[16:59:39.542] - stdout: TRUE
[16:59:39.542] - signal: TRUE
[16:59:39.542] - resignal: FALSE
[16:59:39.542] - force: TRUE
[16:59:39.542] - relayed: [n=2] TRUE, TRUE
[16:59:39.542] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:39.542] - relayed: [n=2] TRUE, TRUE
[16:59:39.542] - queued futures: [n=2] TRUE, TRUE
[16:59:39.542] signalConditionsASAP(NULL, pos=0) ... done
[16:59:39.542] resolve() on list ... DONE
[16:59:39.542] result() for ClusterFuture ...
[16:59:39.543] - result already collected: FutureResult
[16:59:39.543] result() for ClusterFuture ... done
[16:59:39.543] result() for ClusterFuture ...
[16:59:39.543] - result already collected: FutureResult
[16:59:39.543] result() for ClusterFuture ... done
[16:59:39.543] result() for ClusterFuture ...
[16:59:39.543] - result already collected: FutureResult
[16:59:39.543] result() for ClusterFuture ... done
[16:59:39.543] result() for ClusterFuture ...
[16:59:39.543] - result already collected: FutureResult
[16:59:39.543] result() for ClusterFuture ... done
[16:59:39.544]  - Number of value chunks collected: 2
[16:59:39.544] Resolving 2 futures (chunks) ... DONE
[16:59:39.544] Reducing values from 2 chunks ...
[16:59:39.544]  - Number of values collected after concatenation: 3
[16:59:39.544]  - Number of values expected: 3
[16:59:39.544] Reducing values from 2 chunks ... DONE
[16:59:39.544] future_lapply() ... DONE
[16:59:39.544] future_lapply() ...
[16:59:39.548] Number of chunks: 2
[16:59:39.548] getGlobalsAndPackagesXApply() ...
[16:59:39.548]  - future.globals: TRUE
[16:59:39.548] getGlobalsAndPackages() ...
[16:59:39.549] Searching for globals...
[16:59:39.550] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:39.550] Searching for globals ... DONE
[16:59:39.550] Resolving globals: FALSE
[16:59:39.550] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:59:39.550] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:59:39.551] - globals: [1] ‘FUN’
[16:59:39.551] - packages: [1] ‘stats’
[16:59:39.551] getGlobalsAndPackages() ... DONE
[16:59:39.551]  - globals found/used: [n=1] ‘FUN’
[16:59:39.551]  - needed namespaces: [n=1] ‘stats’
[16:59:39.551] Finding globals ... DONE
[16:59:39.551]  - use_args: TRUE
[16:59:39.551]  - Getting '...' globals ...
[16:59:39.552] resolve() on list ...
[16:59:39.552]  recursive: 0
[16:59:39.552]  length: 1
[16:59:39.552]  elements: ‘...’
[16:59:39.552]  length: 0 (resolved future 1)
[16:59:39.552] resolve() on list ... DONE
[16:59:39.552]    - '...' content: [n=0] 
[16:59:39.552] List of 1
[16:59:39.552]  $ ...: list()
[16:59:39.552]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:39.552]  - attr(*, "where")=List of 1
[16:59:39.552]   ..$ ...:<environment: 0x55c349b0ca90> 
[16:59:39.552]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:39.552]  - attr(*, "resolved")= logi TRUE
[16:59:39.552]  - attr(*, "total_size")= num NA
[16:59:39.555]  - Getting '...' globals ... DONE
[16:59:39.555] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:39.555] List of 2
[16:59:39.555]  $ ...future.FUN:function (x, ...)  
[16:59:39.555]  $ ...          : list()
[16:59:39.555]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:39.555]  - attr(*, "where")=List of 2
[16:59:39.555]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:39.555]   ..$ ...          :<environment: 0x55c349b0ca90> 
[16:59:39.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:39.555]  - attr(*, "resolved")= logi FALSE
[16:59:39.555]  - attr(*, "total_size")= num 1248
[16:59:39.558] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:39.558] getGlobalsAndPackagesXApply() ... DONE
[16:59:39.558] Number of futures (= number of chunks): 2
[16:59:39.558] Launching 2 futures (chunks) ...
[16:59:39.558] Chunk #1 of 2 ...
[16:59:39.558]  - Finding globals in 'X' for chunk #1 ...
[16:59:39.558] getGlobalsAndPackages() ...
[16:59:39.559] Searching for globals...
[16:59:39.559] 
[16:59:39.559] Searching for globals ... DONE
[16:59:39.559] - globals: [0] <none>
[16:59:39.559] getGlobalsAndPackages() ... DONE
[16:59:39.559]    + additional globals found: [n=0] 
[16:59:39.559]    + additional namespaces needed: [n=0] 
[16:59:39.559]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:39.559]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:39.560]  - seeds: <none>
[16:59:39.560]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.560] getGlobalsAndPackages() ...
[16:59:39.560] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.560] Resolving globals: FALSE
[16:59:39.560] Tweak future expression to call with '...' arguments ...
[16:59:39.560] {
[16:59:39.560]     do.call(function(...) {
[16:59:39.560]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.560]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.560]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.560]             on.exit(options(oopts), add = TRUE)
[16:59:39.560]         }
[16:59:39.560]         {
[16:59:39.560]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.560]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.560]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.560]             })
[16:59:39.560]         }
[16:59:39.560]     }, args = future.call.arguments)
[16:59:39.560] }
[16:59:39.560] Tweak future expression to call with '...' arguments ... DONE
[16:59:39.561] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.561] - packages: [1] ‘stats’
[16:59:39.561] getGlobalsAndPackages() ... DONE
[16:59:39.561] run() for ‘Future’ ...
[16:59:39.561] - state: ‘created’
[16:59:39.561] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:39.575] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.575] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:39.575]   - Field: ‘node’
[16:59:39.575]   - Field: ‘label’
[16:59:39.575]   - Field: ‘local’
[16:59:39.576]   - Field: ‘owner’
[16:59:39.576]   - Field: ‘envir’
[16:59:39.576]   - Field: ‘workers’
[16:59:39.576]   - Field: ‘packages’
[16:59:39.576]   - Field: ‘gc’
[16:59:39.576]   - Field: ‘conditions’
[16:59:39.576]   - Field: ‘persistent’
[16:59:39.576]   - Field: ‘expr’
[16:59:39.576]   - Field: ‘uuid’
[16:59:39.576]   - Field: ‘seed’
[16:59:39.576]   - Field: ‘version’
[16:59:39.577]   - Field: ‘result’
[16:59:39.577]   - Field: ‘asynchronous’
[16:59:39.577]   - Field: ‘calls’
[16:59:39.577]   - Field: ‘globals’
[16:59:39.577]   - Field: ‘stdout’
[16:59:39.577]   - Field: ‘earlySignal’
[16:59:39.577]   - Field: ‘lazy’
[16:59:39.577]   - Field: ‘state’
[16:59:39.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:39.577] - Launch lazy future ...
[16:59:39.578] Packages needed by the future expression (n = 1): ‘stats’
[16:59:39.578] Packages needed by future strategies (n = 0): <none>
[16:59:39.578] {
[16:59:39.578]     {
[16:59:39.578]         {
[16:59:39.578]             ...future.startTime <- base::Sys.time()
[16:59:39.578]             {
[16:59:39.578]                 {
[16:59:39.578]                   {
[16:59:39.578]                     {
[16:59:39.578]                       {
[16:59:39.578]                         base::local({
[16:59:39.578]                           has_future <- base::requireNamespace("future", 
[16:59:39.578]                             quietly = TRUE)
[16:59:39.578]                           if (has_future) {
[16:59:39.578]                             ns <- base::getNamespace("future")
[16:59:39.578]                             version <- ns[[".package"]][["version"]]
[16:59:39.578]                             if (is.null(version)) 
[16:59:39.578]                               version <- utils::packageVersion("future")
[16:59:39.578]                           }
[16:59:39.578]                           else {
[16:59:39.578]                             version <- NULL
[16:59:39.578]                           }
[16:59:39.578]                           if (!has_future || version < "1.8.0") {
[16:59:39.578]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:39.578]                               "", base::R.version$version.string), 
[16:59:39.578]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:39.578]                                 base::R.version$platform, 8 * 
[16:59:39.578]                                   base::.Machine$sizeof.pointer), 
[16:59:39.578]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:39.578]                                 "release", "version")], collapse = " "), 
[16:59:39.578]                               hostname = base::Sys.info()[["nodename"]])
[16:59:39.578]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:39.578]                               info)
[16:59:39.578]                             info <- base::paste(info, collapse = "; ")
[16:59:39.578]                             if (!has_future) {
[16:59:39.578]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:39.578]                                 info)
[16:59:39.578]                             }
[16:59:39.578]                             else {
[16:59:39.578]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:39.578]                                 info, version)
[16:59:39.578]                             }
[16:59:39.578]                             base::stop(msg)
[16:59:39.578]                           }
[16:59:39.578]                         })
[16:59:39.578]                       }
[16:59:39.578]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:39.578]                       base::options(mc.cores = 1L)
[16:59:39.578]                     }
[16:59:39.578]                     base::local({
[16:59:39.578]                       for (pkg in "stats") {
[16:59:39.578]                         base::loadNamespace(pkg)
[16:59:39.578]                         base::library(pkg, character.only = TRUE)
[16:59:39.578]                       }
[16:59:39.578]                     })
[16:59:39.578]                   }
[16:59:39.578]                   ...future.strategy.old <- future::plan("list")
[16:59:39.578]                   options(future.plan = NULL)
[16:59:39.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:39.578]                 }
[16:59:39.578]                 ...future.workdir <- getwd()
[16:59:39.578]             }
[16:59:39.578]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:39.578]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:39.578]         }
[16:59:39.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:39.578]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:39.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:39.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:39.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:39.578]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:39.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:39.578]             base::names(...future.oldOptions))
[16:59:39.578]     }
[16:59:39.578]     if (FALSE) {
[16:59:39.578]     }
[16:59:39.578]     else {
[16:59:39.578]         if (TRUE) {
[16:59:39.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:39.578]                 open = "w")
[16:59:39.578]         }
[16:59:39.578]         else {
[16:59:39.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:39.578]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:39.578]         }
[16:59:39.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:39.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:39.578]             base::sink(type = "output", split = FALSE)
[16:59:39.578]             base::close(...future.stdout)
[16:59:39.578]         }, add = TRUE)
[16:59:39.578]     }
[16:59:39.578]     ...future.frame <- base::sys.nframe()
[16:59:39.578]     ...future.conditions <- base::list()
[16:59:39.578]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:39.578]     if (FALSE) {
[16:59:39.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:39.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:39.578]     }
[16:59:39.578]     ...future.result <- base::tryCatch({
[16:59:39.578]         base::withCallingHandlers({
[16:59:39.578]             ...future.value <- base::withVisible(base::local({
[16:59:39.578]                 ...future.makeSendCondition <- base::local({
[16:59:39.578]                   sendCondition <- NULL
[16:59:39.578]                   function(frame = 1L) {
[16:59:39.578]                     if (is.function(sendCondition)) 
[16:59:39.578]                       return(sendCondition)
[16:59:39.578]                     ns <- getNamespace("parallel")
[16:59:39.578]                     if (exists("sendData", mode = "function", 
[16:59:39.578]                       envir = ns)) {
[16:59:39.578]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:39.578]                         envir = ns)
[16:59:39.578]                       envir <- sys.frame(frame)
[16:59:39.578]                       master <- NULL
[16:59:39.578]                       while (!identical(envir, .GlobalEnv) && 
[16:59:39.578]                         !identical(envir, emptyenv())) {
[16:59:39.578]                         if (exists("master", mode = "list", envir = envir, 
[16:59:39.578]                           inherits = FALSE)) {
[16:59:39.578]                           master <- get("master", mode = "list", 
[16:59:39.578]                             envir = envir, inherits = FALSE)
[16:59:39.578]                           if (inherits(master, c("SOCKnode", 
[16:59:39.578]                             "SOCK0node"))) {
[16:59:39.578]                             sendCondition <<- function(cond) {
[16:59:39.578]                               data <- list(type = "VALUE", value = cond, 
[16:59:39.578]                                 success = TRUE)
[16:59:39.578]                               parallel_sendData(master, data)
[16:59:39.578]                             }
[16:59:39.578]                             return(sendCondition)
[16:59:39.578]                           }
[16:59:39.578]                         }
[16:59:39.578]                         frame <- frame + 1L
[16:59:39.578]                         envir <- sys.frame(frame)
[16:59:39.578]                       }
[16:59:39.578]                     }
[16:59:39.578]                     sendCondition <<- function(cond) NULL
[16:59:39.578]                   }
[16:59:39.578]                 })
[16:59:39.578]                 withCallingHandlers({
[16:59:39.578]                   {
[16:59:39.578]                     do.call(function(...) {
[16:59:39.578]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.578]                       if (!identical(...future.globals.maxSize.org, 
[16:59:39.578]                         ...future.globals.maxSize)) {
[16:59:39.578]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.578]                         on.exit(options(oopts), add = TRUE)
[16:59:39.578]                       }
[16:59:39.578]                       {
[16:59:39.578]                         lapply(seq_along(...future.elements_ii), 
[16:59:39.578]                           FUN = function(jj) {
[16:59:39.578]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.578]                             ...future.FUN(...future.X_jj, ...)
[16:59:39.578]                           })
[16:59:39.578]                       }
[16:59:39.578]                     }, args = future.call.arguments)
[16:59:39.578]                   }
[16:59:39.578]                 }, immediateCondition = function(cond) {
[16:59:39.578]                   sendCondition <- ...future.makeSendCondition()
[16:59:39.578]                   sendCondition(cond)
[16:59:39.578]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.578]                   {
[16:59:39.578]                     inherits <- base::inherits
[16:59:39.578]                     invokeRestart <- base::invokeRestart
[16:59:39.578]                     is.null <- base::is.null
[16:59:39.578]                     muffled <- FALSE
[16:59:39.578]                     if (inherits(cond, "message")) {
[16:59:39.578]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:39.578]                       if (muffled) 
[16:59:39.578]                         invokeRestart("muffleMessage")
[16:59:39.578]                     }
[16:59:39.578]                     else if (inherits(cond, "warning")) {
[16:59:39.578]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:39.578]                       if (muffled) 
[16:59:39.578]                         invokeRestart("muffleWarning")
[16:59:39.578]                     }
[16:59:39.578]                     else if (inherits(cond, "condition")) {
[16:59:39.578]                       if (!is.null(pattern)) {
[16:59:39.578]                         computeRestarts <- base::computeRestarts
[16:59:39.578]                         grepl <- base::grepl
[16:59:39.578]                         restarts <- computeRestarts(cond)
[16:59:39.578]                         for (restart in restarts) {
[16:59:39.578]                           name <- restart$name
[16:59:39.578]                           if (is.null(name)) 
[16:59:39.578]                             next
[16:59:39.578]                           if (!grepl(pattern, name)) 
[16:59:39.578]                             next
[16:59:39.578]                           invokeRestart(restart)
[16:59:39.578]                           muffled <- TRUE
[16:59:39.578]                           break
[16:59:39.578]                         }
[16:59:39.578]                       }
[16:59:39.578]                     }
[16:59:39.578]                     invisible(muffled)
[16:59:39.578]                   }
[16:59:39.578]                   muffleCondition(cond)
[16:59:39.578]                 })
[16:59:39.578]             }))
[16:59:39.578]             future::FutureResult(value = ...future.value$value, 
[16:59:39.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.578]                   ...future.rng), globalenv = if (FALSE) 
[16:59:39.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:39.578]                     ...future.globalenv.names))
[16:59:39.578]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:39.578]         }, condition = base::local({
[16:59:39.578]             c <- base::c
[16:59:39.578]             inherits <- base::inherits
[16:59:39.578]             invokeRestart <- base::invokeRestart
[16:59:39.578]             length <- base::length
[16:59:39.578]             list <- base::list
[16:59:39.578]             seq.int <- base::seq.int
[16:59:39.578]             signalCondition <- base::signalCondition
[16:59:39.578]             sys.calls <- base::sys.calls
[16:59:39.578]             `[[` <- base::`[[`
[16:59:39.578]             `+` <- base::`+`
[16:59:39.578]             `<<-` <- base::`<<-`
[16:59:39.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:39.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:39.578]                   3L)]
[16:59:39.578]             }
[16:59:39.578]             function(cond) {
[16:59:39.578]                 is_error <- inherits(cond, "error")
[16:59:39.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:39.578]                   NULL)
[16:59:39.578]                 if (is_error) {
[16:59:39.578]                   sessionInformation <- function() {
[16:59:39.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:39.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:39.578]                       search = base::search(), system = base::Sys.info())
[16:59:39.578]                   }
[16:59:39.578]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:39.578]                     cond$call), session = sessionInformation(), 
[16:59:39.578]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:39.578]                   signalCondition(cond)
[16:59:39.578]                 }
[16:59:39.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:39.578]                 "immediateCondition"))) {
[16:59:39.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:39.578]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:39.578]                   if (TRUE && !signal) {
[16:59:39.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.578]                     {
[16:59:39.578]                       inherits <- base::inherits
[16:59:39.578]                       invokeRestart <- base::invokeRestart
[16:59:39.578]                       is.null <- base::is.null
[16:59:39.578]                       muffled <- FALSE
[16:59:39.578]                       if (inherits(cond, "message")) {
[16:59:39.578]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.578]                         if (muffled) 
[16:59:39.578]                           invokeRestart("muffleMessage")
[16:59:39.578]                       }
[16:59:39.578]                       else if (inherits(cond, "warning")) {
[16:59:39.578]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.578]                         if (muffled) 
[16:59:39.578]                           invokeRestart("muffleWarning")
[16:59:39.578]                       }
[16:59:39.578]                       else if (inherits(cond, "condition")) {
[16:59:39.578]                         if (!is.null(pattern)) {
[16:59:39.578]                           computeRestarts <- base::computeRestarts
[16:59:39.578]                           grepl <- base::grepl
[16:59:39.578]                           restarts <- computeRestarts(cond)
[16:59:39.578]                           for (restart in restarts) {
[16:59:39.578]                             name <- restart$name
[16:59:39.578]                             if (is.null(name)) 
[16:59:39.578]                               next
[16:59:39.578]                             if (!grepl(pattern, name)) 
[16:59:39.578]                               next
[16:59:39.578]                             invokeRestart(restart)
[16:59:39.578]                             muffled <- TRUE
[16:59:39.578]                             break
[16:59:39.578]                           }
[16:59:39.578]                         }
[16:59:39.578]                       }
[16:59:39.578]                       invisible(muffled)
[16:59:39.578]                     }
[16:59:39.578]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.578]                   }
[16:59:39.578]                 }
[16:59:39.578]                 else {
[16:59:39.578]                   if (TRUE) {
[16:59:39.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.578]                     {
[16:59:39.578]                       inherits <- base::inherits
[16:59:39.578]                       invokeRestart <- base::invokeRestart
[16:59:39.578]                       is.null <- base::is.null
[16:59:39.578]                       muffled <- FALSE
[16:59:39.578]                       if (inherits(cond, "message")) {
[16:59:39.578]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.578]                         if (muffled) 
[16:59:39.578]                           invokeRestart("muffleMessage")
[16:59:39.578]                       }
[16:59:39.578]                       else if (inherits(cond, "warning")) {
[16:59:39.578]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.578]                         if (muffled) 
[16:59:39.578]                           invokeRestart("muffleWarning")
[16:59:39.578]                       }
[16:59:39.578]                       else if (inherits(cond, "condition")) {
[16:59:39.578]                         if (!is.null(pattern)) {
[16:59:39.578]                           computeRestarts <- base::computeRestarts
[16:59:39.578]                           grepl <- base::grepl
[16:59:39.578]                           restarts <- computeRestarts(cond)
[16:59:39.578]                           for (restart in restarts) {
[16:59:39.578]                             name <- restart$name
[16:59:39.578]                             if (is.null(name)) 
[16:59:39.578]                               next
[16:59:39.578]                             if (!grepl(pattern, name)) 
[16:59:39.578]                               next
[16:59:39.578]                             invokeRestart(restart)
[16:59:39.578]                             muffled <- TRUE
[16:59:39.578]                             break
[16:59:39.578]                           }
[16:59:39.578]                         }
[16:59:39.578]                       }
[16:59:39.578]                       invisible(muffled)
[16:59:39.578]                     }
[16:59:39.578]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.578]                   }
[16:59:39.578]                 }
[16:59:39.578]             }
[16:59:39.578]         }))
[16:59:39.578]     }, error = function(ex) {
[16:59:39.578]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:39.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.578]                 ...future.rng), started = ...future.startTime, 
[16:59:39.578]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:39.578]             version = "1.8"), class = "FutureResult")
[16:59:39.578]     }, finally = {
[16:59:39.578]         if (!identical(...future.workdir, getwd())) 
[16:59:39.578]             setwd(...future.workdir)
[16:59:39.578]         {
[16:59:39.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:39.578]                 ...future.oldOptions$nwarnings <- NULL
[16:59:39.578]             }
[16:59:39.578]             base::options(...future.oldOptions)
[16:59:39.578]             if (.Platform$OS.type == "windows") {
[16:59:39.578]                 old_names <- names(...future.oldEnvVars)
[16:59:39.578]                 envs <- base::Sys.getenv()
[16:59:39.578]                 names <- names(envs)
[16:59:39.578]                 common <- intersect(names, old_names)
[16:59:39.578]                 added <- setdiff(names, old_names)
[16:59:39.578]                 removed <- setdiff(old_names, names)
[16:59:39.578]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:39.578]                   envs[common]]
[16:59:39.578]                 NAMES <- toupper(changed)
[16:59:39.578]                 args <- list()
[16:59:39.578]                 for (kk in seq_along(NAMES)) {
[16:59:39.578]                   name <- changed[[kk]]
[16:59:39.578]                   NAME <- NAMES[[kk]]
[16:59:39.578]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.578]                     next
[16:59:39.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.578]                 }
[16:59:39.578]                 NAMES <- toupper(added)
[16:59:39.578]                 for (kk in seq_along(NAMES)) {
[16:59:39.578]                   name <- added[[kk]]
[16:59:39.578]                   NAME <- NAMES[[kk]]
[16:59:39.578]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.578]                     next
[16:59:39.578]                   args[[name]] <- ""
[16:59:39.578]                 }
[16:59:39.578]                 NAMES <- toupper(removed)
[16:59:39.578]                 for (kk in seq_along(NAMES)) {
[16:59:39.578]                   name <- removed[[kk]]
[16:59:39.578]                   NAME <- NAMES[[kk]]
[16:59:39.578]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.578]                     next
[16:59:39.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.578]                 }
[16:59:39.578]                 if (length(args) > 0) 
[16:59:39.578]                   base::do.call(base::Sys.setenv, args = args)
[16:59:39.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:39.578]             }
[16:59:39.578]             else {
[16:59:39.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:39.578]             }
[16:59:39.578]             {
[16:59:39.578]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:39.578]                   0L) {
[16:59:39.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:39.578]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:39.578]                   base::options(opts)
[16:59:39.578]                 }
[16:59:39.578]                 {
[16:59:39.578]                   {
[16:59:39.578]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:39.578]                     NULL
[16:59:39.578]                   }
[16:59:39.578]                   options(future.plan = NULL)
[16:59:39.578]                   if (is.na(NA_character_)) 
[16:59:39.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:39.578]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:39.578]                     .init = FALSE)
[16:59:39.578]                 }
[16:59:39.578]             }
[16:59:39.578]         }
[16:59:39.578]     })
[16:59:39.578]     if (TRUE) {
[16:59:39.578]         base::sink(type = "output", split = FALSE)
[16:59:39.578]         if (TRUE) {
[16:59:39.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:39.578]         }
[16:59:39.578]         else {
[16:59:39.578]             ...future.result["stdout"] <- base::list(NULL)
[16:59:39.578]         }
[16:59:39.578]         base::close(...future.stdout)
[16:59:39.578]         ...future.stdout <- NULL
[16:59:39.578]     }
[16:59:39.578]     ...future.result$conditions <- ...future.conditions
[16:59:39.578]     ...future.result$finished <- base::Sys.time()
[16:59:39.578]     ...future.result
[16:59:39.578] }
[16:59:39.581] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[16:59:39.581] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:59:39.581] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:59:39.582] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:39.582] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:39.582] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:59:39.582] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:59:39.583] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:39.583] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:39.583] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:59:39.583] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:59:39.583] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[16:59:39.584] MultisessionFuture started
[16:59:39.584] - Launch lazy future ... done
[16:59:39.584] run() for ‘MultisessionFuture’ ... done
[16:59:39.584] Created future:
[16:59:39.584] MultisessionFuture:
[16:59:39.584] Label: ‘future_eapply-1’
[16:59:39.584] Expression:
[16:59:39.584] {
[16:59:39.584]     do.call(function(...) {
[16:59:39.584]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.584]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.584]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.584]             on.exit(options(oopts), add = TRUE)
[16:59:39.584]         }
[16:59:39.584]         {
[16:59:39.584]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.584]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.584]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.584]             })
[16:59:39.584]         }
[16:59:39.584]     }, args = future.call.arguments)
[16:59:39.584] }
[16:59:39.584] Lazy evaluation: FALSE
[16:59:39.584] Asynchronous evaluation: TRUE
[16:59:39.584] Local evaluation: TRUE
[16:59:39.584] Environment: R_GlobalEnv
[16:59:39.584] Capture standard output: TRUE
[16:59:39.584] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:39.584] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:39.584] Packages: 1 packages (‘stats’)
[16:59:39.584] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:39.584] Resolved: FALSE
[16:59:39.584] Value: <not collected>
[16:59:39.584] Conditions captured: <none>
[16:59:39.584] Early signaling: FALSE
[16:59:39.584] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:39.584] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.596] Chunk #1 of 2 ... DONE
[16:59:39.596] Chunk #2 of 2 ...
[16:59:39.596]  - Finding globals in 'X' for chunk #2 ...
[16:59:39.596] getGlobalsAndPackages() ...
[16:59:39.596] Searching for globals...
[16:59:39.596] 
[16:59:39.596] Searching for globals ... DONE
[16:59:39.597] - globals: [0] <none>
[16:59:39.597] getGlobalsAndPackages() ... DONE
[16:59:39.597]    + additional globals found: [n=0] 
[16:59:39.597]    + additional namespaces needed: [n=0] 
[16:59:39.597]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:39.597]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:39.597]  - seeds: <none>
[16:59:39.597]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.597] getGlobalsAndPackages() ...
[16:59:39.597] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.598] Resolving globals: FALSE
[16:59:39.598] Tweak future expression to call with '...' arguments ...
[16:59:39.598] {
[16:59:39.598]     do.call(function(...) {
[16:59:39.598]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.598]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.598]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.598]             on.exit(options(oopts), add = TRUE)
[16:59:39.598]         }
[16:59:39.598]         {
[16:59:39.598]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.598]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.598]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.598]             })
[16:59:39.598]         }
[16:59:39.598]     }, args = future.call.arguments)
[16:59:39.598] }
[16:59:39.598] Tweak future expression to call with '...' arguments ... DONE
[16:59:39.598] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:39.598] - packages: [1] ‘stats’
[16:59:39.599] getGlobalsAndPackages() ... DONE
[16:59:39.599] run() for ‘Future’ ...
[16:59:39.599] - state: ‘created’
[16:59:39.599] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:39.617] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:39.617]   - Field: ‘node’
[16:59:39.617]   - Field: ‘label’
[16:59:39.617]   - Field: ‘local’
[16:59:39.617]   - Field: ‘owner’
[16:59:39.618]   - Field: ‘envir’
[16:59:39.618]   - Field: ‘workers’
[16:59:39.618]   - Field: ‘packages’
[16:59:39.618]   - Field: ‘gc’
[16:59:39.618]   - Field: ‘conditions’
[16:59:39.618]   - Field: ‘persistent’
[16:59:39.618]   - Field: ‘expr’
[16:59:39.618]   - Field: ‘uuid’
[16:59:39.618]   - Field: ‘seed’
[16:59:39.618]   - Field: ‘version’
[16:59:39.618]   - Field: ‘result’
[16:59:39.619]   - Field: ‘asynchronous’
[16:59:39.619]   - Field: ‘calls’
[16:59:39.619]   - Field: ‘globals’
[16:59:39.619]   - Field: ‘stdout’
[16:59:39.619]   - Field: ‘earlySignal’
[16:59:39.619]   - Field: ‘lazy’
[16:59:39.619]   - Field: ‘state’
[16:59:39.619] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:39.619] - Launch lazy future ...
[16:59:39.619] Packages needed by the future expression (n = 1): ‘stats’
[16:59:39.620] Packages needed by future strategies (n = 0): <none>
[16:59:39.620] {
[16:59:39.620]     {
[16:59:39.620]         {
[16:59:39.620]             ...future.startTime <- base::Sys.time()
[16:59:39.620]             {
[16:59:39.620]                 {
[16:59:39.620]                   {
[16:59:39.620]                     {
[16:59:39.620]                       {
[16:59:39.620]                         base::local({
[16:59:39.620]                           has_future <- base::requireNamespace("future", 
[16:59:39.620]                             quietly = TRUE)
[16:59:39.620]                           if (has_future) {
[16:59:39.620]                             ns <- base::getNamespace("future")
[16:59:39.620]                             version <- ns[[".package"]][["version"]]
[16:59:39.620]                             if (is.null(version)) 
[16:59:39.620]                               version <- utils::packageVersion("future")
[16:59:39.620]                           }
[16:59:39.620]                           else {
[16:59:39.620]                             version <- NULL
[16:59:39.620]                           }
[16:59:39.620]                           if (!has_future || version < "1.8.0") {
[16:59:39.620]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:39.620]                               "", base::R.version$version.string), 
[16:59:39.620]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:39.620]                                 base::R.version$platform, 8 * 
[16:59:39.620]                                   base::.Machine$sizeof.pointer), 
[16:59:39.620]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:39.620]                                 "release", "version")], collapse = " "), 
[16:59:39.620]                               hostname = base::Sys.info()[["nodename"]])
[16:59:39.620]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:39.620]                               info)
[16:59:39.620]                             info <- base::paste(info, collapse = "; ")
[16:59:39.620]                             if (!has_future) {
[16:59:39.620]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:39.620]                                 info)
[16:59:39.620]                             }
[16:59:39.620]                             else {
[16:59:39.620]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:39.620]                                 info, version)
[16:59:39.620]                             }
[16:59:39.620]                             base::stop(msg)
[16:59:39.620]                           }
[16:59:39.620]                         })
[16:59:39.620]                       }
[16:59:39.620]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:39.620]                       base::options(mc.cores = 1L)
[16:59:39.620]                     }
[16:59:39.620]                     base::local({
[16:59:39.620]                       for (pkg in "stats") {
[16:59:39.620]                         base::loadNamespace(pkg)
[16:59:39.620]                         base::library(pkg, character.only = TRUE)
[16:59:39.620]                       }
[16:59:39.620]                     })
[16:59:39.620]                   }
[16:59:39.620]                   ...future.strategy.old <- future::plan("list")
[16:59:39.620]                   options(future.plan = NULL)
[16:59:39.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.620]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:39.620]                 }
[16:59:39.620]                 ...future.workdir <- getwd()
[16:59:39.620]             }
[16:59:39.620]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:39.620]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:39.620]         }
[16:59:39.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:39.620]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:39.620]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:39.620]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:39.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:39.620]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:39.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:39.620]             base::names(...future.oldOptions))
[16:59:39.620]     }
[16:59:39.620]     if (FALSE) {
[16:59:39.620]     }
[16:59:39.620]     else {
[16:59:39.620]         if (TRUE) {
[16:59:39.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:39.620]                 open = "w")
[16:59:39.620]         }
[16:59:39.620]         else {
[16:59:39.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:39.620]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:39.620]         }
[16:59:39.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:39.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:39.620]             base::sink(type = "output", split = FALSE)
[16:59:39.620]             base::close(...future.stdout)
[16:59:39.620]         }, add = TRUE)
[16:59:39.620]     }
[16:59:39.620]     ...future.frame <- base::sys.nframe()
[16:59:39.620]     ...future.conditions <- base::list()
[16:59:39.620]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:39.620]     if (FALSE) {
[16:59:39.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:39.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:39.620]     }
[16:59:39.620]     ...future.result <- base::tryCatch({
[16:59:39.620]         base::withCallingHandlers({
[16:59:39.620]             ...future.value <- base::withVisible(base::local({
[16:59:39.620]                 ...future.makeSendCondition <- base::local({
[16:59:39.620]                   sendCondition <- NULL
[16:59:39.620]                   function(frame = 1L) {
[16:59:39.620]                     if (is.function(sendCondition)) 
[16:59:39.620]                       return(sendCondition)
[16:59:39.620]                     ns <- getNamespace("parallel")
[16:59:39.620]                     if (exists("sendData", mode = "function", 
[16:59:39.620]                       envir = ns)) {
[16:59:39.620]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:39.620]                         envir = ns)
[16:59:39.620]                       envir <- sys.frame(frame)
[16:59:39.620]                       master <- NULL
[16:59:39.620]                       while (!identical(envir, .GlobalEnv) && 
[16:59:39.620]                         !identical(envir, emptyenv())) {
[16:59:39.620]                         if (exists("master", mode = "list", envir = envir, 
[16:59:39.620]                           inherits = FALSE)) {
[16:59:39.620]                           master <- get("master", mode = "list", 
[16:59:39.620]                             envir = envir, inherits = FALSE)
[16:59:39.620]                           if (inherits(master, c("SOCKnode", 
[16:59:39.620]                             "SOCK0node"))) {
[16:59:39.620]                             sendCondition <<- function(cond) {
[16:59:39.620]                               data <- list(type = "VALUE", value = cond, 
[16:59:39.620]                                 success = TRUE)
[16:59:39.620]                               parallel_sendData(master, data)
[16:59:39.620]                             }
[16:59:39.620]                             return(sendCondition)
[16:59:39.620]                           }
[16:59:39.620]                         }
[16:59:39.620]                         frame <- frame + 1L
[16:59:39.620]                         envir <- sys.frame(frame)
[16:59:39.620]                       }
[16:59:39.620]                     }
[16:59:39.620]                     sendCondition <<- function(cond) NULL
[16:59:39.620]                   }
[16:59:39.620]                 })
[16:59:39.620]                 withCallingHandlers({
[16:59:39.620]                   {
[16:59:39.620]                     do.call(function(...) {
[16:59:39.620]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.620]                       if (!identical(...future.globals.maxSize.org, 
[16:59:39.620]                         ...future.globals.maxSize)) {
[16:59:39.620]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.620]                         on.exit(options(oopts), add = TRUE)
[16:59:39.620]                       }
[16:59:39.620]                       {
[16:59:39.620]                         lapply(seq_along(...future.elements_ii), 
[16:59:39.620]                           FUN = function(jj) {
[16:59:39.620]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.620]                             ...future.FUN(...future.X_jj, ...)
[16:59:39.620]                           })
[16:59:39.620]                       }
[16:59:39.620]                     }, args = future.call.arguments)
[16:59:39.620]                   }
[16:59:39.620]                 }, immediateCondition = function(cond) {
[16:59:39.620]                   sendCondition <- ...future.makeSendCondition()
[16:59:39.620]                   sendCondition(cond)
[16:59:39.620]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.620]                   {
[16:59:39.620]                     inherits <- base::inherits
[16:59:39.620]                     invokeRestart <- base::invokeRestart
[16:59:39.620]                     is.null <- base::is.null
[16:59:39.620]                     muffled <- FALSE
[16:59:39.620]                     if (inherits(cond, "message")) {
[16:59:39.620]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:39.620]                       if (muffled) 
[16:59:39.620]                         invokeRestart("muffleMessage")
[16:59:39.620]                     }
[16:59:39.620]                     else if (inherits(cond, "warning")) {
[16:59:39.620]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:39.620]                       if (muffled) 
[16:59:39.620]                         invokeRestart("muffleWarning")
[16:59:39.620]                     }
[16:59:39.620]                     else if (inherits(cond, "condition")) {
[16:59:39.620]                       if (!is.null(pattern)) {
[16:59:39.620]                         computeRestarts <- base::computeRestarts
[16:59:39.620]                         grepl <- base::grepl
[16:59:39.620]                         restarts <- computeRestarts(cond)
[16:59:39.620]                         for (restart in restarts) {
[16:59:39.620]                           name <- restart$name
[16:59:39.620]                           if (is.null(name)) 
[16:59:39.620]                             next
[16:59:39.620]                           if (!grepl(pattern, name)) 
[16:59:39.620]                             next
[16:59:39.620]                           invokeRestart(restart)
[16:59:39.620]                           muffled <- TRUE
[16:59:39.620]                           break
[16:59:39.620]                         }
[16:59:39.620]                       }
[16:59:39.620]                     }
[16:59:39.620]                     invisible(muffled)
[16:59:39.620]                   }
[16:59:39.620]                   muffleCondition(cond)
[16:59:39.620]                 })
[16:59:39.620]             }))
[16:59:39.620]             future::FutureResult(value = ...future.value$value, 
[16:59:39.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.620]                   ...future.rng), globalenv = if (FALSE) 
[16:59:39.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:39.620]                     ...future.globalenv.names))
[16:59:39.620]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:39.620]         }, condition = base::local({
[16:59:39.620]             c <- base::c
[16:59:39.620]             inherits <- base::inherits
[16:59:39.620]             invokeRestart <- base::invokeRestart
[16:59:39.620]             length <- base::length
[16:59:39.620]             list <- base::list
[16:59:39.620]             seq.int <- base::seq.int
[16:59:39.620]             signalCondition <- base::signalCondition
[16:59:39.620]             sys.calls <- base::sys.calls
[16:59:39.620]             `[[` <- base::`[[`
[16:59:39.620]             `+` <- base::`+`
[16:59:39.620]             `<<-` <- base::`<<-`
[16:59:39.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:39.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:39.620]                   3L)]
[16:59:39.620]             }
[16:59:39.620]             function(cond) {
[16:59:39.620]                 is_error <- inherits(cond, "error")
[16:59:39.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:39.620]                   NULL)
[16:59:39.620]                 if (is_error) {
[16:59:39.620]                   sessionInformation <- function() {
[16:59:39.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:39.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:39.620]                       search = base::search(), system = base::Sys.info())
[16:59:39.620]                   }
[16:59:39.620]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:39.620]                     cond$call), session = sessionInformation(), 
[16:59:39.620]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:39.620]                   signalCondition(cond)
[16:59:39.620]                 }
[16:59:39.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:39.620]                 "immediateCondition"))) {
[16:59:39.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:39.620]                   ...future.conditions[[length(...future.conditions) + 
[16:59:39.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:39.620]                   if (TRUE && !signal) {
[16:59:39.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.620]                     {
[16:59:39.620]                       inherits <- base::inherits
[16:59:39.620]                       invokeRestart <- base::invokeRestart
[16:59:39.620]                       is.null <- base::is.null
[16:59:39.620]                       muffled <- FALSE
[16:59:39.620]                       if (inherits(cond, "message")) {
[16:59:39.620]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.620]                         if (muffled) 
[16:59:39.620]                           invokeRestart("muffleMessage")
[16:59:39.620]                       }
[16:59:39.620]                       else if (inherits(cond, "warning")) {
[16:59:39.620]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.620]                         if (muffled) 
[16:59:39.620]                           invokeRestart("muffleWarning")
[16:59:39.620]                       }
[16:59:39.620]                       else if (inherits(cond, "condition")) {
[16:59:39.620]                         if (!is.null(pattern)) {
[16:59:39.620]                           computeRestarts <- base::computeRestarts
[16:59:39.620]                           grepl <- base::grepl
[16:59:39.620]                           restarts <- computeRestarts(cond)
[16:59:39.620]                           for (restart in restarts) {
[16:59:39.620]                             name <- restart$name
[16:59:39.620]                             if (is.null(name)) 
[16:59:39.620]                               next
[16:59:39.620]                             if (!grepl(pattern, name)) 
[16:59:39.620]                               next
[16:59:39.620]                             invokeRestart(restart)
[16:59:39.620]                             muffled <- TRUE
[16:59:39.620]                             break
[16:59:39.620]                           }
[16:59:39.620]                         }
[16:59:39.620]                       }
[16:59:39.620]                       invisible(muffled)
[16:59:39.620]                     }
[16:59:39.620]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.620]                   }
[16:59:39.620]                 }
[16:59:39.620]                 else {
[16:59:39.620]                   if (TRUE) {
[16:59:39.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:39.620]                     {
[16:59:39.620]                       inherits <- base::inherits
[16:59:39.620]                       invokeRestart <- base::invokeRestart
[16:59:39.620]                       is.null <- base::is.null
[16:59:39.620]                       muffled <- FALSE
[16:59:39.620]                       if (inherits(cond, "message")) {
[16:59:39.620]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:39.620]                         if (muffled) 
[16:59:39.620]                           invokeRestart("muffleMessage")
[16:59:39.620]                       }
[16:59:39.620]                       else if (inherits(cond, "warning")) {
[16:59:39.620]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:39.620]                         if (muffled) 
[16:59:39.620]                           invokeRestart("muffleWarning")
[16:59:39.620]                       }
[16:59:39.620]                       else if (inherits(cond, "condition")) {
[16:59:39.620]                         if (!is.null(pattern)) {
[16:59:39.620]                           computeRestarts <- base::computeRestarts
[16:59:39.620]                           grepl <- base::grepl
[16:59:39.620]                           restarts <- computeRestarts(cond)
[16:59:39.620]                           for (restart in restarts) {
[16:59:39.620]                             name <- restart$name
[16:59:39.620]                             if (is.null(name)) 
[16:59:39.620]                               next
[16:59:39.620]                             if (!grepl(pattern, name)) 
[16:59:39.620]                               next
[16:59:39.620]                             invokeRestart(restart)
[16:59:39.620]                             muffled <- TRUE
[16:59:39.620]                             break
[16:59:39.620]                           }
[16:59:39.620]                         }
[16:59:39.620]                       }
[16:59:39.620]                       invisible(muffled)
[16:59:39.620]                     }
[16:59:39.620]                     muffleCondition(cond, pattern = "^muffle")
[16:59:39.620]                   }
[16:59:39.620]                 }
[16:59:39.620]             }
[16:59:39.620]         }))
[16:59:39.620]     }, error = function(ex) {
[16:59:39.620]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:39.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:39.620]                 ...future.rng), started = ...future.startTime, 
[16:59:39.620]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:39.620]             version = "1.8"), class = "FutureResult")
[16:59:39.620]     }, finally = {
[16:59:39.620]         if (!identical(...future.workdir, getwd())) 
[16:59:39.620]             setwd(...future.workdir)
[16:59:39.620]         {
[16:59:39.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:39.620]                 ...future.oldOptions$nwarnings <- NULL
[16:59:39.620]             }
[16:59:39.620]             base::options(...future.oldOptions)
[16:59:39.620]             if (.Platform$OS.type == "windows") {
[16:59:39.620]                 old_names <- names(...future.oldEnvVars)
[16:59:39.620]                 envs <- base::Sys.getenv()
[16:59:39.620]                 names <- names(envs)
[16:59:39.620]                 common <- intersect(names, old_names)
[16:59:39.620]                 added <- setdiff(names, old_names)
[16:59:39.620]                 removed <- setdiff(old_names, names)
[16:59:39.620]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:39.620]                   envs[common]]
[16:59:39.620]                 NAMES <- toupper(changed)
[16:59:39.620]                 args <- list()
[16:59:39.620]                 for (kk in seq_along(NAMES)) {
[16:59:39.620]                   name <- changed[[kk]]
[16:59:39.620]                   NAME <- NAMES[[kk]]
[16:59:39.620]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.620]                     next
[16:59:39.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.620]                 }
[16:59:39.620]                 NAMES <- toupper(added)
[16:59:39.620]                 for (kk in seq_along(NAMES)) {
[16:59:39.620]                   name <- added[[kk]]
[16:59:39.620]                   NAME <- NAMES[[kk]]
[16:59:39.620]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.620]                     next
[16:59:39.620]                   args[[name]] <- ""
[16:59:39.620]                 }
[16:59:39.620]                 NAMES <- toupper(removed)
[16:59:39.620]                 for (kk in seq_along(NAMES)) {
[16:59:39.620]                   name <- removed[[kk]]
[16:59:39.620]                   NAME <- NAMES[[kk]]
[16:59:39.620]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:39.620]                     next
[16:59:39.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:39.620]                 }
[16:59:39.620]                 if (length(args) > 0) 
[16:59:39.620]                   base::do.call(base::Sys.setenv, args = args)
[16:59:39.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:39.620]             }
[16:59:39.620]             else {
[16:59:39.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:39.620]             }
[16:59:39.620]             {
[16:59:39.620]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:39.620]                   0L) {
[16:59:39.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:39.620]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:39.620]                   base::options(opts)
[16:59:39.620]                 }
[16:59:39.620]                 {
[16:59:39.620]                   {
[16:59:39.620]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:39.620]                     NULL
[16:59:39.620]                   }
[16:59:39.620]                   options(future.plan = NULL)
[16:59:39.620]                   if (is.na(NA_character_)) 
[16:59:39.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:39.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:39.620]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:39.620]                     .init = FALSE)
[16:59:39.620]                 }
[16:59:39.620]             }
[16:59:39.620]         }
[16:59:39.620]     })
[16:59:39.620]     if (TRUE) {
[16:59:39.620]         base::sink(type = "output", split = FALSE)
[16:59:39.620]         if (TRUE) {
[16:59:39.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:39.620]         }
[16:59:39.620]         else {
[16:59:39.620]             ...future.result["stdout"] <- base::list(NULL)
[16:59:39.620]         }
[16:59:39.620]         base::close(...future.stdout)
[16:59:39.620]         ...future.stdout <- NULL
[16:59:39.620]     }
[16:59:39.620]     ...future.result$conditions <- ...future.conditions
[16:59:39.620]     ...future.result$finished <- base::Sys.time()
[16:59:39.620]     ...future.result
[16:59:39.620] }
[16:59:39.623] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[16:59:39.623] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:59:39.623] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:59:39.623] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:59:39.624] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:59:39.624] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:59:39.624] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:59:39.624] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:39.625] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:39.625] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:59:39.625] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:59:39.625] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[16:59:39.626] MultisessionFuture started
[16:59:39.626] - Launch lazy future ... done
[16:59:39.626] run() for ‘MultisessionFuture’ ... done
[16:59:39.626] Created future:
[16:59:39.626] MultisessionFuture:
[16:59:39.626] Label: ‘future_eapply-2’
[16:59:39.626] Expression:
[16:59:39.626] {
[16:59:39.626]     do.call(function(...) {
[16:59:39.626]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:39.626]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:39.626]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:39.626]             on.exit(options(oopts), add = TRUE)
[16:59:39.626]         }
[16:59:39.626]         {
[16:59:39.626]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:39.626]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:39.626]                 ...future.FUN(...future.X_jj, ...)
[16:59:39.626]             })
[16:59:39.626]         }
[16:59:39.626]     }, args = future.call.arguments)
[16:59:39.626] }
[16:59:39.626] Lazy evaluation: FALSE
[16:59:39.626] Asynchronous evaluation: TRUE
[16:59:39.626] Local evaluation: TRUE
[16:59:39.626] Environment: R_GlobalEnv
[16:59:39.626] Capture standard output: TRUE
[16:59:39.626] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:39.626] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:39.626] Packages: 1 packages (‘stats’)
[16:59:39.626] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:39.626] Resolved: FALSE
[16:59:39.626] Value: <not collected>
[16:59:39.626] Conditions captured: <none>
[16:59:39.626] Early signaling: FALSE
[16:59:39.626] Owner process: 379d9905-cdd9-b380-dc86-e0accd4e5d65
[16:59:39.626] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:39.638] Chunk #2 of 2 ... DONE
[16:59:39.638] Launching 2 futures (chunks) ... DONE
[16:59:39.638] Resolving 2 futures (chunks) ...
[16:59:39.638] resolve() on list ...
[16:59:39.638]  recursive: 0
[16:59:39.638]  length: 2
[16:59:39.638] 
[16:59:39.639] receiveMessageFromWorker() for ClusterFuture ...
[16:59:39.639] - Validating connection of MultisessionFuture
[16:59:39.639] - received message: FutureResult
[16:59:39.639] - Received FutureResult
[16:59:39.639] - Erased future from FutureRegistry
[16:59:39.640] result() for ClusterFuture ...
[16:59:39.640] - result already collected: FutureResult
[16:59:39.640] result() for ClusterFuture ... done
[16:59:39.640] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:39.640] Future #1
[16:59:39.640] result() for ClusterFuture ...
[16:59:39.640] - result already collected: FutureResult
[16:59:39.640] result() for ClusterFuture ... done
[16:59:39.640] result() for ClusterFuture ...
[16:59:39.640] - result already collected: FutureResult
[16:59:39.640] result() for ClusterFuture ... done
[16:59:39.640] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:39.641] - nx: 2
[16:59:39.641] - relay: TRUE
[16:59:39.641] - stdout: TRUE
[16:59:39.641] - signal: TRUE
[16:59:39.641] - resignal: FALSE
[16:59:39.641] - force: TRUE
[16:59:39.641] - relayed: [n=2] FALSE, FALSE
[16:59:39.641] - queued futures: [n=2] FALSE, FALSE
[16:59:39.641]  - until=1
[16:59:39.641]  - relaying element #1
[16:59:39.641] result() for ClusterFuture ...
[16:59:39.641] - result already collected: FutureResult
[16:59:39.642] result() for ClusterFuture ... done
[16:59:39.642] result() for ClusterFuture ...
[16:59:39.642] - result already collected: FutureResult
[16:59:39.642] result() for ClusterFuture ... done
[16:59:39.642] result() for ClusterFuture ...
[16:59:39.642] - result already collected: FutureResult
[16:59:39.642] result() for ClusterFuture ... done
[16:59:39.642] result() for ClusterFuture ...
[16:59:39.642] - result already collected: FutureResult
[16:59:39.642] result() for ClusterFuture ... done
[16:59:39.642] - relayed: [n=2] TRUE, FALSE
[16:59:39.642] - queued futures: [n=2] TRUE, FALSE
[16:59:39.643] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:39.643]  length: 1 (resolved future 1)
[16:59:39.670] receiveMessageFromWorker() for ClusterFuture ...
[16:59:39.670] - Validating connection of MultisessionFuture
[16:59:39.670] - received message: FutureResult
[16:59:39.670] - Received FutureResult
[16:59:39.670] - Erased future from FutureRegistry
[16:59:39.670] result() for ClusterFuture ...
[16:59:39.671] - result already collected: FutureResult
[16:59:39.671] result() for ClusterFuture ... done
[16:59:39.671] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:39.671] Future #2
[16:59:39.671] result() for ClusterFuture ...
[16:59:39.671] - result already collected: FutureResult
[16:59:39.671] result() for ClusterFuture ... done
[16:59:39.671] result() for ClusterFuture ...
[16:59:39.671] - result already collected: FutureResult
[16:59:39.671] result() for ClusterFuture ... done
[16:59:39.671] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:39.672] - nx: 2
[16:59:39.672] - relay: TRUE
[16:59:39.672] - stdout: TRUE
[16:59:39.672] - signal: TRUE
[16:59:39.672] - resignal: FALSE
[16:59:39.672] - force: TRUE
[16:59:39.672] - relayed: [n=2] TRUE, FALSE
[16:59:39.672] - queued futures: [n=2] TRUE, FALSE
[16:59:39.672]  - until=2
[16:59:39.672]  - relaying element #2
[16:59:39.672] result() for ClusterFuture ...
[16:59:39.672] - result already collected: FutureResult
[16:59:39.673] result() for ClusterFuture ... done
[16:59:39.673] result() for ClusterFuture ...
[16:59:39.673] - result already collected: FutureResult
[16:59:39.673] result() for ClusterFuture ... done
[16:59:39.673] result() for ClusterFuture ...
[16:59:39.673] - result already collected: FutureResult
[16:59:39.673] result() for ClusterFuture ... done
[16:59:39.673] result() for ClusterFuture ...
[16:59:39.673] - result already collected: FutureResult
[16:59:39.673] result() for ClusterFuture ... done
[16:59:39.673] - relayed: [n=2] TRUE, TRUE
[16:59:39.673] - queued futures: [n=2] TRUE, TRUE
[16:59:39.674] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:39.674]  length: 0 (resolved future 2)
[16:59:39.674] Relaying remaining futures
[16:59:39.674] signalConditionsASAP(NULL, pos=0) ...
[16:59:39.674] - nx: 2
[16:59:39.674] - relay: TRUE
[16:59:39.674] - stdout: TRUE
[16:59:39.674] - signal: TRUE
[16:59:39.674] - resignal: FALSE
[16:59:39.674] - force: TRUE
[16:59:39.674] - relayed: [n=2] TRUE, TRUE
[16:59:39.674] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:39.675] - relayed: [n=2] TRUE, TRUE
[16:59:39.675] - queued futures: [n=2] TRUE, TRUE
[16:59:39.675] signalConditionsASAP(NULL, pos=0) ... done
[16:59:39.675] resolve() on list ... DONE
[16:59:39.675] result() for ClusterFuture ...
[16:59:39.675] - result already collected: FutureResult
[16:59:39.675] result() for ClusterFuture ... done
[16:59:39.675] result() for ClusterFuture ...
[16:59:39.675] - result already collected: FutureResult
[16:59:39.675] result() for ClusterFuture ... done
[16:59:39.676] result() for ClusterFuture ...
[16:59:39.676] - result already collected: FutureResult
[16:59:39.676] result() for ClusterFuture ... done
[16:59:39.676] result() for ClusterFuture ...
[16:59:39.676] - result already collected: FutureResult
[16:59:39.676] result() for ClusterFuture ... done
[16:59:39.676]  - Number of value chunks collected: 2
[16:59:39.676] Resolving 2 futures (chunks) ... DONE
[16:59:39.676] Reducing values from 2 chunks ...
[16:59:39.676]  - Number of values collected after concatenation: 3
[16:59:39.676]  - Number of values expected: 3
[16:59:39.677] Reducing values from 2 chunks ... DONE
[16:59:39.677] future_lapply() ... DONE
[16:59:39.677] plan(): Setting new future strategy stack:
[16:59:39.677] List of future strategies:
[16:59:39.677] 1. sequential:
[16:59:39.677]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:39.677]    - tweaked: FALSE
[16:59:39.677]    - call: plan(sequential)
[16:59:39.678] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[16:59:39.679] plan(): Setting new future strategy stack:
[16:59:39.679] List of future strategies:
[16:59:39.679] 1. FutureStrategy:
[16:59:39.679]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:39.679]    - tweaked: FALSE
[16:59:39.679]    - call: future::plan(oplan)
[16:59:39.679] plan(): nbrOfWorkers() = 1
> 
