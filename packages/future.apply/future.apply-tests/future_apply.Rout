
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:43:46.993] plan(): Setting new future strategy stack:
[17:43:46.993] List of future strategies:
[17:43:46.993] 1. sequential:
[17:43:46.993]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:46.993]    - tweaked: FALSE
[17:43:46.993]    - call: future::plan("sequential")
[17:43:47.007] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:43:47.064] plan(): Setting new future strategy stack:
[17:43:47.065] List of future strategies:
[17:43:47.065] 1. sequential:
[17:43:47.065]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.065]    - tweaked: FALSE
[17:43:47.065]    - call: plan(strategy)
[17:43:47.077] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[17:43:47.078] getGlobalsAndPackagesXApply() ...
[17:43:47.078]  - future.globals: TRUE
[17:43:47.079] getGlobalsAndPackages() ...
[17:43:47.079] Searching for globals...
[17:43:47.118] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:43:47.118] Searching for globals ... DONE
[17:43:47.118] Resolving globals: FALSE
[17:43:47.120] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:43:47.121] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:43:47.121] - globals: [1] ‘FUN’
[17:43:47.121] 
[17:43:47.121] getGlobalsAndPackages() ... DONE
[17:43:47.121]  - globals found/used: [n=1] ‘FUN’
[17:43:47.121]  - needed namespaces: [n=0] 
[17:43:47.123] Finding globals ... DONE
[17:43:47.123]  - use_args: TRUE
[17:43:47.123]  - Getting '...' globals ...
[17:43:47.124] resolve() on list ...
[17:43:47.124]  recursive: 0
[17:43:47.124]  length: 1
[17:43:47.124]  elements: ‘...’
[17:43:47.124]  length: 0 (resolved future 1)
[17:43:47.124] resolve() on list ... DONE
[17:43:47.124]    - '...' content: [n=0] 
[17:43:47.125] List of 1
[17:43:47.125]  $ ...: list()
[17:43:47.125]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.125]  - attr(*, "where")=List of 1
[17:43:47.125]   ..$ ...:<environment: 0x55dfd43cd898> 
[17:43:47.125]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.125]  - attr(*, "resolved")= logi TRUE
[17:43:47.125]  - attr(*, "total_size")= num NA
[17:43:47.129]  - Getting '...' globals ... DONE
[17:43:47.130] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:47.130] List of 2
[17:43:47.130]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:47.130]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:47.130]  $ ...          : list()
[17:43:47.130]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.130]  - attr(*, "where")=List of 2
[17:43:47.130]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:47.130]   ..$ ...          :<environment: 0x55dfd43cd898> 
[17:43:47.130]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.130]  - attr(*, "resolved")= logi FALSE
[17:43:47.130]  - attr(*, "total_size")= num 354224
[17:43:47.132] Packages to be attached in all futures: [n=0] 
[17:43:47.133] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.133] future_lapply() ...
[17:43:47.165] Number of chunks: 1
[17:43:47.165] getGlobalsAndPackagesXApply() ...
[17:43:47.165]  - future.globals: <name-value list> with names ‘list()’
[17:43:47.165]  - use_args: TRUE
[17:43:47.166] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:47.166] List of 2
[17:43:47.166]  $ ...          : list()
[17:43:47.166]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.166]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:47.166]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:47.166]  - attr(*, "where")=List of 2
[17:43:47.166]   ..$ ...          :<environment: 0x55dfd43cd898> 
[17:43:47.166]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:47.166]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.166]  - attr(*, "resolved")= logi FALSE
[17:43:47.166]  - attr(*, "total_size")= num NA
[17:43:47.169] Packages to be attached in all futures: [n=0] 
[17:43:47.169] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.170] Number of futures (= number of chunks): 1
[17:43:47.170] Launching 1 futures (chunks) ...
[17:43:47.170] Chunk #1 of 1 ...
[17:43:47.170]  - seeds: <none>
[17:43:47.170]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.170] getGlobalsAndPackages() ...
[17:43:47.170] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.171] Resolving globals: FALSE
[17:43:47.171] Tweak future expression to call with '...' arguments ...
[17:43:47.171] {
[17:43:47.171]     do.call(function(...) {
[17:43:47.171]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.171]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.171]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.171]             on.exit(options(oopts), add = TRUE)
[17:43:47.171]         }
[17:43:47.171]         {
[17:43:47.171]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.171]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.171]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.171]             })
[17:43:47.171]         }
[17:43:47.171]     }, args = future.call.arguments)
[17:43:47.171] }
[17:43:47.171] Tweak future expression to call with '...' arguments ... DONE
[17:43:47.171] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.172] 
[17:43:47.172] getGlobalsAndPackages() ... DONE
[17:43:47.172] run() for ‘Future’ ...
[17:43:47.172] - state: ‘created’
[17:43:47.173] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:47.173] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.173] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:47.173]   - Field: ‘label’
[17:43:47.173]   - Field: ‘local’
[17:43:47.173]   - Field: ‘owner’
[17:43:47.175]   - Field: ‘envir’
[17:43:47.175]   - Field: ‘packages’
[17:43:47.175]   - Field: ‘gc’
[17:43:47.175]   - Field: ‘conditions’
[17:43:47.175]   - Field: ‘expr’
[17:43:47.176]   - Field: ‘uuid’
[17:43:47.176]   - Field: ‘seed’
[17:43:47.176]   - Field: ‘version’
[17:43:47.176]   - Field: ‘result’
[17:43:47.176]   - Field: ‘asynchronous’
[17:43:47.176]   - Field: ‘calls’
[17:43:47.176]   - Field: ‘globals’
[17:43:47.177]   - Field: ‘stdout’
[17:43:47.177]   - Field: ‘earlySignal’
[17:43:47.177]   - Field: ‘lazy’
[17:43:47.177]   - Field: ‘state’
[17:43:47.177] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:47.177] - Launch lazy future ...
[17:43:47.178] Packages needed by the future expression (n = 0): <none>
[17:43:47.178] Packages needed by future strategies (n = 0): <none>
[17:43:47.179] {
[17:43:47.179]     {
[17:43:47.179]         {
[17:43:47.179]             ...future.startTime <- base::Sys.time()
[17:43:47.179]             {
[17:43:47.179]                 {
[17:43:47.179]                   {
[17:43:47.179]                     base::local({
[17:43:47.179]                       has_future <- base::requireNamespace("future", 
[17:43:47.179]                         quietly = TRUE)
[17:43:47.179]                       if (has_future) {
[17:43:47.179]                         ns <- base::getNamespace("future")
[17:43:47.179]                         version <- ns[[".package"]][["version"]]
[17:43:47.179]                         if (is.null(version)) 
[17:43:47.179]                           version <- utils::packageVersion("future")
[17:43:47.179]                       }
[17:43:47.179]                       else {
[17:43:47.179]                         version <- NULL
[17:43:47.179]                       }
[17:43:47.179]                       if (!has_future || version < "1.8.0") {
[17:43:47.179]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.179]                           "", base::R.version$version.string), 
[17:43:47.179]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:47.179]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.179]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.179]                             "release", "version")], collapse = " "), 
[17:43:47.179]                           hostname = base::Sys.info()[["nodename"]])
[17:43:47.179]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.179]                           info)
[17:43:47.179]                         info <- base::paste(info, collapse = "; ")
[17:43:47.179]                         if (!has_future) {
[17:43:47.179]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.179]                             info)
[17:43:47.179]                         }
[17:43:47.179]                         else {
[17:43:47.179]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.179]                             info, version)
[17:43:47.179]                         }
[17:43:47.179]                         base::stop(msg)
[17:43:47.179]                       }
[17:43:47.179]                     })
[17:43:47.179]                   }
[17:43:47.179]                   ...future.strategy.old <- future::plan("list")
[17:43:47.179]                   options(future.plan = NULL)
[17:43:47.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.179]                 }
[17:43:47.179]                 ...future.workdir <- getwd()
[17:43:47.179]             }
[17:43:47.179]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.179]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.179]         }
[17:43:47.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.179]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:47.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.179]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.179]             base::names(...future.oldOptions))
[17:43:47.179]     }
[17:43:47.179]     if (FALSE) {
[17:43:47.179]     }
[17:43:47.179]     else {
[17:43:47.179]         if (TRUE) {
[17:43:47.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.179]                 open = "w")
[17:43:47.179]         }
[17:43:47.179]         else {
[17:43:47.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.179]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.179]         }
[17:43:47.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.179]             base::sink(type = "output", split = FALSE)
[17:43:47.179]             base::close(...future.stdout)
[17:43:47.179]         }, add = TRUE)
[17:43:47.179]     }
[17:43:47.179]     ...future.frame <- base::sys.nframe()
[17:43:47.179]     ...future.conditions <- base::list()
[17:43:47.179]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.179]     if (FALSE) {
[17:43:47.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.179]     }
[17:43:47.179]     ...future.result <- base::tryCatch({
[17:43:47.179]         base::withCallingHandlers({
[17:43:47.179]             ...future.value <- base::withVisible(base::local({
[17:43:47.179]                 do.call(function(...) {
[17:43:47.179]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.179]                   if (!identical(...future.globals.maxSize.org, 
[17:43:47.179]                     ...future.globals.maxSize)) {
[17:43:47.179]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.179]                     on.exit(options(oopts), add = TRUE)
[17:43:47.179]                   }
[17:43:47.179]                   {
[17:43:47.179]                     lapply(seq_along(...future.elements_ii), 
[17:43:47.179]                       FUN = function(jj) {
[17:43:47.179]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.179]                         ...future.FUN(...future.X_jj, ...)
[17:43:47.179]                       })
[17:43:47.179]                   }
[17:43:47.179]                 }, args = future.call.arguments)
[17:43:47.179]             }))
[17:43:47.179]             future::FutureResult(value = ...future.value$value, 
[17:43:47.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.179]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.179]                     ...future.globalenv.names))
[17:43:47.179]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.179]         }, condition = base::local({
[17:43:47.179]             c <- base::c
[17:43:47.179]             inherits <- base::inherits
[17:43:47.179]             invokeRestart <- base::invokeRestart
[17:43:47.179]             length <- base::length
[17:43:47.179]             list <- base::list
[17:43:47.179]             seq.int <- base::seq.int
[17:43:47.179]             signalCondition <- base::signalCondition
[17:43:47.179]             sys.calls <- base::sys.calls
[17:43:47.179]             `[[` <- base::`[[`
[17:43:47.179]             `+` <- base::`+`
[17:43:47.179]             `<<-` <- base::`<<-`
[17:43:47.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.179]                   3L)]
[17:43:47.179]             }
[17:43:47.179]             function(cond) {
[17:43:47.179]                 is_error <- inherits(cond, "error")
[17:43:47.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.179]                   NULL)
[17:43:47.179]                 if (is_error) {
[17:43:47.179]                   sessionInformation <- function() {
[17:43:47.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.179]                       search = base::search(), system = base::Sys.info())
[17:43:47.179]                   }
[17:43:47.179]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.179]                     cond$call), session = sessionInformation(), 
[17:43:47.179]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.179]                   signalCondition(cond)
[17:43:47.179]                 }
[17:43:47.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:47.179]                 "immediateCondition"))) {
[17:43:47.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:47.179]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.179]                   if (TRUE && !signal) {
[17:43:47.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.179]                     {
[17:43:47.179]                       inherits <- base::inherits
[17:43:47.179]                       invokeRestart <- base::invokeRestart
[17:43:47.179]                       is.null <- base::is.null
[17:43:47.179]                       muffled <- FALSE
[17:43:47.179]                       if (inherits(cond, "message")) {
[17:43:47.179]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.179]                         if (muffled) 
[17:43:47.179]                           invokeRestart("muffleMessage")
[17:43:47.179]                       }
[17:43:47.179]                       else if (inherits(cond, "warning")) {
[17:43:47.179]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.179]                         if (muffled) 
[17:43:47.179]                           invokeRestart("muffleWarning")
[17:43:47.179]                       }
[17:43:47.179]                       else if (inherits(cond, "condition")) {
[17:43:47.179]                         if (!is.null(pattern)) {
[17:43:47.179]                           computeRestarts <- base::computeRestarts
[17:43:47.179]                           grepl <- base::grepl
[17:43:47.179]                           restarts <- computeRestarts(cond)
[17:43:47.179]                           for (restart in restarts) {
[17:43:47.179]                             name <- restart$name
[17:43:47.179]                             if (is.null(name)) 
[17:43:47.179]                               next
[17:43:47.179]                             if (!grepl(pattern, name)) 
[17:43:47.179]                               next
[17:43:47.179]                             invokeRestart(restart)
[17:43:47.179]                             muffled <- TRUE
[17:43:47.179]                             break
[17:43:47.179]                           }
[17:43:47.179]                         }
[17:43:47.179]                       }
[17:43:47.179]                       invisible(muffled)
[17:43:47.179]                     }
[17:43:47.179]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.179]                   }
[17:43:47.179]                 }
[17:43:47.179]                 else {
[17:43:47.179]                   if (TRUE) {
[17:43:47.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.179]                     {
[17:43:47.179]                       inherits <- base::inherits
[17:43:47.179]                       invokeRestart <- base::invokeRestart
[17:43:47.179]                       is.null <- base::is.null
[17:43:47.179]                       muffled <- FALSE
[17:43:47.179]                       if (inherits(cond, "message")) {
[17:43:47.179]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.179]                         if (muffled) 
[17:43:47.179]                           invokeRestart("muffleMessage")
[17:43:47.179]                       }
[17:43:47.179]                       else if (inherits(cond, "warning")) {
[17:43:47.179]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.179]                         if (muffled) 
[17:43:47.179]                           invokeRestart("muffleWarning")
[17:43:47.179]                       }
[17:43:47.179]                       else if (inherits(cond, "condition")) {
[17:43:47.179]                         if (!is.null(pattern)) {
[17:43:47.179]                           computeRestarts <- base::computeRestarts
[17:43:47.179]                           grepl <- base::grepl
[17:43:47.179]                           restarts <- computeRestarts(cond)
[17:43:47.179]                           for (restart in restarts) {
[17:43:47.179]                             name <- restart$name
[17:43:47.179]                             if (is.null(name)) 
[17:43:47.179]                               next
[17:43:47.179]                             if (!grepl(pattern, name)) 
[17:43:47.179]                               next
[17:43:47.179]                             invokeRestart(restart)
[17:43:47.179]                             muffled <- TRUE
[17:43:47.179]                             break
[17:43:47.179]                           }
[17:43:47.179]                         }
[17:43:47.179]                       }
[17:43:47.179]                       invisible(muffled)
[17:43:47.179]                     }
[17:43:47.179]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.179]                   }
[17:43:47.179]                 }
[17:43:47.179]             }
[17:43:47.179]         }))
[17:43:47.179]     }, error = function(ex) {
[17:43:47.179]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.179]                 ...future.rng), started = ...future.startTime, 
[17:43:47.179]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.179]             version = "1.8"), class = "FutureResult")
[17:43:47.179]     }, finally = {
[17:43:47.179]         if (!identical(...future.workdir, getwd())) 
[17:43:47.179]             setwd(...future.workdir)
[17:43:47.179]         {
[17:43:47.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.179]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.179]             }
[17:43:47.179]             base::options(...future.oldOptions)
[17:43:47.179]             if (.Platform$OS.type == "windows") {
[17:43:47.179]                 old_names <- names(...future.oldEnvVars)
[17:43:47.179]                 envs <- base::Sys.getenv()
[17:43:47.179]                 names <- names(envs)
[17:43:47.179]                 common <- intersect(names, old_names)
[17:43:47.179]                 added <- setdiff(names, old_names)
[17:43:47.179]                 removed <- setdiff(old_names, names)
[17:43:47.179]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.179]                   envs[common]]
[17:43:47.179]                 NAMES <- toupper(changed)
[17:43:47.179]                 args <- list()
[17:43:47.179]                 for (kk in seq_along(NAMES)) {
[17:43:47.179]                   name <- changed[[kk]]
[17:43:47.179]                   NAME <- NAMES[[kk]]
[17:43:47.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.179]                     next
[17:43:47.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.179]                 }
[17:43:47.179]                 NAMES <- toupper(added)
[17:43:47.179]                 for (kk in seq_along(NAMES)) {
[17:43:47.179]                   name <- added[[kk]]
[17:43:47.179]                   NAME <- NAMES[[kk]]
[17:43:47.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.179]                     next
[17:43:47.179]                   args[[name]] <- ""
[17:43:47.179]                 }
[17:43:47.179]                 NAMES <- toupper(removed)
[17:43:47.179]                 for (kk in seq_along(NAMES)) {
[17:43:47.179]                   name <- removed[[kk]]
[17:43:47.179]                   NAME <- NAMES[[kk]]
[17:43:47.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.179]                     next
[17:43:47.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.179]                 }
[17:43:47.179]                 if (length(args) > 0) 
[17:43:47.179]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.179]             }
[17:43:47.179]             else {
[17:43:47.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.179]             }
[17:43:47.179]             {
[17:43:47.179]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.179]                   0L) {
[17:43:47.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.179]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.179]                   base::options(opts)
[17:43:47.179]                 }
[17:43:47.179]                 {
[17:43:47.179]                   {
[17:43:47.179]                     NULL
[17:43:47.179]                     RNGkind("Mersenne-Twister")
[17:43:47.179]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:47.179]                       inherits = FALSE)
[17:43:47.179]                   }
[17:43:47.179]                   options(future.plan = NULL)
[17:43:47.179]                   if (is.na(NA_character_)) 
[17:43:47.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:47.179]                     .init = FALSE)
[17:43:47.179]                 }
[17:43:47.179]             }
[17:43:47.179]         }
[17:43:47.179]     })
[17:43:47.179]     if (TRUE) {
[17:43:47.179]         base::sink(type = "output", split = FALSE)
[17:43:47.179]         if (TRUE) {
[17:43:47.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.179]         }
[17:43:47.179]         else {
[17:43:47.179]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.179]         }
[17:43:47.179]         base::close(...future.stdout)
[17:43:47.179]         ...future.stdout <- NULL
[17:43:47.179]     }
[17:43:47.179]     ...future.result$conditions <- ...future.conditions
[17:43:47.179]     ...future.result$finished <- base::Sys.time()
[17:43:47.179]     ...future.result
[17:43:47.179] }
[17:43:47.181] assign_globals() ...
[17:43:47.181] List of 5
[17:43:47.181]  $ future.call.arguments    : list()
[17:43:47.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.181]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:47.181]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:47.181]  $ ...future.elements_ii    :List of 2
[17:43:47.181]   ..$ : num [1:4] 1 3 1 7
[17:43:47.181]   ..$ : num [1:4] 2 4 6 8
[17:43:47.181]  $ ...future.seeds_ii       : NULL
[17:43:47.181]  $ ...future.globals.maxSize: num Inf
[17:43:47.181]  - attr(*, "resolved")= logi FALSE
[17:43:47.181]  - attr(*, "total_size")= num NA
[17:43:47.181]  - attr(*, "where")=List of 5
[17:43:47.181]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:47.181]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:47.181]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:47.181]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:47.181]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:47.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.181]  - attr(*, "already-done")= logi TRUE
[17:43:47.186] - copied ‘future.call.arguments’ to environment
[17:43:47.186] - copied ‘...future.FUN’ to environment
[17:43:47.186] - copied ‘...future.elements_ii’ to environment
[17:43:47.186] - copied ‘...future.seeds_ii’ to environment
[17:43:47.187] - copied ‘...future.globals.maxSize’ to environment
[17:43:47.187] assign_globals() ... done
[17:43:47.187] plan(): Setting new future strategy stack:
[17:43:47.187] List of future strategies:
[17:43:47.187] 1. sequential:
[17:43:47.187]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.187]    - tweaked: FALSE
[17:43:47.187]    - call: NULL
[17:43:47.187] plan(): nbrOfWorkers() = 1
[17:43:47.189] plan(): Setting new future strategy stack:
[17:43:47.189] List of future strategies:
[17:43:47.189] 1. sequential:
[17:43:47.189]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.189]    - tweaked: FALSE
[17:43:47.189]    - call: plan(strategy)
[17:43:47.189] plan(): nbrOfWorkers() = 1
[17:43:47.190] SequentialFuture started (and completed)
[17:43:47.190] - Launch lazy future ... done
[17:43:47.190] run() for ‘SequentialFuture’ ... done
[17:43:47.190] Created future:
[17:43:47.190] SequentialFuture:
[17:43:47.190] Label: ‘future_apply-1’
[17:43:47.190] Expression:
[17:43:47.190] {
[17:43:47.190]     do.call(function(...) {
[17:43:47.190]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.190]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.190]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.190]             on.exit(options(oopts), add = TRUE)
[17:43:47.190]         }
[17:43:47.190]         {
[17:43:47.190]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.190]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.190]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.190]             })
[17:43:47.190]         }
[17:43:47.190]     }, args = future.call.arguments)
[17:43:47.190] }
[17:43:47.190] Lazy evaluation: FALSE
[17:43:47.190] Asynchronous evaluation: FALSE
[17:43:47.190] Local evaluation: TRUE
[17:43:47.190] Environment: R_GlobalEnv
[17:43:47.190] Capture standard output: TRUE
[17:43:47.190] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:47.190] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:47.190] Packages: <none>
[17:43:47.190] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:47.190] Resolved: TRUE
[17:43:47.190] Value: 2.21 KiB of class ‘list’
[17:43:47.190] Early signaling: FALSE
[17:43:47.190] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:47.190] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.192] Chunk #1 of 1 ... DONE
[17:43:47.192] Launching 1 futures (chunks) ... DONE
[17:43:47.192] Resolving 1 futures (chunks) ...
[17:43:47.192] resolve() on list ...
[17:43:47.192]  recursive: 0
[17:43:47.192]  length: 1
[17:43:47.192] 
[17:43:47.193] resolved() for ‘SequentialFuture’ ...
[17:43:47.193] - state: ‘finished’
[17:43:47.193] - run: TRUE
[17:43:47.193] - result: ‘FutureResult’
[17:43:47.193] resolved() for ‘SequentialFuture’ ... done
[17:43:47.193] Future #1
[17:43:47.193] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:47.194] - nx: 1
[17:43:47.194] - relay: TRUE
[17:43:47.194] - stdout: TRUE
[17:43:47.194] - signal: TRUE
[17:43:47.194] - resignal: FALSE
[17:43:47.194] - force: TRUE
[17:43:47.194] - relayed: [n=1] FALSE
[17:43:47.194] - queued futures: [n=1] FALSE
[17:43:47.194]  - until=1
[17:43:47.194]  - relaying element #1
[17:43:47.194] - relayed: [n=1] TRUE
[17:43:47.195] - queued futures: [n=1] TRUE
[17:43:47.195] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:47.195]  length: 0 (resolved future 1)
[17:43:47.195] Relaying remaining futures
[17:43:47.195] signalConditionsASAP(NULL, pos=0) ...
[17:43:47.195] - nx: 1
[17:43:47.195] - relay: TRUE
[17:43:47.195] - stdout: TRUE
[17:43:47.195] - signal: TRUE
[17:43:47.195] - resignal: FALSE
[17:43:47.196] - force: TRUE
[17:43:47.196] - relayed: [n=1] TRUE
[17:43:47.196] - queued futures: [n=1] TRUE
 - flush all
[17:43:47.196] - relayed: [n=1] TRUE
[17:43:47.196] - queued futures: [n=1] TRUE
[17:43:47.196] signalConditionsASAP(NULL, pos=0) ... done
[17:43:47.196] resolve() on list ... DONE
[17:43:47.196]  - Number of value chunks collected: 1
[17:43:47.196] Resolving 1 futures (chunks) ... DONE
[17:43:47.196] Reducing values from 1 chunks ...
[17:43:47.197]  - Number of values collected after concatenation: 2
[17:43:47.197]  - Number of values expected: 2
[17:43:47.197] Reducing values from 1 chunks ... DONE
[17:43:47.197] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:43:47.198] getGlobalsAndPackagesXApply() ...
[17:43:47.198]  - future.globals: TRUE
[17:43:47.198] getGlobalsAndPackages() ...
[17:43:47.198] Searching for globals...
[17:43:47.231] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:43:47.231] Searching for globals ... DONE
[17:43:47.232] Resolving globals: FALSE
[17:43:47.233] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:43:47.234] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:43:47.234] - globals: [1] ‘FUN’
[17:43:47.234] 
[17:43:47.234] getGlobalsAndPackages() ... DONE
[17:43:47.234]  - globals found/used: [n=1] ‘FUN’
[17:43:47.234]  - needed namespaces: [n=0] 
[17:43:47.234] Finding globals ... DONE
[17:43:47.234]  - use_args: TRUE
[17:43:47.234]  - Getting '...' globals ...
[17:43:47.235] resolve() on list ...
[17:43:47.235]  recursive: 0
[17:43:47.235]  length: 1
[17:43:47.235]  elements: ‘...’
[17:43:47.235]  length: 0 (resolved future 1)
[17:43:47.235] resolve() on list ... DONE
[17:43:47.235]    - '...' content: [n=0] 
[17:43:47.235] List of 1
[17:43:47.235]  $ ...: list()
[17:43:47.235]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.235]  - attr(*, "where")=List of 1
[17:43:47.235]   ..$ ...:<environment: 0x55dfd4e46908> 
[17:43:47.235]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.235]  - attr(*, "resolved")= logi TRUE
[17:43:47.235]  - attr(*, "total_size")= num NA
[17:43:47.238]  - Getting '...' globals ... DONE
[17:43:47.238] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:47.238] List of 2
[17:43:47.238]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:47.238]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:47.238]  $ ...          : list()
[17:43:47.238]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.238]  - attr(*, "where")=List of 2
[17:43:47.238]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:47.238]   ..$ ...          :<environment: 0x55dfd4e46908> 
[17:43:47.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.238]  - attr(*, "resolved")= logi FALSE
[17:43:47.238]  - attr(*, "total_size")= num 354224
[17:43:47.241] Packages to be attached in all futures: [n=0] 
[17:43:47.241] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.241] future_lapply() ...
[17:43:47.272] Number of chunks: 1
[17:43:47.272] getGlobalsAndPackagesXApply() ...
[17:43:47.272]  - future.globals: <name-value list> with names ‘list()’
[17:43:47.273]  - use_args: TRUE
[17:43:47.273] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:47.273] List of 2
[17:43:47.273]  $ ...          : list()
[17:43:47.273]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.273]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:47.273]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:47.273]  - attr(*, "where")=List of 2
[17:43:47.273]   ..$ ...          :<environment: 0x55dfd4e46908> 
[17:43:47.273]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:47.273]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.273]  - attr(*, "resolved")= logi FALSE
[17:43:47.273]  - attr(*, "total_size")= num NA
[17:43:47.276] Packages to be attached in all futures: [n=0] 
[17:43:47.276] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.276] Number of futures (= number of chunks): 1
[17:43:47.276] Launching 1 futures (chunks) ...
[17:43:47.277] Chunk #1 of 1 ...
[17:43:47.277]  - seeds: <none>
[17:43:47.277]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.277] getGlobalsAndPackages() ...
[17:43:47.277] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.277] Resolving globals: FALSE
[17:43:47.277] Tweak future expression to call with '...' arguments ...
[17:43:47.277] {
[17:43:47.277]     do.call(function(...) {
[17:43:47.277]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.277]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.277]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.277]             on.exit(options(oopts), add = TRUE)
[17:43:47.277]         }
[17:43:47.277]         {
[17:43:47.277]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.277]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.277]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.277]             })
[17:43:47.277]         }
[17:43:47.277]     }, args = future.call.arguments)
[17:43:47.277] }
[17:43:47.278] Tweak future expression to call with '...' arguments ... DONE
[17:43:47.278] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.278] 
[17:43:47.278] getGlobalsAndPackages() ... DONE
[17:43:47.278] run() for ‘Future’ ...
[17:43:47.278] - state: ‘created’
[17:43:47.279] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:47.279] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.279] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:47.279]   - Field: ‘label’
[17:43:47.279]   - Field: ‘local’
[17:43:47.279]   - Field: ‘owner’
[17:43:47.279]   - Field: ‘envir’
[17:43:47.280]   - Field: ‘packages’
[17:43:47.280]   - Field: ‘gc’
[17:43:47.280]   - Field: ‘conditions’
[17:43:47.280]   - Field: ‘expr’
[17:43:47.280]   - Field: ‘uuid’
[17:43:47.280]   - Field: ‘seed’
[17:43:47.280]   - Field: ‘version’
[17:43:47.280]   - Field: ‘result’
[17:43:47.280]   - Field: ‘asynchronous’
[17:43:47.280]   - Field: ‘calls’
[17:43:47.280]   - Field: ‘globals’
[17:43:47.280]   - Field: ‘stdout’
[17:43:47.281]   - Field: ‘earlySignal’
[17:43:47.281]   - Field: ‘lazy’
[17:43:47.281]   - Field: ‘state’
[17:43:47.281] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:47.281] - Launch lazy future ...
[17:43:47.281] Packages needed by the future expression (n = 0): <none>
[17:43:47.281] Packages needed by future strategies (n = 0): <none>
[17:43:47.282] {
[17:43:47.282]     {
[17:43:47.282]         {
[17:43:47.282]             ...future.startTime <- base::Sys.time()
[17:43:47.282]             {
[17:43:47.282]                 {
[17:43:47.282]                   {
[17:43:47.282]                     base::local({
[17:43:47.282]                       has_future <- base::requireNamespace("future", 
[17:43:47.282]                         quietly = TRUE)
[17:43:47.282]                       if (has_future) {
[17:43:47.282]                         ns <- base::getNamespace("future")
[17:43:47.282]                         version <- ns[[".package"]][["version"]]
[17:43:47.282]                         if (is.null(version)) 
[17:43:47.282]                           version <- utils::packageVersion("future")
[17:43:47.282]                       }
[17:43:47.282]                       else {
[17:43:47.282]                         version <- NULL
[17:43:47.282]                       }
[17:43:47.282]                       if (!has_future || version < "1.8.0") {
[17:43:47.282]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.282]                           "", base::R.version$version.string), 
[17:43:47.282]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:47.282]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.282]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.282]                             "release", "version")], collapse = " "), 
[17:43:47.282]                           hostname = base::Sys.info()[["nodename"]])
[17:43:47.282]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.282]                           info)
[17:43:47.282]                         info <- base::paste(info, collapse = "; ")
[17:43:47.282]                         if (!has_future) {
[17:43:47.282]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.282]                             info)
[17:43:47.282]                         }
[17:43:47.282]                         else {
[17:43:47.282]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.282]                             info, version)
[17:43:47.282]                         }
[17:43:47.282]                         base::stop(msg)
[17:43:47.282]                       }
[17:43:47.282]                     })
[17:43:47.282]                   }
[17:43:47.282]                   ...future.strategy.old <- future::plan("list")
[17:43:47.282]                   options(future.plan = NULL)
[17:43:47.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.282]                 }
[17:43:47.282]                 ...future.workdir <- getwd()
[17:43:47.282]             }
[17:43:47.282]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.282]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.282]         }
[17:43:47.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.282]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:47.282]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.282]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.282]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.282]             base::names(...future.oldOptions))
[17:43:47.282]     }
[17:43:47.282]     if (FALSE) {
[17:43:47.282]     }
[17:43:47.282]     else {
[17:43:47.282]         if (TRUE) {
[17:43:47.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.282]                 open = "w")
[17:43:47.282]         }
[17:43:47.282]         else {
[17:43:47.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.282]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.282]         }
[17:43:47.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.282]             base::sink(type = "output", split = FALSE)
[17:43:47.282]             base::close(...future.stdout)
[17:43:47.282]         }, add = TRUE)
[17:43:47.282]     }
[17:43:47.282]     ...future.frame <- base::sys.nframe()
[17:43:47.282]     ...future.conditions <- base::list()
[17:43:47.282]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.282]     if (FALSE) {
[17:43:47.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.282]     }
[17:43:47.282]     ...future.result <- base::tryCatch({
[17:43:47.282]         base::withCallingHandlers({
[17:43:47.282]             ...future.value <- base::withVisible(base::local({
[17:43:47.282]                 do.call(function(...) {
[17:43:47.282]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.282]                   if (!identical(...future.globals.maxSize.org, 
[17:43:47.282]                     ...future.globals.maxSize)) {
[17:43:47.282]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.282]                     on.exit(options(oopts), add = TRUE)
[17:43:47.282]                   }
[17:43:47.282]                   {
[17:43:47.282]                     lapply(seq_along(...future.elements_ii), 
[17:43:47.282]                       FUN = function(jj) {
[17:43:47.282]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.282]                         ...future.FUN(...future.X_jj, ...)
[17:43:47.282]                       })
[17:43:47.282]                   }
[17:43:47.282]                 }, args = future.call.arguments)
[17:43:47.282]             }))
[17:43:47.282]             future::FutureResult(value = ...future.value$value, 
[17:43:47.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.282]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.282]                     ...future.globalenv.names))
[17:43:47.282]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.282]         }, condition = base::local({
[17:43:47.282]             c <- base::c
[17:43:47.282]             inherits <- base::inherits
[17:43:47.282]             invokeRestart <- base::invokeRestart
[17:43:47.282]             length <- base::length
[17:43:47.282]             list <- base::list
[17:43:47.282]             seq.int <- base::seq.int
[17:43:47.282]             signalCondition <- base::signalCondition
[17:43:47.282]             sys.calls <- base::sys.calls
[17:43:47.282]             `[[` <- base::`[[`
[17:43:47.282]             `+` <- base::`+`
[17:43:47.282]             `<<-` <- base::`<<-`
[17:43:47.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.282]                   3L)]
[17:43:47.282]             }
[17:43:47.282]             function(cond) {
[17:43:47.282]                 is_error <- inherits(cond, "error")
[17:43:47.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.282]                   NULL)
[17:43:47.282]                 if (is_error) {
[17:43:47.282]                   sessionInformation <- function() {
[17:43:47.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.282]                       search = base::search(), system = base::Sys.info())
[17:43:47.282]                   }
[17:43:47.282]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.282]                     cond$call), session = sessionInformation(), 
[17:43:47.282]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.282]                   signalCondition(cond)
[17:43:47.282]                 }
[17:43:47.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:47.282]                 "immediateCondition"))) {
[17:43:47.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:47.282]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.282]                   if (TRUE && !signal) {
[17:43:47.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.282]                     {
[17:43:47.282]                       inherits <- base::inherits
[17:43:47.282]                       invokeRestart <- base::invokeRestart
[17:43:47.282]                       is.null <- base::is.null
[17:43:47.282]                       muffled <- FALSE
[17:43:47.282]                       if (inherits(cond, "message")) {
[17:43:47.282]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.282]                         if (muffled) 
[17:43:47.282]                           invokeRestart("muffleMessage")
[17:43:47.282]                       }
[17:43:47.282]                       else if (inherits(cond, "warning")) {
[17:43:47.282]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.282]                         if (muffled) 
[17:43:47.282]                           invokeRestart("muffleWarning")
[17:43:47.282]                       }
[17:43:47.282]                       else if (inherits(cond, "condition")) {
[17:43:47.282]                         if (!is.null(pattern)) {
[17:43:47.282]                           computeRestarts <- base::computeRestarts
[17:43:47.282]                           grepl <- base::grepl
[17:43:47.282]                           restarts <- computeRestarts(cond)
[17:43:47.282]                           for (restart in restarts) {
[17:43:47.282]                             name <- restart$name
[17:43:47.282]                             if (is.null(name)) 
[17:43:47.282]                               next
[17:43:47.282]                             if (!grepl(pattern, name)) 
[17:43:47.282]                               next
[17:43:47.282]                             invokeRestart(restart)
[17:43:47.282]                             muffled <- TRUE
[17:43:47.282]                             break
[17:43:47.282]                           }
[17:43:47.282]                         }
[17:43:47.282]                       }
[17:43:47.282]                       invisible(muffled)
[17:43:47.282]                     }
[17:43:47.282]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.282]                   }
[17:43:47.282]                 }
[17:43:47.282]                 else {
[17:43:47.282]                   if (TRUE) {
[17:43:47.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.282]                     {
[17:43:47.282]                       inherits <- base::inherits
[17:43:47.282]                       invokeRestart <- base::invokeRestart
[17:43:47.282]                       is.null <- base::is.null
[17:43:47.282]                       muffled <- FALSE
[17:43:47.282]                       if (inherits(cond, "message")) {
[17:43:47.282]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.282]                         if (muffled) 
[17:43:47.282]                           invokeRestart("muffleMessage")
[17:43:47.282]                       }
[17:43:47.282]                       else if (inherits(cond, "warning")) {
[17:43:47.282]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.282]                         if (muffled) 
[17:43:47.282]                           invokeRestart("muffleWarning")
[17:43:47.282]                       }
[17:43:47.282]                       else if (inherits(cond, "condition")) {
[17:43:47.282]                         if (!is.null(pattern)) {
[17:43:47.282]                           computeRestarts <- base::computeRestarts
[17:43:47.282]                           grepl <- base::grepl
[17:43:47.282]                           restarts <- computeRestarts(cond)
[17:43:47.282]                           for (restart in restarts) {
[17:43:47.282]                             name <- restart$name
[17:43:47.282]                             if (is.null(name)) 
[17:43:47.282]                               next
[17:43:47.282]                             if (!grepl(pattern, name)) 
[17:43:47.282]                               next
[17:43:47.282]                             invokeRestart(restart)
[17:43:47.282]                             muffled <- TRUE
[17:43:47.282]                             break
[17:43:47.282]                           }
[17:43:47.282]                         }
[17:43:47.282]                       }
[17:43:47.282]                       invisible(muffled)
[17:43:47.282]                     }
[17:43:47.282]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.282]                   }
[17:43:47.282]                 }
[17:43:47.282]             }
[17:43:47.282]         }))
[17:43:47.282]     }, error = function(ex) {
[17:43:47.282]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.282]                 ...future.rng), started = ...future.startTime, 
[17:43:47.282]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.282]             version = "1.8"), class = "FutureResult")
[17:43:47.282]     }, finally = {
[17:43:47.282]         if (!identical(...future.workdir, getwd())) 
[17:43:47.282]             setwd(...future.workdir)
[17:43:47.282]         {
[17:43:47.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.282]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.282]             }
[17:43:47.282]             base::options(...future.oldOptions)
[17:43:47.282]             if (.Platform$OS.type == "windows") {
[17:43:47.282]                 old_names <- names(...future.oldEnvVars)
[17:43:47.282]                 envs <- base::Sys.getenv()
[17:43:47.282]                 names <- names(envs)
[17:43:47.282]                 common <- intersect(names, old_names)
[17:43:47.282]                 added <- setdiff(names, old_names)
[17:43:47.282]                 removed <- setdiff(old_names, names)
[17:43:47.282]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.282]                   envs[common]]
[17:43:47.282]                 NAMES <- toupper(changed)
[17:43:47.282]                 args <- list()
[17:43:47.282]                 for (kk in seq_along(NAMES)) {
[17:43:47.282]                   name <- changed[[kk]]
[17:43:47.282]                   NAME <- NAMES[[kk]]
[17:43:47.282]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.282]                     next
[17:43:47.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.282]                 }
[17:43:47.282]                 NAMES <- toupper(added)
[17:43:47.282]                 for (kk in seq_along(NAMES)) {
[17:43:47.282]                   name <- added[[kk]]
[17:43:47.282]                   NAME <- NAMES[[kk]]
[17:43:47.282]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.282]                     next
[17:43:47.282]                   args[[name]] <- ""
[17:43:47.282]                 }
[17:43:47.282]                 NAMES <- toupper(removed)
[17:43:47.282]                 for (kk in seq_along(NAMES)) {
[17:43:47.282]                   name <- removed[[kk]]
[17:43:47.282]                   NAME <- NAMES[[kk]]
[17:43:47.282]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.282]                     next
[17:43:47.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.282]                 }
[17:43:47.282]                 if (length(args) > 0) 
[17:43:47.282]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.282]             }
[17:43:47.282]             else {
[17:43:47.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.282]             }
[17:43:47.282]             {
[17:43:47.282]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.282]                   0L) {
[17:43:47.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.282]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.282]                   base::options(opts)
[17:43:47.282]                 }
[17:43:47.282]                 {
[17:43:47.282]                   {
[17:43:47.282]                     NULL
[17:43:47.282]                     RNGkind("Mersenne-Twister")
[17:43:47.282]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:47.282]                       inherits = FALSE)
[17:43:47.282]                   }
[17:43:47.282]                   options(future.plan = NULL)
[17:43:47.282]                   if (is.na(NA_character_)) 
[17:43:47.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.282]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:47.282]                     .init = FALSE)
[17:43:47.282]                 }
[17:43:47.282]             }
[17:43:47.282]         }
[17:43:47.282]     })
[17:43:47.282]     if (TRUE) {
[17:43:47.282]         base::sink(type = "output", split = FALSE)
[17:43:47.282]         if (TRUE) {
[17:43:47.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.282]         }
[17:43:47.282]         else {
[17:43:47.282]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.282]         }
[17:43:47.282]         base::close(...future.stdout)
[17:43:47.282]         ...future.stdout <- NULL
[17:43:47.282]     }
[17:43:47.282]     ...future.result$conditions <- ...future.conditions
[17:43:47.282]     ...future.result$finished <- base::Sys.time()
[17:43:47.282]     ...future.result
[17:43:47.282] }
[17:43:47.283] assign_globals() ...
[17:43:47.283] List of 5
[17:43:47.283]  $ future.call.arguments    : list()
[17:43:47.283]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.283]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:47.283]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:47.283]  $ ...future.elements_ii    :List of 2
[17:43:47.283]   ..$ : num [1:4] 1 3 1 7
[17:43:47.283]   ..$ : num [1:4] 2 4 6 8
[17:43:47.283]  $ ...future.seeds_ii       : NULL
[17:43:47.283]  $ ...future.globals.maxSize: num Inf
[17:43:47.283]  - attr(*, "resolved")= logi FALSE
[17:43:47.283]  - attr(*, "total_size")= num NA
[17:43:47.283]  - attr(*, "where")=List of 5
[17:43:47.283]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:47.283]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:47.283]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:47.283]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:47.283]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:47.283]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.283]  - attr(*, "already-done")= logi TRUE
[17:43:47.290] - copied ‘future.call.arguments’ to environment
[17:43:47.290] - copied ‘...future.FUN’ to environment
[17:43:47.290] - copied ‘...future.elements_ii’ to environment
[17:43:47.290] - copied ‘...future.seeds_ii’ to environment
[17:43:47.290] - copied ‘...future.globals.maxSize’ to environment
[17:43:47.290] assign_globals() ... done
[17:43:47.291] plan(): Setting new future strategy stack:
[17:43:47.291] List of future strategies:
[17:43:47.291] 1. sequential:
[17:43:47.291]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.291]    - tweaked: FALSE
[17:43:47.291]    - call: NULL
[17:43:47.291] plan(): nbrOfWorkers() = 1
[17:43:47.292] plan(): Setting new future strategy stack:
[17:43:47.292] List of future strategies:
[17:43:47.292] 1. sequential:
[17:43:47.292]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.292]    - tweaked: FALSE
[17:43:47.292]    - call: plan(strategy)
[17:43:47.293] plan(): nbrOfWorkers() = 1
[17:43:47.293] SequentialFuture started (and completed)
[17:43:47.293] - Launch lazy future ... done
[17:43:47.293] run() for ‘SequentialFuture’ ... done
[17:43:47.293] Created future:
[17:43:47.293] SequentialFuture:
[17:43:47.293] Label: ‘future_apply-1’
[17:43:47.293] Expression:
[17:43:47.293] {
[17:43:47.293]     do.call(function(...) {
[17:43:47.293]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.293]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.293]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.293]             on.exit(options(oopts), add = TRUE)
[17:43:47.293]         }
[17:43:47.293]         {
[17:43:47.293]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.293]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.293]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.293]             })
[17:43:47.293]         }
[17:43:47.293]     }, args = future.call.arguments)
[17:43:47.293] }
[17:43:47.293] Lazy evaluation: FALSE
[17:43:47.293] Asynchronous evaluation: FALSE
[17:43:47.293] Local evaluation: TRUE
[17:43:47.293] Environment: R_GlobalEnv
[17:43:47.293] Capture standard output: TRUE
[17:43:47.293] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:47.293] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:47.293] Packages: <none>
[17:43:47.293] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:47.293] Resolved: TRUE
[17:43:47.293] Value: 2.21 KiB of class ‘list’
[17:43:47.293] Early signaling: FALSE
[17:43:47.293] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:47.293] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.294] Chunk #1 of 1 ... DONE
[17:43:47.294] Launching 1 futures (chunks) ... DONE
[17:43:47.295] Resolving 1 futures (chunks) ...
[17:43:47.295] resolve() on list ...
[17:43:47.295]  recursive: 0
[17:43:47.295]  length: 1
[17:43:47.295] 
[17:43:47.295] resolved() for ‘SequentialFuture’ ...
[17:43:47.295] - state: ‘finished’
[17:43:47.295] - run: TRUE
[17:43:47.295] - result: ‘FutureResult’
[17:43:47.295] resolved() for ‘SequentialFuture’ ... done
[17:43:47.296] Future #1
[17:43:47.296] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:47.296] - nx: 1
[17:43:47.296] - relay: TRUE
[17:43:47.296] - stdout: TRUE
[17:43:47.296] - signal: TRUE
[17:43:47.296] - resignal: FALSE
[17:43:47.296] - force: TRUE
[17:43:47.296] - relayed: [n=1] FALSE
[17:43:47.296] - queued futures: [n=1] FALSE
[17:43:47.296]  - until=1
[17:43:47.297]  - relaying element #1
[17:43:47.297] - relayed: [n=1] TRUE
[17:43:47.297] - queued futures: [n=1] TRUE
[17:43:47.297] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:47.297]  length: 0 (resolved future 1)
[17:43:47.297] Relaying remaining futures
[17:43:47.297] signalConditionsASAP(NULL, pos=0) ...
[17:43:47.297] - nx: 1
[17:43:47.297] - relay: TRUE
[17:43:47.297] - stdout: TRUE
[17:43:47.298] - signal: TRUE
[17:43:47.298] - resignal: FALSE
[17:43:47.298] - force: TRUE
[17:43:47.298] - relayed: [n=1] TRUE
[17:43:47.298] - queued futures: [n=1] TRUE
 - flush all
[17:43:47.298] - relayed: [n=1] TRUE
[17:43:47.298] - queued futures: [n=1] TRUE
[17:43:47.298] signalConditionsASAP(NULL, pos=0) ... done
[17:43:47.298] resolve() on list ... DONE
[17:43:47.298]  - Number of value chunks collected: 1
[17:43:47.299] Resolving 1 futures (chunks) ... DONE
[17:43:47.299] Reducing values from 1 chunks ...
[17:43:47.299]  - Number of values collected after concatenation: 2
[17:43:47.299]  - Number of values expected: 2
[17:43:47.299] Reducing values from 1 chunks ... DONE
[17:43:47.299] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:43:47.301] getGlobalsAndPackagesXApply() ...
[17:43:47.301]  - future.globals: TRUE
[17:43:47.301] getGlobalsAndPackages() ...
[17:43:47.301] Searching for globals...
[17:43:47.302] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:47.303] Searching for globals ... DONE
[17:43:47.303] Resolving globals: FALSE
[17:43:47.303] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:43:47.303] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:43:47.304] - globals: [1] ‘FUN’
[17:43:47.304] - packages: [1] ‘stats’
[17:43:47.304] getGlobalsAndPackages() ... DONE
[17:43:47.304]  - globals found/used: [n=1] ‘FUN’
[17:43:47.304]  - needed namespaces: [n=1] ‘stats’
[17:43:47.304] Finding globals ... DONE
[17:43:47.304]  - use_args: TRUE
[17:43:47.304]  - Getting '...' globals ...
[17:43:47.305] resolve() on list ...
[17:43:47.305]  recursive: 0
[17:43:47.305]  length: 1
[17:43:47.305]  elements: ‘...’
[17:43:47.305]  length: 0 (resolved future 1)
[17:43:47.305] resolve() on list ... DONE
[17:43:47.305]    - '...' content: [n=0] 
[17:43:47.305] List of 1
[17:43:47.305]  $ ...: list()
[17:43:47.305]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.305]  - attr(*, "where")=List of 1
[17:43:47.305]   ..$ ...:<environment: 0x55dfd4ba6298> 
[17:43:47.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.305]  - attr(*, "resolved")= logi TRUE
[17:43:47.305]  - attr(*, "total_size")= num NA
[17:43:47.308]  - Getting '...' globals ... DONE
[17:43:47.308] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:47.308] List of 2
[17:43:47.308]  $ ...future.FUN:function (x, ...)  
[17:43:47.308]  $ ...          : list()
[17:43:47.308]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.308]  - attr(*, "where")=List of 2
[17:43:47.308]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:47.308]   ..$ ...          :<environment: 0x55dfd4ba6298> 
[17:43:47.308]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.308]  - attr(*, "resolved")= logi FALSE
[17:43:47.308]  - attr(*, "total_size")= num 1248
[17:43:47.311] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:47.311] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.311] future_lapply() ...
[17:43:47.313] Number of chunks: 1
[17:43:47.314] getGlobalsAndPackagesXApply() ...
[17:43:47.314]  - future.globals: <name-value list> with names ‘list()’
[17:43:47.314]  - use_args: TRUE
[17:43:47.314] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:47.314] List of 2
[17:43:47.314]  $ ...          : list()
[17:43:47.314]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.314]  $ ...future.FUN:function (x, ...)  
[17:43:47.314]  - attr(*, "where")=List of 2
[17:43:47.314]   ..$ ...          :<environment: 0x55dfd4ba6298> 
[17:43:47.314]   ..$ ...future.FUN:<environment: namespace:stats> 
[17:43:47.314]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.314]  - attr(*, "resolved")= logi FALSE
[17:43:47.314]  - attr(*, "total_size")= num NA
[17:43:47.317] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:47.317] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.317] Number of futures (= number of chunks): 1
[17:43:47.317] Launching 1 futures (chunks) ...
[17:43:47.317] Chunk #1 of 1 ...
[17:43:47.318]  - seeds: <none>
[17:43:47.318]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.318] getGlobalsAndPackages() ...
[17:43:47.318] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.318] Resolving globals: FALSE
[17:43:47.318] Tweak future expression to call with '...' arguments ...
[17:43:47.318] {
[17:43:47.318]     do.call(function(...) {
[17:43:47.318]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.318]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.318]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.318]             on.exit(options(oopts), add = TRUE)
[17:43:47.318]         }
[17:43:47.318]         {
[17:43:47.318]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.318]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.318]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.318]             })
[17:43:47.318]         }
[17:43:47.318]     }, args = future.call.arguments)
[17:43:47.318] }
[17:43:47.318] Tweak future expression to call with '...' arguments ... DONE
[17:43:47.319] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.319] - packages: [1] ‘stats’
[17:43:47.319] getGlobalsAndPackages() ... DONE
[17:43:47.319] run() for ‘Future’ ...
[17:43:47.319] - state: ‘created’
[17:43:47.320] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:47.320] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.320] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:47.320]   - Field: ‘label’
[17:43:47.320]   - Field: ‘local’
[17:43:47.320]   - Field: ‘owner’
[17:43:47.320]   - Field: ‘envir’
[17:43:47.321]   - Field: ‘packages’
[17:43:47.321]   - Field: ‘gc’
[17:43:47.321]   - Field: ‘conditions’
[17:43:47.321]   - Field: ‘expr’
[17:43:47.321]   - Field: ‘uuid’
[17:43:47.321]   - Field: ‘seed’
[17:43:47.321]   - Field: ‘version’
[17:43:47.321]   - Field: ‘result’
[17:43:47.321]   - Field: ‘asynchronous’
[17:43:47.321]   - Field: ‘calls’
[17:43:47.321]   - Field: ‘globals’
[17:43:47.322]   - Field: ‘stdout’
[17:43:47.322]   - Field: ‘earlySignal’
[17:43:47.322]   - Field: ‘lazy’
[17:43:47.322]   - Field: ‘state’
[17:43:47.322] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:47.322] - Launch lazy future ...
[17:43:47.322] Packages needed by the future expression (n = 1): ‘stats’
[17:43:47.322] Packages needed by future strategies (n = 0): <none>
[17:43:47.323] {
[17:43:47.323]     {
[17:43:47.323]         {
[17:43:47.323]             ...future.startTime <- base::Sys.time()
[17:43:47.323]             {
[17:43:47.323]                 {
[17:43:47.323]                   {
[17:43:47.323]                     {
[17:43:47.323]                       base::local({
[17:43:47.323]                         has_future <- base::requireNamespace("future", 
[17:43:47.323]                           quietly = TRUE)
[17:43:47.323]                         if (has_future) {
[17:43:47.323]                           ns <- base::getNamespace("future")
[17:43:47.323]                           version <- ns[[".package"]][["version"]]
[17:43:47.323]                           if (is.null(version)) 
[17:43:47.323]                             version <- utils::packageVersion("future")
[17:43:47.323]                         }
[17:43:47.323]                         else {
[17:43:47.323]                           version <- NULL
[17:43:47.323]                         }
[17:43:47.323]                         if (!has_future || version < "1.8.0") {
[17:43:47.323]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.323]                             "", base::R.version$version.string), 
[17:43:47.323]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:47.323]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.323]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.323]                               "release", "version")], collapse = " "), 
[17:43:47.323]                             hostname = base::Sys.info()[["nodename"]])
[17:43:47.323]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.323]                             info)
[17:43:47.323]                           info <- base::paste(info, collapse = "; ")
[17:43:47.323]                           if (!has_future) {
[17:43:47.323]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.323]                               info)
[17:43:47.323]                           }
[17:43:47.323]                           else {
[17:43:47.323]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.323]                               info, version)
[17:43:47.323]                           }
[17:43:47.323]                           base::stop(msg)
[17:43:47.323]                         }
[17:43:47.323]                       })
[17:43:47.323]                     }
[17:43:47.323]                     base::local({
[17:43:47.323]                       for (pkg in "stats") {
[17:43:47.323]                         base::loadNamespace(pkg)
[17:43:47.323]                         base::library(pkg, character.only = TRUE)
[17:43:47.323]                       }
[17:43:47.323]                     })
[17:43:47.323]                   }
[17:43:47.323]                   ...future.strategy.old <- future::plan("list")
[17:43:47.323]                   options(future.plan = NULL)
[17:43:47.323]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.323]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.323]                 }
[17:43:47.323]                 ...future.workdir <- getwd()
[17:43:47.323]             }
[17:43:47.323]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.323]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.323]         }
[17:43:47.323]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.323]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:47.323]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.323]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.323]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.323]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.323]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.323]             base::names(...future.oldOptions))
[17:43:47.323]     }
[17:43:47.323]     if (FALSE) {
[17:43:47.323]     }
[17:43:47.323]     else {
[17:43:47.323]         if (TRUE) {
[17:43:47.323]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.323]                 open = "w")
[17:43:47.323]         }
[17:43:47.323]         else {
[17:43:47.323]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.323]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.323]         }
[17:43:47.323]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.323]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.323]             base::sink(type = "output", split = FALSE)
[17:43:47.323]             base::close(...future.stdout)
[17:43:47.323]         }, add = TRUE)
[17:43:47.323]     }
[17:43:47.323]     ...future.frame <- base::sys.nframe()
[17:43:47.323]     ...future.conditions <- base::list()
[17:43:47.323]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.323]     if (FALSE) {
[17:43:47.323]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.323]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.323]     }
[17:43:47.323]     ...future.result <- base::tryCatch({
[17:43:47.323]         base::withCallingHandlers({
[17:43:47.323]             ...future.value <- base::withVisible(base::local({
[17:43:47.323]                 do.call(function(...) {
[17:43:47.323]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.323]                   if (!identical(...future.globals.maxSize.org, 
[17:43:47.323]                     ...future.globals.maxSize)) {
[17:43:47.323]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.323]                     on.exit(options(oopts), add = TRUE)
[17:43:47.323]                   }
[17:43:47.323]                   {
[17:43:47.323]                     lapply(seq_along(...future.elements_ii), 
[17:43:47.323]                       FUN = function(jj) {
[17:43:47.323]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.323]                         ...future.FUN(...future.X_jj, ...)
[17:43:47.323]                       })
[17:43:47.323]                   }
[17:43:47.323]                 }, args = future.call.arguments)
[17:43:47.323]             }))
[17:43:47.323]             future::FutureResult(value = ...future.value$value, 
[17:43:47.323]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.323]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.323]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.323]                     ...future.globalenv.names))
[17:43:47.323]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.323]         }, condition = base::local({
[17:43:47.323]             c <- base::c
[17:43:47.323]             inherits <- base::inherits
[17:43:47.323]             invokeRestart <- base::invokeRestart
[17:43:47.323]             length <- base::length
[17:43:47.323]             list <- base::list
[17:43:47.323]             seq.int <- base::seq.int
[17:43:47.323]             signalCondition <- base::signalCondition
[17:43:47.323]             sys.calls <- base::sys.calls
[17:43:47.323]             `[[` <- base::`[[`
[17:43:47.323]             `+` <- base::`+`
[17:43:47.323]             `<<-` <- base::`<<-`
[17:43:47.323]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.323]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.323]                   3L)]
[17:43:47.323]             }
[17:43:47.323]             function(cond) {
[17:43:47.323]                 is_error <- inherits(cond, "error")
[17:43:47.323]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.323]                   NULL)
[17:43:47.323]                 if (is_error) {
[17:43:47.323]                   sessionInformation <- function() {
[17:43:47.323]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.323]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.323]                       search = base::search(), system = base::Sys.info())
[17:43:47.323]                   }
[17:43:47.323]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.323]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.323]                     cond$call), session = sessionInformation(), 
[17:43:47.323]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.323]                   signalCondition(cond)
[17:43:47.323]                 }
[17:43:47.323]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:47.323]                 "immediateCondition"))) {
[17:43:47.323]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:47.323]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.323]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.323]                   if (TRUE && !signal) {
[17:43:47.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.323]                     {
[17:43:47.323]                       inherits <- base::inherits
[17:43:47.323]                       invokeRestart <- base::invokeRestart
[17:43:47.323]                       is.null <- base::is.null
[17:43:47.323]                       muffled <- FALSE
[17:43:47.323]                       if (inherits(cond, "message")) {
[17:43:47.323]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.323]                         if (muffled) 
[17:43:47.323]                           invokeRestart("muffleMessage")
[17:43:47.323]                       }
[17:43:47.323]                       else if (inherits(cond, "warning")) {
[17:43:47.323]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.323]                         if (muffled) 
[17:43:47.323]                           invokeRestart("muffleWarning")
[17:43:47.323]                       }
[17:43:47.323]                       else if (inherits(cond, "condition")) {
[17:43:47.323]                         if (!is.null(pattern)) {
[17:43:47.323]                           computeRestarts <- base::computeRestarts
[17:43:47.323]                           grepl <- base::grepl
[17:43:47.323]                           restarts <- computeRestarts(cond)
[17:43:47.323]                           for (restart in restarts) {
[17:43:47.323]                             name <- restart$name
[17:43:47.323]                             if (is.null(name)) 
[17:43:47.323]                               next
[17:43:47.323]                             if (!grepl(pattern, name)) 
[17:43:47.323]                               next
[17:43:47.323]                             invokeRestart(restart)
[17:43:47.323]                             muffled <- TRUE
[17:43:47.323]                             break
[17:43:47.323]                           }
[17:43:47.323]                         }
[17:43:47.323]                       }
[17:43:47.323]                       invisible(muffled)
[17:43:47.323]                     }
[17:43:47.323]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.323]                   }
[17:43:47.323]                 }
[17:43:47.323]                 else {
[17:43:47.323]                   if (TRUE) {
[17:43:47.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.323]                     {
[17:43:47.323]                       inherits <- base::inherits
[17:43:47.323]                       invokeRestart <- base::invokeRestart
[17:43:47.323]                       is.null <- base::is.null
[17:43:47.323]                       muffled <- FALSE
[17:43:47.323]                       if (inherits(cond, "message")) {
[17:43:47.323]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.323]                         if (muffled) 
[17:43:47.323]                           invokeRestart("muffleMessage")
[17:43:47.323]                       }
[17:43:47.323]                       else if (inherits(cond, "warning")) {
[17:43:47.323]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.323]                         if (muffled) 
[17:43:47.323]                           invokeRestart("muffleWarning")
[17:43:47.323]                       }
[17:43:47.323]                       else if (inherits(cond, "condition")) {
[17:43:47.323]                         if (!is.null(pattern)) {
[17:43:47.323]                           computeRestarts <- base::computeRestarts
[17:43:47.323]                           grepl <- base::grepl
[17:43:47.323]                           restarts <- computeRestarts(cond)
[17:43:47.323]                           for (restart in restarts) {
[17:43:47.323]                             name <- restart$name
[17:43:47.323]                             if (is.null(name)) 
[17:43:47.323]                               next
[17:43:47.323]                             if (!grepl(pattern, name)) 
[17:43:47.323]                               next
[17:43:47.323]                             invokeRestart(restart)
[17:43:47.323]                             muffled <- TRUE
[17:43:47.323]                             break
[17:43:47.323]                           }
[17:43:47.323]                         }
[17:43:47.323]                       }
[17:43:47.323]                       invisible(muffled)
[17:43:47.323]                     }
[17:43:47.323]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.323]                   }
[17:43:47.323]                 }
[17:43:47.323]             }
[17:43:47.323]         }))
[17:43:47.323]     }, error = function(ex) {
[17:43:47.323]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.323]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.323]                 ...future.rng), started = ...future.startTime, 
[17:43:47.323]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.323]             version = "1.8"), class = "FutureResult")
[17:43:47.323]     }, finally = {
[17:43:47.323]         if (!identical(...future.workdir, getwd())) 
[17:43:47.323]             setwd(...future.workdir)
[17:43:47.323]         {
[17:43:47.323]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.323]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.323]             }
[17:43:47.323]             base::options(...future.oldOptions)
[17:43:47.323]             if (.Platform$OS.type == "windows") {
[17:43:47.323]                 old_names <- names(...future.oldEnvVars)
[17:43:47.323]                 envs <- base::Sys.getenv()
[17:43:47.323]                 names <- names(envs)
[17:43:47.323]                 common <- intersect(names, old_names)
[17:43:47.323]                 added <- setdiff(names, old_names)
[17:43:47.323]                 removed <- setdiff(old_names, names)
[17:43:47.323]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.323]                   envs[common]]
[17:43:47.323]                 NAMES <- toupper(changed)
[17:43:47.323]                 args <- list()
[17:43:47.323]                 for (kk in seq_along(NAMES)) {
[17:43:47.323]                   name <- changed[[kk]]
[17:43:47.323]                   NAME <- NAMES[[kk]]
[17:43:47.323]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.323]                     next
[17:43:47.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.323]                 }
[17:43:47.323]                 NAMES <- toupper(added)
[17:43:47.323]                 for (kk in seq_along(NAMES)) {
[17:43:47.323]                   name <- added[[kk]]
[17:43:47.323]                   NAME <- NAMES[[kk]]
[17:43:47.323]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.323]                     next
[17:43:47.323]                   args[[name]] <- ""
[17:43:47.323]                 }
[17:43:47.323]                 NAMES <- toupper(removed)
[17:43:47.323]                 for (kk in seq_along(NAMES)) {
[17:43:47.323]                   name <- removed[[kk]]
[17:43:47.323]                   NAME <- NAMES[[kk]]
[17:43:47.323]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.323]                     next
[17:43:47.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.323]                 }
[17:43:47.323]                 if (length(args) > 0) 
[17:43:47.323]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.323]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.323]             }
[17:43:47.323]             else {
[17:43:47.323]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.323]             }
[17:43:47.323]             {
[17:43:47.323]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.323]                   0L) {
[17:43:47.323]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.323]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.323]                   base::options(opts)
[17:43:47.323]                 }
[17:43:47.323]                 {
[17:43:47.323]                   {
[17:43:47.323]                     NULL
[17:43:47.323]                     RNGkind("Mersenne-Twister")
[17:43:47.323]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:47.323]                       inherits = FALSE)
[17:43:47.323]                   }
[17:43:47.323]                   options(future.plan = NULL)
[17:43:47.323]                   if (is.na(NA_character_)) 
[17:43:47.323]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.323]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.323]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:47.323]                     .init = FALSE)
[17:43:47.323]                 }
[17:43:47.323]             }
[17:43:47.323]         }
[17:43:47.323]     })
[17:43:47.323]     if (TRUE) {
[17:43:47.323]         base::sink(type = "output", split = FALSE)
[17:43:47.323]         if (TRUE) {
[17:43:47.323]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.323]         }
[17:43:47.323]         else {
[17:43:47.323]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.323]         }
[17:43:47.323]         base::close(...future.stdout)
[17:43:47.323]         ...future.stdout <- NULL
[17:43:47.323]     }
[17:43:47.323]     ...future.result$conditions <- ...future.conditions
[17:43:47.323]     ...future.result$finished <- base::Sys.time()
[17:43:47.323]     ...future.result
[17:43:47.323] }
[17:43:47.325] assign_globals() ...
[17:43:47.325] List of 5
[17:43:47.325]  $ future.call.arguments    : list()
[17:43:47.325]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.325]  $ ...future.FUN            :function (x, ...)  
[17:43:47.325]  $ ...future.elements_ii    :List of 2
[17:43:47.325]   ..$ : num [1:4] 1 3 1 7
[17:43:47.325]   ..$ : num [1:4] 2 4 6 8
[17:43:47.325]  $ ...future.seeds_ii       : NULL
[17:43:47.325]  $ ...future.globals.maxSize: num Inf
[17:43:47.325]  - attr(*, "resolved")= logi FALSE
[17:43:47.325]  - attr(*, "total_size")= num NA
[17:43:47.325]  - attr(*, "where")=List of 5
[17:43:47.325]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:47.325]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:47.325]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:47.325]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:47.325]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:47.325]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.325]  - attr(*, "already-done")= logi TRUE
[17:43:47.330] - copied ‘future.call.arguments’ to environment
[17:43:47.330] - copied ‘...future.FUN’ to environment
[17:43:47.330] - copied ‘...future.elements_ii’ to environment
[17:43:47.330] - copied ‘...future.seeds_ii’ to environment
[17:43:47.330] - copied ‘...future.globals.maxSize’ to environment
[17:43:47.330] assign_globals() ... done
[17:43:47.331] plan(): Setting new future strategy stack:
[17:43:47.331] List of future strategies:
[17:43:47.331] 1. sequential:
[17:43:47.331]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.331]    - tweaked: FALSE
[17:43:47.331]    - call: NULL
[17:43:47.331] plan(): nbrOfWorkers() = 1
[17:43:47.332] plan(): Setting new future strategy stack:
[17:43:47.332] List of future strategies:
[17:43:47.332] 1. sequential:
[17:43:47.332]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.332]    - tweaked: FALSE
[17:43:47.332]    - call: plan(strategy)
[17:43:47.333] plan(): nbrOfWorkers() = 1
[17:43:47.333] SequentialFuture started (and completed)
[17:43:47.333] - Launch lazy future ... done
[17:43:47.333] run() for ‘SequentialFuture’ ... done
[17:43:47.333] Created future:
[17:43:47.333] SequentialFuture:
[17:43:47.333] Label: ‘future_apply-1’
[17:43:47.333] Expression:
[17:43:47.333] {
[17:43:47.333]     do.call(function(...) {
[17:43:47.333]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.333]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.333]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.333]             on.exit(options(oopts), add = TRUE)
[17:43:47.333]         }
[17:43:47.333]         {
[17:43:47.333]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.333]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.333]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.333]             })
[17:43:47.333]         }
[17:43:47.333]     }, args = future.call.arguments)
[17:43:47.333] }
[17:43:47.333] Lazy evaluation: FALSE
[17:43:47.333] Asynchronous evaluation: FALSE
[17:43:47.333] Local evaluation: TRUE
[17:43:47.333] Environment: R_GlobalEnv
[17:43:47.333] Capture standard output: TRUE
[17:43:47.333] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:47.333] Globals: 5 objects totaling 1.43 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:47.333] Packages: 1 packages (‘stats’)
[17:43:47.333] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:47.333] Resolved: TRUE
[17:43:47.333] Value: 1.14 KiB of class ‘list’
[17:43:47.333] Early signaling: FALSE
[17:43:47.333] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:47.333] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.334] Chunk #1 of 1 ... DONE
[17:43:47.334] Launching 1 futures (chunks) ... DONE
[17:43:47.335] Resolving 1 futures (chunks) ...
[17:43:47.335] resolve() on list ...
[17:43:47.335]  recursive: 0
[17:43:47.335]  length: 1
[17:43:47.335] 
[17:43:47.335] resolved() for ‘SequentialFuture’ ...
[17:43:47.335] - state: ‘finished’
[17:43:47.335] - run: TRUE
[17:43:47.335] - result: ‘FutureResult’
[17:43:47.335] resolved() for ‘SequentialFuture’ ... done
[17:43:47.336] Future #1
[17:43:47.336] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:47.336] - nx: 1
[17:43:47.336] - relay: TRUE
[17:43:47.336] - stdout: TRUE
[17:43:47.336] - signal: TRUE
[17:43:47.336] - resignal: FALSE
[17:43:47.336] - force: TRUE
[17:43:47.336] - relayed: [n=1] FALSE
[17:43:47.336] - queued futures: [n=1] FALSE
[17:43:47.336]  - until=1
[17:43:47.337]  - relaying element #1
[17:43:47.337] - relayed: [n=1] TRUE
[17:43:47.337] - queued futures: [n=1] TRUE
[17:43:47.337] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:47.337]  length: 0 (resolved future 1)
[17:43:47.337] Relaying remaining futures
[17:43:47.337] signalConditionsASAP(NULL, pos=0) ...
[17:43:47.337] - nx: 1
[17:43:47.337] - relay: TRUE
[17:43:47.337] - stdout: TRUE
[17:43:47.338] - signal: TRUE
[17:43:47.338] - resignal: FALSE
[17:43:47.339] - force: TRUE
[17:43:47.339] - relayed: [n=1] TRUE
[17:43:47.340] - queued futures: [n=1] TRUE
 - flush all
[17:43:47.340] - relayed: [n=1] TRUE
[17:43:47.340] - queued futures: [n=1] TRUE
[17:43:47.340] signalConditionsASAP(NULL, pos=0) ... done
[17:43:47.340] resolve() on list ... DONE
[17:43:47.340]  - Number of value chunks collected: 1
[17:43:47.340] Resolving 1 futures (chunks) ... DONE
[17:43:47.340] Reducing values from 1 chunks ...
[17:43:47.340]  - Number of values collected after concatenation: 2
[17:43:47.341]  - Number of values expected: 2
[17:43:47.341] Reducing values from 1 chunks ... DONE
[17:43:47.341] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[17:43:47.341] getGlobalsAndPackagesXApply() ...
[17:43:47.342]  - future.globals: TRUE
[17:43:47.342] getGlobalsAndPackages() ...
[17:43:47.342] Searching for globals...
[17:43:47.343] - globals found: [1] ‘FUN’
[17:43:47.343] Searching for globals ... DONE
[17:43:47.343] Resolving globals: FALSE
[17:43:47.343] The total size of the 1 globals is 848 bytes (848 bytes)
[17:43:47.344] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:43:47.344] - globals: [1] ‘FUN’
[17:43:47.344] 
[17:43:47.344] getGlobalsAndPackages() ... DONE
[17:43:47.344]  - globals found/used: [n=1] ‘FUN’
[17:43:47.344]  - needed namespaces: [n=0] 
[17:43:47.344] Finding globals ... DONE
[17:43:47.344]  - use_args: TRUE
[17:43:47.344]  - Getting '...' globals ...
[17:43:47.345] resolve() on list ...
[17:43:47.345]  recursive: 0
[17:43:47.345]  length: 1
[17:43:47.345]  elements: ‘...’
[17:43:47.345]  length: 0 (resolved future 1)
[17:43:47.345] resolve() on list ... DONE
[17:43:47.345]    - '...' content: [n=0] 
[17:43:47.345] List of 1
[17:43:47.345]  $ ...: list()
[17:43:47.345]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.345]  - attr(*, "where")=List of 1
[17:43:47.345]   ..$ ...:<environment: 0x55dfd352b4c8> 
[17:43:47.345]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.345]  - attr(*, "resolved")= logi TRUE
[17:43:47.345]  - attr(*, "total_size")= num NA
[17:43:47.348]  - Getting '...' globals ... DONE
[17:43:47.348] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:47.348] List of 2
[17:43:47.348]  $ ...future.FUN:function (x)  
[17:43:47.348]  $ ...          : list()
[17:43:47.348]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.348]  - attr(*, "where")=List of 2
[17:43:47.348]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:47.348]   ..$ ...          :<environment: 0x55dfd352b4c8> 
[17:43:47.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.348]  - attr(*, "resolved")= logi FALSE
[17:43:47.348]  - attr(*, "total_size")= num 848
[17:43:47.351] Packages to be attached in all futures: [n=0] 
[17:43:47.351] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.351] future_lapply() ...
[17:43:47.352] Number of chunks: 1
[17:43:47.352] getGlobalsAndPackagesXApply() ...
[17:43:47.352]  - future.globals: <name-value list> with names ‘list()’
[17:43:47.352]  - use_args: TRUE
[17:43:47.352] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:47.352] List of 2
[17:43:47.352]  $ ...          : list()
[17:43:47.352]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.352]  $ ...future.FUN:function (x)  
[17:43:47.352]  - attr(*, "where")=List of 2
[17:43:47.352]   ..$ ...          :<environment: 0x55dfd352b4c8> 
[17:43:47.352]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:47.352]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.352]  - attr(*, "resolved")= logi FALSE
[17:43:47.352]  - attr(*, "total_size")= num NA
[17:43:47.355] Packages to be attached in all futures: [n=0] 
[17:43:47.356] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.356] Number of futures (= number of chunks): 1
[17:43:47.356] Launching 1 futures (chunks) ...
[17:43:47.356] Chunk #1 of 1 ...
[17:43:47.356]  - seeds: <none>
[17:43:47.356]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.356] getGlobalsAndPackages() ...
[17:43:47.356] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.356] Resolving globals: FALSE
[17:43:47.357] Tweak future expression to call with '...' arguments ...
[17:43:47.357] {
[17:43:47.357]     do.call(function(...) {
[17:43:47.357]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.357]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.357]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.357]             on.exit(options(oopts), add = TRUE)
[17:43:47.357]         }
[17:43:47.357]         {
[17:43:47.357]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.357]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.357]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.357]             })
[17:43:47.357]         }
[17:43:47.357]     }, args = future.call.arguments)
[17:43:47.357] }
[17:43:47.357] Tweak future expression to call with '...' arguments ... DONE
[17:43:47.357] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.357] 
[17:43:47.358] getGlobalsAndPackages() ... DONE
[17:43:47.358] run() for ‘Future’ ...
[17:43:47.358] - state: ‘created’
[17:43:47.358] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:47.358] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.358] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:47.358]   - Field: ‘label’
[17:43:47.359]   - Field: ‘local’
[17:43:47.359]   - Field: ‘owner’
[17:43:47.359]   - Field: ‘envir’
[17:43:47.359]   - Field: ‘packages’
[17:43:47.359]   - Field: ‘gc’
[17:43:47.359]   - Field: ‘conditions’
[17:43:47.359]   - Field: ‘expr’
[17:43:47.359]   - Field: ‘uuid’
[17:43:47.359]   - Field: ‘seed’
[17:43:47.359]   - Field: ‘version’
[17:43:47.360]   - Field: ‘result’
[17:43:47.360]   - Field: ‘asynchronous’
[17:43:47.360]   - Field: ‘calls’
[17:43:47.360]   - Field: ‘globals’
[17:43:47.360]   - Field: ‘stdout’
[17:43:47.360]   - Field: ‘earlySignal’
[17:43:47.360]   - Field: ‘lazy’
[17:43:47.360]   - Field: ‘state’
[17:43:47.360] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:47.360] - Launch lazy future ...
[17:43:47.360] Packages needed by the future expression (n = 0): <none>
[17:43:47.361] Packages needed by future strategies (n = 0): <none>
[17:43:47.361] {
[17:43:47.361]     {
[17:43:47.361]         {
[17:43:47.361]             ...future.startTime <- base::Sys.time()
[17:43:47.361]             {
[17:43:47.361]                 {
[17:43:47.361]                   {
[17:43:47.361]                     base::local({
[17:43:47.361]                       has_future <- base::requireNamespace("future", 
[17:43:47.361]                         quietly = TRUE)
[17:43:47.361]                       if (has_future) {
[17:43:47.361]                         ns <- base::getNamespace("future")
[17:43:47.361]                         version <- ns[[".package"]][["version"]]
[17:43:47.361]                         if (is.null(version)) 
[17:43:47.361]                           version <- utils::packageVersion("future")
[17:43:47.361]                       }
[17:43:47.361]                       else {
[17:43:47.361]                         version <- NULL
[17:43:47.361]                       }
[17:43:47.361]                       if (!has_future || version < "1.8.0") {
[17:43:47.361]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.361]                           "", base::R.version$version.string), 
[17:43:47.361]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:47.361]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.361]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.361]                             "release", "version")], collapse = " "), 
[17:43:47.361]                           hostname = base::Sys.info()[["nodename"]])
[17:43:47.361]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.361]                           info)
[17:43:47.361]                         info <- base::paste(info, collapse = "; ")
[17:43:47.361]                         if (!has_future) {
[17:43:47.361]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.361]                             info)
[17:43:47.361]                         }
[17:43:47.361]                         else {
[17:43:47.361]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.361]                             info, version)
[17:43:47.361]                         }
[17:43:47.361]                         base::stop(msg)
[17:43:47.361]                       }
[17:43:47.361]                     })
[17:43:47.361]                   }
[17:43:47.361]                   ...future.strategy.old <- future::plan("list")
[17:43:47.361]                   options(future.plan = NULL)
[17:43:47.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.361]                 }
[17:43:47.361]                 ...future.workdir <- getwd()
[17:43:47.361]             }
[17:43:47.361]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.361]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.361]         }
[17:43:47.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.361]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:47.361]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.361]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.361]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.361]             base::names(...future.oldOptions))
[17:43:47.361]     }
[17:43:47.361]     if (FALSE) {
[17:43:47.361]     }
[17:43:47.361]     else {
[17:43:47.361]         if (TRUE) {
[17:43:47.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.361]                 open = "w")
[17:43:47.361]         }
[17:43:47.361]         else {
[17:43:47.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.361]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.361]         }
[17:43:47.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.361]             base::sink(type = "output", split = FALSE)
[17:43:47.361]             base::close(...future.stdout)
[17:43:47.361]         }, add = TRUE)
[17:43:47.361]     }
[17:43:47.361]     ...future.frame <- base::sys.nframe()
[17:43:47.361]     ...future.conditions <- base::list()
[17:43:47.361]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.361]     if (FALSE) {
[17:43:47.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.361]     }
[17:43:47.361]     ...future.result <- base::tryCatch({
[17:43:47.361]         base::withCallingHandlers({
[17:43:47.361]             ...future.value <- base::withVisible(base::local({
[17:43:47.361]                 do.call(function(...) {
[17:43:47.361]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.361]                   if (!identical(...future.globals.maxSize.org, 
[17:43:47.361]                     ...future.globals.maxSize)) {
[17:43:47.361]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.361]                     on.exit(options(oopts), add = TRUE)
[17:43:47.361]                   }
[17:43:47.361]                   {
[17:43:47.361]                     lapply(seq_along(...future.elements_ii), 
[17:43:47.361]                       FUN = function(jj) {
[17:43:47.361]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.361]                         ...future.FUN(...future.X_jj, ...)
[17:43:47.361]                       })
[17:43:47.361]                   }
[17:43:47.361]                 }, args = future.call.arguments)
[17:43:47.361]             }))
[17:43:47.361]             future::FutureResult(value = ...future.value$value, 
[17:43:47.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.361]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.361]                     ...future.globalenv.names))
[17:43:47.361]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.361]         }, condition = base::local({
[17:43:47.361]             c <- base::c
[17:43:47.361]             inherits <- base::inherits
[17:43:47.361]             invokeRestart <- base::invokeRestart
[17:43:47.361]             length <- base::length
[17:43:47.361]             list <- base::list
[17:43:47.361]             seq.int <- base::seq.int
[17:43:47.361]             signalCondition <- base::signalCondition
[17:43:47.361]             sys.calls <- base::sys.calls
[17:43:47.361]             `[[` <- base::`[[`
[17:43:47.361]             `+` <- base::`+`
[17:43:47.361]             `<<-` <- base::`<<-`
[17:43:47.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.361]                   3L)]
[17:43:47.361]             }
[17:43:47.361]             function(cond) {
[17:43:47.361]                 is_error <- inherits(cond, "error")
[17:43:47.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.361]                   NULL)
[17:43:47.361]                 if (is_error) {
[17:43:47.361]                   sessionInformation <- function() {
[17:43:47.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.361]                       search = base::search(), system = base::Sys.info())
[17:43:47.361]                   }
[17:43:47.361]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.361]                     cond$call), session = sessionInformation(), 
[17:43:47.361]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.361]                   signalCondition(cond)
[17:43:47.361]                 }
[17:43:47.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:47.361]                 "immediateCondition"))) {
[17:43:47.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:47.361]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.361]                   if (TRUE && !signal) {
[17:43:47.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.361]                     {
[17:43:47.361]                       inherits <- base::inherits
[17:43:47.361]                       invokeRestart <- base::invokeRestart
[17:43:47.361]                       is.null <- base::is.null
[17:43:47.361]                       muffled <- FALSE
[17:43:47.361]                       if (inherits(cond, "message")) {
[17:43:47.361]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.361]                         if (muffled) 
[17:43:47.361]                           invokeRestart("muffleMessage")
[17:43:47.361]                       }
[17:43:47.361]                       else if (inherits(cond, "warning")) {
[17:43:47.361]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.361]                         if (muffled) 
[17:43:47.361]                           invokeRestart("muffleWarning")
[17:43:47.361]                       }
[17:43:47.361]                       else if (inherits(cond, "condition")) {
[17:43:47.361]                         if (!is.null(pattern)) {
[17:43:47.361]                           computeRestarts <- base::computeRestarts
[17:43:47.361]                           grepl <- base::grepl
[17:43:47.361]                           restarts <- computeRestarts(cond)
[17:43:47.361]                           for (restart in restarts) {
[17:43:47.361]                             name <- restart$name
[17:43:47.361]                             if (is.null(name)) 
[17:43:47.361]                               next
[17:43:47.361]                             if (!grepl(pattern, name)) 
[17:43:47.361]                               next
[17:43:47.361]                             invokeRestart(restart)
[17:43:47.361]                             muffled <- TRUE
[17:43:47.361]                             break
[17:43:47.361]                           }
[17:43:47.361]                         }
[17:43:47.361]                       }
[17:43:47.361]                       invisible(muffled)
[17:43:47.361]                     }
[17:43:47.361]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.361]                   }
[17:43:47.361]                 }
[17:43:47.361]                 else {
[17:43:47.361]                   if (TRUE) {
[17:43:47.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.361]                     {
[17:43:47.361]                       inherits <- base::inherits
[17:43:47.361]                       invokeRestart <- base::invokeRestart
[17:43:47.361]                       is.null <- base::is.null
[17:43:47.361]                       muffled <- FALSE
[17:43:47.361]                       if (inherits(cond, "message")) {
[17:43:47.361]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.361]                         if (muffled) 
[17:43:47.361]                           invokeRestart("muffleMessage")
[17:43:47.361]                       }
[17:43:47.361]                       else if (inherits(cond, "warning")) {
[17:43:47.361]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.361]                         if (muffled) 
[17:43:47.361]                           invokeRestart("muffleWarning")
[17:43:47.361]                       }
[17:43:47.361]                       else if (inherits(cond, "condition")) {
[17:43:47.361]                         if (!is.null(pattern)) {
[17:43:47.361]                           computeRestarts <- base::computeRestarts
[17:43:47.361]                           grepl <- base::grepl
[17:43:47.361]                           restarts <- computeRestarts(cond)
[17:43:47.361]                           for (restart in restarts) {
[17:43:47.361]                             name <- restart$name
[17:43:47.361]                             if (is.null(name)) 
[17:43:47.361]                               next
[17:43:47.361]                             if (!grepl(pattern, name)) 
[17:43:47.361]                               next
[17:43:47.361]                             invokeRestart(restart)
[17:43:47.361]                             muffled <- TRUE
[17:43:47.361]                             break
[17:43:47.361]                           }
[17:43:47.361]                         }
[17:43:47.361]                       }
[17:43:47.361]                       invisible(muffled)
[17:43:47.361]                     }
[17:43:47.361]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.361]                   }
[17:43:47.361]                 }
[17:43:47.361]             }
[17:43:47.361]         }))
[17:43:47.361]     }, error = function(ex) {
[17:43:47.361]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.361]                 ...future.rng), started = ...future.startTime, 
[17:43:47.361]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.361]             version = "1.8"), class = "FutureResult")
[17:43:47.361]     }, finally = {
[17:43:47.361]         if (!identical(...future.workdir, getwd())) 
[17:43:47.361]             setwd(...future.workdir)
[17:43:47.361]         {
[17:43:47.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.361]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.361]             }
[17:43:47.361]             base::options(...future.oldOptions)
[17:43:47.361]             if (.Platform$OS.type == "windows") {
[17:43:47.361]                 old_names <- names(...future.oldEnvVars)
[17:43:47.361]                 envs <- base::Sys.getenv()
[17:43:47.361]                 names <- names(envs)
[17:43:47.361]                 common <- intersect(names, old_names)
[17:43:47.361]                 added <- setdiff(names, old_names)
[17:43:47.361]                 removed <- setdiff(old_names, names)
[17:43:47.361]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.361]                   envs[common]]
[17:43:47.361]                 NAMES <- toupper(changed)
[17:43:47.361]                 args <- list()
[17:43:47.361]                 for (kk in seq_along(NAMES)) {
[17:43:47.361]                   name <- changed[[kk]]
[17:43:47.361]                   NAME <- NAMES[[kk]]
[17:43:47.361]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.361]                     next
[17:43:47.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.361]                 }
[17:43:47.361]                 NAMES <- toupper(added)
[17:43:47.361]                 for (kk in seq_along(NAMES)) {
[17:43:47.361]                   name <- added[[kk]]
[17:43:47.361]                   NAME <- NAMES[[kk]]
[17:43:47.361]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.361]                     next
[17:43:47.361]                   args[[name]] <- ""
[17:43:47.361]                 }
[17:43:47.361]                 NAMES <- toupper(removed)
[17:43:47.361]                 for (kk in seq_along(NAMES)) {
[17:43:47.361]                   name <- removed[[kk]]
[17:43:47.361]                   NAME <- NAMES[[kk]]
[17:43:47.361]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.361]                     next
[17:43:47.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.361]                 }
[17:43:47.361]                 if (length(args) > 0) 
[17:43:47.361]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.361]             }
[17:43:47.361]             else {
[17:43:47.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.361]             }
[17:43:47.361]             {
[17:43:47.361]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.361]                   0L) {
[17:43:47.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.361]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.361]                   base::options(opts)
[17:43:47.361]                 }
[17:43:47.361]                 {
[17:43:47.361]                   {
[17:43:47.361]                     NULL
[17:43:47.361]                     RNGkind("Mersenne-Twister")
[17:43:47.361]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:47.361]                       inherits = FALSE)
[17:43:47.361]                   }
[17:43:47.361]                   options(future.plan = NULL)
[17:43:47.361]                   if (is.na(NA_character_)) 
[17:43:47.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.361]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:47.361]                     .init = FALSE)
[17:43:47.361]                 }
[17:43:47.361]             }
[17:43:47.361]         }
[17:43:47.361]     })
[17:43:47.361]     if (TRUE) {
[17:43:47.361]         base::sink(type = "output", split = FALSE)
[17:43:47.361]         if (TRUE) {
[17:43:47.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.361]         }
[17:43:47.361]         else {
[17:43:47.361]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.361]         }
[17:43:47.361]         base::close(...future.stdout)
[17:43:47.361]         ...future.stdout <- NULL
[17:43:47.361]     }
[17:43:47.361]     ...future.result$conditions <- ...future.conditions
[17:43:47.361]     ...future.result$finished <- base::Sys.time()
[17:43:47.361]     ...future.result
[17:43:47.361] }
[17:43:47.363] assign_globals() ...
[17:43:47.363] List of 5
[17:43:47.363]  $ future.call.arguments    : list()
[17:43:47.363]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.363]  $ ...future.FUN            :function (x)  
[17:43:47.363]  $ ...future.elements_ii    :List of 2
[17:43:47.363]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:43:47.363]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:43:47.363]  $ ...future.seeds_ii       : NULL
[17:43:47.363]  $ ...future.globals.maxSize: num Inf
[17:43:47.363]  - attr(*, "resolved")= logi FALSE
[17:43:47.363]  - attr(*, "total_size")= num NA
[17:43:47.363]  - attr(*, "where")=List of 5
[17:43:47.363]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:47.363]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:47.363]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:47.363]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:47.363]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:47.363]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.363]  - attr(*, "already-done")= logi TRUE
[17:43:47.369] - copied ‘future.call.arguments’ to environment
[17:43:47.369] - copied ‘...future.FUN’ to environment
[17:43:47.369] - copied ‘...future.elements_ii’ to environment
[17:43:47.369] - copied ‘...future.seeds_ii’ to environment
[17:43:47.369] - copied ‘...future.globals.maxSize’ to environment
[17:43:47.369] assign_globals() ... done
[17:43:47.370] plan(): Setting new future strategy stack:
[17:43:47.370] List of future strategies:
[17:43:47.370] 1. sequential:
[17:43:47.370]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.370]    - tweaked: FALSE
[17:43:47.370]    - call: NULL
[17:43:47.370] plan(): nbrOfWorkers() = 1
[17:43:47.371] plan(): Setting new future strategy stack:
[17:43:47.371] List of future strategies:
[17:43:47.371] 1. sequential:
[17:43:47.371]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.371]    - tweaked: FALSE
[17:43:47.371]    - call: plan(strategy)
[17:43:47.371] plan(): nbrOfWorkers() = 1
[17:43:47.372] SequentialFuture started (and completed)
[17:43:47.372] - Launch lazy future ... done
[17:43:47.372] run() for ‘SequentialFuture’ ... done
[17:43:47.372] Created future:
[17:43:47.372] SequentialFuture:
[17:43:47.372] Label: ‘future_apply-1’
[17:43:47.372] Expression:
[17:43:47.372] {
[17:43:47.372]     do.call(function(...) {
[17:43:47.372]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.372]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.372]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.372]             on.exit(options(oopts), add = TRUE)
[17:43:47.372]         }
[17:43:47.372]         {
[17:43:47.372]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.372]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.372]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.372]             })
[17:43:47.372]         }
[17:43:47.372]     }, args = future.call.arguments)
[17:43:47.372] }
[17:43:47.372] Lazy evaluation: FALSE
[17:43:47.372] Asynchronous evaluation: FALSE
[17:43:47.372] Local evaluation: TRUE
[17:43:47.372] Environment: R_GlobalEnv
[17:43:47.372] Capture standard output: TRUE
[17:43:47.372] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:47.372] Globals: 5 objects totaling 1.10 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:47.372] Packages: <none>
[17:43:47.372] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:47.372] Resolved: TRUE
[17:43:47.372] Value: 224 bytes of class ‘list’
[17:43:47.372] Early signaling: FALSE
[17:43:47.372] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:47.372] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.373] Chunk #1 of 1 ... DONE
[17:43:47.373] Launching 1 futures (chunks) ... DONE
[17:43:47.373] Resolving 1 futures (chunks) ...
[17:43:47.373] resolve() on list ...
[17:43:47.373]  recursive: 0
[17:43:47.373]  length: 1
[17:43:47.374] 
[17:43:47.374] resolved() for ‘SequentialFuture’ ...
[17:43:47.374] - state: ‘finished’
[17:43:47.374] - run: TRUE
[17:43:47.374] - result: ‘FutureResult’
[17:43:47.374] resolved() for ‘SequentialFuture’ ... done
[17:43:47.374] Future #1
[17:43:47.374] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:47.374] - nx: 1
[17:43:47.374] - relay: TRUE
[17:43:47.374] - stdout: TRUE
[17:43:47.375] - signal: TRUE
[17:43:47.375] - resignal: FALSE
[17:43:47.375] - force: TRUE
[17:43:47.375] - relayed: [n=1] FALSE
[17:43:47.375] - queued futures: [n=1] FALSE
[17:43:47.375]  - until=1
[17:43:47.375]  - relaying element #1
[17:43:47.375] - relayed: [n=1] TRUE
[17:43:47.375] - queued futures: [n=1] TRUE
[17:43:47.375] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:47.376]  length: 0 (resolved future 1)
[17:43:47.376] Relaying remaining futures
[17:43:47.376] signalConditionsASAP(NULL, pos=0) ...
[17:43:47.376] - nx: 1
[17:43:47.376] - relay: TRUE
[17:43:47.376] - stdout: TRUE
[17:43:47.376] - signal: TRUE
[17:43:47.376] - resignal: FALSE
[17:43:47.376] - force: TRUE
[17:43:47.376] - relayed: [n=1] TRUE
[17:43:47.376] - queued futures: [n=1] TRUE
 - flush all
[17:43:47.377] - relayed: [n=1] TRUE
[17:43:47.377] - queued futures: [n=1] TRUE
[17:43:47.377] signalConditionsASAP(NULL, pos=0) ... done
[17:43:47.377] resolve() on list ... DONE
[17:43:47.377]  - Number of value chunks collected: 1
[17:43:47.377] Resolving 1 futures (chunks) ... DONE
[17:43:47.377] Reducing values from 1 chunks ...
[17:43:47.377]  - Number of values collected after concatenation: 2
[17:43:47.377]  - Number of values expected: 2
[17:43:47.377] Reducing values from 1 chunks ... DONE
[17:43:47.377] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[17:43:47.378] getGlobalsAndPackagesXApply() ...
[17:43:47.378]  - future.globals: TRUE
[17:43:47.378] getGlobalsAndPackages() ...
[17:43:47.378] Searching for globals...
[17:43:47.379] - globals found: [1] ‘FUN’
[17:43:47.379] Searching for globals ... DONE
[17:43:47.379] Resolving globals: FALSE
[17:43:47.379] The total size of the 1 globals is 848 bytes (848 bytes)
[17:43:47.380] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:43:47.380] - globals: [1] ‘FUN’
[17:43:47.380] 
[17:43:47.380] getGlobalsAndPackages() ... DONE
[17:43:47.380]  - globals found/used: [n=1] ‘FUN’
[17:43:47.380]  - needed namespaces: [n=0] 
[17:43:47.380] Finding globals ... DONE
[17:43:47.380]  - use_args: TRUE
[17:43:47.381]  - Getting '...' globals ...
[17:43:47.381] resolve() on list ...
[17:43:47.381]  recursive: 0
[17:43:47.381]  length: 1
[17:43:47.381]  elements: ‘...’
[17:43:47.381]  length: 0 (resolved future 1)
[17:43:47.381] resolve() on list ... DONE
[17:43:47.381]    - '...' content: [n=0] 
[17:43:47.381] List of 1
[17:43:47.381]  $ ...: list()
[17:43:47.381]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.381]  - attr(*, "where")=List of 1
[17:43:47.381]   ..$ ...:<environment: 0x55dfd4c4f458> 
[17:43:47.381]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.381]  - attr(*, "resolved")= logi TRUE
[17:43:47.381]  - attr(*, "total_size")= num NA
[17:43:47.384]  - Getting '...' globals ... DONE
[17:43:47.384] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:47.384] List of 2
[17:43:47.384]  $ ...future.FUN:function (x)  
[17:43:47.384]  $ ...          : list()
[17:43:47.384]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.384]  - attr(*, "where")=List of 2
[17:43:47.384]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:47.384]   ..$ ...          :<environment: 0x55dfd4c4f458> 
[17:43:47.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.384]  - attr(*, "resolved")= logi FALSE
[17:43:47.384]  - attr(*, "total_size")= num 848
[17:43:47.388] Packages to be attached in all futures: [n=0] 
[17:43:47.388] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.389] future_lapply() ...
[17:43:47.389] Number of chunks: 1
[17:43:47.389] getGlobalsAndPackagesXApply() ...
[17:43:47.389]  - future.globals: <name-value list> with names ‘list()’
[17:43:47.389]  - use_args: TRUE
[17:43:47.390] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:47.390] List of 2
[17:43:47.390]  $ ...          : list()
[17:43:47.390]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.390]  $ ...future.FUN:function (x)  
[17:43:47.390]  - attr(*, "where")=List of 2
[17:43:47.390]   ..$ ...          :<environment: 0x55dfd4c4f458> 
[17:43:47.390]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:47.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.390]  - attr(*, "resolved")= logi FALSE
[17:43:47.390]  - attr(*, "total_size")= num NA
[17:43:47.393] Packages to be attached in all futures: [n=0] 
[17:43:47.393] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.393] Number of futures (= number of chunks): 1
[17:43:47.393] Launching 1 futures (chunks) ...
[17:43:47.393] Chunk #1 of 1 ...
[17:43:47.393]  - seeds: <none>
[17:43:47.393]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.394] getGlobalsAndPackages() ...
[17:43:47.394] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.394] Resolving globals: FALSE
[17:43:47.394] Tweak future expression to call with '...' arguments ...
[17:43:47.394] {
[17:43:47.394]     do.call(function(...) {
[17:43:47.394]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.394]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.394]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.394]             on.exit(options(oopts), add = TRUE)
[17:43:47.394]         }
[17:43:47.394]         {
[17:43:47.394]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.394]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.394]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.394]             })
[17:43:47.394]         }
[17:43:47.394]     }, args = future.call.arguments)
[17:43:47.394] }
[17:43:47.394] Tweak future expression to call with '...' arguments ... DONE
[17:43:47.395] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.395] 
[17:43:47.395] getGlobalsAndPackages() ... DONE
[17:43:47.395] run() for ‘Future’ ...
[17:43:47.395] - state: ‘created’
[17:43:47.395] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:47.396] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.396] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:47.396]   - Field: ‘label’
[17:43:47.396]   - Field: ‘local’
[17:43:47.396]   - Field: ‘owner’
[17:43:47.396]   - Field: ‘envir’
[17:43:47.396]   - Field: ‘packages’
[17:43:47.396]   - Field: ‘gc’
[17:43:47.396]   - Field: ‘conditions’
[17:43:47.396]   - Field: ‘expr’
[17:43:47.397]   - Field: ‘uuid’
[17:43:47.397]   - Field: ‘seed’
[17:43:47.397]   - Field: ‘version’
[17:43:47.397]   - Field: ‘result’
[17:43:47.397]   - Field: ‘asynchronous’
[17:43:47.397]   - Field: ‘calls’
[17:43:47.397]   - Field: ‘globals’
[17:43:47.397]   - Field: ‘stdout’
[17:43:47.397]   - Field: ‘earlySignal’
[17:43:47.397]   - Field: ‘lazy’
[17:43:47.397]   - Field: ‘state’
[17:43:47.398] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:47.398] - Launch lazy future ...
[17:43:47.398] Packages needed by the future expression (n = 0): <none>
[17:43:47.398] Packages needed by future strategies (n = 0): <none>
[17:43:47.398] {
[17:43:47.398]     {
[17:43:47.398]         {
[17:43:47.398]             ...future.startTime <- base::Sys.time()
[17:43:47.398]             {
[17:43:47.398]                 {
[17:43:47.398]                   {
[17:43:47.398]                     base::local({
[17:43:47.398]                       has_future <- base::requireNamespace("future", 
[17:43:47.398]                         quietly = TRUE)
[17:43:47.398]                       if (has_future) {
[17:43:47.398]                         ns <- base::getNamespace("future")
[17:43:47.398]                         version <- ns[[".package"]][["version"]]
[17:43:47.398]                         if (is.null(version)) 
[17:43:47.398]                           version <- utils::packageVersion("future")
[17:43:47.398]                       }
[17:43:47.398]                       else {
[17:43:47.398]                         version <- NULL
[17:43:47.398]                       }
[17:43:47.398]                       if (!has_future || version < "1.8.0") {
[17:43:47.398]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.398]                           "", base::R.version$version.string), 
[17:43:47.398]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:47.398]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.398]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.398]                             "release", "version")], collapse = " "), 
[17:43:47.398]                           hostname = base::Sys.info()[["nodename"]])
[17:43:47.398]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.398]                           info)
[17:43:47.398]                         info <- base::paste(info, collapse = "; ")
[17:43:47.398]                         if (!has_future) {
[17:43:47.398]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.398]                             info)
[17:43:47.398]                         }
[17:43:47.398]                         else {
[17:43:47.398]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.398]                             info, version)
[17:43:47.398]                         }
[17:43:47.398]                         base::stop(msg)
[17:43:47.398]                       }
[17:43:47.398]                     })
[17:43:47.398]                   }
[17:43:47.398]                   ...future.strategy.old <- future::plan("list")
[17:43:47.398]                   options(future.plan = NULL)
[17:43:47.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.398]                 }
[17:43:47.398]                 ...future.workdir <- getwd()
[17:43:47.398]             }
[17:43:47.398]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.398]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.398]         }
[17:43:47.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.398]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:47.398]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.398]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.398]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.398]             base::names(...future.oldOptions))
[17:43:47.398]     }
[17:43:47.398]     if (FALSE) {
[17:43:47.398]     }
[17:43:47.398]     else {
[17:43:47.398]         if (TRUE) {
[17:43:47.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.398]                 open = "w")
[17:43:47.398]         }
[17:43:47.398]         else {
[17:43:47.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.398]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.398]         }
[17:43:47.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.398]             base::sink(type = "output", split = FALSE)
[17:43:47.398]             base::close(...future.stdout)
[17:43:47.398]         }, add = TRUE)
[17:43:47.398]     }
[17:43:47.398]     ...future.frame <- base::sys.nframe()
[17:43:47.398]     ...future.conditions <- base::list()
[17:43:47.398]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.398]     if (FALSE) {
[17:43:47.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.398]     }
[17:43:47.398]     ...future.result <- base::tryCatch({
[17:43:47.398]         base::withCallingHandlers({
[17:43:47.398]             ...future.value <- base::withVisible(base::local({
[17:43:47.398]                 do.call(function(...) {
[17:43:47.398]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.398]                   if (!identical(...future.globals.maxSize.org, 
[17:43:47.398]                     ...future.globals.maxSize)) {
[17:43:47.398]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.398]                     on.exit(options(oopts), add = TRUE)
[17:43:47.398]                   }
[17:43:47.398]                   {
[17:43:47.398]                     lapply(seq_along(...future.elements_ii), 
[17:43:47.398]                       FUN = function(jj) {
[17:43:47.398]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.398]                         ...future.FUN(...future.X_jj, ...)
[17:43:47.398]                       })
[17:43:47.398]                   }
[17:43:47.398]                 }, args = future.call.arguments)
[17:43:47.398]             }))
[17:43:47.398]             future::FutureResult(value = ...future.value$value, 
[17:43:47.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.398]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.398]                     ...future.globalenv.names))
[17:43:47.398]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.398]         }, condition = base::local({
[17:43:47.398]             c <- base::c
[17:43:47.398]             inherits <- base::inherits
[17:43:47.398]             invokeRestart <- base::invokeRestart
[17:43:47.398]             length <- base::length
[17:43:47.398]             list <- base::list
[17:43:47.398]             seq.int <- base::seq.int
[17:43:47.398]             signalCondition <- base::signalCondition
[17:43:47.398]             sys.calls <- base::sys.calls
[17:43:47.398]             `[[` <- base::`[[`
[17:43:47.398]             `+` <- base::`+`
[17:43:47.398]             `<<-` <- base::`<<-`
[17:43:47.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.398]                   3L)]
[17:43:47.398]             }
[17:43:47.398]             function(cond) {
[17:43:47.398]                 is_error <- inherits(cond, "error")
[17:43:47.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.398]                   NULL)
[17:43:47.398]                 if (is_error) {
[17:43:47.398]                   sessionInformation <- function() {
[17:43:47.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.398]                       search = base::search(), system = base::Sys.info())
[17:43:47.398]                   }
[17:43:47.398]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.398]                     cond$call), session = sessionInformation(), 
[17:43:47.398]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.398]                   signalCondition(cond)
[17:43:47.398]                 }
[17:43:47.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:47.398]                 "immediateCondition"))) {
[17:43:47.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:47.398]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.398]                   if (TRUE && !signal) {
[17:43:47.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.398]                     {
[17:43:47.398]                       inherits <- base::inherits
[17:43:47.398]                       invokeRestart <- base::invokeRestart
[17:43:47.398]                       is.null <- base::is.null
[17:43:47.398]                       muffled <- FALSE
[17:43:47.398]                       if (inherits(cond, "message")) {
[17:43:47.398]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.398]                         if (muffled) 
[17:43:47.398]                           invokeRestart("muffleMessage")
[17:43:47.398]                       }
[17:43:47.398]                       else if (inherits(cond, "warning")) {
[17:43:47.398]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.398]                         if (muffled) 
[17:43:47.398]                           invokeRestart("muffleWarning")
[17:43:47.398]                       }
[17:43:47.398]                       else if (inherits(cond, "condition")) {
[17:43:47.398]                         if (!is.null(pattern)) {
[17:43:47.398]                           computeRestarts <- base::computeRestarts
[17:43:47.398]                           grepl <- base::grepl
[17:43:47.398]                           restarts <- computeRestarts(cond)
[17:43:47.398]                           for (restart in restarts) {
[17:43:47.398]                             name <- restart$name
[17:43:47.398]                             if (is.null(name)) 
[17:43:47.398]                               next
[17:43:47.398]                             if (!grepl(pattern, name)) 
[17:43:47.398]                               next
[17:43:47.398]                             invokeRestart(restart)
[17:43:47.398]                             muffled <- TRUE
[17:43:47.398]                             break
[17:43:47.398]                           }
[17:43:47.398]                         }
[17:43:47.398]                       }
[17:43:47.398]                       invisible(muffled)
[17:43:47.398]                     }
[17:43:47.398]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.398]                   }
[17:43:47.398]                 }
[17:43:47.398]                 else {
[17:43:47.398]                   if (TRUE) {
[17:43:47.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.398]                     {
[17:43:47.398]                       inherits <- base::inherits
[17:43:47.398]                       invokeRestart <- base::invokeRestart
[17:43:47.398]                       is.null <- base::is.null
[17:43:47.398]                       muffled <- FALSE
[17:43:47.398]                       if (inherits(cond, "message")) {
[17:43:47.398]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.398]                         if (muffled) 
[17:43:47.398]                           invokeRestart("muffleMessage")
[17:43:47.398]                       }
[17:43:47.398]                       else if (inherits(cond, "warning")) {
[17:43:47.398]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.398]                         if (muffled) 
[17:43:47.398]                           invokeRestart("muffleWarning")
[17:43:47.398]                       }
[17:43:47.398]                       else if (inherits(cond, "condition")) {
[17:43:47.398]                         if (!is.null(pattern)) {
[17:43:47.398]                           computeRestarts <- base::computeRestarts
[17:43:47.398]                           grepl <- base::grepl
[17:43:47.398]                           restarts <- computeRestarts(cond)
[17:43:47.398]                           for (restart in restarts) {
[17:43:47.398]                             name <- restart$name
[17:43:47.398]                             if (is.null(name)) 
[17:43:47.398]                               next
[17:43:47.398]                             if (!grepl(pattern, name)) 
[17:43:47.398]                               next
[17:43:47.398]                             invokeRestart(restart)
[17:43:47.398]                             muffled <- TRUE
[17:43:47.398]                             break
[17:43:47.398]                           }
[17:43:47.398]                         }
[17:43:47.398]                       }
[17:43:47.398]                       invisible(muffled)
[17:43:47.398]                     }
[17:43:47.398]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.398]                   }
[17:43:47.398]                 }
[17:43:47.398]             }
[17:43:47.398]         }))
[17:43:47.398]     }, error = function(ex) {
[17:43:47.398]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.398]                 ...future.rng), started = ...future.startTime, 
[17:43:47.398]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.398]             version = "1.8"), class = "FutureResult")
[17:43:47.398]     }, finally = {
[17:43:47.398]         if (!identical(...future.workdir, getwd())) 
[17:43:47.398]             setwd(...future.workdir)
[17:43:47.398]         {
[17:43:47.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.398]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.398]             }
[17:43:47.398]             base::options(...future.oldOptions)
[17:43:47.398]             if (.Platform$OS.type == "windows") {
[17:43:47.398]                 old_names <- names(...future.oldEnvVars)
[17:43:47.398]                 envs <- base::Sys.getenv()
[17:43:47.398]                 names <- names(envs)
[17:43:47.398]                 common <- intersect(names, old_names)
[17:43:47.398]                 added <- setdiff(names, old_names)
[17:43:47.398]                 removed <- setdiff(old_names, names)
[17:43:47.398]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.398]                   envs[common]]
[17:43:47.398]                 NAMES <- toupper(changed)
[17:43:47.398]                 args <- list()
[17:43:47.398]                 for (kk in seq_along(NAMES)) {
[17:43:47.398]                   name <- changed[[kk]]
[17:43:47.398]                   NAME <- NAMES[[kk]]
[17:43:47.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.398]                     next
[17:43:47.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.398]                 }
[17:43:47.398]                 NAMES <- toupper(added)
[17:43:47.398]                 for (kk in seq_along(NAMES)) {
[17:43:47.398]                   name <- added[[kk]]
[17:43:47.398]                   NAME <- NAMES[[kk]]
[17:43:47.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.398]                     next
[17:43:47.398]                   args[[name]] <- ""
[17:43:47.398]                 }
[17:43:47.398]                 NAMES <- toupper(removed)
[17:43:47.398]                 for (kk in seq_along(NAMES)) {
[17:43:47.398]                   name <- removed[[kk]]
[17:43:47.398]                   NAME <- NAMES[[kk]]
[17:43:47.398]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.398]                     next
[17:43:47.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.398]                 }
[17:43:47.398]                 if (length(args) > 0) 
[17:43:47.398]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.398]             }
[17:43:47.398]             else {
[17:43:47.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.398]             }
[17:43:47.398]             {
[17:43:47.398]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.398]                   0L) {
[17:43:47.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.398]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.398]                   base::options(opts)
[17:43:47.398]                 }
[17:43:47.398]                 {
[17:43:47.398]                   {
[17:43:47.398]                     NULL
[17:43:47.398]                     RNGkind("Mersenne-Twister")
[17:43:47.398]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:47.398]                       inherits = FALSE)
[17:43:47.398]                   }
[17:43:47.398]                   options(future.plan = NULL)
[17:43:47.398]                   if (is.na(NA_character_)) 
[17:43:47.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.398]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:47.398]                     .init = FALSE)
[17:43:47.398]                 }
[17:43:47.398]             }
[17:43:47.398]         }
[17:43:47.398]     })
[17:43:47.398]     if (TRUE) {
[17:43:47.398]         base::sink(type = "output", split = FALSE)
[17:43:47.398]         if (TRUE) {
[17:43:47.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.398]         }
[17:43:47.398]         else {
[17:43:47.398]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.398]         }
[17:43:47.398]         base::close(...future.stdout)
[17:43:47.398]         ...future.stdout <- NULL
[17:43:47.398]     }
[17:43:47.398]     ...future.result$conditions <- ...future.conditions
[17:43:47.398]     ...future.result$finished <- base::Sys.time()
[17:43:47.398]     ...future.result
[17:43:47.398] }
[17:43:47.400] assign_globals() ...
[17:43:47.400] List of 5
[17:43:47.400]  $ future.call.arguments    : list()
[17:43:47.400]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.400]  $ ...future.FUN            :function (x)  
[17:43:47.400]  $ ...future.elements_ii    :List of 6
[17:43:47.400]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:43:47.400]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:43:47.400]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:43:47.400]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:43:47.400]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:43:47.400]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:43:47.400]  $ ...future.seeds_ii       : NULL
[17:43:47.400]  $ ...future.globals.maxSize: num Inf
[17:43:47.400]  - attr(*, "resolved")= logi FALSE
[17:43:47.400]  - attr(*, "total_size")= num NA
[17:43:47.400]  - attr(*, "where")=List of 5
[17:43:47.400]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:47.400]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:47.400]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:47.400]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:47.400]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:47.400]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.400]  - attr(*, "already-done")= logi TRUE
[17:43:47.406] - copied ‘future.call.arguments’ to environment
[17:43:47.406] - copied ‘...future.FUN’ to environment
[17:43:47.406] - copied ‘...future.elements_ii’ to environment
[17:43:47.406] - copied ‘...future.seeds_ii’ to environment
[17:43:47.407] - copied ‘...future.globals.maxSize’ to environment
[17:43:47.407] assign_globals() ... done
[17:43:47.407] plan(): Setting new future strategy stack:
[17:43:47.407] List of future strategies:
[17:43:47.407] 1. sequential:
[17:43:47.407]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.407]    - tweaked: FALSE
[17:43:47.407]    - call: NULL
[17:43:47.407] plan(): nbrOfWorkers() = 1
[17:43:47.408] plan(): Setting new future strategy stack:
[17:43:47.408] List of future strategies:
[17:43:47.408] 1. sequential:
[17:43:47.408]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.408]    - tweaked: FALSE
[17:43:47.408]    - call: plan(strategy)
[17:43:47.409] plan(): nbrOfWorkers() = 1
[17:43:47.409] SequentialFuture started (and completed)
[17:43:47.409] - Launch lazy future ... done
[17:43:47.409] run() for ‘SequentialFuture’ ... done
[17:43:47.409] Created future:
[17:43:47.409] SequentialFuture:
[17:43:47.409] Label: ‘future_apply-1’
[17:43:47.409] Expression:
[17:43:47.409] {
[17:43:47.409]     do.call(function(...) {
[17:43:47.409]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.409]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.409]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.409]             on.exit(options(oopts), add = TRUE)
[17:43:47.409]         }
[17:43:47.409]         {
[17:43:47.409]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.409]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.409]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.409]             })
[17:43:47.409]         }
[17:43:47.409]     }, args = future.call.arguments)
[17:43:47.409] }
[17:43:47.409] Lazy evaluation: FALSE
[17:43:47.409] Asynchronous evaluation: FALSE
[17:43:47.409] Local evaluation: TRUE
[17:43:47.409] Environment: R_GlobalEnv
[17:43:47.409] Capture standard output: TRUE
[17:43:47.409] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:47.409] Globals: 5 objects totaling 1.54 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 672 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:47.409] Packages: <none>
[17:43:47.409] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:47.409] Resolved: TRUE
[17:43:47.409] Value: 672 bytes of class ‘list’
[17:43:47.409] Early signaling: FALSE
[17:43:47.409] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:47.409] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.410] Chunk #1 of 1 ... DONE
[17:43:47.410] Launching 1 futures (chunks) ... DONE
[17:43:47.411] Resolving 1 futures (chunks) ...
[17:43:47.411] resolve() on list ...
[17:43:47.411]  recursive: 0
[17:43:47.411]  length: 1
[17:43:47.411] 
[17:43:47.411] resolved() for ‘SequentialFuture’ ...
[17:43:47.413] - state: ‘finished’
[17:43:47.413] - run: TRUE
[17:43:47.413] - result: ‘FutureResult’
[17:43:47.413] resolved() for ‘SequentialFuture’ ... done
[17:43:47.413] Future #1
[17:43:47.413] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:47.413] - nx: 1
[17:43:47.414] - relay: TRUE
[17:43:47.414] - stdout: TRUE
[17:43:47.414] - signal: TRUE
[17:43:47.414] - resignal: FALSE
[17:43:47.414] - force: TRUE
[17:43:47.414] - relayed: [n=1] FALSE
[17:43:47.414] - queued futures: [n=1] FALSE
[17:43:47.414]  - until=1
[17:43:47.414]  - relaying element #1
[17:43:47.414] - relayed: [n=1] TRUE
[17:43:47.415] - queued futures: [n=1] TRUE
[17:43:47.415] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:47.415]  length: 0 (resolved future 1)
[17:43:47.415] Relaying remaining futures
[17:43:47.415] signalConditionsASAP(NULL, pos=0) ...
[17:43:47.415] - nx: 1
[17:43:47.415] - relay: TRUE
[17:43:47.415] - stdout: TRUE
[17:43:47.415] - signal: TRUE
[17:43:47.415] - resignal: FALSE
[17:43:47.415] - force: TRUE
[17:43:47.416] - relayed: [n=1] TRUE
[17:43:47.416] - queued futures: [n=1] TRUE
 - flush all
[17:43:47.416] - relayed: [n=1] TRUE
[17:43:47.416] - queued futures: [n=1] TRUE
[17:43:47.416] signalConditionsASAP(NULL, pos=0) ... done
[17:43:47.416] resolve() on list ... DONE
[17:43:47.416]  - Number of value chunks collected: 1
[17:43:47.416] Resolving 1 futures (chunks) ... DONE
[17:43:47.416] Reducing values from 1 chunks ...
[17:43:47.416]  - Number of values collected after concatenation: 6
[17:43:47.417]  - Number of values expected: 6
[17:43:47.417] Reducing values from 1 chunks ... DONE
[17:43:47.417] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[17:43:47.417] getGlobalsAndPackagesXApply() ...
[17:43:47.417]  - future.globals: TRUE
[17:43:47.417] getGlobalsAndPackages() ...
[17:43:47.418] Searching for globals...
[17:43:47.419] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[17:43:47.419] Searching for globals ... DONE
[17:43:47.419] Resolving globals: FALSE
[17:43:47.420] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[17:43:47.420] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[17:43:47.420] - globals: [1] ‘FUN’
[17:43:47.420] 
[17:43:47.420] getGlobalsAndPackages() ... DONE
[17:43:47.420]  - globals found/used: [n=1] ‘FUN’
[17:43:47.420]  - needed namespaces: [n=0] 
[17:43:47.421] Finding globals ... DONE
[17:43:47.421]  - use_args: TRUE
[17:43:47.421]  - Getting '...' globals ...
[17:43:47.421] resolve() on list ...
[17:43:47.421]  recursive: 0
[17:43:47.421]  length: 1
[17:43:47.421]  elements: ‘...’
[17:43:47.421]  length: 0 (resolved future 1)
[17:43:47.422] resolve() on list ... DONE
[17:43:47.422]    - '...' content: [n=0] 
[17:43:47.422] List of 1
[17:43:47.422]  $ ...: list()
[17:43:47.422]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.422]  - attr(*, "where")=List of 1
[17:43:47.422]   ..$ ...:<environment: 0x55dfd2925040> 
[17:43:47.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.422]  - attr(*, "resolved")= logi TRUE
[17:43:47.422]  - attr(*, "total_size")= num NA
[17:43:47.424]  - Getting '...' globals ... DONE
[17:43:47.425] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:47.425] List of 2
[17:43:47.425]  $ ...future.FUN:function (x)  
[17:43:47.425]  $ ...          : list()
[17:43:47.425]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.425]  - attr(*, "where")=List of 2
[17:43:47.425]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:47.425]   ..$ ...          :<environment: 0x55dfd2925040> 
[17:43:47.425]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.425]  - attr(*, "resolved")= logi FALSE
[17:43:47.425]  - attr(*, "total_size")= num 1768
[17:43:47.427] Packages to be attached in all futures: [n=0] 
[17:43:47.427] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.428] future_lapply() ...
[17:43:47.428] Number of chunks: 1
[17:43:47.428] getGlobalsAndPackagesXApply() ...
[17:43:47.428]  - future.globals: <name-value list> with names ‘list()’
[17:43:47.429]  - use_args: TRUE
[17:43:47.429] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:47.429] List of 2
[17:43:47.429]  $ ...          : list()
[17:43:47.429]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.429]  $ ...future.FUN:function (x)  
[17:43:47.429]  - attr(*, "where")=List of 2
[17:43:47.429]   ..$ ...          :<environment: 0x55dfd2925040> 
[17:43:47.429]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:43:47.429]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.429]  - attr(*, "resolved")= logi FALSE
[17:43:47.429]  - attr(*, "total_size")= num NA
[17:43:47.431] Packages to be attached in all futures: [n=0] 
[17:43:47.432] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.432] Number of futures (= number of chunks): 1
[17:43:47.432] Launching 1 futures (chunks) ...
[17:43:47.432] Chunk #1 of 1 ...
[17:43:47.432]  - seeds: <none>
[17:43:47.432]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.432] getGlobalsAndPackages() ...
[17:43:47.432] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.433] Resolving globals: FALSE
[17:43:47.433] Tweak future expression to call with '...' arguments ...
[17:43:47.433] {
[17:43:47.433]     do.call(function(...) {
[17:43:47.433]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.433]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.433]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.433]             on.exit(options(oopts), add = TRUE)
[17:43:47.433]         }
[17:43:47.433]         {
[17:43:47.433]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.433]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.433]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.433]             })
[17:43:47.433]         }
[17:43:47.433]     }, args = future.call.arguments)
[17:43:47.433] }
[17:43:47.433] Tweak future expression to call with '...' arguments ... DONE
[17:43:47.433] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.433] 
[17:43:47.434] getGlobalsAndPackages() ... DONE
[17:43:47.434] run() for ‘Future’ ...
[17:43:47.434] - state: ‘created’
[17:43:47.434] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:47.434] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.434] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:47.435]   - Field: ‘label’
[17:43:47.435]   - Field: ‘local’
[17:43:47.435]   - Field: ‘owner’
[17:43:47.435]   - Field: ‘envir’
[17:43:47.435]   - Field: ‘packages’
[17:43:47.435]   - Field: ‘gc’
[17:43:47.437]   - Field: ‘conditions’
[17:43:47.437]   - Field: ‘expr’
[17:43:47.437]   - Field: ‘uuid’
[17:43:47.437]   - Field: ‘seed’
[17:43:47.437]   - Field: ‘version’
[17:43:47.438]   - Field: ‘result’
[17:43:47.438]   - Field: ‘asynchronous’
[17:43:47.438]   - Field: ‘calls’
[17:43:47.438]   - Field: ‘globals’
[17:43:47.438]   - Field: ‘stdout’
[17:43:47.438]   - Field: ‘earlySignal’
[17:43:47.438]   - Field: ‘lazy’
[17:43:47.438]   - Field: ‘state’
[17:43:47.438] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:47.438] - Launch lazy future ...
[17:43:47.439] Packages needed by the future expression (n = 0): <none>
[17:43:47.439] Packages needed by future strategies (n = 0): <none>
[17:43:47.439] {
[17:43:47.439]     {
[17:43:47.439]         {
[17:43:47.439]             ...future.startTime <- base::Sys.time()
[17:43:47.439]             {
[17:43:47.439]                 {
[17:43:47.439]                   {
[17:43:47.439]                     base::local({
[17:43:47.439]                       has_future <- base::requireNamespace("future", 
[17:43:47.439]                         quietly = TRUE)
[17:43:47.439]                       if (has_future) {
[17:43:47.439]                         ns <- base::getNamespace("future")
[17:43:47.439]                         version <- ns[[".package"]][["version"]]
[17:43:47.439]                         if (is.null(version)) 
[17:43:47.439]                           version <- utils::packageVersion("future")
[17:43:47.439]                       }
[17:43:47.439]                       else {
[17:43:47.439]                         version <- NULL
[17:43:47.439]                       }
[17:43:47.439]                       if (!has_future || version < "1.8.0") {
[17:43:47.439]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.439]                           "", base::R.version$version.string), 
[17:43:47.439]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:47.439]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.439]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.439]                             "release", "version")], collapse = " "), 
[17:43:47.439]                           hostname = base::Sys.info()[["nodename"]])
[17:43:47.439]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.439]                           info)
[17:43:47.439]                         info <- base::paste(info, collapse = "; ")
[17:43:47.439]                         if (!has_future) {
[17:43:47.439]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.439]                             info)
[17:43:47.439]                         }
[17:43:47.439]                         else {
[17:43:47.439]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.439]                             info, version)
[17:43:47.439]                         }
[17:43:47.439]                         base::stop(msg)
[17:43:47.439]                       }
[17:43:47.439]                     })
[17:43:47.439]                   }
[17:43:47.439]                   ...future.strategy.old <- future::plan("list")
[17:43:47.439]                   options(future.plan = NULL)
[17:43:47.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.439]                 }
[17:43:47.439]                 ...future.workdir <- getwd()
[17:43:47.439]             }
[17:43:47.439]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.439]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.439]         }
[17:43:47.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.439]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:47.439]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.439]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.439]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.439]             base::names(...future.oldOptions))
[17:43:47.439]     }
[17:43:47.439]     if (FALSE) {
[17:43:47.439]     }
[17:43:47.439]     else {
[17:43:47.439]         if (TRUE) {
[17:43:47.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.439]                 open = "w")
[17:43:47.439]         }
[17:43:47.439]         else {
[17:43:47.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.439]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.439]         }
[17:43:47.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.439]             base::sink(type = "output", split = FALSE)
[17:43:47.439]             base::close(...future.stdout)
[17:43:47.439]         }, add = TRUE)
[17:43:47.439]     }
[17:43:47.439]     ...future.frame <- base::sys.nframe()
[17:43:47.439]     ...future.conditions <- base::list()
[17:43:47.439]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.439]     if (FALSE) {
[17:43:47.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.439]     }
[17:43:47.439]     ...future.result <- base::tryCatch({
[17:43:47.439]         base::withCallingHandlers({
[17:43:47.439]             ...future.value <- base::withVisible(base::local({
[17:43:47.439]                 do.call(function(...) {
[17:43:47.439]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.439]                   if (!identical(...future.globals.maxSize.org, 
[17:43:47.439]                     ...future.globals.maxSize)) {
[17:43:47.439]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.439]                     on.exit(options(oopts), add = TRUE)
[17:43:47.439]                   }
[17:43:47.439]                   {
[17:43:47.439]                     lapply(seq_along(...future.elements_ii), 
[17:43:47.439]                       FUN = function(jj) {
[17:43:47.439]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.439]                         ...future.FUN(...future.X_jj, ...)
[17:43:47.439]                       })
[17:43:47.439]                   }
[17:43:47.439]                 }, args = future.call.arguments)
[17:43:47.439]             }))
[17:43:47.439]             future::FutureResult(value = ...future.value$value, 
[17:43:47.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.439]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.439]                     ...future.globalenv.names))
[17:43:47.439]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.439]         }, condition = base::local({
[17:43:47.439]             c <- base::c
[17:43:47.439]             inherits <- base::inherits
[17:43:47.439]             invokeRestart <- base::invokeRestart
[17:43:47.439]             length <- base::length
[17:43:47.439]             list <- base::list
[17:43:47.439]             seq.int <- base::seq.int
[17:43:47.439]             signalCondition <- base::signalCondition
[17:43:47.439]             sys.calls <- base::sys.calls
[17:43:47.439]             `[[` <- base::`[[`
[17:43:47.439]             `+` <- base::`+`
[17:43:47.439]             `<<-` <- base::`<<-`
[17:43:47.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.439]                   3L)]
[17:43:47.439]             }
[17:43:47.439]             function(cond) {
[17:43:47.439]                 is_error <- inherits(cond, "error")
[17:43:47.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.439]                   NULL)
[17:43:47.439]                 if (is_error) {
[17:43:47.439]                   sessionInformation <- function() {
[17:43:47.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.439]                       search = base::search(), system = base::Sys.info())
[17:43:47.439]                   }
[17:43:47.439]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.439]                     cond$call), session = sessionInformation(), 
[17:43:47.439]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.439]                   signalCondition(cond)
[17:43:47.439]                 }
[17:43:47.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:47.439]                 "immediateCondition"))) {
[17:43:47.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:47.439]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.439]                   if (TRUE && !signal) {
[17:43:47.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.439]                     {
[17:43:47.439]                       inherits <- base::inherits
[17:43:47.439]                       invokeRestart <- base::invokeRestart
[17:43:47.439]                       is.null <- base::is.null
[17:43:47.439]                       muffled <- FALSE
[17:43:47.439]                       if (inherits(cond, "message")) {
[17:43:47.439]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.439]                         if (muffled) 
[17:43:47.439]                           invokeRestart("muffleMessage")
[17:43:47.439]                       }
[17:43:47.439]                       else if (inherits(cond, "warning")) {
[17:43:47.439]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.439]                         if (muffled) 
[17:43:47.439]                           invokeRestart("muffleWarning")
[17:43:47.439]                       }
[17:43:47.439]                       else if (inherits(cond, "condition")) {
[17:43:47.439]                         if (!is.null(pattern)) {
[17:43:47.439]                           computeRestarts <- base::computeRestarts
[17:43:47.439]                           grepl <- base::grepl
[17:43:47.439]                           restarts <- computeRestarts(cond)
[17:43:47.439]                           for (restart in restarts) {
[17:43:47.439]                             name <- restart$name
[17:43:47.439]                             if (is.null(name)) 
[17:43:47.439]                               next
[17:43:47.439]                             if (!grepl(pattern, name)) 
[17:43:47.439]                               next
[17:43:47.439]                             invokeRestart(restart)
[17:43:47.439]                             muffled <- TRUE
[17:43:47.439]                             break
[17:43:47.439]                           }
[17:43:47.439]                         }
[17:43:47.439]                       }
[17:43:47.439]                       invisible(muffled)
[17:43:47.439]                     }
[17:43:47.439]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.439]                   }
[17:43:47.439]                 }
[17:43:47.439]                 else {
[17:43:47.439]                   if (TRUE) {
[17:43:47.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.439]                     {
[17:43:47.439]                       inherits <- base::inherits
[17:43:47.439]                       invokeRestart <- base::invokeRestart
[17:43:47.439]                       is.null <- base::is.null
[17:43:47.439]                       muffled <- FALSE
[17:43:47.439]                       if (inherits(cond, "message")) {
[17:43:47.439]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.439]                         if (muffled) 
[17:43:47.439]                           invokeRestart("muffleMessage")
[17:43:47.439]                       }
[17:43:47.439]                       else if (inherits(cond, "warning")) {
[17:43:47.439]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.439]                         if (muffled) 
[17:43:47.439]                           invokeRestart("muffleWarning")
[17:43:47.439]                       }
[17:43:47.439]                       else if (inherits(cond, "condition")) {
[17:43:47.439]                         if (!is.null(pattern)) {
[17:43:47.439]                           computeRestarts <- base::computeRestarts
[17:43:47.439]                           grepl <- base::grepl
[17:43:47.439]                           restarts <- computeRestarts(cond)
[17:43:47.439]                           for (restart in restarts) {
[17:43:47.439]                             name <- restart$name
[17:43:47.439]                             if (is.null(name)) 
[17:43:47.439]                               next
[17:43:47.439]                             if (!grepl(pattern, name)) 
[17:43:47.439]                               next
[17:43:47.439]                             invokeRestart(restart)
[17:43:47.439]                             muffled <- TRUE
[17:43:47.439]                             break
[17:43:47.439]                           }
[17:43:47.439]                         }
[17:43:47.439]                       }
[17:43:47.439]                       invisible(muffled)
[17:43:47.439]                     }
[17:43:47.439]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.439]                   }
[17:43:47.439]                 }
[17:43:47.439]             }
[17:43:47.439]         }))
[17:43:47.439]     }, error = function(ex) {
[17:43:47.439]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.439]                 ...future.rng), started = ...future.startTime, 
[17:43:47.439]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.439]             version = "1.8"), class = "FutureResult")
[17:43:47.439]     }, finally = {
[17:43:47.439]         if (!identical(...future.workdir, getwd())) 
[17:43:47.439]             setwd(...future.workdir)
[17:43:47.439]         {
[17:43:47.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.439]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.439]             }
[17:43:47.439]             base::options(...future.oldOptions)
[17:43:47.439]             if (.Platform$OS.type == "windows") {
[17:43:47.439]                 old_names <- names(...future.oldEnvVars)
[17:43:47.439]                 envs <- base::Sys.getenv()
[17:43:47.439]                 names <- names(envs)
[17:43:47.439]                 common <- intersect(names, old_names)
[17:43:47.439]                 added <- setdiff(names, old_names)
[17:43:47.439]                 removed <- setdiff(old_names, names)
[17:43:47.439]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.439]                   envs[common]]
[17:43:47.439]                 NAMES <- toupper(changed)
[17:43:47.439]                 args <- list()
[17:43:47.439]                 for (kk in seq_along(NAMES)) {
[17:43:47.439]                   name <- changed[[kk]]
[17:43:47.439]                   NAME <- NAMES[[kk]]
[17:43:47.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.439]                     next
[17:43:47.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.439]                 }
[17:43:47.439]                 NAMES <- toupper(added)
[17:43:47.439]                 for (kk in seq_along(NAMES)) {
[17:43:47.439]                   name <- added[[kk]]
[17:43:47.439]                   NAME <- NAMES[[kk]]
[17:43:47.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.439]                     next
[17:43:47.439]                   args[[name]] <- ""
[17:43:47.439]                 }
[17:43:47.439]                 NAMES <- toupper(removed)
[17:43:47.439]                 for (kk in seq_along(NAMES)) {
[17:43:47.439]                   name <- removed[[kk]]
[17:43:47.439]                   NAME <- NAMES[[kk]]
[17:43:47.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.439]                     next
[17:43:47.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.439]                 }
[17:43:47.439]                 if (length(args) > 0) 
[17:43:47.439]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.439]             }
[17:43:47.439]             else {
[17:43:47.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.439]             }
[17:43:47.439]             {
[17:43:47.439]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.439]                   0L) {
[17:43:47.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.439]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.439]                   base::options(opts)
[17:43:47.439]                 }
[17:43:47.439]                 {
[17:43:47.439]                   {
[17:43:47.439]                     NULL
[17:43:47.439]                     RNGkind("Mersenne-Twister")
[17:43:47.439]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:47.439]                       inherits = FALSE)
[17:43:47.439]                   }
[17:43:47.439]                   options(future.plan = NULL)
[17:43:47.439]                   if (is.na(NA_character_)) 
[17:43:47.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.439]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:47.439]                     .init = FALSE)
[17:43:47.439]                 }
[17:43:47.439]             }
[17:43:47.439]         }
[17:43:47.439]     })
[17:43:47.439]     if (TRUE) {
[17:43:47.439]         base::sink(type = "output", split = FALSE)
[17:43:47.439]         if (TRUE) {
[17:43:47.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.439]         }
[17:43:47.439]         else {
[17:43:47.439]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.439]         }
[17:43:47.439]         base::close(...future.stdout)
[17:43:47.439]         ...future.stdout <- NULL
[17:43:47.439]     }
[17:43:47.439]     ...future.result$conditions <- ...future.conditions
[17:43:47.439]     ...future.result$finished <- base::Sys.time()
[17:43:47.439]     ...future.result
[17:43:47.439] }
[17:43:47.441] assign_globals() ...
[17:43:47.441] List of 5
[17:43:47.441]  $ future.call.arguments    : list()
[17:43:47.441]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.441]  $ ...future.FUN            :function (x)  
[17:43:47.441]  $ ...future.elements_ii    :List of 6
[17:43:47.441]   ..$ : int [1:4] 1 7 13 19
[17:43:47.441]   ..$ : int [1:4] 2 8 14 20
[17:43:47.441]   ..$ : int [1:4] 3 9 15 21
[17:43:47.441]   ..$ : int [1:4] 4 10 16 22
[17:43:47.441]   ..$ : int [1:4] 5 11 17 23
[17:43:47.441]   ..$ : int [1:4] 6 12 18 24
[17:43:47.441]  $ ...future.seeds_ii       : NULL
[17:43:47.441]  $ ...future.globals.maxSize: num Inf
[17:43:47.441]  - attr(*, "resolved")= logi FALSE
[17:43:47.441]  - attr(*, "total_size")= num NA
[17:43:47.441]  - attr(*, "where")=List of 5
[17:43:47.441]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:47.441]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:47.441]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:47.441]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:47.441]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:47.441]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.441]  - attr(*, "already-done")= logi TRUE
[17:43:47.447] - copied ‘future.call.arguments’ to environment
[17:43:47.448] - reassign environment for ‘...future.FUN’
[17:43:47.448] - copied ‘...future.FUN’ to environment
[17:43:47.448] - copied ‘...future.elements_ii’ to environment
[17:43:47.448] - copied ‘...future.seeds_ii’ to environment
[17:43:47.448] - copied ‘...future.globals.maxSize’ to environment
[17:43:47.448] assign_globals() ... done
[17:43:47.448] plan(): Setting new future strategy stack:
[17:43:47.448] List of future strategies:
[17:43:47.448] 1. sequential:
[17:43:47.448]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.448]    - tweaked: FALSE
[17:43:47.448]    - call: NULL
[17:43:47.449] plan(): nbrOfWorkers() = 1
[17:43:47.450] plan(): Setting new future strategy stack:
[17:43:47.450] List of future strategies:
[17:43:47.450] 1. sequential:
[17:43:47.450]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.450]    - tweaked: FALSE
[17:43:47.450]    - call: plan(strategy)
[17:43:47.450] plan(): nbrOfWorkers() = 1
[17:43:47.450] SequentialFuture started (and completed)
[17:43:47.450] - Launch lazy future ... done
[17:43:47.451] run() for ‘SequentialFuture’ ... done
[17:43:47.451] Created future:
[17:43:47.451] SequentialFuture:
[17:43:47.451] Label: ‘future_apply-1’
[17:43:47.451] Expression:
[17:43:47.451] {
[17:43:47.451]     do.call(function(...) {
[17:43:47.451]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.451]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.451]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.451]             on.exit(options(oopts), add = TRUE)
[17:43:47.451]         }
[17:43:47.451]         {
[17:43:47.451]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.451]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.451]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.451]             })
[17:43:47.451]         }
[17:43:47.451]     }, args = future.call.arguments)
[17:43:47.451] }
[17:43:47.451] Lazy evaluation: FALSE
[17:43:47.451] Asynchronous evaluation: FALSE
[17:43:47.451] Local evaluation: TRUE
[17:43:47.451] Environment: R_GlobalEnv
[17:43:47.451] Capture standard output: TRUE
[17:43:47.451] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:47.451] Globals: 5 objects totaling 2.16 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 384 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:47.451] Packages: <none>
[17:43:47.451] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:47.451] Resolved: TRUE
[17:43:47.451] Value: 1.03 KiB of class ‘list’
[17:43:47.451] Early signaling: FALSE
[17:43:47.451] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:47.451] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.452] Chunk #1 of 1 ... DONE
[17:43:47.452] Launching 1 futures (chunks) ... DONE
[17:43:47.452] Resolving 1 futures (chunks) ...
[17:43:47.452] resolve() on list ...
[17:43:47.452]  recursive: 0
[17:43:47.452]  length: 1
[17:43:47.452] 
[17:43:47.453] resolved() for ‘SequentialFuture’ ...
[17:43:47.453] - state: ‘finished’
[17:43:47.453] - run: TRUE
[17:43:47.453] - result: ‘FutureResult’
[17:43:47.453] resolved() for ‘SequentialFuture’ ... done
[17:43:47.453] Future #1
[17:43:47.453] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:47.453] - nx: 1
[17:43:47.453] - relay: TRUE
[17:43:47.453] - stdout: TRUE
[17:43:47.454] - signal: TRUE
[17:43:47.454] - resignal: FALSE
[17:43:47.454] - force: TRUE
[17:43:47.454] - relayed: [n=1] FALSE
[17:43:47.454] - queued futures: [n=1] FALSE
[17:43:47.454]  - until=1
[17:43:47.454]  - relaying element #1
[17:43:47.454] - relayed: [n=1] TRUE
[17:43:47.454] - queued futures: [n=1] TRUE
[17:43:47.454] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:47.455]  length: 0 (resolved future 1)
[17:43:47.455] Relaying remaining futures
[17:43:47.455] signalConditionsASAP(NULL, pos=0) ...
[17:43:47.455] - nx: 1
[17:43:47.455] - relay: TRUE
[17:43:47.455] - stdout: TRUE
[17:43:47.455] - signal: TRUE
[17:43:47.455] - resignal: FALSE
[17:43:47.455] - force: TRUE
[17:43:47.455] - relayed: [n=1] TRUE
[17:43:47.455] - queued futures: [n=1] TRUE
 - flush all
[17:43:47.456] - relayed: [n=1] TRUE
[17:43:47.456] - queued futures: [n=1] TRUE
[17:43:47.456] signalConditionsASAP(NULL, pos=0) ... done
[17:43:47.456] resolve() on list ... DONE
[17:43:47.456]  - Number of value chunks collected: 1
[17:43:47.456] Resolving 1 futures (chunks) ... DONE
[17:43:47.456] Reducing values from 1 chunks ...
[17:43:47.456]  - Number of values collected after concatenation: 6
[17:43:47.456]  - Number of values expected: 6
[17:43:47.456] Reducing values from 1 chunks ... DONE
[17:43:47.457] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[17:43:47.457] getGlobalsAndPackagesXApply() ...
[17:43:47.457]  - future.globals: TRUE
[17:43:47.457] getGlobalsAndPackages() ...
[17:43:47.457] Searching for globals...
[17:43:47.458] - globals found: [1] ‘FUN’
[17:43:47.458] Searching for globals ... DONE
[17:43:47.458] Resolving globals: FALSE
[17:43:47.459] The total size of the 1 globals is 848 bytes (848 bytes)
[17:43:47.459] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:43:47.459] - globals: [1] ‘FUN’
[17:43:47.459] 
[17:43:47.459] getGlobalsAndPackages() ... DONE
[17:43:47.459]  - globals found/used: [n=1] ‘FUN’
[17:43:47.459]  - needed namespaces: [n=0] 
[17:43:47.460] Finding globals ... DONE
[17:43:47.460]  - use_args: TRUE
[17:43:47.460]  - Getting '...' globals ...
[17:43:47.460] resolve() on list ...
[17:43:47.460]  recursive: 0
[17:43:47.460]  length: 1
[17:43:47.460]  elements: ‘...’
[17:43:47.460]  length: 0 (resolved future 1)
[17:43:47.461] resolve() on list ... DONE
[17:43:47.462]    - '...' content: [n=0] 
[17:43:47.462] List of 1
[17:43:47.462]  $ ...: list()
[17:43:47.462]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.462]  - attr(*, "where")=List of 1
[17:43:47.462]   ..$ ...:<environment: 0x55dfd4f948b8> 
[17:43:47.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.462]  - attr(*, "resolved")= logi TRUE
[17:43:47.462]  - attr(*, "total_size")= num NA
[17:43:47.465]  - Getting '...' globals ... DONE
[17:43:47.465] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:47.465] List of 2
[17:43:47.465]  $ ...future.FUN:function (x)  
[17:43:47.465]  $ ...          : list()
[17:43:47.465]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.465]  - attr(*, "where")=List of 2
[17:43:47.465]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:47.465]   ..$ ...          :<environment: 0x55dfd4f948b8> 
[17:43:47.465]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.465]  - attr(*, "resolved")= logi FALSE
[17:43:47.465]  - attr(*, "total_size")= num 848
[17:43:47.468] Packages to be attached in all futures: [n=0] 
[17:43:47.468] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.468] future_lapply() ...
[17:43:47.469] Number of chunks: 1
[17:43:47.469] getGlobalsAndPackagesXApply() ...
[17:43:47.469]  - future.globals: <name-value list> with names ‘list()’
[17:43:47.469]  - use_args: TRUE
[17:43:47.469] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:47.469] List of 2
[17:43:47.469]  $ ...          : list()
[17:43:47.469]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.469]  $ ...future.FUN:function (x)  
[17:43:47.469]  - attr(*, "where")=List of 2
[17:43:47.469]   ..$ ...          :<environment: 0x55dfd4f948b8> 
[17:43:47.469]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:47.469]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.469]  - attr(*, "resolved")= logi FALSE
[17:43:47.469]  - attr(*, "total_size")= num NA
[17:43:47.472] Packages to be attached in all futures: [n=0] 
[17:43:47.472] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.473] Number of futures (= number of chunks): 1
[17:43:47.473] Launching 1 futures (chunks) ...
[17:43:47.473] Chunk #1 of 1 ...
[17:43:47.473]  - seeds: <none>
[17:43:47.473]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.473] getGlobalsAndPackages() ...
[17:43:47.473] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.473] Resolving globals: FALSE
[17:43:47.474] Tweak future expression to call with '...' arguments ...
[17:43:47.474] {
[17:43:47.474]     do.call(function(...) {
[17:43:47.474]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.474]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.474]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.474]             on.exit(options(oopts), add = TRUE)
[17:43:47.474]         }
[17:43:47.474]         {
[17:43:47.474]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.474]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.474]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.474]             })
[17:43:47.474]         }
[17:43:47.474]     }, args = future.call.arguments)
[17:43:47.474] }
[17:43:47.474] Tweak future expression to call with '...' arguments ... DONE
[17:43:47.474] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.474] 
[17:43:47.474] getGlobalsAndPackages() ... DONE
[17:43:47.475] run() for ‘Future’ ...
[17:43:47.475] - state: ‘created’
[17:43:47.475] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:47.475] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.475] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:47.475]   - Field: ‘label’
[17:43:47.476]   - Field: ‘local’
[17:43:47.476]   - Field: ‘owner’
[17:43:47.476]   - Field: ‘envir’
[17:43:47.476]   - Field: ‘packages’
[17:43:47.476]   - Field: ‘gc’
[17:43:47.476]   - Field: ‘conditions’
[17:43:47.476]   - Field: ‘expr’
[17:43:47.476]   - Field: ‘uuid’
[17:43:47.476]   - Field: ‘seed’
[17:43:47.476]   - Field: ‘version’
[17:43:47.476]   - Field: ‘result’
[17:43:47.477]   - Field: ‘asynchronous’
[17:43:47.477]   - Field: ‘calls’
[17:43:47.477]   - Field: ‘globals’
[17:43:47.477]   - Field: ‘stdout’
[17:43:47.477]   - Field: ‘earlySignal’
[17:43:47.477]   - Field: ‘lazy’
[17:43:47.477]   - Field: ‘state’
[17:43:47.477] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:47.477] - Launch lazy future ...
[17:43:47.477] Packages needed by the future expression (n = 0): <none>
[17:43:47.478] Packages needed by future strategies (n = 0): <none>
[17:43:47.478] {
[17:43:47.478]     {
[17:43:47.478]         {
[17:43:47.478]             ...future.startTime <- base::Sys.time()
[17:43:47.478]             {
[17:43:47.478]                 {
[17:43:47.478]                   {
[17:43:47.478]                     base::local({
[17:43:47.478]                       has_future <- base::requireNamespace("future", 
[17:43:47.478]                         quietly = TRUE)
[17:43:47.478]                       if (has_future) {
[17:43:47.478]                         ns <- base::getNamespace("future")
[17:43:47.478]                         version <- ns[[".package"]][["version"]]
[17:43:47.478]                         if (is.null(version)) 
[17:43:47.478]                           version <- utils::packageVersion("future")
[17:43:47.478]                       }
[17:43:47.478]                       else {
[17:43:47.478]                         version <- NULL
[17:43:47.478]                       }
[17:43:47.478]                       if (!has_future || version < "1.8.0") {
[17:43:47.478]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.478]                           "", base::R.version$version.string), 
[17:43:47.478]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:47.478]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.478]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.478]                             "release", "version")], collapse = " "), 
[17:43:47.478]                           hostname = base::Sys.info()[["nodename"]])
[17:43:47.478]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.478]                           info)
[17:43:47.478]                         info <- base::paste(info, collapse = "; ")
[17:43:47.478]                         if (!has_future) {
[17:43:47.478]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.478]                             info)
[17:43:47.478]                         }
[17:43:47.478]                         else {
[17:43:47.478]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.478]                             info, version)
[17:43:47.478]                         }
[17:43:47.478]                         base::stop(msg)
[17:43:47.478]                       }
[17:43:47.478]                     })
[17:43:47.478]                   }
[17:43:47.478]                   ...future.strategy.old <- future::plan("list")
[17:43:47.478]                   options(future.plan = NULL)
[17:43:47.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.478]                 }
[17:43:47.478]                 ...future.workdir <- getwd()
[17:43:47.478]             }
[17:43:47.478]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.478]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.478]         }
[17:43:47.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.478]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:47.478]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.478]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.478]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.478]             base::names(...future.oldOptions))
[17:43:47.478]     }
[17:43:47.478]     if (FALSE) {
[17:43:47.478]     }
[17:43:47.478]     else {
[17:43:47.478]         if (TRUE) {
[17:43:47.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.478]                 open = "w")
[17:43:47.478]         }
[17:43:47.478]         else {
[17:43:47.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.478]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.478]         }
[17:43:47.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.478]             base::sink(type = "output", split = FALSE)
[17:43:47.478]             base::close(...future.stdout)
[17:43:47.478]         }, add = TRUE)
[17:43:47.478]     }
[17:43:47.478]     ...future.frame <- base::sys.nframe()
[17:43:47.478]     ...future.conditions <- base::list()
[17:43:47.478]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.478]     if (FALSE) {
[17:43:47.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.478]     }
[17:43:47.478]     ...future.result <- base::tryCatch({
[17:43:47.478]         base::withCallingHandlers({
[17:43:47.478]             ...future.value <- base::withVisible(base::local({
[17:43:47.478]                 do.call(function(...) {
[17:43:47.478]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.478]                   if (!identical(...future.globals.maxSize.org, 
[17:43:47.478]                     ...future.globals.maxSize)) {
[17:43:47.478]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.478]                     on.exit(options(oopts), add = TRUE)
[17:43:47.478]                   }
[17:43:47.478]                   {
[17:43:47.478]                     lapply(seq_along(...future.elements_ii), 
[17:43:47.478]                       FUN = function(jj) {
[17:43:47.478]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.478]                         ...future.FUN(...future.X_jj, ...)
[17:43:47.478]                       })
[17:43:47.478]                   }
[17:43:47.478]                 }, args = future.call.arguments)
[17:43:47.478]             }))
[17:43:47.478]             future::FutureResult(value = ...future.value$value, 
[17:43:47.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.478]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.478]                     ...future.globalenv.names))
[17:43:47.478]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.478]         }, condition = base::local({
[17:43:47.478]             c <- base::c
[17:43:47.478]             inherits <- base::inherits
[17:43:47.478]             invokeRestart <- base::invokeRestart
[17:43:47.478]             length <- base::length
[17:43:47.478]             list <- base::list
[17:43:47.478]             seq.int <- base::seq.int
[17:43:47.478]             signalCondition <- base::signalCondition
[17:43:47.478]             sys.calls <- base::sys.calls
[17:43:47.478]             `[[` <- base::`[[`
[17:43:47.478]             `+` <- base::`+`
[17:43:47.478]             `<<-` <- base::`<<-`
[17:43:47.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.478]                   3L)]
[17:43:47.478]             }
[17:43:47.478]             function(cond) {
[17:43:47.478]                 is_error <- inherits(cond, "error")
[17:43:47.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.478]                   NULL)
[17:43:47.478]                 if (is_error) {
[17:43:47.478]                   sessionInformation <- function() {
[17:43:47.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.478]                       search = base::search(), system = base::Sys.info())
[17:43:47.478]                   }
[17:43:47.478]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.478]                     cond$call), session = sessionInformation(), 
[17:43:47.478]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.478]                   signalCondition(cond)
[17:43:47.478]                 }
[17:43:47.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:47.478]                 "immediateCondition"))) {
[17:43:47.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:47.478]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.478]                   if (TRUE && !signal) {
[17:43:47.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.478]                     {
[17:43:47.478]                       inherits <- base::inherits
[17:43:47.478]                       invokeRestart <- base::invokeRestart
[17:43:47.478]                       is.null <- base::is.null
[17:43:47.478]                       muffled <- FALSE
[17:43:47.478]                       if (inherits(cond, "message")) {
[17:43:47.478]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.478]                         if (muffled) 
[17:43:47.478]                           invokeRestart("muffleMessage")
[17:43:47.478]                       }
[17:43:47.478]                       else if (inherits(cond, "warning")) {
[17:43:47.478]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.478]                         if (muffled) 
[17:43:47.478]                           invokeRestart("muffleWarning")
[17:43:47.478]                       }
[17:43:47.478]                       else if (inherits(cond, "condition")) {
[17:43:47.478]                         if (!is.null(pattern)) {
[17:43:47.478]                           computeRestarts <- base::computeRestarts
[17:43:47.478]                           grepl <- base::grepl
[17:43:47.478]                           restarts <- computeRestarts(cond)
[17:43:47.478]                           for (restart in restarts) {
[17:43:47.478]                             name <- restart$name
[17:43:47.478]                             if (is.null(name)) 
[17:43:47.478]                               next
[17:43:47.478]                             if (!grepl(pattern, name)) 
[17:43:47.478]                               next
[17:43:47.478]                             invokeRestart(restart)
[17:43:47.478]                             muffled <- TRUE
[17:43:47.478]                             break
[17:43:47.478]                           }
[17:43:47.478]                         }
[17:43:47.478]                       }
[17:43:47.478]                       invisible(muffled)
[17:43:47.478]                     }
[17:43:47.478]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.478]                   }
[17:43:47.478]                 }
[17:43:47.478]                 else {
[17:43:47.478]                   if (TRUE) {
[17:43:47.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.478]                     {
[17:43:47.478]                       inherits <- base::inherits
[17:43:47.478]                       invokeRestart <- base::invokeRestart
[17:43:47.478]                       is.null <- base::is.null
[17:43:47.478]                       muffled <- FALSE
[17:43:47.478]                       if (inherits(cond, "message")) {
[17:43:47.478]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.478]                         if (muffled) 
[17:43:47.478]                           invokeRestart("muffleMessage")
[17:43:47.478]                       }
[17:43:47.478]                       else if (inherits(cond, "warning")) {
[17:43:47.478]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.478]                         if (muffled) 
[17:43:47.478]                           invokeRestart("muffleWarning")
[17:43:47.478]                       }
[17:43:47.478]                       else if (inherits(cond, "condition")) {
[17:43:47.478]                         if (!is.null(pattern)) {
[17:43:47.478]                           computeRestarts <- base::computeRestarts
[17:43:47.478]                           grepl <- base::grepl
[17:43:47.478]                           restarts <- computeRestarts(cond)
[17:43:47.478]                           for (restart in restarts) {
[17:43:47.478]                             name <- restart$name
[17:43:47.478]                             if (is.null(name)) 
[17:43:47.478]                               next
[17:43:47.478]                             if (!grepl(pattern, name)) 
[17:43:47.478]                               next
[17:43:47.478]                             invokeRestart(restart)
[17:43:47.478]                             muffled <- TRUE
[17:43:47.478]                             break
[17:43:47.478]                           }
[17:43:47.478]                         }
[17:43:47.478]                       }
[17:43:47.478]                       invisible(muffled)
[17:43:47.478]                     }
[17:43:47.478]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.478]                   }
[17:43:47.478]                 }
[17:43:47.478]             }
[17:43:47.478]         }))
[17:43:47.478]     }, error = function(ex) {
[17:43:47.478]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.478]                 ...future.rng), started = ...future.startTime, 
[17:43:47.478]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.478]             version = "1.8"), class = "FutureResult")
[17:43:47.478]     }, finally = {
[17:43:47.478]         if (!identical(...future.workdir, getwd())) 
[17:43:47.478]             setwd(...future.workdir)
[17:43:47.478]         {
[17:43:47.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.478]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.478]             }
[17:43:47.478]             base::options(...future.oldOptions)
[17:43:47.478]             if (.Platform$OS.type == "windows") {
[17:43:47.478]                 old_names <- names(...future.oldEnvVars)
[17:43:47.478]                 envs <- base::Sys.getenv()
[17:43:47.478]                 names <- names(envs)
[17:43:47.478]                 common <- intersect(names, old_names)
[17:43:47.478]                 added <- setdiff(names, old_names)
[17:43:47.478]                 removed <- setdiff(old_names, names)
[17:43:47.478]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.478]                   envs[common]]
[17:43:47.478]                 NAMES <- toupper(changed)
[17:43:47.478]                 args <- list()
[17:43:47.478]                 for (kk in seq_along(NAMES)) {
[17:43:47.478]                   name <- changed[[kk]]
[17:43:47.478]                   NAME <- NAMES[[kk]]
[17:43:47.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.478]                     next
[17:43:47.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.478]                 }
[17:43:47.478]                 NAMES <- toupper(added)
[17:43:47.478]                 for (kk in seq_along(NAMES)) {
[17:43:47.478]                   name <- added[[kk]]
[17:43:47.478]                   NAME <- NAMES[[kk]]
[17:43:47.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.478]                     next
[17:43:47.478]                   args[[name]] <- ""
[17:43:47.478]                 }
[17:43:47.478]                 NAMES <- toupper(removed)
[17:43:47.478]                 for (kk in seq_along(NAMES)) {
[17:43:47.478]                   name <- removed[[kk]]
[17:43:47.478]                   NAME <- NAMES[[kk]]
[17:43:47.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.478]                     next
[17:43:47.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.478]                 }
[17:43:47.478]                 if (length(args) > 0) 
[17:43:47.478]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.478]             }
[17:43:47.478]             else {
[17:43:47.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.478]             }
[17:43:47.478]             {
[17:43:47.478]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.478]                   0L) {
[17:43:47.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.478]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.478]                   base::options(opts)
[17:43:47.478]                 }
[17:43:47.478]                 {
[17:43:47.478]                   {
[17:43:47.478]                     NULL
[17:43:47.478]                     RNGkind("Mersenne-Twister")
[17:43:47.478]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:47.478]                       inherits = FALSE)
[17:43:47.478]                   }
[17:43:47.478]                   options(future.plan = NULL)
[17:43:47.478]                   if (is.na(NA_character_)) 
[17:43:47.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.478]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:47.478]                     .init = FALSE)
[17:43:47.478]                 }
[17:43:47.478]             }
[17:43:47.478]         }
[17:43:47.478]     })
[17:43:47.478]     if (TRUE) {
[17:43:47.478]         base::sink(type = "output", split = FALSE)
[17:43:47.478]         if (TRUE) {
[17:43:47.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.478]         }
[17:43:47.478]         else {
[17:43:47.478]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.478]         }
[17:43:47.478]         base::close(...future.stdout)
[17:43:47.478]         ...future.stdout <- NULL
[17:43:47.478]     }
[17:43:47.478]     ...future.result$conditions <- ...future.conditions
[17:43:47.478]     ...future.result$finished <- base::Sys.time()
[17:43:47.478]     ...future.result
[17:43:47.478] }
[17:43:47.480] assign_globals() ...
[17:43:47.480] List of 5
[17:43:47.480]  $ future.call.arguments    : list()
[17:43:47.480]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.480]  $ ...future.FUN            :function (x)  
[17:43:47.480]  $ ...future.elements_ii    :List of 2
[17:43:47.480]   ..$ : int 1
[17:43:47.480]   ..$ : int 2
[17:43:47.480]  $ ...future.seeds_ii       : NULL
[17:43:47.480]  $ ...future.globals.maxSize: num Inf
[17:43:47.480]  - attr(*, "resolved")= logi FALSE
[17:43:47.480]  - attr(*, "total_size")= num NA
[17:43:47.480]  - attr(*, "where")=List of 5
[17:43:47.480]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:47.480]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:47.480]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:47.480]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:47.480]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:47.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.480]  - attr(*, "already-done")= logi TRUE
[17:43:47.484] - copied ‘future.call.arguments’ to environment
[17:43:47.510] - copied ‘...future.FUN’ to environment
[17:43:47.510] - copied ‘...future.elements_ii’ to environment
[17:43:47.510] - copied ‘...future.seeds_ii’ to environment
[17:43:47.511] - copied ‘...future.globals.maxSize’ to environment
[17:43:47.511] assign_globals() ... done
[17:43:47.511] plan(): Setting new future strategy stack:
[17:43:47.511] List of future strategies:
[17:43:47.511] 1. sequential:
[17:43:47.511]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.511]    - tweaked: FALSE
[17:43:47.511]    - call: NULL
[17:43:47.512] plan(): nbrOfWorkers() = 1
[17:43:47.513] plan(): Setting new future strategy stack:
[17:43:47.513] List of future strategies:
[17:43:47.513] 1. sequential:
[17:43:47.513]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.513]    - tweaked: FALSE
[17:43:47.513]    - call: plan(strategy)
[17:43:47.513] plan(): nbrOfWorkers() = 1
[17:43:47.513] SequentialFuture started (and completed)
[17:43:47.513] - Launch lazy future ... done
[17:43:47.513] run() for ‘SequentialFuture’ ... done
[17:43:47.514] Created future:
[17:43:47.514] SequentialFuture:
[17:43:47.514] Label: ‘future_apply-1’
[17:43:47.514] Expression:
[17:43:47.514] {
[17:43:47.514]     do.call(function(...) {
[17:43:47.514]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.514]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.514]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.514]             on.exit(options(oopts), add = TRUE)
[17:43:47.514]         }
[17:43:47.514]         {
[17:43:47.514]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.514]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.514]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.514]             })
[17:43:47.514]         }
[17:43:47.514]     }, args = future.call.arguments)
[17:43:47.514] }
[17:43:47.514] Lazy evaluation: FALSE
[17:43:47.514] Asynchronous evaluation: FALSE
[17:43:47.514] Local evaluation: TRUE
[17:43:47.514] Environment: R_GlobalEnv
[17:43:47.514] Capture standard output: TRUE
[17:43:47.514] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:47.514] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:47.514] Packages: <none>
[17:43:47.514] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:47.514] Resolved: TRUE
[17:43:47.514] Value: 112 bytes of class ‘list’
[17:43:47.514] Early signaling: FALSE
[17:43:47.514] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:47.514] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.515] Chunk #1 of 1 ... DONE
[17:43:47.515] Launching 1 futures (chunks) ... DONE
[17:43:47.515] Resolving 1 futures (chunks) ...
[17:43:47.515] resolve() on list ...
[17:43:47.515]  recursive: 0
[17:43:47.515]  length: 1
[17:43:47.515] 
[17:43:47.515] resolved() for ‘SequentialFuture’ ...
[17:43:47.515] - state: ‘finished’
[17:43:47.515] - run: TRUE
[17:43:47.516] - result: ‘FutureResult’
[17:43:47.516] resolved() for ‘SequentialFuture’ ... done
[17:43:47.516] Future #1
[17:43:47.516] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:47.516] - nx: 1
[17:43:47.516] - relay: TRUE
[17:43:47.516] - stdout: TRUE
[17:43:47.516] - signal: TRUE
[17:43:47.516] - resignal: FALSE
[17:43:47.516] - force: TRUE
[17:43:47.516] - relayed: [n=1] FALSE
[17:43:47.517] - queued futures: [n=1] FALSE
[17:43:47.517]  - until=1
[17:43:47.517]  - relaying element #1
[17:43:47.517] - relayed: [n=1] TRUE
[17:43:47.517] - queued futures: [n=1] TRUE
[17:43:47.517] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:47.517]  length: 0 (resolved future 1)
[17:43:47.517] Relaying remaining futures
[17:43:47.517] signalConditionsASAP(NULL, pos=0) ...
[17:43:47.517] - nx: 1
[17:43:47.518] - relay: TRUE
[17:43:47.518] - stdout: TRUE
[17:43:47.518] - signal: TRUE
[17:43:47.518] - resignal: FALSE
[17:43:47.518] - force: TRUE
[17:43:47.518] - relayed: [n=1] TRUE
[17:43:47.518] - queued futures: [n=1] TRUE
 - flush all
[17:43:47.518] - relayed: [n=1] TRUE
[17:43:47.518] - queued futures: [n=1] TRUE
[17:43:47.518] signalConditionsASAP(NULL, pos=0) ... done
[17:43:47.518] resolve() on list ... DONE
[17:43:47.519]  - Number of value chunks collected: 1
[17:43:47.519] Resolving 1 futures (chunks) ... DONE
[17:43:47.519] Reducing values from 1 chunks ...
[17:43:47.519]  - Number of values collected after concatenation: 2
[17:43:47.519]  - Number of values expected: 2
[17:43:47.519] Reducing values from 1 chunks ... DONE
[17:43:47.519] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[17:43:47.519] getGlobalsAndPackagesXApply() ...
[17:43:47.520]  - future.globals: TRUE
[17:43:47.520] getGlobalsAndPackages() ...
[17:43:47.520] Searching for globals...
[17:43:47.521] - globals found: [1] ‘FUN’
[17:43:47.521] Searching for globals ... DONE
[17:43:47.521] Resolving globals: FALSE
[17:43:47.521] The total size of the 1 globals is 848 bytes (848 bytes)
[17:43:47.522] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:43:47.522] - globals: [1] ‘FUN’
[17:43:47.522] 
[17:43:47.522] getGlobalsAndPackages() ... DONE
[17:43:47.522]  - globals found/used: [n=1] ‘FUN’
[17:43:47.522]  - needed namespaces: [n=0] 
[17:43:47.522] Finding globals ... DONE
[17:43:47.522]  - use_args: TRUE
[17:43:47.522]  - Getting '...' globals ...
[17:43:47.523] resolve() on list ...
[17:43:47.523]  recursive: 0
[17:43:47.523]  length: 1
[17:43:47.523]  elements: ‘...’
[17:43:47.523]  length: 0 (resolved future 1)
[17:43:47.523] resolve() on list ... DONE
[17:43:47.523]    - '...' content: [n=0] 
[17:43:47.523] List of 1
[17:43:47.523]  $ ...: list()
[17:43:47.523]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.523]  - attr(*, "where")=List of 1
[17:43:47.523]   ..$ ...:<environment: 0x55dfd392b2c8> 
[17:43:47.523]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.523]  - attr(*, "resolved")= logi TRUE
[17:43:47.523]  - attr(*, "total_size")= num NA
[17:43:47.526]  - Getting '...' globals ... DONE
[17:43:47.526] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:47.526] List of 2
[17:43:47.526]  $ ...future.FUN:function (x)  
[17:43:47.526]  $ ...          : list()
[17:43:47.526]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.526]  - attr(*, "where")=List of 2
[17:43:47.526]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:47.526]   ..$ ...          :<environment: 0x55dfd392b2c8> 
[17:43:47.526]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.526]  - attr(*, "resolved")= logi FALSE
[17:43:47.526]  - attr(*, "total_size")= num 848
[17:43:47.529] Packages to be attached in all futures: [n=0] 
[17:43:47.529] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.529] future_lapply() ...
[17:43:47.529] Number of chunks: 1
[17:43:47.530] getGlobalsAndPackagesXApply() ...
[17:43:47.530]  - future.globals: <name-value list> with names ‘list()’
[17:43:47.530]  - use_args: TRUE
[17:43:47.530] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:47.530] List of 2
[17:43:47.530]  $ ...          : list()
[17:43:47.530]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.530]  $ ...future.FUN:function (x)  
[17:43:47.530]  - attr(*, "where")=List of 2
[17:43:47.530]   ..$ ...          :<environment: 0x55dfd392b2c8> 
[17:43:47.530]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:47.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.530]  - attr(*, "resolved")= logi FALSE
[17:43:47.530]  - attr(*, "total_size")= num NA
[17:43:47.533] Packages to be attached in all futures: [n=0] 
[17:43:47.533] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.534] Number of futures (= number of chunks): 1
[17:43:47.534] Launching 1 futures (chunks) ...
[17:43:47.534] Chunk #1 of 1 ...
[17:43:47.534]  - seeds: <none>
[17:43:47.534]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.534] getGlobalsAndPackages() ...
[17:43:47.534] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.534] Resolving globals: FALSE
[17:43:47.534] Tweak future expression to call with '...' arguments ...
[17:43:47.534] {
[17:43:47.534]     do.call(function(...) {
[17:43:47.534]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.534]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.534]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.534]             on.exit(options(oopts), add = TRUE)
[17:43:47.534]         }
[17:43:47.534]         {
[17:43:47.534]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.534]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.534]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.534]             })
[17:43:47.534]         }
[17:43:47.534]     }, args = future.call.arguments)
[17:43:47.534] }
[17:43:47.535] Tweak future expression to call with '...' arguments ... DONE
[17:43:47.536] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.536] 
[17:43:47.536] getGlobalsAndPackages() ... DONE
[17:43:47.537] run() for ‘Future’ ...
[17:43:47.537] - state: ‘created’
[17:43:47.537] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:47.537] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.537] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:47.538]   - Field: ‘label’
[17:43:47.538]   - Field: ‘local’
[17:43:47.538]   - Field: ‘owner’
[17:43:47.538]   - Field: ‘envir’
[17:43:47.538]   - Field: ‘packages’
[17:43:47.538]   - Field: ‘gc’
[17:43:47.538]   - Field: ‘conditions’
[17:43:47.538]   - Field: ‘expr’
[17:43:47.538]   - Field: ‘uuid’
[17:43:47.538]   - Field: ‘seed’
[17:43:47.538]   - Field: ‘version’
[17:43:47.539]   - Field: ‘result’
[17:43:47.539]   - Field: ‘asynchronous’
[17:43:47.539]   - Field: ‘calls’
[17:43:47.539]   - Field: ‘globals’
[17:43:47.539]   - Field: ‘stdout’
[17:43:47.539]   - Field: ‘earlySignal’
[17:43:47.539]   - Field: ‘lazy’
[17:43:47.539]   - Field: ‘state’
[17:43:47.539] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:47.539] - Launch lazy future ...
[17:43:47.540] Packages needed by the future expression (n = 0): <none>
[17:43:47.540] Packages needed by future strategies (n = 0): <none>
[17:43:47.540] {
[17:43:47.540]     {
[17:43:47.540]         {
[17:43:47.540]             ...future.startTime <- base::Sys.time()
[17:43:47.540]             {
[17:43:47.540]                 {
[17:43:47.540]                   {
[17:43:47.540]                     base::local({
[17:43:47.540]                       has_future <- base::requireNamespace("future", 
[17:43:47.540]                         quietly = TRUE)
[17:43:47.540]                       if (has_future) {
[17:43:47.540]                         ns <- base::getNamespace("future")
[17:43:47.540]                         version <- ns[[".package"]][["version"]]
[17:43:47.540]                         if (is.null(version)) 
[17:43:47.540]                           version <- utils::packageVersion("future")
[17:43:47.540]                       }
[17:43:47.540]                       else {
[17:43:47.540]                         version <- NULL
[17:43:47.540]                       }
[17:43:47.540]                       if (!has_future || version < "1.8.0") {
[17:43:47.540]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.540]                           "", base::R.version$version.string), 
[17:43:47.540]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:47.540]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.540]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.540]                             "release", "version")], collapse = " "), 
[17:43:47.540]                           hostname = base::Sys.info()[["nodename"]])
[17:43:47.540]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.540]                           info)
[17:43:47.540]                         info <- base::paste(info, collapse = "; ")
[17:43:47.540]                         if (!has_future) {
[17:43:47.540]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.540]                             info)
[17:43:47.540]                         }
[17:43:47.540]                         else {
[17:43:47.540]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.540]                             info, version)
[17:43:47.540]                         }
[17:43:47.540]                         base::stop(msg)
[17:43:47.540]                       }
[17:43:47.540]                     })
[17:43:47.540]                   }
[17:43:47.540]                   ...future.strategy.old <- future::plan("list")
[17:43:47.540]                   options(future.plan = NULL)
[17:43:47.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.540]                 }
[17:43:47.540]                 ...future.workdir <- getwd()
[17:43:47.540]             }
[17:43:47.540]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.540]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.540]         }
[17:43:47.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.540]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:47.540]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.540]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.540]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.540]             base::names(...future.oldOptions))
[17:43:47.540]     }
[17:43:47.540]     if (FALSE) {
[17:43:47.540]     }
[17:43:47.540]     else {
[17:43:47.540]         if (TRUE) {
[17:43:47.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.540]                 open = "w")
[17:43:47.540]         }
[17:43:47.540]         else {
[17:43:47.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.540]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.540]         }
[17:43:47.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.540]             base::sink(type = "output", split = FALSE)
[17:43:47.540]             base::close(...future.stdout)
[17:43:47.540]         }, add = TRUE)
[17:43:47.540]     }
[17:43:47.540]     ...future.frame <- base::sys.nframe()
[17:43:47.540]     ...future.conditions <- base::list()
[17:43:47.540]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.540]     if (FALSE) {
[17:43:47.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.540]     }
[17:43:47.540]     ...future.result <- base::tryCatch({
[17:43:47.540]         base::withCallingHandlers({
[17:43:47.540]             ...future.value <- base::withVisible(base::local({
[17:43:47.540]                 do.call(function(...) {
[17:43:47.540]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.540]                   if (!identical(...future.globals.maxSize.org, 
[17:43:47.540]                     ...future.globals.maxSize)) {
[17:43:47.540]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.540]                     on.exit(options(oopts), add = TRUE)
[17:43:47.540]                   }
[17:43:47.540]                   {
[17:43:47.540]                     lapply(seq_along(...future.elements_ii), 
[17:43:47.540]                       FUN = function(jj) {
[17:43:47.540]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.540]                         ...future.FUN(...future.X_jj, ...)
[17:43:47.540]                       })
[17:43:47.540]                   }
[17:43:47.540]                 }, args = future.call.arguments)
[17:43:47.540]             }))
[17:43:47.540]             future::FutureResult(value = ...future.value$value, 
[17:43:47.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.540]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.540]                     ...future.globalenv.names))
[17:43:47.540]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.540]         }, condition = base::local({
[17:43:47.540]             c <- base::c
[17:43:47.540]             inherits <- base::inherits
[17:43:47.540]             invokeRestart <- base::invokeRestart
[17:43:47.540]             length <- base::length
[17:43:47.540]             list <- base::list
[17:43:47.540]             seq.int <- base::seq.int
[17:43:47.540]             signalCondition <- base::signalCondition
[17:43:47.540]             sys.calls <- base::sys.calls
[17:43:47.540]             `[[` <- base::`[[`
[17:43:47.540]             `+` <- base::`+`
[17:43:47.540]             `<<-` <- base::`<<-`
[17:43:47.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.540]                   3L)]
[17:43:47.540]             }
[17:43:47.540]             function(cond) {
[17:43:47.540]                 is_error <- inherits(cond, "error")
[17:43:47.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.540]                   NULL)
[17:43:47.540]                 if (is_error) {
[17:43:47.540]                   sessionInformation <- function() {
[17:43:47.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.540]                       search = base::search(), system = base::Sys.info())
[17:43:47.540]                   }
[17:43:47.540]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.540]                     cond$call), session = sessionInformation(), 
[17:43:47.540]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.540]                   signalCondition(cond)
[17:43:47.540]                 }
[17:43:47.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:47.540]                 "immediateCondition"))) {
[17:43:47.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:47.540]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.540]                   if (TRUE && !signal) {
[17:43:47.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.540]                     {
[17:43:47.540]                       inherits <- base::inherits
[17:43:47.540]                       invokeRestart <- base::invokeRestart
[17:43:47.540]                       is.null <- base::is.null
[17:43:47.540]                       muffled <- FALSE
[17:43:47.540]                       if (inherits(cond, "message")) {
[17:43:47.540]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.540]                         if (muffled) 
[17:43:47.540]                           invokeRestart("muffleMessage")
[17:43:47.540]                       }
[17:43:47.540]                       else if (inherits(cond, "warning")) {
[17:43:47.540]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.540]                         if (muffled) 
[17:43:47.540]                           invokeRestart("muffleWarning")
[17:43:47.540]                       }
[17:43:47.540]                       else if (inherits(cond, "condition")) {
[17:43:47.540]                         if (!is.null(pattern)) {
[17:43:47.540]                           computeRestarts <- base::computeRestarts
[17:43:47.540]                           grepl <- base::grepl
[17:43:47.540]                           restarts <- computeRestarts(cond)
[17:43:47.540]                           for (restart in restarts) {
[17:43:47.540]                             name <- restart$name
[17:43:47.540]                             if (is.null(name)) 
[17:43:47.540]                               next
[17:43:47.540]                             if (!grepl(pattern, name)) 
[17:43:47.540]                               next
[17:43:47.540]                             invokeRestart(restart)
[17:43:47.540]                             muffled <- TRUE
[17:43:47.540]                             break
[17:43:47.540]                           }
[17:43:47.540]                         }
[17:43:47.540]                       }
[17:43:47.540]                       invisible(muffled)
[17:43:47.540]                     }
[17:43:47.540]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.540]                   }
[17:43:47.540]                 }
[17:43:47.540]                 else {
[17:43:47.540]                   if (TRUE) {
[17:43:47.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.540]                     {
[17:43:47.540]                       inherits <- base::inherits
[17:43:47.540]                       invokeRestart <- base::invokeRestart
[17:43:47.540]                       is.null <- base::is.null
[17:43:47.540]                       muffled <- FALSE
[17:43:47.540]                       if (inherits(cond, "message")) {
[17:43:47.540]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.540]                         if (muffled) 
[17:43:47.540]                           invokeRestart("muffleMessage")
[17:43:47.540]                       }
[17:43:47.540]                       else if (inherits(cond, "warning")) {
[17:43:47.540]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.540]                         if (muffled) 
[17:43:47.540]                           invokeRestart("muffleWarning")
[17:43:47.540]                       }
[17:43:47.540]                       else if (inherits(cond, "condition")) {
[17:43:47.540]                         if (!is.null(pattern)) {
[17:43:47.540]                           computeRestarts <- base::computeRestarts
[17:43:47.540]                           grepl <- base::grepl
[17:43:47.540]                           restarts <- computeRestarts(cond)
[17:43:47.540]                           for (restart in restarts) {
[17:43:47.540]                             name <- restart$name
[17:43:47.540]                             if (is.null(name)) 
[17:43:47.540]                               next
[17:43:47.540]                             if (!grepl(pattern, name)) 
[17:43:47.540]                               next
[17:43:47.540]                             invokeRestart(restart)
[17:43:47.540]                             muffled <- TRUE
[17:43:47.540]                             break
[17:43:47.540]                           }
[17:43:47.540]                         }
[17:43:47.540]                       }
[17:43:47.540]                       invisible(muffled)
[17:43:47.540]                     }
[17:43:47.540]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.540]                   }
[17:43:47.540]                 }
[17:43:47.540]             }
[17:43:47.540]         }))
[17:43:47.540]     }, error = function(ex) {
[17:43:47.540]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.540]                 ...future.rng), started = ...future.startTime, 
[17:43:47.540]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.540]             version = "1.8"), class = "FutureResult")
[17:43:47.540]     }, finally = {
[17:43:47.540]         if (!identical(...future.workdir, getwd())) 
[17:43:47.540]             setwd(...future.workdir)
[17:43:47.540]         {
[17:43:47.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.540]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.540]             }
[17:43:47.540]             base::options(...future.oldOptions)
[17:43:47.540]             if (.Platform$OS.type == "windows") {
[17:43:47.540]                 old_names <- names(...future.oldEnvVars)
[17:43:47.540]                 envs <- base::Sys.getenv()
[17:43:47.540]                 names <- names(envs)
[17:43:47.540]                 common <- intersect(names, old_names)
[17:43:47.540]                 added <- setdiff(names, old_names)
[17:43:47.540]                 removed <- setdiff(old_names, names)
[17:43:47.540]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.540]                   envs[common]]
[17:43:47.540]                 NAMES <- toupper(changed)
[17:43:47.540]                 args <- list()
[17:43:47.540]                 for (kk in seq_along(NAMES)) {
[17:43:47.540]                   name <- changed[[kk]]
[17:43:47.540]                   NAME <- NAMES[[kk]]
[17:43:47.540]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.540]                     next
[17:43:47.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.540]                 }
[17:43:47.540]                 NAMES <- toupper(added)
[17:43:47.540]                 for (kk in seq_along(NAMES)) {
[17:43:47.540]                   name <- added[[kk]]
[17:43:47.540]                   NAME <- NAMES[[kk]]
[17:43:47.540]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.540]                     next
[17:43:47.540]                   args[[name]] <- ""
[17:43:47.540]                 }
[17:43:47.540]                 NAMES <- toupper(removed)
[17:43:47.540]                 for (kk in seq_along(NAMES)) {
[17:43:47.540]                   name <- removed[[kk]]
[17:43:47.540]                   NAME <- NAMES[[kk]]
[17:43:47.540]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.540]                     next
[17:43:47.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.540]                 }
[17:43:47.540]                 if (length(args) > 0) 
[17:43:47.540]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.540]             }
[17:43:47.540]             else {
[17:43:47.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.540]             }
[17:43:47.540]             {
[17:43:47.540]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.540]                   0L) {
[17:43:47.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.540]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.540]                   base::options(opts)
[17:43:47.540]                 }
[17:43:47.540]                 {
[17:43:47.540]                   {
[17:43:47.540]                     NULL
[17:43:47.540]                     RNGkind("Mersenne-Twister")
[17:43:47.540]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:47.540]                       inherits = FALSE)
[17:43:47.540]                   }
[17:43:47.540]                   options(future.plan = NULL)
[17:43:47.540]                   if (is.na(NA_character_)) 
[17:43:47.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.540]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:47.540]                     .init = FALSE)
[17:43:47.540]                 }
[17:43:47.540]             }
[17:43:47.540]         }
[17:43:47.540]     })
[17:43:47.540]     if (TRUE) {
[17:43:47.540]         base::sink(type = "output", split = FALSE)
[17:43:47.540]         if (TRUE) {
[17:43:47.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.540]         }
[17:43:47.540]         else {
[17:43:47.540]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.540]         }
[17:43:47.540]         base::close(...future.stdout)
[17:43:47.540]         ...future.stdout <- NULL
[17:43:47.540]     }
[17:43:47.540]     ...future.result$conditions <- ...future.conditions
[17:43:47.540]     ...future.result$finished <- base::Sys.time()
[17:43:47.540]     ...future.result
[17:43:47.540] }
[17:43:47.542] assign_globals() ...
[17:43:47.542] List of 5
[17:43:47.542]  $ future.call.arguments    : list()
[17:43:47.542]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.542]  $ ...future.FUN            :function (x)  
[17:43:47.542]  $ ...future.elements_ii    :List of 2
[17:43:47.542]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[17:43:47.542]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[17:43:47.542]  $ ...future.seeds_ii       : NULL
[17:43:47.542]  $ ...future.globals.maxSize: num Inf
[17:43:47.542]  - attr(*, "resolved")= logi FALSE
[17:43:47.542]  - attr(*, "total_size")= num NA
[17:43:47.542]  - attr(*, "where")=List of 5
[17:43:47.542]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:47.542]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:47.542]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:47.542]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:47.542]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:47.542]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.542]  - attr(*, "already-done")= logi TRUE
[17:43:47.547] - copied ‘future.call.arguments’ to environment
[17:43:47.547] - copied ‘...future.FUN’ to environment
[17:43:47.547] - copied ‘...future.elements_ii’ to environment
[17:43:47.547] - copied ‘...future.seeds_ii’ to environment
[17:43:47.547] - copied ‘...future.globals.maxSize’ to environment
[17:43:47.548] assign_globals() ... done
[17:43:47.548] plan(): Setting new future strategy stack:
[17:43:47.548] List of future strategies:
[17:43:47.548] 1. sequential:
[17:43:47.548]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.548]    - tweaked: FALSE
[17:43:47.548]    - call: NULL
[17:43:47.548] plan(): nbrOfWorkers() = 1
[17:43:47.549] plan(): Setting new future strategy stack:
[17:43:47.549] List of future strategies:
[17:43:47.549] 1. sequential:
[17:43:47.549]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.549]    - tweaked: FALSE
[17:43:47.549]    - call: plan(strategy)
[17:43:47.550] plan(): nbrOfWorkers() = 1
[17:43:47.550] SequentialFuture started (and completed)
[17:43:47.550] - Launch lazy future ... done
[17:43:47.550] run() for ‘SequentialFuture’ ... done
[17:43:47.550] Created future:
[17:43:47.550] SequentialFuture:
[17:43:47.550] Label: ‘future_apply-1’
[17:43:47.550] Expression:
[17:43:47.550] {
[17:43:47.550]     do.call(function(...) {
[17:43:47.550]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.550]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.550]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.550]             on.exit(options(oopts), add = TRUE)
[17:43:47.550]         }
[17:43:47.550]         {
[17:43:47.550]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.550]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.550]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.550]             })
[17:43:47.550]         }
[17:43:47.550]     }, args = future.call.arguments)
[17:43:47.550] }
[17:43:47.550] Lazy evaluation: FALSE
[17:43:47.550] Asynchronous evaluation: FALSE
[17:43:47.550] Local evaluation: TRUE
[17:43:47.550] Environment: R_GlobalEnv
[17:43:47.550] Capture standard output: TRUE
[17:43:47.550] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:47.550] Globals: 5 objects totaling 1.37 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 496 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:47.550] Packages: <none>
[17:43:47.550] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:47.550] Resolved: TRUE
[17:43:47.550] Value: 496 bytes of class ‘list’
[17:43:47.550] Early signaling: FALSE
[17:43:47.550] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:47.550] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.551] Chunk #1 of 1 ... DONE
[17:43:47.551] Launching 1 futures (chunks) ... DONE
[17:43:47.551] Resolving 1 futures (chunks) ...
[17:43:47.551] resolve() on list ...
[17:43:47.551]  recursive: 0
[17:43:47.552]  length: 1
[17:43:47.552] 
[17:43:47.552] resolved() for ‘SequentialFuture’ ...
[17:43:47.552] - state: ‘finished’
[17:43:47.552] - run: TRUE
[17:43:47.552] - result: ‘FutureResult’
[17:43:47.552] resolved() for ‘SequentialFuture’ ... done
[17:43:47.552] Future #1
[17:43:47.552] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:47.552] - nx: 1
[17:43:47.553] - relay: TRUE
[17:43:47.553] - stdout: TRUE
[17:43:47.553] - signal: TRUE
[17:43:47.553] - resignal: FALSE
[17:43:47.553] - force: TRUE
[17:43:47.553] - relayed: [n=1] FALSE
[17:43:47.553] - queued futures: [n=1] FALSE
[17:43:47.553]  - until=1
[17:43:47.553]  - relaying element #1
[17:43:47.553] - relayed: [n=1] TRUE
[17:43:47.553] - queued futures: [n=1] TRUE
[17:43:47.554] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:47.554]  length: 0 (resolved future 1)
[17:43:47.554] Relaying remaining futures
[17:43:47.554] signalConditionsASAP(NULL, pos=0) ...
[17:43:47.554] - nx: 1
[17:43:47.554] - relay: TRUE
[17:43:47.554] - stdout: TRUE
[17:43:47.554] - signal: TRUE
[17:43:47.554] - resignal: FALSE
[17:43:47.554] - force: TRUE
[17:43:47.554] - relayed: [n=1] TRUE
[17:43:47.554] - queued futures: [n=1] TRUE
 - flush all
[17:43:47.555] - relayed: [n=1] TRUE
[17:43:47.555] - queued futures: [n=1] TRUE
[17:43:47.555] signalConditionsASAP(NULL, pos=0) ... done
[17:43:47.555] resolve() on list ... DONE
[17:43:47.555]  - Number of value chunks collected: 1
[17:43:47.555] Resolving 1 futures (chunks) ... DONE
[17:43:47.555] Reducing values from 1 chunks ...
[17:43:47.555]  - Number of values collected after concatenation: 2
[17:43:47.555]  - Number of values expected: 2
[17:43:47.556] Reducing values from 1 chunks ... DONE
[17:43:47.556] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[17:43:47.556] getGlobalsAndPackagesXApply() ...
[17:43:47.556]  - future.globals: TRUE
[17:43:47.556] getGlobalsAndPackages() ...
[17:43:47.556] Searching for globals...
[17:43:47.559] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[17:43:47.559] Searching for globals ... DONE
[17:43:47.559] Resolving globals: FALSE
[17:43:47.559] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[17:43:47.560] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[17:43:47.560] - globals: [1] ‘FUN’
[17:43:47.560] 
[17:43:47.560] getGlobalsAndPackages() ... DONE
[17:43:47.560]  - globals found/used: [n=1] ‘FUN’
[17:43:47.560]  - needed namespaces: [n=0] 
[17:43:47.560] Finding globals ... DONE
[17:43:47.560]  - use_args: TRUE
[17:43:47.560]  - Getting '...' globals ...
[17:43:47.562] resolve() on list ...
[17:43:47.562]  recursive: 0
[17:43:47.562]  length: 1
[17:43:47.562]  elements: ‘...’
[17:43:47.562]  length: 0 (resolved future 1)
[17:43:47.562] resolve() on list ... DONE
[17:43:47.562]    - '...' content: [n=0] 
[17:43:47.563] List of 1
[17:43:47.563]  $ ...: list()
[17:43:47.563]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.563]  - attr(*, "where")=List of 1
[17:43:47.563]   ..$ ...:<environment: 0x55dfd4ee4f78> 
[17:43:47.563]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.563]  - attr(*, "resolved")= logi TRUE
[17:43:47.563]  - attr(*, "total_size")= num NA
[17:43:47.565]  - Getting '...' globals ... DONE
[17:43:47.565] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:47.565] List of 2
[17:43:47.565]  $ ...future.FUN:function (x)  
[17:43:47.565]  $ ...          : list()
[17:43:47.565]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.565]  - attr(*, "where")=List of 2
[17:43:47.565]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:47.565]   ..$ ...          :<environment: 0x55dfd4ee4f78> 
[17:43:47.565]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.565]  - attr(*, "resolved")= logi FALSE
[17:43:47.565]  - attr(*, "total_size")= num 9888
[17:43:47.568] Packages to be attached in all futures: [n=0] 
[17:43:47.568] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.568] future_lapply() ...
[17:43:47.569] Number of chunks: 1
[17:43:47.570] getGlobalsAndPackagesXApply() ...
[17:43:47.570]  - future.globals: <name-value list> with names ‘list()’
[17:43:47.570]  - use_args: TRUE
[17:43:47.570] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:47.570] List of 2
[17:43:47.570]  $ ...          : list()
[17:43:47.570]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.570]  $ ...future.FUN:function (x)  
[17:43:47.570]  - attr(*, "where")=List of 2
[17:43:47.570]   ..$ ...          :<environment: 0x55dfd4ee4f78> 
[17:43:47.570]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:43:47.570]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.570]  - attr(*, "resolved")= logi FALSE
[17:43:47.570]  - attr(*, "total_size")= num NA
[17:43:47.573] Packages to be attached in all futures: [n=0] 
[17:43:47.573] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.573] Number of futures (= number of chunks): 1
[17:43:47.573] Launching 1 futures (chunks) ...
[17:43:47.573] Chunk #1 of 1 ...
[17:43:47.573]  - seeds: <none>
[17:43:47.573]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.573] getGlobalsAndPackages() ...
[17:43:47.574] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.574] Resolving globals: FALSE
[17:43:47.574] Tweak future expression to call with '...' arguments ...
[17:43:47.574] {
[17:43:47.574]     do.call(function(...) {
[17:43:47.574]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.574]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.574]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.574]             on.exit(options(oopts), add = TRUE)
[17:43:47.574]         }
[17:43:47.574]         {
[17:43:47.574]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.574]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.574]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.574]             })
[17:43:47.574]         }
[17:43:47.574]     }, args = future.call.arguments)
[17:43:47.574] }
[17:43:47.574] Tweak future expression to call with '...' arguments ... DONE
[17:43:47.574] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.575] 
[17:43:47.575] getGlobalsAndPackages() ... DONE
[17:43:47.575] run() for ‘Future’ ...
[17:43:47.575] - state: ‘created’
[17:43:47.575] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:47.575] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.576] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:47.576]   - Field: ‘label’
[17:43:47.576]   - Field: ‘local’
[17:43:47.576]   - Field: ‘owner’
[17:43:47.576]   - Field: ‘envir’
[17:43:47.576]   - Field: ‘packages’
[17:43:47.576]   - Field: ‘gc’
[17:43:47.576]   - Field: ‘conditions’
[17:43:47.576]   - Field: ‘expr’
[17:43:47.576]   - Field: ‘uuid’
[17:43:47.576]   - Field: ‘seed’
[17:43:47.577]   - Field: ‘version’
[17:43:47.577]   - Field: ‘result’
[17:43:47.577]   - Field: ‘asynchronous’
[17:43:47.577]   - Field: ‘calls’
[17:43:47.577]   - Field: ‘globals’
[17:43:47.577]   - Field: ‘stdout’
[17:43:47.577]   - Field: ‘earlySignal’
[17:43:47.577]   - Field: ‘lazy’
[17:43:47.577]   - Field: ‘state’
[17:43:47.577] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:47.577] - Launch lazy future ...
[17:43:47.578] Packages needed by the future expression (n = 0): <none>
[17:43:47.578] Packages needed by future strategies (n = 0): <none>
[17:43:47.578] {
[17:43:47.578]     {
[17:43:47.578]         {
[17:43:47.578]             ...future.startTime <- base::Sys.time()
[17:43:47.578]             {
[17:43:47.578]                 {
[17:43:47.578]                   {
[17:43:47.578]                     base::local({
[17:43:47.578]                       has_future <- base::requireNamespace("future", 
[17:43:47.578]                         quietly = TRUE)
[17:43:47.578]                       if (has_future) {
[17:43:47.578]                         ns <- base::getNamespace("future")
[17:43:47.578]                         version <- ns[[".package"]][["version"]]
[17:43:47.578]                         if (is.null(version)) 
[17:43:47.578]                           version <- utils::packageVersion("future")
[17:43:47.578]                       }
[17:43:47.578]                       else {
[17:43:47.578]                         version <- NULL
[17:43:47.578]                       }
[17:43:47.578]                       if (!has_future || version < "1.8.0") {
[17:43:47.578]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.578]                           "", base::R.version$version.string), 
[17:43:47.578]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:47.578]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.578]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.578]                             "release", "version")], collapse = " "), 
[17:43:47.578]                           hostname = base::Sys.info()[["nodename"]])
[17:43:47.578]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.578]                           info)
[17:43:47.578]                         info <- base::paste(info, collapse = "; ")
[17:43:47.578]                         if (!has_future) {
[17:43:47.578]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.578]                             info)
[17:43:47.578]                         }
[17:43:47.578]                         else {
[17:43:47.578]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.578]                             info, version)
[17:43:47.578]                         }
[17:43:47.578]                         base::stop(msg)
[17:43:47.578]                       }
[17:43:47.578]                     })
[17:43:47.578]                   }
[17:43:47.578]                   ...future.strategy.old <- future::plan("list")
[17:43:47.578]                   options(future.plan = NULL)
[17:43:47.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.578]                 }
[17:43:47.578]                 ...future.workdir <- getwd()
[17:43:47.578]             }
[17:43:47.578]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.578]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.578]         }
[17:43:47.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.578]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:47.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.578]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.578]             base::names(...future.oldOptions))
[17:43:47.578]     }
[17:43:47.578]     if (FALSE) {
[17:43:47.578]     }
[17:43:47.578]     else {
[17:43:47.578]         if (TRUE) {
[17:43:47.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.578]                 open = "w")
[17:43:47.578]         }
[17:43:47.578]         else {
[17:43:47.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.578]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.578]         }
[17:43:47.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.578]             base::sink(type = "output", split = FALSE)
[17:43:47.578]             base::close(...future.stdout)
[17:43:47.578]         }, add = TRUE)
[17:43:47.578]     }
[17:43:47.578]     ...future.frame <- base::sys.nframe()
[17:43:47.578]     ...future.conditions <- base::list()
[17:43:47.578]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.578]     if (FALSE) {
[17:43:47.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.578]     }
[17:43:47.578]     ...future.result <- base::tryCatch({
[17:43:47.578]         base::withCallingHandlers({
[17:43:47.578]             ...future.value <- base::withVisible(base::local({
[17:43:47.578]                 do.call(function(...) {
[17:43:47.578]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.578]                   if (!identical(...future.globals.maxSize.org, 
[17:43:47.578]                     ...future.globals.maxSize)) {
[17:43:47.578]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.578]                     on.exit(options(oopts), add = TRUE)
[17:43:47.578]                   }
[17:43:47.578]                   {
[17:43:47.578]                     lapply(seq_along(...future.elements_ii), 
[17:43:47.578]                       FUN = function(jj) {
[17:43:47.578]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.578]                         ...future.FUN(...future.X_jj, ...)
[17:43:47.578]                       })
[17:43:47.578]                   }
[17:43:47.578]                 }, args = future.call.arguments)
[17:43:47.578]             }))
[17:43:47.578]             future::FutureResult(value = ...future.value$value, 
[17:43:47.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.578]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.578]                     ...future.globalenv.names))
[17:43:47.578]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.578]         }, condition = base::local({
[17:43:47.578]             c <- base::c
[17:43:47.578]             inherits <- base::inherits
[17:43:47.578]             invokeRestart <- base::invokeRestart
[17:43:47.578]             length <- base::length
[17:43:47.578]             list <- base::list
[17:43:47.578]             seq.int <- base::seq.int
[17:43:47.578]             signalCondition <- base::signalCondition
[17:43:47.578]             sys.calls <- base::sys.calls
[17:43:47.578]             `[[` <- base::`[[`
[17:43:47.578]             `+` <- base::`+`
[17:43:47.578]             `<<-` <- base::`<<-`
[17:43:47.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.578]                   3L)]
[17:43:47.578]             }
[17:43:47.578]             function(cond) {
[17:43:47.578]                 is_error <- inherits(cond, "error")
[17:43:47.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.578]                   NULL)
[17:43:47.578]                 if (is_error) {
[17:43:47.578]                   sessionInformation <- function() {
[17:43:47.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.578]                       search = base::search(), system = base::Sys.info())
[17:43:47.578]                   }
[17:43:47.578]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.578]                     cond$call), session = sessionInformation(), 
[17:43:47.578]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.578]                   signalCondition(cond)
[17:43:47.578]                 }
[17:43:47.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:47.578]                 "immediateCondition"))) {
[17:43:47.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:47.578]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.578]                   if (TRUE && !signal) {
[17:43:47.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.578]                     {
[17:43:47.578]                       inherits <- base::inherits
[17:43:47.578]                       invokeRestart <- base::invokeRestart
[17:43:47.578]                       is.null <- base::is.null
[17:43:47.578]                       muffled <- FALSE
[17:43:47.578]                       if (inherits(cond, "message")) {
[17:43:47.578]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.578]                         if (muffled) 
[17:43:47.578]                           invokeRestart("muffleMessage")
[17:43:47.578]                       }
[17:43:47.578]                       else if (inherits(cond, "warning")) {
[17:43:47.578]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.578]                         if (muffled) 
[17:43:47.578]                           invokeRestart("muffleWarning")
[17:43:47.578]                       }
[17:43:47.578]                       else if (inherits(cond, "condition")) {
[17:43:47.578]                         if (!is.null(pattern)) {
[17:43:47.578]                           computeRestarts <- base::computeRestarts
[17:43:47.578]                           grepl <- base::grepl
[17:43:47.578]                           restarts <- computeRestarts(cond)
[17:43:47.578]                           for (restart in restarts) {
[17:43:47.578]                             name <- restart$name
[17:43:47.578]                             if (is.null(name)) 
[17:43:47.578]                               next
[17:43:47.578]                             if (!grepl(pattern, name)) 
[17:43:47.578]                               next
[17:43:47.578]                             invokeRestart(restart)
[17:43:47.578]                             muffled <- TRUE
[17:43:47.578]                             break
[17:43:47.578]                           }
[17:43:47.578]                         }
[17:43:47.578]                       }
[17:43:47.578]                       invisible(muffled)
[17:43:47.578]                     }
[17:43:47.578]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.578]                   }
[17:43:47.578]                 }
[17:43:47.578]                 else {
[17:43:47.578]                   if (TRUE) {
[17:43:47.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.578]                     {
[17:43:47.578]                       inherits <- base::inherits
[17:43:47.578]                       invokeRestart <- base::invokeRestart
[17:43:47.578]                       is.null <- base::is.null
[17:43:47.578]                       muffled <- FALSE
[17:43:47.578]                       if (inherits(cond, "message")) {
[17:43:47.578]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.578]                         if (muffled) 
[17:43:47.578]                           invokeRestart("muffleMessage")
[17:43:47.578]                       }
[17:43:47.578]                       else if (inherits(cond, "warning")) {
[17:43:47.578]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.578]                         if (muffled) 
[17:43:47.578]                           invokeRestart("muffleWarning")
[17:43:47.578]                       }
[17:43:47.578]                       else if (inherits(cond, "condition")) {
[17:43:47.578]                         if (!is.null(pattern)) {
[17:43:47.578]                           computeRestarts <- base::computeRestarts
[17:43:47.578]                           grepl <- base::grepl
[17:43:47.578]                           restarts <- computeRestarts(cond)
[17:43:47.578]                           for (restart in restarts) {
[17:43:47.578]                             name <- restart$name
[17:43:47.578]                             if (is.null(name)) 
[17:43:47.578]                               next
[17:43:47.578]                             if (!grepl(pattern, name)) 
[17:43:47.578]                               next
[17:43:47.578]                             invokeRestart(restart)
[17:43:47.578]                             muffled <- TRUE
[17:43:47.578]                             break
[17:43:47.578]                           }
[17:43:47.578]                         }
[17:43:47.578]                       }
[17:43:47.578]                       invisible(muffled)
[17:43:47.578]                     }
[17:43:47.578]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.578]                   }
[17:43:47.578]                 }
[17:43:47.578]             }
[17:43:47.578]         }))
[17:43:47.578]     }, error = function(ex) {
[17:43:47.578]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.578]                 ...future.rng), started = ...future.startTime, 
[17:43:47.578]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.578]             version = "1.8"), class = "FutureResult")
[17:43:47.578]     }, finally = {
[17:43:47.578]         if (!identical(...future.workdir, getwd())) 
[17:43:47.578]             setwd(...future.workdir)
[17:43:47.578]         {
[17:43:47.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.578]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.578]             }
[17:43:47.578]             base::options(...future.oldOptions)
[17:43:47.578]             if (.Platform$OS.type == "windows") {
[17:43:47.578]                 old_names <- names(...future.oldEnvVars)
[17:43:47.578]                 envs <- base::Sys.getenv()
[17:43:47.578]                 names <- names(envs)
[17:43:47.578]                 common <- intersect(names, old_names)
[17:43:47.578]                 added <- setdiff(names, old_names)
[17:43:47.578]                 removed <- setdiff(old_names, names)
[17:43:47.578]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.578]                   envs[common]]
[17:43:47.578]                 NAMES <- toupper(changed)
[17:43:47.578]                 args <- list()
[17:43:47.578]                 for (kk in seq_along(NAMES)) {
[17:43:47.578]                   name <- changed[[kk]]
[17:43:47.578]                   NAME <- NAMES[[kk]]
[17:43:47.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.578]                     next
[17:43:47.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.578]                 }
[17:43:47.578]                 NAMES <- toupper(added)
[17:43:47.578]                 for (kk in seq_along(NAMES)) {
[17:43:47.578]                   name <- added[[kk]]
[17:43:47.578]                   NAME <- NAMES[[kk]]
[17:43:47.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.578]                     next
[17:43:47.578]                   args[[name]] <- ""
[17:43:47.578]                 }
[17:43:47.578]                 NAMES <- toupper(removed)
[17:43:47.578]                 for (kk in seq_along(NAMES)) {
[17:43:47.578]                   name <- removed[[kk]]
[17:43:47.578]                   NAME <- NAMES[[kk]]
[17:43:47.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.578]                     next
[17:43:47.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.578]                 }
[17:43:47.578]                 if (length(args) > 0) 
[17:43:47.578]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.578]             }
[17:43:47.578]             else {
[17:43:47.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.578]             }
[17:43:47.578]             {
[17:43:47.578]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.578]                   0L) {
[17:43:47.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.578]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.578]                   base::options(opts)
[17:43:47.578]                 }
[17:43:47.578]                 {
[17:43:47.578]                   {
[17:43:47.578]                     NULL
[17:43:47.578]                     RNGkind("Mersenne-Twister")
[17:43:47.578]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:47.578]                       inherits = FALSE)
[17:43:47.578]                   }
[17:43:47.578]                   options(future.plan = NULL)
[17:43:47.578]                   if (is.na(NA_character_)) 
[17:43:47.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.578]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:47.578]                     .init = FALSE)
[17:43:47.578]                 }
[17:43:47.578]             }
[17:43:47.578]         }
[17:43:47.578]     })
[17:43:47.578]     if (TRUE) {
[17:43:47.578]         base::sink(type = "output", split = FALSE)
[17:43:47.578]         if (TRUE) {
[17:43:47.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.578]         }
[17:43:47.578]         else {
[17:43:47.578]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.578]         }
[17:43:47.578]         base::close(...future.stdout)
[17:43:47.578]         ...future.stdout <- NULL
[17:43:47.578]     }
[17:43:47.578]     ...future.result$conditions <- ...future.conditions
[17:43:47.578]     ...future.result$finished <- base::Sys.time()
[17:43:47.578]     ...future.result
[17:43:47.578] }
[17:43:47.580] assign_globals() ...
[17:43:47.580] List of 5
[17:43:47.580]  $ future.call.arguments    : list()
[17:43:47.580]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.580]  $ ...future.FUN            :function (x)  
[17:43:47.580]  $ ...future.elements_ii    :List of 2
[17:43:47.580]   ..$ : int [1:2] 1 3
[17:43:47.580]   ..$ : int [1:2] 2 4
[17:43:47.580]  $ ...future.seeds_ii       : NULL
[17:43:47.580]  $ ...future.globals.maxSize: num Inf
[17:43:47.580]  - attr(*, "resolved")= logi FALSE
[17:43:47.580]  - attr(*, "total_size")= num NA
[17:43:47.580]  - attr(*, "where")=List of 5
[17:43:47.580]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:47.580]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:47.580]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:47.580]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:47.580]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:47.580]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.580]  - attr(*, "already-done")= logi TRUE
[17:43:47.585] - copied ‘future.call.arguments’ to environment
[17:43:47.585] - reassign environment for ‘...future.FUN’
[17:43:47.585] - copied ‘...future.FUN’ to environment
[17:43:47.586] - copied ‘...future.elements_ii’ to environment
[17:43:47.586] - copied ‘...future.seeds_ii’ to environment
[17:43:47.586] - copied ‘...future.globals.maxSize’ to environment
[17:43:47.586] assign_globals() ... done
[17:43:47.587] plan(): Setting new future strategy stack:
[17:43:47.587] List of future strategies:
[17:43:47.587] 1. sequential:
[17:43:47.587]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.587]    - tweaked: FALSE
[17:43:47.587]    - call: NULL
[17:43:47.587] plan(): nbrOfWorkers() = 1
[17:43:47.588] plan(): Setting new future strategy stack:
[17:43:47.588] List of future strategies:
[17:43:47.588] 1. sequential:
[17:43:47.588]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.588]    - tweaked: FALSE
[17:43:47.588]    - call: plan(strategy)
[17:43:47.588] plan(): nbrOfWorkers() = 1
[17:43:47.589] SequentialFuture started (and completed)
[17:43:47.589] - Launch lazy future ... done
[17:43:47.589] run() for ‘SequentialFuture’ ... done
[17:43:47.589] Created future:
[17:43:47.589] SequentialFuture:
[17:43:47.589] Label: ‘future_apply-1’
[17:43:47.589] Expression:
[17:43:47.589] {
[17:43:47.589]     do.call(function(...) {
[17:43:47.589]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.589]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.589]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.589]             on.exit(options(oopts), add = TRUE)
[17:43:47.589]         }
[17:43:47.589]         {
[17:43:47.589]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.589]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.589]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.589]             })
[17:43:47.589]         }
[17:43:47.589]     }, args = future.call.arguments)
[17:43:47.589] }
[17:43:47.589] Lazy evaluation: FALSE
[17:43:47.589] Asynchronous evaluation: FALSE
[17:43:47.589] Local evaluation: TRUE
[17:43:47.589] Environment: R_GlobalEnv
[17:43:47.589] Capture standard output: TRUE
[17:43:47.589] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:47.589] Globals: 5 objects totaling 9.82 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:47.589] Packages: <none>
[17:43:47.589] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:47.589] Resolved: TRUE
[17:43:47.589] Value: 400 bytes of class ‘list’
[17:43:47.589] Early signaling: FALSE
[17:43:47.589] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:47.589] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.590] Chunk #1 of 1 ... DONE
[17:43:47.590] Launching 1 futures (chunks) ... DONE
[17:43:47.590] Resolving 1 futures (chunks) ...
[17:43:47.590] resolve() on list ...
[17:43:47.590]  recursive: 0
[17:43:47.590]  length: 1
[17:43:47.590] 
[17:43:47.591] resolved() for ‘SequentialFuture’ ...
[17:43:47.591] - state: ‘finished’
[17:43:47.591] - run: TRUE
[17:43:47.591] - result: ‘FutureResult’
[17:43:47.591] resolved() for ‘SequentialFuture’ ... done
[17:43:47.591] Future #1
[17:43:47.591] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:47.591] - nx: 1
[17:43:47.591] - relay: TRUE
[17:43:47.591] - stdout: TRUE
[17:43:47.591] - signal: TRUE
[17:43:47.592] - resignal: FALSE
[17:43:47.592] - force: TRUE
[17:43:47.592] - relayed: [n=1] FALSE
[17:43:47.592] - queued futures: [n=1] FALSE
[17:43:47.592]  - until=1
[17:43:47.592]  - relaying element #1
[17:43:47.592] - relayed: [n=1] TRUE
[17:43:47.592] - queued futures: [n=1] TRUE
[17:43:47.592] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:47.592]  length: 0 (resolved future 1)
[17:43:47.592] Relaying remaining futures
[17:43:47.593] signalConditionsASAP(NULL, pos=0) ...
[17:43:47.593] - nx: 1
[17:43:47.593] - relay: TRUE
[17:43:47.593] - stdout: TRUE
[17:43:47.593] - signal: TRUE
[17:43:47.593] - resignal: FALSE
[17:43:47.593] - force: TRUE
[17:43:47.593] - relayed: [n=1] TRUE
[17:43:47.593] - queued futures: [n=1] TRUE
 - flush all
[17:43:47.593] - relayed: [n=1] TRUE
[17:43:47.593] - queued futures: [n=1] TRUE
[17:43:47.594] signalConditionsASAP(NULL, pos=0) ... done
[17:43:47.594] resolve() on list ... DONE
[17:43:47.594]  - Number of value chunks collected: 1
[17:43:47.594] Resolving 1 futures (chunks) ... DONE
[17:43:47.594] Reducing values from 1 chunks ...
[17:43:47.594]  - Number of values collected after concatenation: 2
[17:43:47.594]  - Number of values expected: 2
[17:43:47.594] Reducing values from 1 chunks ... DONE
[17:43:47.594] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[17:43:47.595] getGlobalsAndPackagesXApply() ...
[17:43:47.595]  - future.globals: TRUE
[17:43:47.595] getGlobalsAndPackages() ...
[17:43:47.595] Searching for globals...
[17:43:47.597] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[17:43:47.598] Searching for globals ... DONE
[17:43:47.598] Resolving globals: FALSE
[17:43:47.598] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[17:43:47.599] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[17:43:47.599] - globals: [1] ‘FUN’
[17:43:47.599] 
[17:43:47.599] getGlobalsAndPackages() ... DONE
[17:43:47.599]  - globals found/used: [n=1] ‘FUN’
[17:43:47.599]  - needed namespaces: [n=0] 
[17:43:47.599] Finding globals ... DONE
[17:43:47.599]  - use_args: TRUE
[17:43:47.599]  - Getting '...' globals ...
[17:43:47.600] resolve() on list ...
[17:43:47.600]  recursive: 0
[17:43:47.600]  length: 1
[17:43:47.600]  elements: ‘...’
[17:43:47.600]  length: 0 (resolved future 1)
[17:43:47.600] resolve() on list ... DONE
[17:43:47.600]    - '...' content: [n=0] 
[17:43:47.600] List of 1
[17:43:47.600]  $ ...: list()
[17:43:47.600]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.600]  - attr(*, "where")=List of 1
[17:43:47.600]   ..$ ...:<environment: 0x55dfd3eb7498> 
[17:43:47.600]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.600]  - attr(*, "resolved")= logi TRUE
[17:43:47.600]  - attr(*, "total_size")= num NA
[17:43:47.603]  - Getting '...' globals ... DONE
[17:43:47.603] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:47.603] List of 2
[17:43:47.603]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:43:47.603]  $ ...          : list()
[17:43:47.603]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.603]  - attr(*, "where")=List of 2
[17:43:47.603]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:47.603]   ..$ ...          :<environment: 0x55dfd3eb7498> 
[17:43:47.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.603]  - attr(*, "resolved")= logi FALSE
[17:43:47.603]  - attr(*, "total_size")= num 36296
[17:43:47.605] Packages to be attached in all futures: [n=0] 
[17:43:47.605] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.606] future_lapply() ...
[17:43:47.607] Generating random seeds ...
[17:43:47.608] Generating random seed streams for 2 elements ...
[17:43:47.609] Generating random seed streams for 2 elements ... DONE
[17:43:47.609] Generating random seeds ... DONE
[17:43:47.609] Will set RNG state on exit: 10407, 1564885844, -547059031, 473793448, 1636779227, -194360588, -903202944
[17:43:47.609] Number of chunks: 1
[17:43:47.609] getGlobalsAndPackagesXApply() ...
[17:43:47.609]  - future.globals: <name-value list> with names ‘list()’
[17:43:47.610]  - use_args: TRUE
[17:43:47.610] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:47.610] List of 2
[17:43:47.610]  $ ...          : list()
[17:43:47.610]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.610]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:43:47.610]  - attr(*, "where")=List of 2
[17:43:47.610]   ..$ ...          :<environment: 0x55dfd3eb7498> 
[17:43:47.610]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:47.610]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.610]  - attr(*, "resolved")= logi FALSE
[17:43:47.610]  - attr(*, "total_size")= num NA
[17:43:47.613] Packages to be attached in all futures: [n=0] 
[17:43:47.613] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.613] Number of futures (= number of chunks): 1
[17:43:47.613] Launching 1 futures (chunks) ...
[17:43:47.613] Chunk #1 of 1 ...
[17:43:47.613]  - seeds: [2] <seeds>
[17:43:47.614]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.614] getGlobalsAndPackages() ...
[17:43:47.614] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.614] Resolving globals: FALSE
[17:43:47.614] Tweak future expression to call with '...' arguments ...
[17:43:47.614] {
[17:43:47.614]     do.call(function(...) {
[17:43:47.614]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.614]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.614]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.614]             on.exit(options(oopts), add = TRUE)
[17:43:47.614]         }
[17:43:47.614]         {
[17:43:47.614]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.614]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.614]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:47.614]                   envir = globalenv(), inherits = FALSE)
[17:43:47.614]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.614]             })
[17:43:47.614]         }
[17:43:47.614]     }, args = future.call.arguments)
[17:43:47.614] }
[17:43:47.614] Tweak future expression to call with '...' arguments ... DONE
[17:43:47.615] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.615] 
[17:43:47.615] getGlobalsAndPackages() ... DONE
[17:43:47.615] run() for ‘Future’ ...
[17:43:47.615] - state: ‘created’
[17:43:47.615] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:47.616] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.616] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:47.616]   - Field: ‘label’
[17:43:47.616]   - Field: ‘local’
[17:43:47.616]   - Field: ‘owner’
[17:43:47.616]   - Field: ‘envir’
[17:43:47.616]   - Field: ‘packages’
[17:43:47.616]   - Field: ‘gc’
[17:43:47.616]   - Field: ‘conditions’
[17:43:47.616]   - Field: ‘expr’
[17:43:47.617]   - Field: ‘uuid’
[17:43:47.617]   - Field: ‘seed’
[17:43:47.617]   - Field: ‘version’
[17:43:47.617]   - Field: ‘result’
[17:43:47.617]   - Field: ‘asynchronous’
[17:43:47.617]   - Field: ‘calls’
[17:43:47.617]   - Field: ‘globals’
[17:43:47.617]   - Field: ‘stdout’
[17:43:47.617]   - Field: ‘earlySignal’
[17:43:47.617]   - Field: ‘lazy’
[17:43:47.617]   - Field: ‘state’
[17:43:47.617] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:47.618] - Launch lazy future ...
[17:43:47.618] Packages needed by the future expression (n = 0): <none>
[17:43:47.618] Packages needed by future strategies (n = 0): <none>
[17:43:47.618] {
[17:43:47.618]     {
[17:43:47.618]         {
[17:43:47.618]             ...future.startTime <- base::Sys.time()
[17:43:47.618]             {
[17:43:47.618]                 {
[17:43:47.618]                   {
[17:43:47.618]                     base::local({
[17:43:47.618]                       has_future <- base::requireNamespace("future", 
[17:43:47.618]                         quietly = TRUE)
[17:43:47.618]                       if (has_future) {
[17:43:47.618]                         ns <- base::getNamespace("future")
[17:43:47.618]                         version <- ns[[".package"]][["version"]]
[17:43:47.618]                         if (is.null(version)) 
[17:43:47.618]                           version <- utils::packageVersion("future")
[17:43:47.618]                       }
[17:43:47.618]                       else {
[17:43:47.618]                         version <- NULL
[17:43:47.618]                       }
[17:43:47.618]                       if (!has_future || version < "1.8.0") {
[17:43:47.618]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.618]                           "", base::R.version$version.string), 
[17:43:47.618]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:47.618]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.618]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.618]                             "release", "version")], collapse = " "), 
[17:43:47.618]                           hostname = base::Sys.info()[["nodename"]])
[17:43:47.618]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.618]                           info)
[17:43:47.618]                         info <- base::paste(info, collapse = "; ")
[17:43:47.618]                         if (!has_future) {
[17:43:47.618]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.618]                             info)
[17:43:47.618]                         }
[17:43:47.618]                         else {
[17:43:47.618]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.618]                             info, version)
[17:43:47.618]                         }
[17:43:47.618]                         base::stop(msg)
[17:43:47.618]                       }
[17:43:47.618]                     })
[17:43:47.618]                   }
[17:43:47.618]                   ...future.strategy.old <- future::plan("list")
[17:43:47.618]                   options(future.plan = NULL)
[17:43:47.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.618]                 }
[17:43:47.618]                 ...future.workdir <- getwd()
[17:43:47.618]             }
[17:43:47.618]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.618]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.618]         }
[17:43:47.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.618]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:47.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.618]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.618]             base::names(...future.oldOptions))
[17:43:47.618]     }
[17:43:47.618]     if (FALSE) {
[17:43:47.618]     }
[17:43:47.618]     else {
[17:43:47.618]         if (TRUE) {
[17:43:47.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.618]                 open = "w")
[17:43:47.618]         }
[17:43:47.618]         else {
[17:43:47.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.618]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.618]         }
[17:43:47.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.618]             base::sink(type = "output", split = FALSE)
[17:43:47.618]             base::close(...future.stdout)
[17:43:47.618]         }, add = TRUE)
[17:43:47.618]     }
[17:43:47.618]     ...future.frame <- base::sys.nframe()
[17:43:47.618]     ...future.conditions <- base::list()
[17:43:47.618]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.618]     if (FALSE) {
[17:43:47.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.618]     }
[17:43:47.618]     ...future.result <- base::tryCatch({
[17:43:47.618]         base::withCallingHandlers({
[17:43:47.618]             ...future.value <- base::withVisible(base::local({
[17:43:47.618]                 do.call(function(...) {
[17:43:47.618]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.618]                   if (!identical(...future.globals.maxSize.org, 
[17:43:47.618]                     ...future.globals.maxSize)) {
[17:43:47.618]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.618]                     on.exit(options(oopts), add = TRUE)
[17:43:47.618]                   }
[17:43:47.618]                   {
[17:43:47.618]                     lapply(seq_along(...future.elements_ii), 
[17:43:47.618]                       FUN = function(jj) {
[17:43:47.618]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.618]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:47.618]                           envir = globalenv(), inherits = FALSE)
[17:43:47.618]                         ...future.FUN(...future.X_jj, ...)
[17:43:47.618]                       })
[17:43:47.618]                   }
[17:43:47.618]                 }, args = future.call.arguments)
[17:43:47.618]             }))
[17:43:47.618]             future::FutureResult(value = ...future.value$value, 
[17:43:47.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.618]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.618]                     ...future.globalenv.names))
[17:43:47.618]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.618]         }, condition = base::local({
[17:43:47.618]             c <- base::c
[17:43:47.618]             inherits <- base::inherits
[17:43:47.618]             invokeRestart <- base::invokeRestart
[17:43:47.618]             length <- base::length
[17:43:47.618]             list <- base::list
[17:43:47.618]             seq.int <- base::seq.int
[17:43:47.618]             signalCondition <- base::signalCondition
[17:43:47.618]             sys.calls <- base::sys.calls
[17:43:47.618]             `[[` <- base::`[[`
[17:43:47.618]             `+` <- base::`+`
[17:43:47.618]             `<<-` <- base::`<<-`
[17:43:47.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.618]                   3L)]
[17:43:47.618]             }
[17:43:47.618]             function(cond) {
[17:43:47.618]                 is_error <- inherits(cond, "error")
[17:43:47.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.618]                   NULL)
[17:43:47.618]                 if (is_error) {
[17:43:47.618]                   sessionInformation <- function() {
[17:43:47.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.618]                       search = base::search(), system = base::Sys.info())
[17:43:47.618]                   }
[17:43:47.618]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.618]                     cond$call), session = sessionInformation(), 
[17:43:47.618]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.618]                   signalCondition(cond)
[17:43:47.618]                 }
[17:43:47.618]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[17:43:47.618]                   signal <- TRUE && inherits(cond, character(0))
[17:43:47.618]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.618]                   if (TRUE && !signal) {
[17:43:47.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.618]                     {
[17:43:47.618]                       inherits <- base::inherits
[17:43:47.618]                       invokeRestart <- base::invokeRestart
[17:43:47.618]                       is.null <- base::is.null
[17:43:47.618]                       muffled <- FALSE
[17:43:47.618]                       if (inherits(cond, "message")) {
[17:43:47.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.618]                         if (muffled) 
[17:43:47.618]                           invokeRestart("muffleMessage")
[17:43:47.618]                       }
[17:43:47.618]                       else if (inherits(cond, "warning")) {
[17:43:47.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.618]                         if (muffled) 
[17:43:47.618]                           invokeRestart("muffleWarning")
[17:43:47.618]                       }
[17:43:47.618]                       else if (inherits(cond, "condition")) {
[17:43:47.618]                         if (!is.null(pattern)) {
[17:43:47.618]                           computeRestarts <- base::computeRestarts
[17:43:47.618]                           grepl <- base::grepl
[17:43:47.618]                           restarts <- computeRestarts(cond)
[17:43:47.618]                           for (restart in restarts) {
[17:43:47.618]                             name <- restart$name
[17:43:47.618]                             if (is.null(name)) 
[17:43:47.618]                               next
[17:43:47.618]                             if (!grepl(pattern, name)) 
[17:43:47.618]                               next
[17:43:47.618]                             invokeRestart(restart)
[17:43:47.618]                             muffled <- TRUE
[17:43:47.618]                             break
[17:43:47.618]                           }
[17:43:47.618]                         }
[17:43:47.618]                       }
[17:43:47.618]                       invisible(muffled)
[17:43:47.618]                     }
[17:43:47.618]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.618]                   }
[17:43:47.618]                 }
[17:43:47.618]                 else {
[17:43:47.618]                   if (FALSE) {
[17:43:47.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.618]                     {
[17:43:47.618]                       inherits <- base::inherits
[17:43:47.618]                       invokeRestart <- base::invokeRestart
[17:43:47.618]                       is.null <- base::is.null
[17:43:47.618]                       muffled <- FALSE
[17:43:47.618]                       if (inherits(cond, "message")) {
[17:43:47.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.618]                         if (muffled) 
[17:43:47.618]                           invokeRestart("muffleMessage")
[17:43:47.618]                       }
[17:43:47.618]                       else if (inherits(cond, "warning")) {
[17:43:47.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.618]                         if (muffled) 
[17:43:47.618]                           invokeRestart("muffleWarning")
[17:43:47.618]                       }
[17:43:47.618]                       else if (inherits(cond, "condition")) {
[17:43:47.618]                         if (!is.null(pattern)) {
[17:43:47.618]                           computeRestarts <- base::computeRestarts
[17:43:47.618]                           grepl <- base::grepl
[17:43:47.618]                           restarts <- computeRestarts(cond)
[17:43:47.618]                           for (restart in restarts) {
[17:43:47.618]                             name <- restart$name
[17:43:47.618]                             if (is.null(name)) 
[17:43:47.618]                               next
[17:43:47.618]                             if (!grepl(pattern, name)) 
[17:43:47.618]                               next
[17:43:47.618]                             invokeRestart(restart)
[17:43:47.618]                             muffled <- TRUE
[17:43:47.618]                             break
[17:43:47.618]                           }
[17:43:47.618]                         }
[17:43:47.618]                       }
[17:43:47.618]                       invisible(muffled)
[17:43:47.618]                     }
[17:43:47.618]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.618]                   }
[17:43:47.618]                 }
[17:43:47.618]             }
[17:43:47.618]         }))
[17:43:47.618]     }, error = function(ex) {
[17:43:47.618]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.618]                 ...future.rng), started = ...future.startTime, 
[17:43:47.618]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.618]             version = "1.8"), class = "FutureResult")
[17:43:47.618]     }, finally = {
[17:43:47.618]         if (!identical(...future.workdir, getwd())) 
[17:43:47.618]             setwd(...future.workdir)
[17:43:47.618]         {
[17:43:47.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.618]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.618]             }
[17:43:47.618]             base::options(...future.oldOptions)
[17:43:47.618]             if (.Platform$OS.type == "windows") {
[17:43:47.618]                 old_names <- names(...future.oldEnvVars)
[17:43:47.618]                 envs <- base::Sys.getenv()
[17:43:47.618]                 names <- names(envs)
[17:43:47.618]                 common <- intersect(names, old_names)
[17:43:47.618]                 added <- setdiff(names, old_names)
[17:43:47.618]                 removed <- setdiff(old_names, names)
[17:43:47.618]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.618]                   envs[common]]
[17:43:47.618]                 NAMES <- toupper(changed)
[17:43:47.618]                 args <- list()
[17:43:47.618]                 for (kk in seq_along(NAMES)) {
[17:43:47.618]                   name <- changed[[kk]]
[17:43:47.618]                   NAME <- NAMES[[kk]]
[17:43:47.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.618]                     next
[17:43:47.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.618]                 }
[17:43:47.618]                 NAMES <- toupper(added)
[17:43:47.618]                 for (kk in seq_along(NAMES)) {
[17:43:47.618]                   name <- added[[kk]]
[17:43:47.618]                   NAME <- NAMES[[kk]]
[17:43:47.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.618]                     next
[17:43:47.618]                   args[[name]] <- ""
[17:43:47.618]                 }
[17:43:47.618]                 NAMES <- toupper(removed)
[17:43:47.618]                 for (kk in seq_along(NAMES)) {
[17:43:47.618]                   name <- removed[[kk]]
[17:43:47.618]                   NAME <- NAMES[[kk]]
[17:43:47.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.618]                     next
[17:43:47.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.618]                 }
[17:43:47.618]                 if (length(args) > 0) 
[17:43:47.618]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.618]             }
[17:43:47.618]             else {
[17:43:47.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.618]             }
[17:43:47.618]             {
[17:43:47.618]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.618]                   0L) {
[17:43:47.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.618]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.618]                   base::options(opts)
[17:43:47.618]                 }
[17:43:47.618]                 {
[17:43:47.618]                   {
[17:43:47.618]                     base::assign(".Random.seed", c(10407L, 1564885844L, 
[17:43:47.618]                     -547059031L, 473793448L, 1636779227L, -194360588L, 
[17:43:47.618]                     -903202944L), envir = base::globalenv(), 
[17:43:47.618]                       inherits = FALSE)
[17:43:47.618]                     NULL
[17:43:47.618]                   }
[17:43:47.618]                   options(future.plan = NULL)
[17:43:47.618]                   if (is.na(NA_character_)) 
[17:43:47.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.618]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:47.618]                     .init = FALSE)
[17:43:47.618]                 }
[17:43:47.618]             }
[17:43:47.618]         }
[17:43:47.618]     })
[17:43:47.618]     if (TRUE) {
[17:43:47.618]         base::sink(type = "output", split = FALSE)
[17:43:47.618]         if (TRUE) {
[17:43:47.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.618]         }
[17:43:47.618]         else {
[17:43:47.618]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.618]         }
[17:43:47.618]         base::close(...future.stdout)
[17:43:47.618]         ...future.stdout <- NULL
[17:43:47.618]     }
[17:43:47.618]     ...future.result$conditions <- ...future.conditions
[17:43:47.618]     ...future.result$finished <- base::Sys.time()
[17:43:47.618]     ...future.result
[17:43:47.618] }
[17:43:47.620] assign_globals() ...
[17:43:47.620] List of 5
[17:43:47.620]  $ future.call.arguments    : list()
[17:43:47.620]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.620]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[17:43:47.620]  $ ...future.elements_ii    :List of 2
[17:43:47.620]   ..$ : int [1:2] 1 3
[17:43:47.620]   ..$ : int [1:2] 2 4
[17:43:47.620]  $ ...future.seeds_ii       :List of 2
[17:43:47.620]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:43:47.620]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:43:47.620]  $ ...future.globals.maxSize: num Inf
[17:43:47.620]  - attr(*, "resolved")= logi FALSE
[17:43:47.620]  - attr(*, "total_size")= num NA
[17:43:47.620]  - attr(*, "where")=List of 5
[17:43:47.620]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:47.620]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:47.620]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:47.620]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:47.620]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:47.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.620]  - attr(*, "already-done")= logi TRUE
[17:43:47.625] - copied ‘future.call.arguments’ to environment
[17:43:47.625] - copied ‘...future.FUN’ to environment
[17:43:47.626] - copied ‘...future.elements_ii’ to environment
[17:43:47.626] - copied ‘...future.seeds_ii’ to environment
[17:43:47.626] - copied ‘...future.globals.maxSize’ to environment
[17:43:47.626] assign_globals() ... done
[17:43:47.626] plan(): Setting new future strategy stack:
[17:43:47.626] List of future strategies:
[17:43:47.626] 1. sequential:
[17:43:47.626]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.626]    - tweaked: FALSE
[17:43:47.626]    - call: NULL
[17:43:47.627] plan(): nbrOfWorkers() = 1
[17:43:47.627] plan(): Setting new future strategy stack:
[17:43:47.627] List of future strategies:
[17:43:47.627] 1. sequential:
[17:43:47.627]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.627]    - tweaked: FALSE
[17:43:47.627]    - call: plan(strategy)
[17:43:47.628] plan(): nbrOfWorkers() = 1
[17:43:47.628] SequentialFuture started (and completed)
[17:43:47.628] - Launch lazy future ... done
[17:43:47.628] run() for ‘SequentialFuture’ ... done
[17:43:47.628] Created future:
[17:43:47.628] SequentialFuture:
[17:43:47.628] Label: ‘future_apply-1’
[17:43:47.628] Expression:
[17:43:47.628] {
[17:43:47.628]     do.call(function(...) {
[17:43:47.628]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.628]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.628]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.628]             on.exit(options(oopts), add = TRUE)
[17:43:47.628]         }
[17:43:47.628]         {
[17:43:47.628]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.628]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.628]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:47.628]                   envir = globalenv(), inherits = FALSE)
[17:43:47.628]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.628]             })
[17:43:47.628]         }
[17:43:47.628]     }, args = future.call.arguments)
[17:43:47.628] }
[17:43:47.628] Lazy evaluation: FALSE
[17:43:47.628] Asynchronous evaluation: FALSE
[17:43:47.628] Local evaluation: TRUE
[17:43:47.628] Environment: R_GlobalEnv
[17:43:47.628] Capture standard output: TRUE
[17:43:47.628] Capture condition classes: <none>
[17:43:47.628] Globals: 5 objects totaling 35.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:47.628] Packages: <none>
[17:43:47.628] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:43:47.628] Resolved: TRUE
[17:43:47.628] Value: 112 bytes of class ‘list’
[17:43:47.628] Early signaling: FALSE
[17:43:47.628] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:47.628] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:47.629] Chunk #1 of 1 ... DONE
[17:43:47.629] Launching 1 futures (chunks) ... DONE
[17:43:47.629] Resolving 1 futures (chunks) ...
[17:43:47.630] resolve() on list ...
[17:43:47.630]  recursive: 0
[17:43:47.630]  length: 1
[17:43:47.630] 
[17:43:47.630] resolved() for ‘SequentialFuture’ ...
[17:43:47.630] - state: ‘finished’
[17:43:47.630] - run: TRUE
[17:43:47.630] - result: ‘FutureResult’
[17:43:47.630] resolved() for ‘SequentialFuture’ ... done
[17:43:47.630] Future #1
[17:43:47.631] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:43:47.631] - nx: 1
[17:43:47.631] - relay: TRUE
[17:43:47.631] - stdout: TRUE
[17:43:47.631] - signal: TRUE
[17:43:47.631] - resignal: FALSE
[17:43:47.631] - force: TRUE
[17:43:47.631] - relayed: [n=1] FALSE
[17:43:47.631] - queued futures: [n=1] FALSE
[17:43:47.631]  - until=1
[17:43:47.631]  - relaying element #1
[17:43:47.632] - relayed: [n=1] TRUE
[17:43:47.632] - queued futures: [n=1] TRUE
[17:43:47.632] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:43:47.632]  length: 0 (resolved future 1)
[17:43:47.632] Relaying remaining futures
[17:43:47.632] signalConditionsASAP(NULL, pos=0) ...
[17:43:47.632] - nx: 1
[17:43:47.632] - relay: TRUE
[17:43:47.632] - stdout: TRUE
[17:43:47.632] - signal: TRUE
[17:43:47.632] - resignal: FALSE
[17:43:47.633] - force: TRUE
[17:43:47.633] - relayed: [n=1] TRUE
[17:43:47.634] - queued futures: [n=1] TRUE
 - flush all
[17:43:47.634] - relayed: [n=1] TRUE
[17:43:47.634] - queued futures: [n=1] TRUE
[17:43:47.634] signalConditionsASAP(NULL, pos=0) ... done
[17:43:47.634] resolve() on list ... DONE
[17:43:47.634]  - Number of value chunks collected: 1
[17:43:47.635] Resolving 1 futures (chunks) ... DONE
[17:43:47.635] Reducing values from 1 chunks ...
[17:43:47.635]  - Number of values collected after concatenation: 2
[17:43:47.635]  - Number of values expected: 2
[17:43:47.635] Reducing values from 1 chunks ... DONE
[17:43:47.635] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[17:43:47.635] plan(): Setting new future strategy stack:
[17:43:47.635] List of future strategies:
[17:43:47.635] 1. sequential:
[17:43:47.635]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.635]    - tweaked: FALSE
[17:43:47.635]    - call: plan(sequential)
[17:43:47.636] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:43:47.636] plan(): Setting new future strategy stack:
[17:43:47.636] List of future strategies:
[17:43:47.636] 1. multicore:
[17:43:47.636]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:47.636]    - tweaked: FALSE
[17:43:47.636]    - call: plan(strategy)
[17:43:47.640] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[17:43:47.641] getGlobalsAndPackagesXApply() ...
[17:43:47.641]  - future.globals: TRUE
[17:43:47.641] getGlobalsAndPackages() ...
[17:43:47.641] Searching for globals...
[17:43:47.673] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:43:47.673] Searching for globals ... DONE
[17:43:47.674] Resolving globals: FALSE
[17:43:47.676] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:43:47.677] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:43:47.677] - globals: [1] ‘FUN’
[17:43:47.677] 
[17:43:47.677] getGlobalsAndPackages() ... DONE
[17:43:47.677]  - globals found/used: [n=1] ‘FUN’
[17:43:47.677]  - needed namespaces: [n=0] 
[17:43:47.677] Finding globals ... DONE
[17:43:47.678]  - use_args: TRUE
[17:43:47.678]  - Getting '...' globals ...
[17:43:47.678] resolve() on list ...
[17:43:47.678]  recursive: 0
[17:43:47.678]  length: 1
[17:43:47.678]  elements: ‘...’
[17:43:47.678]  length: 0 (resolved future 1)
[17:43:47.678] resolve() on list ... DONE
[17:43:47.678]    - '...' content: [n=0] 
[17:43:47.679] List of 1
[17:43:47.679]  $ ...: list()
[17:43:47.679]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.679]  - attr(*, "where")=List of 1
[17:43:47.679]   ..$ ...:<environment: 0x55dfd2e35ed0> 
[17:43:47.679]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.679]  - attr(*, "resolved")= logi TRUE
[17:43:47.679]  - attr(*, "total_size")= num NA
[17:43:47.681]  - Getting '...' globals ... DONE
[17:43:47.681] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:47.681] List of 2
[17:43:47.681]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:47.681]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:47.681]  $ ...          : list()
[17:43:47.681]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.681]  - attr(*, "where")=List of 2
[17:43:47.681]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:47.681]   ..$ ...          :<environment: 0x55dfd2e35ed0> 
[17:43:47.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.681]  - attr(*, "resolved")= logi FALSE
[17:43:47.681]  - attr(*, "total_size")= num 354224
[17:43:47.684] Packages to be attached in all futures: [n=0] 
[17:43:47.684] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.688] future_lapply() ...
[17:43:47.724] Number of chunks: 2
[17:43:47.724] getGlobalsAndPackagesXApply() ...
[17:43:47.724]  - future.globals: <name-value list> with names ‘list()’
[17:43:47.724]  - use_args: TRUE
[17:43:47.725] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:47.725] List of 2
[17:43:47.725]  $ ...          : list()
[17:43:47.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.725]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:47.725]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:47.725]  - attr(*, "where")=List of 2
[17:43:47.725]   ..$ ...          :<environment: 0x55dfd2e35ed0> 
[17:43:47.725]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:47.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.725]  - attr(*, "resolved")= logi FALSE
[17:43:47.725]  - attr(*, "total_size")= num NA
[17:43:47.728] Packages to be attached in all futures: [n=0] 
[17:43:47.728] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.729] Number of futures (= number of chunks): 2
[17:43:47.729] Launching 2 futures (chunks) ...
[17:43:47.729] Chunk #1 of 2 ...
[17:43:47.729]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:47.729]  - seeds: <none>
[17:43:47.729]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.729] getGlobalsAndPackages() ...
[17:43:47.729] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.730] Resolving globals: FALSE
[17:43:47.730] Tweak future expression to call with '...' arguments ...
[17:43:47.730] {
[17:43:47.730]     do.call(function(...) {
[17:43:47.730]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.730]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.730]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.730]             on.exit(options(oopts), add = TRUE)
[17:43:47.730]         }
[17:43:47.730]         {
[17:43:47.730]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.730]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.730]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.730]             })
[17:43:47.730]         }
[17:43:47.730]     }, args = future.call.arguments)
[17:43:47.730] }
[17:43:47.730] Tweak future expression to call with '...' arguments ... DONE
[17:43:47.730] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.731] 
[17:43:47.731] getGlobalsAndPackages() ... DONE
[17:43:47.731] run() for ‘Future’ ...
[17:43:47.731] - state: ‘created’
[17:43:47.731] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:47.735] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:47.735] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:47.735]   - Field: ‘label’
[17:43:47.735]   - Field: ‘local’
[17:43:47.735]   - Field: ‘owner’
[17:43:47.735]   - Field: ‘envir’
[17:43:47.736]   - Field: ‘workers’
[17:43:47.736]   - Field: ‘packages’
[17:43:47.736]   - Field: ‘gc’
[17:43:47.736]   - Field: ‘job’
[17:43:47.736]   - Field: ‘conditions’
[17:43:47.736]   - Field: ‘expr’
[17:43:47.736]   - Field: ‘uuid’
[17:43:47.736]   - Field: ‘seed’
[17:43:47.736]   - Field: ‘version’
[17:43:47.736]   - Field: ‘result’
[17:43:47.737]   - Field: ‘asynchronous’
[17:43:47.737]   - Field: ‘calls’
[17:43:47.737]   - Field: ‘globals’
[17:43:47.737]   - Field: ‘stdout’
[17:43:47.737]   - Field: ‘earlySignal’
[17:43:47.737]   - Field: ‘lazy’
[17:43:47.737]   - Field: ‘state’
[17:43:47.737] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:47.737] - Launch lazy future ...
[17:43:47.738] Packages needed by the future expression (n = 0): <none>
[17:43:47.738] Packages needed by future strategies (n = 0): <none>
[17:43:47.739] {
[17:43:47.739]     {
[17:43:47.739]         {
[17:43:47.739]             ...future.startTime <- base::Sys.time()
[17:43:47.739]             {
[17:43:47.739]                 {
[17:43:47.739]                   {
[17:43:47.739]                     {
[17:43:47.739]                       base::local({
[17:43:47.739]                         has_future <- base::requireNamespace("future", 
[17:43:47.739]                           quietly = TRUE)
[17:43:47.739]                         if (has_future) {
[17:43:47.739]                           ns <- base::getNamespace("future")
[17:43:47.739]                           version <- ns[[".package"]][["version"]]
[17:43:47.739]                           if (is.null(version)) 
[17:43:47.739]                             version <- utils::packageVersion("future")
[17:43:47.739]                         }
[17:43:47.739]                         else {
[17:43:47.739]                           version <- NULL
[17:43:47.739]                         }
[17:43:47.739]                         if (!has_future || version < "1.8.0") {
[17:43:47.739]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.739]                             "", base::R.version$version.string), 
[17:43:47.739]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:47.739]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.739]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.739]                               "release", "version")], collapse = " "), 
[17:43:47.739]                             hostname = base::Sys.info()[["nodename"]])
[17:43:47.739]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.739]                             info)
[17:43:47.739]                           info <- base::paste(info, collapse = "; ")
[17:43:47.739]                           if (!has_future) {
[17:43:47.739]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.739]                               info)
[17:43:47.739]                           }
[17:43:47.739]                           else {
[17:43:47.739]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.739]                               info, version)
[17:43:47.739]                           }
[17:43:47.739]                           base::stop(msg)
[17:43:47.739]                         }
[17:43:47.739]                       })
[17:43:47.739]                     }
[17:43:47.739]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:47.739]                     base::options(mc.cores = 1L)
[17:43:47.739]                   }
[17:43:47.739]                   ...future.strategy.old <- future::plan("list")
[17:43:47.739]                   options(future.plan = NULL)
[17:43:47.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.739]                 }
[17:43:47.739]                 ...future.workdir <- getwd()
[17:43:47.739]             }
[17:43:47.739]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.739]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.739]         }
[17:43:47.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.739]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:47.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.739]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.739]             base::names(...future.oldOptions))
[17:43:47.739]     }
[17:43:47.739]     if (FALSE) {
[17:43:47.739]     }
[17:43:47.739]     else {
[17:43:47.739]         if (TRUE) {
[17:43:47.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.739]                 open = "w")
[17:43:47.739]         }
[17:43:47.739]         else {
[17:43:47.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.739]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.739]         }
[17:43:47.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.739]             base::sink(type = "output", split = FALSE)
[17:43:47.739]             base::close(...future.stdout)
[17:43:47.739]         }, add = TRUE)
[17:43:47.739]     }
[17:43:47.739]     ...future.frame <- base::sys.nframe()
[17:43:47.739]     ...future.conditions <- base::list()
[17:43:47.739]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.739]     if (FALSE) {
[17:43:47.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.739]     }
[17:43:47.739]     ...future.result <- base::tryCatch({
[17:43:47.739]         base::withCallingHandlers({
[17:43:47.739]             ...future.value <- base::withVisible(base::local({
[17:43:47.739]                 withCallingHandlers({
[17:43:47.739]                   {
[17:43:47.739]                     do.call(function(...) {
[17:43:47.739]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.739]                       if (!identical(...future.globals.maxSize.org, 
[17:43:47.739]                         ...future.globals.maxSize)) {
[17:43:47.739]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.739]                         on.exit(options(oopts), add = TRUE)
[17:43:47.739]                       }
[17:43:47.739]                       {
[17:43:47.739]                         lapply(seq_along(...future.elements_ii), 
[17:43:47.739]                           FUN = function(jj) {
[17:43:47.739]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.739]                             ...future.FUN(...future.X_jj, ...)
[17:43:47.739]                           })
[17:43:47.739]                       }
[17:43:47.739]                     }, args = future.call.arguments)
[17:43:47.739]                   }
[17:43:47.739]                 }, immediateCondition = function(cond) {
[17:43:47.739]                   save_rds <- function (object, pathname, ...) 
[17:43:47.739]                   {
[17:43:47.739]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:47.739]                     if (file_test("-f", pathname_tmp)) {
[17:43:47.739]                       fi_tmp <- file.info(pathname_tmp)
[17:43:47.739]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:47.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:47.739]                         fi_tmp[["mtime"]])
[17:43:47.739]                     }
[17:43:47.739]                     tryCatch({
[17:43:47.739]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:47.739]                     }, error = function(ex) {
[17:43:47.739]                       msg <- conditionMessage(ex)
[17:43:47.739]                       fi_tmp <- file.info(pathname_tmp)
[17:43:47.739]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:47.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:47.739]                         fi_tmp[["mtime"]], msg)
[17:43:47.739]                       ex$message <- msg
[17:43:47.739]                       stop(ex)
[17:43:47.739]                     })
[17:43:47.739]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:47.739]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:47.739]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:47.739]                       fi_tmp <- file.info(pathname_tmp)
[17:43:47.739]                       fi <- file.info(pathname)
[17:43:47.739]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:47.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:47.739]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:47.739]                         fi[["size"]], fi[["mtime"]])
[17:43:47.739]                       stop(msg)
[17:43:47.739]                     }
[17:43:47.739]                     invisible(pathname)
[17:43:47.739]                   }
[17:43:47.739]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:47.739]                     rootPath = tempdir()) 
[17:43:47.739]                   {
[17:43:47.739]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:47.739]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:47.739]                       tmpdir = path, fileext = ".rds")
[17:43:47.739]                     save_rds(obj, file)
[17:43:47.739]                   }
[17:43:47.739]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:47.739]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.739]                   {
[17:43:47.739]                     inherits <- base::inherits
[17:43:47.739]                     invokeRestart <- base::invokeRestart
[17:43:47.739]                     is.null <- base::is.null
[17:43:47.739]                     muffled <- FALSE
[17:43:47.739]                     if (inherits(cond, "message")) {
[17:43:47.739]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:47.739]                       if (muffled) 
[17:43:47.739]                         invokeRestart("muffleMessage")
[17:43:47.739]                     }
[17:43:47.739]                     else if (inherits(cond, "warning")) {
[17:43:47.739]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:47.739]                       if (muffled) 
[17:43:47.739]                         invokeRestart("muffleWarning")
[17:43:47.739]                     }
[17:43:47.739]                     else if (inherits(cond, "condition")) {
[17:43:47.739]                       if (!is.null(pattern)) {
[17:43:47.739]                         computeRestarts <- base::computeRestarts
[17:43:47.739]                         grepl <- base::grepl
[17:43:47.739]                         restarts <- computeRestarts(cond)
[17:43:47.739]                         for (restart in restarts) {
[17:43:47.739]                           name <- restart$name
[17:43:47.739]                           if (is.null(name)) 
[17:43:47.739]                             next
[17:43:47.739]                           if (!grepl(pattern, name)) 
[17:43:47.739]                             next
[17:43:47.739]                           invokeRestart(restart)
[17:43:47.739]                           muffled <- TRUE
[17:43:47.739]                           break
[17:43:47.739]                         }
[17:43:47.739]                       }
[17:43:47.739]                     }
[17:43:47.739]                     invisible(muffled)
[17:43:47.739]                   }
[17:43:47.739]                   muffleCondition(cond)
[17:43:47.739]                 })
[17:43:47.739]             }))
[17:43:47.739]             future::FutureResult(value = ...future.value$value, 
[17:43:47.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.739]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.739]                     ...future.globalenv.names))
[17:43:47.739]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.739]         }, condition = base::local({
[17:43:47.739]             c <- base::c
[17:43:47.739]             inherits <- base::inherits
[17:43:47.739]             invokeRestart <- base::invokeRestart
[17:43:47.739]             length <- base::length
[17:43:47.739]             list <- base::list
[17:43:47.739]             seq.int <- base::seq.int
[17:43:47.739]             signalCondition <- base::signalCondition
[17:43:47.739]             sys.calls <- base::sys.calls
[17:43:47.739]             `[[` <- base::`[[`
[17:43:47.739]             `+` <- base::`+`
[17:43:47.739]             `<<-` <- base::`<<-`
[17:43:47.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.739]                   3L)]
[17:43:47.739]             }
[17:43:47.739]             function(cond) {
[17:43:47.739]                 is_error <- inherits(cond, "error")
[17:43:47.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.739]                   NULL)
[17:43:47.739]                 if (is_error) {
[17:43:47.739]                   sessionInformation <- function() {
[17:43:47.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.739]                       search = base::search(), system = base::Sys.info())
[17:43:47.739]                   }
[17:43:47.739]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.739]                     cond$call), session = sessionInformation(), 
[17:43:47.739]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.739]                   signalCondition(cond)
[17:43:47.739]                 }
[17:43:47.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:47.739]                 "immediateCondition"))) {
[17:43:47.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:47.739]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.739]                   if (TRUE && !signal) {
[17:43:47.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.739]                     {
[17:43:47.739]                       inherits <- base::inherits
[17:43:47.739]                       invokeRestart <- base::invokeRestart
[17:43:47.739]                       is.null <- base::is.null
[17:43:47.739]                       muffled <- FALSE
[17:43:47.739]                       if (inherits(cond, "message")) {
[17:43:47.739]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.739]                         if (muffled) 
[17:43:47.739]                           invokeRestart("muffleMessage")
[17:43:47.739]                       }
[17:43:47.739]                       else if (inherits(cond, "warning")) {
[17:43:47.739]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.739]                         if (muffled) 
[17:43:47.739]                           invokeRestart("muffleWarning")
[17:43:47.739]                       }
[17:43:47.739]                       else if (inherits(cond, "condition")) {
[17:43:47.739]                         if (!is.null(pattern)) {
[17:43:47.739]                           computeRestarts <- base::computeRestarts
[17:43:47.739]                           grepl <- base::grepl
[17:43:47.739]                           restarts <- computeRestarts(cond)
[17:43:47.739]                           for (restart in restarts) {
[17:43:47.739]                             name <- restart$name
[17:43:47.739]                             if (is.null(name)) 
[17:43:47.739]                               next
[17:43:47.739]                             if (!grepl(pattern, name)) 
[17:43:47.739]                               next
[17:43:47.739]                             invokeRestart(restart)
[17:43:47.739]                             muffled <- TRUE
[17:43:47.739]                             break
[17:43:47.739]                           }
[17:43:47.739]                         }
[17:43:47.739]                       }
[17:43:47.739]                       invisible(muffled)
[17:43:47.739]                     }
[17:43:47.739]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.739]                   }
[17:43:47.739]                 }
[17:43:47.739]                 else {
[17:43:47.739]                   if (TRUE) {
[17:43:47.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.739]                     {
[17:43:47.739]                       inherits <- base::inherits
[17:43:47.739]                       invokeRestart <- base::invokeRestart
[17:43:47.739]                       is.null <- base::is.null
[17:43:47.739]                       muffled <- FALSE
[17:43:47.739]                       if (inherits(cond, "message")) {
[17:43:47.739]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.739]                         if (muffled) 
[17:43:47.739]                           invokeRestart("muffleMessage")
[17:43:47.739]                       }
[17:43:47.739]                       else if (inherits(cond, "warning")) {
[17:43:47.739]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.739]                         if (muffled) 
[17:43:47.739]                           invokeRestart("muffleWarning")
[17:43:47.739]                       }
[17:43:47.739]                       else if (inherits(cond, "condition")) {
[17:43:47.739]                         if (!is.null(pattern)) {
[17:43:47.739]                           computeRestarts <- base::computeRestarts
[17:43:47.739]                           grepl <- base::grepl
[17:43:47.739]                           restarts <- computeRestarts(cond)
[17:43:47.739]                           for (restart in restarts) {
[17:43:47.739]                             name <- restart$name
[17:43:47.739]                             if (is.null(name)) 
[17:43:47.739]                               next
[17:43:47.739]                             if (!grepl(pattern, name)) 
[17:43:47.739]                               next
[17:43:47.739]                             invokeRestart(restart)
[17:43:47.739]                             muffled <- TRUE
[17:43:47.739]                             break
[17:43:47.739]                           }
[17:43:47.739]                         }
[17:43:47.739]                       }
[17:43:47.739]                       invisible(muffled)
[17:43:47.739]                     }
[17:43:47.739]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.739]                   }
[17:43:47.739]                 }
[17:43:47.739]             }
[17:43:47.739]         }))
[17:43:47.739]     }, error = function(ex) {
[17:43:47.739]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.739]                 ...future.rng), started = ...future.startTime, 
[17:43:47.739]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.739]             version = "1.8"), class = "FutureResult")
[17:43:47.739]     }, finally = {
[17:43:47.739]         if (!identical(...future.workdir, getwd())) 
[17:43:47.739]             setwd(...future.workdir)
[17:43:47.739]         {
[17:43:47.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.739]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.739]             }
[17:43:47.739]             base::options(...future.oldOptions)
[17:43:47.739]             if (.Platform$OS.type == "windows") {
[17:43:47.739]                 old_names <- names(...future.oldEnvVars)
[17:43:47.739]                 envs <- base::Sys.getenv()
[17:43:47.739]                 names <- names(envs)
[17:43:47.739]                 common <- intersect(names, old_names)
[17:43:47.739]                 added <- setdiff(names, old_names)
[17:43:47.739]                 removed <- setdiff(old_names, names)
[17:43:47.739]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.739]                   envs[common]]
[17:43:47.739]                 NAMES <- toupper(changed)
[17:43:47.739]                 args <- list()
[17:43:47.739]                 for (kk in seq_along(NAMES)) {
[17:43:47.739]                   name <- changed[[kk]]
[17:43:47.739]                   NAME <- NAMES[[kk]]
[17:43:47.739]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.739]                     next
[17:43:47.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.739]                 }
[17:43:47.739]                 NAMES <- toupper(added)
[17:43:47.739]                 for (kk in seq_along(NAMES)) {
[17:43:47.739]                   name <- added[[kk]]
[17:43:47.739]                   NAME <- NAMES[[kk]]
[17:43:47.739]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.739]                     next
[17:43:47.739]                   args[[name]] <- ""
[17:43:47.739]                 }
[17:43:47.739]                 NAMES <- toupper(removed)
[17:43:47.739]                 for (kk in seq_along(NAMES)) {
[17:43:47.739]                   name <- removed[[kk]]
[17:43:47.739]                   NAME <- NAMES[[kk]]
[17:43:47.739]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.739]                     next
[17:43:47.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.739]                 }
[17:43:47.739]                 if (length(args) > 0) 
[17:43:47.739]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.739]             }
[17:43:47.739]             else {
[17:43:47.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.739]             }
[17:43:47.739]             {
[17:43:47.739]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.739]                   0L) {
[17:43:47.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.739]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.739]                   base::options(opts)
[17:43:47.739]                 }
[17:43:47.739]                 {
[17:43:47.739]                   {
[17:43:47.739]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:47.739]                     NULL
[17:43:47.739]                   }
[17:43:47.739]                   options(future.plan = NULL)
[17:43:47.739]                   if (is.na(NA_character_)) 
[17:43:47.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.739]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:47.739]                     .init = FALSE)
[17:43:47.739]                 }
[17:43:47.739]             }
[17:43:47.739]         }
[17:43:47.739]     })
[17:43:47.739]     if (TRUE) {
[17:43:47.739]         base::sink(type = "output", split = FALSE)
[17:43:47.739]         if (TRUE) {
[17:43:47.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.739]         }
[17:43:47.739]         else {
[17:43:47.739]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.739]         }
[17:43:47.739]         base::close(...future.stdout)
[17:43:47.739]         ...future.stdout <- NULL
[17:43:47.739]     }
[17:43:47.739]     ...future.result$conditions <- ...future.conditions
[17:43:47.739]     ...future.result$finished <- base::Sys.time()
[17:43:47.739]     ...future.result
[17:43:47.739] }
[17:43:47.741] assign_globals() ...
[17:43:47.741] List of 5
[17:43:47.741]  $ future.call.arguments    : list()
[17:43:47.741]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.741]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:47.741]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:47.741]  $ ...future.elements_ii    :List of 1
[17:43:47.741]   ..$ : num [1:4] 1 3 1 7
[17:43:47.741]  $ ...future.seeds_ii       : NULL
[17:43:47.741]  $ ...future.globals.maxSize: num Inf
[17:43:47.741]  - attr(*, "resolved")= logi FALSE
[17:43:47.741]  - attr(*, "total_size")= num NA
[17:43:47.741]  - attr(*, "where")=List of 5
[17:43:47.741]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:47.741]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:47.741]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:47.741]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:47.741]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:47.741]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.741]  - attr(*, "already-done")= logi TRUE
[17:43:47.746] - copied ‘future.call.arguments’ to environment
[17:43:47.746] - copied ‘...future.FUN’ to environment
[17:43:47.746] - copied ‘...future.elements_ii’ to environment
[17:43:47.746] - copied ‘...future.seeds_ii’ to environment
[17:43:47.746] - copied ‘...future.globals.maxSize’ to environment
[17:43:47.746] assign_globals() ... done
[17:43:47.747] requestCore(): workers = 2
[17:43:47.750] MulticoreFuture started
[17:43:47.750] - Launch lazy future ... done
[17:43:47.750] plan(): Setting new future strategy stack:
[17:43:47.750] run() for ‘MulticoreFuture’ ... done
[17:43:47.751] Created future:
[17:43:47.750] List of future strategies:
[17:43:47.750] 1. sequential:
[17:43:47.750]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.750]    - tweaked: FALSE
[17:43:47.750]    - call: NULL
[17:43:47.752] plan(): nbrOfWorkers() = 1
[17:43:47.759] plan(): Setting new future strategy stack:
[17:43:47.760] List of future strategies:
[17:43:47.760] 1. multicore:
[17:43:47.760]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:47.760]    - tweaked: FALSE
[17:43:47.760]    - call: plan(strategy)
[17:43:47.766] plan(): nbrOfWorkers() = 2
[17:43:47.751] MulticoreFuture:
[17:43:47.751] Label: ‘future_apply-1’
[17:43:47.751] Expression:
[17:43:47.751] {
[17:43:47.751]     do.call(function(...) {
[17:43:47.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.751]             on.exit(options(oopts), add = TRUE)
[17:43:47.751]         }
[17:43:47.751]         {
[17:43:47.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.751]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.751]             })
[17:43:47.751]         }
[17:43:47.751]     }, args = future.call.arguments)
[17:43:47.751] }
[17:43:47.751] Lazy evaluation: FALSE
[17:43:47.751] Asynchronous evaluation: TRUE
[17:43:47.751] Local evaluation: TRUE
[17:43:47.751] Environment: R_GlobalEnv
[17:43:47.751] Capture standard output: TRUE
[17:43:47.751] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:47.751] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:47.751] Packages: <none>
[17:43:47.751] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:47.751] Resolved: TRUE
[17:43:47.751] Value: <not collected>
[17:43:47.751] Conditions captured: <none>
[17:43:47.751] Early signaling: FALSE
[17:43:47.751] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:47.751] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:47.768] Chunk #1 of 2 ... DONE
[17:43:47.768] Chunk #2 of 2 ...
[17:43:47.768]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:47.769]  - seeds: <none>
[17:43:47.769]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.769] getGlobalsAndPackages() ...
[17:43:47.769] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.770] Resolving globals: FALSE
[17:43:47.770] Tweak future expression to call with '...' arguments ...
[17:43:47.770] {
[17:43:47.770]     do.call(function(...) {
[17:43:47.770]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.770]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.770]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.770]             on.exit(options(oopts), add = TRUE)
[17:43:47.770]         }
[17:43:47.770]         {
[17:43:47.770]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.770]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.770]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.770]             })
[17:43:47.770]         }
[17:43:47.770]     }, args = future.call.arguments)
[17:43:47.770] }
[17:43:47.770] Tweak future expression to call with '...' arguments ... DONE
[17:43:47.771] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.771] 
[17:43:47.771] getGlobalsAndPackages() ... DONE
[17:43:47.772] run() for ‘Future’ ...
[17:43:47.772] - state: ‘created’
[17:43:47.772] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:47.777] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:47.777] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:47.777]   - Field: ‘label’
[17:43:47.777]   - Field: ‘local’
[17:43:47.777]   - Field: ‘owner’
[17:43:47.777]   - Field: ‘envir’
[17:43:47.778]   - Field: ‘workers’
[17:43:47.778]   - Field: ‘packages’
[17:43:47.778]   - Field: ‘gc’
[17:43:47.778]   - Field: ‘job’
[17:43:47.778]   - Field: ‘conditions’
[17:43:47.778]   - Field: ‘expr’
[17:43:47.778]   - Field: ‘uuid’
[17:43:47.778]   - Field: ‘seed’
[17:43:47.779]   - Field: ‘version’
[17:43:47.779]   - Field: ‘result’
[17:43:47.779]   - Field: ‘asynchronous’
[17:43:47.779]   - Field: ‘calls’
[17:43:47.779]   - Field: ‘globals’
[17:43:47.779]   - Field: ‘stdout’
[17:43:47.779]   - Field: ‘earlySignal’
[17:43:47.780]   - Field: ‘lazy’
[17:43:47.780]   - Field: ‘state’
[17:43:47.780] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:47.780] - Launch lazy future ...
[17:43:47.780] Packages needed by the future expression (n = 0): <none>
[17:43:47.780] Packages needed by future strategies (n = 0): <none>
[17:43:47.781] {
[17:43:47.781]     {
[17:43:47.781]         {
[17:43:47.781]             ...future.startTime <- base::Sys.time()
[17:43:47.781]             {
[17:43:47.781]                 {
[17:43:47.781]                   {
[17:43:47.781]                     {
[17:43:47.781]                       base::local({
[17:43:47.781]                         has_future <- base::requireNamespace("future", 
[17:43:47.781]                           quietly = TRUE)
[17:43:47.781]                         if (has_future) {
[17:43:47.781]                           ns <- base::getNamespace("future")
[17:43:47.781]                           version <- ns[[".package"]][["version"]]
[17:43:47.781]                           if (is.null(version)) 
[17:43:47.781]                             version <- utils::packageVersion("future")
[17:43:47.781]                         }
[17:43:47.781]                         else {
[17:43:47.781]                           version <- NULL
[17:43:47.781]                         }
[17:43:47.781]                         if (!has_future || version < "1.8.0") {
[17:43:47.781]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.781]                             "", base::R.version$version.string), 
[17:43:47.781]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:47.781]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.781]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.781]                               "release", "version")], collapse = " "), 
[17:43:47.781]                             hostname = base::Sys.info()[["nodename"]])
[17:43:47.781]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.781]                             info)
[17:43:47.781]                           info <- base::paste(info, collapse = "; ")
[17:43:47.781]                           if (!has_future) {
[17:43:47.781]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.781]                               info)
[17:43:47.781]                           }
[17:43:47.781]                           else {
[17:43:47.781]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.781]                               info, version)
[17:43:47.781]                           }
[17:43:47.781]                           base::stop(msg)
[17:43:47.781]                         }
[17:43:47.781]                       })
[17:43:47.781]                     }
[17:43:47.781]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:47.781]                     base::options(mc.cores = 1L)
[17:43:47.781]                   }
[17:43:47.781]                   ...future.strategy.old <- future::plan("list")
[17:43:47.781]                   options(future.plan = NULL)
[17:43:47.781]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.781]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.781]                 }
[17:43:47.781]                 ...future.workdir <- getwd()
[17:43:47.781]             }
[17:43:47.781]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.781]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.781]         }
[17:43:47.781]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.781]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:47.781]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.781]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.781]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.781]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.781]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.781]             base::names(...future.oldOptions))
[17:43:47.781]     }
[17:43:47.781]     if (FALSE) {
[17:43:47.781]     }
[17:43:47.781]     else {
[17:43:47.781]         if (TRUE) {
[17:43:47.781]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.781]                 open = "w")
[17:43:47.781]         }
[17:43:47.781]         else {
[17:43:47.781]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.781]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.781]         }
[17:43:47.781]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.781]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.781]             base::sink(type = "output", split = FALSE)
[17:43:47.781]             base::close(...future.stdout)
[17:43:47.781]         }, add = TRUE)
[17:43:47.781]     }
[17:43:47.781]     ...future.frame <- base::sys.nframe()
[17:43:47.781]     ...future.conditions <- base::list()
[17:43:47.781]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.781]     if (FALSE) {
[17:43:47.781]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.781]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.781]     }
[17:43:47.781]     ...future.result <- base::tryCatch({
[17:43:47.781]         base::withCallingHandlers({
[17:43:47.781]             ...future.value <- base::withVisible(base::local({
[17:43:47.781]                 withCallingHandlers({
[17:43:47.781]                   {
[17:43:47.781]                     do.call(function(...) {
[17:43:47.781]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.781]                       if (!identical(...future.globals.maxSize.org, 
[17:43:47.781]                         ...future.globals.maxSize)) {
[17:43:47.781]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.781]                         on.exit(options(oopts), add = TRUE)
[17:43:47.781]                       }
[17:43:47.781]                       {
[17:43:47.781]                         lapply(seq_along(...future.elements_ii), 
[17:43:47.781]                           FUN = function(jj) {
[17:43:47.781]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.781]                             ...future.FUN(...future.X_jj, ...)
[17:43:47.781]                           })
[17:43:47.781]                       }
[17:43:47.781]                     }, args = future.call.arguments)
[17:43:47.781]                   }
[17:43:47.781]                 }, immediateCondition = function(cond) {
[17:43:47.781]                   save_rds <- function (object, pathname, ...) 
[17:43:47.781]                   {
[17:43:47.781]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:47.781]                     if (file_test("-f", pathname_tmp)) {
[17:43:47.781]                       fi_tmp <- file.info(pathname_tmp)
[17:43:47.781]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:47.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:47.781]                         fi_tmp[["mtime"]])
[17:43:47.781]                     }
[17:43:47.781]                     tryCatch({
[17:43:47.781]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:47.781]                     }, error = function(ex) {
[17:43:47.781]                       msg <- conditionMessage(ex)
[17:43:47.781]                       fi_tmp <- file.info(pathname_tmp)
[17:43:47.781]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:47.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:47.781]                         fi_tmp[["mtime"]], msg)
[17:43:47.781]                       ex$message <- msg
[17:43:47.781]                       stop(ex)
[17:43:47.781]                     })
[17:43:47.781]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:47.781]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:47.781]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:47.781]                       fi_tmp <- file.info(pathname_tmp)
[17:43:47.781]                       fi <- file.info(pathname)
[17:43:47.781]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:47.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:47.781]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:47.781]                         fi[["size"]], fi[["mtime"]])
[17:43:47.781]                       stop(msg)
[17:43:47.781]                     }
[17:43:47.781]                     invisible(pathname)
[17:43:47.781]                   }
[17:43:47.781]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:47.781]                     rootPath = tempdir()) 
[17:43:47.781]                   {
[17:43:47.781]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:47.781]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:47.781]                       tmpdir = path, fileext = ".rds")
[17:43:47.781]                     save_rds(obj, file)
[17:43:47.781]                   }
[17:43:47.781]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:47.781]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.781]                   {
[17:43:47.781]                     inherits <- base::inherits
[17:43:47.781]                     invokeRestart <- base::invokeRestart
[17:43:47.781]                     is.null <- base::is.null
[17:43:47.781]                     muffled <- FALSE
[17:43:47.781]                     if (inherits(cond, "message")) {
[17:43:47.781]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:47.781]                       if (muffled) 
[17:43:47.781]                         invokeRestart("muffleMessage")
[17:43:47.781]                     }
[17:43:47.781]                     else if (inherits(cond, "warning")) {
[17:43:47.781]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:47.781]                       if (muffled) 
[17:43:47.781]                         invokeRestart("muffleWarning")
[17:43:47.781]                     }
[17:43:47.781]                     else if (inherits(cond, "condition")) {
[17:43:47.781]                       if (!is.null(pattern)) {
[17:43:47.781]                         computeRestarts <- base::computeRestarts
[17:43:47.781]                         grepl <- base::grepl
[17:43:47.781]                         restarts <- computeRestarts(cond)
[17:43:47.781]                         for (restart in restarts) {
[17:43:47.781]                           name <- restart$name
[17:43:47.781]                           if (is.null(name)) 
[17:43:47.781]                             next
[17:43:47.781]                           if (!grepl(pattern, name)) 
[17:43:47.781]                             next
[17:43:47.781]                           invokeRestart(restart)
[17:43:47.781]                           muffled <- TRUE
[17:43:47.781]                           break
[17:43:47.781]                         }
[17:43:47.781]                       }
[17:43:47.781]                     }
[17:43:47.781]                     invisible(muffled)
[17:43:47.781]                   }
[17:43:47.781]                   muffleCondition(cond)
[17:43:47.781]                 })
[17:43:47.781]             }))
[17:43:47.781]             future::FutureResult(value = ...future.value$value, 
[17:43:47.781]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.781]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.781]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.781]                     ...future.globalenv.names))
[17:43:47.781]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.781]         }, condition = base::local({
[17:43:47.781]             c <- base::c
[17:43:47.781]             inherits <- base::inherits
[17:43:47.781]             invokeRestart <- base::invokeRestart
[17:43:47.781]             length <- base::length
[17:43:47.781]             list <- base::list
[17:43:47.781]             seq.int <- base::seq.int
[17:43:47.781]             signalCondition <- base::signalCondition
[17:43:47.781]             sys.calls <- base::sys.calls
[17:43:47.781]             `[[` <- base::`[[`
[17:43:47.781]             `+` <- base::`+`
[17:43:47.781]             `<<-` <- base::`<<-`
[17:43:47.781]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.781]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.781]                   3L)]
[17:43:47.781]             }
[17:43:47.781]             function(cond) {
[17:43:47.781]                 is_error <- inherits(cond, "error")
[17:43:47.781]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.781]                   NULL)
[17:43:47.781]                 if (is_error) {
[17:43:47.781]                   sessionInformation <- function() {
[17:43:47.781]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.781]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.781]                       search = base::search(), system = base::Sys.info())
[17:43:47.781]                   }
[17:43:47.781]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.781]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.781]                     cond$call), session = sessionInformation(), 
[17:43:47.781]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.781]                   signalCondition(cond)
[17:43:47.781]                 }
[17:43:47.781]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:47.781]                 "immediateCondition"))) {
[17:43:47.781]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:47.781]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.781]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.781]                   if (TRUE && !signal) {
[17:43:47.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.781]                     {
[17:43:47.781]                       inherits <- base::inherits
[17:43:47.781]                       invokeRestart <- base::invokeRestart
[17:43:47.781]                       is.null <- base::is.null
[17:43:47.781]                       muffled <- FALSE
[17:43:47.781]                       if (inherits(cond, "message")) {
[17:43:47.781]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.781]                         if (muffled) 
[17:43:47.781]                           invokeRestart("muffleMessage")
[17:43:47.781]                       }
[17:43:47.781]                       else if (inherits(cond, "warning")) {
[17:43:47.781]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.781]                         if (muffled) 
[17:43:47.781]                           invokeRestart("muffleWarning")
[17:43:47.781]                       }
[17:43:47.781]                       else if (inherits(cond, "condition")) {
[17:43:47.781]                         if (!is.null(pattern)) {
[17:43:47.781]                           computeRestarts <- base::computeRestarts
[17:43:47.781]                           grepl <- base::grepl
[17:43:47.781]                           restarts <- computeRestarts(cond)
[17:43:47.781]                           for (restart in restarts) {
[17:43:47.781]                             name <- restart$name
[17:43:47.781]                             if (is.null(name)) 
[17:43:47.781]                               next
[17:43:47.781]                             if (!grepl(pattern, name)) 
[17:43:47.781]                               next
[17:43:47.781]                             invokeRestart(restart)
[17:43:47.781]                             muffled <- TRUE
[17:43:47.781]                             break
[17:43:47.781]                           }
[17:43:47.781]                         }
[17:43:47.781]                       }
[17:43:47.781]                       invisible(muffled)
[17:43:47.781]                     }
[17:43:47.781]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.781]                   }
[17:43:47.781]                 }
[17:43:47.781]                 else {
[17:43:47.781]                   if (TRUE) {
[17:43:47.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.781]                     {
[17:43:47.781]                       inherits <- base::inherits
[17:43:47.781]                       invokeRestart <- base::invokeRestart
[17:43:47.781]                       is.null <- base::is.null
[17:43:47.781]                       muffled <- FALSE
[17:43:47.781]                       if (inherits(cond, "message")) {
[17:43:47.781]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.781]                         if (muffled) 
[17:43:47.781]                           invokeRestart("muffleMessage")
[17:43:47.781]                       }
[17:43:47.781]                       else if (inherits(cond, "warning")) {
[17:43:47.781]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.781]                         if (muffled) 
[17:43:47.781]                           invokeRestart("muffleWarning")
[17:43:47.781]                       }
[17:43:47.781]                       else if (inherits(cond, "condition")) {
[17:43:47.781]                         if (!is.null(pattern)) {
[17:43:47.781]                           computeRestarts <- base::computeRestarts
[17:43:47.781]                           grepl <- base::grepl
[17:43:47.781]                           restarts <- computeRestarts(cond)
[17:43:47.781]                           for (restart in restarts) {
[17:43:47.781]                             name <- restart$name
[17:43:47.781]                             if (is.null(name)) 
[17:43:47.781]                               next
[17:43:47.781]                             if (!grepl(pattern, name)) 
[17:43:47.781]                               next
[17:43:47.781]                             invokeRestart(restart)
[17:43:47.781]                             muffled <- TRUE
[17:43:47.781]                             break
[17:43:47.781]                           }
[17:43:47.781]                         }
[17:43:47.781]                       }
[17:43:47.781]                       invisible(muffled)
[17:43:47.781]                     }
[17:43:47.781]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.781]                   }
[17:43:47.781]                 }
[17:43:47.781]             }
[17:43:47.781]         }))
[17:43:47.781]     }, error = function(ex) {
[17:43:47.781]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.781]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.781]                 ...future.rng), started = ...future.startTime, 
[17:43:47.781]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.781]             version = "1.8"), class = "FutureResult")
[17:43:47.781]     }, finally = {
[17:43:47.781]         if (!identical(...future.workdir, getwd())) 
[17:43:47.781]             setwd(...future.workdir)
[17:43:47.781]         {
[17:43:47.781]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.781]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.781]             }
[17:43:47.781]             base::options(...future.oldOptions)
[17:43:47.781]             if (.Platform$OS.type == "windows") {
[17:43:47.781]                 old_names <- names(...future.oldEnvVars)
[17:43:47.781]                 envs <- base::Sys.getenv()
[17:43:47.781]                 names <- names(envs)
[17:43:47.781]                 common <- intersect(names, old_names)
[17:43:47.781]                 added <- setdiff(names, old_names)
[17:43:47.781]                 removed <- setdiff(old_names, names)
[17:43:47.781]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.781]                   envs[common]]
[17:43:47.781]                 NAMES <- toupper(changed)
[17:43:47.781]                 args <- list()
[17:43:47.781]                 for (kk in seq_along(NAMES)) {
[17:43:47.781]                   name <- changed[[kk]]
[17:43:47.781]                   NAME <- NAMES[[kk]]
[17:43:47.781]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.781]                     next
[17:43:47.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.781]                 }
[17:43:47.781]                 NAMES <- toupper(added)
[17:43:47.781]                 for (kk in seq_along(NAMES)) {
[17:43:47.781]                   name <- added[[kk]]
[17:43:47.781]                   NAME <- NAMES[[kk]]
[17:43:47.781]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.781]                     next
[17:43:47.781]                   args[[name]] <- ""
[17:43:47.781]                 }
[17:43:47.781]                 NAMES <- toupper(removed)
[17:43:47.781]                 for (kk in seq_along(NAMES)) {
[17:43:47.781]                   name <- removed[[kk]]
[17:43:47.781]                   NAME <- NAMES[[kk]]
[17:43:47.781]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.781]                     next
[17:43:47.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.781]                 }
[17:43:47.781]                 if (length(args) > 0) 
[17:43:47.781]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.781]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.781]             }
[17:43:47.781]             else {
[17:43:47.781]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.781]             }
[17:43:47.781]             {
[17:43:47.781]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.781]                   0L) {
[17:43:47.781]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.781]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.781]                   base::options(opts)
[17:43:47.781]                 }
[17:43:47.781]                 {
[17:43:47.781]                   {
[17:43:47.781]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:47.781]                     NULL
[17:43:47.781]                   }
[17:43:47.781]                   options(future.plan = NULL)
[17:43:47.781]                   if (is.na(NA_character_)) 
[17:43:47.781]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.781]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.781]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:47.781]                     .init = FALSE)
[17:43:47.781]                 }
[17:43:47.781]             }
[17:43:47.781]         }
[17:43:47.781]     })
[17:43:47.781]     if (TRUE) {
[17:43:47.781]         base::sink(type = "output", split = FALSE)
[17:43:47.781]         if (TRUE) {
[17:43:47.781]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.781]         }
[17:43:47.781]         else {
[17:43:47.781]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.781]         }
[17:43:47.781]         base::close(...future.stdout)
[17:43:47.781]         ...future.stdout <- NULL
[17:43:47.781]     }
[17:43:47.781]     ...future.result$conditions <- ...future.conditions
[17:43:47.781]     ...future.result$finished <- base::Sys.time()
[17:43:47.781]     ...future.result
[17:43:47.781] }
[17:43:47.784] assign_globals() ...
[17:43:47.784] List of 5
[17:43:47.784]  $ future.call.arguments    : list()
[17:43:47.784]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.784]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:47.784]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:47.784]  $ ...future.elements_ii    :List of 1
[17:43:47.784]   ..$ : num [1:4] 2 4 6 8
[17:43:47.784]  $ ...future.seeds_ii       : NULL
[17:43:47.784]  $ ...future.globals.maxSize: num Inf
[17:43:47.784]  - attr(*, "resolved")= logi FALSE
[17:43:47.784]  - attr(*, "total_size")= num NA
[17:43:47.784]  - attr(*, "where")=List of 5
[17:43:47.784]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:47.784]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:47.784]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:47.784]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:47.784]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:47.784]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.784]  - attr(*, "already-done")= logi TRUE
[17:43:47.790] - copied ‘future.call.arguments’ to environment
[17:43:47.791] - copied ‘...future.FUN’ to environment
[17:43:47.791] - copied ‘...future.elements_ii’ to environment
[17:43:47.791] - copied ‘...future.seeds_ii’ to environment
[17:43:47.791] - copied ‘...future.globals.maxSize’ to environment
[17:43:47.791] assign_globals() ... done
[17:43:47.791] requestCore(): workers = 2
[17:43:47.796] MulticoreFuture started
[17:43:47.797] - Launch lazy future ... done
[17:43:47.797] run() for ‘MulticoreFuture’ ... done
[17:43:47.797] Created future:
[17:43:47.797] plan(): Setting new future strategy stack:
[17:43:47.798] List of future strategies:
[17:43:47.798] 1. sequential:
[17:43:47.798]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.798]    - tweaked: FALSE
[17:43:47.798]    - call: NULL
[17:43:47.799] plan(): nbrOfWorkers() = 1
[17:43:47.801] plan(): Setting new future strategy stack:
[17:43:47.801] List of future strategies:
[17:43:47.801] 1. multicore:
[17:43:47.801]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:47.801]    - tweaked: FALSE
[17:43:47.801]    - call: plan(strategy)
[17:43:47.806] plan(): nbrOfWorkers() = 2
[17:43:47.797] MulticoreFuture:
[17:43:47.797] Label: ‘future_apply-2’
[17:43:47.797] Expression:
[17:43:47.797] {
[17:43:47.797]     do.call(function(...) {
[17:43:47.797]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.797]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.797]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.797]             on.exit(options(oopts), add = TRUE)
[17:43:47.797]         }
[17:43:47.797]         {
[17:43:47.797]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.797]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.797]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.797]             })
[17:43:47.797]         }
[17:43:47.797]     }, args = future.call.arguments)
[17:43:47.797] }
[17:43:47.797] Lazy evaluation: FALSE
[17:43:47.797] Asynchronous evaluation: TRUE
[17:43:47.797] Local evaluation: TRUE
[17:43:47.797] Environment: R_GlobalEnv
[17:43:47.797] Capture standard output: TRUE
[17:43:47.797] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:47.797] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:47.797] Packages: <none>
[17:43:47.797] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:47.797] Resolved: TRUE
[17:43:47.797] Value: <not collected>
[17:43:47.797] Conditions captured: <none>
[17:43:47.797] Early signaling: FALSE
[17:43:47.797] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:47.797] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:47.807] Chunk #2 of 2 ... DONE
[17:43:47.807] Launching 2 futures (chunks) ... DONE
[17:43:47.807] Resolving 2 futures (chunks) ...
[17:43:47.807] resolve() on list ...
[17:43:47.808]  recursive: 0
[17:43:47.808]  length: 2
[17:43:47.808] 
[17:43:47.808] Future #1
[17:43:47.809] result() for MulticoreFuture ...
[17:43:47.811] result() for MulticoreFuture ...
[17:43:47.811] result() for MulticoreFuture ... done
[17:43:47.811] result() for MulticoreFuture ... done
[17:43:47.811] result() for MulticoreFuture ...
[17:43:47.811] result() for MulticoreFuture ... done
[17:43:47.812] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:47.812] - nx: 2
[17:43:47.812] - relay: TRUE
[17:43:47.812] - stdout: TRUE
[17:43:47.812] - signal: TRUE
[17:43:47.812] - resignal: FALSE
[17:43:47.813] - force: TRUE
[17:43:47.813] - relayed: [n=2] FALSE, FALSE
[17:43:47.813] - queued futures: [n=2] FALSE, FALSE
[17:43:47.813]  - until=1
[17:43:47.813]  - relaying element #1
[17:43:47.813] result() for MulticoreFuture ...
[17:43:47.814] result() for MulticoreFuture ... done
[17:43:47.814] result() for MulticoreFuture ...
[17:43:47.814] result() for MulticoreFuture ... done
[17:43:47.814] result() for MulticoreFuture ...
[17:43:47.814] result() for MulticoreFuture ... done
[17:43:47.815] result() for MulticoreFuture ...
[17:43:47.815] result() for MulticoreFuture ... done
[17:43:47.815] - relayed: [n=2] TRUE, FALSE
[17:43:47.815] - queued futures: [n=2] TRUE, FALSE
[17:43:47.815] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:47.815]  length: 1 (resolved future 1)
[17:43:47.816] Future #2
[17:43:47.816] result() for MulticoreFuture ...
[17:43:47.820] result() for MulticoreFuture ...
[17:43:47.821] result() for MulticoreFuture ... done
[17:43:47.821] result() for MulticoreFuture ... done
[17:43:47.821] result() for MulticoreFuture ...
[17:43:47.822] result() for MulticoreFuture ... done
[17:43:47.822] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:47.822] - nx: 2
[17:43:47.822] - relay: TRUE
[17:43:47.822] - stdout: TRUE
[17:43:47.822] - signal: TRUE
[17:43:47.823] - resignal: FALSE
[17:43:47.823] - force: TRUE
[17:43:47.823] - relayed: [n=2] TRUE, FALSE
[17:43:47.823] - queued futures: [n=2] TRUE, FALSE
[17:43:47.823]  - until=2
[17:43:47.823]  - relaying element #2
[17:43:47.823] result() for MulticoreFuture ...
[17:43:47.823] result() for MulticoreFuture ... done
[17:43:47.824] result() for MulticoreFuture ...
[17:43:47.824] result() for MulticoreFuture ... done
[17:43:47.824] result() for MulticoreFuture ...
[17:43:47.824] result() for MulticoreFuture ... done
[17:43:47.824] result() for MulticoreFuture ...
[17:43:47.824] result() for MulticoreFuture ... done
[17:43:47.824] - relayed: [n=2] TRUE, TRUE
[17:43:47.824] - queued futures: [n=2] TRUE, TRUE
[17:43:47.825] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:47.825]  length: 0 (resolved future 2)
[17:43:47.825] Relaying remaining futures
[17:43:47.825] signalConditionsASAP(NULL, pos=0) ...
[17:43:47.825] - nx: 2
[17:43:47.825] - relay: TRUE
[17:43:47.825] - stdout: TRUE
[17:43:47.825] - signal: TRUE
[17:43:47.825] - resignal: FALSE
[17:43:47.826] - force: TRUE
[17:43:47.826] - relayed: [n=2] TRUE, TRUE
[17:43:47.826] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:47.826] - relayed: [n=2] TRUE, TRUE
[17:43:47.826] - queued futures: [n=2] TRUE, TRUE
[17:43:47.826] signalConditionsASAP(NULL, pos=0) ... done
[17:43:47.826] resolve() on list ... DONE
[17:43:47.826] result() for MulticoreFuture ...
[17:43:47.826] result() for MulticoreFuture ... done
[17:43:47.827] result() for MulticoreFuture ...
[17:43:47.827] result() for MulticoreFuture ... done
[17:43:47.827] result() for MulticoreFuture ...
[17:43:47.827] result() for MulticoreFuture ... done
[17:43:47.827] result() for MulticoreFuture ...
[17:43:47.827] result() for MulticoreFuture ... done
[17:43:47.827]  - Number of value chunks collected: 2
[17:43:47.827] Resolving 2 futures (chunks) ... DONE
[17:43:47.827] Reducing values from 2 chunks ...
[17:43:47.828]  - Number of values collected after concatenation: 2
[17:43:47.828]  - Number of values expected: 2
[17:43:47.828] Reducing values from 2 chunks ... DONE
[17:43:47.828] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:43:47.828] getGlobalsAndPackagesXApply() ...
[17:43:47.829]  - future.globals: TRUE
[17:43:47.829] getGlobalsAndPackages() ...
[17:43:47.829] Searching for globals...
[17:43:47.866] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:43:47.866] Searching for globals ... DONE
[17:43:47.866] Resolving globals: FALSE
[17:43:47.868] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:43:47.868] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:43:47.868] - globals: [1] ‘FUN’
[17:43:47.868] 
[17:43:47.868] getGlobalsAndPackages() ... DONE
[17:43:47.869]  - globals found/used: [n=1] ‘FUN’
[17:43:47.869]  - needed namespaces: [n=0] 
[17:43:47.869] Finding globals ... DONE
[17:43:47.869]  - use_args: TRUE
[17:43:47.869]  - Getting '...' globals ...
[17:43:47.869] resolve() on list ...
[17:43:47.869]  recursive: 0
[17:43:47.869]  length: 1
[17:43:47.870]  elements: ‘...’
[17:43:47.870]  length: 0 (resolved future 1)
[17:43:47.870] resolve() on list ... DONE
[17:43:47.870]    - '...' content: [n=0] 
[17:43:47.870] List of 1
[17:43:47.870]  $ ...: list()
[17:43:47.870]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.870]  - attr(*, "where")=List of 1
[17:43:47.870]   ..$ ...:<environment: 0x55dfd28b46b8> 
[17:43:47.870]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.870]  - attr(*, "resolved")= logi TRUE
[17:43:47.870]  - attr(*, "total_size")= num NA
[17:43:47.873]  - Getting '...' globals ... DONE
[17:43:47.873] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:47.873] List of 2
[17:43:47.873]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:47.873]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:47.873]  $ ...          : list()
[17:43:47.873]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.873]  - attr(*, "where")=List of 2
[17:43:47.873]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:47.873]   ..$ ...          :<environment: 0x55dfd28b46b8> 
[17:43:47.873]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.873]  - attr(*, "resolved")= logi FALSE
[17:43:47.873]  - attr(*, "total_size")= num 354224
[17:43:47.876] Packages to be attached in all futures: [n=0] 
[17:43:47.876] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.880] future_lapply() ...
[17:43:47.916] Number of chunks: 2
[17:43:47.916] getGlobalsAndPackagesXApply() ...
[17:43:47.916]  - future.globals: <name-value list> with names ‘list()’
[17:43:47.916]  - use_args: TRUE
[17:43:47.917] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:47.917] List of 2
[17:43:47.917]  $ ...          : list()
[17:43:47.917]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.917]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:47.917]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:47.917]  - attr(*, "where")=List of 2
[17:43:47.917]   ..$ ...          :<environment: 0x55dfd28b46b8> 
[17:43:47.917]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:47.917]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.917]  - attr(*, "resolved")= logi FALSE
[17:43:47.917]  - attr(*, "total_size")= num NA
[17:43:47.920] Packages to be attached in all futures: [n=0] 
[17:43:47.920] getGlobalsAndPackagesXApply() ... DONE
[17:43:47.921] Number of futures (= number of chunks): 2
[17:43:47.921] Launching 2 futures (chunks) ...
[17:43:47.921] Chunk #1 of 2 ...
[17:43:47.921]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:47.921]  - seeds: <none>
[17:43:47.921]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.921] getGlobalsAndPackages() ...
[17:43:47.921] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.921] Resolving globals: FALSE
[17:43:47.922] Tweak future expression to call with '...' arguments ...
[17:43:47.922] {
[17:43:47.922]     do.call(function(...) {
[17:43:47.922]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.922]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.922]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.922]             on.exit(options(oopts), add = TRUE)
[17:43:47.922]         }
[17:43:47.922]         {
[17:43:47.922]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.922]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.922]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.922]             })
[17:43:47.922]         }
[17:43:47.922]     }, args = future.call.arguments)
[17:43:47.922] }
[17:43:47.922] Tweak future expression to call with '...' arguments ... DONE
[17:43:47.922] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.923] 
[17:43:47.923] getGlobalsAndPackages() ... DONE
[17:43:47.923] run() for ‘Future’ ...
[17:43:47.923] - state: ‘created’
[17:43:47.923] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:47.927] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:47.927] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:47.927]   - Field: ‘label’
[17:43:47.927]   - Field: ‘local’
[17:43:47.927]   - Field: ‘owner’
[17:43:47.927]   - Field: ‘envir’
[17:43:47.927]   - Field: ‘workers’
[17:43:47.927]   - Field: ‘packages’
[17:43:47.928]   - Field: ‘gc’
[17:43:47.928]   - Field: ‘job’
[17:43:47.928]   - Field: ‘conditions’
[17:43:47.928]   - Field: ‘expr’
[17:43:47.928]   - Field: ‘uuid’
[17:43:47.928]   - Field: ‘seed’
[17:43:47.928]   - Field: ‘version’
[17:43:47.928]   - Field: ‘result’
[17:43:47.928]   - Field: ‘asynchronous’
[17:43:47.930]   - Field: ‘calls’
[17:43:47.930]   - Field: ‘globals’
[17:43:47.930]   - Field: ‘stdout’
[17:43:47.930]   - Field: ‘earlySignal’
[17:43:47.930]   - Field: ‘lazy’
[17:43:47.931]   - Field: ‘state’
[17:43:47.931] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:47.931] - Launch lazy future ...
[17:43:47.931] Packages needed by the future expression (n = 0): <none>
[17:43:47.931] Packages needed by future strategies (n = 0): <none>
[17:43:47.932] {
[17:43:47.932]     {
[17:43:47.932]         {
[17:43:47.932]             ...future.startTime <- base::Sys.time()
[17:43:47.932]             {
[17:43:47.932]                 {
[17:43:47.932]                   {
[17:43:47.932]                     {
[17:43:47.932]                       base::local({
[17:43:47.932]                         has_future <- base::requireNamespace("future", 
[17:43:47.932]                           quietly = TRUE)
[17:43:47.932]                         if (has_future) {
[17:43:47.932]                           ns <- base::getNamespace("future")
[17:43:47.932]                           version <- ns[[".package"]][["version"]]
[17:43:47.932]                           if (is.null(version)) 
[17:43:47.932]                             version <- utils::packageVersion("future")
[17:43:47.932]                         }
[17:43:47.932]                         else {
[17:43:47.932]                           version <- NULL
[17:43:47.932]                         }
[17:43:47.932]                         if (!has_future || version < "1.8.0") {
[17:43:47.932]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.932]                             "", base::R.version$version.string), 
[17:43:47.932]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:47.932]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.932]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.932]                               "release", "version")], collapse = " "), 
[17:43:47.932]                             hostname = base::Sys.info()[["nodename"]])
[17:43:47.932]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.932]                             info)
[17:43:47.932]                           info <- base::paste(info, collapse = "; ")
[17:43:47.932]                           if (!has_future) {
[17:43:47.932]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.932]                               info)
[17:43:47.932]                           }
[17:43:47.932]                           else {
[17:43:47.932]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.932]                               info, version)
[17:43:47.932]                           }
[17:43:47.932]                           base::stop(msg)
[17:43:47.932]                         }
[17:43:47.932]                       })
[17:43:47.932]                     }
[17:43:47.932]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:47.932]                     base::options(mc.cores = 1L)
[17:43:47.932]                   }
[17:43:47.932]                   ...future.strategy.old <- future::plan("list")
[17:43:47.932]                   options(future.plan = NULL)
[17:43:47.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.932]                 }
[17:43:47.932]                 ...future.workdir <- getwd()
[17:43:47.932]             }
[17:43:47.932]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.932]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.932]         }
[17:43:47.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.932]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:47.932]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.932]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.932]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.932]             base::names(...future.oldOptions))
[17:43:47.932]     }
[17:43:47.932]     if (FALSE) {
[17:43:47.932]     }
[17:43:47.932]     else {
[17:43:47.932]         if (TRUE) {
[17:43:47.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.932]                 open = "w")
[17:43:47.932]         }
[17:43:47.932]         else {
[17:43:47.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.932]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.932]         }
[17:43:47.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.932]             base::sink(type = "output", split = FALSE)
[17:43:47.932]             base::close(...future.stdout)
[17:43:47.932]         }, add = TRUE)
[17:43:47.932]     }
[17:43:47.932]     ...future.frame <- base::sys.nframe()
[17:43:47.932]     ...future.conditions <- base::list()
[17:43:47.932]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.932]     if (FALSE) {
[17:43:47.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.932]     }
[17:43:47.932]     ...future.result <- base::tryCatch({
[17:43:47.932]         base::withCallingHandlers({
[17:43:47.932]             ...future.value <- base::withVisible(base::local({
[17:43:47.932]                 withCallingHandlers({
[17:43:47.932]                   {
[17:43:47.932]                     do.call(function(...) {
[17:43:47.932]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.932]                       if (!identical(...future.globals.maxSize.org, 
[17:43:47.932]                         ...future.globals.maxSize)) {
[17:43:47.932]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.932]                         on.exit(options(oopts), add = TRUE)
[17:43:47.932]                       }
[17:43:47.932]                       {
[17:43:47.932]                         lapply(seq_along(...future.elements_ii), 
[17:43:47.932]                           FUN = function(jj) {
[17:43:47.932]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.932]                             ...future.FUN(...future.X_jj, ...)
[17:43:47.932]                           })
[17:43:47.932]                       }
[17:43:47.932]                     }, args = future.call.arguments)
[17:43:47.932]                   }
[17:43:47.932]                 }, immediateCondition = function(cond) {
[17:43:47.932]                   save_rds <- function (object, pathname, ...) 
[17:43:47.932]                   {
[17:43:47.932]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:47.932]                     if (file_test("-f", pathname_tmp)) {
[17:43:47.932]                       fi_tmp <- file.info(pathname_tmp)
[17:43:47.932]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:47.932]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:47.932]                         fi_tmp[["mtime"]])
[17:43:47.932]                     }
[17:43:47.932]                     tryCatch({
[17:43:47.932]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:47.932]                     }, error = function(ex) {
[17:43:47.932]                       msg <- conditionMessage(ex)
[17:43:47.932]                       fi_tmp <- file.info(pathname_tmp)
[17:43:47.932]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:47.932]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:47.932]                         fi_tmp[["mtime"]], msg)
[17:43:47.932]                       ex$message <- msg
[17:43:47.932]                       stop(ex)
[17:43:47.932]                     })
[17:43:47.932]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:47.932]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:47.932]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:47.932]                       fi_tmp <- file.info(pathname_tmp)
[17:43:47.932]                       fi <- file.info(pathname)
[17:43:47.932]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:47.932]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:47.932]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:47.932]                         fi[["size"]], fi[["mtime"]])
[17:43:47.932]                       stop(msg)
[17:43:47.932]                     }
[17:43:47.932]                     invisible(pathname)
[17:43:47.932]                   }
[17:43:47.932]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:47.932]                     rootPath = tempdir()) 
[17:43:47.932]                   {
[17:43:47.932]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:47.932]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:47.932]                       tmpdir = path, fileext = ".rds")
[17:43:47.932]                     save_rds(obj, file)
[17:43:47.932]                   }
[17:43:47.932]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:47.932]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.932]                   {
[17:43:47.932]                     inherits <- base::inherits
[17:43:47.932]                     invokeRestart <- base::invokeRestart
[17:43:47.932]                     is.null <- base::is.null
[17:43:47.932]                     muffled <- FALSE
[17:43:47.932]                     if (inherits(cond, "message")) {
[17:43:47.932]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:47.932]                       if (muffled) 
[17:43:47.932]                         invokeRestart("muffleMessage")
[17:43:47.932]                     }
[17:43:47.932]                     else if (inherits(cond, "warning")) {
[17:43:47.932]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:47.932]                       if (muffled) 
[17:43:47.932]                         invokeRestart("muffleWarning")
[17:43:47.932]                     }
[17:43:47.932]                     else if (inherits(cond, "condition")) {
[17:43:47.932]                       if (!is.null(pattern)) {
[17:43:47.932]                         computeRestarts <- base::computeRestarts
[17:43:47.932]                         grepl <- base::grepl
[17:43:47.932]                         restarts <- computeRestarts(cond)
[17:43:47.932]                         for (restart in restarts) {
[17:43:47.932]                           name <- restart$name
[17:43:47.932]                           if (is.null(name)) 
[17:43:47.932]                             next
[17:43:47.932]                           if (!grepl(pattern, name)) 
[17:43:47.932]                             next
[17:43:47.932]                           invokeRestart(restart)
[17:43:47.932]                           muffled <- TRUE
[17:43:47.932]                           break
[17:43:47.932]                         }
[17:43:47.932]                       }
[17:43:47.932]                     }
[17:43:47.932]                     invisible(muffled)
[17:43:47.932]                   }
[17:43:47.932]                   muffleCondition(cond)
[17:43:47.932]                 })
[17:43:47.932]             }))
[17:43:47.932]             future::FutureResult(value = ...future.value$value, 
[17:43:47.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.932]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.932]                     ...future.globalenv.names))
[17:43:47.932]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.932]         }, condition = base::local({
[17:43:47.932]             c <- base::c
[17:43:47.932]             inherits <- base::inherits
[17:43:47.932]             invokeRestart <- base::invokeRestart
[17:43:47.932]             length <- base::length
[17:43:47.932]             list <- base::list
[17:43:47.932]             seq.int <- base::seq.int
[17:43:47.932]             signalCondition <- base::signalCondition
[17:43:47.932]             sys.calls <- base::sys.calls
[17:43:47.932]             `[[` <- base::`[[`
[17:43:47.932]             `+` <- base::`+`
[17:43:47.932]             `<<-` <- base::`<<-`
[17:43:47.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.932]                   3L)]
[17:43:47.932]             }
[17:43:47.932]             function(cond) {
[17:43:47.932]                 is_error <- inherits(cond, "error")
[17:43:47.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.932]                   NULL)
[17:43:47.932]                 if (is_error) {
[17:43:47.932]                   sessionInformation <- function() {
[17:43:47.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.932]                       search = base::search(), system = base::Sys.info())
[17:43:47.932]                   }
[17:43:47.932]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.932]                     cond$call), session = sessionInformation(), 
[17:43:47.932]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.932]                   signalCondition(cond)
[17:43:47.932]                 }
[17:43:47.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:47.932]                 "immediateCondition"))) {
[17:43:47.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:47.932]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.932]                   if (TRUE && !signal) {
[17:43:47.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.932]                     {
[17:43:47.932]                       inherits <- base::inherits
[17:43:47.932]                       invokeRestart <- base::invokeRestart
[17:43:47.932]                       is.null <- base::is.null
[17:43:47.932]                       muffled <- FALSE
[17:43:47.932]                       if (inherits(cond, "message")) {
[17:43:47.932]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.932]                         if (muffled) 
[17:43:47.932]                           invokeRestart("muffleMessage")
[17:43:47.932]                       }
[17:43:47.932]                       else if (inherits(cond, "warning")) {
[17:43:47.932]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.932]                         if (muffled) 
[17:43:47.932]                           invokeRestart("muffleWarning")
[17:43:47.932]                       }
[17:43:47.932]                       else if (inherits(cond, "condition")) {
[17:43:47.932]                         if (!is.null(pattern)) {
[17:43:47.932]                           computeRestarts <- base::computeRestarts
[17:43:47.932]                           grepl <- base::grepl
[17:43:47.932]                           restarts <- computeRestarts(cond)
[17:43:47.932]                           for (restart in restarts) {
[17:43:47.932]                             name <- restart$name
[17:43:47.932]                             if (is.null(name)) 
[17:43:47.932]                               next
[17:43:47.932]                             if (!grepl(pattern, name)) 
[17:43:47.932]                               next
[17:43:47.932]                             invokeRestart(restart)
[17:43:47.932]                             muffled <- TRUE
[17:43:47.932]                             break
[17:43:47.932]                           }
[17:43:47.932]                         }
[17:43:47.932]                       }
[17:43:47.932]                       invisible(muffled)
[17:43:47.932]                     }
[17:43:47.932]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.932]                   }
[17:43:47.932]                 }
[17:43:47.932]                 else {
[17:43:47.932]                   if (TRUE) {
[17:43:47.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.932]                     {
[17:43:47.932]                       inherits <- base::inherits
[17:43:47.932]                       invokeRestart <- base::invokeRestart
[17:43:47.932]                       is.null <- base::is.null
[17:43:47.932]                       muffled <- FALSE
[17:43:47.932]                       if (inherits(cond, "message")) {
[17:43:47.932]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.932]                         if (muffled) 
[17:43:47.932]                           invokeRestart("muffleMessage")
[17:43:47.932]                       }
[17:43:47.932]                       else if (inherits(cond, "warning")) {
[17:43:47.932]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.932]                         if (muffled) 
[17:43:47.932]                           invokeRestart("muffleWarning")
[17:43:47.932]                       }
[17:43:47.932]                       else if (inherits(cond, "condition")) {
[17:43:47.932]                         if (!is.null(pattern)) {
[17:43:47.932]                           computeRestarts <- base::computeRestarts
[17:43:47.932]                           grepl <- base::grepl
[17:43:47.932]                           restarts <- computeRestarts(cond)
[17:43:47.932]                           for (restart in restarts) {
[17:43:47.932]                             name <- restart$name
[17:43:47.932]                             if (is.null(name)) 
[17:43:47.932]                               next
[17:43:47.932]                             if (!grepl(pattern, name)) 
[17:43:47.932]                               next
[17:43:47.932]                             invokeRestart(restart)
[17:43:47.932]                             muffled <- TRUE
[17:43:47.932]                             break
[17:43:47.932]                           }
[17:43:47.932]                         }
[17:43:47.932]                       }
[17:43:47.932]                       invisible(muffled)
[17:43:47.932]                     }
[17:43:47.932]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.932]                   }
[17:43:47.932]                 }
[17:43:47.932]             }
[17:43:47.932]         }))
[17:43:47.932]     }, error = function(ex) {
[17:43:47.932]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.932]                 ...future.rng), started = ...future.startTime, 
[17:43:47.932]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.932]             version = "1.8"), class = "FutureResult")
[17:43:47.932]     }, finally = {
[17:43:47.932]         if (!identical(...future.workdir, getwd())) 
[17:43:47.932]             setwd(...future.workdir)
[17:43:47.932]         {
[17:43:47.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.932]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.932]             }
[17:43:47.932]             base::options(...future.oldOptions)
[17:43:47.932]             if (.Platform$OS.type == "windows") {
[17:43:47.932]                 old_names <- names(...future.oldEnvVars)
[17:43:47.932]                 envs <- base::Sys.getenv()
[17:43:47.932]                 names <- names(envs)
[17:43:47.932]                 common <- intersect(names, old_names)
[17:43:47.932]                 added <- setdiff(names, old_names)
[17:43:47.932]                 removed <- setdiff(old_names, names)
[17:43:47.932]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.932]                   envs[common]]
[17:43:47.932]                 NAMES <- toupper(changed)
[17:43:47.932]                 args <- list()
[17:43:47.932]                 for (kk in seq_along(NAMES)) {
[17:43:47.932]                   name <- changed[[kk]]
[17:43:47.932]                   NAME <- NAMES[[kk]]
[17:43:47.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.932]                     next
[17:43:47.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.932]                 }
[17:43:47.932]                 NAMES <- toupper(added)
[17:43:47.932]                 for (kk in seq_along(NAMES)) {
[17:43:47.932]                   name <- added[[kk]]
[17:43:47.932]                   NAME <- NAMES[[kk]]
[17:43:47.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.932]                     next
[17:43:47.932]                   args[[name]] <- ""
[17:43:47.932]                 }
[17:43:47.932]                 NAMES <- toupper(removed)
[17:43:47.932]                 for (kk in seq_along(NAMES)) {
[17:43:47.932]                   name <- removed[[kk]]
[17:43:47.932]                   NAME <- NAMES[[kk]]
[17:43:47.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.932]                     next
[17:43:47.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.932]                 }
[17:43:47.932]                 if (length(args) > 0) 
[17:43:47.932]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.932]             }
[17:43:47.932]             else {
[17:43:47.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.932]             }
[17:43:47.932]             {
[17:43:47.932]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.932]                   0L) {
[17:43:47.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.932]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.932]                   base::options(opts)
[17:43:47.932]                 }
[17:43:47.932]                 {
[17:43:47.932]                   {
[17:43:47.932]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:47.932]                     NULL
[17:43:47.932]                   }
[17:43:47.932]                   options(future.plan = NULL)
[17:43:47.932]                   if (is.na(NA_character_)) 
[17:43:47.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.932]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:47.932]                     .init = FALSE)
[17:43:47.932]                 }
[17:43:47.932]             }
[17:43:47.932]         }
[17:43:47.932]     })
[17:43:47.932]     if (TRUE) {
[17:43:47.932]         base::sink(type = "output", split = FALSE)
[17:43:47.932]         if (TRUE) {
[17:43:47.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.932]         }
[17:43:47.932]         else {
[17:43:47.932]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.932]         }
[17:43:47.932]         base::close(...future.stdout)
[17:43:47.932]         ...future.stdout <- NULL
[17:43:47.932]     }
[17:43:47.932]     ...future.result$conditions <- ...future.conditions
[17:43:47.932]     ...future.result$finished <- base::Sys.time()
[17:43:47.932]     ...future.result
[17:43:47.932] }
[17:43:47.934] assign_globals() ...
[17:43:47.934] List of 5
[17:43:47.934]  $ future.call.arguments    : list()
[17:43:47.934]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.934]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:47.934]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:47.934]  $ ...future.elements_ii    :List of 1
[17:43:47.934]   ..$ : num [1:4] 1 3 1 7
[17:43:47.934]  $ ...future.seeds_ii       : NULL
[17:43:47.934]  $ ...future.globals.maxSize: num Inf
[17:43:47.934]  - attr(*, "resolved")= logi FALSE
[17:43:47.934]  - attr(*, "total_size")= num NA
[17:43:47.934]  - attr(*, "where")=List of 5
[17:43:47.934]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:47.934]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:47.934]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:47.934]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:47.934]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:47.934]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.934]  - attr(*, "already-done")= logi TRUE
[17:43:47.939] - copied ‘future.call.arguments’ to environment
[17:43:47.939] - copied ‘...future.FUN’ to environment
[17:43:47.939] - copied ‘...future.elements_ii’ to environment
[17:43:47.939] - copied ‘...future.seeds_ii’ to environment
[17:43:47.939] - copied ‘...future.globals.maxSize’ to environment
[17:43:47.940] assign_globals() ... done
[17:43:47.940] requestCore(): workers = 2
[17:43:47.942] MulticoreFuture started
[17:43:47.942] - Launch lazy future ... done
[17:43:47.942] run() for ‘MulticoreFuture’ ... done
[17:43:47.943] Created future:
[17:43:47.943] plan(): Setting new future strategy stack:
[17:43:47.943] List of future strategies:
[17:43:47.943] 1. sequential:
[17:43:47.943]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.943]    - tweaked: FALSE
[17:43:47.943]    - call: NULL
[17:43:47.944] plan(): nbrOfWorkers() = 1
[17:43:47.947] plan(): Setting new future strategy stack:
[17:43:47.947] List of future strategies:
[17:43:47.947] 1. multicore:
[17:43:47.947]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:47.947]    - tweaked: FALSE
[17:43:47.947]    - call: plan(strategy)
[17:43:47.952] plan(): nbrOfWorkers() = 2
[17:43:47.943] MulticoreFuture:
[17:43:47.943] Label: ‘future_apply-1’
[17:43:47.943] Expression:
[17:43:47.943] {
[17:43:47.943]     do.call(function(...) {
[17:43:47.943]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.943]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.943]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.943]             on.exit(options(oopts), add = TRUE)
[17:43:47.943]         }
[17:43:47.943]         {
[17:43:47.943]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.943]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.943]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.943]             })
[17:43:47.943]         }
[17:43:47.943]     }, args = future.call.arguments)
[17:43:47.943] }
[17:43:47.943] Lazy evaluation: FALSE
[17:43:47.943] Asynchronous evaluation: TRUE
[17:43:47.943] Local evaluation: TRUE
[17:43:47.943] Environment: R_GlobalEnv
[17:43:47.943] Capture standard output: TRUE
[17:43:47.943] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:47.943] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:47.943] Packages: <none>
[17:43:47.943] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:47.943] Resolved: TRUE
[17:43:47.943] Value: <not collected>
[17:43:47.943] Conditions captured: <none>
[17:43:47.943] Early signaling: FALSE
[17:43:47.943] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:47.943] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:47.953] Chunk #1 of 2 ... DONE
[17:43:47.953] Chunk #2 of 2 ...
[17:43:47.953]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:47.954]  - seeds: <none>
[17:43:47.954]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.954] getGlobalsAndPackages() ...
[17:43:47.954] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.954] Resolving globals: FALSE
[17:43:47.954] Tweak future expression to call with '...' arguments ...
[17:43:47.955] {
[17:43:47.955]     do.call(function(...) {
[17:43:47.955]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.955]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.955]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.955]             on.exit(options(oopts), add = TRUE)
[17:43:47.955]         }
[17:43:47.955]         {
[17:43:47.955]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.955]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.955]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.955]             })
[17:43:47.955]         }
[17:43:47.955]     }, args = future.call.arguments)
[17:43:47.955] }
[17:43:47.955] Tweak future expression to call with '...' arguments ... DONE
[17:43:47.956] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:47.956] 
[17:43:47.956] getGlobalsAndPackages() ... DONE
[17:43:47.957] run() for ‘Future’ ...
[17:43:47.957] - state: ‘created’
[17:43:47.957] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:47.962] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:47.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:47.962]   - Field: ‘label’
[17:43:47.962]   - Field: ‘local’
[17:43:47.962]   - Field: ‘owner’
[17:43:47.963]   - Field: ‘envir’
[17:43:47.963]   - Field: ‘workers’
[17:43:47.963]   - Field: ‘packages’
[17:43:47.963]   - Field: ‘gc’
[17:43:47.963]   - Field: ‘job’
[17:43:47.963]   - Field: ‘conditions’
[17:43:47.963]   - Field: ‘expr’
[17:43:47.964]   - Field: ‘uuid’
[17:43:47.964]   - Field: ‘seed’
[17:43:47.964]   - Field: ‘version’
[17:43:47.964]   - Field: ‘result’
[17:43:47.964]   - Field: ‘asynchronous’
[17:43:47.964]   - Field: ‘calls’
[17:43:47.965]   - Field: ‘globals’
[17:43:47.965]   - Field: ‘stdout’
[17:43:47.965]   - Field: ‘earlySignal’
[17:43:47.965]   - Field: ‘lazy’
[17:43:47.965]   - Field: ‘state’
[17:43:47.965] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:47.965] - Launch lazy future ...
[17:43:47.966] Packages needed by the future expression (n = 0): <none>
[17:43:47.966] Packages needed by future strategies (n = 0): <none>
[17:43:47.967] {
[17:43:47.967]     {
[17:43:47.967]         {
[17:43:47.967]             ...future.startTime <- base::Sys.time()
[17:43:47.967]             {
[17:43:47.967]                 {
[17:43:47.967]                   {
[17:43:47.967]                     {
[17:43:47.967]                       base::local({
[17:43:47.967]                         has_future <- base::requireNamespace("future", 
[17:43:47.967]                           quietly = TRUE)
[17:43:47.967]                         if (has_future) {
[17:43:47.967]                           ns <- base::getNamespace("future")
[17:43:47.967]                           version <- ns[[".package"]][["version"]]
[17:43:47.967]                           if (is.null(version)) 
[17:43:47.967]                             version <- utils::packageVersion("future")
[17:43:47.967]                         }
[17:43:47.967]                         else {
[17:43:47.967]                           version <- NULL
[17:43:47.967]                         }
[17:43:47.967]                         if (!has_future || version < "1.8.0") {
[17:43:47.967]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.967]                             "", base::R.version$version.string), 
[17:43:47.967]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:47.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.967]                               "release", "version")], collapse = " "), 
[17:43:47.967]                             hostname = base::Sys.info()[["nodename"]])
[17:43:47.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.967]                             info)
[17:43:47.967]                           info <- base::paste(info, collapse = "; ")
[17:43:47.967]                           if (!has_future) {
[17:43:47.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.967]                               info)
[17:43:47.967]                           }
[17:43:47.967]                           else {
[17:43:47.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.967]                               info, version)
[17:43:47.967]                           }
[17:43:47.967]                           base::stop(msg)
[17:43:47.967]                         }
[17:43:47.967]                       })
[17:43:47.967]                     }
[17:43:47.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:47.967]                     base::options(mc.cores = 1L)
[17:43:47.967]                   }
[17:43:47.967]                   ...future.strategy.old <- future::plan("list")
[17:43:47.967]                   options(future.plan = NULL)
[17:43:47.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.967]                 }
[17:43:47.967]                 ...future.workdir <- getwd()
[17:43:47.967]             }
[17:43:47.967]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.967]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.967]         }
[17:43:47.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.967]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:47.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.967]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.967]             base::names(...future.oldOptions))
[17:43:47.967]     }
[17:43:47.967]     if (FALSE) {
[17:43:47.967]     }
[17:43:47.967]     else {
[17:43:47.967]         if (TRUE) {
[17:43:47.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.967]                 open = "w")
[17:43:47.967]         }
[17:43:47.967]         else {
[17:43:47.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.967]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.967]         }
[17:43:47.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.967]             base::sink(type = "output", split = FALSE)
[17:43:47.967]             base::close(...future.stdout)
[17:43:47.967]         }, add = TRUE)
[17:43:47.967]     }
[17:43:47.967]     ...future.frame <- base::sys.nframe()
[17:43:47.967]     ...future.conditions <- base::list()
[17:43:47.967]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.967]     if (FALSE) {
[17:43:47.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.967]     }
[17:43:47.967]     ...future.result <- base::tryCatch({
[17:43:47.967]         base::withCallingHandlers({
[17:43:47.967]             ...future.value <- base::withVisible(base::local({
[17:43:47.967]                 withCallingHandlers({
[17:43:47.967]                   {
[17:43:47.967]                     do.call(function(...) {
[17:43:47.967]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.967]                       if (!identical(...future.globals.maxSize.org, 
[17:43:47.967]                         ...future.globals.maxSize)) {
[17:43:47.967]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.967]                         on.exit(options(oopts), add = TRUE)
[17:43:47.967]                       }
[17:43:47.967]                       {
[17:43:47.967]                         lapply(seq_along(...future.elements_ii), 
[17:43:47.967]                           FUN = function(jj) {
[17:43:47.967]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.967]                             ...future.FUN(...future.X_jj, ...)
[17:43:47.967]                           })
[17:43:47.967]                       }
[17:43:47.967]                     }, args = future.call.arguments)
[17:43:47.967]                   }
[17:43:47.967]                 }, immediateCondition = function(cond) {
[17:43:47.967]                   save_rds <- function (object, pathname, ...) 
[17:43:47.967]                   {
[17:43:47.967]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:47.967]                     if (file_test("-f", pathname_tmp)) {
[17:43:47.967]                       fi_tmp <- file.info(pathname_tmp)
[17:43:47.967]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:47.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:47.967]                         fi_tmp[["mtime"]])
[17:43:47.967]                     }
[17:43:47.967]                     tryCatch({
[17:43:47.967]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:47.967]                     }, error = function(ex) {
[17:43:47.967]                       msg <- conditionMessage(ex)
[17:43:47.967]                       fi_tmp <- file.info(pathname_tmp)
[17:43:47.967]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:47.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:47.967]                         fi_tmp[["mtime"]], msg)
[17:43:47.967]                       ex$message <- msg
[17:43:47.967]                       stop(ex)
[17:43:47.967]                     })
[17:43:47.967]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:47.967]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:47.967]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:47.967]                       fi_tmp <- file.info(pathname_tmp)
[17:43:47.967]                       fi <- file.info(pathname)
[17:43:47.967]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:47.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:47.967]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:47.967]                         fi[["size"]], fi[["mtime"]])
[17:43:47.967]                       stop(msg)
[17:43:47.967]                     }
[17:43:47.967]                     invisible(pathname)
[17:43:47.967]                   }
[17:43:47.967]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:47.967]                     rootPath = tempdir()) 
[17:43:47.967]                   {
[17:43:47.967]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:47.967]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:47.967]                       tmpdir = path, fileext = ".rds")
[17:43:47.967]                     save_rds(obj, file)
[17:43:47.967]                   }
[17:43:47.967]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:47.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.967]                   {
[17:43:47.967]                     inherits <- base::inherits
[17:43:47.967]                     invokeRestart <- base::invokeRestart
[17:43:47.967]                     is.null <- base::is.null
[17:43:47.967]                     muffled <- FALSE
[17:43:47.967]                     if (inherits(cond, "message")) {
[17:43:47.967]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:47.967]                       if (muffled) 
[17:43:47.967]                         invokeRestart("muffleMessage")
[17:43:47.967]                     }
[17:43:47.967]                     else if (inherits(cond, "warning")) {
[17:43:47.967]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:47.967]                       if (muffled) 
[17:43:47.967]                         invokeRestart("muffleWarning")
[17:43:47.967]                     }
[17:43:47.967]                     else if (inherits(cond, "condition")) {
[17:43:47.967]                       if (!is.null(pattern)) {
[17:43:47.967]                         computeRestarts <- base::computeRestarts
[17:43:47.967]                         grepl <- base::grepl
[17:43:47.967]                         restarts <- computeRestarts(cond)
[17:43:47.967]                         for (restart in restarts) {
[17:43:47.967]                           name <- restart$name
[17:43:47.967]                           if (is.null(name)) 
[17:43:47.967]                             next
[17:43:47.967]                           if (!grepl(pattern, name)) 
[17:43:47.967]                             next
[17:43:47.967]                           invokeRestart(restart)
[17:43:47.967]                           muffled <- TRUE
[17:43:47.967]                           break
[17:43:47.967]                         }
[17:43:47.967]                       }
[17:43:47.967]                     }
[17:43:47.967]                     invisible(muffled)
[17:43:47.967]                   }
[17:43:47.967]                   muffleCondition(cond)
[17:43:47.967]                 })
[17:43:47.967]             }))
[17:43:47.967]             future::FutureResult(value = ...future.value$value, 
[17:43:47.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.967]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.967]                     ...future.globalenv.names))
[17:43:47.967]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.967]         }, condition = base::local({
[17:43:47.967]             c <- base::c
[17:43:47.967]             inherits <- base::inherits
[17:43:47.967]             invokeRestart <- base::invokeRestart
[17:43:47.967]             length <- base::length
[17:43:47.967]             list <- base::list
[17:43:47.967]             seq.int <- base::seq.int
[17:43:47.967]             signalCondition <- base::signalCondition
[17:43:47.967]             sys.calls <- base::sys.calls
[17:43:47.967]             `[[` <- base::`[[`
[17:43:47.967]             `+` <- base::`+`
[17:43:47.967]             `<<-` <- base::`<<-`
[17:43:47.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.967]                   3L)]
[17:43:47.967]             }
[17:43:47.967]             function(cond) {
[17:43:47.967]                 is_error <- inherits(cond, "error")
[17:43:47.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.967]                   NULL)
[17:43:47.967]                 if (is_error) {
[17:43:47.967]                   sessionInformation <- function() {
[17:43:47.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.967]                       search = base::search(), system = base::Sys.info())
[17:43:47.967]                   }
[17:43:47.967]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.967]                     cond$call), session = sessionInformation(), 
[17:43:47.967]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.967]                   signalCondition(cond)
[17:43:47.967]                 }
[17:43:47.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:47.967]                 "immediateCondition"))) {
[17:43:47.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:47.967]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.967]                   if (TRUE && !signal) {
[17:43:47.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.967]                     {
[17:43:47.967]                       inherits <- base::inherits
[17:43:47.967]                       invokeRestart <- base::invokeRestart
[17:43:47.967]                       is.null <- base::is.null
[17:43:47.967]                       muffled <- FALSE
[17:43:47.967]                       if (inherits(cond, "message")) {
[17:43:47.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.967]                         if (muffled) 
[17:43:47.967]                           invokeRestart("muffleMessage")
[17:43:47.967]                       }
[17:43:47.967]                       else if (inherits(cond, "warning")) {
[17:43:47.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.967]                         if (muffled) 
[17:43:47.967]                           invokeRestart("muffleWarning")
[17:43:47.967]                       }
[17:43:47.967]                       else if (inherits(cond, "condition")) {
[17:43:47.967]                         if (!is.null(pattern)) {
[17:43:47.967]                           computeRestarts <- base::computeRestarts
[17:43:47.967]                           grepl <- base::grepl
[17:43:47.967]                           restarts <- computeRestarts(cond)
[17:43:47.967]                           for (restart in restarts) {
[17:43:47.967]                             name <- restart$name
[17:43:47.967]                             if (is.null(name)) 
[17:43:47.967]                               next
[17:43:47.967]                             if (!grepl(pattern, name)) 
[17:43:47.967]                               next
[17:43:47.967]                             invokeRestart(restart)
[17:43:47.967]                             muffled <- TRUE
[17:43:47.967]                             break
[17:43:47.967]                           }
[17:43:47.967]                         }
[17:43:47.967]                       }
[17:43:47.967]                       invisible(muffled)
[17:43:47.967]                     }
[17:43:47.967]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.967]                   }
[17:43:47.967]                 }
[17:43:47.967]                 else {
[17:43:47.967]                   if (TRUE) {
[17:43:47.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.967]                     {
[17:43:47.967]                       inherits <- base::inherits
[17:43:47.967]                       invokeRestart <- base::invokeRestart
[17:43:47.967]                       is.null <- base::is.null
[17:43:47.967]                       muffled <- FALSE
[17:43:47.967]                       if (inherits(cond, "message")) {
[17:43:47.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.967]                         if (muffled) 
[17:43:47.967]                           invokeRestart("muffleMessage")
[17:43:47.967]                       }
[17:43:47.967]                       else if (inherits(cond, "warning")) {
[17:43:47.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.967]                         if (muffled) 
[17:43:47.967]                           invokeRestart("muffleWarning")
[17:43:47.967]                       }
[17:43:47.967]                       else if (inherits(cond, "condition")) {
[17:43:47.967]                         if (!is.null(pattern)) {
[17:43:47.967]                           computeRestarts <- base::computeRestarts
[17:43:47.967]                           grepl <- base::grepl
[17:43:47.967]                           restarts <- computeRestarts(cond)
[17:43:47.967]                           for (restart in restarts) {
[17:43:47.967]                             name <- restart$name
[17:43:47.967]                             if (is.null(name)) 
[17:43:47.967]                               next
[17:43:47.967]                             if (!grepl(pattern, name)) 
[17:43:47.967]                               next
[17:43:47.967]                             invokeRestart(restart)
[17:43:47.967]                             muffled <- TRUE
[17:43:47.967]                             break
[17:43:47.967]                           }
[17:43:47.967]                         }
[17:43:47.967]                       }
[17:43:47.967]                       invisible(muffled)
[17:43:47.967]                     }
[17:43:47.967]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.967]                   }
[17:43:47.967]                 }
[17:43:47.967]             }
[17:43:47.967]         }))
[17:43:47.967]     }, error = function(ex) {
[17:43:47.967]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.967]                 ...future.rng), started = ...future.startTime, 
[17:43:47.967]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.967]             version = "1.8"), class = "FutureResult")
[17:43:47.967]     }, finally = {
[17:43:47.967]         if (!identical(...future.workdir, getwd())) 
[17:43:47.967]             setwd(...future.workdir)
[17:43:47.967]         {
[17:43:47.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.967]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.967]             }
[17:43:47.967]             base::options(...future.oldOptions)
[17:43:47.967]             if (.Platform$OS.type == "windows") {
[17:43:47.967]                 old_names <- names(...future.oldEnvVars)
[17:43:47.967]                 envs <- base::Sys.getenv()
[17:43:47.967]                 names <- names(envs)
[17:43:47.967]                 common <- intersect(names, old_names)
[17:43:47.967]                 added <- setdiff(names, old_names)
[17:43:47.967]                 removed <- setdiff(old_names, names)
[17:43:47.967]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.967]                   envs[common]]
[17:43:47.967]                 NAMES <- toupper(changed)
[17:43:47.967]                 args <- list()
[17:43:47.967]                 for (kk in seq_along(NAMES)) {
[17:43:47.967]                   name <- changed[[kk]]
[17:43:47.967]                   NAME <- NAMES[[kk]]
[17:43:47.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.967]                     next
[17:43:47.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.967]                 }
[17:43:47.967]                 NAMES <- toupper(added)
[17:43:47.967]                 for (kk in seq_along(NAMES)) {
[17:43:47.967]                   name <- added[[kk]]
[17:43:47.967]                   NAME <- NAMES[[kk]]
[17:43:47.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.967]                     next
[17:43:47.967]                   args[[name]] <- ""
[17:43:47.967]                 }
[17:43:47.967]                 NAMES <- toupper(removed)
[17:43:47.967]                 for (kk in seq_along(NAMES)) {
[17:43:47.967]                   name <- removed[[kk]]
[17:43:47.967]                   NAME <- NAMES[[kk]]
[17:43:47.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.967]                     next
[17:43:47.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.967]                 }
[17:43:47.967]                 if (length(args) > 0) 
[17:43:47.967]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.967]             }
[17:43:47.967]             else {
[17:43:47.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.967]             }
[17:43:47.967]             {
[17:43:47.967]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.967]                   0L) {
[17:43:47.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.967]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.967]                   base::options(opts)
[17:43:47.967]                 }
[17:43:47.967]                 {
[17:43:47.967]                   {
[17:43:47.967]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:47.967]                     NULL
[17:43:47.967]                   }
[17:43:47.967]                   options(future.plan = NULL)
[17:43:47.967]                   if (is.na(NA_character_)) 
[17:43:47.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:47.967]                     .init = FALSE)
[17:43:47.967]                 }
[17:43:47.967]             }
[17:43:47.967]         }
[17:43:47.967]     })
[17:43:47.967]     if (TRUE) {
[17:43:47.967]         base::sink(type = "output", split = FALSE)
[17:43:47.967]         if (TRUE) {
[17:43:47.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.967]         }
[17:43:47.967]         else {
[17:43:47.967]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.967]         }
[17:43:47.967]         base::close(...future.stdout)
[17:43:47.967]         ...future.stdout <- NULL
[17:43:47.967]     }
[17:43:47.967]     ...future.result$conditions <- ...future.conditions
[17:43:47.967]     ...future.result$finished <- base::Sys.time()
[17:43:47.967]     ...future.result
[17:43:47.967] }
[17:43:47.970] assign_globals() ...
[17:43:47.970] List of 5
[17:43:47.970]  $ future.call.arguments    : list()
[17:43:47.970]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:47.970]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:47.970]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:47.970]  $ ...future.elements_ii    :List of 1
[17:43:47.970]   ..$ : num [1:4] 2 4 6 8
[17:43:47.970]  $ ...future.seeds_ii       : NULL
[17:43:47.970]  $ ...future.globals.maxSize: num Inf
[17:43:47.970]  - attr(*, "resolved")= logi FALSE
[17:43:47.970]  - attr(*, "total_size")= num NA
[17:43:47.970]  - attr(*, "where")=List of 5
[17:43:47.970]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:47.970]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:47.970]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:47.970]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:47.970]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:47.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:47.970]  - attr(*, "already-done")= logi TRUE
[17:43:47.977] - copied ‘future.call.arguments’ to environment
[17:43:47.980] - copied ‘...future.FUN’ to environment
[17:43:47.981] - copied ‘...future.elements_ii’ to environment
[17:43:47.981] - copied ‘...future.seeds_ii’ to environment
[17:43:47.981] - copied ‘...future.globals.maxSize’ to environment
[17:43:47.981] assign_globals() ... done
[17:43:47.982] requestCore(): workers = 2
[17:43:47.984] MulticoreFuture started
[17:43:47.985] - Launch lazy future ... done
[17:43:47.985] run() for ‘MulticoreFuture’ ... done
[17:43:47.986] plan(): Setting new future strategy stack:
[17:43:47.986] Created future:
[17:43:47.986] List of future strategies:
[17:43:47.986] 1. sequential:
[17:43:47.986]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:47.986]    - tweaked: FALSE
[17:43:47.986]    - call: NULL
[17:43:47.988] plan(): nbrOfWorkers() = 1
[17:43:47.990] plan(): Setting new future strategy stack:
[17:43:47.990] List of future strategies:
[17:43:47.990] 1. multicore:
[17:43:47.990]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:47.990]    - tweaked: FALSE
[17:43:47.990]    - call: plan(strategy)
[17:43:47.997] plan(): nbrOfWorkers() = 2
[17:43:47.986] MulticoreFuture:
[17:43:47.986] Label: ‘future_apply-2’
[17:43:47.986] Expression:
[17:43:47.986] {
[17:43:47.986]     do.call(function(...) {
[17:43:47.986]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:47.986]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:47.986]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:47.986]             on.exit(options(oopts), add = TRUE)
[17:43:47.986]         }
[17:43:47.986]         {
[17:43:47.986]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:47.986]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:47.986]                 ...future.FUN(...future.X_jj, ...)
[17:43:47.986]             })
[17:43:47.986]         }
[17:43:47.986]     }, args = future.call.arguments)
[17:43:47.986] }
[17:43:47.986] Lazy evaluation: FALSE
[17:43:47.986] Asynchronous evaluation: TRUE
[17:43:47.986] Local evaluation: TRUE
[17:43:47.986] Environment: R_GlobalEnv
[17:43:47.986] Capture standard output: TRUE
[17:43:47.986] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:47.986] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:47.986] Packages: <none>
[17:43:47.986] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:47.986] Resolved: TRUE
[17:43:47.986] Value: <not collected>
[17:43:47.986] Conditions captured: <none>
[17:43:47.986] Early signaling: FALSE
[17:43:47.986] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:47.986] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:47.998] Chunk #2 of 2 ... DONE
[17:43:47.998] Launching 2 futures (chunks) ... DONE
[17:43:47.998] Resolving 2 futures (chunks) ...
[17:43:47.998] resolve() on list ...
[17:43:47.998]  recursive: 0
[17:43:47.998]  length: 2
[17:43:47.999] 
[17:43:47.999] Future #1
[17:43:48.000] result() for MulticoreFuture ...
[17:43:48.000] result() for MulticoreFuture ...
[17:43:48.001] result() for MulticoreFuture ... done
[17:43:48.001] result() for MulticoreFuture ... done
[17:43:48.001] result() for MulticoreFuture ...
[17:43:48.001] result() for MulticoreFuture ... done
[17:43:48.001] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:48.002] - nx: 2
[17:43:48.002] - relay: TRUE
[17:43:48.002] - stdout: TRUE
[17:43:48.002] - signal: TRUE
[17:43:48.002] - resignal: FALSE
[17:43:48.002] - force: TRUE
[17:43:48.002] - relayed: [n=2] FALSE, FALSE
[17:43:48.003] - queued futures: [n=2] FALSE, FALSE
[17:43:48.003]  - until=1
[17:43:48.003]  - relaying element #1
[17:43:48.003] result() for MulticoreFuture ...
[17:43:48.003] result() for MulticoreFuture ... done
[17:43:48.003] result() for MulticoreFuture ...
[17:43:48.004] result() for MulticoreFuture ... done
[17:43:48.004] result() for MulticoreFuture ...
[17:43:48.004] result() for MulticoreFuture ... done
[17:43:48.004] result() for MulticoreFuture ...
[17:43:48.004] result() for MulticoreFuture ... done
[17:43:48.004] - relayed: [n=2] TRUE, FALSE
[17:43:48.004] - queued futures: [n=2] TRUE, FALSE
[17:43:48.005] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:48.005]  length: 1 (resolved future 1)
[17:43:48.005] Future #2
[17:43:48.005] result() for MulticoreFuture ...
[17:43:48.006] result() for MulticoreFuture ...
[17:43:48.006] result() for MulticoreFuture ... done
[17:43:48.006] result() for MulticoreFuture ... done
[17:43:48.006] result() for MulticoreFuture ...
[17:43:48.006] result() for MulticoreFuture ... done
[17:43:48.007] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:48.007] - nx: 2
[17:43:48.007] - relay: TRUE
[17:43:48.007] - stdout: TRUE
[17:43:48.007] - signal: TRUE
[17:43:48.007] - resignal: FALSE
[17:43:48.007] - force: TRUE
[17:43:48.007] - relayed: [n=2] TRUE, FALSE
[17:43:48.008] - queued futures: [n=2] TRUE, FALSE
[17:43:48.008]  - until=2
[17:43:48.008]  - relaying element #2
[17:43:48.008] result() for MulticoreFuture ...
[17:43:48.008] result() for MulticoreFuture ... done
[17:43:48.008] result() for MulticoreFuture ...
[17:43:48.008] result() for MulticoreFuture ... done
[17:43:48.009] result() for MulticoreFuture ...
[17:43:48.009] result() for MulticoreFuture ... done
[17:43:48.009] result() for MulticoreFuture ...
[17:43:48.009] result() for MulticoreFuture ... done
[17:43:48.009] - relayed: [n=2] TRUE, TRUE
[17:43:48.009] - queued futures: [n=2] TRUE, TRUE
[17:43:48.009] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:48.009]  length: 0 (resolved future 2)
[17:43:48.009] Relaying remaining futures
[17:43:48.010] signalConditionsASAP(NULL, pos=0) ...
[17:43:48.010] - nx: 2
[17:43:48.010] - relay: TRUE
[17:43:48.010] - stdout: TRUE
[17:43:48.010] - signal: TRUE
[17:43:48.010] - resignal: FALSE
[17:43:48.010] - force: TRUE
[17:43:48.010] - relayed: [n=2] TRUE, TRUE
[17:43:48.010] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:48.011] - relayed: [n=2] TRUE, TRUE
[17:43:48.011] - queued futures: [n=2] TRUE, TRUE
[17:43:48.011] signalConditionsASAP(NULL, pos=0) ... done
[17:43:48.011] resolve() on list ... DONE
[17:43:48.011] result() for MulticoreFuture ...
[17:43:48.011] result() for MulticoreFuture ... done
[17:43:48.011] result() for MulticoreFuture ...
[17:43:48.011] result() for MulticoreFuture ... done
[17:43:48.012] result() for MulticoreFuture ...
[17:43:48.012] result() for MulticoreFuture ... done
[17:43:48.012] result() for MulticoreFuture ...
[17:43:48.012] result() for MulticoreFuture ... done
[17:43:48.012]  - Number of value chunks collected: 2
[17:43:48.012] Resolving 2 futures (chunks) ... DONE
[17:43:48.012] Reducing values from 2 chunks ...
[17:43:48.012]  - Number of values collected after concatenation: 2
[17:43:48.012]  - Number of values expected: 2
[17:43:48.013] Reducing values from 2 chunks ... DONE
[17:43:48.013] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:43:48.014] getGlobalsAndPackagesXApply() ...
[17:43:48.014]  - future.globals: TRUE
[17:43:48.014] getGlobalsAndPackages() ...
[17:43:48.014] Searching for globals...
[17:43:48.016] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:48.016] Searching for globals ... DONE
[17:43:48.016] Resolving globals: FALSE
[17:43:48.016] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:43:48.017] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:43:48.017] - globals: [1] ‘FUN’
[17:43:48.017] - packages: [1] ‘stats’
[17:43:48.017] getGlobalsAndPackages() ... DONE
[17:43:48.017]  - globals found/used: [n=1] ‘FUN’
[17:43:48.017]  - needed namespaces: [n=1] ‘stats’
[17:43:48.017] Finding globals ... DONE
[17:43:48.018]  - use_args: TRUE
[17:43:48.018]  - Getting '...' globals ...
[17:43:48.018] resolve() on list ...
[17:43:48.018]  recursive: 0
[17:43:48.018]  length: 1
[17:43:48.018]  elements: ‘...’
[17:43:48.019]  length: 0 (resolved future 1)
[17:43:48.019] resolve() on list ... DONE
[17:43:48.019]    - '...' content: [n=0] 
[17:43:48.019] List of 1
[17:43:48.019]  $ ...: list()
[17:43:48.019]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.019]  - attr(*, "where")=List of 1
[17:43:48.019]   ..$ ...:<environment: 0x55dfd4aabc18> 
[17:43:48.019]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.019]  - attr(*, "resolved")= logi TRUE
[17:43:48.019]  - attr(*, "total_size")= num NA
[17:43:48.022]  - Getting '...' globals ... DONE
[17:43:48.022] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:48.022] List of 2
[17:43:48.022]  $ ...future.FUN:function (x, ...)  
[17:43:48.022]  $ ...          : list()
[17:43:48.022]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.022]  - attr(*, "where")=List of 2
[17:43:48.022]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:48.022]   ..$ ...          :<environment: 0x55dfd4aabc18> 
[17:43:48.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.022]  - attr(*, "resolved")= logi FALSE
[17:43:48.022]  - attr(*, "total_size")= num 1248
[17:43:48.028] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:48.028] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.032] future_lapply() ...
[17:43:48.036] Number of chunks: 2
[17:43:48.036] getGlobalsAndPackagesXApply() ...
[17:43:48.036]  - future.globals: <name-value list> with names ‘list()’
[17:43:48.037]  - use_args: TRUE
[17:43:48.037] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:48.037] List of 2
[17:43:48.037]  $ ...          : list()
[17:43:48.037]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.037]  $ ...future.FUN:function (x, ...)  
[17:43:48.037]  - attr(*, "where")=List of 2
[17:43:48.037]   ..$ ...          :<environment: 0x55dfd4aabc18> 
[17:43:48.037]   ..$ ...future.FUN:<environment: namespace:stats> 
[17:43:48.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.037]  - attr(*, "resolved")= logi FALSE
[17:43:48.037]  - attr(*, "total_size")= num NA
[17:43:48.040] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:48.040] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.040] Number of futures (= number of chunks): 2
[17:43:48.040] Launching 2 futures (chunks) ...
[17:43:48.040] Chunk #1 of 2 ...
[17:43:48.041]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.041]  - seeds: <none>
[17:43:48.041]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.041] getGlobalsAndPackages() ...
[17:43:48.041] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.041] Resolving globals: FALSE
[17:43:48.041] Tweak future expression to call with '...' arguments ...
[17:43:48.041] {
[17:43:48.041]     do.call(function(...) {
[17:43:48.041]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.041]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.041]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.041]             on.exit(options(oopts), add = TRUE)
[17:43:48.041]         }
[17:43:48.041]         {
[17:43:48.041]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.041]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.041]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.041]             })
[17:43:48.041]         }
[17:43:48.041]     }, args = future.call.arguments)
[17:43:48.041] }
[17:43:48.042] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.042] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.042] - packages: [1] ‘stats’
[17:43:48.042] getGlobalsAndPackages() ... DONE
[17:43:48.043] run() for ‘Future’ ...
[17:43:48.043] - state: ‘created’
[17:43:48.043] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.047] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.047] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.047]   - Field: ‘label’
[17:43:48.047]   - Field: ‘local’
[17:43:48.047]   - Field: ‘owner’
[17:43:48.047]   - Field: ‘envir’
[17:43:48.047]   - Field: ‘workers’
[17:43:48.047]   - Field: ‘packages’
[17:43:48.048]   - Field: ‘gc’
[17:43:48.048]   - Field: ‘job’
[17:43:48.048]   - Field: ‘conditions’
[17:43:48.048]   - Field: ‘expr’
[17:43:48.048]   - Field: ‘uuid’
[17:43:48.048]   - Field: ‘seed’
[17:43:48.048]   - Field: ‘version’
[17:43:48.048]   - Field: ‘result’
[17:43:48.048]   - Field: ‘asynchronous’
[17:43:48.048]   - Field: ‘calls’
[17:43:48.048]   - Field: ‘globals’
[17:43:48.049]   - Field: ‘stdout’
[17:43:48.049]   - Field: ‘earlySignal’
[17:43:48.049]   - Field: ‘lazy’
[17:43:48.049]   - Field: ‘state’
[17:43:48.049] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.049] - Launch lazy future ...
[17:43:48.049] Packages needed by the future expression (n = 1): ‘stats’
[17:43:48.049] Packages needed by future strategies (n = 0): <none>
[17:43:48.050] {
[17:43:48.050]     {
[17:43:48.050]         {
[17:43:48.050]             ...future.startTime <- base::Sys.time()
[17:43:48.050]             {
[17:43:48.050]                 {
[17:43:48.050]                   {
[17:43:48.050]                     {
[17:43:48.050]                       {
[17:43:48.050]                         base::local({
[17:43:48.050]                           has_future <- base::requireNamespace("future", 
[17:43:48.050]                             quietly = TRUE)
[17:43:48.050]                           if (has_future) {
[17:43:48.050]                             ns <- base::getNamespace("future")
[17:43:48.050]                             version <- ns[[".package"]][["version"]]
[17:43:48.050]                             if (is.null(version)) 
[17:43:48.050]                               version <- utils::packageVersion("future")
[17:43:48.050]                           }
[17:43:48.050]                           else {
[17:43:48.050]                             version <- NULL
[17:43:48.050]                           }
[17:43:48.050]                           if (!has_future || version < "1.8.0") {
[17:43:48.050]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.050]                               "", base::R.version$version.string), 
[17:43:48.050]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:48.050]                                 base::R.version$platform, 8 * 
[17:43:48.050]                                   base::.Machine$sizeof.pointer), 
[17:43:48.050]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.050]                                 "release", "version")], collapse = " "), 
[17:43:48.050]                               hostname = base::Sys.info()[["nodename"]])
[17:43:48.050]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.050]                               info)
[17:43:48.050]                             info <- base::paste(info, collapse = "; ")
[17:43:48.050]                             if (!has_future) {
[17:43:48.050]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.050]                                 info)
[17:43:48.050]                             }
[17:43:48.050]                             else {
[17:43:48.050]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.050]                                 info, version)
[17:43:48.050]                             }
[17:43:48.050]                             base::stop(msg)
[17:43:48.050]                           }
[17:43:48.050]                         })
[17:43:48.050]                       }
[17:43:48.050]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.050]                       base::options(mc.cores = 1L)
[17:43:48.050]                     }
[17:43:48.050]                     base::local({
[17:43:48.050]                       for (pkg in "stats") {
[17:43:48.050]                         base::loadNamespace(pkg)
[17:43:48.050]                         base::library(pkg, character.only = TRUE)
[17:43:48.050]                       }
[17:43:48.050]                     })
[17:43:48.050]                   }
[17:43:48.050]                   ...future.strategy.old <- future::plan("list")
[17:43:48.050]                   options(future.plan = NULL)
[17:43:48.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.050]                 }
[17:43:48.050]                 ...future.workdir <- getwd()
[17:43:48.050]             }
[17:43:48.050]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.050]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.050]         }
[17:43:48.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.050]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.050]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.050]             base::names(...future.oldOptions))
[17:43:48.050]     }
[17:43:48.050]     if (FALSE) {
[17:43:48.050]     }
[17:43:48.050]     else {
[17:43:48.050]         if (TRUE) {
[17:43:48.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.050]                 open = "w")
[17:43:48.050]         }
[17:43:48.050]         else {
[17:43:48.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.050]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.050]         }
[17:43:48.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.050]             base::sink(type = "output", split = FALSE)
[17:43:48.050]             base::close(...future.stdout)
[17:43:48.050]         }, add = TRUE)
[17:43:48.050]     }
[17:43:48.050]     ...future.frame <- base::sys.nframe()
[17:43:48.050]     ...future.conditions <- base::list()
[17:43:48.050]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.050]     if (FALSE) {
[17:43:48.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.050]     }
[17:43:48.050]     ...future.result <- base::tryCatch({
[17:43:48.050]         base::withCallingHandlers({
[17:43:48.050]             ...future.value <- base::withVisible(base::local({
[17:43:48.050]                 withCallingHandlers({
[17:43:48.050]                   {
[17:43:48.050]                     do.call(function(...) {
[17:43:48.050]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.050]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.050]                         ...future.globals.maxSize)) {
[17:43:48.050]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.050]                         on.exit(options(oopts), add = TRUE)
[17:43:48.050]                       }
[17:43:48.050]                       {
[17:43:48.050]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.050]                           FUN = function(jj) {
[17:43:48.050]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.050]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.050]                           })
[17:43:48.050]                       }
[17:43:48.050]                     }, args = future.call.arguments)
[17:43:48.050]                   }
[17:43:48.050]                 }, immediateCondition = function(cond) {
[17:43:48.050]                   save_rds <- function (object, pathname, ...) 
[17:43:48.050]                   {
[17:43:48.050]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.050]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.050]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.050]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.050]                         fi_tmp[["mtime"]])
[17:43:48.050]                     }
[17:43:48.050]                     tryCatch({
[17:43:48.050]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.050]                     }, error = function(ex) {
[17:43:48.050]                       msg <- conditionMessage(ex)
[17:43:48.050]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.050]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.050]                         fi_tmp[["mtime"]], msg)
[17:43:48.050]                       ex$message <- msg
[17:43:48.050]                       stop(ex)
[17:43:48.050]                     })
[17:43:48.050]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.050]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.050]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.050]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.050]                       fi <- file.info(pathname)
[17:43:48.050]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.050]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.050]                         fi[["size"]], fi[["mtime"]])
[17:43:48.050]                       stop(msg)
[17:43:48.050]                     }
[17:43:48.050]                     invisible(pathname)
[17:43:48.050]                   }
[17:43:48.050]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.050]                     rootPath = tempdir()) 
[17:43:48.050]                   {
[17:43:48.050]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.050]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.050]                       tmpdir = path, fileext = ".rds")
[17:43:48.050]                     save_rds(obj, file)
[17:43:48.050]                   }
[17:43:48.050]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.050]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.050]                   {
[17:43:48.050]                     inherits <- base::inherits
[17:43:48.050]                     invokeRestart <- base::invokeRestart
[17:43:48.050]                     is.null <- base::is.null
[17:43:48.050]                     muffled <- FALSE
[17:43:48.050]                     if (inherits(cond, "message")) {
[17:43:48.050]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.050]                       if (muffled) 
[17:43:48.050]                         invokeRestart("muffleMessage")
[17:43:48.050]                     }
[17:43:48.050]                     else if (inherits(cond, "warning")) {
[17:43:48.050]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.050]                       if (muffled) 
[17:43:48.050]                         invokeRestart("muffleWarning")
[17:43:48.050]                     }
[17:43:48.050]                     else if (inherits(cond, "condition")) {
[17:43:48.050]                       if (!is.null(pattern)) {
[17:43:48.050]                         computeRestarts <- base::computeRestarts
[17:43:48.050]                         grepl <- base::grepl
[17:43:48.050]                         restarts <- computeRestarts(cond)
[17:43:48.050]                         for (restart in restarts) {
[17:43:48.050]                           name <- restart$name
[17:43:48.050]                           if (is.null(name)) 
[17:43:48.050]                             next
[17:43:48.050]                           if (!grepl(pattern, name)) 
[17:43:48.050]                             next
[17:43:48.050]                           invokeRestart(restart)
[17:43:48.050]                           muffled <- TRUE
[17:43:48.050]                           break
[17:43:48.050]                         }
[17:43:48.050]                       }
[17:43:48.050]                     }
[17:43:48.050]                     invisible(muffled)
[17:43:48.050]                   }
[17:43:48.050]                   muffleCondition(cond)
[17:43:48.050]                 })
[17:43:48.050]             }))
[17:43:48.050]             future::FutureResult(value = ...future.value$value, 
[17:43:48.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.050]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.050]                     ...future.globalenv.names))
[17:43:48.050]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.050]         }, condition = base::local({
[17:43:48.050]             c <- base::c
[17:43:48.050]             inherits <- base::inherits
[17:43:48.050]             invokeRestart <- base::invokeRestart
[17:43:48.050]             length <- base::length
[17:43:48.050]             list <- base::list
[17:43:48.050]             seq.int <- base::seq.int
[17:43:48.050]             signalCondition <- base::signalCondition
[17:43:48.050]             sys.calls <- base::sys.calls
[17:43:48.050]             `[[` <- base::`[[`
[17:43:48.050]             `+` <- base::`+`
[17:43:48.050]             `<<-` <- base::`<<-`
[17:43:48.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.050]                   3L)]
[17:43:48.050]             }
[17:43:48.050]             function(cond) {
[17:43:48.050]                 is_error <- inherits(cond, "error")
[17:43:48.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.050]                   NULL)
[17:43:48.050]                 if (is_error) {
[17:43:48.050]                   sessionInformation <- function() {
[17:43:48.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.050]                       search = base::search(), system = base::Sys.info())
[17:43:48.050]                   }
[17:43:48.050]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.050]                     cond$call), session = sessionInformation(), 
[17:43:48.050]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.050]                   signalCondition(cond)
[17:43:48.050]                 }
[17:43:48.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.050]                 "immediateCondition"))) {
[17:43:48.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.050]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.050]                   if (TRUE && !signal) {
[17:43:48.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.050]                     {
[17:43:48.050]                       inherits <- base::inherits
[17:43:48.050]                       invokeRestart <- base::invokeRestart
[17:43:48.050]                       is.null <- base::is.null
[17:43:48.050]                       muffled <- FALSE
[17:43:48.050]                       if (inherits(cond, "message")) {
[17:43:48.050]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.050]                         if (muffled) 
[17:43:48.050]                           invokeRestart("muffleMessage")
[17:43:48.050]                       }
[17:43:48.050]                       else if (inherits(cond, "warning")) {
[17:43:48.050]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.050]                         if (muffled) 
[17:43:48.050]                           invokeRestart("muffleWarning")
[17:43:48.050]                       }
[17:43:48.050]                       else if (inherits(cond, "condition")) {
[17:43:48.050]                         if (!is.null(pattern)) {
[17:43:48.050]                           computeRestarts <- base::computeRestarts
[17:43:48.050]                           grepl <- base::grepl
[17:43:48.050]                           restarts <- computeRestarts(cond)
[17:43:48.050]                           for (restart in restarts) {
[17:43:48.050]                             name <- restart$name
[17:43:48.050]                             if (is.null(name)) 
[17:43:48.050]                               next
[17:43:48.050]                             if (!grepl(pattern, name)) 
[17:43:48.050]                               next
[17:43:48.050]                             invokeRestart(restart)
[17:43:48.050]                             muffled <- TRUE
[17:43:48.050]                             break
[17:43:48.050]                           }
[17:43:48.050]                         }
[17:43:48.050]                       }
[17:43:48.050]                       invisible(muffled)
[17:43:48.050]                     }
[17:43:48.050]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.050]                   }
[17:43:48.050]                 }
[17:43:48.050]                 else {
[17:43:48.050]                   if (TRUE) {
[17:43:48.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.050]                     {
[17:43:48.050]                       inherits <- base::inherits
[17:43:48.050]                       invokeRestart <- base::invokeRestart
[17:43:48.050]                       is.null <- base::is.null
[17:43:48.050]                       muffled <- FALSE
[17:43:48.050]                       if (inherits(cond, "message")) {
[17:43:48.050]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.050]                         if (muffled) 
[17:43:48.050]                           invokeRestart("muffleMessage")
[17:43:48.050]                       }
[17:43:48.050]                       else if (inherits(cond, "warning")) {
[17:43:48.050]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.050]                         if (muffled) 
[17:43:48.050]                           invokeRestart("muffleWarning")
[17:43:48.050]                       }
[17:43:48.050]                       else if (inherits(cond, "condition")) {
[17:43:48.050]                         if (!is.null(pattern)) {
[17:43:48.050]                           computeRestarts <- base::computeRestarts
[17:43:48.050]                           grepl <- base::grepl
[17:43:48.050]                           restarts <- computeRestarts(cond)
[17:43:48.050]                           for (restart in restarts) {
[17:43:48.050]                             name <- restart$name
[17:43:48.050]                             if (is.null(name)) 
[17:43:48.050]                               next
[17:43:48.050]                             if (!grepl(pattern, name)) 
[17:43:48.050]                               next
[17:43:48.050]                             invokeRestart(restart)
[17:43:48.050]                             muffled <- TRUE
[17:43:48.050]                             break
[17:43:48.050]                           }
[17:43:48.050]                         }
[17:43:48.050]                       }
[17:43:48.050]                       invisible(muffled)
[17:43:48.050]                     }
[17:43:48.050]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.050]                   }
[17:43:48.050]                 }
[17:43:48.050]             }
[17:43:48.050]         }))
[17:43:48.050]     }, error = function(ex) {
[17:43:48.050]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.050]                 ...future.rng), started = ...future.startTime, 
[17:43:48.050]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.050]             version = "1.8"), class = "FutureResult")
[17:43:48.050]     }, finally = {
[17:43:48.050]         if (!identical(...future.workdir, getwd())) 
[17:43:48.050]             setwd(...future.workdir)
[17:43:48.050]         {
[17:43:48.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.050]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.050]             }
[17:43:48.050]             base::options(...future.oldOptions)
[17:43:48.050]             if (.Platform$OS.type == "windows") {
[17:43:48.050]                 old_names <- names(...future.oldEnvVars)
[17:43:48.050]                 envs <- base::Sys.getenv()
[17:43:48.050]                 names <- names(envs)
[17:43:48.050]                 common <- intersect(names, old_names)
[17:43:48.050]                 added <- setdiff(names, old_names)
[17:43:48.050]                 removed <- setdiff(old_names, names)
[17:43:48.050]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.050]                   envs[common]]
[17:43:48.050]                 NAMES <- toupper(changed)
[17:43:48.050]                 args <- list()
[17:43:48.050]                 for (kk in seq_along(NAMES)) {
[17:43:48.050]                   name <- changed[[kk]]
[17:43:48.050]                   NAME <- NAMES[[kk]]
[17:43:48.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.050]                     next
[17:43:48.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.050]                 }
[17:43:48.050]                 NAMES <- toupper(added)
[17:43:48.050]                 for (kk in seq_along(NAMES)) {
[17:43:48.050]                   name <- added[[kk]]
[17:43:48.050]                   NAME <- NAMES[[kk]]
[17:43:48.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.050]                     next
[17:43:48.050]                   args[[name]] <- ""
[17:43:48.050]                 }
[17:43:48.050]                 NAMES <- toupper(removed)
[17:43:48.050]                 for (kk in seq_along(NAMES)) {
[17:43:48.050]                   name <- removed[[kk]]
[17:43:48.050]                   NAME <- NAMES[[kk]]
[17:43:48.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.050]                     next
[17:43:48.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.050]                 }
[17:43:48.050]                 if (length(args) > 0) 
[17:43:48.050]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.050]             }
[17:43:48.050]             else {
[17:43:48.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.050]             }
[17:43:48.050]             {
[17:43:48.050]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.050]                   0L) {
[17:43:48.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.050]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.050]                   base::options(opts)
[17:43:48.050]                 }
[17:43:48.050]                 {
[17:43:48.050]                   {
[17:43:48.050]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.050]                     NULL
[17:43:48.050]                   }
[17:43:48.050]                   options(future.plan = NULL)
[17:43:48.050]                   if (is.na(NA_character_)) 
[17:43:48.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.050]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.050]                     .init = FALSE)
[17:43:48.050]                 }
[17:43:48.050]             }
[17:43:48.050]         }
[17:43:48.050]     })
[17:43:48.050]     if (TRUE) {
[17:43:48.050]         base::sink(type = "output", split = FALSE)
[17:43:48.050]         if (TRUE) {
[17:43:48.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.050]         }
[17:43:48.050]         else {
[17:43:48.050]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.050]         }
[17:43:48.050]         base::close(...future.stdout)
[17:43:48.050]         ...future.stdout <- NULL
[17:43:48.050]     }
[17:43:48.050]     ...future.result$conditions <- ...future.conditions
[17:43:48.050]     ...future.result$finished <- base::Sys.time()
[17:43:48.050]     ...future.result
[17:43:48.050] }
[17:43:48.053] assign_globals() ...
[17:43:48.053] List of 5
[17:43:48.053]  $ future.call.arguments    : list()
[17:43:48.053]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.053]  $ ...future.FUN            :function (x, ...)  
[17:43:48.053]  $ ...future.elements_ii    :List of 1
[17:43:48.053]   ..$ : num [1:4] 1 3 1 7
[17:43:48.053]  $ ...future.seeds_ii       : NULL
[17:43:48.053]  $ ...future.globals.maxSize: num Inf
[17:43:48.053]  - attr(*, "resolved")= logi FALSE
[17:43:48.053]  - attr(*, "total_size")= num NA
[17:43:48.053]  - attr(*, "where")=List of 5
[17:43:48.053]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.053]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.053]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.053]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.053]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.053]  - attr(*, "already-done")= logi TRUE
[17:43:48.058] - copied ‘future.call.arguments’ to environment
[17:43:48.058] - copied ‘...future.FUN’ to environment
[17:43:48.058] - copied ‘...future.elements_ii’ to environment
[17:43:48.058] - copied ‘...future.seeds_ii’ to environment
[17:43:48.058] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.058] assign_globals() ... done
[17:43:48.058] requestCore(): workers = 2
[17:43:48.063] MulticoreFuture started
[17:43:48.064] - Launch lazy future ... done
[17:43:48.064] run() for ‘MulticoreFuture’ ... done
[17:43:48.065] Created future:
[17:43:48.065] plan(): Setting new future strategy stack:
[17:43:48.066] List of future strategies:
[17:43:48.066] 1. sequential:
[17:43:48.066]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.066]    - tweaked: FALSE
[17:43:48.066]    - call: NULL
[17:43:48.068] plan(): nbrOfWorkers() = 1
[17:43:48.071] plan(): Setting new future strategy stack:
[17:43:48.071] List of future strategies:
[17:43:48.071] 1. multicore:
[17:43:48.071]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.071]    - tweaked: FALSE
[17:43:48.071]    - call: plan(strategy)
[17:43:48.077] plan(): nbrOfWorkers() = 2
[17:43:48.065] MulticoreFuture:
[17:43:48.065] Label: ‘future_apply-1’
[17:43:48.065] Expression:
[17:43:48.065] {
[17:43:48.065]     do.call(function(...) {
[17:43:48.065]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.065]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.065]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.065]             on.exit(options(oopts), add = TRUE)
[17:43:48.065]         }
[17:43:48.065]         {
[17:43:48.065]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.065]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.065]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.065]             })
[17:43:48.065]         }
[17:43:48.065]     }, args = future.call.arguments)
[17:43:48.065] }
[17:43:48.065] Lazy evaluation: FALSE
[17:43:48.065] Asynchronous evaluation: TRUE
[17:43:48.065] Local evaluation: TRUE
[17:43:48.065] Environment: R_GlobalEnv
[17:43:48.065] Capture standard output: TRUE
[17:43:48.065] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:48.065] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.065] Packages: 1 packages (‘stats’)
[17:43:48.065] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:48.065] Resolved: TRUE
[17:43:48.065] Value: <not collected>
[17:43:48.065] Conditions captured: <none>
[17:43:48.065] Early signaling: FALSE
[17:43:48.065] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.065] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.078] Chunk #1 of 2 ... DONE
[17:43:48.078] Chunk #2 of 2 ...
[17:43:48.079]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.079]  - seeds: <none>
[17:43:48.079]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.079] getGlobalsAndPackages() ...
[17:43:48.080] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.080] Resolving globals: FALSE
[17:43:48.080] Tweak future expression to call with '...' arguments ...
[17:43:48.080] {
[17:43:48.080]     do.call(function(...) {
[17:43:48.080]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.080]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.080]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.080]             on.exit(options(oopts), add = TRUE)
[17:43:48.080]         }
[17:43:48.080]         {
[17:43:48.080]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.080]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.080]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.080]             })
[17:43:48.080]         }
[17:43:48.080]     }, args = future.call.arguments)
[17:43:48.080] }
[17:43:48.081] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.081] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.082] - packages: [1] ‘stats’
[17:43:48.082] getGlobalsAndPackages() ... DONE
[17:43:48.082] run() for ‘Future’ ...
[17:43:48.082] - state: ‘created’
[17:43:48.083] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.087] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.087] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.087]   - Field: ‘label’
[17:43:48.088]   - Field: ‘local’
[17:43:48.088]   - Field: ‘owner’
[17:43:48.088]   - Field: ‘envir’
[17:43:48.088]   - Field: ‘workers’
[17:43:48.088]   - Field: ‘packages’
[17:43:48.088]   - Field: ‘gc’
[17:43:48.089]   - Field: ‘job’
[17:43:48.089]   - Field: ‘conditions’
[17:43:48.089]   - Field: ‘expr’
[17:43:48.089]   - Field: ‘uuid’
[17:43:48.089]   - Field: ‘seed’
[17:43:48.089]   - Field: ‘version’
[17:43:48.089]   - Field: ‘result’
[17:43:48.090]   - Field: ‘asynchronous’
[17:43:48.090]   - Field: ‘calls’
[17:43:48.090]   - Field: ‘globals’
[17:43:48.090]   - Field: ‘stdout’
[17:43:48.090]   - Field: ‘earlySignal’
[17:43:48.090]   - Field: ‘lazy’
[17:43:48.090]   - Field: ‘state’
[17:43:48.091] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.091] - Launch lazy future ...
[17:43:48.091] Packages needed by the future expression (n = 1): ‘stats’
[17:43:48.091] Packages needed by future strategies (n = 0): <none>
[17:43:48.092] {
[17:43:48.092]     {
[17:43:48.092]         {
[17:43:48.092]             ...future.startTime <- base::Sys.time()
[17:43:48.092]             {
[17:43:48.092]                 {
[17:43:48.092]                   {
[17:43:48.092]                     {
[17:43:48.092]                       {
[17:43:48.092]                         base::local({
[17:43:48.092]                           has_future <- base::requireNamespace("future", 
[17:43:48.092]                             quietly = TRUE)
[17:43:48.092]                           if (has_future) {
[17:43:48.092]                             ns <- base::getNamespace("future")
[17:43:48.092]                             version <- ns[[".package"]][["version"]]
[17:43:48.092]                             if (is.null(version)) 
[17:43:48.092]                               version <- utils::packageVersion("future")
[17:43:48.092]                           }
[17:43:48.092]                           else {
[17:43:48.092]                             version <- NULL
[17:43:48.092]                           }
[17:43:48.092]                           if (!has_future || version < "1.8.0") {
[17:43:48.092]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.092]                               "", base::R.version$version.string), 
[17:43:48.092]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:48.092]                                 base::R.version$platform, 8 * 
[17:43:48.092]                                   base::.Machine$sizeof.pointer), 
[17:43:48.092]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.092]                                 "release", "version")], collapse = " "), 
[17:43:48.092]                               hostname = base::Sys.info()[["nodename"]])
[17:43:48.092]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.092]                               info)
[17:43:48.092]                             info <- base::paste(info, collapse = "; ")
[17:43:48.092]                             if (!has_future) {
[17:43:48.092]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.092]                                 info)
[17:43:48.092]                             }
[17:43:48.092]                             else {
[17:43:48.092]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.092]                                 info, version)
[17:43:48.092]                             }
[17:43:48.092]                             base::stop(msg)
[17:43:48.092]                           }
[17:43:48.092]                         })
[17:43:48.092]                       }
[17:43:48.092]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.092]                       base::options(mc.cores = 1L)
[17:43:48.092]                     }
[17:43:48.092]                     base::local({
[17:43:48.092]                       for (pkg in "stats") {
[17:43:48.092]                         base::loadNamespace(pkg)
[17:43:48.092]                         base::library(pkg, character.only = TRUE)
[17:43:48.092]                       }
[17:43:48.092]                     })
[17:43:48.092]                   }
[17:43:48.092]                   ...future.strategy.old <- future::plan("list")
[17:43:48.092]                   options(future.plan = NULL)
[17:43:48.092]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.092]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.092]                 }
[17:43:48.092]                 ...future.workdir <- getwd()
[17:43:48.092]             }
[17:43:48.092]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.092]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.092]         }
[17:43:48.092]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.092]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.092]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.092]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.092]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.092]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.092]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.092]             base::names(...future.oldOptions))
[17:43:48.092]     }
[17:43:48.092]     if (FALSE) {
[17:43:48.092]     }
[17:43:48.092]     else {
[17:43:48.092]         if (TRUE) {
[17:43:48.092]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.092]                 open = "w")
[17:43:48.092]         }
[17:43:48.092]         else {
[17:43:48.092]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.092]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.092]         }
[17:43:48.092]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.092]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.092]             base::sink(type = "output", split = FALSE)
[17:43:48.092]             base::close(...future.stdout)
[17:43:48.092]         }, add = TRUE)
[17:43:48.092]     }
[17:43:48.092]     ...future.frame <- base::sys.nframe()
[17:43:48.092]     ...future.conditions <- base::list()
[17:43:48.092]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.092]     if (FALSE) {
[17:43:48.092]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.092]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.092]     }
[17:43:48.092]     ...future.result <- base::tryCatch({
[17:43:48.092]         base::withCallingHandlers({
[17:43:48.092]             ...future.value <- base::withVisible(base::local({
[17:43:48.092]                 withCallingHandlers({
[17:43:48.092]                   {
[17:43:48.092]                     do.call(function(...) {
[17:43:48.092]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.092]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.092]                         ...future.globals.maxSize)) {
[17:43:48.092]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.092]                         on.exit(options(oopts), add = TRUE)
[17:43:48.092]                       }
[17:43:48.092]                       {
[17:43:48.092]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.092]                           FUN = function(jj) {
[17:43:48.092]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.092]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.092]                           })
[17:43:48.092]                       }
[17:43:48.092]                     }, args = future.call.arguments)
[17:43:48.092]                   }
[17:43:48.092]                 }, immediateCondition = function(cond) {
[17:43:48.092]                   save_rds <- function (object, pathname, ...) 
[17:43:48.092]                   {
[17:43:48.092]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.092]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.092]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.092]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.092]                         fi_tmp[["mtime"]])
[17:43:48.092]                     }
[17:43:48.092]                     tryCatch({
[17:43:48.092]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.092]                     }, error = function(ex) {
[17:43:48.092]                       msg <- conditionMessage(ex)
[17:43:48.092]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.092]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.092]                         fi_tmp[["mtime"]], msg)
[17:43:48.092]                       ex$message <- msg
[17:43:48.092]                       stop(ex)
[17:43:48.092]                     })
[17:43:48.092]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.092]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.092]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.092]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.092]                       fi <- file.info(pathname)
[17:43:48.092]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.092]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.092]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.092]                         fi[["size"]], fi[["mtime"]])
[17:43:48.092]                       stop(msg)
[17:43:48.092]                     }
[17:43:48.092]                     invisible(pathname)
[17:43:48.092]                   }
[17:43:48.092]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.092]                     rootPath = tempdir()) 
[17:43:48.092]                   {
[17:43:48.092]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.092]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.092]                       tmpdir = path, fileext = ".rds")
[17:43:48.092]                     save_rds(obj, file)
[17:43:48.092]                   }
[17:43:48.092]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.092]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.092]                   {
[17:43:48.092]                     inherits <- base::inherits
[17:43:48.092]                     invokeRestart <- base::invokeRestart
[17:43:48.092]                     is.null <- base::is.null
[17:43:48.092]                     muffled <- FALSE
[17:43:48.092]                     if (inherits(cond, "message")) {
[17:43:48.092]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.092]                       if (muffled) 
[17:43:48.092]                         invokeRestart("muffleMessage")
[17:43:48.092]                     }
[17:43:48.092]                     else if (inherits(cond, "warning")) {
[17:43:48.092]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.092]                       if (muffled) 
[17:43:48.092]                         invokeRestart("muffleWarning")
[17:43:48.092]                     }
[17:43:48.092]                     else if (inherits(cond, "condition")) {
[17:43:48.092]                       if (!is.null(pattern)) {
[17:43:48.092]                         computeRestarts <- base::computeRestarts
[17:43:48.092]                         grepl <- base::grepl
[17:43:48.092]                         restarts <- computeRestarts(cond)
[17:43:48.092]                         for (restart in restarts) {
[17:43:48.092]                           name <- restart$name
[17:43:48.092]                           if (is.null(name)) 
[17:43:48.092]                             next
[17:43:48.092]                           if (!grepl(pattern, name)) 
[17:43:48.092]                             next
[17:43:48.092]                           invokeRestart(restart)
[17:43:48.092]                           muffled <- TRUE
[17:43:48.092]                           break
[17:43:48.092]                         }
[17:43:48.092]                       }
[17:43:48.092]                     }
[17:43:48.092]                     invisible(muffled)
[17:43:48.092]                   }
[17:43:48.092]                   muffleCondition(cond)
[17:43:48.092]                 })
[17:43:48.092]             }))
[17:43:48.092]             future::FutureResult(value = ...future.value$value, 
[17:43:48.092]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.092]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.092]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.092]                     ...future.globalenv.names))
[17:43:48.092]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.092]         }, condition = base::local({
[17:43:48.092]             c <- base::c
[17:43:48.092]             inherits <- base::inherits
[17:43:48.092]             invokeRestart <- base::invokeRestart
[17:43:48.092]             length <- base::length
[17:43:48.092]             list <- base::list
[17:43:48.092]             seq.int <- base::seq.int
[17:43:48.092]             signalCondition <- base::signalCondition
[17:43:48.092]             sys.calls <- base::sys.calls
[17:43:48.092]             `[[` <- base::`[[`
[17:43:48.092]             `+` <- base::`+`
[17:43:48.092]             `<<-` <- base::`<<-`
[17:43:48.092]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.092]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.092]                   3L)]
[17:43:48.092]             }
[17:43:48.092]             function(cond) {
[17:43:48.092]                 is_error <- inherits(cond, "error")
[17:43:48.092]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.092]                   NULL)
[17:43:48.092]                 if (is_error) {
[17:43:48.092]                   sessionInformation <- function() {
[17:43:48.092]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.092]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.092]                       search = base::search(), system = base::Sys.info())
[17:43:48.092]                   }
[17:43:48.092]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.092]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.092]                     cond$call), session = sessionInformation(), 
[17:43:48.092]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.092]                   signalCondition(cond)
[17:43:48.092]                 }
[17:43:48.092]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.092]                 "immediateCondition"))) {
[17:43:48.092]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.092]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.092]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.092]                   if (TRUE && !signal) {
[17:43:48.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.092]                     {
[17:43:48.092]                       inherits <- base::inherits
[17:43:48.092]                       invokeRestart <- base::invokeRestart
[17:43:48.092]                       is.null <- base::is.null
[17:43:48.092]                       muffled <- FALSE
[17:43:48.092]                       if (inherits(cond, "message")) {
[17:43:48.092]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.092]                         if (muffled) 
[17:43:48.092]                           invokeRestart("muffleMessage")
[17:43:48.092]                       }
[17:43:48.092]                       else if (inherits(cond, "warning")) {
[17:43:48.092]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.092]                         if (muffled) 
[17:43:48.092]                           invokeRestart("muffleWarning")
[17:43:48.092]                       }
[17:43:48.092]                       else if (inherits(cond, "condition")) {
[17:43:48.092]                         if (!is.null(pattern)) {
[17:43:48.092]                           computeRestarts <- base::computeRestarts
[17:43:48.092]                           grepl <- base::grepl
[17:43:48.092]                           restarts <- computeRestarts(cond)
[17:43:48.092]                           for (restart in restarts) {
[17:43:48.092]                             name <- restart$name
[17:43:48.092]                             if (is.null(name)) 
[17:43:48.092]                               next
[17:43:48.092]                             if (!grepl(pattern, name)) 
[17:43:48.092]                               next
[17:43:48.092]                             invokeRestart(restart)
[17:43:48.092]                             muffled <- TRUE
[17:43:48.092]                             break
[17:43:48.092]                           }
[17:43:48.092]                         }
[17:43:48.092]                       }
[17:43:48.092]                       invisible(muffled)
[17:43:48.092]                     }
[17:43:48.092]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.092]                   }
[17:43:48.092]                 }
[17:43:48.092]                 else {
[17:43:48.092]                   if (TRUE) {
[17:43:48.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.092]                     {
[17:43:48.092]                       inherits <- base::inherits
[17:43:48.092]                       invokeRestart <- base::invokeRestart
[17:43:48.092]                       is.null <- base::is.null
[17:43:48.092]                       muffled <- FALSE
[17:43:48.092]                       if (inherits(cond, "message")) {
[17:43:48.092]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.092]                         if (muffled) 
[17:43:48.092]                           invokeRestart("muffleMessage")
[17:43:48.092]                       }
[17:43:48.092]                       else if (inherits(cond, "warning")) {
[17:43:48.092]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.092]                         if (muffled) 
[17:43:48.092]                           invokeRestart("muffleWarning")
[17:43:48.092]                       }
[17:43:48.092]                       else if (inherits(cond, "condition")) {
[17:43:48.092]                         if (!is.null(pattern)) {
[17:43:48.092]                           computeRestarts <- base::computeRestarts
[17:43:48.092]                           grepl <- base::grepl
[17:43:48.092]                           restarts <- computeRestarts(cond)
[17:43:48.092]                           for (restart in restarts) {
[17:43:48.092]                             name <- restart$name
[17:43:48.092]                             if (is.null(name)) 
[17:43:48.092]                               next
[17:43:48.092]                             if (!grepl(pattern, name)) 
[17:43:48.092]                               next
[17:43:48.092]                             invokeRestart(restart)
[17:43:48.092]                             muffled <- TRUE
[17:43:48.092]                             break
[17:43:48.092]                           }
[17:43:48.092]                         }
[17:43:48.092]                       }
[17:43:48.092]                       invisible(muffled)
[17:43:48.092]                     }
[17:43:48.092]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.092]                   }
[17:43:48.092]                 }
[17:43:48.092]             }
[17:43:48.092]         }))
[17:43:48.092]     }, error = function(ex) {
[17:43:48.092]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.092]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.092]                 ...future.rng), started = ...future.startTime, 
[17:43:48.092]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.092]             version = "1.8"), class = "FutureResult")
[17:43:48.092]     }, finally = {
[17:43:48.092]         if (!identical(...future.workdir, getwd())) 
[17:43:48.092]             setwd(...future.workdir)
[17:43:48.092]         {
[17:43:48.092]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.092]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.092]             }
[17:43:48.092]             base::options(...future.oldOptions)
[17:43:48.092]             if (.Platform$OS.type == "windows") {
[17:43:48.092]                 old_names <- names(...future.oldEnvVars)
[17:43:48.092]                 envs <- base::Sys.getenv()
[17:43:48.092]                 names <- names(envs)
[17:43:48.092]                 common <- intersect(names, old_names)
[17:43:48.092]                 added <- setdiff(names, old_names)
[17:43:48.092]                 removed <- setdiff(old_names, names)
[17:43:48.092]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.092]                   envs[common]]
[17:43:48.092]                 NAMES <- toupper(changed)
[17:43:48.092]                 args <- list()
[17:43:48.092]                 for (kk in seq_along(NAMES)) {
[17:43:48.092]                   name <- changed[[kk]]
[17:43:48.092]                   NAME <- NAMES[[kk]]
[17:43:48.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.092]                     next
[17:43:48.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.092]                 }
[17:43:48.092]                 NAMES <- toupper(added)
[17:43:48.092]                 for (kk in seq_along(NAMES)) {
[17:43:48.092]                   name <- added[[kk]]
[17:43:48.092]                   NAME <- NAMES[[kk]]
[17:43:48.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.092]                     next
[17:43:48.092]                   args[[name]] <- ""
[17:43:48.092]                 }
[17:43:48.092]                 NAMES <- toupper(removed)
[17:43:48.092]                 for (kk in seq_along(NAMES)) {
[17:43:48.092]                   name <- removed[[kk]]
[17:43:48.092]                   NAME <- NAMES[[kk]]
[17:43:48.092]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.092]                     next
[17:43:48.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.092]                 }
[17:43:48.092]                 if (length(args) > 0) 
[17:43:48.092]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.092]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.092]             }
[17:43:48.092]             else {
[17:43:48.092]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.092]             }
[17:43:48.092]             {
[17:43:48.092]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.092]                   0L) {
[17:43:48.092]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.092]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.092]                   base::options(opts)
[17:43:48.092]                 }
[17:43:48.092]                 {
[17:43:48.092]                   {
[17:43:48.092]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.092]                     NULL
[17:43:48.092]                   }
[17:43:48.092]                   options(future.plan = NULL)
[17:43:48.092]                   if (is.na(NA_character_)) 
[17:43:48.092]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.092]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.092]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.092]                     .init = FALSE)
[17:43:48.092]                 }
[17:43:48.092]             }
[17:43:48.092]         }
[17:43:48.092]     })
[17:43:48.092]     if (TRUE) {
[17:43:48.092]         base::sink(type = "output", split = FALSE)
[17:43:48.092]         if (TRUE) {
[17:43:48.092]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.092]         }
[17:43:48.092]         else {
[17:43:48.092]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.092]         }
[17:43:48.092]         base::close(...future.stdout)
[17:43:48.092]         ...future.stdout <- NULL
[17:43:48.092]     }
[17:43:48.092]     ...future.result$conditions <- ...future.conditions
[17:43:48.092]     ...future.result$finished <- base::Sys.time()
[17:43:48.092]     ...future.result
[17:43:48.092] }
[17:43:48.095] assign_globals() ...
[17:43:48.095] List of 5
[17:43:48.095]  $ future.call.arguments    : list()
[17:43:48.095]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.095]  $ ...future.FUN            :function (x, ...)  
[17:43:48.095]  $ ...future.elements_ii    :List of 1
[17:43:48.095]   ..$ : num [1:4] 2 4 6 8
[17:43:48.095]  $ ...future.seeds_ii       : NULL
[17:43:48.095]  $ ...future.globals.maxSize: num Inf
[17:43:48.095]  - attr(*, "resolved")= logi FALSE
[17:43:48.095]  - attr(*, "total_size")= num NA
[17:43:48.095]  - attr(*, "where")=List of 5
[17:43:48.095]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.095]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.095]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.095]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.095]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.095]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.095]  - attr(*, "already-done")= logi TRUE
[17:43:48.102] - copied ‘future.call.arguments’ to environment
[17:43:48.102] - copied ‘...future.FUN’ to environment
[17:43:48.103] - copied ‘...future.elements_ii’ to environment
[17:43:48.103] - copied ‘...future.seeds_ii’ to environment
[17:43:48.103] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.103] assign_globals() ... done
[17:43:48.103] requestCore(): workers = 2
[17:43:48.106] MulticoreFuture started
[17:43:48.106] - Launch lazy future ... done
[17:43:48.106] run() for ‘MulticoreFuture’ ... done
[17:43:48.106] Created future:
[17:43:48.107] plan(): Setting new future strategy stack:
[17:43:48.107] List of future strategies:
[17:43:48.107] 1. sequential:
[17:43:48.107]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.107]    - tweaked: FALSE
[17:43:48.107]    - call: NULL
[17:43:48.108] plan(): nbrOfWorkers() = 1
[17:43:48.111] plan(): Setting new future strategy stack:
[17:43:48.111] List of future strategies:
[17:43:48.111] 1. multicore:
[17:43:48.111]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.111]    - tweaked: FALSE
[17:43:48.111]    - call: plan(strategy)
[17:43:48.116] plan(): nbrOfWorkers() = 2
[17:43:48.107] MulticoreFuture:
[17:43:48.107] Label: ‘future_apply-2’
[17:43:48.107] Expression:
[17:43:48.107] {
[17:43:48.107]     do.call(function(...) {
[17:43:48.107]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.107]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.107]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.107]             on.exit(options(oopts), add = TRUE)
[17:43:48.107]         }
[17:43:48.107]         {
[17:43:48.107]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.107]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.107]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.107]             })
[17:43:48.107]         }
[17:43:48.107]     }, args = future.call.arguments)
[17:43:48.107] }
[17:43:48.107] Lazy evaluation: FALSE
[17:43:48.107] Asynchronous evaluation: TRUE
[17:43:48.107] Local evaluation: TRUE
[17:43:48.107] Environment: R_GlobalEnv
[17:43:48.107] Capture standard output: TRUE
[17:43:48.107] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:48.107] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.107] Packages: 1 packages (‘stats’)
[17:43:48.107] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:48.107] Resolved: TRUE
[17:43:48.107] Value: <not collected>
[17:43:48.107] Conditions captured: <none>
[17:43:48.107] Early signaling: FALSE
[17:43:48.107] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.107] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.117] Chunk #2 of 2 ... DONE
[17:43:48.118] Launching 2 futures (chunks) ... DONE
[17:43:48.118] Resolving 2 futures (chunks) ...
[17:43:48.118] resolve() on list ...
[17:43:48.118]  recursive: 0
[17:43:48.118]  length: 2
[17:43:48.118] 
[17:43:48.119] Future #1
[17:43:48.119] result() for MulticoreFuture ...
[17:43:48.120] result() for MulticoreFuture ...
[17:43:48.120] result() for MulticoreFuture ... done
[17:43:48.120] result() for MulticoreFuture ... done
[17:43:48.120] result() for MulticoreFuture ...
[17:43:48.121] result() for MulticoreFuture ... done
[17:43:48.121] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:48.121] - nx: 2
[17:43:48.121] - relay: TRUE
[17:43:48.121] - stdout: TRUE
[17:43:48.122] - signal: TRUE
[17:43:48.122] - resignal: FALSE
[17:43:48.122] - force: TRUE
[17:43:48.122] - relayed: [n=2] FALSE, FALSE
[17:43:48.122] - queued futures: [n=2] FALSE, FALSE
[17:43:48.122]  - until=1
[17:43:48.123]  - relaying element #1
[17:43:48.123] result() for MulticoreFuture ...
[17:43:48.123] result() for MulticoreFuture ... done
[17:43:48.123] result() for MulticoreFuture ...
[17:43:48.123] result() for MulticoreFuture ... done
[17:43:48.124] result() for MulticoreFuture ...
[17:43:48.124] result() for MulticoreFuture ... done
[17:43:48.124] result() for MulticoreFuture ...
[17:43:48.124] result() for MulticoreFuture ... done
[17:43:48.124] - relayed: [n=2] TRUE, FALSE
[17:43:48.124] - queued futures: [n=2] TRUE, FALSE
[17:43:48.124] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:48.125]  length: 1 (resolved future 1)
[17:43:48.125] Future #2
[17:43:48.125] result() for MulticoreFuture ...
[17:43:48.126] result() for MulticoreFuture ...
[17:43:48.126] result() for MulticoreFuture ... done
[17:43:48.126] result() for MulticoreFuture ... done
[17:43:48.126] result() for MulticoreFuture ...
[17:43:48.126] result() for MulticoreFuture ... done
[17:43:48.127] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:48.127] - nx: 2
[17:43:48.127] - relay: TRUE
[17:43:48.130] - stdout: TRUE
[17:43:48.130] - signal: TRUE
[17:43:48.130] - resignal: FALSE
[17:43:48.130] - force: TRUE
[17:43:48.130] - relayed: [n=2] TRUE, FALSE
[17:43:48.131] - queued futures: [n=2] TRUE, FALSE
[17:43:48.131]  - until=2
[17:43:48.131]  - relaying element #2
[17:43:48.131] result() for MulticoreFuture ...
[17:43:48.131] result() for MulticoreFuture ... done
[17:43:48.131] result() for MulticoreFuture ...
[17:43:48.132] result() for MulticoreFuture ... done
[17:43:48.132] result() for MulticoreFuture ...
[17:43:48.132] result() for MulticoreFuture ... done
[17:43:48.132] result() for MulticoreFuture ...
[17:43:48.132] result() for MulticoreFuture ... done
[17:43:48.132] - relayed: [n=2] TRUE, TRUE
[17:43:48.132] - queued futures: [n=2] TRUE, TRUE
[17:43:48.133] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:48.133]  length: 0 (resolved future 2)
[17:43:48.133] Relaying remaining futures
[17:43:48.133] signalConditionsASAP(NULL, pos=0) ...
[17:43:48.133] - nx: 2
[17:43:48.133] - relay: TRUE
[17:43:48.133] - stdout: TRUE
[17:43:48.133] - signal: TRUE
[17:43:48.133] - resignal: FALSE
[17:43:48.134] - force: TRUE
[17:43:48.134] - relayed: [n=2] TRUE, TRUE
[17:43:48.134] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:48.134] - relayed: [n=2] TRUE, TRUE
[17:43:48.134] - queued futures: [n=2] TRUE, TRUE
[17:43:48.134] signalConditionsASAP(NULL, pos=0) ... done
[17:43:48.134] resolve() on list ... DONE
[17:43:48.135] result() for MulticoreFuture ...
[17:43:48.135] result() for MulticoreFuture ... done
[17:43:48.135] result() for MulticoreFuture ...
[17:43:48.135] result() for MulticoreFuture ... done
[17:43:48.135] result() for MulticoreFuture ...
[17:43:48.135] result() for MulticoreFuture ... done
[17:43:48.135] result() for MulticoreFuture ...
[17:43:48.135] result() for MulticoreFuture ... done
[17:43:48.136]  - Number of value chunks collected: 2
[17:43:48.136] Resolving 2 futures (chunks) ... DONE
[17:43:48.136] Reducing values from 2 chunks ...
[17:43:48.136]  - Number of values collected after concatenation: 2
[17:43:48.136]  - Number of values expected: 2
[17:43:48.136] Reducing values from 2 chunks ... DONE
[17:43:48.136] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[17:43:48.137] getGlobalsAndPackagesXApply() ...
[17:43:48.137]  - future.globals: TRUE
[17:43:48.137] getGlobalsAndPackages() ...
[17:43:48.137] Searching for globals...
[17:43:48.139] - globals found: [1] ‘FUN’
[17:43:48.139] Searching for globals ... DONE
[17:43:48.139] Resolving globals: FALSE
[17:43:48.139] The total size of the 1 globals is 848 bytes (848 bytes)
[17:43:48.140] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:43:48.140] - globals: [1] ‘FUN’
[17:43:48.140] 
[17:43:48.140] getGlobalsAndPackages() ... DONE
[17:43:48.140]  - globals found/used: [n=1] ‘FUN’
[17:43:48.140]  - needed namespaces: [n=0] 
[17:43:48.140] Finding globals ... DONE
[17:43:48.141]  - use_args: TRUE
[17:43:48.141]  - Getting '...' globals ...
[17:43:48.141] resolve() on list ...
[17:43:48.141]  recursive: 0
[17:43:48.141]  length: 1
[17:43:48.141]  elements: ‘...’
[17:43:48.141]  length: 0 (resolved future 1)
[17:43:48.142] resolve() on list ... DONE
[17:43:48.142]    - '...' content: [n=0] 
[17:43:48.142] List of 1
[17:43:48.142]  $ ...: list()
[17:43:48.142]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.142]  - attr(*, "where")=List of 1
[17:43:48.142]   ..$ ...:<environment: 0x55dfd2939a90> 
[17:43:48.142]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.142]  - attr(*, "resolved")= logi TRUE
[17:43:48.142]  - attr(*, "total_size")= num NA
[17:43:48.145]  - Getting '...' globals ... DONE
[17:43:48.145] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:48.145] List of 2
[17:43:48.145]  $ ...future.FUN:function (x)  
[17:43:48.145]  $ ...          : list()
[17:43:48.145]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.145]  - attr(*, "where")=List of 2
[17:43:48.145]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:48.145]   ..$ ...          :<environment: 0x55dfd2939a90> 
[17:43:48.145]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.145]  - attr(*, "resolved")= logi FALSE
[17:43:48.145]  - attr(*, "total_size")= num 848
[17:43:48.148] Packages to be attached in all futures: [n=0] 
[17:43:48.148] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.152] future_lapply() ...
[17:43:48.156] Number of chunks: 2
[17:43:48.156] getGlobalsAndPackagesXApply() ...
[17:43:48.156]  - future.globals: <name-value list> with names ‘list()’
[17:43:48.157]  - use_args: TRUE
[17:43:48.157] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:48.157] List of 2
[17:43:48.157]  $ ...          : list()
[17:43:48.157]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.157]  $ ...future.FUN:function (x)  
[17:43:48.157]  - attr(*, "where")=List of 2
[17:43:48.157]   ..$ ...          :<environment: 0x55dfd2939a90> 
[17:43:48.157]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:48.157]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.157]  - attr(*, "resolved")= logi FALSE
[17:43:48.157]  - attr(*, "total_size")= num NA
[17:43:48.164] Packages to be attached in all futures: [n=0] 
[17:43:48.164] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.165] Number of futures (= number of chunks): 2
[17:43:48.165] Launching 2 futures (chunks) ...
[17:43:48.165] Chunk #1 of 2 ...
[17:43:48.165]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.165]  - seeds: <none>
[17:43:48.165]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.165] getGlobalsAndPackages() ...
[17:43:48.165] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.166] Resolving globals: FALSE
[17:43:48.166] Tweak future expression to call with '...' arguments ...
[17:43:48.166] {
[17:43:48.166]     do.call(function(...) {
[17:43:48.166]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.166]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.166]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.166]             on.exit(options(oopts), add = TRUE)
[17:43:48.166]         }
[17:43:48.166]         {
[17:43:48.166]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.166]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.166]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.166]             })
[17:43:48.166]         }
[17:43:48.166]     }, args = future.call.arguments)
[17:43:48.166] }
[17:43:48.166] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.167] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.167] 
[17:43:48.167] getGlobalsAndPackages() ... DONE
[17:43:48.167] run() for ‘Future’ ...
[17:43:48.167] - state: ‘created’
[17:43:48.168] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.171] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.171] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.171]   - Field: ‘label’
[17:43:48.172]   - Field: ‘local’
[17:43:48.172]   - Field: ‘owner’
[17:43:48.172]   - Field: ‘envir’
[17:43:48.172]   - Field: ‘workers’
[17:43:48.172]   - Field: ‘packages’
[17:43:48.172]   - Field: ‘gc’
[17:43:48.172]   - Field: ‘job’
[17:43:48.172]   - Field: ‘conditions’
[17:43:48.172]   - Field: ‘expr’
[17:43:48.172]   - Field: ‘uuid’
[17:43:48.172]   - Field: ‘seed’
[17:43:48.173]   - Field: ‘version’
[17:43:48.173]   - Field: ‘result’
[17:43:48.173]   - Field: ‘asynchronous’
[17:43:48.173]   - Field: ‘calls’
[17:43:48.173]   - Field: ‘globals’
[17:43:48.173]   - Field: ‘stdout’
[17:43:48.173]   - Field: ‘earlySignal’
[17:43:48.173]   - Field: ‘lazy’
[17:43:48.173]   - Field: ‘state’
[17:43:48.173] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.173] - Launch lazy future ...
[17:43:48.174] Packages needed by the future expression (n = 0): <none>
[17:43:48.174] Packages needed by future strategies (n = 0): <none>
[17:43:48.174] {
[17:43:48.174]     {
[17:43:48.174]         {
[17:43:48.174]             ...future.startTime <- base::Sys.time()
[17:43:48.174]             {
[17:43:48.174]                 {
[17:43:48.174]                   {
[17:43:48.174]                     {
[17:43:48.174]                       base::local({
[17:43:48.174]                         has_future <- base::requireNamespace("future", 
[17:43:48.174]                           quietly = TRUE)
[17:43:48.174]                         if (has_future) {
[17:43:48.174]                           ns <- base::getNamespace("future")
[17:43:48.174]                           version <- ns[[".package"]][["version"]]
[17:43:48.174]                           if (is.null(version)) 
[17:43:48.174]                             version <- utils::packageVersion("future")
[17:43:48.174]                         }
[17:43:48.174]                         else {
[17:43:48.174]                           version <- NULL
[17:43:48.174]                         }
[17:43:48.174]                         if (!has_future || version < "1.8.0") {
[17:43:48.174]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.174]                             "", base::R.version$version.string), 
[17:43:48.174]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.174]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.174]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.174]                               "release", "version")], collapse = " "), 
[17:43:48.174]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.174]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.174]                             info)
[17:43:48.174]                           info <- base::paste(info, collapse = "; ")
[17:43:48.174]                           if (!has_future) {
[17:43:48.174]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.174]                               info)
[17:43:48.174]                           }
[17:43:48.174]                           else {
[17:43:48.174]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.174]                               info, version)
[17:43:48.174]                           }
[17:43:48.174]                           base::stop(msg)
[17:43:48.174]                         }
[17:43:48.174]                       })
[17:43:48.174]                     }
[17:43:48.174]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.174]                     base::options(mc.cores = 1L)
[17:43:48.174]                   }
[17:43:48.174]                   ...future.strategy.old <- future::plan("list")
[17:43:48.174]                   options(future.plan = NULL)
[17:43:48.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.174]                 }
[17:43:48.174]                 ...future.workdir <- getwd()
[17:43:48.174]             }
[17:43:48.174]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.174]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.174]         }
[17:43:48.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.174]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.174]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.174]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.174]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.174]             base::names(...future.oldOptions))
[17:43:48.174]     }
[17:43:48.174]     if (FALSE) {
[17:43:48.174]     }
[17:43:48.174]     else {
[17:43:48.174]         if (TRUE) {
[17:43:48.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.174]                 open = "w")
[17:43:48.174]         }
[17:43:48.174]         else {
[17:43:48.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.174]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.174]         }
[17:43:48.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.174]             base::sink(type = "output", split = FALSE)
[17:43:48.174]             base::close(...future.stdout)
[17:43:48.174]         }, add = TRUE)
[17:43:48.174]     }
[17:43:48.174]     ...future.frame <- base::sys.nframe()
[17:43:48.174]     ...future.conditions <- base::list()
[17:43:48.174]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.174]     if (FALSE) {
[17:43:48.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.174]     }
[17:43:48.174]     ...future.result <- base::tryCatch({
[17:43:48.174]         base::withCallingHandlers({
[17:43:48.174]             ...future.value <- base::withVisible(base::local({
[17:43:48.174]                 withCallingHandlers({
[17:43:48.174]                   {
[17:43:48.174]                     do.call(function(...) {
[17:43:48.174]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.174]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.174]                         ...future.globals.maxSize)) {
[17:43:48.174]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.174]                         on.exit(options(oopts), add = TRUE)
[17:43:48.174]                       }
[17:43:48.174]                       {
[17:43:48.174]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.174]                           FUN = function(jj) {
[17:43:48.174]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.174]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.174]                           })
[17:43:48.174]                       }
[17:43:48.174]                     }, args = future.call.arguments)
[17:43:48.174]                   }
[17:43:48.174]                 }, immediateCondition = function(cond) {
[17:43:48.174]                   save_rds <- function (object, pathname, ...) 
[17:43:48.174]                   {
[17:43:48.174]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.174]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.174]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.174]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.174]                         fi_tmp[["mtime"]])
[17:43:48.174]                     }
[17:43:48.174]                     tryCatch({
[17:43:48.174]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.174]                     }, error = function(ex) {
[17:43:48.174]                       msg <- conditionMessage(ex)
[17:43:48.174]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.174]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.174]                         fi_tmp[["mtime"]], msg)
[17:43:48.174]                       ex$message <- msg
[17:43:48.174]                       stop(ex)
[17:43:48.174]                     })
[17:43:48.174]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.174]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.174]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.174]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.174]                       fi <- file.info(pathname)
[17:43:48.174]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.174]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.174]                         fi[["size"]], fi[["mtime"]])
[17:43:48.174]                       stop(msg)
[17:43:48.174]                     }
[17:43:48.174]                     invisible(pathname)
[17:43:48.174]                   }
[17:43:48.174]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.174]                     rootPath = tempdir()) 
[17:43:48.174]                   {
[17:43:48.174]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.174]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.174]                       tmpdir = path, fileext = ".rds")
[17:43:48.174]                     save_rds(obj, file)
[17:43:48.174]                   }
[17:43:48.174]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.174]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.174]                   {
[17:43:48.174]                     inherits <- base::inherits
[17:43:48.174]                     invokeRestart <- base::invokeRestart
[17:43:48.174]                     is.null <- base::is.null
[17:43:48.174]                     muffled <- FALSE
[17:43:48.174]                     if (inherits(cond, "message")) {
[17:43:48.174]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.174]                       if (muffled) 
[17:43:48.174]                         invokeRestart("muffleMessage")
[17:43:48.174]                     }
[17:43:48.174]                     else if (inherits(cond, "warning")) {
[17:43:48.174]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.174]                       if (muffled) 
[17:43:48.174]                         invokeRestart("muffleWarning")
[17:43:48.174]                     }
[17:43:48.174]                     else if (inherits(cond, "condition")) {
[17:43:48.174]                       if (!is.null(pattern)) {
[17:43:48.174]                         computeRestarts <- base::computeRestarts
[17:43:48.174]                         grepl <- base::grepl
[17:43:48.174]                         restarts <- computeRestarts(cond)
[17:43:48.174]                         for (restart in restarts) {
[17:43:48.174]                           name <- restart$name
[17:43:48.174]                           if (is.null(name)) 
[17:43:48.174]                             next
[17:43:48.174]                           if (!grepl(pattern, name)) 
[17:43:48.174]                             next
[17:43:48.174]                           invokeRestart(restart)
[17:43:48.174]                           muffled <- TRUE
[17:43:48.174]                           break
[17:43:48.174]                         }
[17:43:48.174]                       }
[17:43:48.174]                     }
[17:43:48.174]                     invisible(muffled)
[17:43:48.174]                   }
[17:43:48.174]                   muffleCondition(cond)
[17:43:48.174]                 })
[17:43:48.174]             }))
[17:43:48.174]             future::FutureResult(value = ...future.value$value, 
[17:43:48.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.174]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.174]                     ...future.globalenv.names))
[17:43:48.174]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.174]         }, condition = base::local({
[17:43:48.174]             c <- base::c
[17:43:48.174]             inherits <- base::inherits
[17:43:48.174]             invokeRestart <- base::invokeRestart
[17:43:48.174]             length <- base::length
[17:43:48.174]             list <- base::list
[17:43:48.174]             seq.int <- base::seq.int
[17:43:48.174]             signalCondition <- base::signalCondition
[17:43:48.174]             sys.calls <- base::sys.calls
[17:43:48.174]             `[[` <- base::`[[`
[17:43:48.174]             `+` <- base::`+`
[17:43:48.174]             `<<-` <- base::`<<-`
[17:43:48.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.174]                   3L)]
[17:43:48.174]             }
[17:43:48.174]             function(cond) {
[17:43:48.174]                 is_error <- inherits(cond, "error")
[17:43:48.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.174]                   NULL)
[17:43:48.174]                 if (is_error) {
[17:43:48.174]                   sessionInformation <- function() {
[17:43:48.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.174]                       search = base::search(), system = base::Sys.info())
[17:43:48.174]                   }
[17:43:48.174]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.174]                     cond$call), session = sessionInformation(), 
[17:43:48.174]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.174]                   signalCondition(cond)
[17:43:48.174]                 }
[17:43:48.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.174]                 "immediateCondition"))) {
[17:43:48.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.174]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.174]                   if (TRUE && !signal) {
[17:43:48.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.174]                     {
[17:43:48.174]                       inherits <- base::inherits
[17:43:48.174]                       invokeRestart <- base::invokeRestart
[17:43:48.174]                       is.null <- base::is.null
[17:43:48.174]                       muffled <- FALSE
[17:43:48.174]                       if (inherits(cond, "message")) {
[17:43:48.174]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.174]                         if (muffled) 
[17:43:48.174]                           invokeRestart("muffleMessage")
[17:43:48.174]                       }
[17:43:48.174]                       else if (inherits(cond, "warning")) {
[17:43:48.174]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.174]                         if (muffled) 
[17:43:48.174]                           invokeRestart("muffleWarning")
[17:43:48.174]                       }
[17:43:48.174]                       else if (inherits(cond, "condition")) {
[17:43:48.174]                         if (!is.null(pattern)) {
[17:43:48.174]                           computeRestarts <- base::computeRestarts
[17:43:48.174]                           grepl <- base::grepl
[17:43:48.174]                           restarts <- computeRestarts(cond)
[17:43:48.174]                           for (restart in restarts) {
[17:43:48.174]                             name <- restart$name
[17:43:48.174]                             if (is.null(name)) 
[17:43:48.174]                               next
[17:43:48.174]                             if (!grepl(pattern, name)) 
[17:43:48.174]                               next
[17:43:48.174]                             invokeRestart(restart)
[17:43:48.174]                             muffled <- TRUE
[17:43:48.174]                             break
[17:43:48.174]                           }
[17:43:48.174]                         }
[17:43:48.174]                       }
[17:43:48.174]                       invisible(muffled)
[17:43:48.174]                     }
[17:43:48.174]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.174]                   }
[17:43:48.174]                 }
[17:43:48.174]                 else {
[17:43:48.174]                   if (TRUE) {
[17:43:48.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.174]                     {
[17:43:48.174]                       inherits <- base::inherits
[17:43:48.174]                       invokeRestart <- base::invokeRestart
[17:43:48.174]                       is.null <- base::is.null
[17:43:48.174]                       muffled <- FALSE
[17:43:48.174]                       if (inherits(cond, "message")) {
[17:43:48.174]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.174]                         if (muffled) 
[17:43:48.174]                           invokeRestart("muffleMessage")
[17:43:48.174]                       }
[17:43:48.174]                       else if (inherits(cond, "warning")) {
[17:43:48.174]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.174]                         if (muffled) 
[17:43:48.174]                           invokeRestart("muffleWarning")
[17:43:48.174]                       }
[17:43:48.174]                       else if (inherits(cond, "condition")) {
[17:43:48.174]                         if (!is.null(pattern)) {
[17:43:48.174]                           computeRestarts <- base::computeRestarts
[17:43:48.174]                           grepl <- base::grepl
[17:43:48.174]                           restarts <- computeRestarts(cond)
[17:43:48.174]                           for (restart in restarts) {
[17:43:48.174]                             name <- restart$name
[17:43:48.174]                             if (is.null(name)) 
[17:43:48.174]                               next
[17:43:48.174]                             if (!grepl(pattern, name)) 
[17:43:48.174]                               next
[17:43:48.174]                             invokeRestart(restart)
[17:43:48.174]                             muffled <- TRUE
[17:43:48.174]                             break
[17:43:48.174]                           }
[17:43:48.174]                         }
[17:43:48.174]                       }
[17:43:48.174]                       invisible(muffled)
[17:43:48.174]                     }
[17:43:48.174]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.174]                   }
[17:43:48.174]                 }
[17:43:48.174]             }
[17:43:48.174]         }))
[17:43:48.174]     }, error = function(ex) {
[17:43:48.174]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.174]                 ...future.rng), started = ...future.startTime, 
[17:43:48.174]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.174]             version = "1.8"), class = "FutureResult")
[17:43:48.174]     }, finally = {
[17:43:48.174]         if (!identical(...future.workdir, getwd())) 
[17:43:48.174]             setwd(...future.workdir)
[17:43:48.174]         {
[17:43:48.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.174]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.174]             }
[17:43:48.174]             base::options(...future.oldOptions)
[17:43:48.174]             if (.Platform$OS.type == "windows") {
[17:43:48.174]                 old_names <- names(...future.oldEnvVars)
[17:43:48.174]                 envs <- base::Sys.getenv()
[17:43:48.174]                 names <- names(envs)
[17:43:48.174]                 common <- intersect(names, old_names)
[17:43:48.174]                 added <- setdiff(names, old_names)
[17:43:48.174]                 removed <- setdiff(old_names, names)
[17:43:48.174]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.174]                   envs[common]]
[17:43:48.174]                 NAMES <- toupper(changed)
[17:43:48.174]                 args <- list()
[17:43:48.174]                 for (kk in seq_along(NAMES)) {
[17:43:48.174]                   name <- changed[[kk]]
[17:43:48.174]                   NAME <- NAMES[[kk]]
[17:43:48.174]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.174]                     next
[17:43:48.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.174]                 }
[17:43:48.174]                 NAMES <- toupper(added)
[17:43:48.174]                 for (kk in seq_along(NAMES)) {
[17:43:48.174]                   name <- added[[kk]]
[17:43:48.174]                   NAME <- NAMES[[kk]]
[17:43:48.174]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.174]                     next
[17:43:48.174]                   args[[name]] <- ""
[17:43:48.174]                 }
[17:43:48.174]                 NAMES <- toupper(removed)
[17:43:48.174]                 for (kk in seq_along(NAMES)) {
[17:43:48.174]                   name <- removed[[kk]]
[17:43:48.174]                   NAME <- NAMES[[kk]]
[17:43:48.174]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.174]                     next
[17:43:48.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.174]                 }
[17:43:48.174]                 if (length(args) > 0) 
[17:43:48.174]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.174]             }
[17:43:48.174]             else {
[17:43:48.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.174]             }
[17:43:48.174]             {
[17:43:48.174]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.174]                   0L) {
[17:43:48.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.174]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.174]                   base::options(opts)
[17:43:48.174]                 }
[17:43:48.174]                 {
[17:43:48.174]                   {
[17:43:48.174]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.174]                     NULL
[17:43:48.174]                   }
[17:43:48.174]                   options(future.plan = NULL)
[17:43:48.174]                   if (is.na(NA_character_)) 
[17:43:48.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.174]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.174]                     .init = FALSE)
[17:43:48.174]                 }
[17:43:48.174]             }
[17:43:48.174]         }
[17:43:48.174]     })
[17:43:48.174]     if (TRUE) {
[17:43:48.174]         base::sink(type = "output", split = FALSE)
[17:43:48.174]         if (TRUE) {
[17:43:48.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.174]         }
[17:43:48.174]         else {
[17:43:48.174]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.174]         }
[17:43:48.174]         base::close(...future.stdout)
[17:43:48.174]         ...future.stdout <- NULL
[17:43:48.174]     }
[17:43:48.174]     ...future.result$conditions <- ...future.conditions
[17:43:48.174]     ...future.result$finished <- base::Sys.time()
[17:43:48.174]     ...future.result
[17:43:48.174] }
[17:43:48.177] assign_globals() ...
[17:43:48.177] List of 5
[17:43:48.177]  $ future.call.arguments    : list()
[17:43:48.177]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.177]  $ ...future.FUN            :function (x)  
[17:43:48.177]  $ ...future.elements_ii    :List of 1
[17:43:48.177]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:43:48.177]  $ ...future.seeds_ii       : NULL
[17:43:48.177]  $ ...future.globals.maxSize: num Inf
[17:43:48.177]  - attr(*, "resolved")= logi FALSE
[17:43:48.177]  - attr(*, "total_size")= num NA
[17:43:48.177]  - attr(*, "where")=List of 5
[17:43:48.177]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.177]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.177]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.177]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.177]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.177]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.177]  - attr(*, "already-done")= logi TRUE
[17:43:48.183] - copied ‘future.call.arguments’ to environment
[17:43:48.183] - copied ‘...future.FUN’ to environment
[17:43:48.183] - copied ‘...future.elements_ii’ to environment
[17:43:48.183] - copied ‘...future.seeds_ii’ to environment
[17:43:48.183] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.183] assign_globals() ... done
[17:43:48.183] requestCore(): workers = 2
[17:43:48.185] MulticoreFuture started
[17:43:48.186] - Launch lazy future ... done
[17:43:48.186] run() for ‘MulticoreFuture’ ... done
[17:43:48.186] Created future:
[17:43:48.187] plan(): Setting new future strategy stack:
[17:43:48.187] List of future strategies:
[17:43:48.187] 1. sequential:
[17:43:48.187]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.187]    - tweaked: FALSE
[17:43:48.187]    - call: NULL
[17:43:48.188] plan(): nbrOfWorkers() = 1
[17:43:48.190] plan(): Setting new future strategy stack:
[17:43:48.190] List of future strategies:
[17:43:48.190] 1. multicore:
[17:43:48.190]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.190]    - tweaked: FALSE
[17:43:48.190]    - call: plan(strategy)
[17:43:48.195] plan(): nbrOfWorkers() = 2
[17:43:48.187] MulticoreFuture:
[17:43:48.187] Label: ‘future_apply-1’
[17:43:48.187] Expression:
[17:43:48.187] {
[17:43:48.187]     do.call(function(...) {
[17:43:48.187]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.187]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.187]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.187]             on.exit(options(oopts), add = TRUE)
[17:43:48.187]         }
[17:43:48.187]         {
[17:43:48.187]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.187]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.187]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.187]             })
[17:43:48.187]         }
[17:43:48.187]     }, args = future.call.arguments)
[17:43:48.187] }
[17:43:48.187] Lazy evaluation: FALSE
[17:43:48.187] Asynchronous evaluation: TRUE
[17:43:48.187] Local evaluation: TRUE
[17:43:48.187] Environment: R_GlobalEnv
[17:43:48.187] Capture standard output: TRUE
[17:43:48.187] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:48.187] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.187] Packages: <none>
[17:43:48.187] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:48.187] Resolved: TRUE
[17:43:48.187] Value: <not collected>
[17:43:48.187] Conditions captured: <none>
[17:43:48.187] Early signaling: FALSE
[17:43:48.187] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.187] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.197] Chunk #1 of 2 ... DONE
[17:43:48.197] Chunk #2 of 2 ...
[17:43:48.197]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.197]  - seeds: <none>
[17:43:48.197]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.198] getGlobalsAndPackages() ...
[17:43:48.198] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.198] Resolving globals: FALSE
[17:43:48.198] Tweak future expression to call with '...' arguments ...
[17:43:48.198] {
[17:43:48.198]     do.call(function(...) {
[17:43:48.198]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.198]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.198]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.198]             on.exit(options(oopts), add = TRUE)
[17:43:48.198]         }
[17:43:48.198]         {
[17:43:48.198]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.198]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.198]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.198]             })
[17:43:48.198]         }
[17:43:48.198]     }, args = future.call.arguments)
[17:43:48.198] }
[17:43:48.199] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.199] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.200] 
[17:43:48.200] getGlobalsAndPackages() ... DONE
[17:43:48.200] run() for ‘Future’ ...
[17:43:48.200] - state: ‘created’
[17:43:48.201] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.205] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.206] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.206]   - Field: ‘label’
[17:43:48.206]   - Field: ‘local’
[17:43:48.206]   - Field: ‘owner’
[17:43:48.206]   - Field: ‘envir’
[17:43:48.206]   - Field: ‘workers’
[17:43:48.207]   - Field: ‘packages’
[17:43:48.207]   - Field: ‘gc’
[17:43:48.207]   - Field: ‘job’
[17:43:48.207]   - Field: ‘conditions’
[17:43:48.207]   - Field: ‘expr’
[17:43:48.207]   - Field: ‘uuid’
[17:43:48.207]   - Field: ‘seed’
[17:43:48.208]   - Field: ‘version’
[17:43:48.208]   - Field: ‘result’
[17:43:48.208]   - Field: ‘asynchronous’
[17:43:48.208]   - Field: ‘calls’
[17:43:48.208]   - Field: ‘globals’
[17:43:48.208]   - Field: ‘stdout’
[17:43:48.208]   - Field: ‘earlySignal’
[17:43:48.209]   - Field: ‘lazy’
[17:43:48.209]   - Field: ‘state’
[17:43:48.209] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.209] - Launch lazy future ...
[17:43:48.209] Packages needed by the future expression (n = 0): <none>
[17:43:48.210] Packages needed by future strategies (n = 0): <none>
[17:43:48.210] {
[17:43:48.210]     {
[17:43:48.210]         {
[17:43:48.210]             ...future.startTime <- base::Sys.time()
[17:43:48.210]             {
[17:43:48.210]                 {
[17:43:48.210]                   {
[17:43:48.210]                     {
[17:43:48.210]                       base::local({
[17:43:48.210]                         has_future <- base::requireNamespace("future", 
[17:43:48.210]                           quietly = TRUE)
[17:43:48.210]                         if (has_future) {
[17:43:48.210]                           ns <- base::getNamespace("future")
[17:43:48.210]                           version <- ns[[".package"]][["version"]]
[17:43:48.210]                           if (is.null(version)) 
[17:43:48.210]                             version <- utils::packageVersion("future")
[17:43:48.210]                         }
[17:43:48.210]                         else {
[17:43:48.210]                           version <- NULL
[17:43:48.210]                         }
[17:43:48.210]                         if (!has_future || version < "1.8.0") {
[17:43:48.210]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.210]                             "", base::R.version$version.string), 
[17:43:48.210]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.210]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.210]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.210]                               "release", "version")], collapse = " "), 
[17:43:48.210]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.210]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.210]                             info)
[17:43:48.210]                           info <- base::paste(info, collapse = "; ")
[17:43:48.210]                           if (!has_future) {
[17:43:48.210]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.210]                               info)
[17:43:48.210]                           }
[17:43:48.210]                           else {
[17:43:48.210]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.210]                               info, version)
[17:43:48.210]                           }
[17:43:48.210]                           base::stop(msg)
[17:43:48.210]                         }
[17:43:48.210]                       })
[17:43:48.210]                     }
[17:43:48.210]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.210]                     base::options(mc.cores = 1L)
[17:43:48.210]                   }
[17:43:48.210]                   ...future.strategy.old <- future::plan("list")
[17:43:48.210]                   options(future.plan = NULL)
[17:43:48.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.210]                 }
[17:43:48.210]                 ...future.workdir <- getwd()
[17:43:48.210]             }
[17:43:48.210]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.210]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.210]         }
[17:43:48.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.210]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.210]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.210]             base::names(...future.oldOptions))
[17:43:48.210]     }
[17:43:48.210]     if (FALSE) {
[17:43:48.210]     }
[17:43:48.210]     else {
[17:43:48.210]         if (TRUE) {
[17:43:48.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.210]                 open = "w")
[17:43:48.210]         }
[17:43:48.210]         else {
[17:43:48.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.210]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.210]         }
[17:43:48.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.210]             base::sink(type = "output", split = FALSE)
[17:43:48.210]             base::close(...future.stdout)
[17:43:48.210]         }, add = TRUE)
[17:43:48.210]     }
[17:43:48.210]     ...future.frame <- base::sys.nframe()
[17:43:48.210]     ...future.conditions <- base::list()
[17:43:48.210]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.210]     if (FALSE) {
[17:43:48.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.210]     }
[17:43:48.210]     ...future.result <- base::tryCatch({
[17:43:48.210]         base::withCallingHandlers({
[17:43:48.210]             ...future.value <- base::withVisible(base::local({
[17:43:48.210]                 withCallingHandlers({
[17:43:48.210]                   {
[17:43:48.210]                     do.call(function(...) {
[17:43:48.210]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.210]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.210]                         ...future.globals.maxSize)) {
[17:43:48.210]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.210]                         on.exit(options(oopts), add = TRUE)
[17:43:48.210]                       }
[17:43:48.210]                       {
[17:43:48.210]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.210]                           FUN = function(jj) {
[17:43:48.210]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.210]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.210]                           })
[17:43:48.210]                       }
[17:43:48.210]                     }, args = future.call.arguments)
[17:43:48.210]                   }
[17:43:48.210]                 }, immediateCondition = function(cond) {
[17:43:48.210]                   save_rds <- function (object, pathname, ...) 
[17:43:48.210]                   {
[17:43:48.210]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.210]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.210]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.210]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.210]                         fi_tmp[["mtime"]])
[17:43:48.210]                     }
[17:43:48.210]                     tryCatch({
[17:43:48.210]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.210]                     }, error = function(ex) {
[17:43:48.210]                       msg <- conditionMessage(ex)
[17:43:48.210]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.210]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.210]                         fi_tmp[["mtime"]], msg)
[17:43:48.210]                       ex$message <- msg
[17:43:48.210]                       stop(ex)
[17:43:48.210]                     })
[17:43:48.210]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.210]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.210]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.210]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.210]                       fi <- file.info(pathname)
[17:43:48.210]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.210]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.210]                         fi[["size"]], fi[["mtime"]])
[17:43:48.210]                       stop(msg)
[17:43:48.210]                     }
[17:43:48.210]                     invisible(pathname)
[17:43:48.210]                   }
[17:43:48.210]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.210]                     rootPath = tempdir()) 
[17:43:48.210]                   {
[17:43:48.210]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.210]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.210]                       tmpdir = path, fileext = ".rds")
[17:43:48.210]                     save_rds(obj, file)
[17:43:48.210]                   }
[17:43:48.210]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.210]                   {
[17:43:48.210]                     inherits <- base::inherits
[17:43:48.210]                     invokeRestart <- base::invokeRestart
[17:43:48.210]                     is.null <- base::is.null
[17:43:48.210]                     muffled <- FALSE
[17:43:48.210]                     if (inherits(cond, "message")) {
[17:43:48.210]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.210]                       if (muffled) 
[17:43:48.210]                         invokeRestart("muffleMessage")
[17:43:48.210]                     }
[17:43:48.210]                     else if (inherits(cond, "warning")) {
[17:43:48.210]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.210]                       if (muffled) 
[17:43:48.210]                         invokeRestart("muffleWarning")
[17:43:48.210]                     }
[17:43:48.210]                     else if (inherits(cond, "condition")) {
[17:43:48.210]                       if (!is.null(pattern)) {
[17:43:48.210]                         computeRestarts <- base::computeRestarts
[17:43:48.210]                         grepl <- base::grepl
[17:43:48.210]                         restarts <- computeRestarts(cond)
[17:43:48.210]                         for (restart in restarts) {
[17:43:48.210]                           name <- restart$name
[17:43:48.210]                           if (is.null(name)) 
[17:43:48.210]                             next
[17:43:48.210]                           if (!grepl(pattern, name)) 
[17:43:48.210]                             next
[17:43:48.210]                           invokeRestart(restart)
[17:43:48.210]                           muffled <- TRUE
[17:43:48.210]                           break
[17:43:48.210]                         }
[17:43:48.210]                       }
[17:43:48.210]                     }
[17:43:48.210]                     invisible(muffled)
[17:43:48.210]                   }
[17:43:48.210]                   muffleCondition(cond)
[17:43:48.210]                 })
[17:43:48.210]             }))
[17:43:48.210]             future::FutureResult(value = ...future.value$value, 
[17:43:48.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.210]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.210]                     ...future.globalenv.names))
[17:43:48.210]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.210]         }, condition = base::local({
[17:43:48.210]             c <- base::c
[17:43:48.210]             inherits <- base::inherits
[17:43:48.210]             invokeRestart <- base::invokeRestart
[17:43:48.210]             length <- base::length
[17:43:48.210]             list <- base::list
[17:43:48.210]             seq.int <- base::seq.int
[17:43:48.210]             signalCondition <- base::signalCondition
[17:43:48.210]             sys.calls <- base::sys.calls
[17:43:48.210]             `[[` <- base::`[[`
[17:43:48.210]             `+` <- base::`+`
[17:43:48.210]             `<<-` <- base::`<<-`
[17:43:48.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.210]                   3L)]
[17:43:48.210]             }
[17:43:48.210]             function(cond) {
[17:43:48.210]                 is_error <- inherits(cond, "error")
[17:43:48.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.210]                   NULL)
[17:43:48.210]                 if (is_error) {
[17:43:48.210]                   sessionInformation <- function() {
[17:43:48.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.210]                       search = base::search(), system = base::Sys.info())
[17:43:48.210]                   }
[17:43:48.210]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.210]                     cond$call), session = sessionInformation(), 
[17:43:48.210]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.210]                   signalCondition(cond)
[17:43:48.210]                 }
[17:43:48.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.210]                 "immediateCondition"))) {
[17:43:48.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.210]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.210]                   if (TRUE && !signal) {
[17:43:48.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.210]                     {
[17:43:48.210]                       inherits <- base::inherits
[17:43:48.210]                       invokeRestart <- base::invokeRestart
[17:43:48.210]                       is.null <- base::is.null
[17:43:48.210]                       muffled <- FALSE
[17:43:48.210]                       if (inherits(cond, "message")) {
[17:43:48.210]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.210]                         if (muffled) 
[17:43:48.210]                           invokeRestart("muffleMessage")
[17:43:48.210]                       }
[17:43:48.210]                       else if (inherits(cond, "warning")) {
[17:43:48.210]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.210]                         if (muffled) 
[17:43:48.210]                           invokeRestart("muffleWarning")
[17:43:48.210]                       }
[17:43:48.210]                       else if (inherits(cond, "condition")) {
[17:43:48.210]                         if (!is.null(pattern)) {
[17:43:48.210]                           computeRestarts <- base::computeRestarts
[17:43:48.210]                           grepl <- base::grepl
[17:43:48.210]                           restarts <- computeRestarts(cond)
[17:43:48.210]                           for (restart in restarts) {
[17:43:48.210]                             name <- restart$name
[17:43:48.210]                             if (is.null(name)) 
[17:43:48.210]                               next
[17:43:48.210]                             if (!grepl(pattern, name)) 
[17:43:48.210]                               next
[17:43:48.210]                             invokeRestart(restart)
[17:43:48.210]                             muffled <- TRUE
[17:43:48.210]                             break
[17:43:48.210]                           }
[17:43:48.210]                         }
[17:43:48.210]                       }
[17:43:48.210]                       invisible(muffled)
[17:43:48.210]                     }
[17:43:48.210]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.210]                   }
[17:43:48.210]                 }
[17:43:48.210]                 else {
[17:43:48.210]                   if (TRUE) {
[17:43:48.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.210]                     {
[17:43:48.210]                       inherits <- base::inherits
[17:43:48.210]                       invokeRestart <- base::invokeRestart
[17:43:48.210]                       is.null <- base::is.null
[17:43:48.210]                       muffled <- FALSE
[17:43:48.210]                       if (inherits(cond, "message")) {
[17:43:48.210]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.210]                         if (muffled) 
[17:43:48.210]                           invokeRestart("muffleMessage")
[17:43:48.210]                       }
[17:43:48.210]                       else if (inherits(cond, "warning")) {
[17:43:48.210]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.210]                         if (muffled) 
[17:43:48.210]                           invokeRestart("muffleWarning")
[17:43:48.210]                       }
[17:43:48.210]                       else if (inherits(cond, "condition")) {
[17:43:48.210]                         if (!is.null(pattern)) {
[17:43:48.210]                           computeRestarts <- base::computeRestarts
[17:43:48.210]                           grepl <- base::grepl
[17:43:48.210]                           restarts <- computeRestarts(cond)
[17:43:48.210]                           for (restart in restarts) {
[17:43:48.210]                             name <- restart$name
[17:43:48.210]                             if (is.null(name)) 
[17:43:48.210]                               next
[17:43:48.210]                             if (!grepl(pattern, name)) 
[17:43:48.210]                               next
[17:43:48.210]                             invokeRestart(restart)
[17:43:48.210]                             muffled <- TRUE
[17:43:48.210]                             break
[17:43:48.210]                           }
[17:43:48.210]                         }
[17:43:48.210]                       }
[17:43:48.210]                       invisible(muffled)
[17:43:48.210]                     }
[17:43:48.210]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.210]                   }
[17:43:48.210]                 }
[17:43:48.210]             }
[17:43:48.210]         }))
[17:43:48.210]     }, error = function(ex) {
[17:43:48.210]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.210]                 ...future.rng), started = ...future.startTime, 
[17:43:48.210]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.210]             version = "1.8"), class = "FutureResult")
[17:43:48.210]     }, finally = {
[17:43:48.210]         if (!identical(...future.workdir, getwd())) 
[17:43:48.210]             setwd(...future.workdir)
[17:43:48.210]         {
[17:43:48.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.210]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.210]             }
[17:43:48.210]             base::options(...future.oldOptions)
[17:43:48.210]             if (.Platform$OS.type == "windows") {
[17:43:48.210]                 old_names <- names(...future.oldEnvVars)
[17:43:48.210]                 envs <- base::Sys.getenv()
[17:43:48.210]                 names <- names(envs)
[17:43:48.210]                 common <- intersect(names, old_names)
[17:43:48.210]                 added <- setdiff(names, old_names)
[17:43:48.210]                 removed <- setdiff(old_names, names)
[17:43:48.210]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.210]                   envs[common]]
[17:43:48.210]                 NAMES <- toupper(changed)
[17:43:48.210]                 args <- list()
[17:43:48.210]                 for (kk in seq_along(NAMES)) {
[17:43:48.210]                   name <- changed[[kk]]
[17:43:48.210]                   NAME <- NAMES[[kk]]
[17:43:48.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.210]                     next
[17:43:48.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.210]                 }
[17:43:48.210]                 NAMES <- toupper(added)
[17:43:48.210]                 for (kk in seq_along(NAMES)) {
[17:43:48.210]                   name <- added[[kk]]
[17:43:48.210]                   NAME <- NAMES[[kk]]
[17:43:48.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.210]                     next
[17:43:48.210]                   args[[name]] <- ""
[17:43:48.210]                 }
[17:43:48.210]                 NAMES <- toupper(removed)
[17:43:48.210]                 for (kk in seq_along(NAMES)) {
[17:43:48.210]                   name <- removed[[kk]]
[17:43:48.210]                   NAME <- NAMES[[kk]]
[17:43:48.210]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.210]                     next
[17:43:48.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.210]                 }
[17:43:48.210]                 if (length(args) > 0) 
[17:43:48.210]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.210]             }
[17:43:48.210]             else {
[17:43:48.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.210]             }
[17:43:48.210]             {
[17:43:48.210]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.210]                   0L) {
[17:43:48.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.210]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.210]                   base::options(opts)
[17:43:48.210]                 }
[17:43:48.210]                 {
[17:43:48.210]                   {
[17:43:48.210]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.210]                     NULL
[17:43:48.210]                   }
[17:43:48.210]                   options(future.plan = NULL)
[17:43:48.210]                   if (is.na(NA_character_)) 
[17:43:48.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.210]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.210]                     .init = FALSE)
[17:43:48.210]                 }
[17:43:48.210]             }
[17:43:48.210]         }
[17:43:48.210]     })
[17:43:48.210]     if (TRUE) {
[17:43:48.210]         base::sink(type = "output", split = FALSE)
[17:43:48.210]         if (TRUE) {
[17:43:48.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.210]         }
[17:43:48.210]         else {
[17:43:48.210]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.210]         }
[17:43:48.210]         base::close(...future.stdout)
[17:43:48.210]         ...future.stdout <- NULL
[17:43:48.210]     }
[17:43:48.210]     ...future.result$conditions <- ...future.conditions
[17:43:48.210]     ...future.result$finished <- base::Sys.time()
[17:43:48.210]     ...future.result
[17:43:48.210] }
[17:43:48.214] assign_globals() ...
[17:43:48.214] List of 5
[17:43:48.214]  $ future.call.arguments    : list()
[17:43:48.214]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.214]  $ ...future.FUN            :function (x)  
[17:43:48.214]  $ ...future.elements_ii    :List of 1
[17:43:48.214]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:43:48.214]  $ ...future.seeds_ii       : NULL
[17:43:48.214]  $ ...future.globals.maxSize: num Inf
[17:43:48.214]  - attr(*, "resolved")= logi FALSE
[17:43:48.214]  - attr(*, "total_size")= num NA
[17:43:48.214]  - attr(*, "where")=List of 5
[17:43:48.214]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.214]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.214]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.214]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.214]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.214]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.214]  - attr(*, "already-done")= logi TRUE
[17:43:48.228] - copied ‘future.call.arguments’ to environment
[17:43:48.228] - copied ‘...future.FUN’ to environment
[17:43:48.228] - copied ‘...future.elements_ii’ to environment
[17:43:48.229] - copied ‘...future.seeds_ii’ to environment
[17:43:48.229] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.229] assign_globals() ... done
[17:43:48.229] requestCore(): workers = 2
[17:43:48.232] MulticoreFuture started
[17:43:48.232] - Launch lazy future ... done
[17:43:48.232] run() for ‘MulticoreFuture’ ... done
[17:43:48.233] Created future:
[17:43:48.233] plan(): Setting new future strategy stack:
[17:43:48.233] List of future strategies:
[17:43:48.233] 1. sequential:
[17:43:48.233]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.233]    - tweaked: FALSE
[17:43:48.233]    - call: NULL
[17:43:48.234] plan(): nbrOfWorkers() = 1
[17:43:48.237] plan(): Setting new future strategy stack:
[17:43:48.237] List of future strategies:
[17:43:48.237] 1. multicore:
[17:43:48.237]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.237]    - tweaked: FALSE
[17:43:48.237]    - call: plan(strategy)
[17:43:48.242] plan(): nbrOfWorkers() = 2
[17:43:48.233] MulticoreFuture:
[17:43:48.233] Label: ‘future_apply-2’
[17:43:48.233] Expression:
[17:43:48.233] {
[17:43:48.233]     do.call(function(...) {
[17:43:48.233]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.233]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.233]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.233]             on.exit(options(oopts), add = TRUE)
[17:43:48.233]         }
[17:43:48.233]         {
[17:43:48.233]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.233]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.233]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.233]             })
[17:43:48.233]         }
[17:43:48.233]     }, args = future.call.arguments)
[17:43:48.233] }
[17:43:48.233] Lazy evaluation: FALSE
[17:43:48.233] Asynchronous evaluation: TRUE
[17:43:48.233] Local evaluation: TRUE
[17:43:48.233] Environment: R_GlobalEnv
[17:43:48.233] Capture standard output: TRUE
[17:43:48.233] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:48.233] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.233] Packages: <none>
[17:43:48.233] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:48.233] Resolved: TRUE
[17:43:48.233] Value: <not collected>
[17:43:48.233] Conditions captured: <none>
[17:43:48.233] Early signaling: FALSE
[17:43:48.233] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.233] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.243] Chunk #2 of 2 ... DONE
[17:43:48.243] Launching 2 futures (chunks) ... DONE
[17:43:48.244] Resolving 2 futures (chunks) ...
[17:43:48.244] resolve() on list ...
[17:43:48.244]  recursive: 0
[17:43:48.244]  length: 2
[17:43:48.244] 
[17:43:48.245] Future #1
[17:43:48.245] result() for MulticoreFuture ...
[17:43:48.246] result() for MulticoreFuture ...
[17:43:48.246] result() for MulticoreFuture ... done
[17:43:48.246] result() for MulticoreFuture ... done
[17:43:48.247] result() for MulticoreFuture ...
[17:43:48.247] result() for MulticoreFuture ... done
[17:43:48.247] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:48.247] - nx: 2
[17:43:48.247] - relay: TRUE
[17:43:48.248] - stdout: TRUE
[17:43:48.248] - signal: TRUE
[17:43:48.248] - resignal: FALSE
[17:43:48.248] - force: TRUE
[17:43:48.248] - relayed: [n=2] FALSE, FALSE
[17:43:48.248] - queued futures: [n=2] FALSE, FALSE
[17:43:48.249]  - until=1
[17:43:48.249]  - relaying element #1
[17:43:48.249] result() for MulticoreFuture ...
[17:43:48.249] result() for MulticoreFuture ... done
[17:43:48.249] result() for MulticoreFuture ...
[17:43:48.250] result() for MulticoreFuture ... done
[17:43:48.250] result() for MulticoreFuture ...
[17:43:48.250] result() for MulticoreFuture ... done
[17:43:48.250] result() for MulticoreFuture ...
[17:43:48.250] result() for MulticoreFuture ... done
[17:43:48.251] - relayed: [n=2] TRUE, FALSE
[17:43:48.251] - queued futures: [n=2] TRUE, FALSE
[17:43:48.251] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:48.251]  length: 1 (resolved future 1)
[17:43:48.252] Future #2
[17:43:48.252] result() for MulticoreFuture ...
[17:43:48.253] result() for MulticoreFuture ...
[17:43:48.253] result() for MulticoreFuture ... done
[17:43:48.253] result() for MulticoreFuture ... done
[17:43:48.253] result() for MulticoreFuture ...
[17:43:48.253] result() for MulticoreFuture ... done
[17:43:48.253] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:48.253] - nx: 2
[17:43:48.254] - relay: TRUE
[17:43:48.254] - stdout: TRUE
[17:43:48.254] - signal: TRUE
[17:43:48.254] - resignal: FALSE
[17:43:48.254] - force: TRUE
[17:43:48.254] - relayed: [n=2] TRUE, FALSE
[17:43:48.254] - queued futures: [n=2] TRUE, FALSE
[17:43:48.254]  - until=2
[17:43:48.255]  - relaying element #2
[17:43:48.255] result() for MulticoreFuture ...
[17:43:48.255] result() for MulticoreFuture ... done
[17:43:48.255] result() for MulticoreFuture ...
[17:43:48.255] result() for MulticoreFuture ... done
[17:43:48.255] result() for MulticoreFuture ...
[17:43:48.255] result() for MulticoreFuture ... done
[17:43:48.255] result() for MulticoreFuture ...
[17:43:48.256] result() for MulticoreFuture ... done
[17:43:48.256] - relayed: [n=2] TRUE, TRUE
[17:43:48.256] - queued futures: [n=2] TRUE, TRUE
[17:43:48.256] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:48.256]  length: 0 (resolved future 2)
[17:43:48.256] Relaying remaining futures
[17:43:48.256] signalConditionsASAP(NULL, pos=0) ...
[17:43:48.256] - nx: 2
[17:43:48.256] - relay: TRUE
[17:43:48.257] - stdout: TRUE
[17:43:48.257] - signal: TRUE
[17:43:48.257] - resignal: FALSE
[17:43:48.257] - force: TRUE
[17:43:48.257] - relayed: [n=2] TRUE, TRUE
[17:43:48.257] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:48.257] - relayed: [n=2] TRUE, TRUE
[17:43:48.257] - queued futures: [n=2] TRUE, TRUE
[17:43:48.257] signalConditionsASAP(NULL, pos=0) ... done
[17:43:48.258] resolve() on list ... DONE
[17:43:48.258] result() for MulticoreFuture ...
[17:43:48.258] result() for MulticoreFuture ... done
[17:43:48.258] result() for MulticoreFuture ...
[17:43:48.258] result() for MulticoreFuture ... done
[17:43:48.258] result() for MulticoreFuture ...
[17:43:48.258] result() for MulticoreFuture ... done
[17:43:48.258] result() for MulticoreFuture ...
[17:43:48.258] result() for MulticoreFuture ... done
[17:43:48.259]  - Number of value chunks collected: 2
[17:43:48.259] Resolving 2 futures (chunks) ... DONE
[17:43:48.259] Reducing values from 2 chunks ...
[17:43:48.259]  - Number of values collected after concatenation: 2
[17:43:48.259]  - Number of values expected: 2
[17:43:48.259] Reducing values from 2 chunks ... DONE
[17:43:48.259] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[17:43:48.260] getGlobalsAndPackagesXApply() ...
[17:43:48.260]  - future.globals: TRUE
[17:43:48.260] getGlobalsAndPackages() ...
[17:43:48.260] Searching for globals...
[17:43:48.262] - globals found: [1] ‘FUN’
[17:43:48.262] Searching for globals ... DONE
[17:43:48.262] Resolving globals: FALSE
[17:43:48.262] The total size of the 1 globals is 848 bytes (848 bytes)
[17:43:48.263] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:43:48.263] - globals: [1] ‘FUN’
[17:43:48.263] 
[17:43:48.263] getGlobalsAndPackages() ... DONE
[17:43:48.263]  - globals found/used: [n=1] ‘FUN’
[17:43:48.263]  - needed namespaces: [n=0] 
[17:43:48.263] Finding globals ... DONE
[17:43:48.264]  - use_args: TRUE
[17:43:48.264]  - Getting '...' globals ...
[17:43:48.264] resolve() on list ...
[17:43:48.264]  recursive: 0
[17:43:48.264]  length: 1
[17:43:48.265]  elements: ‘...’
[17:43:48.265]  length: 0 (resolved future 1)
[17:43:48.265] resolve() on list ... DONE
[17:43:48.265]    - '...' content: [n=0] 
[17:43:48.265] List of 1
[17:43:48.265]  $ ...: list()
[17:43:48.265]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.265]  - attr(*, "where")=List of 1
[17:43:48.265]   ..$ ...:<environment: 0x55dfd4e13970> 
[17:43:48.265]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.265]  - attr(*, "resolved")= logi TRUE
[17:43:48.265]  - attr(*, "total_size")= num NA
[17:43:48.271]  - Getting '...' globals ... DONE
[17:43:48.272] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:48.272] List of 2
[17:43:48.272]  $ ...future.FUN:function (x)  
[17:43:48.272]  $ ...          : list()
[17:43:48.272]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.272]  - attr(*, "where")=List of 2
[17:43:48.272]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:48.272]   ..$ ...          :<environment: 0x55dfd4e13970> 
[17:43:48.272]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.272]  - attr(*, "resolved")= logi FALSE
[17:43:48.272]  - attr(*, "total_size")= num 848
[17:43:48.275] Packages to be attached in all futures: [n=0] 
[17:43:48.275] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.279] future_lapply() ...
[17:43:48.283] Number of chunks: 2
[17:43:48.283] getGlobalsAndPackagesXApply() ...
[17:43:48.283]  - future.globals: <name-value list> with names ‘list()’
[17:43:48.283]  - use_args: TRUE
[17:43:48.284] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:48.284] List of 2
[17:43:48.284]  $ ...          : list()
[17:43:48.284]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.284]  $ ...future.FUN:function (x)  
[17:43:48.284]  - attr(*, "where")=List of 2
[17:43:48.284]   ..$ ...          :<environment: 0x55dfd4e13970> 
[17:43:48.284]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:48.284]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.284]  - attr(*, "resolved")= logi FALSE
[17:43:48.284]  - attr(*, "total_size")= num NA
[17:43:48.287] Packages to be attached in all futures: [n=0] 
[17:43:48.287] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.288] Number of futures (= number of chunks): 2
[17:43:48.288] Launching 2 futures (chunks) ...
[17:43:48.288] Chunk #1 of 2 ...
[17:43:48.288]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.288]  - seeds: <none>
[17:43:48.288]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.288] getGlobalsAndPackages() ...
[17:43:48.288] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.289] Resolving globals: FALSE
[17:43:48.289] Tweak future expression to call with '...' arguments ...
[17:43:48.289] {
[17:43:48.289]     do.call(function(...) {
[17:43:48.289]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.289]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.289]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.289]             on.exit(options(oopts), add = TRUE)
[17:43:48.289]         }
[17:43:48.289]         {
[17:43:48.289]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.289]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.289]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.289]             })
[17:43:48.289]         }
[17:43:48.289]     }, args = future.call.arguments)
[17:43:48.289] }
[17:43:48.289] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.289] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.290] 
[17:43:48.290] getGlobalsAndPackages() ... DONE
[17:43:48.290] run() for ‘Future’ ...
[17:43:48.290] - state: ‘created’
[17:43:48.290] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.294] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.294] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.295]   - Field: ‘label’
[17:43:48.295]   - Field: ‘local’
[17:43:48.295]   - Field: ‘owner’
[17:43:48.295]   - Field: ‘envir’
[17:43:48.295]   - Field: ‘workers’
[17:43:48.295]   - Field: ‘packages’
[17:43:48.295]   - Field: ‘gc’
[17:43:48.295]   - Field: ‘job’
[17:43:48.296]   - Field: ‘conditions’
[17:43:48.296]   - Field: ‘expr’
[17:43:48.296]   - Field: ‘uuid’
[17:43:48.296]   - Field: ‘seed’
[17:43:48.296]   - Field: ‘version’
[17:43:48.296]   - Field: ‘result’
[17:43:48.296]   - Field: ‘asynchronous’
[17:43:48.296]   - Field: ‘calls’
[17:43:48.296]   - Field: ‘globals’
[17:43:48.297]   - Field: ‘stdout’
[17:43:48.297]   - Field: ‘earlySignal’
[17:43:48.297]   - Field: ‘lazy’
[17:43:48.297]   - Field: ‘state’
[17:43:48.297] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.297] - Launch lazy future ...
[17:43:48.297] Packages needed by the future expression (n = 0): <none>
[17:43:48.298] Packages needed by future strategies (n = 0): <none>
[17:43:48.298] {
[17:43:48.298]     {
[17:43:48.298]         {
[17:43:48.298]             ...future.startTime <- base::Sys.time()
[17:43:48.298]             {
[17:43:48.298]                 {
[17:43:48.298]                   {
[17:43:48.298]                     {
[17:43:48.298]                       base::local({
[17:43:48.298]                         has_future <- base::requireNamespace("future", 
[17:43:48.298]                           quietly = TRUE)
[17:43:48.298]                         if (has_future) {
[17:43:48.298]                           ns <- base::getNamespace("future")
[17:43:48.298]                           version <- ns[[".package"]][["version"]]
[17:43:48.298]                           if (is.null(version)) 
[17:43:48.298]                             version <- utils::packageVersion("future")
[17:43:48.298]                         }
[17:43:48.298]                         else {
[17:43:48.298]                           version <- NULL
[17:43:48.298]                         }
[17:43:48.298]                         if (!has_future || version < "1.8.0") {
[17:43:48.298]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.298]                             "", base::R.version$version.string), 
[17:43:48.298]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.298]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.298]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.298]                               "release", "version")], collapse = " "), 
[17:43:48.298]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.298]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.298]                             info)
[17:43:48.298]                           info <- base::paste(info, collapse = "; ")
[17:43:48.298]                           if (!has_future) {
[17:43:48.298]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.298]                               info)
[17:43:48.298]                           }
[17:43:48.298]                           else {
[17:43:48.298]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.298]                               info, version)
[17:43:48.298]                           }
[17:43:48.298]                           base::stop(msg)
[17:43:48.298]                         }
[17:43:48.298]                       })
[17:43:48.298]                     }
[17:43:48.298]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.298]                     base::options(mc.cores = 1L)
[17:43:48.298]                   }
[17:43:48.298]                   ...future.strategy.old <- future::plan("list")
[17:43:48.298]                   options(future.plan = NULL)
[17:43:48.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.298]                 }
[17:43:48.298]                 ...future.workdir <- getwd()
[17:43:48.298]             }
[17:43:48.298]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.298]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.298]         }
[17:43:48.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.298]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.298]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.298]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.298]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.298]             base::names(...future.oldOptions))
[17:43:48.298]     }
[17:43:48.298]     if (FALSE) {
[17:43:48.298]     }
[17:43:48.298]     else {
[17:43:48.298]         if (TRUE) {
[17:43:48.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.298]                 open = "w")
[17:43:48.298]         }
[17:43:48.298]         else {
[17:43:48.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.298]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.298]         }
[17:43:48.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.298]             base::sink(type = "output", split = FALSE)
[17:43:48.298]             base::close(...future.stdout)
[17:43:48.298]         }, add = TRUE)
[17:43:48.298]     }
[17:43:48.298]     ...future.frame <- base::sys.nframe()
[17:43:48.298]     ...future.conditions <- base::list()
[17:43:48.298]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.298]     if (FALSE) {
[17:43:48.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.298]     }
[17:43:48.298]     ...future.result <- base::tryCatch({
[17:43:48.298]         base::withCallingHandlers({
[17:43:48.298]             ...future.value <- base::withVisible(base::local({
[17:43:48.298]                 withCallingHandlers({
[17:43:48.298]                   {
[17:43:48.298]                     do.call(function(...) {
[17:43:48.298]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.298]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.298]                         ...future.globals.maxSize)) {
[17:43:48.298]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.298]                         on.exit(options(oopts), add = TRUE)
[17:43:48.298]                       }
[17:43:48.298]                       {
[17:43:48.298]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.298]                           FUN = function(jj) {
[17:43:48.298]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.298]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.298]                           })
[17:43:48.298]                       }
[17:43:48.298]                     }, args = future.call.arguments)
[17:43:48.298]                   }
[17:43:48.298]                 }, immediateCondition = function(cond) {
[17:43:48.298]                   save_rds <- function (object, pathname, ...) 
[17:43:48.298]                   {
[17:43:48.298]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.298]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.298]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.298]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.298]                         fi_tmp[["mtime"]])
[17:43:48.298]                     }
[17:43:48.298]                     tryCatch({
[17:43:48.298]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.298]                     }, error = function(ex) {
[17:43:48.298]                       msg <- conditionMessage(ex)
[17:43:48.298]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.298]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.298]                         fi_tmp[["mtime"]], msg)
[17:43:48.298]                       ex$message <- msg
[17:43:48.298]                       stop(ex)
[17:43:48.298]                     })
[17:43:48.298]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.298]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.298]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.298]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.298]                       fi <- file.info(pathname)
[17:43:48.298]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.298]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.298]                         fi[["size"]], fi[["mtime"]])
[17:43:48.298]                       stop(msg)
[17:43:48.298]                     }
[17:43:48.298]                     invisible(pathname)
[17:43:48.298]                   }
[17:43:48.298]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.298]                     rootPath = tempdir()) 
[17:43:48.298]                   {
[17:43:48.298]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.298]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.298]                       tmpdir = path, fileext = ".rds")
[17:43:48.298]                     save_rds(obj, file)
[17:43:48.298]                   }
[17:43:48.298]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.298]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.298]                   {
[17:43:48.298]                     inherits <- base::inherits
[17:43:48.298]                     invokeRestart <- base::invokeRestart
[17:43:48.298]                     is.null <- base::is.null
[17:43:48.298]                     muffled <- FALSE
[17:43:48.298]                     if (inherits(cond, "message")) {
[17:43:48.298]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.298]                       if (muffled) 
[17:43:48.298]                         invokeRestart("muffleMessage")
[17:43:48.298]                     }
[17:43:48.298]                     else if (inherits(cond, "warning")) {
[17:43:48.298]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.298]                       if (muffled) 
[17:43:48.298]                         invokeRestart("muffleWarning")
[17:43:48.298]                     }
[17:43:48.298]                     else if (inherits(cond, "condition")) {
[17:43:48.298]                       if (!is.null(pattern)) {
[17:43:48.298]                         computeRestarts <- base::computeRestarts
[17:43:48.298]                         grepl <- base::grepl
[17:43:48.298]                         restarts <- computeRestarts(cond)
[17:43:48.298]                         for (restart in restarts) {
[17:43:48.298]                           name <- restart$name
[17:43:48.298]                           if (is.null(name)) 
[17:43:48.298]                             next
[17:43:48.298]                           if (!grepl(pattern, name)) 
[17:43:48.298]                             next
[17:43:48.298]                           invokeRestart(restart)
[17:43:48.298]                           muffled <- TRUE
[17:43:48.298]                           break
[17:43:48.298]                         }
[17:43:48.298]                       }
[17:43:48.298]                     }
[17:43:48.298]                     invisible(muffled)
[17:43:48.298]                   }
[17:43:48.298]                   muffleCondition(cond)
[17:43:48.298]                 })
[17:43:48.298]             }))
[17:43:48.298]             future::FutureResult(value = ...future.value$value, 
[17:43:48.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.298]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.298]                     ...future.globalenv.names))
[17:43:48.298]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.298]         }, condition = base::local({
[17:43:48.298]             c <- base::c
[17:43:48.298]             inherits <- base::inherits
[17:43:48.298]             invokeRestart <- base::invokeRestart
[17:43:48.298]             length <- base::length
[17:43:48.298]             list <- base::list
[17:43:48.298]             seq.int <- base::seq.int
[17:43:48.298]             signalCondition <- base::signalCondition
[17:43:48.298]             sys.calls <- base::sys.calls
[17:43:48.298]             `[[` <- base::`[[`
[17:43:48.298]             `+` <- base::`+`
[17:43:48.298]             `<<-` <- base::`<<-`
[17:43:48.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.298]                   3L)]
[17:43:48.298]             }
[17:43:48.298]             function(cond) {
[17:43:48.298]                 is_error <- inherits(cond, "error")
[17:43:48.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.298]                   NULL)
[17:43:48.298]                 if (is_error) {
[17:43:48.298]                   sessionInformation <- function() {
[17:43:48.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.298]                       search = base::search(), system = base::Sys.info())
[17:43:48.298]                   }
[17:43:48.298]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.298]                     cond$call), session = sessionInformation(), 
[17:43:48.298]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.298]                   signalCondition(cond)
[17:43:48.298]                 }
[17:43:48.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.298]                 "immediateCondition"))) {
[17:43:48.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.298]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.298]                   if (TRUE && !signal) {
[17:43:48.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.298]                     {
[17:43:48.298]                       inherits <- base::inherits
[17:43:48.298]                       invokeRestart <- base::invokeRestart
[17:43:48.298]                       is.null <- base::is.null
[17:43:48.298]                       muffled <- FALSE
[17:43:48.298]                       if (inherits(cond, "message")) {
[17:43:48.298]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.298]                         if (muffled) 
[17:43:48.298]                           invokeRestart("muffleMessage")
[17:43:48.298]                       }
[17:43:48.298]                       else if (inherits(cond, "warning")) {
[17:43:48.298]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.298]                         if (muffled) 
[17:43:48.298]                           invokeRestart("muffleWarning")
[17:43:48.298]                       }
[17:43:48.298]                       else if (inherits(cond, "condition")) {
[17:43:48.298]                         if (!is.null(pattern)) {
[17:43:48.298]                           computeRestarts <- base::computeRestarts
[17:43:48.298]                           grepl <- base::grepl
[17:43:48.298]                           restarts <- computeRestarts(cond)
[17:43:48.298]                           for (restart in restarts) {
[17:43:48.298]                             name <- restart$name
[17:43:48.298]                             if (is.null(name)) 
[17:43:48.298]                               next
[17:43:48.298]                             if (!grepl(pattern, name)) 
[17:43:48.298]                               next
[17:43:48.298]                             invokeRestart(restart)
[17:43:48.298]                             muffled <- TRUE
[17:43:48.298]                             break
[17:43:48.298]                           }
[17:43:48.298]                         }
[17:43:48.298]                       }
[17:43:48.298]                       invisible(muffled)
[17:43:48.298]                     }
[17:43:48.298]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.298]                   }
[17:43:48.298]                 }
[17:43:48.298]                 else {
[17:43:48.298]                   if (TRUE) {
[17:43:48.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.298]                     {
[17:43:48.298]                       inherits <- base::inherits
[17:43:48.298]                       invokeRestart <- base::invokeRestart
[17:43:48.298]                       is.null <- base::is.null
[17:43:48.298]                       muffled <- FALSE
[17:43:48.298]                       if (inherits(cond, "message")) {
[17:43:48.298]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.298]                         if (muffled) 
[17:43:48.298]                           invokeRestart("muffleMessage")
[17:43:48.298]                       }
[17:43:48.298]                       else if (inherits(cond, "warning")) {
[17:43:48.298]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.298]                         if (muffled) 
[17:43:48.298]                           invokeRestart("muffleWarning")
[17:43:48.298]                       }
[17:43:48.298]                       else if (inherits(cond, "condition")) {
[17:43:48.298]                         if (!is.null(pattern)) {
[17:43:48.298]                           computeRestarts <- base::computeRestarts
[17:43:48.298]                           grepl <- base::grepl
[17:43:48.298]                           restarts <- computeRestarts(cond)
[17:43:48.298]                           for (restart in restarts) {
[17:43:48.298]                             name <- restart$name
[17:43:48.298]                             if (is.null(name)) 
[17:43:48.298]                               next
[17:43:48.298]                             if (!grepl(pattern, name)) 
[17:43:48.298]                               next
[17:43:48.298]                             invokeRestart(restart)
[17:43:48.298]                             muffled <- TRUE
[17:43:48.298]                             break
[17:43:48.298]                           }
[17:43:48.298]                         }
[17:43:48.298]                       }
[17:43:48.298]                       invisible(muffled)
[17:43:48.298]                     }
[17:43:48.298]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.298]                   }
[17:43:48.298]                 }
[17:43:48.298]             }
[17:43:48.298]         }))
[17:43:48.298]     }, error = function(ex) {
[17:43:48.298]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.298]                 ...future.rng), started = ...future.startTime, 
[17:43:48.298]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.298]             version = "1.8"), class = "FutureResult")
[17:43:48.298]     }, finally = {
[17:43:48.298]         if (!identical(...future.workdir, getwd())) 
[17:43:48.298]             setwd(...future.workdir)
[17:43:48.298]         {
[17:43:48.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.298]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.298]             }
[17:43:48.298]             base::options(...future.oldOptions)
[17:43:48.298]             if (.Platform$OS.type == "windows") {
[17:43:48.298]                 old_names <- names(...future.oldEnvVars)
[17:43:48.298]                 envs <- base::Sys.getenv()
[17:43:48.298]                 names <- names(envs)
[17:43:48.298]                 common <- intersect(names, old_names)
[17:43:48.298]                 added <- setdiff(names, old_names)
[17:43:48.298]                 removed <- setdiff(old_names, names)
[17:43:48.298]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.298]                   envs[common]]
[17:43:48.298]                 NAMES <- toupper(changed)
[17:43:48.298]                 args <- list()
[17:43:48.298]                 for (kk in seq_along(NAMES)) {
[17:43:48.298]                   name <- changed[[kk]]
[17:43:48.298]                   NAME <- NAMES[[kk]]
[17:43:48.298]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.298]                     next
[17:43:48.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.298]                 }
[17:43:48.298]                 NAMES <- toupper(added)
[17:43:48.298]                 for (kk in seq_along(NAMES)) {
[17:43:48.298]                   name <- added[[kk]]
[17:43:48.298]                   NAME <- NAMES[[kk]]
[17:43:48.298]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.298]                     next
[17:43:48.298]                   args[[name]] <- ""
[17:43:48.298]                 }
[17:43:48.298]                 NAMES <- toupper(removed)
[17:43:48.298]                 for (kk in seq_along(NAMES)) {
[17:43:48.298]                   name <- removed[[kk]]
[17:43:48.298]                   NAME <- NAMES[[kk]]
[17:43:48.298]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.298]                     next
[17:43:48.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.298]                 }
[17:43:48.298]                 if (length(args) > 0) 
[17:43:48.298]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.298]             }
[17:43:48.298]             else {
[17:43:48.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.298]             }
[17:43:48.298]             {
[17:43:48.298]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.298]                   0L) {
[17:43:48.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.298]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.298]                   base::options(opts)
[17:43:48.298]                 }
[17:43:48.298]                 {
[17:43:48.298]                   {
[17:43:48.298]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.298]                     NULL
[17:43:48.298]                   }
[17:43:48.298]                   options(future.plan = NULL)
[17:43:48.298]                   if (is.na(NA_character_)) 
[17:43:48.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.298]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.298]                     .init = FALSE)
[17:43:48.298]                 }
[17:43:48.298]             }
[17:43:48.298]         }
[17:43:48.298]     })
[17:43:48.298]     if (TRUE) {
[17:43:48.298]         base::sink(type = "output", split = FALSE)
[17:43:48.298]         if (TRUE) {
[17:43:48.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.298]         }
[17:43:48.298]         else {
[17:43:48.298]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.298]         }
[17:43:48.298]         base::close(...future.stdout)
[17:43:48.298]         ...future.stdout <- NULL
[17:43:48.298]     }
[17:43:48.298]     ...future.result$conditions <- ...future.conditions
[17:43:48.298]     ...future.result$finished <- base::Sys.time()
[17:43:48.298]     ...future.result
[17:43:48.298] }
[17:43:48.301] assign_globals() ...
[17:43:48.301] List of 5
[17:43:48.301]  $ future.call.arguments    : list()
[17:43:48.301]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.301]  $ ...future.FUN            :function (x)  
[17:43:48.301]  $ ...future.elements_ii    :List of 3
[17:43:48.301]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:43:48.301]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:43:48.301]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:43:48.301]  $ ...future.seeds_ii       : NULL
[17:43:48.301]  $ ...future.globals.maxSize: num Inf
[17:43:48.301]  - attr(*, "resolved")= logi FALSE
[17:43:48.301]  - attr(*, "total_size")= num NA
[17:43:48.301]  - attr(*, "where")=List of 5
[17:43:48.301]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.301]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.301]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.301]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.301]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.301]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.301]  - attr(*, "already-done")= logi TRUE
[17:43:48.309] - copied ‘future.call.arguments’ to environment
[17:43:48.309] - copied ‘...future.FUN’ to environment
[17:43:48.309] - copied ‘...future.elements_ii’ to environment
[17:43:48.309] - copied ‘...future.seeds_ii’ to environment
[17:43:48.309] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.309] assign_globals() ... done
[17:43:48.309] requestCore(): workers = 2
[17:43:48.312] MulticoreFuture started
[17:43:48.312] - Launch lazy future ... done
[17:43:48.312] run() for ‘MulticoreFuture’ ... done
[17:43:48.313] Created future:
[17:43:48.313] plan(): Setting new future strategy stack:
[17:43:48.313] List of future strategies:
[17:43:48.313] 1. sequential:
[17:43:48.313]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.313]    - tweaked: FALSE
[17:43:48.313]    - call: NULL
[17:43:48.314] plan(): nbrOfWorkers() = 1
[17:43:48.317] plan(): Setting new future strategy stack:
[17:43:48.317] List of future strategies:
[17:43:48.317] 1. multicore:
[17:43:48.317]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.317]    - tweaked: FALSE
[17:43:48.317]    - call: plan(strategy)
[17:43:48.322] plan(): nbrOfWorkers() = 2
[17:43:48.313] MulticoreFuture:
[17:43:48.313] Label: ‘future_apply-1’
[17:43:48.313] Expression:
[17:43:48.313] {
[17:43:48.313]     do.call(function(...) {
[17:43:48.313]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.313]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.313]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.313]             on.exit(options(oopts), add = TRUE)
[17:43:48.313]         }
[17:43:48.313]         {
[17:43:48.313]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.313]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.313]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.313]             })
[17:43:48.313]         }
[17:43:48.313]     }, args = future.call.arguments)
[17:43:48.313] }
[17:43:48.313] Lazy evaluation: FALSE
[17:43:48.313] Asynchronous evaluation: TRUE
[17:43:48.313] Local evaluation: TRUE
[17:43:48.313] Environment: R_GlobalEnv
[17:43:48.313] Capture standard output: TRUE
[17:43:48.313] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:48.313] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.313] Packages: <none>
[17:43:48.313] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:48.313] Resolved: TRUE
[17:43:48.313] Value: <not collected>
[17:43:48.313] Conditions captured: <none>
[17:43:48.313] Early signaling: FALSE
[17:43:48.313] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.313] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.323] Chunk #1 of 2 ... DONE
[17:43:48.323] Chunk #2 of 2 ...
[17:43:48.324]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.324]  - seeds: <none>
[17:43:48.324]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.324] getGlobalsAndPackages() ...
[17:43:48.324] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.325] Resolving globals: FALSE
[17:43:48.325] Tweak future expression to call with '...' arguments ...
[17:43:48.325] {
[17:43:48.325]     do.call(function(...) {
[17:43:48.325]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.325]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.325]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.325]             on.exit(options(oopts), add = TRUE)
[17:43:48.325]         }
[17:43:48.325]         {
[17:43:48.325]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.325]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.325]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.325]             })
[17:43:48.325]         }
[17:43:48.325]     }, args = future.call.arguments)
[17:43:48.325] }
[17:43:48.325] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.326] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.326] 
[17:43:48.326] getGlobalsAndPackages() ... DONE
[17:43:48.327] run() for ‘Future’ ...
[17:43:48.327] - state: ‘created’
[17:43:48.327] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.332] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.332] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.333]   - Field: ‘label’
[17:43:48.333]   - Field: ‘local’
[17:43:48.333]   - Field: ‘owner’
[17:43:48.333]   - Field: ‘envir’
[17:43:48.333]   - Field: ‘workers’
[17:43:48.333]   - Field: ‘packages’
[17:43:48.334]   - Field: ‘gc’
[17:43:48.334]   - Field: ‘job’
[17:43:48.334]   - Field: ‘conditions’
[17:43:48.334]   - Field: ‘expr’
[17:43:48.334]   - Field: ‘uuid’
[17:43:48.334]   - Field: ‘seed’
[17:43:48.334]   - Field: ‘version’
[17:43:48.335]   - Field: ‘result’
[17:43:48.335]   - Field: ‘asynchronous’
[17:43:48.335]   - Field: ‘calls’
[17:43:48.335]   - Field: ‘globals’
[17:43:48.335]   - Field: ‘stdout’
[17:43:48.335]   - Field: ‘earlySignal’
[17:43:48.335]   - Field: ‘lazy’
[17:43:48.336]   - Field: ‘state’
[17:43:48.336] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.336] - Launch lazy future ...
[17:43:48.336] Packages needed by the future expression (n = 0): <none>
[17:43:48.337] Packages needed by future strategies (n = 0): <none>
[17:43:48.337] {
[17:43:48.337]     {
[17:43:48.337]         {
[17:43:48.337]             ...future.startTime <- base::Sys.time()
[17:43:48.337]             {
[17:43:48.337]                 {
[17:43:48.337]                   {
[17:43:48.337]                     {
[17:43:48.337]                       base::local({
[17:43:48.337]                         has_future <- base::requireNamespace("future", 
[17:43:48.337]                           quietly = TRUE)
[17:43:48.337]                         if (has_future) {
[17:43:48.337]                           ns <- base::getNamespace("future")
[17:43:48.337]                           version <- ns[[".package"]][["version"]]
[17:43:48.337]                           if (is.null(version)) 
[17:43:48.337]                             version <- utils::packageVersion("future")
[17:43:48.337]                         }
[17:43:48.337]                         else {
[17:43:48.337]                           version <- NULL
[17:43:48.337]                         }
[17:43:48.337]                         if (!has_future || version < "1.8.0") {
[17:43:48.337]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.337]                             "", base::R.version$version.string), 
[17:43:48.337]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.337]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.337]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.337]                               "release", "version")], collapse = " "), 
[17:43:48.337]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.337]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.337]                             info)
[17:43:48.337]                           info <- base::paste(info, collapse = "; ")
[17:43:48.337]                           if (!has_future) {
[17:43:48.337]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.337]                               info)
[17:43:48.337]                           }
[17:43:48.337]                           else {
[17:43:48.337]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.337]                               info, version)
[17:43:48.337]                           }
[17:43:48.337]                           base::stop(msg)
[17:43:48.337]                         }
[17:43:48.337]                       })
[17:43:48.337]                     }
[17:43:48.337]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.337]                     base::options(mc.cores = 1L)
[17:43:48.337]                   }
[17:43:48.337]                   ...future.strategy.old <- future::plan("list")
[17:43:48.337]                   options(future.plan = NULL)
[17:43:48.337]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.337]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.337]                 }
[17:43:48.337]                 ...future.workdir <- getwd()
[17:43:48.337]             }
[17:43:48.337]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.337]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.337]         }
[17:43:48.337]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.337]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.337]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.337]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.337]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.337]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.337]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.337]             base::names(...future.oldOptions))
[17:43:48.337]     }
[17:43:48.337]     if (FALSE) {
[17:43:48.337]     }
[17:43:48.337]     else {
[17:43:48.337]         if (TRUE) {
[17:43:48.337]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.337]                 open = "w")
[17:43:48.337]         }
[17:43:48.337]         else {
[17:43:48.337]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.337]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.337]         }
[17:43:48.337]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.337]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.337]             base::sink(type = "output", split = FALSE)
[17:43:48.337]             base::close(...future.stdout)
[17:43:48.337]         }, add = TRUE)
[17:43:48.337]     }
[17:43:48.337]     ...future.frame <- base::sys.nframe()
[17:43:48.337]     ...future.conditions <- base::list()
[17:43:48.337]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.337]     if (FALSE) {
[17:43:48.337]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.337]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.337]     }
[17:43:48.337]     ...future.result <- base::tryCatch({
[17:43:48.337]         base::withCallingHandlers({
[17:43:48.337]             ...future.value <- base::withVisible(base::local({
[17:43:48.337]                 withCallingHandlers({
[17:43:48.337]                   {
[17:43:48.337]                     do.call(function(...) {
[17:43:48.337]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.337]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.337]                         ...future.globals.maxSize)) {
[17:43:48.337]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.337]                         on.exit(options(oopts), add = TRUE)
[17:43:48.337]                       }
[17:43:48.337]                       {
[17:43:48.337]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.337]                           FUN = function(jj) {
[17:43:48.337]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.337]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.337]                           })
[17:43:48.337]                       }
[17:43:48.337]                     }, args = future.call.arguments)
[17:43:48.337]                   }
[17:43:48.337]                 }, immediateCondition = function(cond) {
[17:43:48.337]                   save_rds <- function (object, pathname, ...) 
[17:43:48.337]                   {
[17:43:48.337]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.337]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.337]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.337]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.337]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.337]                         fi_tmp[["mtime"]])
[17:43:48.337]                     }
[17:43:48.337]                     tryCatch({
[17:43:48.337]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.337]                     }, error = function(ex) {
[17:43:48.337]                       msg <- conditionMessage(ex)
[17:43:48.337]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.337]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.337]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.337]                         fi_tmp[["mtime"]], msg)
[17:43:48.337]                       ex$message <- msg
[17:43:48.337]                       stop(ex)
[17:43:48.337]                     })
[17:43:48.337]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.337]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.337]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.337]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.337]                       fi <- file.info(pathname)
[17:43:48.337]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.337]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.337]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.337]                         fi[["size"]], fi[["mtime"]])
[17:43:48.337]                       stop(msg)
[17:43:48.337]                     }
[17:43:48.337]                     invisible(pathname)
[17:43:48.337]                   }
[17:43:48.337]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.337]                     rootPath = tempdir()) 
[17:43:48.337]                   {
[17:43:48.337]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.337]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.337]                       tmpdir = path, fileext = ".rds")
[17:43:48.337]                     save_rds(obj, file)
[17:43:48.337]                   }
[17:43:48.337]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.337]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.337]                   {
[17:43:48.337]                     inherits <- base::inherits
[17:43:48.337]                     invokeRestart <- base::invokeRestart
[17:43:48.337]                     is.null <- base::is.null
[17:43:48.337]                     muffled <- FALSE
[17:43:48.337]                     if (inherits(cond, "message")) {
[17:43:48.337]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.337]                       if (muffled) 
[17:43:48.337]                         invokeRestart("muffleMessage")
[17:43:48.337]                     }
[17:43:48.337]                     else if (inherits(cond, "warning")) {
[17:43:48.337]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.337]                       if (muffled) 
[17:43:48.337]                         invokeRestart("muffleWarning")
[17:43:48.337]                     }
[17:43:48.337]                     else if (inherits(cond, "condition")) {
[17:43:48.337]                       if (!is.null(pattern)) {
[17:43:48.337]                         computeRestarts <- base::computeRestarts
[17:43:48.337]                         grepl <- base::grepl
[17:43:48.337]                         restarts <- computeRestarts(cond)
[17:43:48.337]                         for (restart in restarts) {
[17:43:48.337]                           name <- restart$name
[17:43:48.337]                           if (is.null(name)) 
[17:43:48.337]                             next
[17:43:48.337]                           if (!grepl(pattern, name)) 
[17:43:48.337]                             next
[17:43:48.337]                           invokeRestart(restart)
[17:43:48.337]                           muffled <- TRUE
[17:43:48.337]                           break
[17:43:48.337]                         }
[17:43:48.337]                       }
[17:43:48.337]                     }
[17:43:48.337]                     invisible(muffled)
[17:43:48.337]                   }
[17:43:48.337]                   muffleCondition(cond)
[17:43:48.337]                 })
[17:43:48.337]             }))
[17:43:48.337]             future::FutureResult(value = ...future.value$value, 
[17:43:48.337]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.337]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.337]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.337]                     ...future.globalenv.names))
[17:43:48.337]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.337]         }, condition = base::local({
[17:43:48.337]             c <- base::c
[17:43:48.337]             inherits <- base::inherits
[17:43:48.337]             invokeRestart <- base::invokeRestart
[17:43:48.337]             length <- base::length
[17:43:48.337]             list <- base::list
[17:43:48.337]             seq.int <- base::seq.int
[17:43:48.337]             signalCondition <- base::signalCondition
[17:43:48.337]             sys.calls <- base::sys.calls
[17:43:48.337]             `[[` <- base::`[[`
[17:43:48.337]             `+` <- base::`+`
[17:43:48.337]             `<<-` <- base::`<<-`
[17:43:48.337]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.337]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.337]                   3L)]
[17:43:48.337]             }
[17:43:48.337]             function(cond) {
[17:43:48.337]                 is_error <- inherits(cond, "error")
[17:43:48.337]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.337]                   NULL)
[17:43:48.337]                 if (is_error) {
[17:43:48.337]                   sessionInformation <- function() {
[17:43:48.337]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.337]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.337]                       search = base::search(), system = base::Sys.info())
[17:43:48.337]                   }
[17:43:48.337]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.337]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.337]                     cond$call), session = sessionInformation(), 
[17:43:48.337]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.337]                   signalCondition(cond)
[17:43:48.337]                 }
[17:43:48.337]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.337]                 "immediateCondition"))) {
[17:43:48.337]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.337]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.337]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.337]                   if (TRUE && !signal) {
[17:43:48.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.337]                     {
[17:43:48.337]                       inherits <- base::inherits
[17:43:48.337]                       invokeRestart <- base::invokeRestart
[17:43:48.337]                       is.null <- base::is.null
[17:43:48.337]                       muffled <- FALSE
[17:43:48.337]                       if (inherits(cond, "message")) {
[17:43:48.337]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.337]                         if (muffled) 
[17:43:48.337]                           invokeRestart("muffleMessage")
[17:43:48.337]                       }
[17:43:48.337]                       else if (inherits(cond, "warning")) {
[17:43:48.337]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.337]                         if (muffled) 
[17:43:48.337]                           invokeRestart("muffleWarning")
[17:43:48.337]                       }
[17:43:48.337]                       else if (inherits(cond, "condition")) {
[17:43:48.337]                         if (!is.null(pattern)) {
[17:43:48.337]                           computeRestarts <- base::computeRestarts
[17:43:48.337]                           grepl <- base::grepl
[17:43:48.337]                           restarts <- computeRestarts(cond)
[17:43:48.337]                           for (restart in restarts) {
[17:43:48.337]                             name <- restart$name
[17:43:48.337]                             if (is.null(name)) 
[17:43:48.337]                               next
[17:43:48.337]                             if (!grepl(pattern, name)) 
[17:43:48.337]                               next
[17:43:48.337]                             invokeRestart(restart)
[17:43:48.337]                             muffled <- TRUE
[17:43:48.337]                             break
[17:43:48.337]                           }
[17:43:48.337]                         }
[17:43:48.337]                       }
[17:43:48.337]                       invisible(muffled)
[17:43:48.337]                     }
[17:43:48.337]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.337]                   }
[17:43:48.337]                 }
[17:43:48.337]                 else {
[17:43:48.337]                   if (TRUE) {
[17:43:48.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.337]                     {
[17:43:48.337]                       inherits <- base::inherits
[17:43:48.337]                       invokeRestart <- base::invokeRestart
[17:43:48.337]                       is.null <- base::is.null
[17:43:48.337]                       muffled <- FALSE
[17:43:48.337]                       if (inherits(cond, "message")) {
[17:43:48.337]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.337]                         if (muffled) 
[17:43:48.337]                           invokeRestart("muffleMessage")
[17:43:48.337]                       }
[17:43:48.337]                       else if (inherits(cond, "warning")) {
[17:43:48.337]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.337]                         if (muffled) 
[17:43:48.337]                           invokeRestart("muffleWarning")
[17:43:48.337]                       }
[17:43:48.337]                       else if (inherits(cond, "condition")) {
[17:43:48.337]                         if (!is.null(pattern)) {
[17:43:48.337]                           computeRestarts <- base::computeRestarts
[17:43:48.337]                           grepl <- base::grepl
[17:43:48.337]                           restarts <- computeRestarts(cond)
[17:43:48.337]                           for (restart in restarts) {
[17:43:48.337]                             name <- restart$name
[17:43:48.337]                             if (is.null(name)) 
[17:43:48.337]                               next
[17:43:48.337]                             if (!grepl(pattern, name)) 
[17:43:48.337]                               next
[17:43:48.337]                             invokeRestart(restart)
[17:43:48.337]                             muffled <- TRUE
[17:43:48.337]                             break
[17:43:48.337]                           }
[17:43:48.337]                         }
[17:43:48.337]                       }
[17:43:48.337]                       invisible(muffled)
[17:43:48.337]                     }
[17:43:48.337]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.337]                   }
[17:43:48.337]                 }
[17:43:48.337]             }
[17:43:48.337]         }))
[17:43:48.337]     }, error = function(ex) {
[17:43:48.337]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.337]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.337]                 ...future.rng), started = ...future.startTime, 
[17:43:48.337]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.337]             version = "1.8"), class = "FutureResult")
[17:43:48.337]     }, finally = {
[17:43:48.337]         if (!identical(...future.workdir, getwd())) 
[17:43:48.337]             setwd(...future.workdir)
[17:43:48.337]         {
[17:43:48.337]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.337]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.337]             }
[17:43:48.337]             base::options(...future.oldOptions)
[17:43:48.337]             if (.Platform$OS.type == "windows") {
[17:43:48.337]                 old_names <- names(...future.oldEnvVars)
[17:43:48.337]                 envs <- base::Sys.getenv()
[17:43:48.337]                 names <- names(envs)
[17:43:48.337]                 common <- intersect(names, old_names)
[17:43:48.337]                 added <- setdiff(names, old_names)
[17:43:48.337]                 removed <- setdiff(old_names, names)
[17:43:48.337]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.337]                   envs[common]]
[17:43:48.337]                 NAMES <- toupper(changed)
[17:43:48.337]                 args <- list()
[17:43:48.337]                 for (kk in seq_along(NAMES)) {
[17:43:48.337]                   name <- changed[[kk]]
[17:43:48.337]                   NAME <- NAMES[[kk]]
[17:43:48.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.337]                     next
[17:43:48.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.337]                 }
[17:43:48.337]                 NAMES <- toupper(added)
[17:43:48.337]                 for (kk in seq_along(NAMES)) {
[17:43:48.337]                   name <- added[[kk]]
[17:43:48.337]                   NAME <- NAMES[[kk]]
[17:43:48.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.337]                     next
[17:43:48.337]                   args[[name]] <- ""
[17:43:48.337]                 }
[17:43:48.337]                 NAMES <- toupper(removed)
[17:43:48.337]                 for (kk in seq_along(NAMES)) {
[17:43:48.337]                   name <- removed[[kk]]
[17:43:48.337]                   NAME <- NAMES[[kk]]
[17:43:48.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.337]                     next
[17:43:48.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.337]                 }
[17:43:48.337]                 if (length(args) > 0) 
[17:43:48.337]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.337]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.337]             }
[17:43:48.337]             else {
[17:43:48.337]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.337]             }
[17:43:48.337]             {
[17:43:48.337]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.337]                   0L) {
[17:43:48.337]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.337]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.337]                   base::options(opts)
[17:43:48.337]                 }
[17:43:48.337]                 {
[17:43:48.337]                   {
[17:43:48.337]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.337]                     NULL
[17:43:48.337]                   }
[17:43:48.337]                   options(future.plan = NULL)
[17:43:48.337]                   if (is.na(NA_character_)) 
[17:43:48.337]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.337]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.337]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.337]                     .init = FALSE)
[17:43:48.337]                 }
[17:43:48.337]             }
[17:43:48.337]         }
[17:43:48.337]     })
[17:43:48.337]     if (TRUE) {
[17:43:48.337]         base::sink(type = "output", split = FALSE)
[17:43:48.337]         if (TRUE) {
[17:43:48.337]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.337]         }
[17:43:48.337]         else {
[17:43:48.337]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.337]         }
[17:43:48.337]         base::close(...future.stdout)
[17:43:48.337]         ...future.stdout <- NULL
[17:43:48.337]     }
[17:43:48.337]     ...future.result$conditions <- ...future.conditions
[17:43:48.337]     ...future.result$finished <- base::Sys.time()
[17:43:48.337]     ...future.result
[17:43:48.337] }
[17:43:48.341] assign_globals() ...
[17:43:48.341] List of 5
[17:43:48.341]  $ future.call.arguments    : list()
[17:43:48.341]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.341]  $ ...future.FUN            :function (x)  
[17:43:48.341]  $ ...future.elements_ii    :List of 3
[17:43:48.341]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:43:48.341]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[17:43:48.341]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[17:43:48.341]  $ ...future.seeds_ii       : NULL
[17:43:48.341]  $ ...future.globals.maxSize: num Inf
[17:43:48.341]  - attr(*, "resolved")= logi FALSE
[17:43:48.341]  - attr(*, "total_size")= num NA
[17:43:48.341]  - attr(*, "where")=List of 5
[17:43:48.341]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.341]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.341]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.341]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.341]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.341]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.341]  - attr(*, "already-done")= logi TRUE
[17:43:48.350] - copied ‘future.call.arguments’ to environment
[17:43:48.350] - copied ‘...future.FUN’ to environment
[17:43:48.351] - copied ‘...future.elements_ii’ to environment
[17:43:48.351] - copied ‘...future.seeds_ii’ to environment
[17:43:48.351] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.351] assign_globals() ... done
[17:43:48.351] requestCore(): workers = 2
[17:43:48.354] MulticoreFuture started
[17:43:48.354] - Launch lazy future ... done
[17:43:48.355] run() for ‘MulticoreFuture’ ... done
[17:43:48.355] Created future:
[17:43:48.355] plan(): Setting new future strategy stack:
[17:43:48.356] List of future strategies:
[17:43:48.356] 1. sequential:
[17:43:48.356]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.356]    - tweaked: FALSE
[17:43:48.356]    - call: NULL
[17:43:48.357] plan(): nbrOfWorkers() = 1
[17:43:48.359] plan(): Setting new future strategy stack:
[17:43:48.359] List of future strategies:
[17:43:48.359] 1. multicore:
[17:43:48.359]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.359]    - tweaked: FALSE
[17:43:48.359]    - call: plan(strategy)
[17:43:48.355] MulticoreFuture:
[17:43:48.355] Label: ‘future_apply-2’
[17:43:48.355] Expression:
[17:43:48.355] {
[17:43:48.355]     do.call(function(...) {
[17:43:48.355]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.355]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.355]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.355]             on.exit(options(oopts), add = TRUE)
[17:43:48.355]         }
[17:43:48.355]         {
[17:43:48.355]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.355]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.355]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.355]             })
[17:43:48.355]         }
[17:43:48.355]     }, args = future.call.arguments)
[17:43:48.355] }
[17:43:48.355] Lazy evaluation: FALSE
[17:43:48.355] Asynchronous evaluation: TRUE
[17:43:48.355] Local evaluation: TRUE
[17:43:48.355] Environment: R_GlobalEnv
[17:43:48.355] Capture standard output: TRUE
[17:43:48.355] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:48.355] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.355] Packages: <none>
[17:43:48.355] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:48.355] Resolved: FALSE
[17:43:48.355] Value: <not collected>
[17:43:48.355] Conditions captured: <none>
[17:43:48.355] Early signaling: FALSE
[17:43:48.355] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.355] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.369] Chunk #2 of 2 ... DONE
[17:43:48.369] Launching 2 futures (chunks) ... DONE
[17:43:48.370] Resolving 2 futures (chunks) ...
[17:43:48.370] resolve() on list ...
[17:43:48.370]  recursive: 0
[17:43:48.370] plan(): nbrOfWorkers() = 2
[17:43:48.370]  length: 2
[17:43:48.371] 
[17:43:48.371] Future #1
[17:43:48.372] result() for MulticoreFuture ...
[17:43:48.373] result() for MulticoreFuture ...
[17:43:48.376] result() for MulticoreFuture ... done
[17:43:48.377] result() for MulticoreFuture ... done
[17:43:48.377] result() for MulticoreFuture ...
[17:43:48.378] result() for MulticoreFuture ... done
[17:43:48.379] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:48.379] - nx: 2
[17:43:48.380] - relay: TRUE
[17:43:48.380] - stdout: TRUE
[17:43:48.381] - signal: TRUE
[17:43:48.381] - resignal: FALSE
[17:43:48.382] - force: TRUE
[17:43:48.382] - relayed: [n=2] FALSE, FALSE
[17:43:48.382] - queued futures: [n=2] FALSE, FALSE
[17:43:48.383]  - until=1
[17:43:48.383]  - relaying element #1
[17:43:48.384] result() for MulticoreFuture ...
[17:43:48.384] result() for MulticoreFuture ... done
[17:43:48.385] result() for MulticoreFuture ...
[17:43:48.385] result() for MulticoreFuture ... done
[17:43:48.386] result() for MulticoreFuture ...
[17:43:48.386] result() for MulticoreFuture ... done
[17:43:48.386] result() for MulticoreFuture ...
[17:43:48.387] result() for MulticoreFuture ... done
[17:43:48.387] - relayed: [n=2] TRUE, FALSE
[17:43:48.388] - queued futures: [n=2] TRUE, FALSE
[17:43:48.388] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:48.388]  length: 1 (resolved future 1)
[17:43:48.389] Future #2
[17:43:48.389] result() for MulticoreFuture ...
[17:43:48.390] result() for MulticoreFuture ...
[17:43:48.390] result() for MulticoreFuture ... done
[17:43:48.390] result() for MulticoreFuture ... done
[17:43:48.391] result() for MulticoreFuture ...
[17:43:48.391] result() for MulticoreFuture ... done
[17:43:48.391] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:48.392] - nx: 2
[17:43:48.392] - relay: TRUE
[17:43:48.392] - stdout: TRUE
[17:43:48.392] - signal: TRUE
[17:43:48.392] - resignal: FALSE
[17:43:48.393] - force: TRUE
[17:43:48.393] - relayed: [n=2] TRUE, FALSE
[17:43:48.393] - queued futures: [n=2] TRUE, FALSE
[17:43:48.393]  - until=2
[17:43:48.393]  - relaying element #2
[17:43:48.394] result() for MulticoreFuture ...
[17:43:48.394] result() for MulticoreFuture ... done
[17:43:48.394] result() for MulticoreFuture ...
[17:43:48.394] result() for MulticoreFuture ... done
[17:43:48.395] result() for MulticoreFuture ...
[17:43:48.395] result() for MulticoreFuture ... done
[17:43:48.395] result() for MulticoreFuture ...
[17:43:48.395] result() for MulticoreFuture ... done
[17:43:48.395] - relayed: [n=2] TRUE, TRUE
[17:43:48.396] - queued futures: [n=2] TRUE, TRUE
[17:43:48.396] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:48.396]  length: 0 (resolved future 2)
[17:43:48.396] Relaying remaining futures
[17:43:48.396] signalConditionsASAP(NULL, pos=0) ...
[17:43:48.396] - nx: 2
[17:43:48.397] - relay: TRUE
[17:43:48.397] - stdout: TRUE
[17:43:48.397] - signal: TRUE
[17:43:48.397] - resignal: FALSE
[17:43:48.397] - force: TRUE
[17:43:48.398] - relayed: [n=2] TRUE, TRUE
[17:43:48.398] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:48.398] - relayed: [n=2] TRUE, TRUE
[17:43:48.398] - queued futures: [n=2] TRUE, TRUE
[17:43:48.398] signalConditionsASAP(NULL, pos=0) ... done
[17:43:48.399] resolve() on list ... DONE
[17:43:48.399] result() for MulticoreFuture ...
[17:43:48.399] result() for MulticoreFuture ... done
[17:43:48.399] result() for MulticoreFuture ...
[17:43:48.399] result() for MulticoreFuture ... done
[17:43:48.400] result() for MulticoreFuture ...
[17:43:48.400] result() for MulticoreFuture ... done
[17:43:48.400] result() for MulticoreFuture ...
[17:43:48.400] result() for MulticoreFuture ... done
[17:43:48.400]  - Number of value chunks collected: 2
[17:43:48.401] Resolving 2 futures (chunks) ... DONE
[17:43:48.401] Reducing values from 2 chunks ...
[17:43:48.401]  - Number of values collected after concatenation: 6
[17:43:48.401]  - Number of values expected: 6
[17:43:48.401] Reducing values from 2 chunks ... DONE
[17:43:48.402] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[17:43:48.403] getGlobalsAndPackagesXApply() ...
[17:43:48.403]  - future.globals: TRUE
[17:43:48.403] getGlobalsAndPackages() ...
[17:43:48.403] Searching for globals...
[17:43:48.406] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[17:43:48.406] Searching for globals ... DONE
[17:43:48.406] Resolving globals: FALSE
[17:43:48.407] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[17:43:48.408] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[17:43:48.408] - globals: [1] ‘FUN’
[17:43:48.408] 
[17:43:48.408] getGlobalsAndPackages() ... DONE
[17:43:48.408]  - globals found/used: [n=1] ‘FUN’
[17:43:48.408]  - needed namespaces: [n=0] 
[17:43:48.409] Finding globals ... DONE
[17:43:48.409]  - use_args: TRUE
[17:43:48.409]  - Getting '...' globals ...
[17:43:48.409] resolve() on list ...
[17:43:48.410]  recursive: 0
[17:43:48.410]  length: 1
[17:43:48.410]  elements: ‘...’
[17:43:48.410]  length: 0 (resolved future 1)
[17:43:48.410] resolve() on list ... DONE
[17:43:48.410]    - '...' content: [n=0] 
[17:43:48.410] List of 1
[17:43:48.410]  $ ...: list()
[17:43:48.410]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.410]  - attr(*, "where")=List of 1
[17:43:48.410]   ..$ ...:<environment: 0x55dfd2975380> 
[17:43:48.410]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.410]  - attr(*, "resolved")= logi TRUE
[17:43:48.410]  - attr(*, "total_size")= num NA
[17:43:48.414]  - Getting '...' globals ... DONE
[17:43:48.414] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:48.414] List of 2
[17:43:48.414]  $ ...future.FUN:function (x)  
[17:43:48.414]  $ ...          : list()
[17:43:48.414]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.414]  - attr(*, "where")=List of 2
[17:43:48.414]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:48.414]   ..$ ...          :<environment: 0x55dfd2975380> 
[17:43:48.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.414]  - attr(*, "resolved")= logi FALSE
[17:43:48.414]  - attr(*, "total_size")= num 1768
[17:43:48.417] Packages to be attached in all futures: [n=0] 
[17:43:48.417] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.421] future_lapply() ...
[17:43:48.426] Number of chunks: 2
[17:43:48.426] getGlobalsAndPackagesXApply() ...
[17:43:48.426]  - future.globals: <name-value list> with names ‘list()’
[17:43:48.427]  - use_args: TRUE
[17:43:48.427] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:48.427] List of 2
[17:43:48.427]  $ ...          : list()
[17:43:48.427]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.427]  $ ...future.FUN:function (x)  
[17:43:48.427]  - attr(*, "where")=List of 2
[17:43:48.427]   ..$ ...          :<environment: 0x55dfd2975380> 
[17:43:48.427]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:43:48.427]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.427]  - attr(*, "resolved")= logi FALSE
[17:43:48.427]  - attr(*, "total_size")= num NA
[17:43:48.430] Packages to be attached in all futures: [n=0] 
[17:43:48.430] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.430] Number of futures (= number of chunks): 2
[17:43:48.431] Launching 2 futures (chunks) ...
[17:43:48.431] Chunk #1 of 2 ...
[17:43:48.431]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.431]  - seeds: <none>
[17:43:48.431]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.431] getGlobalsAndPackages() ...
[17:43:48.431] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.431] Resolving globals: FALSE
[17:43:48.431] Tweak future expression to call with '...' arguments ...
[17:43:48.432] {
[17:43:48.432]     do.call(function(...) {
[17:43:48.432]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.432]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.432]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.432]             on.exit(options(oopts), add = TRUE)
[17:43:48.432]         }
[17:43:48.432]         {
[17:43:48.432]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.432]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.432]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.432]             })
[17:43:48.432]         }
[17:43:48.432]     }, args = future.call.arguments)
[17:43:48.432] }
[17:43:48.432] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.432] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.432] 
[17:43:48.432] getGlobalsAndPackages() ... DONE
[17:43:48.433] run() for ‘Future’ ...
[17:43:48.433] - state: ‘created’
[17:43:48.433] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.436] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.437] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.437]   - Field: ‘label’
[17:43:48.437]   - Field: ‘local’
[17:43:48.437]   - Field: ‘owner’
[17:43:48.437]   - Field: ‘envir’
[17:43:48.437]   - Field: ‘workers’
[17:43:48.437]   - Field: ‘packages’
[17:43:48.437]   - Field: ‘gc’
[17:43:48.437]   - Field: ‘job’
[17:43:48.437]   - Field: ‘conditions’
[17:43:48.437]   - Field: ‘expr’
[17:43:48.438]   - Field: ‘uuid’
[17:43:48.438]   - Field: ‘seed’
[17:43:48.438]   - Field: ‘version’
[17:43:48.438]   - Field: ‘result’
[17:43:48.438]   - Field: ‘asynchronous’
[17:43:48.438]   - Field: ‘calls’
[17:43:48.438]   - Field: ‘globals’
[17:43:48.438]   - Field: ‘stdout’
[17:43:48.438]   - Field: ‘earlySignal’
[17:43:48.438]   - Field: ‘lazy’
[17:43:48.439]   - Field: ‘state’
[17:43:48.439] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.439] - Launch lazy future ...
[17:43:48.439] Packages needed by the future expression (n = 0): <none>
[17:43:48.439] Packages needed by future strategies (n = 0): <none>
[17:43:48.440] {
[17:43:48.440]     {
[17:43:48.440]         {
[17:43:48.440]             ...future.startTime <- base::Sys.time()
[17:43:48.440]             {
[17:43:48.440]                 {
[17:43:48.440]                   {
[17:43:48.440]                     {
[17:43:48.440]                       base::local({
[17:43:48.440]                         has_future <- base::requireNamespace("future", 
[17:43:48.440]                           quietly = TRUE)
[17:43:48.440]                         if (has_future) {
[17:43:48.440]                           ns <- base::getNamespace("future")
[17:43:48.440]                           version <- ns[[".package"]][["version"]]
[17:43:48.440]                           if (is.null(version)) 
[17:43:48.440]                             version <- utils::packageVersion("future")
[17:43:48.440]                         }
[17:43:48.440]                         else {
[17:43:48.440]                           version <- NULL
[17:43:48.440]                         }
[17:43:48.440]                         if (!has_future || version < "1.8.0") {
[17:43:48.440]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.440]                             "", base::R.version$version.string), 
[17:43:48.440]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.440]                               "release", "version")], collapse = " "), 
[17:43:48.440]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.440]                             info)
[17:43:48.440]                           info <- base::paste(info, collapse = "; ")
[17:43:48.440]                           if (!has_future) {
[17:43:48.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.440]                               info)
[17:43:48.440]                           }
[17:43:48.440]                           else {
[17:43:48.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.440]                               info, version)
[17:43:48.440]                           }
[17:43:48.440]                           base::stop(msg)
[17:43:48.440]                         }
[17:43:48.440]                       })
[17:43:48.440]                     }
[17:43:48.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.440]                     base::options(mc.cores = 1L)
[17:43:48.440]                   }
[17:43:48.440]                   ...future.strategy.old <- future::plan("list")
[17:43:48.440]                   options(future.plan = NULL)
[17:43:48.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.440]                 }
[17:43:48.440]                 ...future.workdir <- getwd()
[17:43:48.440]             }
[17:43:48.440]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.440]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.440]         }
[17:43:48.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.440]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.440]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.440]             base::names(...future.oldOptions))
[17:43:48.440]     }
[17:43:48.440]     if (FALSE) {
[17:43:48.440]     }
[17:43:48.440]     else {
[17:43:48.440]         if (TRUE) {
[17:43:48.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.440]                 open = "w")
[17:43:48.440]         }
[17:43:48.440]         else {
[17:43:48.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.440]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.440]         }
[17:43:48.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.440]             base::sink(type = "output", split = FALSE)
[17:43:48.440]             base::close(...future.stdout)
[17:43:48.440]         }, add = TRUE)
[17:43:48.440]     }
[17:43:48.440]     ...future.frame <- base::sys.nframe()
[17:43:48.440]     ...future.conditions <- base::list()
[17:43:48.440]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.440]     if (FALSE) {
[17:43:48.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.440]     }
[17:43:48.440]     ...future.result <- base::tryCatch({
[17:43:48.440]         base::withCallingHandlers({
[17:43:48.440]             ...future.value <- base::withVisible(base::local({
[17:43:48.440]                 withCallingHandlers({
[17:43:48.440]                   {
[17:43:48.440]                     do.call(function(...) {
[17:43:48.440]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.440]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.440]                         ...future.globals.maxSize)) {
[17:43:48.440]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.440]                         on.exit(options(oopts), add = TRUE)
[17:43:48.440]                       }
[17:43:48.440]                       {
[17:43:48.440]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.440]                           FUN = function(jj) {
[17:43:48.440]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.440]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.440]                           })
[17:43:48.440]                       }
[17:43:48.440]                     }, args = future.call.arguments)
[17:43:48.440]                   }
[17:43:48.440]                 }, immediateCondition = function(cond) {
[17:43:48.440]                   save_rds <- function (object, pathname, ...) 
[17:43:48.440]                   {
[17:43:48.440]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.440]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.440]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.440]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.440]                         fi_tmp[["mtime"]])
[17:43:48.440]                     }
[17:43:48.440]                     tryCatch({
[17:43:48.440]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.440]                     }, error = function(ex) {
[17:43:48.440]                       msg <- conditionMessage(ex)
[17:43:48.440]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.440]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.440]                         fi_tmp[["mtime"]], msg)
[17:43:48.440]                       ex$message <- msg
[17:43:48.440]                       stop(ex)
[17:43:48.440]                     })
[17:43:48.440]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.440]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.440]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.440]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.440]                       fi <- file.info(pathname)
[17:43:48.440]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.440]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.440]                         fi[["size"]], fi[["mtime"]])
[17:43:48.440]                       stop(msg)
[17:43:48.440]                     }
[17:43:48.440]                     invisible(pathname)
[17:43:48.440]                   }
[17:43:48.440]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.440]                     rootPath = tempdir()) 
[17:43:48.440]                   {
[17:43:48.440]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.440]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.440]                       tmpdir = path, fileext = ".rds")
[17:43:48.440]                     save_rds(obj, file)
[17:43:48.440]                   }
[17:43:48.440]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.440]                   {
[17:43:48.440]                     inherits <- base::inherits
[17:43:48.440]                     invokeRestart <- base::invokeRestart
[17:43:48.440]                     is.null <- base::is.null
[17:43:48.440]                     muffled <- FALSE
[17:43:48.440]                     if (inherits(cond, "message")) {
[17:43:48.440]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.440]                       if (muffled) 
[17:43:48.440]                         invokeRestart("muffleMessage")
[17:43:48.440]                     }
[17:43:48.440]                     else if (inherits(cond, "warning")) {
[17:43:48.440]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.440]                       if (muffled) 
[17:43:48.440]                         invokeRestart("muffleWarning")
[17:43:48.440]                     }
[17:43:48.440]                     else if (inherits(cond, "condition")) {
[17:43:48.440]                       if (!is.null(pattern)) {
[17:43:48.440]                         computeRestarts <- base::computeRestarts
[17:43:48.440]                         grepl <- base::grepl
[17:43:48.440]                         restarts <- computeRestarts(cond)
[17:43:48.440]                         for (restart in restarts) {
[17:43:48.440]                           name <- restart$name
[17:43:48.440]                           if (is.null(name)) 
[17:43:48.440]                             next
[17:43:48.440]                           if (!grepl(pattern, name)) 
[17:43:48.440]                             next
[17:43:48.440]                           invokeRestart(restart)
[17:43:48.440]                           muffled <- TRUE
[17:43:48.440]                           break
[17:43:48.440]                         }
[17:43:48.440]                       }
[17:43:48.440]                     }
[17:43:48.440]                     invisible(muffled)
[17:43:48.440]                   }
[17:43:48.440]                   muffleCondition(cond)
[17:43:48.440]                 })
[17:43:48.440]             }))
[17:43:48.440]             future::FutureResult(value = ...future.value$value, 
[17:43:48.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.440]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.440]                     ...future.globalenv.names))
[17:43:48.440]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.440]         }, condition = base::local({
[17:43:48.440]             c <- base::c
[17:43:48.440]             inherits <- base::inherits
[17:43:48.440]             invokeRestart <- base::invokeRestart
[17:43:48.440]             length <- base::length
[17:43:48.440]             list <- base::list
[17:43:48.440]             seq.int <- base::seq.int
[17:43:48.440]             signalCondition <- base::signalCondition
[17:43:48.440]             sys.calls <- base::sys.calls
[17:43:48.440]             `[[` <- base::`[[`
[17:43:48.440]             `+` <- base::`+`
[17:43:48.440]             `<<-` <- base::`<<-`
[17:43:48.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.440]                   3L)]
[17:43:48.440]             }
[17:43:48.440]             function(cond) {
[17:43:48.440]                 is_error <- inherits(cond, "error")
[17:43:48.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.440]                   NULL)
[17:43:48.440]                 if (is_error) {
[17:43:48.440]                   sessionInformation <- function() {
[17:43:48.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.440]                       search = base::search(), system = base::Sys.info())
[17:43:48.440]                   }
[17:43:48.440]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.440]                     cond$call), session = sessionInformation(), 
[17:43:48.440]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.440]                   signalCondition(cond)
[17:43:48.440]                 }
[17:43:48.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.440]                 "immediateCondition"))) {
[17:43:48.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.440]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.440]                   if (TRUE && !signal) {
[17:43:48.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.440]                     {
[17:43:48.440]                       inherits <- base::inherits
[17:43:48.440]                       invokeRestart <- base::invokeRestart
[17:43:48.440]                       is.null <- base::is.null
[17:43:48.440]                       muffled <- FALSE
[17:43:48.440]                       if (inherits(cond, "message")) {
[17:43:48.440]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.440]                         if (muffled) 
[17:43:48.440]                           invokeRestart("muffleMessage")
[17:43:48.440]                       }
[17:43:48.440]                       else if (inherits(cond, "warning")) {
[17:43:48.440]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.440]                         if (muffled) 
[17:43:48.440]                           invokeRestart("muffleWarning")
[17:43:48.440]                       }
[17:43:48.440]                       else if (inherits(cond, "condition")) {
[17:43:48.440]                         if (!is.null(pattern)) {
[17:43:48.440]                           computeRestarts <- base::computeRestarts
[17:43:48.440]                           grepl <- base::grepl
[17:43:48.440]                           restarts <- computeRestarts(cond)
[17:43:48.440]                           for (restart in restarts) {
[17:43:48.440]                             name <- restart$name
[17:43:48.440]                             if (is.null(name)) 
[17:43:48.440]                               next
[17:43:48.440]                             if (!grepl(pattern, name)) 
[17:43:48.440]                               next
[17:43:48.440]                             invokeRestart(restart)
[17:43:48.440]                             muffled <- TRUE
[17:43:48.440]                             break
[17:43:48.440]                           }
[17:43:48.440]                         }
[17:43:48.440]                       }
[17:43:48.440]                       invisible(muffled)
[17:43:48.440]                     }
[17:43:48.440]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.440]                   }
[17:43:48.440]                 }
[17:43:48.440]                 else {
[17:43:48.440]                   if (TRUE) {
[17:43:48.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.440]                     {
[17:43:48.440]                       inherits <- base::inherits
[17:43:48.440]                       invokeRestart <- base::invokeRestart
[17:43:48.440]                       is.null <- base::is.null
[17:43:48.440]                       muffled <- FALSE
[17:43:48.440]                       if (inherits(cond, "message")) {
[17:43:48.440]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.440]                         if (muffled) 
[17:43:48.440]                           invokeRestart("muffleMessage")
[17:43:48.440]                       }
[17:43:48.440]                       else if (inherits(cond, "warning")) {
[17:43:48.440]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.440]                         if (muffled) 
[17:43:48.440]                           invokeRestart("muffleWarning")
[17:43:48.440]                       }
[17:43:48.440]                       else if (inherits(cond, "condition")) {
[17:43:48.440]                         if (!is.null(pattern)) {
[17:43:48.440]                           computeRestarts <- base::computeRestarts
[17:43:48.440]                           grepl <- base::grepl
[17:43:48.440]                           restarts <- computeRestarts(cond)
[17:43:48.440]                           for (restart in restarts) {
[17:43:48.440]                             name <- restart$name
[17:43:48.440]                             if (is.null(name)) 
[17:43:48.440]                               next
[17:43:48.440]                             if (!grepl(pattern, name)) 
[17:43:48.440]                               next
[17:43:48.440]                             invokeRestart(restart)
[17:43:48.440]                             muffled <- TRUE
[17:43:48.440]                             break
[17:43:48.440]                           }
[17:43:48.440]                         }
[17:43:48.440]                       }
[17:43:48.440]                       invisible(muffled)
[17:43:48.440]                     }
[17:43:48.440]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.440]                   }
[17:43:48.440]                 }
[17:43:48.440]             }
[17:43:48.440]         }))
[17:43:48.440]     }, error = function(ex) {
[17:43:48.440]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.440]                 ...future.rng), started = ...future.startTime, 
[17:43:48.440]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.440]             version = "1.8"), class = "FutureResult")
[17:43:48.440]     }, finally = {
[17:43:48.440]         if (!identical(...future.workdir, getwd())) 
[17:43:48.440]             setwd(...future.workdir)
[17:43:48.440]         {
[17:43:48.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.440]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.440]             }
[17:43:48.440]             base::options(...future.oldOptions)
[17:43:48.440]             if (.Platform$OS.type == "windows") {
[17:43:48.440]                 old_names <- names(...future.oldEnvVars)
[17:43:48.440]                 envs <- base::Sys.getenv()
[17:43:48.440]                 names <- names(envs)
[17:43:48.440]                 common <- intersect(names, old_names)
[17:43:48.440]                 added <- setdiff(names, old_names)
[17:43:48.440]                 removed <- setdiff(old_names, names)
[17:43:48.440]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.440]                   envs[common]]
[17:43:48.440]                 NAMES <- toupper(changed)
[17:43:48.440]                 args <- list()
[17:43:48.440]                 for (kk in seq_along(NAMES)) {
[17:43:48.440]                   name <- changed[[kk]]
[17:43:48.440]                   NAME <- NAMES[[kk]]
[17:43:48.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.440]                     next
[17:43:48.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.440]                 }
[17:43:48.440]                 NAMES <- toupper(added)
[17:43:48.440]                 for (kk in seq_along(NAMES)) {
[17:43:48.440]                   name <- added[[kk]]
[17:43:48.440]                   NAME <- NAMES[[kk]]
[17:43:48.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.440]                     next
[17:43:48.440]                   args[[name]] <- ""
[17:43:48.440]                 }
[17:43:48.440]                 NAMES <- toupper(removed)
[17:43:48.440]                 for (kk in seq_along(NAMES)) {
[17:43:48.440]                   name <- removed[[kk]]
[17:43:48.440]                   NAME <- NAMES[[kk]]
[17:43:48.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.440]                     next
[17:43:48.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.440]                 }
[17:43:48.440]                 if (length(args) > 0) 
[17:43:48.440]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.440]             }
[17:43:48.440]             else {
[17:43:48.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.440]             }
[17:43:48.440]             {
[17:43:48.440]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.440]                   0L) {
[17:43:48.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.440]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.440]                   base::options(opts)
[17:43:48.440]                 }
[17:43:48.440]                 {
[17:43:48.440]                   {
[17:43:48.440]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.440]                     NULL
[17:43:48.440]                   }
[17:43:48.440]                   options(future.plan = NULL)
[17:43:48.440]                   if (is.na(NA_character_)) 
[17:43:48.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.440]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.440]                     .init = FALSE)
[17:43:48.440]                 }
[17:43:48.440]             }
[17:43:48.440]         }
[17:43:48.440]     })
[17:43:48.440]     if (TRUE) {
[17:43:48.440]         base::sink(type = "output", split = FALSE)
[17:43:48.440]         if (TRUE) {
[17:43:48.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.440]         }
[17:43:48.440]         else {
[17:43:48.440]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.440]         }
[17:43:48.440]         base::close(...future.stdout)
[17:43:48.440]         ...future.stdout <- NULL
[17:43:48.440]     }
[17:43:48.440]     ...future.result$conditions <- ...future.conditions
[17:43:48.440]     ...future.result$finished <- base::Sys.time()
[17:43:48.440]     ...future.result
[17:43:48.440] }
[17:43:48.442] assign_globals() ...
[17:43:48.442] List of 5
[17:43:48.442]  $ future.call.arguments    : list()
[17:43:48.442]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.442]  $ ...future.FUN            :function (x)  
[17:43:48.442]  $ ...future.elements_ii    :List of 3
[17:43:48.442]   ..$ : int [1:4] 1 7 13 19
[17:43:48.442]   ..$ : int [1:4] 2 8 14 20
[17:43:48.442]   ..$ : int [1:4] 3 9 15 21
[17:43:48.442]  $ ...future.seeds_ii       : NULL
[17:43:48.442]  $ ...future.globals.maxSize: num Inf
[17:43:48.442]  - attr(*, "resolved")= logi FALSE
[17:43:48.442]  - attr(*, "total_size")= num NA
[17:43:48.442]  - attr(*, "where")=List of 5
[17:43:48.442]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.442]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.442]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.442]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.442]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.442]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.442]  - attr(*, "already-done")= logi TRUE
[17:43:48.447] - copied ‘future.call.arguments’ to environment
[17:43:48.447] - reassign environment for ‘...future.FUN’
[17:43:48.448] - copied ‘...future.FUN’ to environment
[17:43:48.448] - copied ‘...future.elements_ii’ to environment
[17:43:48.448] - copied ‘...future.seeds_ii’ to environment
[17:43:48.448] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.448] assign_globals() ... done
[17:43:48.448] requestCore(): workers = 2
[17:43:48.450] MulticoreFuture started
[17:43:48.451] - Launch lazy future ... done
[17:43:48.451] run() for ‘MulticoreFuture’ ... done
[17:43:48.451] Created future:
[17:43:48.451] plan(): Setting new future strategy stack:
[17:43:48.452] List of future strategies:
[17:43:48.452] 1. sequential:
[17:43:48.452]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.452]    - tweaked: FALSE
[17:43:48.452]    - call: NULL
[17:43:48.453] plan(): nbrOfWorkers() = 1
[17:43:48.455] plan(): Setting new future strategy stack:
[17:43:48.455] List of future strategies:
[17:43:48.455] 1. multicore:
[17:43:48.455]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.455]    - tweaked: FALSE
[17:43:48.455]    - call: plan(strategy)
[17:43:48.460] plan(): nbrOfWorkers() = 2
[17:43:48.451] MulticoreFuture:
[17:43:48.451] Label: ‘future_apply-1’
[17:43:48.451] Expression:
[17:43:48.451] {
[17:43:48.451]     do.call(function(...) {
[17:43:48.451]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.451]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.451]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.451]             on.exit(options(oopts), add = TRUE)
[17:43:48.451]         }
[17:43:48.451]         {
[17:43:48.451]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.451]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.451]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.451]             })
[17:43:48.451]         }
[17:43:48.451]     }, args = future.call.arguments)
[17:43:48.451] }
[17:43:48.451] Lazy evaluation: FALSE
[17:43:48.451] Asynchronous evaluation: TRUE
[17:43:48.451] Local evaluation: TRUE
[17:43:48.451] Environment: R_GlobalEnv
[17:43:48.451] Capture standard output: TRUE
[17:43:48.451] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:48.451] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.451] Packages: <none>
[17:43:48.451] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:48.451] Resolved: TRUE
[17:43:48.451] Value: <not collected>
[17:43:48.451] Conditions captured: <none>
[17:43:48.451] Early signaling: FALSE
[17:43:48.451] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.451] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.461] Chunk #1 of 2 ... DONE
[17:43:48.461] Chunk #2 of 2 ...
[17:43:48.461]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.461]  - seeds: <none>
[17:43:48.461]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.462] getGlobalsAndPackages() ...
[17:43:48.462] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.462] Resolving globals: FALSE
[17:43:48.462] Tweak future expression to call with '...' arguments ...
[17:43:48.462] {
[17:43:48.462]     do.call(function(...) {
[17:43:48.462]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.462]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.462]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.462]             on.exit(options(oopts), add = TRUE)
[17:43:48.462]         }
[17:43:48.462]         {
[17:43:48.462]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.462]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.462]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.462]             })
[17:43:48.462]         }
[17:43:48.462]     }, args = future.call.arguments)
[17:43:48.462] }
[17:43:48.463] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.463] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.463] 
[17:43:48.464] getGlobalsAndPackages() ... DONE
[17:43:48.468] run() for ‘Future’ ...
[17:43:48.468] - state: ‘created’
[17:43:48.469] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.475] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.476] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.476]   - Field: ‘label’
[17:43:48.476]   - Field: ‘local’
[17:43:48.477]   - Field: ‘owner’
[17:43:48.477]   - Field: ‘envir’
[17:43:48.477]   - Field: ‘workers’
[17:43:48.477]   - Field: ‘packages’
[17:43:48.477]   - Field: ‘gc’
[17:43:48.478]   - Field: ‘job’
[17:43:48.478]   - Field: ‘conditions’
[17:43:48.478]   - Field: ‘expr’
[17:43:48.478]   - Field: ‘uuid’
[17:43:48.478]   - Field: ‘seed’
[17:43:48.478]   - Field: ‘version’
[17:43:48.478]   - Field: ‘result’
[17:43:48.479]   - Field: ‘asynchronous’
[17:43:48.479]   - Field: ‘calls’
[17:43:48.479]   - Field: ‘globals’
[17:43:48.479]   - Field: ‘stdout’
[17:43:48.479]   - Field: ‘earlySignal’
[17:43:48.479]   - Field: ‘lazy’
[17:43:48.480]   - Field: ‘state’
[17:43:48.480] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.480] - Launch lazy future ...
[17:43:48.481] Packages needed by the future expression (n = 0): <none>
[17:43:48.481] Packages needed by future strategies (n = 0): <none>
[17:43:48.481] {
[17:43:48.481]     {
[17:43:48.481]         {
[17:43:48.481]             ...future.startTime <- base::Sys.time()
[17:43:48.481]             {
[17:43:48.481]                 {
[17:43:48.481]                   {
[17:43:48.481]                     {
[17:43:48.481]                       base::local({
[17:43:48.481]                         has_future <- base::requireNamespace("future", 
[17:43:48.481]                           quietly = TRUE)
[17:43:48.481]                         if (has_future) {
[17:43:48.481]                           ns <- base::getNamespace("future")
[17:43:48.481]                           version <- ns[[".package"]][["version"]]
[17:43:48.481]                           if (is.null(version)) 
[17:43:48.481]                             version <- utils::packageVersion("future")
[17:43:48.481]                         }
[17:43:48.481]                         else {
[17:43:48.481]                           version <- NULL
[17:43:48.481]                         }
[17:43:48.481]                         if (!has_future || version < "1.8.0") {
[17:43:48.481]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.481]                             "", base::R.version$version.string), 
[17:43:48.481]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.481]                               "release", "version")], collapse = " "), 
[17:43:48.481]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.481]                             info)
[17:43:48.481]                           info <- base::paste(info, collapse = "; ")
[17:43:48.481]                           if (!has_future) {
[17:43:48.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.481]                               info)
[17:43:48.481]                           }
[17:43:48.481]                           else {
[17:43:48.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.481]                               info, version)
[17:43:48.481]                           }
[17:43:48.481]                           base::stop(msg)
[17:43:48.481]                         }
[17:43:48.481]                       })
[17:43:48.481]                     }
[17:43:48.481]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.481]                     base::options(mc.cores = 1L)
[17:43:48.481]                   }
[17:43:48.481]                   ...future.strategy.old <- future::plan("list")
[17:43:48.481]                   options(future.plan = NULL)
[17:43:48.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.481]                 }
[17:43:48.481]                 ...future.workdir <- getwd()
[17:43:48.481]             }
[17:43:48.481]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.481]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.481]         }
[17:43:48.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.481]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.481]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.481]             base::names(...future.oldOptions))
[17:43:48.481]     }
[17:43:48.481]     if (FALSE) {
[17:43:48.481]     }
[17:43:48.481]     else {
[17:43:48.481]         if (TRUE) {
[17:43:48.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.481]                 open = "w")
[17:43:48.481]         }
[17:43:48.481]         else {
[17:43:48.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.481]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.481]         }
[17:43:48.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.481]             base::sink(type = "output", split = FALSE)
[17:43:48.481]             base::close(...future.stdout)
[17:43:48.481]         }, add = TRUE)
[17:43:48.481]     }
[17:43:48.481]     ...future.frame <- base::sys.nframe()
[17:43:48.481]     ...future.conditions <- base::list()
[17:43:48.481]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.481]     if (FALSE) {
[17:43:48.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.481]     }
[17:43:48.481]     ...future.result <- base::tryCatch({
[17:43:48.481]         base::withCallingHandlers({
[17:43:48.481]             ...future.value <- base::withVisible(base::local({
[17:43:48.481]                 withCallingHandlers({
[17:43:48.481]                   {
[17:43:48.481]                     do.call(function(...) {
[17:43:48.481]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.481]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.481]                         ...future.globals.maxSize)) {
[17:43:48.481]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.481]                         on.exit(options(oopts), add = TRUE)
[17:43:48.481]                       }
[17:43:48.481]                       {
[17:43:48.481]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.481]                           FUN = function(jj) {
[17:43:48.481]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.481]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.481]                           })
[17:43:48.481]                       }
[17:43:48.481]                     }, args = future.call.arguments)
[17:43:48.481]                   }
[17:43:48.481]                 }, immediateCondition = function(cond) {
[17:43:48.481]                   save_rds <- function (object, pathname, ...) 
[17:43:48.481]                   {
[17:43:48.481]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.481]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.481]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.481]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.481]                         fi_tmp[["mtime"]])
[17:43:48.481]                     }
[17:43:48.481]                     tryCatch({
[17:43:48.481]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.481]                     }, error = function(ex) {
[17:43:48.481]                       msg <- conditionMessage(ex)
[17:43:48.481]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.481]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.481]                         fi_tmp[["mtime"]], msg)
[17:43:48.481]                       ex$message <- msg
[17:43:48.481]                       stop(ex)
[17:43:48.481]                     })
[17:43:48.481]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.481]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.481]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.481]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.481]                       fi <- file.info(pathname)
[17:43:48.481]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.481]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.481]                         fi[["size"]], fi[["mtime"]])
[17:43:48.481]                       stop(msg)
[17:43:48.481]                     }
[17:43:48.481]                     invisible(pathname)
[17:43:48.481]                   }
[17:43:48.481]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.481]                     rootPath = tempdir()) 
[17:43:48.481]                   {
[17:43:48.481]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.481]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.481]                       tmpdir = path, fileext = ".rds")
[17:43:48.481]                     save_rds(obj, file)
[17:43:48.481]                   }
[17:43:48.481]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.481]                   {
[17:43:48.481]                     inherits <- base::inherits
[17:43:48.481]                     invokeRestart <- base::invokeRestart
[17:43:48.481]                     is.null <- base::is.null
[17:43:48.481]                     muffled <- FALSE
[17:43:48.481]                     if (inherits(cond, "message")) {
[17:43:48.481]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.481]                       if (muffled) 
[17:43:48.481]                         invokeRestart("muffleMessage")
[17:43:48.481]                     }
[17:43:48.481]                     else if (inherits(cond, "warning")) {
[17:43:48.481]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.481]                       if (muffled) 
[17:43:48.481]                         invokeRestart("muffleWarning")
[17:43:48.481]                     }
[17:43:48.481]                     else if (inherits(cond, "condition")) {
[17:43:48.481]                       if (!is.null(pattern)) {
[17:43:48.481]                         computeRestarts <- base::computeRestarts
[17:43:48.481]                         grepl <- base::grepl
[17:43:48.481]                         restarts <- computeRestarts(cond)
[17:43:48.481]                         for (restart in restarts) {
[17:43:48.481]                           name <- restart$name
[17:43:48.481]                           if (is.null(name)) 
[17:43:48.481]                             next
[17:43:48.481]                           if (!grepl(pattern, name)) 
[17:43:48.481]                             next
[17:43:48.481]                           invokeRestart(restart)
[17:43:48.481]                           muffled <- TRUE
[17:43:48.481]                           break
[17:43:48.481]                         }
[17:43:48.481]                       }
[17:43:48.481]                     }
[17:43:48.481]                     invisible(muffled)
[17:43:48.481]                   }
[17:43:48.481]                   muffleCondition(cond)
[17:43:48.481]                 })
[17:43:48.481]             }))
[17:43:48.481]             future::FutureResult(value = ...future.value$value, 
[17:43:48.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.481]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.481]                     ...future.globalenv.names))
[17:43:48.481]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.481]         }, condition = base::local({
[17:43:48.481]             c <- base::c
[17:43:48.481]             inherits <- base::inherits
[17:43:48.481]             invokeRestart <- base::invokeRestart
[17:43:48.481]             length <- base::length
[17:43:48.481]             list <- base::list
[17:43:48.481]             seq.int <- base::seq.int
[17:43:48.481]             signalCondition <- base::signalCondition
[17:43:48.481]             sys.calls <- base::sys.calls
[17:43:48.481]             `[[` <- base::`[[`
[17:43:48.481]             `+` <- base::`+`
[17:43:48.481]             `<<-` <- base::`<<-`
[17:43:48.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.481]                   3L)]
[17:43:48.481]             }
[17:43:48.481]             function(cond) {
[17:43:48.481]                 is_error <- inherits(cond, "error")
[17:43:48.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.481]                   NULL)
[17:43:48.481]                 if (is_error) {
[17:43:48.481]                   sessionInformation <- function() {
[17:43:48.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.481]                       search = base::search(), system = base::Sys.info())
[17:43:48.481]                   }
[17:43:48.481]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.481]                     cond$call), session = sessionInformation(), 
[17:43:48.481]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.481]                   signalCondition(cond)
[17:43:48.481]                 }
[17:43:48.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.481]                 "immediateCondition"))) {
[17:43:48.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.481]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.481]                   if (TRUE && !signal) {
[17:43:48.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.481]                     {
[17:43:48.481]                       inherits <- base::inherits
[17:43:48.481]                       invokeRestart <- base::invokeRestart
[17:43:48.481]                       is.null <- base::is.null
[17:43:48.481]                       muffled <- FALSE
[17:43:48.481]                       if (inherits(cond, "message")) {
[17:43:48.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.481]                         if (muffled) 
[17:43:48.481]                           invokeRestart("muffleMessage")
[17:43:48.481]                       }
[17:43:48.481]                       else if (inherits(cond, "warning")) {
[17:43:48.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.481]                         if (muffled) 
[17:43:48.481]                           invokeRestart("muffleWarning")
[17:43:48.481]                       }
[17:43:48.481]                       else if (inherits(cond, "condition")) {
[17:43:48.481]                         if (!is.null(pattern)) {
[17:43:48.481]                           computeRestarts <- base::computeRestarts
[17:43:48.481]                           grepl <- base::grepl
[17:43:48.481]                           restarts <- computeRestarts(cond)
[17:43:48.481]                           for (restart in restarts) {
[17:43:48.481]                             name <- restart$name
[17:43:48.481]                             if (is.null(name)) 
[17:43:48.481]                               next
[17:43:48.481]                             if (!grepl(pattern, name)) 
[17:43:48.481]                               next
[17:43:48.481]                             invokeRestart(restart)
[17:43:48.481]                             muffled <- TRUE
[17:43:48.481]                             break
[17:43:48.481]                           }
[17:43:48.481]                         }
[17:43:48.481]                       }
[17:43:48.481]                       invisible(muffled)
[17:43:48.481]                     }
[17:43:48.481]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.481]                   }
[17:43:48.481]                 }
[17:43:48.481]                 else {
[17:43:48.481]                   if (TRUE) {
[17:43:48.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.481]                     {
[17:43:48.481]                       inherits <- base::inherits
[17:43:48.481]                       invokeRestart <- base::invokeRestart
[17:43:48.481]                       is.null <- base::is.null
[17:43:48.481]                       muffled <- FALSE
[17:43:48.481]                       if (inherits(cond, "message")) {
[17:43:48.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.481]                         if (muffled) 
[17:43:48.481]                           invokeRestart("muffleMessage")
[17:43:48.481]                       }
[17:43:48.481]                       else if (inherits(cond, "warning")) {
[17:43:48.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.481]                         if (muffled) 
[17:43:48.481]                           invokeRestart("muffleWarning")
[17:43:48.481]                       }
[17:43:48.481]                       else if (inherits(cond, "condition")) {
[17:43:48.481]                         if (!is.null(pattern)) {
[17:43:48.481]                           computeRestarts <- base::computeRestarts
[17:43:48.481]                           grepl <- base::grepl
[17:43:48.481]                           restarts <- computeRestarts(cond)
[17:43:48.481]                           for (restart in restarts) {
[17:43:48.481]                             name <- restart$name
[17:43:48.481]                             if (is.null(name)) 
[17:43:48.481]                               next
[17:43:48.481]                             if (!grepl(pattern, name)) 
[17:43:48.481]                               next
[17:43:48.481]                             invokeRestart(restart)
[17:43:48.481]                             muffled <- TRUE
[17:43:48.481]                             break
[17:43:48.481]                           }
[17:43:48.481]                         }
[17:43:48.481]                       }
[17:43:48.481]                       invisible(muffled)
[17:43:48.481]                     }
[17:43:48.481]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.481]                   }
[17:43:48.481]                 }
[17:43:48.481]             }
[17:43:48.481]         }))
[17:43:48.481]     }, error = function(ex) {
[17:43:48.481]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.481]                 ...future.rng), started = ...future.startTime, 
[17:43:48.481]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.481]             version = "1.8"), class = "FutureResult")
[17:43:48.481]     }, finally = {
[17:43:48.481]         if (!identical(...future.workdir, getwd())) 
[17:43:48.481]             setwd(...future.workdir)
[17:43:48.481]         {
[17:43:48.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.481]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.481]             }
[17:43:48.481]             base::options(...future.oldOptions)
[17:43:48.481]             if (.Platform$OS.type == "windows") {
[17:43:48.481]                 old_names <- names(...future.oldEnvVars)
[17:43:48.481]                 envs <- base::Sys.getenv()
[17:43:48.481]                 names <- names(envs)
[17:43:48.481]                 common <- intersect(names, old_names)
[17:43:48.481]                 added <- setdiff(names, old_names)
[17:43:48.481]                 removed <- setdiff(old_names, names)
[17:43:48.481]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.481]                   envs[common]]
[17:43:48.481]                 NAMES <- toupper(changed)
[17:43:48.481]                 args <- list()
[17:43:48.481]                 for (kk in seq_along(NAMES)) {
[17:43:48.481]                   name <- changed[[kk]]
[17:43:48.481]                   NAME <- NAMES[[kk]]
[17:43:48.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.481]                     next
[17:43:48.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.481]                 }
[17:43:48.481]                 NAMES <- toupper(added)
[17:43:48.481]                 for (kk in seq_along(NAMES)) {
[17:43:48.481]                   name <- added[[kk]]
[17:43:48.481]                   NAME <- NAMES[[kk]]
[17:43:48.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.481]                     next
[17:43:48.481]                   args[[name]] <- ""
[17:43:48.481]                 }
[17:43:48.481]                 NAMES <- toupper(removed)
[17:43:48.481]                 for (kk in seq_along(NAMES)) {
[17:43:48.481]                   name <- removed[[kk]]
[17:43:48.481]                   NAME <- NAMES[[kk]]
[17:43:48.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.481]                     next
[17:43:48.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.481]                 }
[17:43:48.481]                 if (length(args) > 0) 
[17:43:48.481]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.481]             }
[17:43:48.481]             else {
[17:43:48.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.481]             }
[17:43:48.481]             {
[17:43:48.481]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.481]                   0L) {
[17:43:48.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.481]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.481]                   base::options(opts)
[17:43:48.481]                 }
[17:43:48.481]                 {
[17:43:48.481]                   {
[17:43:48.481]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.481]                     NULL
[17:43:48.481]                   }
[17:43:48.481]                   options(future.plan = NULL)
[17:43:48.481]                   if (is.na(NA_character_)) 
[17:43:48.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.481]                     .init = FALSE)
[17:43:48.481]                 }
[17:43:48.481]             }
[17:43:48.481]         }
[17:43:48.481]     })
[17:43:48.481]     if (TRUE) {
[17:43:48.481]         base::sink(type = "output", split = FALSE)
[17:43:48.481]         if (TRUE) {
[17:43:48.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.481]         }
[17:43:48.481]         else {
[17:43:48.481]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.481]         }
[17:43:48.481]         base::close(...future.stdout)
[17:43:48.481]         ...future.stdout <- NULL
[17:43:48.481]     }
[17:43:48.481]     ...future.result$conditions <- ...future.conditions
[17:43:48.481]     ...future.result$finished <- base::Sys.time()
[17:43:48.481]     ...future.result
[17:43:48.481] }
[17:43:48.484] assign_globals() ...
[17:43:48.484] List of 5
[17:43:48.484]  $ future.call.arguments    : list()
[17:43:48.484]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.484]  $ ...future.FUN            :function (x)  
[17:43:48.484]  $ ...future.elements_ii    :List of 3
[17:43:48.484]   ..$ : int [1:4] 4 10 16 22
[17:43:48.484]   ..$ : int [1:4] 5 11 17 23
[17:43:48.484]   ..$ : int [1:4] 6 12 18 24
[17:43:48.484]  $ ...future.seeds_ii       : NULL
[17:43:48.484]  $ ...future.globals.maxSize: num Inf
[17:43:48.484]  - attr(*, "resolved")= logi FALSE
[17:43:48.484]  - attr(*, "total_size")= num NA
[17:43:48.484]  - attr(*, "where")=List of 5
[17:43:48.484]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.484]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.484]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.484]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.484]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.484]  - attr(*, "already-done")= logi TRUE
[17:43:48.491] - copied ‘future.call.arguments’ to environment
[17:43:48.491] - reassign environment for ‘...future.FUN’
[17:43:48.492] - copied ‘...future.FUN’ to environment
[17:43:48.492] - copied ‘...future.elements_ii’ to environment
[17:43:48.492] - copied ‘...future.seeds_ii’ to environment
[17:43:48.492] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.492] assign_globals() ... done
[17:43:48.492] requestCore(): workers = 2
[17:43:48.495] MulticoreFuture started
[17:43:48.495] - Launch lazy future ... done
[17:43:48.495] run() for ‘MulticoreFuture’ ... done
[17:43:48.495] Created future:
[17:43:48.496] plan(): Setting new future strategy stack:
[17:43:48.496] List of future strategies:
[17:43:48.496] 1. sequential:
[17:43:48.496]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.496]    - tweaked: FALSE
[17:43:48.496]    - call: NULL
[17:43:48.497] plan(): nbrOfWorkers() = 1
[17:43:48.499] plan(): Setting new future strategy stack:
[17:43:48.499] List of future strategies:
[17:43:48.499] 1. multicore:
[17:43:48.499]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.499]    - tweaked: FALSE
[17:43:48.499]    - call: plan(strategy)
[17:43:48.504] plan(): nbrOfWorkers() = 2
[17:43:48.496] MulticoreFuture:
[17:43:48.496] Label: ‘future_apply-2’
[17:43:48.496] Expression:
[17:43:48.496] {
[17:43:48.496]     do.call(function(...) {
[17:43:48.496]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.496]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.496]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.496]             on.exit(options(oopts), add = TRUE)
[17:43:48.496]         }
[17:43:48.496]         {
[17:43:48.496]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.496]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.496]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.496]             })
[17:43:48.496]         }
[17:43:48.496]     }, args = future.call.arguments)
[17:43:48.496] }
[17:43:48.496] Lazy evaluation: FALSE
[17:43:48.496] Asynchronous evaluation: TRUE
[17:43:48.496] Local evaluation: TRUE
[17:43:48.496] Environment: R_GlobalEnv
[17:43:48.496] Capture standard output: TRUE
[17:43:48.496] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:48.496] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.496] Packages: <none>
[17:43:48.496] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:48.496] Resolved: TRUE
[17:43:48.496] Value: <not collected>
[17:43:48.496] Conditions captured: <none>
[17:43:48.496] Early signaling: FALSE
[17:43:48.496] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.496] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.505] Chunk #2 of 2 ... DONE
[17:43:48.506] Launching 2 futures (chunks) ... DONE
[17:43:48.506] Resolving 2 futures (chunks) ...
[17:43:48.506] resolve() on list ...
[17:43:48.506]  recursive: 0
[17:43:48.506]  length: 2
[17:43:48.506] 
[17:43:48.507] Future #1
[17:43:48.507] result() for MulticoreFuture ...
[17:43:48.508] result() for MulticoreFuture ...
[17:43:48.508] result() for MulticoreFuture ... done
[17:43:48.508] result() for MulticoreFuture ... done
[17:43:48.508] result() for MulticoreFuture ...
[17:43:48.508] result() for MulticoreFuture ... done
[17:43:48.509] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:48.509] - nx: 2
[17:43:48.509] - relay: TRUE
[17:43:48.509] - stdout: TRUE
[17:43:48.509] - signal: TRUE
[17:43:48.509] - resignal: FALSE
[17:43:48.510] - force: TRUE
[17:43:48.510] - relayed: [n=2] FALSE, FALSE
[17:43:48.510] - queued futures: [n=2] FALSE, FALSE
[17:43:48.510]  - until=1
[17:43:48.510]  - relaying element #1
[17:43:48.510] result() for MulticoreFuture ...
[17:43:48.510] result() for MulticoreFuture ... done
[17:43:48.511] result() for MulticoreFuture ...
[17:43:48.511] result() for MulticoreFuture ... done
[17:43:48.511] result() for MulticoreFuture ...
[17:43:48.511] result() for MulticoreFuture ... done
[17:43:48.511] result() for MulticoreFuture ...
[17:43:48.511] result() for MulticoreFuture ... done
[17:43:48.512] - relayed: [n=2] TRUE, FALSE
[17:43:48.512] - queued futures: [n=2] TRUE, FALSE
[17:43:48.512] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:48.512]  length: 1 (resolved future 1)
[17:43:48.512] Future #2
[17:43:48.512] result() for MulticoreFuture ...
[17:43:48.513] result() for MulticoreFuture ...
[17:43:48.513] result() for MulticoreFuture ... done
[17:43:48.513] result() for MulticoreFuture ... done
[17:43:48.514] result() for MulticoreFuture ...
[17:43:48.514] result() for MulticoreFuture ... done
[17:43:48.514] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:48.514] - nx: 2
[17:43:48.514] - relay: TRUE
[17:43:48.514] - stdout: TRUE
[17:43:48.514] - signal: TRUE
[17:43:48.514] - resignal: FALSE
[17:43:48.515] - force: TRUE
[17:43:48.515] - relayed: [n=2] TRUE, FALSE
[17:43:48.515] - queued futures: [n=2] TRUE, FALSE
[17:43:48.515]  - until=2
[17:43:48.515]  - relaying element #2
[17:43:48.515] result() for MulticoreFuture ...
[17:43:48.515] result() for MulticoreFuture ... done
[17:43:48.515] result() for MulticoreFuture ...
[17:43:48.516] result() for MulticoreFuture ... done
[17:43:48.516] result() for MulticoreFuture ...
[17:43:48.516] result() for MulticoreFuture ... done
[17:43:48.516] result() for MulticoreFuture ...
[17:43:48.516] result() for MulticoreFuture ... done
[17:43:48.516] - relayed: [n=2] TRUE, TRUE
[17:43:48.516] - queued futures: [n=2] TRUE, TRUE
[17:43:48.516] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:48.516]  length: 0 (resolved future 2)
[17:43:48.517] Relaying remaining futures
[17:43:48.517] signalConditionsASAP(NULL, pos=0) ...
[17:43:48.517] - nx: 2
[17:43:48.517] - relay: TRUE
[17:43:48.517] - stdout: TRUE
[17:43:48.517] - signal: TRUE
[17:43:48.519] - resignal: FALSE
[17:43:48.520] - force: TRUE
[17:43:48.520] - relayed: [n=2] TRUE, TRUE
[17:43:48.520] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:48.520] - relayed: [n=2] TRUE, TRUE
[17:43:48.521] - queued futures: [n=2] TRUE, TRUE
[17:43:48.521] signalConditionsASAP(NULL, pos=0) ... done
[17:43:48.521] resolve() on list ... DONE
[17:43:48.521] result() for MulticoreFuture ...
[17:43:48.521] result() for MulticoreFuture ... done
[17:43:48.521] result() for MulticoreFuture ...
[17:43:48.522] result() for MulticoreFuture ... done
[17:43:48.522] result() for MulticoreFuture ...
[17:43:48.522] result() for MulticoreFuture ... done
[17:43:48.522] result() for MulticoreFuture ...
[17:43:48.522] result() for MulticoreFuture ... done
[17:43:48.522]  - Number of value chunks collected: 2
[17:43:48.523] Resolving 2 futures (chunks) ... DONE
[17:43:48.523] Reducing values from 2 chunks ...
[17:43:48.523]  - Number of values collected after concatenation: 6
[17:43:48.523]  - Number of values expected: 6
[17:43:48.523] Reducing values from 2 chunks ... DONE
[17:43:48.523] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[17:43:48.524] getGlobalsAndPackagesXApply() ...
[17:43:48.524]  - future.globals: TRUE
[17:43:48.524] getGlobalsAndPackages() ...
[17:43:48.524] Searching for globals...
[17:43:48.526] - globals found: [1] ‘FUN’
[17:43:48.526] Searching for globals ... DONE
[17:43:48.526] Resolving globals: FALSE
[17:43:48.526] The total size of the 1 globals is 848 bytes (848 bytes)
[17:43:48.527] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:43:48.527] - globals: [1] ‘FUN’
[17:43:48.527] 
[17:43:48.527] getGlobalsAndPackages() ... DONE
[17:43:48.527]  - globals found/used: [n=1] ‘FUN’
[17:43:48.527]  - needed namespaces: [n=0] 
[17:43:48.528] Finding globals ... DONE
[17:43:48.528]  - use_args: TRUE
[17:43:48.528]  - Getting '...' globals ...
[17:43:48.528] resolve() on list ...
[17:43:48.528]  recursive: 0
[17:43:48.528]  length: 1
[17:43:48.528]  elements: ‘...’
[17:43:48.529]  length: 0 (resolved future 1)
[17:43:48.529] resolve() on list ... DONE
[17:43:48.529]    - '...' content: [n=0] 
[17:43:48.529] List of 1
[17:43:48.529]  $ ...: list()
[17:43:48.529]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.529]  - attr(*, "where")=List of 1
[17:43:48.529]   ..$ ...:<environment: 0x55dfd4da9768> 
[17:43:48.529]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.529]  - attr(*, "resolved")= logi TRUE
[17:43:48.529]  - attr(*, "total_size")= num NA
[17:43:48.532]  - Getting '...' globals ... DONE
[17:43:48.532] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:48.532] List of 2
[17:43:48.532]  $ ...future.FUN:function (x)  
[17:43:48.532]  $ ...          : list()
[17:43:48.532]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.532]  - attr(*, "where")=List of 2
[17:43:48.532]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:48.532]   ..$ ...          :<environment: 0x55dfd4da9768> 
[17:43:48.532]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.532]  - attr(*, "resolved")= logi FALSE
[17:43:48.532]  - attr(*, "total_size")= num 848
[17:43:48.535] Packages to be attached in all futures: [n=0] 
[17:43:48.535] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.539] future_lapply() ...
[17:43:48.543] Number of chunks: 2
[17:43:48.543] getGlobalsAndPackagesXApply() ...
[17:43:48.544]  - future.globals: <name-value list> with names ‘list()’
[17:43:48.544]  - use_args: TRUE
[17:43:48.544] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:48.544] List of 2
[17:43:48.544]  $ ...          : list()
[17:43:48.544]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.544]  $ ...future.FUN:function (x)  
[17:43:48.544]  - attr(*, "where")=List of 2
[17:43:48.544]   ..$ ...          :<environment: 0x55dfd4da9768> 
[17:43:48.544]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:48.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.544]  - attr(*, "resolved")= logi FALSE
[17:43:48.544]  - attr(*, "total_size")= num NA
[17:43:48.547] Packages to be attached in all futures: [n=0] 
[17:43:48.547] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.547] Number of futures (= number of chunks): 2
[17:43:48.548] Launching 2 futures (chunks) ...
[17:43:48.548] Chunk #1 of 2 ...
[17:43:48.548]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.548]  - seeds: <none>
[17:43:48.548]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.548] getGlobalsAndPackages() ...
[17:43:48.548] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.548] Resolving globals: FALSE
[17:43:48.548] Tweak future expression to call with '...' arguments ...
[17:43:48.549] {
[17:43:48.549]     do.call(function(...) {
[17:43:48.549]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.549]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.549]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.549]             on.exit(options(oopts), add = TRUE)
[17:43:48.549]         }
[17:43:48.549]         {
[17:43:48.549]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.549]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.549]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.549]             })
[17:43:48.549]         }
[17:43:48.549]     }, args = future.call.arguments)
[17:43:48.549] }
[17:43:48.549] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.549] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.549] 
[17:43:48.549] getGlobalsAndPackages() ... DONE
[17:43:48.550] run() for ‘Future’ ...
[17:43:48.550] - state: ‘created’
[17:43:48.551] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.555] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.555] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.555]   - Field: ‘label’
[17:43:48.555]   - Field: ‘local’
[17:43:48.555]   - Field: ‘owner’
[17:43:48.555]   - Field: ‘envir’
[17:43:48.555]   - Field: ‘workers’
[17:43:48.556]   - Field: ‘packages’
[17:43:48.556]   - Field: ‘gc’
[17:43:48.556]   - Field: ‘job’
[17:43:48.556]   - Field: ‘conditions’
[17:43:48.556]   - Field: ‘expr’
[17:43:48.556]   - Field: ‘uuid’
[17:43:48.556]   - Field: ‘seed’
[17:43:48.556]   - Field: ‘version’
[17:43:48.556]   - Field: ‘result’
[17:43:48.556]   - Field: ‘asynchronous’
[17:43:48.557]   - Field: ‘calls’
[17:43:48.557]   - Field: ‘globals’
[17:43:48.557]   - Field: ‘stdout’
[17:43:48.557]   - Field: ‘earlySignal’
[17:43:48.557]   - Field: ‘lazy’
[17:43:48.557]   - Field: ‘state’
[17:43:48.557] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.557] - Launch lazy future ...
[17:43:48.557] Packages needed by the future expression (n = 0): <none>
[17:43:48.558] Packages needed by future strategies (n = 0): <none>
[17:43:48.558] {
[17:43:48.558]     {
[17:43:48.558]         {
[17:43:48.558]             ...future.startTime <- base::Sys.time()
[17:43:48.558]             {
[17:43:48.558]                 {
[17:43:48.558]                   {
[17:43:48.558]                     {
[17:43:48.558]                       base::local({
[17:43:48.558]                         has_future <- base::requireNamespace("future", 
[17:43:48.558]                           quietly = TRUE)
[17:43:48.558]                         if (has_future) {
[17:43:48.558]                           ns <- base::getNamespace("future")
[17:43:48.558]                           version <- ns[[".package"]][["version"]]
[17:43:48.558]                           if (is.null(version)) 
[17:43:48.558]                             version <- utils::packageVersion("future")
[17:43:48.558]                         }
[17:43:48.558]                         else {
[17:43:48.558]                           version <- NULL
[17:43:48.558]                         }
[17:43:48.558]                         if (!has_future || version < "1.8.0") {
[17:43:48.558]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.558]                             "", base::R.version$version.string), 
[17:43:48.558]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.558]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.558]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.558]                               "release", "version")], collapse = " "), 
[17:43:48.558]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.558]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.558]                             info)
[17:43:48.558]                           info <- base::paste(info, collapse = "; ")
[17:43:48.558]                           if (!has_future) {
[17:43:48.558]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.558]                               info)
[17:43:48.558]                           }
[17:43:48.558]                           else {
[17:43:48.558]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.558]                               info, version)
[17:43:48.558]                           }
[17:43:48.558]                           base::stop(msg)
[17:43:48.558]                         }
[17:43:48.558]                       })
[17:43:48.558]                     }
[17:43:48.558]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.558]                     base::options(mc.cores = 1L)
[17:43:48.558]                   }
[17:43:48.558]                   ...future.strategy.old <- future::plan("list")
[17:43:48.558]                   options(future.plan = NULL)
[17:43:48.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.558]                 }
[17:43:48.558]                 ...future.workdir <- getwd()
[17:43:48.558]             }
[17:43:48.558]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.558]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.558]         }
[17:43:48.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.558]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.558]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.558]             base::names(...future.oldOptions))
[17:43:48.558]     }
[17:43:48.558]     if (FALSE) {
[17:43:48.558]     }
[17:43:48.558]     else {
[17:43:48.558]         if (TRUE) {
[17:43:48.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.558]                 open = "w")
[17:43:48.558]         }
[17:43:48.558]         else {
[17:43:48.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.558]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.558]         }
[17:43:48.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.558]             base::sink(type = "output", split = FALSE)
[17:43:48.558]             base::close(...future.stdout)
[17:43:48.558]         }, add = TRUE)
[17:43:48.558]     }
[17:43:48.558]     ...future.frame <- base::sys.nframe()
[17:43:48.558]     ...future.conditions <- base::list()
[17:43:48.558]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.558]     if (FALSE) {
[17:43:48.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.558]     }
[17:43:48.558]     ...future.result <- base::tryCatch({
[17:43:48.558]         base::withCallingHandlers({
[17:43:48.558]             ...future.value <- base::withVisible(base::local({
[17:43:48.558]                 withCallingHandlers({
[17:43:48.558]                   {
[17:43:48.558]                     do.call(function(...) {
[17:43:48.558]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.558]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.558]                         ...future.globals.maxSize)) {
[17:43:48.558]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.558]                         on.exit(options(oopts), add = TRUE)
[17:43:48.558]                       }
[17:43:48.558]                       {
[17:43:48.558]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.558]                           FUN = function(jj) {
[17:43:48.558]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.558]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.558]                           })
[17:43:48.558]                       }
[17:43:48.558]                     }, args = future.call.arguments)
[17:43:48.558]                   }
[17:43:48.558]                 }, immediateCondition = function(cond) {
[17:43:48.558]                   save_rds <- function (object, pathname, ...) 
[17:43:48.558]                   {
[17:43:48.558]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.558]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.558]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.558]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.558]                         fi_tmp[["mtime"]])
[17:43:48.558]                     }
[17:43:48.558]                     tryCatch({
[17:43:48.558]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.558]                     }, error = function(ex) {
[17:43:48.558]                       msg <- conditionMessage(ex)
[17:43:48.558]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.558]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.558]                         fi_tmp[["mtime"]], msg)
[17:43:48.558]                       ex$message <- msg
[17:43:48.558]                       stop(ex)
[17:43:48.558]                     })
[17:43:48.558]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.558]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.558]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.558]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.558]                       fi <- file.info(pathname)
[17:43:48.558]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.558]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.558]                         fi[["size"]], fi[["mtime"]])
[17:43:48.558]                       stop(msg)
[17:43:48.558]                     }
[17:43:48.558]                     invisible(pathname)
[17:43:48.558]                   }
[17:43:48.558]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.558]                     rootPath = tempdir()) 
[17:43:48.558]                   {
[17:43:48.558]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.558]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.558]                       tmpdir = path, fileext = ".rds")
[17:43:48.558]                     save_rds(obj, file)
[17:43:48.558]                   }
[17:43:48.558]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.558]                   {
[17:43:48.558]                     inherits <- base::inherits
[17:43:48.558]                     invokeRestart <- base::invokeRestart
[17:43:48.558]                     is.null <- base::is.null
[17:43:48.558]                     muffled <- FALSE
[17:43:48.558]                     if (inherits(cond, "message")) {
[17:43:48.558]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.558]                       if (muffled) 
[17:43:48.558]                         invokeRestart("muffleMessage")
[17:43:48.558]                     }
[17:43:48.558]                     else if (inherits(cond, "warning")) {
[17:43:48.558]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.558]                       if (muffled) 
[17:43:48.558]                         invokeRestart("muffleWarning")
[17:43:48.558]                     }
[17:43:48.558]                     else if (inherits(cond, "condition")) {
[17:43:48.558]                       if (!is.null(pattern)) {
[17:43:48.558]                         computeRestarts <- base::computeRestarts
[17:43:48.558]                         grepl <- base::grepl
[17:43:48.558]                         restarts <- computeRestarts(cond)
[17:43:48.558]                         for (restart in restarts) {
[17:43:48.558]                           name <- restart$name
[17:43:48.558]                           if (is.null(name)) 
[17:43:48.558]                             next
[17:43:48.558]                           if (!grepl(pattern, name)) 
[17:43:48.558]                             next
[17:43:48.558]                           invokeRestart(restart)
[17:43:48.558]                           muffled <- TRUE
[17:43:48.558]                           break
[17:43:48.558]                         }
[17:43:48.558]                       }
[17:43:48.558]                     }
[17:43:48.558]                     invisible(muffled)
[17:43:48.558]                   }
[17:43:48.558]                   muffleCondition(cond)
[17:43:48.558]                 })
[17:43:48.558]             }))
[17:43:48.558]             future::FutureResult(value = ...future.value$value, 
[17:43:48.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.558]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.558]                     ...future.globalenv.names))
[17:43:48.558]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.558]         }, condition = base::local({
[17:43:48.558]             c <- base::c
[17:43:48.558]             inherits <- base::inherits
[17:43:48.558]             invokeRestart <- base::invokeRestart
[17:43:48.558]             length <- base::length
[17:43:48.558]             list <- base::list
[17:43:48.558]             seq.int <- base::seq.int
[17:43:48.558]             signalCondition <- base::signalCondition
[17:43:48.558]             sys.calls <- base::sys.calls
[17:43:48.558]             `[[` <- base::`[[`
[17:43:48.558]             `+` <- base::`+`
[17:43:48.558]             `<<-` <- base::`<<-`
[17:43:48.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.558]                   3L)]
[17:43:48.558]             }
[17:43:48.558]             function(cond) {
[17:43:48.558]                 is_error <- inherits(cond, "error")
[17:43:48.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.558]                   NULL)
[17:43:48.558]                 if (is_error) {
[17:43:48.558]                   sessionInformation <- function() {
[17:43:48.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.558]                       search = base::search(), system = base::Sys.info())
[17:43:48.558]                   }
[17:43:48.558]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.558]                     cond$call), session = sessionInformation(), 
[17:43:48.558]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.558]                   signalCondition(cond)
[17:43:48.558]                 }
[17:43:48.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.558]                 "immediateCondition"))) {
[17:43:48.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.558]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.558]                   if (TRUE && !signal) {
[17:43:48.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.558]                     {
[17:43:48.558]                       inherits <- base::inherits
[17:43:48.558]                       invokeRestart <- base::invokeRestart
[17:43:48.558]                       is.null <- base::is.null
[17:43:48.558]                       muffled <- FALSE
[17:43:48.558]                       if (inherits(cond, "message")) {
[17:43:48.558]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.558]                         if (muffled) 
[17:43:48.558]                           invokeRestart("muffleMessage")
[17:43:48.558]                       }
[17:43:48.558]                       else if (inherits(cond, "warning")) {
[17:43:48.558]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.558]                         if (muffled) 
[17:43:48.558]                           invokeRestart("muffleWarning")
[17:43:48.558]                       }
[17:43:48.558]                       else if (inherits(cond, "condition")) {
[17:43:48.558]                         if (!is.null(pattern)) {
[17:43:48.558]                           computeRestarts <- base::computeRestarts
[17:43:48.558]                           grepl <- base::grepl
[17:43:48.558]                           restarts <- computeRestarts(cond)
[17:43:48.558]                           for (restart in restarts) {
[17:43:48.558]                             name <- restart$name
[17:43:48.558]                             if (is.null(name)) 
[17:43:48.558]                               next
[17:43:48.558]                             if (!grepl(pattern, name)) 
[17:43:48.558]                               next
[17:43:48.558]                             invokeRestart(restart)
[17:43:48.558]                             muffled <- TRUE
[17:43:48.558]                             break
[17:43:48.558]                           }
[17:43:48.558]                         }
[17:43:48.558]                       }
[17:43:48.558]                       invisible(muffled)
[17:43:48.558]                     }
[17:43:48.558]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.558]                   }
[17:43:48.558]                 }
[17:43:48.558]                 else {
[17:43:48.558]                   if (TRUE) {
[17:43:48.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.558]                     {
[17:43:48.558]                       inherits <- base::inherits
[17:43:48.558]                       invokeRestart <- base::invokeRestart
[17:43:48.558]                       is.null <- base::is.null
[17:43:48.558]                       muffled <- FALSE
[17:43:48.558]                       if (inherits(cond, "message")) {
[17:43:48.558]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.558]                         if (muffled) 
[17:43:48.558]                           invokeRestart("muffleMessage")
[17:43:48.558]                       }
[17:43:48.558]                       else if (inherits(cond, "warning")) {
[17:43:48.558]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.558]                         if (muffled) 
[17:43:48.558]                           invokeRestart("muffleWarning")
[17:43:48.558]                       }
[17:43:48.558]                       else if (inherits(cond, "condition")) {
[17:43:48.558]                         if (!is.null(pattern)) {
[17:43:48.558]                           computeRestarts <- base::computeRestarts
[17:43:48.558]                           grepl <- base::grepl
[17:43:48.558]                           restarts <- computeRestarts(cond)
[17:43:48.558]                           for (restart in restarts) {
[17:43:48.558]                             name <- restart$name
[17:43:48.558]                             if (is.null(name)) 
[17:43:48.558]                               next
[17:43:48.558]                             if (!grepl(pattern, name)) 
[17:43:48.558]                               next
[17:43:48.558]                             invokeRestart(restart)
[17:43:48.558]                             muffled <- TRUE
[17:43:48.558]                             break
[17:43:48.558]                           }
[17:43:48.558]                         }
[17:43:48.558]                       }
[17:43:48.558]                       invisible(muffled)
[17:43:48.558]                     }
[17:43:48.558]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.558]                   }
[17:43:48.558]                 }
[17:43:48.558]             }
[17:43:48.558]         }))
[17:43:48.558]     }, error = function(ex) {
[17:43:48.558]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.558]                 ...future.rng), started = ...future.startTime, 
[17:43:48.558]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.558]             version = "1.8"), class = "FutureResult")
[17:43:48.558]     }, finally = {
[17:43:48.558]         if (!identical(...future.workdir, getwd())) 
[17:43:48.558]             setwd(...future.workdir)
[17:43:48.558]         {
[17:43:48.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.558]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.558]             }
[17:43:48.558]             base::options(...future.oldOptions)
[17:43:48.558]             if (.Platform$OS.type == "windows") {
[17:43:48.558]                 old_names <- names(...future.oldEnvVars)
[17:43:48.558]                 envs <- base::Sys.getenv()
[17:43:48.558]                 names <- names(envs)
[17:43:48.558]                 common <- intersect(names, old_names)
[17:43:48.558]                 added <- setdiff(names, old_names)
[17:43:48.558]                 removed <- setdiff(old_names, names)
[17:43:48.558]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.558]                   envs[common]]
[17:43:48.558]                 NAMES <- toupper(changed)
[17:43:48.558]                 args <- list()
[17:43:48.558]                 for (kk in seq_along(NAMES)) {
[17:43:48.558]                   name <- changed[[kk]]
[17:43:48.558]                   NAME <- NAMES[[kk]]
[17:43:48.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.558]                     next
[17:43:48.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.558]                 }
[17:43:48.558]                 NAMES <- toupper(added)
[17:43:48.558]                 for (kk in seq_along(NAMES)) {
[17:43:48.558]                   name <- added[[kk]]
[17:43:48.558]                   NAME <- NAMES[[kk]]
[17:43:48.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.558]                     next
[17:43:48.558]                   args[[name]] <- ""
[17:43:48.558]                 }
[17:43:48.558]                 NAMES <- toupper(removed)
[17:43:48.558]                 for (kk in seq_along(NAMES)) {
[17:43:48.558]                   name <- removed[[kk]]
[17:43:48.558]                   NAME <- NAMES[[kk]]
[17:43:48.558]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.558]                     next
[17:43:48.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.558]                 }
[17:43:48.558]                 if (length(args) > 0) 
[17:43:48.558]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.558]             }
[17:43:48.558]             else {
[17:43:48.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.558]             }
[17:43:48.558]             {
[17:43:48.558]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.558]                   0L) {
[17:43:48.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.558]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.558]                   base::options(opts)
[17:43:48.558]                 }
[17:43:48.558]                 {
[17:43:48.558]                   {
[17:43:48.558]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.558]                     NULL
[17:43:48.558]                   }
[17:43:48.558]                   options(future.plan = NULL)
[17:43:48.558]                   if (is.na(NA_character_)) 
[17:43:48.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.558]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.558]                     .init = FALSE)
[17:43:48.558]                 }
[17:43:48.558]             }
[17:43:48.558]         }
[17:43:48.558]     })
[17:43:48.558]     if (TRUE) {
[17:43:48.558]         base::sink(type = "output", split = FALSE)
[17:43:48.558]         if (TRUE) {
[17:43:48.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.558]         }
[17:43:48.558]         else {
[17:43:48.558]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.558]         }
[17:43:48.558]         base::close(...future.stdout)
[17:43:48.558]         ...future.stdout <- NULL
[17:43:48.558]     }
[17:43:48.558]     ...future.result$conditions <- ...future.conditions
[17:43:48.558]     ...future.result$finished <- base::Sys.time()
[17:43:48.558]     ...future.result
[17:43:48.558] }
[17:43:48.560] assign_globals() ...
[17:43:48.560] List of 5
[17:43:48.560]  $ future.call.arguments    : list()
[17:43:48.560]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.560]  $ ...future.FUN            :function (x)  
[17:43:48.560]  $ ...future.elements_ii    :List of 1
[17:43:48.560]   ..$ : int 1
[17:43:48.560]  $ ...future.seeds_ii       : NULL
[17:43:48.560]  $ ...future.globals.maxSize: num Inf
[17:43:48.560]  - attr(*, "resolved")= logi FALSE
[17:43:48.560]  - attr(*, "total_size")= num NA
[17:43:48.560]  - attr(*, "where")=List of 5
[17:43:48.560]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.560]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.560]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.560]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.560]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.560]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.560]  - attr(*, "already-done")= logi TRUE
[17:43:48.565] - copied ‘future.call.arguments’ to environment
[17:43:48.565] - copied ‘...future.FUN’ to environment
[17:43:48.565] - copied ‘...future.elements_ii’ to environment
[17:43:48.565] - copied ‘...future.seeds_ii’ to environment
[17:43:48.565] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.565] assign_globals() ... done
[17:43:48.565] requestCore(): workers = 2
[17:43:48.567] MulticoreFuture started
[17:43:48.568] - Launch lazy future ... done
[17:43:48.568] run() for ‘MulticoreFuture’ ... done
[17:43:48.568] Created future:
[17:43:48.568] plan(): Setting new future strategy stack:
[17:43:48.569] List of future strategies:
[17:43:48.569] 1. sequential:
[17:43:48.569]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.569]    - tweaked: FALSE
[17:43:48.569]    - call: NULL
[17:43:48.570] plan(): nbrOfWorkers() = 1
[17:43:48.572] plan(): Setting new future strategy stack:
[17:43:48.572] List of future strategies:
[17:43:48.572] 1. multicore:
[17:43:48.572]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.572]    - tweaked: FALSE
[17:43:48.572]    - call: plan(strategy)
[17:43:48.577] plan(): nbrOfWorkers() = 2
[17:43:48.568] MulticoreFuture:
[17:43:48.568] Label: ‘future_apply-1’
[17:43:48.568] Expression:
[17:43:48.568] {
[17:43:48.568]     do.call(function(...) {
[17:43:48.568]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.568]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.568]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.568]             on.exit(options(oopts), add = TRUE)
[17:43:48.568]         }
[17:43:48.568]         {
[17:43:48.568]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.568]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.568]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.568]             })
[17:43:48.568]         }
[17:43:48.568]     }, args = future.call.arguments)
[17:43:48.568] }
[17:43:48.568] Lazy evaluation: FALSE
[17:43:48.568] Asynchronous evaluation: TRUE
[17:43:48.568] Local evaluation: TRUE
[17:43:48.568] Environment: R_GlobalEnv
[17:43:48.568] Capture standard output: TRUE
[17:43:48.568] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:48.568] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.568] Packages: <none>
[17:43:48.568] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:48.568] Resolved: TRUE
[17:43:48.568] Value: <not collected>
[17:43:48.568] Conditions captured: <none>
[17:43:48.568] Early signaling: FALSE
[17:43:48.568] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.568] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.578] Chunk #1 of 2 ... DONE
[17:43:48.578] Chunk #2 of 2 ...
[17:43:48.579]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.579]  - seeds: <none>
[17:43:48.579]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.579] getGlobalsAndPackages() ...
[17:43:48.579] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.579] Resolving globals: FALSE
[17:43:48.580] Tweak future expression to call with '...' arguments ...
[17:43:48.580] {
[17:43:48.580]     do.call(function(...) {
[17:43:48.580]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.580]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.580]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.580]             on.exit(options(oopts), add = TRUE)
[17:43:48.580]         }
[17:43:48.580]         {
[17:43:48.580]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.580]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.580]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.580]             })
[17:43:48.580]         }
[17:43:48.580]     }, args = future.call.arguments)
[17:43:48.580] }
[17:43:48.580] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.581] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.581] 
[17:43:48.581] getGlobalsAndPackages() ... DONE
[17:43:48.582] run() for ‘Future’ ...
[17:43:48.582] - state: ‘created’
[17:43:48.582] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.587] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.587] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.587]   - Field: ‘label’
[17:43:48.587]   - Field: ‘local’
[17:43:48.587]   - Field: ‘owner’
[17:43:48.587]   - Field: ‘envir’
[17:43:48.588]   - Field: ‘workers’
[17:43:48.588]   - Field: ‘packages’
[17:43:48.588]   - Field: ‘gc’
[17:43:48.588]   - Field: ‘job’
[17:43:48.588]   - Field: ‘conditions’
[17:43:48.588]   - Field: ‘expr’
[17:43:48.588]   - Field: ‘uuid’
[17:43:48.589]   - Field: ‘seed’
[17:43:48.589]   - Field: ‘version’
[17:43:48.589]   - Field: ‘result’
[17:43:48.589]   - Field: ‘asynchronous’
[17:43:48.589]   - Field: ‘calls’
[17:43:48.589]   - Field: ‘globals’
[17:43:48.589]   - Field: ‘stdout’
[17:43:48.590]   - Field: ‘earlySignal’
[17:43:48.590]   - Field: ‘lazy’
[17:43:48.590]   - Field: ‘state’
[17:43:48.590] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.590] - Launch lazy future ...
[17:43:48.590] Packages needed by the future expression (n = 0): <none>
[17:43:48.591] Packages needed by future strategies (n = 0): <none>
[17:43:48.591] {
[17:43:48.591]     {
[17:43:48.591]         {
[17:43:48.591]             ...future.startTime <- base::Sys.time()
[17:43:48.591]             {
[17:43:48.591]                 {
[17:43:48.591]                   {
[17:43:48.591]                     {
[17:43:48.591]                       base::local({
[17:43:48.591]                         has_future <- base::requireNamespace("future", 
[17:43:48.591]                           quietly = TRUE)
[17:43:48.591]                         if (has_future) {
[17:43:48.591]                           ns <- base::getNamespace("future")
[17:43:48.591]                           version <- ns[[".package"]][["version"]]
[17:43:48.591]                           if (is.null(version)) 
[17:43:48.591]                             version <- utils::packageVersion("future")
[17:43:48.591]                         }
[17:43:48.591]                         else {
[17:43:48.591]                           version <- NULL
[17:43:48.591]                         }
[17:43:48.591]                         if (!has_future || version < "1.8.0") {
[17:43:48.591]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.591]                             "", base::R.version$version.string), 
[17:43:48.591]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.591]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.591]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.591]                               "release", "version")], collapse = " "), 
[17:43:48.591]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.591]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.591]                             info)
[17:43:48.591]                           info <- base::paste(info, collapse = "; ")
[17:43:48.591]                           if (!has_future) {
[17:43:48.591]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.591]                               info)
[17:43:48.591]                           }
[17:43:48.591]                           else {
[17:43:48.591]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.591]                               info, version)
[17:43:48.591]                           }
[17:43:48.591]                           base::stop(msg)
[17:43:48.591]                         }
[17:43:48.591]                       })
[17:43:48.591]                     }
[17:43:48.591]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.591]                     base::options(mc.cores = 1L)
[17:43:48.591]                   }
[17:43:48.591]                   ...future.strategy.old <- future::plan("list")
[17:43:48.591]                   options(future.plan = NULL)
[17:43:48.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.591]                 }
[17:43:48.591]                 ...future.workdir <- getwd()
[17:43:48.591]             }
[17:43:48.591]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.591]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.591]         }
[17:43:48.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.591]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.591]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.591]             base::names(...future.oldOptions))
[17:43:48.591]     }
[17:43:48.591]     if (FALSE) {
[17:43:48.591]     }
[17:43:48.591]     else {
[17:43:48.591]         if (TRUE) {
[17:43:48.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.591]                 open = "w")
[17:43:48.591]         }
[17:43:48.591]         else {
[17:43:48.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.591]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.591]         }
[17:43:48.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.591]             base::sink(type = "output", split = FALSE)
[17:43:48.591]             base::close(...future.stdout)
[17:43:48.591]         }, add = TRUE)
[17:43:48.591]     }
[17:43:48.591]     ...future.frame <- base::sys.nframe()
[17:43:48.591]     ...future.conditions <- base::list()
[17:43:48.591]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.591]     if (FALSE) {
[17:43:48.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.591]     }
[17:43:48.591]     ...future.result <- base::tryCatch({
[17:43:48.591]         base::withCallingHandlers({
[17:43:48.591]             ...future.value <- base::withVisible(base::local({
[17:43:48.591]                 withCallingHandlers({
[17:43:48.591]                   {
[17:43:48.591]                     do.call(function(...) {
[17:43:48.591]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.591]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.591]                         ...future.globals.maxSize)) {
[17:43:48.591]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.591]                         on.exit(options(oopts), add = TRUE)
[17:43:48.591]                       }
[17:43:48.591]                       {
[17:43:48.591]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.591]                           FUN = function(jj) {
[17:43:48.591]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.591]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.591]                           })
[17:43:48.591]                       }
[17:43:48.591]                     }, args = future.call.arguments)
[17:43:48.591]                   }
[17:43:48.591]                 }, immediateCondition = function(cond) {
[17:43:48.591]                   save_rds <- function (object, pathname, ...) 
[17:43:48.591]                   {
[17:43:48.591]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.591]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.591]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.591]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.591]                         fi_tmp[["mtime"]])
[17:43:48.591]                     }
[17:43:48.591]                     tryCatch({
[17:43:48.591]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.591]                     }, error = function(ex) {
[17:43:48.591]                       msg <- conditionMessage(ex)
[17:43:48.591]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.591]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.591]                         fi_tmp[["mtime"]], msg)
[17:43:48.591]                       ex$message <- msg
[17:43:48.591]                       stop(ex)
[17:43:48.591]                     })
[17:43:48.591]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.591]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.591]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.591]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.591]                       fi <- file.info(pathname)
[17:43:48.591]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.591]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.591]                         fi[["size"]], fi[["mtime"]])
[17:43:48.591]                       stop(msg)
[17:43:48.591]                     }
[17:43:48.591]                     invisible(pathname)
[17:43:48.591]                   }
[17:43:48.591]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.591]                     rootPath = tempdir()) 
[17:43:48.591]                   {
[17:43:48.591]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.591]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.591]                       tmpdir = path, fileext = ".rds")
[17:43:48.591]                     save_rds(obj, file)
[17:43:48.591]                   }
[17:43:48.591]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.591]                   {
[17:43:48.591]                     inherits <- base::inherits
[17:43:48.591]                     invokeRestart <- base::invokeRestart
[17:43:48.591]                     is.null <- base::is.null
[17:43:48.591]                     muffled <- FALSE
[17:43:48.591]                     if (inherits(cond, "message")) {
[17:43:48.591]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.591]                       if (muffled) 
[17:43:48.591]                         invokeRestart("muffleMessage")
[17:43:48.591]                     }
[17:43:48.591]                     else if (inherits(cond, "warning")) {
[17:43:48.591]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.591]                       if (muffled) 
[17:43:48.591]                         invokeRestart("muffleWarning")
[17:43:48.591]                     }
[17:43:48.591]                     else if (inherits(cond, "condition")) {
[17:43:48.591]                       if (!is.null(pattern)) {
[17:43:48.591]                         computeRestarts <- base::computeRestarts
[17:43:48.591]                         grepl <- base::grepl
[17:43:48.591]                         restarts <- computeRestarts(cond)
[17:43:48.591]                         for (restart in restarts) {
[17:43:48.591]                           name <- restart$name
[17:43:48.591]                           if (is.null(name)) 
[17:43:48.591]                             next
[17:43:48.591]                           if (!grepl(pattern, name)) 
[17:43:48.591]                             next
[17:43:48.591]                           invokeRestart(restart)
[17:43:48.591]                           muffled <- TRUE
[17:43:48.591]                           break
[17:43:48.591]                         }
[17:43:48.591]                       }
[17:43:48.591]                     }
[17:43:48.591]                     invisible(muffled)
[17:43:48.591]                   }
[17:43:48.591]                   muffleCondition(cond)
[17:43:48.591]                 })
[17:43:48.591]             }))
[17:43:48.591]             future::FutureResult(value = ...future.value$value, 
[17:43:48.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.591]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.591]                     ...future.globalenv.names))
[17:43:48.591]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.591]         }, condition = base::local({
[17:43:48.591]             c <- base::c
[17:43:48.591]             inherits <- base::inherits
[17:43:48.591]             invokeRestart <- base::invokeRestart
[17:43:48.591]             length <- base::length
[17:43:48.591]             list <- base::list
[17:43:48.591]             seq.int <- base::seq.int
[17:43:48.591]             signalCondition <- base::signalCondition
[17:43:48.591]             sys.calls <- base::sys.calls
[17:43:48.591]             `[[` <- base::`[[`
[17:43:48.591]             `+` <- base::`+`
[17:43:48.591]             `<<-` <- base::`<<-`
[17:43:48.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.591]                   3L)]
[17:43:48.591]             }
[17:43:48.591]             function(cond) {
[17:43:48.591]                 is_error <- inherits(cond, "error")
[17:43:48.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.591]                   NULL)
[17:43:48.591]                 if (is_error) {
[17:43:48.591]                   sessionInformation <- function() {
[17:43:48.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.591]                       search = base::search(), system = base::Sys.info())
[17:43:48.591]                   }
[17:43:48.591]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.591]                     cond$call), session = sessionInformation(), 
[17:43:48.591]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.591]                   signalCondition(cond)
[17:43:48.591]                 }
[17:43:48.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.591]                 "immediateCondition"))) {
[17:43:48.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.591]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.591]                   if (TRUE && !signal) {
[17:43:48.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.591]                     {
[17:43:48.591]                       inherits <- base::inherits
[17:43:48.591]                       invokeRestart <- base::invokeRestart
[17:43:48.591]                       is.null <- base::is.null
[17:43:48.591]                       muffled <- FALSE
[17:43:48.591]                       if (inherits(cond, "message")) {
[17:43:48.591]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.591]                         if (muffled) 
[17:43:48.591]                           invokeRestart("muffleMessage")
[17:43:48.591]                       }
[17:43:48.591]                       else if (inherits(cond, "warning")) {
[17:43:48.591]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.591]                         if (muffled) 
[17:43:48.591]                           invokeRestart("muffleWarning")
[17:43:48.591]                       }
[17:43:48.591]                       else if (inherits(cond, "condition")) {
[17:43:48.591]                         if (!is.null(pattern)) {
[17:43:48.591]                           computeRestarts <- base::computeRestarts
[17:43:48.591]                           grepl <- base::grepl
[17:43:48.591]                           restarts <- computeRestarts(cond)
[17:43:48.591]                           for (restart in restarts) {
[17:43:48.591]                             name <- restart$name
[17:43:48.591]                             if (is.null(name)) 
[17:43:48.591]                               next
[17:43:48.591]                             if (!grepl(pattern, name)) 
[17:43:48.591]                               next
[17:43:48.591]                             invokeRestart(restart)
[17:43:48.591]                             muffled <- TRUE
[17:43:48.591]                             break
[17:43:48.591]                           }
[17:43:48.591]                         }
[17:43:48.591]                       }
[17:43:48.591]                       invisible(muffled)
[17:43:48.591]                     }
[17:43:48.591]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.591]                   }
[17:43:48.591]                 }
[17:43:48.591]                 else {
[17:43:48.591]                   if (TRUE) {
[17:43:48.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.591]                     {
[17:43:48.591]                       inherits <- base::inherits
[17:43:48.591]                       invokeRestart <- base::invokeRestart
[17:43:48.591]                       is.null <- base::is.null
[17:43:48.591]                       muffled <- FALSE
[17:43:48.591]                       if (inherits(cond, "message")) {
[17:43:48.591]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.591]                         if (muffled) 
[17:43:48.591]                           invokeRestart("muffleMessage")
[17:43:48.591]                       }
[17:43:48.591]                       else if (inherits(cond, "warning")) {
[17:43:48.591]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.591]                         if (muffled) 
[17:43:48.591]                           invokeRestart("muffleWarning")
[17:43:48.591]                       }
[17:43:48.591]                       else if (inherits(cond, "condition")) {
[17:43:48.591]                         if (!is.null(pattern)) {
[17:43:48.591]                           computeRestarts <- base::computeRestarts
[17:43:48.591]                           grepl <- base::grepl
[17:43:48.591]                           restarts <- computeRestarts(cond)
[17:43:48.591]                           for (restart in restarts) {
[17:43:48.591]                             name <- restart$name
[17:43:48.591]                             if (is.null(name)) 
[17:43:48.591]                               next
[17:43:48.591]                             if (!grepl(pattern, name)) 
[17:43:48.591]                               next
[17:43:48.591]                             invokeRestart(restart)
[17:43:48.591]                             muffled <- TRUE
[17:43:48.591]                             break
[17:43:48.591]                           }
[17:43:48.591]                         }
[17:43:48.591]                       }
[17:43:48.591]                       invisible(muffled)
[17:43:48.591]                     }
[17:43:48.591]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.591]                   }
[17:43:48.591]                 }
[17:43:48.591]             }
[17:43:48.591]         }))
[17:43:48.591]     }, error = function(ex) {
[17:43:48.591]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.591]                 ...future.rng), started = ...future.startTime, 
[17:43:48.591]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.591]             version = "1.8"), class = "FutureResult")
[17:43:48.591]     }, finally = {
[17:43:48.591]         if (!identical(...future.workdir, getwd())) 
[17:43:48.591]             setwd(...future.workdir)
[17:43:48.591]         {
[17:43:48.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.591]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.591]             }
[17:43:48.591]             base::options(...future.oldOptions)
[17:43:48.591]             if (.Platform$OS.type == "windows") {
[17:43:48.591]                 old_names <- names(...future.oldEnvVars)
[17:43:48.591]                 envs <- base::Sys.getenv()
[17:43:48.591]                 names <- names(envs)
[17:43:48.591]                 common <- intersect(names, old_names)
[17:43:48.591]                 added <- setdiff(names, old_names)
[17:43:48.591]                 removed <- setdiff(old_names, names)
[17:43:48.591]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.591]                   envs[common]]
[17:43:48.591]                 NAMES <- toupper(changed)
[17:43:48.591]                 args <- list()
[17:43:48.591]                 for (kk in seq_along(NAMES)) {
[17:43:48.591]                   name <- changed[[kk]]
[17:43:48.591]                   NAME <- NAMES[[kk]]
[17:43:48.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.591]                     next
[17:43:48.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.591]                 }
[17:43:48.591]                 NAMES <- toupper(added)
[17:43:48.591]                 for (kk in seq_along(NAMES)) {
[17:43:48.591]                   name <- added[[kk]]
[17:43:48.591]                   NAME <- NAMES[[kk]]
[17:43:48.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.591]                     next
[17:43:48.591]                   args[[name]] <- ""
[17:43:48.591]                 }
[17:43:48.591]                 NAMES <- toupper(removed)
[17:43:48.591]                 for (kk in seq_along(NAMES)) {
[17:43:48.591]                   name <- removed[[kk]]
[17:43:48.591]                   NAME <- NAMES[[kk]]
[17:43:48.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.591]                     next
[17:43:48.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.591]                 }
[17:43:48.591]                 if (length(args) > 0) 
[17:43:48.591]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.591]             }
[17:43:48.591]             else {
[17:43:48.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.591]             }
[17:43:48.591]             {
[17:43:48.591]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.591]                   0L) {
[17:43:48.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.591]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.591]                   base::options(opts)
[17:43:48.591]                 }
[17:43:48.591]                 {
[17:43:48.591]                   {
[17:43:48.591]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.591]                     NULL
[17:43:48.591]                   }
[17:43:48.591]                   options(future.plan = NULL)
[17:43:48.591]                   if (is.na(NA_character_)) 
[17:43:48.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.591]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.591]                     .init = FALSE)
[17:43:48.591]                 }
[17:43:48.591]             }
[17:43:48.591]         }
[17:43:48.591]     })
[17:43:48.591]     if (TRUE) {
[17:43:48.591]         base::sink(type = "output", split = FALSE)
[17:43:48.591]         if (TRUE) {
[17:43:48.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.591]         }
[17:43:48.591]         else {
[17:43:48.591]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.591]         }
[17:43:48.591]         base::close(...future.stdout)
[17:43:48.591]         ...future.stdout <- NULL
[17:43:48.591]     }
[17:43:48.591]     ...future.result$conditions <- ...future.conditions
[17:43:48.591]     ...future.result$finished <- base::Sys.time()
[17:43:48.591]     ...future.result
[17:43:48.591] }
[17:43:48.595] assign_globals() ...
[17:43:48.595] List of 5
[17:43:48.595]  $ future.call.arguments    : list()
[17:43:48.595]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.595]  $ ...future.FUN            :function (x)  
[17:43:48.595]  $ ...future.elements_ii    :List of 1
[17:43:48.595]   ..$ : int 2
[17:43:48.595]  $ ...future.seeds_ii       : NULL
[17:43:48.595]  $ ...future.globals.maxSize: num Inf
[17:43:48.595]  - attr(*, "resolved")= logi FALSE
[17:43:48.595]  - attr(*, "total_size")= num NA
[17:43:48.595]  - attr(*, "where")=List of 5
[17:43:48.595]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.595]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.595]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.595]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.595]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.595]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.595]  - attr(*, "already-done")= logi TRUE
[17:43:48.608] - copied ‘future.call.arguments’ to environment
[17:43:48.609] - copied ‘...future.FUN’ to environment
[17:43:48.609] - copied ‘...future.elements_ii’ to environment
[17:43:48.609] - copied ‘...future.seeds_ii’ to environment
[17:43:48.609] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.609] assign_globals() ... done
[17:43:48.609] requestCore(): workers = 2
[17:43:48.612] MulticoreFuture started
[17:43:48.612] - Launch lazy future ... done
[17:43:48.612] run() for ‘MulticoreFuture’ ... done
[17:43:48.613] Created future:
[17:43:48.613] plan(): Setting new future strategy stack:
[17:43:48.613] List of future strategies:
[17:43:48.613] 1. sequential:
[17:43:48.613]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.613]    - tweaked: FALSE
[17:43:48.613]    - call: NULL
[17:43:48.615] plan(): nbrOfWorkers() = 1
[17:43:48.617] plan(): Setting new future strategy stack:
[17:43:48.617] List of future strategies:
[17:43:48.617] 1. multicore:
[17:43:48.617]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.617]    - tweaked: FALSE
[17:43:48.617]    - call: plan(strategy)
[17:43:48.622] plan(): nbrOfWorkers() = 2
[17:43:48.613] MulticoreFuture:
[17:43:48.613] Label: ‘future_apply-2’
[17:43:48.613] Expression:
[17:43:48.613] {
[17:43:48.613]     do.call(function(...) {
[17:43:48.613]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.613]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.613]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.613]             on.exit(options(oopts), add = TRUE)
[17:43:48.613]         }
[17:43:48.613]         {
[17:43:48.613]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.613]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.613]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.613]             })
[17:43:48.613]         }
[17:43:48.613]     }, args = future.call.arguments)
[17:43:48.613] }
[17:43:48.613] Lazy evaluation: FALSE
[17:43:48.613] Asynchronous evaluation: TRUE
[17:43:48.613] Local evaluation: TRUE
[17:43:48.613] Environment: R_GlobalEnv
[17:43:48.613] Capture standard output: TRUE
[17:43:48.613] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:48.613] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.613] Packages: <none>
[17:43:48.613] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:48.613] Resolved: TRUE
[17:43:48.613] Value: <not collected>
[17:43:48.613] Conditions captured: <none>
[17:43:48.613] Early signaling: FALSE
[17:43:48.613] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.613] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.623] Chunk #2 of 2 ... DONE
[17:43:48.623] Launching 2 futures (chunks) ... DONE
[17:43:48.624] Resolving 2 futures (chunks) ...
[17:43:48.624] resolve() on list ...
[17:43:48.624]  recursive: 0
[17:43:48.624]  length: 2
[17:43:48.624] 
[17:43:48.625] Future #1
[17:43:48.625] result() for MulticoreFuture ...
[17:43:48.626] result() for MulticoreFuture ...
[17:43:48.626] result() for MulticoreFuture ... done
[17:43:48.626] result() for MulticoreFuture ... done
[17:43:48.626] result() for MulticoreFuture ...
[17:43:48.626] result() for MulticoreFuture ... done
[17:43:48.627] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:48.627] - nx: 2
[17:43:48.627] - relay: TRUE
[17:43:48.627] - stdout: TRUE
[17:43:48.627] - signal: TRUE
[17:43:48.627] - resignal: FALSE
[17:43:48.627] - force: TRUE
[17:43:48.628] - relayed: [n=2] FALSE, FALSE
[17:43:48.628] - queued futures: [n=2] FALSE, FALSE
[17:43:48.628]  - until=1
[17:43:48.628]  - relaying element #1
[17:43:48.628] result() for MulticoreFuture ...
[17:43:48.628] result() for MulticoreFuture ... done
[17:43:48.628] result() for MulticoreFuture ...
[17:43:48.629] result() for MulticoreFuture ... done
[17:43:48.629] result() for MulticoreFuture ...
[17:43:48.629] result() for MulticoreFuture ... done
[17:43:48.629] result() for MulticoreFuture ...
[17:43:48.629] result() for MulticoreFuture ... done
[17:43:48.629] - relayed: [n=2] TRUE, FALSE
[17:43:48.629] - queued futures: [n=2] TRUE, FALSE
[17:43:48.630] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:48.630]  length: 1 (resolved future 1)
[17:43:48.630] Future #2
[17:43:48.630] result() for MulticoreFuture ...
[17:43:48.631] result() for MulticoreFuture ...
[17:43:48.631] result() for MulticoreFuture ... done
[17:43:48.631] result() for MulticoreFuture ... done
[17:43:48.631] result() for MulticoreFuture ...
[17:43:48.632] result() for MulticoreFuture ... done
[17:43:48.632] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:48.632] - nx: 2
[17:43:48.632] - relay: TRUE
[17:43:48.632] - stdout: TRUE
[17:43:48.632] - signal: TRUE
[17:43:48.632] - resignal: FALSE
[17:43:48.632] - force: TRUE
[17:43:48.633] - relayed: [n=2] TRUE, FALSE
[17:43:48.633] - queued futures: [n=2] TRUE, FALSE
[17:43:48.633]  - until=2
[17:43:48.633]  - relaying element #2
[17:43:48.633] result() for MulticoreFuture ...
[17:43:48.633] result() for MulticoreFuture ... done
[17:43:48.633] result() for MulticoreFuture ...
[17:43:48.633] result() for MulticoreFuture ... done
[17:43:48.634] result() for MulticoreFuture ...
[17:43:48.634] result() for MulticoreFuture ... done
[17:43:48.634] result() for MulticoreFuture ...
[17:43:48.634] result() for MulticoreFuture ... done
[17:43:48.634] - relayed: [n=2] TRUE, TRUE
[17:43:48.634] - queued futures: [n=2] TRUE, TRUE
[17:43:48.634] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:48.634]  length: 0 (resolved future 2)
[17:43:48.635] Relaying remaining futures
[17:43:48.635] signalConditionsASAP(NULL, pos=0) ...
[17:43:48.635] - nx: 2
[17:43:48.635] - relay: TRUE
[17:43:48.635] - stdout: TRUE
[17:43:48.635] - signal: TRUE
[17:43:48.635] - resignal: FALSE
[17:43:48.635] - force: TRUE
[17:43:48.635] - relayed: [n=2] TRUE, TRUE
[17:43:48.636] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:48.636] - relayed: [n=2] TRUE, TRUE
[17:43:48.636] - queued futures: [n=2] TRUE, TRUE
[17:43:48.636] signalConditionsASAP(NULL, pos=0) ... done
[17:43:48.636] resolve() on list ... DONE
[17:43:48.636] result() for MulticoreFuture ...
[17:43:48.636] result() for MulticoreFuture ... done
[17:43:48.636] result() for MulticoreFuture ...
[17:43:48.637] result() for MulticoreFuture ... done
[17:43:48.637] result() for MulticoreFuture ...
[17:43:48.637] result() for MulticoreFuture ... done
[17:43:48.637] result() for MulticoreFuture ...
[17:43:48.637] result() for MulticoreFuture ... done
[17:43:48.637]  - Number of value chunks collected: 2
[17:43:48.637] Resolving 2 futures (chunks) ... DONE
[17:43:48.637] Reducing values from 2 chunks ...
[17:43:48.637]  - Number of values collected after concatenation: 2
[17:43:48.638]  - Number of values expected: 2
[17:43:48.638] Reducing values from 2 chunks ... DONE
[17:43:48.638] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[17:43:48.638] getGlobalsAndPackagesXApply() ...
[17:43:48.638]  - future.globals: TRUE
[17:43:48.638] getGlobalsAndPackages() ...
[17:43:48.639] Searching for globals...
[17:43:48.640] - globals found: [1] ‘FUN’
[17:43:48.640] Searching for globals ... DONE
[17:43:48.640] Resolving globals: FALSE
[17:43:48.641] The total size of the 1 globals is 848 bytes (848 bytes)
[17:43:48.641] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:43:48.641] - globals: [1] ‘FUN’
[17:43:48.641] 
[17:43:48.641] getGlobalsAndPackages() ... DONE
[17:43:48.642]  - globals found/used: [n=1] ‘FUN’
[17:43:48.642]  - needed namespaces: [n=0] 
[17:43:48.642] Finding globals ... DONE
[17:43:48.642]  - use_args: TRUE
[17:43:48.642]  - Getting '...' globals ...
[17:43:48.642] resolve() on list ...
[17:43:48.642]  recursive: 0
[17:43:48.643]  length: 1
[17:43:48.643]  elements: ‘...’
[17:43:48.643]  length: 0 (resolved future 1)
[17:43:48.643] resolve() on list ... DONE
[17:43:48.643]    - '...' content: [n=0] 
[17:43:48.643] List of 1
[17:43:48.643]  $ ...: list()
[17:43:48.643]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.643]  - attr(*, "where")=List of 1
[17:43:48.643]   ..$ ...:<environment: 0x55dfd4d47298> 
[17:43:48.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.643]  - attr(*, "resolved")= logi TRUE
[17:43:48.643]  - attr(*, "total_size")= num NA
[17:43:48.649]  - Getting '...' globals ... DONE
[17:43:48.649] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:48.650] List of 2
[17:43:48.650]  $ ...future.FUN:function (x)  
[17:43:48.650]  $ ...          : list()
[17:43:48.650]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.650]  - attr(*, "where")=List of 2
[17:43:48.650]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:48.650]   ..$ ...          :<environment: 0x55dfd4d47298> 
[17:43:48.650]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.650]  - attr(*, "resolved")= logi FALSE
[17:43:48.650]  - attr(*, "total_size")= num 848
[17:43:48.653] Packages to be attached in all futures: [n=0] 
[17:43:48.653] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.657] future_lapply() ...
[17:43:48.660] Number of chunks: 2
[17:43:48.661] getGlobalsAndPackagesXApply() ...
[17:43:48.661]  - future.globals: <name-value list> with names ‘list()’
[17:43:48.661]  - use_args: TRUE
[17:43:48.661] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:48.661] List of 2
[17:43:48.661]  $ ...          : list()
[17:43:48.661]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.661]  $ ...future.FUN:function (x)  
[17:43:48.661]  - attr(*, "where")=List of 2
[17:43:48.661]   ..$ ...          :<environment: 0x55dfd4d47298> 
[17:43:48.661]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:48.661]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.661]  - attr(*, "resolved")= logi FALSE
[17:43:48.661]  - attr(*, "total_size")= num NA
[17:43:48.664] Packages to be attached in all futures: [n=0] 
[17:43:48.664] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.665] Number of futures (= number of chunks): 2
[17:43:48.665] Launching 2 futures (chunks) ...
[17:43:48.665] Chunk #1 of 2 ...
[17:43:48.665]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.665]  - seeds: <none>
[17:43:48.665]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.665] getGlobalsAndPackages() ...
[17:43:48.665] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.666] Resolving globals: FALSE
[17:43:48.666] Tweak future expression to call with '...' arguments ...
[17:43:48.666] {
[17:43:48.666]     do.call(function(...) {
[17:43:48.666]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.666]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.666]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.666]             on.exit(options(oopts), add = TRUE)
[17:43:48.666]         }
[17:43:48.666]         {
[17:43:48.666]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.666]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.666]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.666]             })
[17:43:48.666]         }
[17:43:48.666]     }, args = future.call.arguments)
[17:43:48.666] }
[17:43:48.666] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.666] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.667] 
[17:43:48.667] getGlobalsAndPackages() ... DONE
[17:43:48.667] run() for ‘Future’ ...
[17:43:48.667] - state: ‘created’
[17:43:48.667] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.671] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.671]   - Field: ‘label’
[17:43:48.671]   - Field: ‘local’
[17:43:48.671]   - Field: ‘owner’
[17:43:48.671]   - Field: ‘envir’
[17:43:48.671]   - Field: ‘workers’
[17:43:48.671]   - Field: ‘packages’
[17:43:48.672]   - Field: ‘gc’
[17:43:48.672]   - Field: ‘job’
[17:43:48.672]   - Field: ‘conditions’
[17:43:48.672]   - Field: ‘expr’
[17:43:48.672]   - Field: ‘uuid’
[17:43:48.672]   - Field: ‘seed’
[17:43:48.672]   - Field: ‘version’
[17:43:48.672]   - Field: ‘result’
[17:43:48.672]   - Field: ‘asynchronous’
[17:43:48.672]   - Field: ‘calls’
[17:43:48.672]   - Field: ‘globals’
[17:43:48.673]   - Field: ‘stdout’
[17:43:48.673]   - Field: ‘earlySignal’
[17:43:48.673]   - Field: ‘lazy’
[17:43:48.673]   - Field: ‘state’
[17:43:48.673] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.673] - Launch lazy future ...
[17:43:48.673] Packages needed by the future expression (n = 0): <none>
[17:43:48.673] Packages needed by future strategies (n = 0): <none>
[17:43:48.674] {
[17:43:48.674]     {
[17:43:48.674]         {
[17:43:48.674]             ...future.startTime <- base::Sys.time()
[17:43:48.674]             {
[17:43:48.674]                 {
[17:43:48.674]                   {
[17:43:48.674]                     {
[17:43:48.674]                       base::local({
[17:43:48.674]                         has_future <- base::requireNamespace("future", 
[17:43:48.674]                           quietly = TRUE)
[17:43:48.674]                         if (has_future) {
[17:43:48.674]                           ns <- base::getNamespace("future")
[17:43:48.674]                           version <- ns[[".package"]][["version"]]
[17:43:48.674]                           if (is.null(version)) 
[17:43:48.674]                             version <- utils::packageVersion("future")
[17:43:48.674]                         }
[17:43:48.674]                         else {
[17:43:48.674]                           version <- NULL
[17:43:48.674]                         }
[17:43:48.674]                         if (!has_future || version < "1.8.0") {
[17:43:48.674]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.674]                             "", base::R.version$version.string), 
[17:43:48.674]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.674]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.674]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.674]                               "release", "version")], collapse = " "), 
[17:43:48.674]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.674]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.674]                             info)
[17:43:48.674]                           info <- base::paste(info, collapse = "; ")
[17:43:48.674]                           if (!has_future) {
[17:43:48.674]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.674]                               info)
[17:43:48.674]                           }
[17:43:48.674]                           else {
[17:43:48.674]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.674]                               info, version)
[17:43:48.674]                           }
[17:43:48.674]                           base::stop(msg)
[17:43:48.674]                         }
[17:43:48.674]                       })
[17:43:48.674]                     }
[17:43:48.674]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.674]                     base::options(mc.cores = 1L)
[17:43:48.674]                   }
[17:43:48.674]                   ...future.strategy.old <- future::plan("list")
[17:43:48.674]                   options(future.plan = NULL)
[17:43:48.674]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.674]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.674]                 }
[17:43:48.674]                 ...future.workdir <- getwd()
[17:43:48.674]             }
[17:43:48.674]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.674]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.674]         }
[17:43:48.674]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.674]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.674]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.674]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.674]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.674]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.674]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.674]             base::names(...future.oldOptions))
[17:43:48.674]     }
[17:43:48.674]     if (FALSE) {
[17:43:48.674]     }
[17:43:48.674]     else {
[17:43:48.674]         if (TRUE) {
[17:43:48.674]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.674]                 open = "w")
[17:43:48.674]         }
[17:43:48.674]         else {
[17:43:48.674]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.674]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.674]         }
[17:43:48.674]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.674]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.674]             base::sink(type = "output", split = FALSE)
[17:43:48.674]             base::close(...future.stdout)
[17:43:48.674]         }, add = TRUE)
[17:43:48.674]     }
[17:43:48.674]     ...future.frame <- base::sys.nframe()
[17:43:48.674]     ...future.conditions <- base::list()
[17:43:48.674]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.674]     if (FALSE) {
[17:43:48.674]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.674]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.674]     }
[17:43:48.674]     ...future.result <- base::tryCatch({
[17:43:48.674]         base::withCallingHandlers({
[17:43:48.674]             ...future.value <- base::withVisible(base::local({
[17:43:48.674]                 withCallingHandlers({
[17:43:48.674]                   {
[17:43:48.674]                     do.call(function(...) {
[17:43:48.674]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.674]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.674]                         ...future.globals.maxSize)) {
[17:43:48.674]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.674]                         on.exit(options(oopts), add = TRUE)
[17:43:48.674]                       }
[17:43:48.674]                       {
[17:43:48.674]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.674]                           FUN = function(jj) {
[17:43:48.674]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.674]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.674]                           })
[17:43:48.674]                       }
[17:43:48.674]                     }, args = future.call.arguments)
[17:43:48.674]                   }
[17:43:48.674]                 }, immediateCondition = function(cond) {
[17:43:48.674]                   save_rds <- function (object, pathname, ...) 
[17:43:48.674]                   {
[17:43:48.674]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.674]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.674]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.674]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.674]                         fi_tmp[["mtime"]])
[17:43:48.674]                     }
[17:43:48.674]                     tryCatch({
[17:43:48.674]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.674]                     }, error = function(ex) {
[17:43:48.674]                       msg <- conditionMessage(ex)
[17:43:48.674]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.674]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.674]                         fi_tmp[["mtime"]], msg)
[17:43:48.674]                       ex$message <- msg
[17:43:48.674]                       stop(ex)
[17:43:48.674]                     })
[17:43:48.674]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.674]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.674]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.674]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.674]                       fi <- file.info(pathname)
[17:43:48.674]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.674]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.674]                         fi[["size"]], fi[["mtime"]])
[17:43:48.674]                       stop(msg)
[17:43:48.674]                     }
[17:43:48.674]                     invisible(pathname)
[17:43:48.674]                   }
[17:43:48.674]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.674]                     rootPath = tempdir()) 
[17:43:48.674]                   {
[17:43:48.674]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.674]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.674]                       tmpdir = path, fileext = ".rds")
[17:43:48.674]                     save_rds(obj, file)
[17:43:48.674]                   }
[17:43:48.674]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.674]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.674]                   {
[17:43:48.674]                     inherits <- base::inherits
[17:43:48.674]                     invokeRestart <- base::invokeRestart
[17:43:48.674]                     is.null <- base::is.null
[17:43:48.674]                     muffled <- FALSE
[17:43:48.674]                     if (inherits(cond, "message")) {
[17:43:48.674]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.674]                       if (muffled) 
[17:43:48.674]                         invokeRestart("muffleMessage")
[17:43:48.674]                     }
[17:43:48.674]                     else if (inherits(cond, "warning")) {
[17:43:48.674]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.674]                       if (muffled) 
[17:43:48.674]                         invokeRestart("muffleWarning")
[17:43:48.674]                     }
[17:43:48.674]                     else if (inherits(cond, "condition")) {
[17:43:48.674]                       if (!is.null(pattern)) {
[17:43:48.674]                         computeRestarts <- base::computeRestarts
[17:43:48.674]                         grepl <- base::grepl
[17:43:48.674]                         restarts <- computeRestarts(cond)
[17:43:48.674]                         for (restart in restarts) {
[17:43:48.674]                           name <- restart$name
[17:43:48.674]                           if (is.null(name)) 
[17:43:48.674]                             next
[17:43:48.674]                           if (!grepl(pattern, name)) 
[17:43:48.674]                             next
[17:43:48.674]                           invokeRestart(restart)
[17:43:48.674]                           muffled <- TRUE
[17:43:48.674]                           break
[17:43:48.674]                         }
[17:43:48.674]                       }
[17:43:48.674]                     }
[17:43:48.674]                     invisible(muffled)
[17:43:48.674]                   }
[17:43:48.674]                   muffleCondition(cond)
[17:43:48.674]                 })
[17:43:48.674]             }))
[17:43:48.674]             future::FutureResult(value = ...future.value$value, 
[17:43:48.674]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.674]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.674]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.674]                     ...future.globalenv.names))
[17:43:48.674]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.674]         }, condition = base::local({
[17:43:48.674]             c <- base::c
[17:43:48.674]             inherits <- base::inherits
[17:43:48.674]             invokeRestart <- base::invokeRestart
[17:43:48.674]             length <- base::length
[17:43:48.674]             list <- base::list
[17:43:48.674]             seq.int <- base::seq.int
[17:43:48.674]             signalCondition <- base::signalCondition
[17:43:48.674]             sys.calls <- base::sys.calls
[17:43:48.674]             `[[` <- base::`[[`
[17:43:48.674]             `+` <- base::`+`
[17:43:48.674]             `<<-` <- base::`<<-`
[17:43:48.674]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.674]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.674]                   3L)]
[17:43:48.674]             }
[17:43:48.674]             function(cond) {
[17:43:48.674]                 is_error <- inherits(cond, "error")
[17:43:48.674]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.674]                   NULL)
[17:43:48.674]                 if (is_error) {
[17:43:48.674]                   sessionInformation <- function() {
[17:43:48.674]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.674]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.674]                       search = base::search(), system = base::Sys.info())
[17:43:48.674]                   }
[17:43:48.674]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.674]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.674]                     cond$call), session = sessionInformation(), 
[17:43:48.674]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.674]                   signalCondition(cond)
[17:43:48.674]                 }
[17:43:48.674]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.674]                 "immediateCondition"))) {
[17:43:48.674]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.674]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.674]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.674]                   if (TRUE && !signal) {
[17:43:48.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.674]                     {
[17:43:48.674]                       inherits <- base::inherits
[17:43:48.674]                       invokeRestart <- base::invokeRestart
[17:43:48.674]                       is.null <- base::is.null
[17:43:48.674]                       muffled <- FALSE
[17:43:48.674]                       if (inherits(cond, "message")) {
[17:43:48.674]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.674]                         if (muffled) 
[17:43:48.674]                           invokeRestart("muffleMessage")
[17:43:48.674]                       }
[17:43:48.674]                       else if (inherits(cond, "warning")) {
[17:43:48.674]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.674]                         if (muffled) 
[17:43:48.674]                           invokeRestart("muffleWarning")
[17:43:48.674]                       }
[17:43:48.674]                       else if (inherits(cond, "condition")) {
[17:43:48.674]                         if (!is.null(pattern)) {
[17:43:48.674]                           computeRestarts <- base::computeRestarts
[17:43:48.674]                           grepl <- base::grepl
[17:43:48.674]                           restarts <- computeRestarts(cond)
[17:43:48.674]                           for (restart in restarts) {
[17:43:48.674]                             name <- restart$name
[17:43:48.674]                             if (is.null(name)) 
[17:43:48.674]                               next
[17:43:48.674]                             if (!grepl(pattern, name)) 
[17:43:48.674]                               next
[17:43:48.674]                             invokeRestart(restart)
[17:43:48.674]                             muffled <- TRUE
[17:43:48.674]                             break
[17:43:48.674]                           }
[17:43:48.674]                         }
[17:43:48.674]                       }
[17:43:48.674]                       invisible(muffled)
[17:43:48.674]                     }
[17:43:48.674]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.674]                   }
[17:43:48.674]                 }
[17:43:48.674]                 else {
[17:43:48.674]                   if (TRUE) {
[17:43:48.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.674]                     {
[17:43:48.674]                       inherits <- base::inherits
[17:43:48.674]                       invokeRestart <- base::invokeRestart
[17:43:48.674]                       is.null <- base::is.null
[17:43:48.674]                       muffled <- FALSE
[17:43:48.674]                       if (inherits(cond, "message")) {
[17:43:48.674]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.674]                         if (muffled) 
[17:43:48.674]                           invokeRestart("muffleMessage")
[17:43:48.674]                       }
[17:43:48.674]                       else if (inherits(cond, "warning")) {
[17:43:48.674]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.674]                         if (muffled) 
[17:43:48.674]                           invokeRestart("muffleWarning")
[17:43:48.674]                       }
[17:43:48.674]                       else if (inherits(cond, "condition")) {
[17:43:48.674]                         if (!is.null(pattern)) {
[17:43:48.674]                           computeRestarts <- base::computeRestarts
[17:43:48.674]                           grepl <- base::grepl
[17:43:48.674]                           restarts <- computeRestarts(cond)
[17:43:48.674]                           for (restart in restarts) {
[17:43:48.674]                             name <- restart$name
[17:43:48.674]                             if (is.null(name)) 
[17:43:48.674]                               next
[17:43:48.674]                             if (!grepl(pattern, name)) 
[17:43:48.674]                               next
[17:43:48.674]                             invokeRestart(restart)
[17:43:48.674]                             muffled <- TRUE
[17:43:48.674]                             break
[17:43:48.674]                           }
[17:43:48.674]                         }
[17:43:48.674]                       }
[17:43:48.674]                       invisible(muffled)
[17:43:48.674]                     }
[17:43:48.674]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.674]                   }
[17:43:48.674]                 }
[17:43:48.674]             }
[17:43:48.674]         }))
[17:43:48.674]     }, error = function(ex) {
[17:43:48.674]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.674]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.674]                 ...future.rng), started = ...future.startTime, 
[17:43:48.674]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.674]             version = "1.8"), class = "FutureResult")
[17:43:48.674]     }, finally = {
[17:43:48.674]         if (!identical(...future.workdir, getwd())) 
[17:43:48.674]             setwd(...future.workdir)
[17:43:48.674]         {
[17:43:48.674]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.674]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.674]             }
[17:43:48.674]             base::options(...future.oldOptions)
[17:43:48.674]             if (.Platform$OS.type == "windows") {
[17:43:48.674]                 old_names <- names(...future.oldEnvVars)
[17:43:48.674]                 envs <- base::Sys.getenv()
[17:43:48.674]                 names <- names(envs)
[17:43:48.674]                 common <- intersect(names, old_names)
[17:43:48.674]                 added <- setdiff(names, old_names)
[17:43:48.674]                 removed <- setdiff(old_names, names)
[17:43:48.674]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.674]                   envs[common]]
[17:43:48.674]                 NAMES <- toupper(changed)
[17:43:48.674]                 args <- list()
[17:43:48.674]                 for (kk in seq_along(NAMES)) {
[17:43:48.674]                   name <- changed[[kk]]
[17:43:48.674]                   NAME <- NAMES[[kk]]
[17:43:48.674]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.674]                     next
[17:43:48.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.674]                 }
[17:43:48.674]                 NAMES <- toupper(added)
[17:43:48.674]                 for (kk in seq_along(NAMES)) {
[17:43:48.674]                   name <- added[[kk]]
[17:43:48.674]                   NAME <- NAMES[[kk]]
[17:43:48.674]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.674]                     next
[17:43:48.674]                   args[[name]] <- ""
[17:43:48.674]                 }
[17:43:48.674]                 NAMES <- toupper(removed)
[17:43:48.674]                 for (kk in seq_along(NAMES)) {
[17:43:48.674]                   name <- removed[[kk]]
[17:43:48.674]                   NAME <- NAMES[[kk]]
[17:43:48.674]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.674]                     next
[17:43:48.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.674]                 }
[17:43:48.674]                 if (length(args) > 0) 
[17:43:48.674]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.674]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.674]             }
[17:43:48.674]             else {
[17:43:48.674]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.674]             }
[17:43:48.674]             {
[17:43:48.674]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.674]                   0L) {
[17:43:48.674]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.674]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.674]                   base::options(opts)
[17:43:48.674]                 }
[17:43:48.674]                 {
[17:43:48.674]                   {
[17:43:48.674]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.674]                     NULL
[17:43:48.674]                   }
[17:43:48.674]                   options(future.plan = NULL)
[17:43:48.674]                   if (is.na(NA_character_)) 
[17:43:48.674]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.674]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.674]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.674]                     .init = FALSE)
[17:43:48.674]                 }
[17:43:48.674]             }
[17:43:48.674]         }
[17:43:48.674]     })
[17:43:48.674]     if (TRUE) {
[17:43:48.674]         base::sink(type = "output", split = FALSE)
[17:43:48.674]         if (TRUE) {
[17:43:48.674]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.674]         }
[17:43:48.674]         else {
[17:43:48.674]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.674]         }
[17:43:48.674]         base::close(...future.stdout)
[17:43:48.674]         ...future.stdout <- NULL
[17:43:48.674]     }
[17:43:48.674]     ...future.result$conditions <- ...future.conditions
[17:43:48.674]     ...future.result$finished <- base::Sys.time()
[17:43:48.674]     ...future.result
[17:43:48.674] }
[17:43:48.677] assign_globals() ...
[17:43:48.677] List of 5
[17:43:48.677]  $ future.call.arguments    : list()
[17:43:48.677]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.677]  $ ...future.FUN            :function (x)  
[17:43:48.677]  $ ...future.elements_ii    :List of 1
[17:43:48.677]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[17:43:48.677]  $ ...future.seeds_ii       : NULL
[17:43:48.677]  $ ...future.globals.maxSize: num Inf
[17:43:48.677]  - attr(*, "resolved")= logi FALSE
[17:43:48.677]  - attr(*, "total_size")= num NA
[17:43:48.677]  - attr(*, "where")=List of 5
[17:43:48.677]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.677]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.677]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.677]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.677]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.677]  - attr(*, "already-done")= logi TRUE
[17:43:48.684] - copied ‘future.call.arguments’ to environment
[17:43:48.684] - copied ‘...future.FUN’ to environment
[17:43:48.684] - copied ‘...future.elements_ii’ to environment
[17:43:48.684] - copied ‘...future.seeds_ii’ to environment
[17:43:48.684] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.684] assign_globals() ... done
[17:43:48.684] requestCore(): workers = 2
[17:43:48.686] MulticoreFuture started
[17:43:48.687] - Launch lazy future ... done
[17:43:48.687] run() for ‘MulticoreFuture’ ... done
[17:43:48.687] Created future:
[17:43:48.688] plan(): Setting new future strategy stack:
[17:43:48.688] List of future strategies:
[17:43:48.688] 1. sequential:
[17:43:48.688]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.688]    - tweaked: FALSE
[17:43:48.688]    - call: NULL
[17:43:48.689] plan(): nbrOfWorkers() = 1
[17:43:48.691] plan(): Setting new future strategy stack:
[17:43:48.691] List of future strategies:
[17:43:48.691] 1. multicore:
[17:43:48.691]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.691]    - tweaked: FALSE
[17:43:48.691]    - call: plan(strategy)
[17:43:48.697] plan(): nbrOfWorkers() = 2
[17:43:48.688] MulticoreFuture:
[17:43:48.688] Label: ‘future_apply-1’
[17:43:48.688] Expression:
[17:43:48.688] {
[17:43:48.688]     do.call(function(...) {
[17:43:48.688]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.688]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.688]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.688]             on.exit(options(oopts), add = TRUE)
[17:43:48.688]         }
[17:43:48.688]         {
[17:43:48.688]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.688]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.688]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.688]             })
[17:43:48.688]         }
[17:43:48.688]     }, args = future.call.arguments)
[17:43:48.688] }
[17:43:48.688] Lazy evaluation: FALSE
[17:43:48.688] Asynchronous evaluation: TRUE
[17:43:48.688] Local evaluation: TRUE
[17:43:48.688] Environment: R_GlobalEnv
[17:43:48.688] Capture standard output: TRUE
[17:43:48.688] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:48.688] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.688] Packages: <none>
[17:43:48.688] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:48.688] Resolved: TRUE
[17:43:48.688] Value: <not collected>
[17:43:48.688] Conditions captured: <none>
[17:43:48.688] Early signaling: FALSE
[17:43:48.688] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.688] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.698] Chunk #1 of 2 ... DONE
[17:43:48.698] Chunk #2 of 2 ...
[17:43:48.698]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.699]  - seeds: <none>
[17:43:48.699]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.699] getGlobalsAndPackages() ...
[17:43:48.699] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.699] Resolving globals: FALSE
[17:43:48.699] Tweak future expression to call with '...' arguments ...
[17:43:48.700] {
[17:43:48.700]     do.call(function(...) {
[17:43:48.700]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.700]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.700]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.700]             on.exit(options(oopts), add = TRUE)
[17:43:48.700]         }
[17:43:48.700]         {
[17:43:48.700]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.700]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.700]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.700]             })
[17:43:48.700]         }
[17:43:48.700]     }, args = future.call.arguments)
[17:43:48.700] }
[17:43:48.700] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.701] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.701] 
[17:43:48.701] getGlobalsAndPackages() ... DONE
[17:43:48.701] run() for ‘Future’ ...
[17:43:48.702] - state: ‘created’
[17:43:48.702] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.706] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.707]   - Field: ‘label’
[17:43:48.707]   - Field: ‘local’
[17:43:48.707]   - Field: ‘owner’
[17:43:48.707]   - Field: ‘envir’
[17:43:48.707]   - Field: ‘workers’
[17:43:48.708]   - Field: ‘packages’
[17:43:48.708]   - Field: ‘gc’
[17:43:48.708]   - Field: ‘job’
[17:43:48.708]   - Field: ‘conditions’
[17:43:48.708]   - Field: ‘expr’
[17:43:48.708]   - Field: ‘uuid’
[17:43:48.708]   - Field: ‘seed’
[17:43:48.709]   - Field: ‘version’
[17:43:48.709]   - Field: ‘result’
[17:43:48.709]   - Field: ‘asynchronous’
[17:43:48.709]   - Field: ‘calls’
[17:43:48.709]   - Field: ‘globals’
[17:43:48.709]   - Field: ‘stdout’
[17:43:48.709]   - Field: ‘earlySignal’
[17:43:48.710]   - Field: ‘lazy’
[17:43:48.710]   - Field: ‘state’
[17:43:48.710] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.710] - Launch lazy future ...
[17:43:48.710] Packages needed by the future expression (n = 0): <none>
[17:43:48.711] Packages needed by future strategies (n = 0): <none>
[17:43:48.712] {
[17:43:48.712]     {
[17:43:48.712]         {
[17:43:48.712]             ...future.startTime <- base::Sys.time()
[17:43:48.712]             {
[17:43:48.712]                 {
[17:43:48.712]                   {
[17:43:48.712]                     {
[17:43:48.712]                       base::local({
[17:43:48.712]                         has_future <- base::requireNamespace("future", 
[17:43:48.712]                           quietly = TRUE)
[17:43:48.712]                         if (has_future) {
[17:43:48.712]                           ns <- base::getNamespace("future")
[17:43:48.712]                           version <- ns[[".package"]][["version"]]
[17:43:48.712]                           if (is.null(version)) 
[17:43:48.712]                             version <- utils::packageVersion("future")
[17:43:48.712]                         }
[17:43:48.712]                         else {
[17:43:48.712]                           version <- NULL
[17:43:48.712]                         }
[17:43:48.712]                         if (!has_future || version < "1.8.0") {
[17:43:48.712]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.712]                             "", base::R.version$version.string), 
[17:43:48.712]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.712]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.712]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.712]                               "release", "version")], collapse = " "), 
[17:43:48.712]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.712]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.712]                             info)
[17:43:48.712]                           info <- base::paste(info, collapse = "; ")
[17:43:48.712]                           if (!has_future) {
[17:43:48.712]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.712]                               info)
[17:43:48.712]                           }
[17:43:48.712]                           else {
[17:43:48.712]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.712]                               info, version)
[17:43:48.712]                           }
[17:43:48.712]                           base::stop(msg)
[17:43:48.712]                         }
[17:43:48.712]                       })
[17:43:48.712]                     }
[17:43:48.712]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.712]                     base::options(mc.cores = 1L)
[17:43:48.712]                   }
[17:43:48.712]                   ...future.strategy.old <- future::plan("list")
[17:43:48.712]                   options(future.plan = NULL)
[17:43:48.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.712]                 }
[17:43:48.712]                 ...future.workdir <- getwd()
[17:43:48.712]             }
[17:43:48.712]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.712]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.712]         }
[17:43:48.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.712]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.712]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.712]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.712]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.712]             base::names(...future.oldOptions))
[17:43:48.712]     }
[17:43:48.712]     if (FALSE) {
[17:43:48.712]     }
[17:43:48.712]     else {
[17:43:48.712]         if (TRUE) {
[17:43:48.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.712]                 open = "w")
[17:43:48.712]         }
[17:43:48.712]         else {
[17:43:48.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.712]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.712]         }
[17:43:48.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.712]             base::sink(type = "output", split = FALSE)
[17:43:48.712]             base::close(...future.stdout)
[17:43:48.712]         }, add = TRUE)
[17:43:48.712]     }
[17:43:48.712]     ...future.frame <- base::sys.nframe()
[17:43:48.712]     ...future.conditions <- base::list()
[17:43:48.712]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.712]     if (FALSE) {
[17:43:48.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.712]     }
[17:43:48.712]     ...future.result <- base::tryCatch({
[17:43:48.712]         base::withCallingHandlers({
[17:43:48.712]             ...future.value <- base::withVisible(base::local({
[17:43:48.712]                 withCallingHandlers({
[17:43:48.712]                   {
[17:43:48.712]                     do.call(function(...) {
[17:43:48.712]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.712]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.712]                         ...future.globals.maxSize)) {
[17:43:48.712]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.712]                         on.exit(options(oopts), add = TRUE)
[17:43:48.712]                       }
[17:43:48.712]                       {
[17:43:48.712]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.712]                           FUN = function(jj) {
[17:43:48.712]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.712]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.712]                           })
[17:43:48.712]                       }
[17:43:48.712]                     }, args = future.call.arguments)
[17:43:48.712]                   }
[17:43:48.712]                 }, immediateCondition = function(cond) {
[17:43:48.712]                   save_rds <- function (object, pathname, ...) 
[17:43:48.712]                   {
[17:43:48.712]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.712]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.712]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.712]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.712]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.712]                         fi_tmp[["mtime"]])
[17:43:48.712]                     }
[17:43:48.712]                     tryCatch({
[17:43:48.712]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.712]                     }, error = function(ex) {
[17:43:48.712]                       msg <- conditionMessage(ex)
[17:43:48.712]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.712]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.712]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.712]                         fi_tmp[["mtime"]], msg)
[17:43:48.712]                       ex$message <- msg
[17:43:48.712]                       stop(ex)
[17:43:48.712]                     })
[17:43:48.712]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.712]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.712]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.712]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.712]                       fi <- file.info(pathname)
[17:43:48.712]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.712]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.712]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.712]                         fi[["size"]], fi[["mtime"]])
[17:43:48.712]                       stop(msg)
[17:43:48.712]                     }
[17:43:48.712]                     invisible(pathname)
[17:43:48.712]                   }
[17:43:48.712]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.712]                     rootPath = tempdir()) 
[17:43:48.712]                   {
[17:43:48.712]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.712]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.712]                       tmpdir = path, fileext = ".rds")
[17:43:48.712]                     save_rds(obj, file)
[17:43:48.712]                   }
[17:43:48.712]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.712]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.712]                   {
[17:43:48.712]                     inherits <- base::inherits
[17:43:48.712]                     invokeRestart <- base::invokeRestart
[17:43:48.712]                     is.null <- base::is.null
[17:43:48.712]                     muffled <- FALSE
[17:43:48.712]                     if (inherits(cond, "message")) {
[17:43:48.712]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.712]                       if (muffled) 
[17:43:48.712]                         invokeRestart("muffleMessage")
[17:43:48.712]                     }
[17:43:48.712]                     else if (inherits(cond, "warning")) {
[17:43:48.712]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.712]                       if (muffled) 
[17:43:48.712]                         invokeRestart("muffleWarning")
[17:43:48.712]                     }
[17:43:48.712]                     else if (inherits(cond, "condition")) {
[17:43:48.712]                       if (!is.null(pattern)) {
[17:43:48.712]                         computeRestarts <- base::computeRestarts
[17:43:48.712]                         grepl <- base::grepl
[17:43:48.712]                         restarts <- computeRestarts(cond)
[17:43:48.712]                         for (restart in restarts) {
[17:43:48.712]                           name <- restart$name
[17:43:48.712]                           if (is.null(name)) 
[17:43:48.712]                             next
[17:43:48.712]                           if (!grepl(pattern, name)) 
[17:43:48.712]                             next
[17:43:48.712]                           invokeRestart(restart)
[17:43:48.712]                           muffled <- TRUE
[17:43:48.712]                           break
[17:43:48.712]                         }
[17:43:48.712]                       }
[17:43:48.712]                     }
[17:43:48.712]                     invisible(muffled)
[17:43:48.712]                   }
[17:43:48.712]                   muffleCondition(cond)
[17:43:48.712]                 })
[17:43:48.712]             }))
[17:43:48.712]             future::FutureResult(value = ...future.value$value, 
[17:43:48.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.712]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.712]                     ...future.globalenv.names))
[17:43:48.712]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.712]         }, condition = base::local({
[17:43:48.712]             c <- base::c
[17:43:48.712]             inherits <- base::inherits
[17:43:48.712]             invokeRestart <- base::invokeRestart
[17:43:48.712]             length <- base::length
[17:43:48.712]             list <- base::list
[17:43:48.712]             seq.int <- base::seq.int
[17:43:48.712]             signalCondition <- base::signalCondition
[17:43:48.712]             sys.calls <- base::sys.calls
[17:43:48.712]             `[[` <- base::`[[`
[17:43:48.712]             `+` <- base::`+`
[17:43:48.712]             `<<-` <- base::`<<-`
[17:43:48.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.712]                   3L)]
[17:43:48.712]             }
[17:43:48.712]             function(cond) {
[17:43:48.712]                 is_error <- inherits(cond, "error")
[17:43:48.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.712]                   NULL)
[17:43:48.712]                 if (is_error) {
[17:43:48.712]                   sessionInformation <- function() {
[17:43:48.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.712]                       search = base::search(), system = base::Sys.info())
[17:43:48.712]                   }
[17:43:48.712]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.712]                     cond$call), session = sessionInformation(), 
[17:43:48.712]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.712]                   signalCondition(cond)
[17:43:48.712]                 }
[17:43:48.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.712]                 "immediateCondition"))) {
[17:43:48.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.712]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.712]                   if (TRUE && !signal) {
[17:43:48.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.712]                     {
[17:43:48.712]                       inherits <- base::inherits
[17:43:48.712]                       invokeRestart <- base::invokeRestart
[17:43:48.712]                       is.null <- base::is.null
[17:43:48.712]                       muffled <- FALSE
[17:43:48.712]                       if (inherits(cond, "message")) {
[17:43:48.712]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.712]                         if (muffled) 
[17:43:48.712]                           invokeRestart("muffleMessage")
[17:43:48.712]                       }
[17:43:48.712]                       else if (inherits(cond, "warning")) {
[17:43:48.712]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.712]                         if (muffled) 
[17:43:48.712]                           invokeRestart("muffleWarning")
[17:43:48.712]                       }
[17:43:48.712]                       else if (inherits(cond, "condition")) {
[17:43:48.712]                         if (!is.null(pattern)) {
[17:43:48.712]                           computeRestarts <- base::computeRestarts
[17:43:48.712]                           grepl <- base::grepl
[17:43:48.712]                           restarts <- computeRestarts(cond)
[17:43:48.712]                           for (restart in restarts) {
[17:43:48.712]                             name <- restart$name
[17:43:48.712]                             if (is.null(name)) 
[17:43:48.712]                               next
[17:43:48.712]                             if (!grepl(pattern, name)) 
[17:43:48.712]                               next
[17:43:48.712]                             invokeRestart(restart)
[17:43:48.712]                             muffled <- TRUE
[17:43:48.712]                             break
[17:43:48.712]                           }
[17:43:48.712]                         }
[17:43:48.712]                       }
[17:43:48.712]                       invisible(muffled)
[17:43:48.712]                     }
[17:43:48.712]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.712]                   }
[17:43:48.712]                 }
[17:43:48.712]                 else {
[17:43:48.712]                   if (TRUE) {
[17:43:48.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.712]                     {
[17:43:48.712]                       inherits <- base::inherits
[17:43:48.712]                       invokeRestart <- base::invokeRestart
[17:43:48.712]                       is.null <- base::is.null
[17:43:48.712]                       muffled <- FALSE
[17:43:48.712]                       if (inherits(cond, "message")) {
[17:43:48.712]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.712]                         if (muffled) 
[17:43:48.712]                           invokeRestart("muffleMessage")
[17:43:48.712]                       }
[17:43:48.712]                       else if (inherits(cond, "warning")) {
[17:43:48.712]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.712]                         if (muffled) 
[17:43:48.712]                           invokeRestart("muffleWarning")
[17:43:48.712]                       }
[17:43:48.712]                       else if (inherits(cond, "condition")) {
[17:43:48.712]                         if (!is.null(pattern)) {
[17:43:48.712]                           computeRestarts <- base::computeRestarts
[17:43:48.712]                           grepl <- base::grepl
[17:43:48.712]                           restarts <- computeRestarts(cond)
[17:43:48.712]                           for (restart in restarts) {
[17:43:48.712]                             name <- restart$name
[17:43:48.712]                             if (is.null(name)) 
[17:43:48.712]                               next
[17:43:48.712]                             if (!grepl(pattern, name)) 
[17:43:48.712]                               next
[17:43:48.712]                             invokeRestart(restart)
[17:43:48.712]                             muffled <- TRUE
[17:43:48.712]                             break
[17:43:48.712]                           }
[17:43:48.712]                         }
[17:43:48.712]                       }
[17:43:48.712]                       invisible(muffled)
[17:43:48.712]                     }
[17:43:48.712]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.712]                   }
[17:43:48.712]                 }
[17:43:48.712]             }
[17:43:48.712]         }))
[17:43:48.712]     }, error = function(ex) {
[17:43:48.712]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.712]                 ...future.rng), started = ...future.startTime, 
[17:43:48.712]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.712]             version = "1.8"), class = "FutureResult")
[17:43:48.712]     }, finally = {
[17:43:48.712]         if (!identical(...future.workdir, getwd())) 
[17:43:48.712]             setwd(...future.workdir)
[17:43:48.712]         {
[17:43:48.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.712]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.712]             }
[17:43:48.712]             base::options(...future.oldOptions)
[17:43:48.712]             if (.Platform$OS.type == "windows") {
[17:43:48.712]                 old_names <- names(...future.oldEnvVars)
[17:43:48.712]                 envs <- base::Sys.getenv()
[17:43:48.712]                 names <- names(envs)
[17:43:48.712]                 common <- intersect(names, old_names)
[17:43:48.712]                 added <- setdiff(names, old_names)
[17:43:48.712]                 removed <- setdiff(old_names, names)
[17:43:48.712]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.712]                   envs[common]]
[17:43:48.712]                 NAMES <- toupper(changed)
[17:43:48.712]                 args <- list()
[17:43:48.712]                 for (kk in seq_along(NAMES)) {
[17:43:48.712]                   name <- changed[[kk]]
[17:43:48.712]                   NAME <- NAMES[[kk]]
[17:43:48.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.712]                     next
[17:43:48.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.712]                 }
[17:43:48.712]                 NAMES <- toupper(added)
[17:43:48.712]                 for (kk in seq_along(NAMES)) {
[17:43:48.712]                   name <- added[[kk]]
[17:43:48.712]                   NAME <- NAMES[[kk]]
[17:43:48.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.712]                     next
[17:43:48.712]                   args[[name]] <- ""
[17:43:48.712]                 }
[17:43:48.712]                 NAMES <- toupper(removed)
[17:43:48.712]                 for (kk in seq_along(NAMES)) {
[17:43:48.712]                   name <- removed[[kk]]
[17:43:48.712]                   NAME <- NAMES[[kk]]
[17:43:48.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.712]                     next
[17:43:48.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.712]                 }
[17:43:48.712]                 if (length(args) > 0) 
[17:43:48.712]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.712]             }
[17:43:48.712]             else {
[17:43:48.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.712]             }
[17:43:48.712]             {
[17:43:48.712]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.712]                   0L) {
[17:43:48.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.712]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.712]                   base::options(opts)
[17:43:48.712]                 }
[17:43:48.712]                 {
[17:43:48.712]                   {
[17:43:48.712]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.712]                     NULL
[17:43:48.712]                   }
[17:43:48.712]                   options(future.plan = NULL)
[17:43:48.712]                   if (is.na(NA_character_)) 
[17:43:48.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.712]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.712]                     .init = FALSE)
[17:43:48.712]                 }
[17:43:48.712]             }
[17:43:48.712]         }
[17:43:48.712]     })
[17:43:48.712]     if (TRUE) {
[17:43:48.712]         base::sink(type = "output", split = FALSE)
[17:43:48.712]         if (TRUE) {
[17:43:48.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.712]         }
[17:43:48.712]         else {
[17:43:48.712]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.712]         }
[17:43:48.712]         base::close(...future.stdout)
[17:43:48.712]         ...future.stdout <- NULL
[17:43:48.712]     }
[17:43:48.712]     ...future.result$conditions <- ...future.conditions
[17:43:48.712]     ...future.result$finished <- base::Sys.time()
[17:43:48.712]     ...future.result
[17:43:48.712] }
[17:43:48.715] assign_globals() ...
[17:43:48.715] List of 5
[17:43:48.715]  $ future.call.arguments    : list()
[17:43:48.715]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.715]  $ ...future.FUN            :function (x)  
[17:43:48.715]  $ ...future.elements_ii    :List of 1
[17:43:48.715]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[17:43:48.715]  $ ...future.seeds_ii       : NULL
[17:43:48.715]  $ ...future.globals.maxSize: num Inf
[17:43:48.715]  - attr(*, "resolved")= logi FALSE
[17:43:48.715]  - attr(*, "total_size")= num NA
[17:43:48.715]  - attr(*, "where")=List of 5
[17:43:48.715]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.715]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.715]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.715]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.715]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.715]  - attr(*, "already-done")= logi TRUE
[17:43:48.723] - copied ‘future.call.arguments’ to environment
[17:43:48.723] - copied ‘...future.FUN’ to environment
[17:43:48.723] - copied ‘...future.elements_ii’ to environment
[17:43:48.723] - copied ‘...future.seeds_ii’ to environment
[17:43:48.723] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.723] assign_globals() ... done
[17:43:48.724] requestCore(): workers = 2
[17:43:48.726] MulticoreFuture started
[17:43:48.726] - Launch lazy future ... done
[17:43:48.726] run() for ‘MulticoreFuture’ ... done
[17:43:48.727] Created future:
[17:43:48.727] plan(): Setting new future strategy stack:
[17:43:48.727] List of future strategies:
[17:43:48.727] 1. sequential:
[17:43:48.727]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.727]    - tweaked: FALSE
[17:43:48.727]    - call: NULL
[17:43:48.728] plan(): nbrOfWorkers() = 1
[17:43:48.730] plan(): Setting new future strategy stack:
[17:43:48.730] List of future strategies:
[17:43:48.730] 1. multicore:
[17:43:48.730]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.730]    - tweaked: FALSE
[17:43:48.730]    - call: plan(strategy)
[17:43:48.727] MulticoreFuture:
[17:43:48.727] Label: ‘future_apply-2’
[17:43:48.727] Expression:
[17:43:48.727] {
[17:43:48.727]     do.call(function(...) {
[17:43:48.727]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.727]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.727]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.727]             on.exit(options(oopts), add = TRUE)
[17:43:48.727]         }
[17:43:48.727]         {
[17:43:48.727]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.727]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.727]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.727]             })
[17:43:48.727]         }
[17:43:48.727]     }, args = future.call.arguments)
[17:43:48.727] }
[17:43:48.727] Lazy evaluation: FALSE
[17:43:48.727] Asynchronous evaluation: TRUE
[17:43:48.727] Local evaluation: TRUE
[17:43:48.727] Environment: R_GlobalEnv
[17:43:48.727] Capture standard output: TRUE
[17:43:48.727] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:48.727] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.727] Packages: <none>
[17:43:48.727] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:48.727] Resolved: FALSE
[17:43:48.727] Value: <not collected>
[17:43:48.727] Conditions captured: <none>
[17:43:48.727] Early signaling: FALSE
[17:43:48.727] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.727] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.740] Chunk #2 of 2 ... DONE
[17:43:48.740] Launching 2 futures (chunks) ... DONE
[17:43:48.740] Resolving 2 futures (chunks) ...
[17:43:48.740] resolve() on list ...
[17:43:48.740]  recursive: 0
[17:43:48.741]  length: 2
[17:43:48.741] plan(): nbrOfWorkers() = 2
[17:43:48.743] 
[17:43:48.744] Future #1
[17:43:48.744] result() for MulticoreFuture ...
[17:43:48.746] result() for MulticoreFuture ...
[17:43:48.746] result() for MulticoreFuture ... done
[17:43:48.746] result() for MulticoreFuture ... done
[17:43:48.747] result() for MulticoreFuture ...
[17:43:48.747] result() for MulticoreFuture ... done
[17:43:48.747] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:48.748] - nx: 2
[17:43:48.748] - relay: TRUE
[17:43:48.748] - stdout: TRUE
[17:43:48.748] - signal: TRUE
[17:43:48.749] - resignal: FALSE
[17:43:48.749] - force: TRUE
[17:43:48.749] - relayed: [n=2] FALSE, FALSE
[17:43:48.749] - queued futures: [n=2] FALSE, FALSE
[17:43:48.750]  - until=1
[17:43:48.750]  - relaying element #1
[17:43:48.750] result() for MulticoreFuture ...
[17:43:48.750] result() for MulticoreFuture ... done
[17:43:48.751] result() for MulticoreFuture ...
[17:43:48.751] result() for MulticoreFuture ... done
[17:43:48.751] result() for MulticoreFuture ...
[17:43:48.751] result() for MulticoreFuture ... done
[17:43:48.751] result() for MulticoreFuture ...
[17:43:48.752] result() for MulticoreFuture ... done
[17:43:48.752] - relayed: [n=2] TRUE, FALSE
[17:43:48.752] - queued futures: [n=2] TRUE, FALSE
[17:43:48.752] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:48.752]  length: 1 (resolved future 1)
[17:43:48.752] Future #2
[17:43:48.753] result() for MulticoreFuture ...
[17:43:48.754] result() for MulticoreFuture ...
[17:43:48.754] result() for MulticoreFuture ... done
[17:43:48.754] result() for MulticoreFuture ... done
[17:43:48.754] result() for MulticoreFuture ...
[17:43:48.754] result() for MulticoreFuture ... done
[17:43:48.754] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:48.755] - nx: 2
[17:43:48.755] - relay: TRUE
[17:43:48.755] - stdout: TRUE
[17:43:48.755] - signal: TRUE
[17:43:48.755] - resignal: FALSE
[17:43:48.755] - force: TRUE
[17:43:48.755] - relayed: [n=2] TRUE, FALSE
[17:43:48.755] - queued futures: [n=2] TRUE, FALSE
[17:43:48.755]  - until=2
[17:43:48.756]  - relaying element #2
[17:43:48.756] result() for MulticoreFuture ...
[17:43:48.756] result() for MulticoreFuture ... done
[17:43:48.756] result() for MulticoreFuture ...
[17:43:48.756] result() for MulticoreFuture ... done
[17:43:48.756] result() for MulticoreFuture ...
[17:43:48.756] result() for MulticoreFuture ... done
[17:43:48.756] result() for MulticoreFuture ...
[17:43:48.756] result() for MulticoreFuture ... done
[17:43:48.757] - relayed: [n=2] TRUE, TRUE
[17:43:48.757] - queued futures: [n=2] TRUE, TRUE
[17:43:48.757] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:48.757]  length: 0 (resolved future 2)
[17:43:48.757] Relaying remaining futures
[17:43:48.757] signalConditionsASAP(NULL, pos=0) ...
[17:43:48.757] - nx: 2
[17:43:48.757] - relay: TRUE
[17:43:48.757] - stdout: TRUE
[17:43:48.758] - signal: TRUE
[17:43:48.758] - resignal: FALSE
[17:43:48.758] - force: TRUE
[17:43:48.758] - relayed: [n=2] TRUE, TRUE
[17:43:48.758] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:48.758] - relayed: [n=2] TRUE, TRUE
[17:43:48.758] - queued futures: [n=2] TRUE, TRUE
[17:43:48.758] signalConditionsASAP(NULL, pos=0) ... done
[17:43:48.758] resolve() on list ... DONE
[17:43:48.758] result() for MulticoreFuture ...
[17:43:48.759] result() for MulticoreFuture ... done
[17:43:48.759] result() for MulticoreFuture ...
[17:43:48.759] result() for MulticoreFuture ... done
[17:43:48.759] result() for MulticoreFuture ...
[17:43:48.759] result() for MulticoreFuture ... done
[17:43:48.759] result() for MulticoreFuture ...
[17:43:48.759] result() for MulticoreFuture ... done
[17:43:48.759]  - Number of value chunks collected: 2
[17:43:48.760] Resolving 2 futures (chunks) ... DONE
[17:43:48.760] Reducing values from 2 chunks ...
[17:43:48.760]  - Number of values collected after concatenation: 2
[17:43:48.760]  - Number of values expected: 2
[17:43:48.760] Reducing values from 2 chunks ... DONE
[17:43:48.760] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[17:43:48.760] getGlobalsAndPackagesXApply() ...
[17:43:48.761]  - future.globals: TRUE
[17:43:48.761] getGlobalsAndPackages() ...
[17:43:48.761] Searching for globals...
[17:43:48.764] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[17:43:48.764] Searching for globals ... DONE
[17:43:48.764] Resolving globals: FALSE
[17:43:48.765] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[17:43:48.765] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[17:43:48.765] - globals: [1] ‘FUN’
[17:43:48.765] 
[17:43:48.765] getGlobalsAndPackages() ... DONE
[17:43:48.766]  - globals found/used: [n=1] ‘FUN’
[17:43:48.766]  - needed namespaces: [n=0] 
[17:43:48.766] Finding globals ... DONE
[17:43:48.766]  - use_args: TRUE
[17:43:48.766]  - Getting '...' globals ...
[17:43:48.766] resolve() on list ...
[17:43:48.766]  recursive: 0
[17:43:48.767]  length: 1
[17:43:48.767]  elements: ‘...’
[17:43:48.767]  length: 0 (resolved future 1)
[17:43:48.767] resolve() on list ... DONE
[17:43:48.767]    - '...' content: [n=0] 
[17:43:48.767] List of 1
[17:43:48.767]  $ ...: list()
[17:43:48.767]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.767]  - attr(*, "where")=List of 1
[17:43:48.767]   ..$ ...:<environment: 0x55dfd2db62d8> 
[17:43:48.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.767]  - attr(*, "resolved")= logi TRUE
[17:43:48.767]  - attr(*, "total_size")= num NA
[17:43:48.770]  - Getting '...' globals ... DONE
[17:43:48.770] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:48.770] List of 2
[17:43:48.770]  $ ...future.FUN:function (x)  
[17:43:48.770]  $ ...          : list()
[17:43:48.770]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.770]  - attr(*, "where")=List of 2
[17:43:48.770]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:48.770]   ..$ ...          :<environment: 0x55dfd2db62d8> 
[17:43:48.770]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.770]  - attr(*, "resolved")= logi FALSE
[17:43:48.770]  - attr(*, "total_size")= num 9888
[17:43:48.775] Packages to be attached in all futures: [n=0] 
[17:43:48.776] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.780] future_lapply() ...
[17:43:48.785] Number of chunks: 2
[17:43:48.785] getGlobalsAndPackagesXApply() ...
[17:43:48.785]  - future.globals: <name-value list> with names ‘list()’
[17:43:48.785]  - use_args: TRUE
[17:43:48.785] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:48.786] List of 2
[17:43:48.786]  $ ...          : list()
[17:43:48.786]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.786]  $ ...future.FUN:function (x)  
[17:43:48.786]  - attr(*, "where")=List of 2
[17:43:48.786]   ..$ ...          :<environment: 0x55dfd2db62d8> 
[17:43:48.786]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:43:48.786]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.786]  - attr(*, "resolved")= logi FALSE
[17:43:48.786]  - attr(*, "total_size")= num NA
[17:43:48.788] Packages to be attached in all futures: [n=0] 
[17:43:48.788] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.789] Number of futures (= number of chunks): 2
[17:43:48.789] Launching 2 futures (chunks) ...
[17:43:48.789] Chunk #1 of 2 ...
[17:43:48.789]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.789]  - seeds: <none>
[17:43:48.789]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.789] getGlobalsAndPackages() ...
[17:43:48.789] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.790] Resolving globals: FALSE
[17:43:48.790] Tweak future expression to call with '...' arguments ...
[17:43:48.790] {
[17:43:48.790]     do.call(function(...) {
[17:43:48.790]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.790]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.790]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.790]             on.exit(options(oopts), add = TRUE)
[17:43:48.790]         }
[17:43:48.790]         {
[17:43:48.790]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.790]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.790]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.790]             })
[17:43:48.790]         }
[17:43:48.790]     }, args = future.call.arguments)
[17:43:48.790] }
[17:43:48.790] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.790] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.791] 
[17:43:48.791] getGlobalsAndPackages() ... DONE
[17:43:48.791] run() for ‘Future’ ...
[17:43:48.791] - state: ‘created’
[17:43:48.791] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.795] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.795] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.795]   - Field: ‘label’
[17:43:48.795]   - Field: ‘local’
[17:43:48.795]   - Field: ‘owner’
[17:43:48.795]   - Field: ‘envir’
[17:43:48.796]   - Field: ‘workers’
[17:43:48.796]   - Field: ‘packages’
[17:43:48.796]   - Field: ‘gc’
[17:43:48.796]   - Field: ‘job’
[17:43:48.796]   - Field: ‘conditions’
[17:43:48.796]   - Field: ‘expr’
[17:43:48.796]   - Field: ‘uuid’
[17:43:48.796]   - Field: ‘seed’
[17:43:48.796]   - Field: ‘version’
[17:43:48.796]   - Field: ‘result’
[17:43:48.797]   - Field: ‘asynchronous’
[17:43:48.797]   - Field: ‘calls’
[17:43:48.797]   - Field: ‘globals’
[17:43:48.797]   - Field: ‘stdout’
[17:43:48.797]   - Field: ‘earlySignal’
[17:43:48.797]   - Field: ‘lazy’
[17:43:48.797]   - Field: ‘state’
[17:43:48.797] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.797] - Launch lazy future ...
[17:43:48.798] Packages needed by the future expression (n = 0): <none>
[17:43:48.798] Packages needed by future strategies (n = 0): <none>
[17:43:48.798] {
[17:43:48.798]     {
[17:43:48.798]         {
[17:43:48.798]             ...future.startTime <- base::Sys.time()
[17:43:48.798]             {
[17:43:48.798]                 {
[17:43:48.798]                   {
[17:43:48.798]                     {
[17:43:48.798]                       base::local({
[17:43:48.798]                         has_future <- base::requireNamespace("future", 
[17:43:48.798]                           quietly = TRUE)
[17:43:48.798]                         if (has_future) {
[17:43:48.798]                           ns <- base::getNamespace("future")
[17:43:48.798]                           version <- ns[[".package"]][["version"]]
[17:43:48.798]                           if (is.null(version)) 
[17:43:48.798]                             version <- utils::packageVersion("future")
[17:43:48.798]                         }
[17:43:48.798]                         else {
[17:43:48.798]                           version <- NULL
[17:43:48.798]                         }
[17:43:48.798]                         if (!has_future || version < "1.8.0") {
[17:43:48.798]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.798]                             "", base::R.version$version.string), 
[17:43:48.798]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.798]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.798]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.798]                               "release", "version")], collapse = " "), 
[17:43:48.798]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.798]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.798]                             info)
[17:43:48.798]                           info <- base::paste(info, collapse = "; ")
[17:43:48.798]                           if (!has_future) {
[17:43:48.798]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.798]                               info)
[17:43:48.798]                           }
[17:43:48.798]                           else {
[17:43:48.798]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.798]                               info, version)
[17:43:48.798]                           }
[17:43:48.798]                           base::stop(msg)
[17:43:48.798]                         }
[17:43:48.798]                       })
[17:43:48.798]                     }
[17:43:48.798]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.798]                     base::options(mc.cores = 1L)
[17:43:48.798]                   }
[17:43:48.798]                   ...future.strategy.old <- future::plan("list")
[17:43:48.798]                   options(future.plan = NULL)
[17:43:48.798]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.798]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.798]                 }
[17:43:48.798]                 ...future.workdir <- getwd()
[17:43:48.798]             }
[17:43:48.798]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.798]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.798]         }
[17:43:48.798]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.798]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.798]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.798]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.798]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.798]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.798]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.798]             base::names(...future.oldOptions))
[17:43:48.798]     }
[17:43:48.798]     if (FALSE) {
[17:43:48.798]     }
[17:43:48.798]     else {
[17:43:48.798]         if (TRUE) {
[17:43:48.798]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.798]                 open = "w")
[17:43:48.798]         }
[17:43:48.798]         else {
[17:43:48.798]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.798]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.798]         }
[17:43:48.798]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.798]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.798]             base::sink(type = "output", split = FALSE)
[17:43:48.798]             base::close(...future.stdout)
[17:43:48.798]         }, add = TRUE)
[17:43:48.798]     }
[17:43:48.798]     ...future.frame <- base::sys.nframe()
[17:43:48.798]     ...future.conditions <- base::list()
[17:43:48.798]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.798]     if (FALSE) {
[17:43:48.798]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.798]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.798]     }
[17:43:48.798]     ...future.result <- base::tryCatch({
[17:43:48.798]         base::withCallingHandlers({
[17:43:48.798]             ...future.value <- base::withVisible(base::local({
[17:43:48.798]                 withCallingHandlers({
[17:43:48.798]                   {
[17:43:48.798]                     do.call(function(...) {
[17:43:48.798]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.798]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.798]                         ...future.globals.maxSize)) {
[17:43:48.798]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.798]                         on.exit(options(oopts), add = TRUE)
[17:43:48.798]                       }
[17:43:48.798]                       {
[17:43:48.798]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.798]                           FUN = function(jj) {
[17:43:48.798]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.798]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.798]                           })
[17:43:48.798]                       }
[17:43:48.798]                     }, args = future.call.arguments)
[17:43:48.798]                   }
[17:43:48.798]                 }, immediateCondition = function(cond) {
[17:43:48.798]                   save_rds <- function (object, pathname, ...) 
[17:43:48.798]                   {
[17:43:48.798]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.798]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.798]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.798]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.798]                         fi_tmp[["mtime"]])
[17:43:48.798]                     }
[17:43:48.798]                     tryCatch({
[17:43:48.798]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.798]                     }, error = function(ex) {
[17:43:48.798]                       msg <- conditionMessage(ex)
[17:43:48.798]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.798]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.798]                         fi_tmp[["mtime"]], msg)
[17:43:48.798]                       ex$message <- msg
[17:43:48.798]                       stop(ex)
[17:43:48.798]                     })
[17:43:48.798]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.798]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.798]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.798]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.798]                       fi <- file.info(pathname)
[17:43:48.798]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.798]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.798]                         fi[["size"]], fi[["mtime"]])
[17:43:48.798]                       stop(msg)
[17:43:48.798]                     }
[17:43:48.798]                     invisible(pathname)
[17:43:48.798]                   }
[17:43:48.798]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.798]                     rootPath = tempdir()) 
[17:43:48.798]                   {
[17:43:48.798]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.798]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.798]                       tmpdir = path, fileext = ".rds")
[17:43:48.798]                     save_rds(obj, file)
[17:43:48.798]                   }
[17:43:48.798]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.798]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.798]                   {
[17:43:48.798]                     inherits <- base::inherits
[17:43:48.798]                     invokeRestart <- base::invokeRestart
[17:43:48.798]                     is.null <- base::is.null
[17:43:48.798]                     muffled <- FALSE
[17:43:48.798]                     if (inherits(cond, "message")) {
[17:43:48.798]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.798]                       if (muffled) 
[17:43:48.798]                         invokeRestart("muffleMessage")
[17:43:48.798]                     }
[17:43:48.798]                     else if (inherits(cond, "warning")) {
[17:43:48.798]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.798]                       if (muffled) 
[17:43:48.798]                         invokeRestart("muffleWarning")
[17:43:48.798]                     }
[17:43:48.798]                     else if (inherits(cond, "condition")) {
[17:43:48.798]                       if (!is.null(pattern)) {
[17:43:48.798]                         computeRestarts <- base::computeRestarts
[17:43:48.798]                         grepl <- base::grepl
[17:43:48.798]                         restarts <- computeRestarts(cond)
[17:43:48.798]                         for (restart in restarts) {
[17:43:48.798]                           name <- restart$name
[17:43:48.798]                           if (is.null(name)) 
[17:43:48.798]                             next
[17:43:48.798]                           if (!grepl(pattern, name)) 
[17:43:48.798]                             next
[17:43:48.798]                           invokeRestart(restart)
[17:43:48.798]                           muffled <- TRUE
[17:43:48.798]                           break
[17:43:48.798]                         }
[17:43:48.798]                       }
[17:43:48.798]                     }
[17:43:48.798]                     invisible(muffled)
[17:43:48.798]                   }
[17:43:48.798]                   muffleCondition(cond)
[17:43:48.798]                 })
[17:43:48.798]             }))
[17:43:48.798]             future::FutureResult(value = ...future.value$value, 
[17:43:48.798]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.798]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.798]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.798]                     ...future.globalenv.names))
[17:43:48.798]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.798]         }, condition = base::local({
[17:43:48.798]             c <- base::c
[17:43:48.798]             inherits <- base::inherits
[17:43:48.798]             invokeRestart <- base::invokeRestart
[17:43:48.798]             length <- base::length
[17:43:48.798]             list <- base::list
[17:43:48.798]             seq.int <- base::seq.int
[17:43:48.798]             signalCondition <- base::signalCondition
[17:43:48.798]             sys.calls <- base::sys.calls
[17:43:48.798]             `[[` <- base::`[[`
[17:43:48.798]             `+` <- base::`+`
[17:43:48.798]             `<<-` <- base::`<<-`
[17:43:48.798]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.798]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.798]                   3L)]
[17:43:48.798]             }
[17:43:48.798]             function(cond) {
[17:43:48.798]                 is_error <- inherits(cond, "error")
[17:43:48.798]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.798]                   NULL)
[17:43:48.798]                 if (is_error) {
[17:43:48.798]                   sessionInformation <- function() {
[17:43:48.798]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.798]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.798]                       search = base::search(), system = base::Sys.info())
[17:43:48.798]                   }
[17:43:48.798]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.798]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.798]                     cond$call), session = sessionInformation(), 
[17:43:48.798]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.798]                   signalCondition(cond)
[17:43:48.798]                 }
[17:43:48.798]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.798]                 "immediateCondition"))) {
[17:43:48.798]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.798]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.798]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.798]                   if (TRUE && !signal) {
[17:43:48.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.798]                     {
[17:43:48.798]                       inherits <- base::inherits
[17:43:48.798]                       invokeRestart <- base::invokeRestart
[17:43:48.798]                       is.null <- base::is.null
[17:43:48.798]                       muffled <- FALSE
[17:43:48.798]                       if (inherits(cond, "message")) {
[17:43:48.798]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.798]                         if (muffled) 
[17:43:48.798]                           invokeRestart("muffleMessage")
[17:43:48.798]                       }
[17:43:48.798]                       else if (inherits(cond, "warning")) {
[17:43:48.798]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.798]                         if (muffled) 
[17:43:48.798]                           invokeRestart("muffleWarning")
[17:43:48.798]                       }
[17:43:48.798]                       else if (inherits(cond, "condition")) {
[17:43:48.798]                         if (!is.null(pattern)) {
[17:43:48.798]                           computeRestarts <- base::computeRestarts
[17:43:48.798]                           grepl <- base::grepl
[17:43:48.798]                           restarts <- computeRestarts(cond)
[17:43:48.798]                           for (restart in restarts) {
[17:43:48.798]                             name <- restart$name
[17:43:48.798]                             if (is.null(name)) 
[17:43:48.798]                               next
[17:43:48.798]                             if (!grepl(pattern, name)) 
[17:43:48.798]                               next
[17:43:48.798]                             invokeRestart(restart)
[17:43:48.798]                             muffled <- TRUE
[17:43:48.798]                             break
[17:43:48.798]                           }
[17:43:48.798]                         }
[17:43:48.798]                       }
[17:43:48.798]                       invisible(muffled)
[17:43:48.798]                     }
[17:43:48.798]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.798]                   }
[17:43:48.798]                 }
[17:43:48.798]                 else {
[17:43:48.798]                   if (TRUE) {
[17:43:48.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.798]                     {
[17:43:48.798]                       inherits <- base::inherits
[17:43:48.798]                       invokeRestart <- base::invokeRestart
[17:43:48.798]                       is.null <- base::is.null
[17:43:48.798]                       muffled <- FALSE
[17:43:48.798]                       if (inherits(cond, "message")) {
[17:43:48.798]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.798]                         if (muffled) 
[17:43:48.798]                           invokeRestart("muffleMessage")
[17:43:48.798]                       }
[17:43:48.798]                       else if (inherits(cond, "warning")) {
[17:43:48.798]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.798]                         if (muffled) 
[17:43:48.798]                           invokeRestart("muffleWarning")
[17:43:48.798]                       }
[17:43:48.798]                       else if (inherits(cond, "condition")) {
[17:43:48.798]                         if (!is.null(pattern)) {
[17:43:48.798]                           computeRestarts <- base::computeRestarts
[17:43:48.798]                           grepl <- base::grepl
[17:43:48.798]                           restarts <- computeRestarts(cond)
[17:43:48.798]                           for (restart in restarts) {
[17:43:48.798]                             name <- restart$name
[17:43:48.798]                             if (is.null(name)) 
[17:43:48.798]                               next
[17:43:48.798]                             if (!grepl(pattern, name)) 
[17:43:48.798]                               next
[17:43:48.798]                             invokeRestart(restart)
[17:43:48.798]                             muffled <- TRUE
[17:43:48.798]                             break
[17:43:48.798]                           }
[17:43:48.798]                         }
[17:43:48.798]                       }
[17:43:48.798]                       invisible(muffled)
[17:43:48.798]                     }
[17:43:48.798]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.798]                   }
[17:43:48.798]                 }
[17:43:48.798]             }
[17:43:48.798]         }))
[17:43:48.798]     }, error = function(ex) {
[17:43:48.798]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.798]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.798]                 ...future.rng), started = ...future.startTime, 
[17:43:48.798]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.798]             version = "1.8"), class = "FutureResult")
[17:43:48.798]     }, finally = {
[17:43:48.798]         if (!identical(...future.workdir, getwd())) 
[17:43:48.798]             setwd(...future.workdir)
[17:43:48.798]         {
[17:43:48.798]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.798]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.798]             }
[17:43:48.798]             base::options(...future.oldOptions)
[17:43:48.798]             if (.Platform$OS.type == "windows") {
[17:43:48.798]                 old_names <- names(...future.oldEnvVars)
[17:43:48.798]                 envs <- base::Sys.getenv()
[17:43:48.798]                 names <- names(envs)
[17:43:48.798]                 common <- intersect(names, old_names)
[17:43:48.798]                 added <- setdiff(names, old_names)
[17:43:48.798]                 removed <- setdiff(old_names, names)
[17:43:48.798]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.798]                   envs[common]]
[17:43:48.798]                 NAMES <- toupper(changed)
[17:43:48.798]                 args <- list()
[17:43:48.798]                 for (kk in seq_along(NAMES)) {
[17:43:48.798]                   name <- changed[[kk]]
[17:43:48.798]                   NAME <- NAMES[[kk]]
[17:43:48.798]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.798]                     next
[17:43:48.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.798]                 }
[17:43:48.798]                 NAMES <- toupper(added)
[17:43:48.798]                 for (kk in seq_along(NAMES)) {
[17:43:48.798]                   name <- added[[kk]]
[17:43:48.798]                   NAME <- NAMES[[kk]]
[17:43:48.798]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.798]                     next
[17:43:48.798]                   args[[name]] <- ""
[17:43:48.798]                 }
[17:43:48.798]                 NAMES <- toupper(removed)
[17:43:48.798]                 for (kk in seq_along(NAMES)) {
[17:43:48.798]                   name <- removed[[kk]]
[17:43:48.798]                   NAME <- NAMES[[kk]]
[17:43:48.798]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.798]                     next
[17:43:48.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.798]                 }
[17:43:48.798]                 if (length(args) > 0) 
[17:43:48.798]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.798]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.798]             }
[17:43:48.798]             else {
[17:43:48.798]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.798]             }
[17:43:48.798]             {
[17:43:48.798]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.798]                   0L) {
[17:43:48.798]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.798]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.798]                   base::options(opts)
[17:43:48.798]                 }
[17:43:48.798]                 {
[17:43:48.798]                   {
[17:43:48.798]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.798]                     NULL
[17:43:48.798]                   }
[17:43:48.798]                   options(future.plan = NULL)
[17:43:48.798]                   if (is.na(NA_character_)) 
[17:43:48.798]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.798]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.798]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.798]                     .init = FALSE)
[17:43:48.798]                 }
[17:43:48.798]             }
[17:43:48.798]         }
[17:43:48.798]     })
[17:43:48.798]     if (TRUE) {
[17:43:48.798]         base::sink(type = "output", split = FALSE)
[17:43:48.798]         if (TRUE) {
[17:43:48.798]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.798]         }
[17:43:48.798]         else {
[17:43:48.798]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.798]         }
[17:43:48.798]         base::close(...future.stdout)
[17:43:48.798]         ...future.stdout <- NULL
[17:43:48.798]     }
[17:43:48.798]     ...future.result$conditions <- ...future.conditions
[17:43:48.798]     ...future.result$finished <- base::Sys.time()
[17:43:48.798]     ...future.result
[17:43:48.798] }
[17:43:48.801] assign_globals() ...
[17:43:48.801] List of 5
[17:43:48.801]  $ future.call.arguments    : list()
[17:43:48.801]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.801]  $ ...future.FUN            :function (x)  
[17:43:48.801]  $ ...future.elements_ii    :List of 1
[17:43:48.801]   ..$ : int [1:2] 1 3
[17:43:48.801]  $ ...future.seeds_ii       : NULL
[17:43:48.801]  $ ...future.globals.maxSize: num Inf
[17:43:48.801]  - attr(*, "resolved")= logi FALSE
[17:43:48.801]  - attr(*, "total_size")= num NA
[17:43:48.801]  - attr(*, "where")=List of 5
[17:43:48.801]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.801]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.801]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.801]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.801]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.801]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.801]  - attr(*, "already-done")= logi TRUE
[17:43:48.808] - copied ‘future.call.arguments’ to environment
[17:43:48.808] - reassign environment for ‘...future.FUN’
[17:43:48.808] - copied ‘...future.FUN’ to environment
[17:43:48.808] - copied ‘...future.elements_ii’ to environment
[17:43:48.808] - copied ‘...future.seeds_ii’ to environment
[17:43:48.809] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.809] assign_globals() ... done
[17:43:48.809] requestCore(): workers = 2
[17:43:48.811] MulticoreFuture started
[17:43:48.812] - Launch lazy future ... done
[17:43:48.813] plan(): Setting new future strategy stack:
[17:43:48.813] run() for ‘MulticoreFuture’ ... done
[17:43:48.813] Created future:
[17:43:48.813] List of future strategies:
[17:43:48.813] 1. sequential:
[17:43:48.813]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.813]    - tweaked: FALSE
[17:43:48.813]    - call: NULL
[17:43:48.814] plan(): nbrOfWorkers() = 1
[17:43:48.817] plan(): Setting new future strategy stack:
[17:43:48.817] List of future strategies:
[17:43:48.817] 1. multicore:
[17:43:48.817]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.817]    - tweaked: FALSE
[17:43:48.817]    - call: plan(strategy)
[17:43:48.823] plan(): nbrOfWorkers() = 2
[17:43:48.814] MulticoreFuture:
[17:43:48.814] Label: ‘future_apply-1’
[17:43:48.814] Expression:
[17:43:48.814] {
[17:43:48.814]     do.call(function(...) {
[17:43:48.814]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.814]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.814]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.814]             on.exit(options(oopts), add = TRUE)
[17:43:48.814]         }
[17:43:48.814]         {
[17:43:48.814]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.814]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.814]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.814]             })
[17:43:48.814]         }
[17:43:48.814]     }, args = future.call.arguments)
[17:43:48.814] }
[17:43:48.814] Lazy evaluation: FALSE
[17:43:48.814] Asynchronous evaluation: TRUE
[17:43:48.814] Local evaluation: TRUE
[17:43:48.814] Environment: R_GlobalEnv
[17:43:48.814] Capture standard output: TRUE
[17:43:48.814] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:48.814] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.814] Packages: <none>
[17:43:48.814] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:48.814] Resolved: TRUE
[17:43:48.814] Value: <not collected>
[17:43:48.814] Conditions captured: <none>
[17:43:48.814] Early signaling: FALSE
[17:43:48.814] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.814] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.824] Chunk #1 of 2 ... DONE
[17:43:48.824] Chunk #2 of 2 ...
[17:43:48.825]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.825]  - seeds: <none>
[17:43:48.825]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.825] getGlobalsAndPackages() ...
[17:43:48.825] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.826] Resolving globals: FALSE
[17:43:48.826] Tweak future expression to call with '...' arguments ...
[17:43:48.826] {
[17:43:48.826]     do.call(function(...) {
[17:43:48.826]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.826]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.826]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.826]             on.exit(options(oopts), add = TRUE)
[17:43:48.826]         }
[17:43:48.826]         {
[17:43:48.826]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.826]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.826]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.826]             })
[17:43:48.826]         }
[17:43:48.826]     }, args = future.call.arguments)
[17:43:48.826] }
[17:43:48.826] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.827] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.827] 
[17:43:48.827] getGlobalsAndPackages() ... DONE
[17:43:48.828] run() for ‘Future’ ...
[17:43:48.828] - state: ‘created’
[17:43:48.828] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.833] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.833] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.833]   - Field: ‘label’
[17:43:48.834]   - Field: ‘local’
[17:43:48.834]   - Field: ‘owner’
[17:43:48.834]   - Field: ‘envir’
[17:43:48.834]   - Field: ‘workers’
[17:43:48.834]   - Field: ‘packages’
[17:43:48.834]   - Field: ‘gc’
[17:43:48.834]   - Field: ‘job’
[17:43:48.835]   - Field: ‘conditions’
[17:43:48.835]   - Field: ‘expr’
[17:43:48.835]   - Field: ‘uuid’
[17:43:48.835]   - Field: ‘seed’
[17:43:48.835]   - Field: ‘version’
[17:43:48.835]   - Field: ‘result’
[17:43:48.835]   - Field: ‘asynchronous’
[17:43:48.836]   - Field: ‘calls’
[17:43:48.836]   - Field: ‘globals’
[17:43:48.836]   - Field: ‘stdout’
[17:43:48.836]   - Field: ‘earlySignal’
[17:43:48.836]   - Field: ‘lazy’
[17:43:48.836]   - Field: ‘state’
[17:43:48.836] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.837] - Launch lazy future ...
[17:43:48.837] Packages needed by the future expression (n = 0): <none>
[17:43:48.837] Packages needed by future strategies (n = 0): <none>
[17:43:48.838] {
[17:43:48.838]     {
[17:43:48.838]         {
[17:43:48.838]             ...future.startTime <- base::Sys.time()
[17:43:48.838]             {
[17:43:48.838]                 {
[17:43:48.838]                   {
[17:43:48.838]                     {
[17:43:48.838]                       base::local({
[17:43:48.838]                         has_future <- base::requireNamespace("future", 
[17:43:48.838]                           quietly = TRUE)
[17:43:48.838]                         if (has_future) {
[17:43:48.838]                           ns <- base::getNamespace("future")
[17:43:48.838]                           version <- ns[[".package"]][["version"]]
[17:43:48.838]                           if (is.null(version)) 
[17:43:48.838]                             version <- utils::packageVersion("future")
[17:43:48.838]                         }
[17:43:48.838]                         else {
[17:43:48.838]                           version <- NULL
[17:43:48.838]                         }
[17:43:48.838]                         if (!has_future || version < "1.8.0") {
[17:43:48.838]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.838]                             "", base::R.version$version.string), 
[17:43:48.838]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.838]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.838]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.838]                               "release", "version")], collapse = " "), 
[17:43:48.838]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.838]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.838]                             info)
[17:43:48.838]                           info <- base::paste(info, collapse = "; ")
[17:43:48.838]                           if (!has_future) {
[17:43:48.838]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.838]                               info)
[17:43:48.838]                           }
[17:43:48.838]                           else {
[17:43:48.838]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.838]                               info, version)
[17:43:48.838]                           }
[17:43:48.838]                           base::stop(msg)
[17:43:48.838]                         }
[17:43:48.838]                       })
[17:43:48.838]                     }
[17:43:48.838]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.838]                     base::options(mc.cores = 1L)
[17:43:48.838]                   }
[17:43:48.838]                   ...future.strategy.old <- future::plan("list")
[17:43:48.838]                   options(future.plan = NULL)
[17:43:48.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.838]                 }
[17:43:48.838]                 ...future.workdir <- getwd()
[17:43:48.838]             }
[17:43:48.838]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.838]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.838]         }
[17:43:48.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.838]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.838]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.838]             base::names(...future.oldOptions))
[17:43:48.838]     }
[17:43:48.838]     if (FALSE) {
[17:43:48.838]     }
[17:43:48.838]     else {
[17:43:48.838]         if (TRUE) {
[17:43:48.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.838]                 open = "w")
[17:43:48.838]         }
[17:43:48.838]         else {
[17:43:48.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.838]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.838]         }
[17:43:48.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.838]             base::sink(type = "output", split = FALSE)
[17:43:48.838]             base::close(...future.stdout)
[17:43:48.838]         }, add = TRUE)
[17:43:48.838]     }
[17:43:48.838]     ...future.frame <- base::sys.nframe()
[17:43:48.838]     ...future.conditions <- base::list()
[17:43:48.838]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.838]     if (FALSE) {
[17:43:48.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.838]     }
[17:43:48.838]     ...future.result <- base::tryCatch({
[17:43:48.838]         base::withCallingHandlers({
[17:43:48.838]             ...future.value <- base::withVisible(base::local({
[17:43:48.838]                 withCallingHandlers({
[17:43:48.838]                   {
[17:43:48.838]                     do.call(function(...) {
[17:43:48.838]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.838]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.838]                         ...future.globals.maxSize)) {
[17:43:48.838]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.838]                         on.exit(options(oopts), add = TRUE)
[17:43:48.838]                       }
[17:43:48.838]                       {
[17:43:48.838]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.838]                           FUN = function(jj) {
[17:43:48.838]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.838]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.838]                           })
[17:43:48.838]                       }
[17:43:48.838]                     }, args = future.call.arguments)
[17:43:48.838]                   }
[17:43:48.838]                 }, immediateCondition = function(cond) {
[17:43:48.838]                   save_rds <- function (object, pathname, ...) 
[17:43:48.838]                   {
[17:43:48.838]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.838]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.838]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.838]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.838]                         fi_tmp[["mtime"]])
[17:43:48.838]                     }
[17:43:48.838]                     tryCatch({
[17:43:48.838]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.838]                     }, error = function(ex) {
[17:43:48.838]                       msg <- conditionMessage(ex)
[17:43:48.838]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.838]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.838]                         fi_tmp[["mtime"]], msg)
[17:43:48.838]                       ex$message <- msg
[17:43:48.838]                       stop(ex)
[17:43:48.838]                     })
[17:43:48.838]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.838]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.838]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.838]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.838]                       fi <- file.info(pathname)
[17:43:48.838]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.838]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.838]                         fi[["size"]], fi[["mtime"]])
[17:43:48.838]                       stop(msg)
[17:43:48.838]                     }
[17:43:48.838]                     invisible(pathname)
[17:43:48.838]                   }
[17:43:48.838]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.838]                     rootPath = tempdir()) 
[17:43:48.838]                   {
[17:43:48.838]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.838]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.838]                       tmpdir = path, fileext = ".rds")
[17:43:48.838]                     save_rds(obj, file)
[17:43:48.838]                   }
[17:43:48.838]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.838]                   {
[17:43:48.838]                     inherits <- base::inherits
[17:43:48.838]                     invokeRestart <- base::invokeRestart
[17:43:48.838]                     is.null <- base::is.null
[17:43:48.838]                     muffled <- FALSE
[17:43:48.838]                     if (inherits(cond, "message")) {
[17:43:48.838]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.838]                       if (muffled) 
[17:43:48.838]                         invokeRestart("muffleMessage")
[17:43:48.838]                     }
[17:43:48.838]                     else if (inherits(cond, "warning")) {
[17:43:48.838]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.838]                       if (muffled) 
[17:43:48.838]                         invokeRestart("muffleWarning")
[17:43:48.838]                     }
[17:43:48.838]                     else if (inherits(cond, "condition")) {
[17:43:48.838]                       if (!is.null(pattern)) {
[17:43:48.838]                         computeRestarts <- base::computeRestarts
[17:43:48.838]                         grepl <- base::grepl
[17:43:48.838]                         restarts <- computeRestarts(cond)
[17:43:48.838]                         for (restart in restarts) {
[17:43:48.838]                           name <- restart$name
[17:43:48.838]                           if (is.null(name)) 
[17:43:48.838]                             next
[17:43:48.838]                           if (!grepl(pattern, name)) 
[17:43:48.838]                             next
[17:43:48.838]                           invokeRestart(restart)
[17:43:48.838]                           muffled <- TRUE
[17:43:48.838]                           break
[17:43:48.838]                         }
[17:43:48.838]                       }
[17:43:48.838]                     }
[17:43:48.838]                     invisible(muffled)
[17:43:48.838]                   }
[17:43:48.838]                   muffleCondition(cond)
[17:43:48.838]                 })
[17:43:48.838]             }))
[17:43:48.838]             future::FutureResult(value = ...future.value$value, 
[17:43:48.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.838]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.838]                     ...future.globalenv.names))
[17:43:48.838]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.838]         }, condition = base::local({
[17:43:48.838]             c <- base::c
[17:43:48.838]             inherits <- base::inherits
[17:43:48.838]             invokeRestart <- base::invokeRestart
[17:43:48.838]             length <- base::length
[17:43:48.838]             list <- base::list
[17:43:48.838]             seq.int <- base::seq.int
[17:43:48.838]             signalCondition <- base::signalCondition
[17:43:48.838]             sys.calls <- base::sys.calls
[17:43:48.838]             `[[` <- base::`[[`
[17:43:48.838]             `+` <- base::`+`
[17:43:48.838]             `<<-` <- base::`<<-`
[17:43:48.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.838]                   3L)]
[17:43:48.838]             }
[17:43:48.838]             function(cond) {
[17:43:48.838]                 is_error <- inherits(cond, "error")
[17:43:48.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.838]                   NULL)
[17:43:48.838]                 if (is_error) {
[17:43:48.838]                   sessionInformation <- function() {
[17:43:48.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.838]                       search = base::search(), system = base::Sys.info())
[17:43:48.838]                   }
[17:43:48.838]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.838]                     cond$call), session = sessionInformation(), 
[17:43:48.838]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.838]                   signalCondition(cond)
[17:43:48.838]                 }
[17:43:48.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.838]                 "immediateCondition"))) {
[17:43:48.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.838]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.838]                   if (TRUE && !signal) {
[17:43:48.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.838]                     {
[17:43:48.838]                       inherits <- base::inherits
[17:43:48.838]                       invokeRestart <- base::invokeRestart
[17:43:48.838]                       is.null <- base::is.null
[17:43:48.838]                       muffled <- FALSE
[17:43:48.838]                       if (inherits(cond, "message")) {
[17:43:48.838]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.838]                         if (muffled) 
[17:43:48.838]                           invokeRestart("muffleMessage")
[17:43:48.838]                       }
[17:43:48.838]                       else if (inherits(cond, "warning")) {
[17:43:48.838]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.838]                         if (muffled) 
[17:43:48.838]                           invokeRestart("muffleWarning")
[17:43:48.838]                       }
[17:43:48.838]                       else if (inherits(cond, "condition")) {
[17:43:48.838]                         if (!is.null(pattern)) {
[17:43:48.838]                           computeRestarts <- base::computeRestarts
[17:43:48.838]                           grepl <- base::grepl
[17:43:48.838]                           restarts <- computeRestarts(cond)
[17:43:48.838]                           for (restart in restarts) {
[17:43:48.838]                             name <- restart$name
[17:43:48.838]                             if (is.null(name)) 
[17:43:48.838]                               next
[17:43:48.838]                             if (!grepl(pattern, name)) 
[17:43:48.838]                               next
[17:43:48.838]                             invokeRestart(restart)
[17:43:48.838]                             muffled <- TRUE
[17:43:48.838]                             break
[17:43:48.838]                           }
[17:43:48.838]                         }
[17:43:48.838]                       }
[17:43:48.838]                       invisible(muffled)
[17:43:48.838]                     }
[17:43:48.838]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.838]                   }
[17:43:48.838]                 }
[17:43:48.838]                 else {
[17:43:48.838]                   if (TRUE) {
[17:43:48.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.838]                     {
[17:43:48.838]                       inherits <- base::inherits
[17:43:48.838]                       invokeRestart <- base::invokeRestart
[17:43:48.838]                       is.null <- base::is.null
[17:43:48.838]                       muffled <- FALSE
[17:43:48.838]                       if (inherits(cond, "message")) {
[17:43:48.838]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.838]                         if (muffled) 
[17:43:48.838]                           invokeRestart("muffleMessage")
[17:43:48.838]                       }
[17:43:48.838]                       else if (inherits(cond, "warning")) {
[17:43:48.838]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.838]                         if (muffled) 
[17:43:48.838]                           invokeRestart("muffleWarning")
[17:43:48.838]                       }
[17:43:48.838]                       else if (inherits(cond, "condition")) {
[17:43:48.838]                         if (!is.null(pattern)) {
[17:43:48.838]                           computeRestarts <- base::computeRestarts
[17:43:48.838]                           grepl <- base::grepl
[17:43:48.838]                           restarts <- computeRestarts(cond)
[17:43:48.838]                           for (restart in restarts) {
[17:43:48.838]                             name <- restart$name
[17:43:48.838]                             if (is.null(name)) 
[17:43:48.838]                               next
[17:43:48.838]                             if (!grepl(pattern, name)) 
[17:43:48.838]                               next
[17:43:48.838]                             invokeRestart(restart)
[17:43:48.838]                             muffled <- TRUE
[17:43:48.838]                             break
[17:43:48.838]                           }
[17:43:48.838]                         }
[17:43:48.838]                       }
[17:43:48.838]                       invisible(muffled)
[17:43:48.838]                     }
[17:43:48.838]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.838]                   }
[17:43:48.838]                 }
[17:43:48.838]             }
[17:43:48.838]         }))
[17:43:48.838]     }, error = function(ex) {
[17:43:48.838]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.838]                 ...future.rng), started = ...future.startTime, 
[17:43:48.838]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.838]             version = "1.8"), class = "FutureResult")
[17:43:48.838]     }, finally = {
[17:43:48.838]         if (!identical(...future.workdir, getwd())) 
[17:43:48.838]             setwd(...future.workdir)
[17:43:48.838]         {
[17:43:48.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.838]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.838]             }
[17:43:48.838]             base::options(...future.oldOptions)
[17:43:48.838]             if (.Platform$OS.type == "windows") {
[17:43:48.838]                 old_names <- names(...future.oldEnvVars)
[17:43:48.838]                 envs <- base::Sys.getenv()
[17:43:48.838]                 names <- names(envs)
[17:43:48.838]                 common <- intersect(names, old_names)
[17:43:48.838]                 added <- setdiff(names, old_names)
[17:43:48.838]                 removed <- setdiff(old_names, names)
[17:43:48.838]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.838]                   envs[common]]
[17:43:48.838]                 NAMES <- toupper(changed)
[17:43:48.838]                 args <- list()
[17:43:48.838]                 for (kk in seq_along(NAMES)) {
[17:43:48.838]                   name <- changed[[kk]]
[17:43:48.838]                   NAME <- NAMES[[kk]]
[17:43:48.838]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.838]                     next
[17:43:48.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.838]                 }
[17:43:48.838]                 NAMES <- toupper(added)
[17:43:48.838]                 for (kk in seq_along(NAMES)) {
[17:43:48.838]                   name <- added[[kk]]
[17:43:48.838]                   NAME <- NAMES[[kk]]
[17:43:48.838]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.838]                     next
[17:43:48.838]                   args[[name]] <- ""
[17:43:48.838]                 }
[17:43:48.838]                 NAMES <- toupper(removed)
[17:43:48.838]                 for (kk in seq_along(NAMES)) {
[17:43:48.838]                   name <- removed[[kk]]
[17:43:48.838]                   NAME <- NAMES[[kk]]
[17:43:48.838]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.838]                     next
[17:43:48.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.838]                 }
[17:43:48.838]                 if (length(args) > 0) 
[17:43:48.838]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.838]             }
[17:43:48.838]             else {
[17:43:48.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.838]             }
[17:43:48.838]             {
[17:43:48.838]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.838]                   0L) {
[17:43:48.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.838]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.838]                   base::options(opts)
[17:43:48.838]                 }
[17:43:48.838]                 {
[17:43:48.838]                   {
[17:43:48.838]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.838]                     NULL
[17:43:48.838]                   }
[17:43:48.838]                   options(future.plan = NULL)
[17:43:48.838]                   if (is.na(NA_character_)) 
[17:43:48.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.838]                     .init = FALSE)
[17:43:48.838]                 }
[17:43:48.838]             }
[17:43:48.838]         }
[17:43:48.838]     })
[17:43:48.838]     if (TRUE) {
[17:43:48.838]         base::sink(type = "output", split = FALSE)
[17:43:48.838]         if (TRUE) {
[17:43:48.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.838]         }
[17:43:48.838]         else {
[17:43:48.838]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.838]         }
[17:43:48.838]         base::close(...future.stdout)
[17:43:48.838]         ...future.stdout <- NULL
[17:43:48.838]     }
[17:43:48.838]     ...future.result$conditions <- ...future.conditions
[17:43:48.838]     ...future.result$finished <- base::Sys.time()
[17:43:48.838]     ...future.result
[17:43:48.838] }
[17:43:48.841] assign_globals() ...
[17:43:48.841] List of 5
[17:43:48.841]  $ future.call.arguments    : list()
[17:43:48.841]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.841]  $ ...future.FUN            :function (x)  
[17:43:48.841]  $ ...future.elements_ii    :List of 1
[17:43:48.841]   ..$ : int [1:2] 2 4
[17:43:48.841]  $ ...future.seeds_ii       : NULL
[17:43:48.841]  $ ...future.globals.maxSize: num Inf
[17:43:48.841]  - attr(*, "resolved")= logi FALSE
[17:43:48.841]  - attr(*, "total_size")= num NA
[17:43:48.841]  - attr(*, "where")=List of 5
[17:43:48.841]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.841]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.841]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.841]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.841]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.841]  - attr(*, "already-done")= logi TRUE
[17:43:48.849] - copied ‘future.call.arguments’ to environment
[17:43:48.849] - reassign environment for ‘...future.FUN’
[17:43:48.849] - copied ‘...future.FUN’ to environment
[17:43:48.850] - copied ‘...future.elements_ii’ to environment
[17:43:48.850] - copied ‘...future.seeds_ii’ to environment
[17:43:48.850] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.850] assign_globals() ... done
[17:43:48.850] requestCore(): workers = 2
[17:43:48.853] MulticoreFuture started
[17:43:48.853] - Launch lazy future ... done
[17:43:48.853] run() for ‘MulticoreFuture’ ... done
[17:43:48.853] Created future:
[17:43:48.854] plan(): Setting new future strategy stack:
[17:43:48.854] List of future strategies:
[17:43:48.854] 1. sequential:
[17:43:48.854]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.854]    - tweaked: FALSE
[17:43:48.854]    - call: NULL
[17:43:48.855] plan(): nbrOfWorkers() = 1
[17:43:48.857] plan(): Setting new future strategy stack:
[17:43:48.857] List of future strategies:
[17:43:48.857] 1. multicore:
[17:43:48.857]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.857]    - tweaked: FALSE
[17:43:48.857]    - call: plan(strategy)
[17:43:48.862] plan(): nbrOfWorkers() = 2
[17:43:48.854] MulticoreFuture:
[17:43:48.854] Label: ‘future_apply-2’
[17:43:48.854] Expression:
[17:43:48.854] {
[17:43:48.854]     do.call(function(...) {
[17:43:48.854]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.854]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.854]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.854]             on.exit(options(oopts), add = TRUE)
[17:43:48.854]         }
[17:43:48.854]         {
[17:43:48.854]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.854]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.854]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.854]             })
[17:43:48.854]         }
[17:43:48.854]     }, args = future.call.arguments)
[17:43:48.854] }
[17:43:48.854] Lazy evaluation: FALSE
[17:43:48.854] Asynchronous evaluation: TRUE
[17:43:48.854] Local evaluation: TRUE
[17:43:48.854] Environment: R_GlobalEnv
[17:43:48.854] Capture standard output: TRUE
[17:43:48.854] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:48.854] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.854] Packages: <none>
[17:43:48.854] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:48.854] Resolved: TRUE
[17:43:48.854] Value: <not collected>
[17:43:48.854] Conditions captured: <none>
[17:43:48.854] Early signaling: FALSE
[17:43:48.854] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.854] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.864] Chunk #2 of 2 ... DONE
[17:43:48.864] Launching 2 futures (chunks) ... DONE
[17:43:48.864] Resolving 2 futures (chunks) ...
[17:43:48.864] resolve() on list ...
[17:43:48.864]  recursive: 0
[17:43:48.864]  length: 2
[17:43:48.864] 
[17:43:48.865] Future #1
[17:43:48.865] result() for MulticoreFuture ...
[17:43:48.866] result() for MulticoreFuture ...
[17:43:48.866] result() for MulticoreFuture ... done
[17:43:48.866] result() for MulticoreFuture ... done
[17:43:48.866] result() for MulticoreFuture ...
[17:43:48.867] result() for MulticoreFuture ... done
[17:43:48.867] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:48.867] - nx: 2
[17:43:48.867] - relay: TRUE
[17:43:48.871] - stdout: TRUE
[17:43:48.871] - signal: TRUE
[17:43:48.872] - resignal: FALSE
[17:43:48.872] - force: TRUE
[17:43:48.873] - relayed: [n=2] FALSE, FALSE
[17:43:48.873] - queued futures: [n=2] FALSE, FALSE
[17:43:48.873]  - until=1
[17:43:48.874]  - relaying element #1
[17:43:48.874] result() for MulticoreFuture ...
[17:43:48.874] result() for MulticoreFuture ... done
[17:43:48.875] result() for MulticoreFuture ...
[17:43:48.875] result() for MulticoreFuture ... done
[17:43:48.875] result() for MulticoreFuture ...
[17:43:48.876] result() for MulticoreFuture ... done
[17:43:48.876] result() for MulticoreFuture ...
[17:43:48.876] result() for MulticoreFuture ... done
[17:43:48.876] - relayed: [n=2] TRUE, FALSE
[17:43:48.877] - queued futures: [n=2] TRUE, FALSE
[17:43:48.877] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:48.877]  length: 1 (resolved future 1)
[17:43:48.878] Future #2
[17:43:48.878] result() for MulticoreFuture ...
[17:43:48.879] result() for MulticoreFuture ...
[17:43:48.879] result() for MulticoreFuture ... done
[17:43:48.879] result() for MulticoreFuture ... done
[17:43:48.879] result() for MulticoreFuture ...
[17:43:48.880] result() for MulticoreFuture ... done
[17:43:48.880] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:48.880] - nx: 2
[17:43:48.880] - relay: TRUE
[17:43:48.880] - stdout: TRUE
[17:43:48.880] - signal: TRUE
[17:43:48.880] - resignal: FALSE
[17:43:48.880] - force: TRUE
[17:43:48.880] - relayed: [n=2] TRUE, FALSE
[17:43:48.881] - queued futures: [n=2] TRUE, FALSE
[17:43:48.881]  - until=2
[17:43:48.881]  - relaying element #2
[17:43:48.881] result() for MulticoreFuture ...
[17:43:48.881] result() for MulticoreFuture ... done
[17:43:48.881] result() for MulticoreFuture ...
[17:43:48.881] result() for MulticoreFuture ... done
[17:43:48.882] result() for MulticoreFuture ...
[17:43:48.882] result() for MulticoreFuture ... done
[17:43:48.882] result() for MulticoreFuture ...
[17:43:48.882] result() for MulticoreFuture ... done
[17:43:48.882] - relayed: [n=2] TRUE, TRUE
[17:43:48.882] - queued futures: [n=2] TRUE, TRUE
[17:43:48.882] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:48.882]  length: 0 (resolved future 2)
[17:43:48.882] Relaying remaining futures
[17:43:48.883] signalConditionsASAP(NULL, pos=0) ...
[17:43:48.883] - nx: 2
[17:43:48.883] - relay: TRUE
[17:43:48.883] - stdout: TRUE
[17:43:48.883] - signal: TRUE
[17:43:48.883] - resignal: FALSE
[17:43:48.883] - force: TRUE
[17:43:48.883] - relayed: [n=2] TRUE, TRUE
[17:43:48.883] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:48.884] - relayed: [n=2] TRUE, TRUE
[17:43:48.884] - queued futures: [n=2] TRUE, TRUE
[17:43:48.884] signalConditionsASAP(NULL, pos=0) ... done
[17:43:48.884] resolve() on list ... DONE
[17:43:48.884] result() for MulticoreFuture ...
[17:43:48.884] result() for MulticoreFuture ... done
[17:43:48.884] result() for MulticoreFuture ...
[17:43:48.884] result() for MulticoreFuture ... done
[17:43:48.884] result() for MulticoreFuture ...
[17:43:48.885] result() for MulticoreFuture ... done
[17:43:48.885] result() for MulticoreFuture ...
[17:43:48.885] result() for MulticoreFuture ... done
[17:43:48.885]  - Number of value chunks collected: 2
[17:43:48.885] Resolving 2 futures (chunks) ... DONE
[17:43:48.885] Reducing values from 2 chunks ...
[17:43:48.885]  - Number of values collected after concatenation: 2
[17:43:48.885]  - Number of values expected: 2
[17:43:48.885] Reducing values from 2 chunks ... DONE
[17:43:48.885] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[17:43:48.886] getGlobalsAndPackagesXApply() ...
[17:43:48.886]  - future.globals: TRUE
[17:43:48.886] getGlobalsAndPackages() ...
[17:43:48.886] Searching for globals...
[17:43:48.890] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[17:43:48.890] Searching for globals ... DONE
[17:43:48.890] Resolving globals: FALSE
[17:43:48.891] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[17:43:48.891] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[17:43:48.891] - globals: [1] ‘FUN’
[17:43:48.891] 
[17:43:48.891] getGlobalsAndPackages() ... DONE
[17:43:48.892]  - globals found/used: [n=1] ‘FUN’
[17:43:48.892]  - needed namespaces: [n=0] 
[17:43:48.892] Finding globals ... DONE
[17:43:48.892]  - use_args: TRUE
[17:43:48.892]  - Getting '...' globals ...
[17:43:48.892] resolve() on list ...
[17:43:48.892]  recursive: 0
[17:43:48.893]  length: 1
[17:43:48.893]  elements: ‘...’
[17:43:48.893]  length: 0 (resolved future 1)
[17:43:48.893] resolve() on list ... DONE
[17:43:48.893]    - '...' content: [n=0] 
[17:43:48.893] List of 1
[17:43:48.893]  $ ...: list()
[17:43:48.893]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.893]  - attr(*, "where")=List of 1
[17:43:48.893]   ..$ ...:<environment: 0x55dfd33304b8> 
[17:43:48.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.893]  - attr(*, "resolved")= logi TRUE
[17:43:48.893]  - attr(*, "total_size")= num NA
[17:43:48.896]  - Getting '...' globals ... DONE
[17:43:48.896] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:48.896] List of 2
[17:43:48.896]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:43:48.896]  $ ...          : list()
[17:43:48.896]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.896]  - attr(*, "where")=List of 2
[17:43:48.896]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:48.896]   ..$ ...          :<environment: 0x55dfd33304b8> 
[17:43:48.896]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.896]  - attr(*, "resolved")= logi FALSE
[17:43:48.896]  - attr(*, "total_size")= num 36296
[17:43:48.901] Packages to be attached in all futures: [n=0] 
[17:43:48.902] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.906] future_lapply() ...
[17:43:48.908] Generating random seeds ...
[17:43:48.908] Generating random seed streams for 2 elements ...
[17:43:48.908] Generating random seed streams for 2 elements ... DONE
[17:43:48.908] Generating random seeds ... DONE
[17:43:48.908] Will set RNG state on exit: 10407, 473793448, -1638208785, 497165730, -903202944, 684013430, -10551270
[17:43:48.912] Number of chunks: 2
[17:43:48.912] getGlobalsAndPackagesXApply() ...
[17:43:48.912]  - future.globals: <name-value list> with names ‘list()’
[17:43:48.912]  - use_args: TRUE
[17:43:48.912] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:48.912] List of 2
[17:43:48.912]  $ ...          : list()
[17:43:48.912]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.912]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:43:48.912]  - attr(*, "where")=List of 2
[17:43:48.912]   ..$ ...          :<environment: 0x55dfd33304b8> 
[17:43:48.912]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:48.912]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.912]  - attr(*, "resolved")= logi FALSE
[17:43:48.912]  - attr(*, "total_size")= num NA
[17:43:48.916] Packages to be attached in all futures: [n=0] 
[17:43:48.916] getGlobalsAndPackagesXApply() ... DONE
[17:43:48.916] Number of futures (= number of chunks): 2
[17:43:48.916] Launching 2 futures (chunks) ...
[17:43:48.916] Chunk #1 of 2 ...
[17:43:48.917]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.917]  - seeds: [1] <seeds>
[17:43:48.917]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.917] getGlobalsAndPackages() ...
[17:43:48.917] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.917] Resolving globals: FALSE
[17:43:48.917] Tweak future expression to call with '...' arguments ...
[17:43:48.917] {
[17:43:48.917]     do.call(function(...) {
[17:43:48.917]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.917]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.917]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.917]             on.exit(options(oopts), add = TRUE)
[17:43:48.917]         }
[17:43:48.917]         {
[17:43:48.917]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.917]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.917]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:48.917]                   envir = globalenv(), inherits = FALSE)
[17:43:48.917]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.917]             })
[17:43:48.917]         }
[17:43:48.917]     }, args = future.call.arguments)
[17:43:48.917] }
[17:43:48.918] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.918] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.918] 
[17:43:48.918] getGlobalsAndPackages() ... DONE
[17:43:48.918] run() for ‘Future’ ...
[17:43:48.919] - state: ‘created’
[17:43:48.919] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.922] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.922] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.923]   - Field: ‘label’
[17:43:48.923]   - Field: ‘local’
[17:43:48.923]   - Field: ‘owner’
[17:43:48.923]   - Field: ‘envir’
[17:43:48.923]   - Field: ‘workers’
[17:43:48.923]   - Field: ‘packages’
[17:43:48.923]   - Field: ‘gc’
[17:43:48.923]   - Field: ‘job’
[17:43:48.923]   - Field: ‘conditions’
[17:43:48.924]   - Field: ‘expr’
[17:43:48.924]   - Field: ‘uuid’
[17:43:48.924]   - Field: ‘seed’
[17:43:48.924]   - Field: ‘version’
[17:43:48.924]   - Field: ‘result’
[17:43:48.924]   - Field: ‘asynchronous’
[17:43:48.924]   - Field: ‘calls’
[17:43:48.924]   - Field: ‘globals’
[17:43:48.924]   - Field: ‘stdout’
[17:43:48.924]   - Field: ‘earlySignal’
[17:43:48.924]   - Field: ‘lazy’
[17:43:48.925]   - Field: ‘state’
[17:43:48.925] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.925] - Launch lazy future ...
[17:43:48.925] Packages needed by the future expression (n = 0): <none>
[17:43:48.925] Packages needed by future strategies (n = 0): <none>
[17:43:48.926] {
[17:43:48.926]     {
[17:43:48.926]         {
[17:43:48.926]             ...future.startTime <- base::Sys.time()
[17:43:48.926]             {
[17:43:48.926]                 {
[17:43:48.926]                   {
[17:43:48.926]                     {
[17:43:48.926]                       base::local({
[17:43:48.926]                         has_future <- base::requireNamespace("future", 
[17:43:48.926]                           quietly = TRUE)
[17:43:48.926]                         if (has_future) {
[17:43:48.926]                           ns <- base::getNamespace("future")
[17:43:48.926]                           version <- ns[[".package"]][["version"]]
[17:43:48.926]                           if (is.null(version)) 
[17:43:48.926]                             version <- utils::packageVersion("future")
[17:43:48.926]                         }
[17:43:48.926]                         else {
[17:43:48.926]                           version <- NULL
[17:43:48.926]                         }
[17:43:48.926]                         if (!has_future || version < "1.8.0") {
[17:43:48.926]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.926]                             "", base::R.version$version.string), 
[17:43:48.926]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.926]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.926]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.926]                               "release", "version")], collapse = " "), 
[17:43:48.926]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.926]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.926]                             info)
[17:43:48.926]                           info <- base::paste(info, collapse = "; ")
[17:43:48.926]                           if (!has_future) {
[17:43:48.926]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.926]                               info)
[17:43:48.926]                           }
[17:43:48.926]                           else {
[17:43:48.926]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.926]                               info, version)
[17:43:48.926]                           }
[17:43:48.926]                           base::stop(msg)
[17:43:48.926]                         }
[17:43:48.926]                       })
[17:43:48.926]                     }
[17:43:48.926]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.926]                     base::options(mc.cores = 1L)
[17:43:48.926]                   }
[17:43:48.926]                   ...future.strategy.old <- future::plan("list")
[17:43:48.926]                   options(future.plan = NULL)
[17:43:48.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.926]                 }
[17:43:48.926]                 ...future.workdir <- getwd()
[17:43:48.926]             }
[17:43:48.926]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.926]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.926]         }
[17:43:48.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.926]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.926]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.926]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.926]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.926]             base::names(...future.oldOptions))
[17:43:48.926]     }
[17:43:48.926]     if (FALSE) {
[17:43:48.926]     }
[17:43:48.926]     else {
[17:43:48.926]         if (TRUE) {
[17:43:48.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.926]                 open = "w")
[17:43:48.926]         }
[17:43:48.926]         else {
[17:43:48.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.926]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.926]         }
[17:43:48.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.926]             base::sink(type = "output", split = FALSE)
[17:43:48.926]             base::close(...future.stdout)
[17:43:48.926]         }, add = TRUE)
[17:43:48.926]     }
[17:43:48.926]     ...future.frame <- base::sys.nframe()
[17:43:48.926]     ...future.conditions <- base::list()
[17:43:48.926]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.926]     if (FALSE) {
[17:43:48.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.926]     }
[17:43:48.926]     ...future.result <- base::tryCatch({
[17:43:48.926]         base::withCallingHandlers({
[17:43:48.926]             ...future.value <- base::withVisible(base::local({
[17:43:48.926]                 withCallingHandlers({
[17:43:48.926]                   {
[17:43:48.926]                     do.call(function(...) {
[17:43:48.926]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.926]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.926]                         ...future.globals.maxSize)) {
[17:43:48.926]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.926]                         on.exit(options(oopts), add = TRUE)
[17:43:48.926]                       }
[17:43:48.926]                       {
[17:43:48.926]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.926]                           FUN = function(jj) {
[17:43:48.926]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.926]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:48.926]                               envir = globalenv(), inherits = FALSE)
[17:43:48.926]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.926]                           })
[17:43:48.926]                       }
[17:43:48.926]                     }, args = future.call.arguments)
[17:43:48.926]                   }
[17:43:48.926]                 }, immediateCondition = function(cond) {
[17:43:48.926]                   save_rds <- function (object, pathname, ...) 
[17:43:48.926]                   {
[17:43:48.926]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.926]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.926]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.926]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.926]                         fi_tmp[["mtime"]])
[17:43:48.926]                     }
[17:43:48.926]                     tryCatch({
[17:43:48.926]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.926]                     }, error = function(ex) {
[17:43:48.926]                       msg <- conditionMessage(ex)
[17:43:48.926]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.926]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.926]                         fi_tmp[["mtime"]], msg)
[17:43:48.926]                       ex$message <- msg
[17:43:48.926]                       stop(ex)
[17:43:48.926]                     })
[17:43:48.926]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.926]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.926]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.926]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.926]                       fi <- file.info(pathname)
[17:43:48.926]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.926]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.926]                         fi[["size"]], fi[["mtime"]])
[17:43:48.926]                       stop(msg)
[17:43:48.926]                     }
[17:43:48.926]                     invisible(pathname)
[17:43:48.926]                   }
[17:43:48.926]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.926]                     rootPath = tempdir()) 
[17:43:48.926]                   {
[17:43:48.926]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.926]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.926]                       tmpdir = path, fileext = ".rds")
[17:43:48.926]                     save_rds(obj, file)
[17:43:48.926]                   }
[17:43:48.926]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.926]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.926]                   {
[17:43:48.926]                     inherits <- base::inherits
[17:43:48.926]                     invokeRestart <- base::invokeRestart
[17:43:48.926]                     is.null <- base::is.null
[17:43:48.926]                     muffled <- FALSE
[17:43:48.926]                     if (inherits(cond, "message")) {
[17:43:48.926]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.926]                       if (muffled) 
[17:43:48.926]                         invokeRestart("muffleMessage")
[17:43:48.926]                     }
[17:43:48.926]                     else if (inherits(cond, "warning")) {
[17:43:48.926]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.926]                       if (muffled) 
[17:43:48.926]                         invokeRestart("muffleWarning")
[17:43:48.926]                     }
[17:43:48.926]                     else if (inherits(cond, "condition")) {
[17:43:48.926]                       if (!is.null(pattern)) {
[17:43:48.926]                         computeRestarts <- base::computeRestarts
[17:43:48.926]                         grepl <- base::grepl
[17:43:48.926]                         restarts <- computeRestarts(cond)
[17:43:48.926]                         for (restart in restarts) {
[17:43:48.926]                           name <- restart$name
[17:43:48.926]                           if (is.null(name)) 
[17:43:48.926]                             next
[17:43:48.926]                           if (!grepl(pattern, name)) 
[17:43:48.926]                             next
[17:43:48.926]                           invokeRestart(restart)
[17:43:48.926]                           muffled <- TRUE
[17:43:48.926]                           break
[17:43:48.926]                         }
[17:43:48.926]                       }
[17:43:48.926]                     }
[17:43:48.926]                     invisible(muffled)
[17:43:48.926]                   }
[17:43:48.926]                   muffleCondition(cond)
[17:43:48.926]                 })
[17:43:48.926]             }))
[17:43:48.926]             future::FutureResult(value = ...future.value$value, 
[17:43:48.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.926]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.926]                     ...future.globalenv.names))
[17:43:48.926]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.926]         }, condition = base::local({
[17:43:48.926]             c <- base::c
[17:43:48.926]             inherits <- base::inherits
[17:43:48.926]             invokeRestart <- base::invokeRestart
[17:43:48.926]             length <- base::length
[17:43:48.926]             list <- base::list
[17:43:48.926]             seq.int <- base::seq.int
[17:43:48.926]             signalCondition <- base::signalCondition
[17:43:48.926]             sys.calls <- base::sys.calls
[17:43:48.926]             `[[` <- base::`[[`
[17:43:48.926]             `+` <- base::`+`
[17:43:48.926]             `<<-` <- base::`<<-`
[17:43:48.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.926]                   3L)]
[17:43:48.926]             }
[17:43:48.926]             function(cond) {
[17:43:48.926]                 is_error <- inherits(cond, "error")
[17:43:48.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.926]                   NULL)
[17:43:48.926]                 if (is_error) {
[17:43:48.926]                   sessionInformation <- function() {
[17:43:48.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.926]                       search = base::search(), system = base::Sys.info())
[17:43:48.926]                   }
[17:43:48.926]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.926]                     cond$call), session = sessionInformation(), 
[17:43:48.926]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.926]                   signalCondition(cond)
[17:43:48.926]                 }
[17:43:48.926]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:43:48.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.926]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.926]                   if (TRUE && !signal) {
[17:43:48.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.926]                     {
[17:43:48.926]                       inherits <- base::inherits
[17:43:48.926]                       invokeRestart <- base::invokeRestart
[17:43:48.926]                       is.null <- base::is.null
[17:43:48.926]                       muffled <- FALSE
[17:43:48.926]                       if (inherits(cond, "message")) {
[17:43:48.926]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.926]                         if (muffled) 
[17:43:48.926]                           invokeRestart("muffleMessage")
[17:43:48.926]                       }
[17:43:48.926]                       else if (inherits(cond, "warning")) {
[17:43:48.926]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.926]                         if (muffled) 
[17:43:48.926]                           invokeRestart("muffleWarning")
[17:43:48.926]                       }
[17:43:48.926]                       else if (inherits(cond, "condition")) {
[17:43:48.926]                         if (!is.null(pattern)) {
[17:43:48.926]                           computeRestarts <- base::computeRestarts
[17:43:48.926]                           grepl <- base::grepl
[17:43:48.926]                           restarts <- computeRestarts(cond)
[17:43:48.926]                           for (restart in restarts) {
[17:43:48.926]                             name <- restart$name
[17:43:48.926]                             if (is.null(name)) 
[17:43:48.926]                               next
[17:43:48.926]                             if (!grepl(pattern, name)) 
[17:43:48.926]                               next
[17:43:48.926]                             invokeRestart(restart)
[17:43:48.926]                             muffled <- TRUE
[17:43:48.926]                             break
[17:43:48.926]                           }
[17:43:48.926]                         }
[17:43:48.926]                       }
[17:43:48.926]                       invisible(muffled)
[17:43:48.926]                     }
[17:43:48.926]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.926]                   }
[17:43:48.926]                 }
[17:43:48.926]                 else {
[17:43:48.926]                   if (TRUE) {
[17:43:48.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.926]                     {
[17:43:48.926]                       inherits <- base::inherits
[17:43:48.926]                       invokeRestart <- base::invokeRestart
[17:43:48.926]                       is.null <- base::is.null
[17:43:48.926]                       muffled <- FALSE
[17:43:48.926]                       if (inherits(cond, "message")) {
[17:43:48.926]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.926]                         if (muffled) 
[17:43:48.926]                           invokeRestart("muffleMessage")
[17:43:48.926]                       }
[17:43:48.926]                       else if (inherits(cond, "warning")) {
[17:43:48.926]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.926]                         if (muffled) 
[17:43:48.926]                           invokeRestart("muffleWarning")
[17:43:48.926]                       }
[17:43:48.926]                       else if (inherits(cond, "condition")) {
[17:43:48.926]                         if (!is.null(pattern)) {
[17:43:48.926]                           computeRestarts <- base::computeRestarts
[17:43:48.926]                           grepl <- base::grepl
[17:43:48.926]                           restarts <- computeRestarts(cond)
[17:43:48.926]                           for (restart in restarts) {
[17:43:48.926]                             name <- restart$name
[17:43:48.926]                             if (is.null(name)) 
[17:43:48.926]                               next
[17:43:48.926]                             if (!grepl(pattern, name)) 
[17:43:48.926]                               next
[17:43:48.926]                             invokeRestart(restart)
[17:43:48.926]                             muffled <- TRUE
[17:43:48.926]                             break
[17:43:48.926]                           }
[17:43:48.926]                         }
[17:43:48.926]                       }
[17:43:48.926]                       invisible(muffled)
[17:43:48.926]                     }
[17:43:48.926]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.926]                   }
[17:43:48.926]                 }
[17:43:48.926]             }
[17:43:48.926]         }))
[17:43:48.926]     }, error = function(ex) {
[17:43:48.926]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.926]                 ...future.rng), started = ...future.startTime, 
[17:43:48.926]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.926]             version = "1.8"), class = "FutureResult")
[17:43:48.926]     }, finally = {
[17:43:48.926]         if (!identical(...future.workdir, getwd())) 
[17:43:48.926]             setwd(...future.workdir)
[17:43:48.926]         {
[17:43:48.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.926]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.926]             }
[17:43:48.926]             base::options(...future.oldOptions)
[17:43:48.926]             if (.Platform$OS.type == "windows") {
[17:43:48.926]                 old_names <- names(...future.oldEnvVars)
[17:43:48.926]                 envs <- base::Sys.getenv()
[17:43:48.926]                 names <- names(envs)
[17:43:48.926]                 common <- intersect(names, old_names)
[17:43:48.926]                 added <- setdiff(names, old_names)
[17:43:48.926]                 removed <- setdiff(old_names, names)
[17:43:48.926]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.926]                   envs[common]]
[17:43:48.926]                 NAMES <- toupper(changed)
[17:43:48.926]                 args <- list()
[17:43:48.926]                 for (kk in seq_along(NAMES)) {
[17:43:48.926]                   name <- changed[[kk]]
[17:43:48.926]                   NAME <- NAMES[[kk]]
[17:43:48.926]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.926]                     next
[17:43:48.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.926]                 }
[17:43:48.926]                 NAMES <- toupper(added)
[17:43:48.926]                 for (kk in seq_along(NAMES)) {
[17:43:48.926]                   name <- added[[kk]]
[17:43:48.926]                   NAME <- NAMES[[kk]]
[17:43:48.926]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.926]                     next
[17:43:48.926]                   args[[name]] <- ""
[17:43:48.926]                 }
[17:43:48.926]                 NAMES <- toupper(removed)
[17:43:48.926]                 for (kk in seq_along(NAMES)) {
[17:43:48.926]                   name <- removed[[kk]]
[17:43:48.926]                   NAME <- NAMES[[kk]]
[17:43:48.926]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.926]                     next
[17:43:48.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.926]                 }
[17:43:48.926]                 if (length(args) > 0) 
[17:43:48.926]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.926]             }
[17:43:48.926]             else {
[17:43:48.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.926]             }
[17:43:48.926]             {
[17:43:48.926]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.926]                   0L) {
[17:43:48.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.926]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.926]                   base::options(opts)
[17:43:48.926]                 }
[17:43:48.926]                 {
[17:43:48.926]                   {
[17:43:48.926]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.926]                     NULL
[17:43:48.926]                   }
[17:43:48.926]                   options(future.plan = NULL)
[17:43:48.926]                   if (is.na(NA_character_)) 
[17:43:48.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.926]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.926]                     .init = FALSE)
[17:43:48.926]                 }
[17:43:48.926]             }
[17:43:48.926]         }
[17:43:48.926]     })
[17:43:48.926]     if (TRUE) {
[17:43:48.926]         base::sink(type = "output", split = FALSE)
[17:43:48.926]         if (TRUE) {
[17:43:48.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.926]         }
[17:43:48.926]         else {
[17:43:48.926]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.926]         }
[17:43:48.926]         base::close(...future.stdout)
[17:43:48.926]         ...future.stdout <- NULL
[17:43:48.926]     }
[17:43:48.926]     ...future.result$conditions <- ...future.conditions
[17:43:48.926]     ...future.result$finished <- base::Sys.time()
[17:43:48.926]     ...future.result
[17:43:48.926] }
[17:43:48.928] assign_globals() ...
[17:43:48.928] List of 5
[17:43:48.928]  $ future.call.arguments    : list()
[17:43:48.928]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.928]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[17:43:48.928]  $ ...future.elements_ii    :List of 1
[17:43:48.928]   ..$ : int [1:2] 1 3
[17:43:48.928]  $ ...future.seeds_ii       :List of 1
[17:43:48.928]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:43:48.928]  $ ...future.globals.maxSize: num Inf
[17:43:48.928]  - attr(*, "resolved")= logi FALSE
[17:43:48.928]  - attr(*, "total_size")= num NA
[17:43:48.928]  - attr(*, "where")=List of 5
[17:43:48.928]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.928]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.928]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.928]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.928]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.928]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.928]  - attr(*, "already-done")= logi TRUE
[17:43:48.936] - copied ‘future.call.arguments’ to environment
[17:43:48.936] - copied ‘...future.FUN’ to environment
[17:43:48.936] - copied ‘...future.elements_ii’ to environment
[17:43:48.936] - copied ‘...future.seeds_ii’ to environment
[17:43:48.936] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.936] assign_globals() ... done
[17:43:48.936] requestCore(): workers = 2
[17:43:48.939] MulticoreFuture started
[17:43:48.939] - Launch lazy future ... done
[17:43:48.939] run() for ‘MulticoreFuture’ ... done
[17:43:48.940] Created future:
[17:43:48.940] plan(): Setting new future strategy stack:
[17:43:48.940] List of future strategies:
[17:43:48.940] 1. sequential:
[17:43:48.940]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.940]    - tweaked: FALSE
[17:43:48.940]    - call: NULL
[17:43:48.941] plan(): nbrOfWorkers() = 1
[17:43:48.944] plan(): Setting new future strategy stack:
[17:43:48.944] List of future strategies:
[17:43:48.944] 1. multicore:
[17:43:48.944]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.944]    - tweaked: FALSE
[17:43:48.944]    - call: plan(strategy)
[17:43:48.949] plan(): nbrOfWorkers() = 2
[17:43:48.940] MulticoreFuture:
[17:43:48.940] Label: ‘future_apply-1’
[17:43:48.940] Expression:
[17:43:48.940] {
[17:43:48.940]     do.call(function(...) {
[17:43:48.940]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.940]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.940]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.940]             on.exit(options(oopts), add = TRUE)
[17:43:48.940]         }
[17:43:48.940]         {
[17:43:48.940]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.940]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.940]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:48.940]                   envir = globalenv(), inherits = FALSE)
[17:43:48.940]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.940]             })
[17:43:48.940]         }
[17:43:48.940]     }, args = future.call.arguments)
[17:43:48.940] }
[17:43:48.940] Lazy evaluation: FALSE
[17:43:48.940] Asynchronous evaluation: TRUE
[17:43:48.940] Local evaluation: TRUE
[17:43:48.940] Environment: R_GlobalEnv
[17:43:48.940] Capture standard output: TRUE
[17:43:48.940] Capture condition classes: <none>
[17:43:48.940] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.940] Packages: <none>
[17:43:48.940] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:43:48.940] Resolved: TRUE
[17:43:48.940] Value: <not collected>
[17:43:48.940] Conditions captured: <none>
[17:43:48.940] Early signaling: FALSE
[17:43:48.940] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.940] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.950] Chunk #1 of 2 ... DONE
[17:43:48.950] Chunk #2 of 2 ...
[17:43:48.951]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:48.951]  - seeds: [1] <seeds>
[17:43:48.951]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.951] getGlobalsAndPackages() ...
[17:43:48.951] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.952] Resolving globals: FALSE
[17:43:48.952] Tweak future expression to call with '...' arguments ...
[17:43:48.952] {
[17:43:48.952]     do.call(function(...) {
[17:43:48.952]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.952]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.952]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.952]             on.exit(options(oopts), add = TRUE)
[17:43:48.952]         }
[17:43:48.952]         {
[17:43:48.952]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.952]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.952]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:48.952]                   envir = globalenv(), inherits = FALSE)
[17:43:48.952]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.952]             })
[17:43:48.952]         }
[17:43:48.952]     }, args = future.call.arguments)
[17:43:48.952] }
[17:43:48.952] Tweak future expression to call with '...' arguments ... DONE
[17:43:48.953] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:48.953] 
[17:43:48.953] getGlobalsAndPackages() ... DONE
[17:43:48.954] run() for ‘Future’ ...
[17:43:48.954] - state: ‘created’
[17:43:48.954] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.959] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.959] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:48.959]   - Field: ‘label’
[17:43:48.959]   - Field: ‘local’
[17:43:48.959]   - Field: ‘owner’
[17:43:48.960]   - Field: ‘envir’
[17:43:48.960]   - Field: ‘workers’
[17:43:48.960]   - Field: ‘packages’
[17:43:48.960]   - Field: ‘gc’
[17:43:48.960]   - Field: ‘job’
[17:43:48.960]   - Field: ‘conditions’
[17:43:48.961]   - Field: ‘expr’
[17:43:48.961]   - Field: ‘uuid’
[17:43:48.961]   - Field: ‘seed’
[17:43:48.961]   - Field: ‘version’
[17:43:48.961]   - Field: ‘result’
[17:43:48.961]   - Field: ‘asynchronous’
[17:43:48.961]   - Field: ‘calls’
[17:43:48.961]   - Field: ‘globals’
[17:43:48.962]   - Field: ‘stdout’
[17:43:48.962]   - Field: ‘earlySignal’
[17:43:48.962]   - Field: ‘lazy’
[17:43:48.962]   - Field: ‘state’
[17:43:48.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:48.962] - Launch lazy future ...
[17:43:48.963] Packages needed by the future expression (n = 0): <none>
[17:43:48.963] Packages needed by future strategies (n = 0): <none>
[17:43:48.964] {
[17:43:48.964]     {
[17:43:48.964]         {
[17:43:48.964]             ...future.startTime <- base::Sys.time()
[17:43:48.964]             {
[17:43:48.964]                 {
[17:43:48.964]                   {
[17:43:48.964]                     {
[17:43:48.964]                       base::local({
[17:43:48.964]                         has_future <- base::requireNamespace("future", 
[17:43:48.964]                           quietly = TRUE)
[17:43:48.964]                         if (has_future) {
[17:43:48.964]                           ns <- base::getNamespace("future")
[17:43:48.964]                           version <- ns[[".package"]][["version"]]
[17:43:48.964]                           if (is.null(version)) 
[17:43:48.964]                             version <- utils::packageVersion("future")
[17:43:48.964]                         }
[17:43:48.964]                         else {
[17:43:48.964]                           version <- NULL
[17:43:48.964]                         }
[17:43:48.964]                         if (!has_future || version < "1.8.0") {
[17:43:48.964]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.964]                             "", base::R.version$version.string), 
[17:43:48.964]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.964]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.964]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.964]                               "release", "version")], collapse = " "), 
[17:43:48.964]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.964]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.964]                             info)
[17:43:48.964]                           info <- base::paste(info, collapse = "; ")
[17:43:48.964]                           if (!has_future) {
[17:43:48.964]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.964]                               info)
[17:43:48.964]                           }
[17:43:48.964]                           else {
[17:43:48.964]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.964]                               info, version)
[17:43:48.964]                           }
[17:43:48.964]                           base::stop(msg)
[17:43:48.964]                         }
[17:43:48.964]                       })
[17:43:48.964]                     }
[17:43:48.964]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.964]                     base::options(mc.cores = 1L)
[17:43:48.964]                   }
[17:43:48.964]                   ...future.strategy.old <- future::plan("list")
[17:43:48.964]                   options(future.plan = NULL)
[17:43:48.964]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.964]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.964]                 }
[17:43:48.964]                 ...future.workdir <- getwd()
[17:43:48.964]             }
[17:43:48.964]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.964]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.964]         }
[17:43:48.964]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.964]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:48.964]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.964]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.964]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.964]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.964]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.964]             base::names(...future.oldOptions))
[17:43:48.964]     }
[17:43:48.964]     if (FALSE) {
[17:43:48.964]     }
[17:43:48.964]     else {
[17:43:48.964]         if (TRUE) {
[17:43:48.964]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.964]                 open = "w")
[17:43:48.964]         }
[17:43:48.964]         else {
[17:43:48.964]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.964]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.964]         }
[17:43:48.964]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.964]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.964]             base::sink(type = "output", split = FALSE)
[17:43:48.964]             base::close(...future.stdout)
[17:43:48.964]         }, add = TRUE)
[17:43:48.964]     }
[17:43:48.964]     ...future.frame <- base::sys.nframe()
[17:43:48.964]     ...future.conditions <- base::list()
[17:43:48.964]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.964]     if (FALSE) {
[17:43:48.964]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.964]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.964]     }
[17:43:48.964]     ...future.result <- base::tryCatch({
[17:43:48.964]         base::withCallingHandlers({
[17:43:48.964]             ...future.value <- base::withVisible(base::local({
[17:43:48.964]                 withCallingHandlers({
[17:43:48.964]                   {
[17:43:48.964]                     do.call(function(...) {
[17:43:48.964]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.964]                       if (!identical(...future.globals.maxSize.org, 
[17:43:48.964]                         ...future.globals.maxSize)) {
[17:43:48.964]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.964]                         on.exit(options(oopts), add = TRUE)
[17:43:48.964]                       }
[17:43:48.964]                       {
[17:43:48.964]                         lapply(seq_along(...future.elements_ii), 
[17:43:48.964]                           FUN = function(jj) {
[17:43:48.964]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.964]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:48.964]                               envir = globalenv(), inherits = FALSE)
[17:43:48.964]                             ...future.FUN(...future.X_jj, ...)
[17:43:48.964]                           })
[17:43:48.964]                       }
[17:43:48.964]                     }, args = future.call.arguments)
[17:43:48.964]                   }
[17:43:48.964]                 }, immediateCondition = function(cond) {
[17:43:48.964]                   save_rds <- function (object, pathname, ...) 
[17:43:48.964]                   {
[17:43:48.964]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:48.964]                     if (file_test("-f", pathname_tmp)) {
[17:43:48.964]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.964]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:48.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.964]                         fi_tmp[["mtime"]])
[17:43:48.964]                     }
[17:43:48.964]                     tryCatch({
[17:43:48.964]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:48.964]                     }, error = function(ex) {
[17:43:48.964]                       msg <- conditionMessage(ex)
[17:43:48.964]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.964]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:48.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.964]                         fi_tmp[["mtime"]], msg)
[17:43:48.964]                       ex$message <- msg
[17:43:48.964]                       stop(ex)
[17:43:48.964]                     })
[17:43:48.964]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:48.964]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:48.964]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:48.964]                       fi_tmp <- file.info(pathname_tmp)
[17:43:48.964]                       fi <- file.info(pathname)
[17:43:48.964]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:48.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:48.964]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:48.964]                         fi[["size"]], fi[["mtime"]])
[17:43:48.964]                       stop(msg)
[17:43:48.964]                     }
[17:43:48.964]                     invisible(pathname)
[17:43:48.964]                   }
[17:43:48.964]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:48.964]                     rootPath = tempdir()) 
[17:43:48.964]                   {
[17:43:48.964]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:48.964]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:48.964]                       tmpdir = path, fileext = ".rds")
[17:43:48.964]                     save_rds(obj, file)
[17:43:48.964]                   }
[17:43:48.964]                   saveImmediateCondition(cond, path = "/tmp/RtmpRRGhM6/.future/immediateConditions")
[17:43:48.964]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.964]                   {
[17:43:48.964]                     inherits <- base::inherits
[17:43:48.964]                     invokeRestart <- base::invokeRestart
[17:43:48.964]                     is.null <- base::is.null
[17:43:48.964]                     muffled <- FALSE
[17:43:48.964]                     if (inherits(cond, "message")) {
[17:43:48.964]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.964]                       if (muffled) 
[17:43:48.964]                         invokeRestart("muffleMessage")
[17:43:48.964]                     }
[17:43:48.964]                     else if (inherits(cond, "warning")) {
[17:43:48.964]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.964]                       if (muffled) 
[17:43:48.964]                         invokeRestart("muffleWarning")
[17:43:48.964]                     }
[17:43:48.964]                     else if (inherits(cond, "condition")) {
[17:43:48.964]                       if (!is.null(pattern)) {
[17:43:48.964]                         computeRestarts <- base::computeRestarts
[17:43:48.964]                         grepl <- base::grepl
[17:43:48.964]                         restarts <- computeRestarts(cond)
[17:43:48.964]                         for (restart in restarts) {
[17:43:48.964]                           name <- restart$name
[17:43:48.964]                           if (is.null(name)) 
[17:43:48.964]                             next
[17:43:48.964]                           if (!grepl(pattern, name)) 
[17:43:48.964]                             next
[17:43:48.964]                           invokeRestart(restart)
[17:43:48.964]                           muffled <- TRUE
[17:43:48.964]                           break
[17:43:48.964]                         }
[17:43:48.964]                       }
[17:43:48.964]                     }
[17:43:48.964]                     invisible(muffled)
[17:43:48.964]                   }
[17:43:48.964]                   muffleCondition(cond)
[17:43:48.964]                 })
[17:43:48.964]             }))
[17:43:48.964]             future::FutureResult(value = ...future.value$value, 
[17:43:48.964]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.964]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.964]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.964]                     ...future.globalenv.names))
[17:43:48.964]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.964]         }, condition = base::local({
[17:43:48.964]             c <- base::c
[17:43:48.964]             inherits <- base::inherits
[17:43:48.964]             invokeRestart <- base::invokeRestart
[17:43:48.964]             length <- base::length
[17:43:48.964]             list <- base::list
[17:43:48.964]             seq.int <- base::seq.int
[17:43:48.964]             signalCondition <- base::signalCondition
[17:43:48.964]             sys.calls <- base::sys.calls
[17:43:48.964]             `[[` <- base::`[[`
[17:43:48.964]             `+` <- base::`+`
[17:43:48.964]             `<<-` <- base::`<<-`
[17:43:48.964]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.964]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.964]                   3L)]
[17:43:48.964]             }
[17:43:48.964]             function(cond) {
[17:43:48.964]                 is_error <- inherits(cond, "error")
[17:43:48.964]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.964]                   NULL)
[17:43:48.964]                 if (is_error) {
[17:43:48.964]                   sessionInformation <- function() {
[17:43:48.964]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.964]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.964]                       search = base::search(), system = base::Sys.info())
[17:43:48.964]                   }
[17:43:48.964]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.964]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.964]                     cond$call), session = sessionInformation(), 
[17:43:48.964]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.964]                   signalCondition(cond)
[17:43:48.964]                 }
[17:43:48.964]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:43:48.964]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.964]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.964]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.964]                   if (TRUE && !signal) {
[17:43:48.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.964]                     {
[17:43:48.964]                       inherits <- base::inherits
[17:43:48.964]                       invokeRestart <- base::invokeRestart
[17:43:48.964]                       is.null <- base::is.null
[17:43:48.964]                       muffled <- FALSE
[17:43:48.964]                       if (inherits(cond, "message")) {
[17:43:48.964]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.964]                         if (muffled) 
[17:43:48.964]                           invokeRestart("muffleMessage")
[17:43:48.964]                       }
[17:43:48.964]                       else if (inherits(cond, "warning")) {
[17:43:48.964]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.964]                         if (muffled) 
[17:43:48.964]                           invokeRestart("muffleWarning")
[17:43:48.964]                       }
[17:43:48.964]                       else if (inherits(cond, "condition")) {
[17:43:48.964]                         if (!is.null(pattern)) {
[17:43:48.964]                           computeRestarts <- base::computeRestarts
[17:43:48.964]                           grepl <- base::grepl
[17:43:48.964]                           restarts <- computeRestarts(cond)
[17:43:48.964]                           for (restart in restarts) {
[17:43:48.964]                             name <- restart$name
[17:43:48.964]                             if (is.null(name)) 
[17:43:48.964]                               next
[17:43:48.964]                             if (!grepl(pattern, name)) 
[17:43:48.964]                               next
[17:43:48.964]                             invokeRestart(restart)
[17:43:48.964]                             muffled <- TRUE
[17:43:48.964]                             break
[17:43:48.964]                           }
[17:43:48.964]                         }
[17:43:48.964]                       }
[17:43:48.964]                       invisible(muffled)
[17:43:48.964]                     }
[17:43:48.964]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.964]                   }
[17:43:48.964]                 }
[17:43:48.964]                 else {
[17:43:48.964]                   if (TRUE) {
[17:43:48.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.964]                     {
[17:43:48.964]                       inherits <- base::inherits
[17:43:48.964]                       invokeRestart <- base::invokeRestart
[17:43:48.964]                       is.null <- base::is.null
[17:43:48.964]                       muffled <- FALSE
[17:43:48.964]                       if (inherits(cond, "message")) {
[17:43:48.964]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.964]                         if (muffled) 
[17:43:48.964]                           invokeRestart("muffleMessage")
[17:43:48.964]                       }
[17:43:48.964]                       else if (inherits(cond, "warning")) {
[17:43:48.964]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.964]                         if (muffled) 
[17:43:48.964]                           invokeRestart("muffleWarning")
[17:43:48.964]                       }
[17:43:48.964]                       else if (inherits(cond, "condition")) {
[17:43:48.964]                         if (!is.null(pattern)) {
[17:43:48.964]                           computeRestarts <- base::computeRestarts
[17:43:48.964]                           grepl <- base::grepl
[17:43:48.964]                           restarts <- computeRestarts(cond)
[17:43:48.964]                           for (restart in restarts) {
[17:43:48.964]                             name <- restart$name
[17:43:48.964]                             if (is.null(name)) 
[17:43:48.964]                               next
[17:43:48.964]                             if (!grepl(pattern, name)) 
[17:43:48.964]                               next
[17:43:48.964]                             invokeRestart(restart)
[17:43:48.964]                             muffled <- TRUE
[17:43:48.964]                             break
[17:43:48.964]                           }
[17:43:48.964]                         }
[17:43:48.964]                       }
[17:43:48.964]                       invisible(muffled)
[17:43:48.964]                     }
[17:43:48.964]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.964]                   }
[17:43:48.964]                 }
[17:43:48.964]             }
[17:43:48.964]         }))
[17:43:48.964]     }, error = function(ex) {
[17:43:48.964]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.964]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.964]                 ...future.rng), started = ...future.startTime, 
[17:43:48.964]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.964]             version = "1.8"), class = "FutureResult")
[17:43:48.964]     }, finally = {
[17:43:48.964]         if (!identical(...future.workdir, getwd())) 
[17:43:48.964]             setwd(...future.workdir)
[17:43:48.964]         {
[17:43:48.964]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.964]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.964]             }
[17:43:48.964]             base::options(...future.oldOptions)
[17:43:48.964]             if (.Platform$OS.type == "windows") {
[17:43:48.964]                 old_names <- names(...future.oldEnvVars)
[17:43:48.964]                 envs <- base::Sys.getenv()
[17:43:48.964]                 names <- names(envs)
[17:43:48.964]                 common <- intersect(names, old_names)
[17:43:48.964]                 added <- setdiff(names, old_names)
[17:43:48.964]                 removed <- setdiff(old_names, names)
[17:43:48.964]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.964]                   envs[common]]
[17:43:48.964]                 NAMES <- toupper(changed)
[17:43:48.964]                 args <- list()
[17:43:48.964]                 for (kk in seq_along(NAMES)) {
[17:43:48.964]                   name <- changed[[kk]]
[17:43:48.964]                   NAME <- NAMES[[kk]]
[17:43:48.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.964]                     next
[17:43:48.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.964]                 }
[17:43:48.964]                 NAMES <- toupper(added)
[17:43:48.964]                 for (kk in seq_along(NAMES)) {
[17:43:48.964]                   name <- added[[kk]]
[17:43:48.964]                   NAME <- NAMES[[kk]]
[17:43:48.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.964]                     next
[17:43:48.964]                   args[[name]] <- ""
[17:43:48.964]                 }
[17:43:48.964]                 NAMES <- toupper(removed)
[17:43:48.964]                 for (kk in seq_along(NAMES)) {
[17:43:48.964]                   name <- removed[[kk]]
[17:43:48.964]                   NAME <- NAMES[[kk]]
[17:43:48.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.964]                     next
[17:43:48.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.964]                 }
[17:43:48.964]                 if (length(args) > 0) 
[17:43:48.964]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.964]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.964]             }
[17:43:48.964]             else {
[17:43:48.964]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.964]             }
[17:43:48.964]             {
[17:43:48.964]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.964]                   0L) {
[17:43:48.964]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.964]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.964]                   base::options(opts)
[17:43:48.964]                 }
[17:43:48.964]                 {
[17:43:48.964]                   {
[17:43:48.964]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.964]                     NULL
[17:43:48.964]                   }
[17:43:48.964]                   options(future.plan = NULL)
[17:43:48.964]                   if (is.na(NA_character_)) 
[17:43:48.964]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.964]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.964]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:48.964]                     .init = FALSE)
[17:43:48.964]                 }
[17:43:48.964]             }
[17:43:48.964]         }
[17:43:48.964]     })
[17:43:48.964]     if (TRUE) {
[17:43:48.964]         base::sink(type = "output", split = FALSE)
[17:43:48.964]         if (TRUE) {
[17:43:48.964]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.964]         }
[17:43:48.964]         else {
[17:43:48.964]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.964]         }
[17:43:48.964]         base::close(...future.stdout)
[17:43:48.964]         ...future.stdout <- NULL
[17:43:48.964]     }
[17:43:48.964]     ...future.result$conditions <- ...future.conditions
[17:43:48.964]     ...future.result$finished <- base::Sys.time()
[17:43:48.964]     ...future.result
[17:43:48.964] }
[17:43:48.967] assign_globals() ...
[17:43:48.968] List of 5
[17:43:48.968]  $ future.call.arguments    : list()
[17:43:48.968]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:48.968]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[17:43:48.968]  $ ...future.elements_ii    :List of 1
[17:43:48.968]   ..$ : int [1:2] 2 4
[17:43:48.968]  $ ...future.seeds_ii       :List of 1
[17:43:48.968]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:43:48.968]  $ ...future.globals.maxSize: num Inf
[17:43:48.968]  - attr(*, "resolved")= logi FALSE
[17:43:48.968]  - attr(*, "total_size")= num NA
[17:43:48.968]  - attr(*, "where")=List of 5
[17:43:48.968]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:43:48.968]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:43:48.968]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:43:48.968]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:43:48.968]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:43:48.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:48.968]  - attr(*, "already-done")= logi TRUE
[17:43:48.975] - copied ‘future.call.arguments’ to environment
[17:43:48.976] - copied ‘...future.FUN’ to environment
[17:43:48.976] - copied ‘...future.elements_ii’ to environment
[17:43:48.976] - copied ‘...future.seeds_ii’ to environment
[17:43:48.976] - copied ‘...future.globals.maxSize’ to environment
[17:43:48.976] assign_globals() ... done
[17:43:48.976] requestCore(): workers = 2
[17:43:48.979] MulticoreFuture started
[17:43:48.979] - Launch lazy future ... done
[17:43:48.979] run() for ‘MulticoreFuture’ ... done
[17:43:48.979] Created future:
[17:43:48.980] plan(): Setting new future strategy stack:
[17:43:48.980] List of future strategies:
[17:43:48.980] 1. sequential:
[17:43:48.980]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:48.980]    - tweaked: FALSE
[17:43:48.980]    - call: NULL
[17:43:48.981] plan(): nbrOfWorkers() = 1
[17:43:48.988] plan(): Setting new future strategy stack:
[17:43:48.988] List of future strategies:
[17:43:48.988] 1. multicore:
[17:43:48.988]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:48.988]    - tweaked: FALSE
[17:43:48.988]    - call: plan(strategy)
[17:43:48.995] plan(): nbrOfWorkers() = 2
[17:43:48.980] MulticoreFuture:
[17:43:48.980] Label: ‘future_apply-2’
[17:43:48.980] Expression:
[17:43:48.980] {
[17:43:48.980]     do.call(function(...) {
[17:43:48.980]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:48.980]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:48.980]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:48.980]             on.exit(options(oopts), add = TRUE)
[17:43:48.980]         }
[17:43:48.980]         {
[17:43:48.980]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:48.980]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:48.980]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:48.980]                   envir = globalenv(), inherits = FALSE)
[17:43:48.980]                 ...future.FUN(...future.X_jj, ...)
[17:43:48.980]             })
[17:43:48.980]         }
[17:43:48.980]     }, args = future.call.arguments)
[17:43:48.980] }
[17:43:48.980] Lazy evaluation: FALSE
[17:43:48.980] Asynchronous evaluation: TRUE
[17:43:48.980] Local evaluation: TRUE
[17:43:48.980] Environment: R_GlobalEnv
[17:43:48.980] Capture standard output: TRUE
[17:43:48.980] Capture condition classes: <none>
[17:43:48.980] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:48.980] Packages: <none>
[17:43:48.980] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:43:48.980] Resolved: TRUE
[17:43:48.980] Value: <not collected>
[17:43:48.980] Conditions captured: <none>
[17:43:48.980] Early signaling: FALSE
[17:43:48.980] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:48.980] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.996] Chunk #2 of 2 ... DONE
[17:43:48.997] Launching 2 futures (chunks) ... DONE
[17:43:48.997] Resolving 2 futures (chunks) ...
[17:43:48.997] resolve() on list ...
[17:43:48.997]  recursive: 0
[17:43:48.998]  length: 2
[17:43:48.998] 
[17:43:48.998] Future #1
[17:43:48.999] result() for MulticoreFuture ...
[17:43:49.000] result() for MulticoreFuture ...
[17:43:49.000] result() for MulticoreFuture ... done
[17:43:49.000] result() for MulticoreFuture ... done
[17:43:49.001] result() for MulticoreFuture ...
[17:43:49.001] result() for MulticoreFuture ... done
[17:43:49.001] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:43:49.001] - nx: 2
[17:43:49.001] - relay: TRUE
[17:43:49.002] - stdout: TRUE
[17:43:49.002] - signal: TRUE
[17:43:49.002] - resignal: FALSE
[17:43:49.002] - force: TRUE
[17:43:49.002] - relayed: [n=2] FALSE, FALSE
[17:43:49.002] - queued futures: [n=2] FALSE, FALSE
[17:43:49.002]  - until=1
[17:43:49.003]  - relaying element #1
[17:43:49.003] result() for MulticoreFuture ...
[17:43:49.003] result() for MulticoreFuture ... done
[17:43:49.003] result() for MulticoreFuture ...
[17:43:49.003] result() for MulticoreFuture ... done
[17:43:49.004] result() for MulticoreFuture ...
[17:43:49.004] result() for MulticoreFuture ... done
[17:43:49.004] result() for MulticoreFuture ...
[17:43:49.004] result() for MulticoreFuture ... done
[17:43:49.004] - relayed: [n=2] TRUE, FALSE
[17:43:49.004] - queued futures: [n=2] TRUE, FALSE
[17:43:49.005] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:43:49.005]  length: 1 (resolved future 1)
[17:43:49.005] Future #2
[17:43:49.005] result() for MulticoreFuture ...
[17:43:49.006] result() for MulticoreFuture ...
[17:43:49.006] result() for MulticoreFuture ... done
[17:43:49.006] result() for MulticoreFuture ... done
[17:43:49.007] result() for MulticoreFuture ...
[17:43:49.007] result() for MulticoreFuture ... done
[17:43:49.007] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:43:49.007] - nx: 2
[17:43:49.007] - relay: TRUE
[17:43:49.007] - stdout: TRUE
[17:43:49.008] - signal: TRUE
[17:43:49.008] - resignal: FALSE
[17:43:49.008] - force: TRUE
[17:43:49.008] - relayed: [n=2] TRUE, FALSE
[17:43:49.008] - queued futures: [n=2] TRUE, FALSE
[17:43:49.008]  - until=2
[17:43:49.008]  - relaying element #2
[17:43:49.009] result() for MulticoreFuture ...
[17:43:49.009] result() for MulticoreFuture ... done
[17:43:49.009] result() for MulticoreFuture ...
[17:43:49.009] result() for MulticoreFuture ... done
[17:43:49.009] result() for MulticoreFuture ...
[17:43:49.009] result() for MulticoreFuture ... done
[17:43:49.010] result() for MulticoreFuture ...
[17:43:49.010] result() for MulticoreFuture ... done
[17:43:49.010] - relayed: [n=2] TRUE, TRUE
[17:43:49.010] - queued futures: [n=2] TRUE, TRUE
[17:43:49.010] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:43:49.010]  length: 0 (resolved future 2)
[17:43:49.010] Relaying remaining futures
[17:43:49.010] signalConditionsASAP(NULL, pos=0) ...
[17:43:49.010] - nx: 2
[17:43:49.010] - relay: TRUE
[17:43:49.011] - stdout: TRUE
[17:43:49.011] - signal: TRUE
[17:43:49.011] - resignal: FALSE
[17:43:49.011] - force: TRUE
[17:43:49.011] - relayed: [n=2] TRUE, TRUE
[17:43:49.011] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:49.011] - relayed: [n=2] TRUE, TRUE
[17:43:49.011] - queued futures: [n=2] TRUE, TRUE
[17:43:49.011] signalConditionsASAP(NULL, pos=0) ... done
[17:43:49.012] resolve() on list ... DONE
[17:43:49.012] result() for MulticoreFuture ...
[17:43:49.012] result() for MulticoreFuture ... done
[17:43:49.012] result() for MulticoreFuture ...
[17:43:49.012] result() for MulticoreFuture ... done
[17:43:49.012] result() for MulticoreFuture ...
[17:43:49.012] result() for MulticoreFuture ... done
[17:43:49.012] result() for MulticoreFuture ...
[17:43:49.012] result() for MulticoreFuture ... done
[17:43:49.012]  - Number of value chunks collected: 2
[17:43:49.013] Resolving 2 futures (chunks) ... DONE
[17:43:49.013] Reducing values from 2 chunks ...
[17:43:49.013]  - Number of values collected after concatenation: 2
[17:43:49.013]  - Number of values expected: 2
[17:43:49.013] Reducing values from 2 chunks ... DONE
[17:43:49.013] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[17:43:49.013] plan(): Setting new future strategy stack:
[17:43:49.014] List of future strategies:
[17:43:49.014] 1. sequential:
[17:43:49.014]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:49.014]    - tweaked: FALSE
[17:43:49.014]    - call: plan(sequential)
[17:43:49.014] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:43:49.015] plan(): Setting new future strategy stack:
[17:43:49.015] List of future strategies:
[17:43:49.015] 1. multisession:
[17:43:49.015]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:49.015]    - tweaked: FALSE
[17:43:49.015]    - call: plan(strategy)
[17:43:49.015] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:43:49.015] multisession:
[17:43:49.015] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:49.015] - tweaked: FALSE
[17:43:49.015] - call: plan(strategy)
[17:43:49.022] getGlobalsAndPackages() ...
[17:43:49.023] Not searching for globals
[17:43:49.023] - globals: [0] <none>
[17:43:49.023] getGlobalsAndPackages() ... DONE
[17:43:49.023] [local output] makeClusterPSOCK() ...
[17:43:49.072] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:43:49.073] [local output] Base port: 11887
[17:43:49.073] [local output] Getting setup options for 2 cluster nodes ...
[17:43:49.074] [local output]  - Node 1 of 2 ...
[17:43:49.074] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:49.075] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpRRGhM6/worker.rank=1.parallelly.parent=28370.6ed23cc82921.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpRRGhM6/worker.rank=1.parallelly.parent=28370.6ed23cc82921.pid")'’
[17:43:49.266] - Possible to infer worker's PID: TRUE
[17:43:49.266] [local output] Rscript port: 11887

[17:43:49.266] [local output]  - Node 2 of 2 ...
[17:43:49.267] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:49.267] [local output] Rscript port: 11887

[17:43:49.268] [local output] Getting setup options for 2 cluster nodes ... done
[17:43:49.268] [local output]  - Parallel setup requested for some PSOCK nodes
[17:43:49.268] [local output] Setting up PSOCK nodes in parallel
[17:43:49.269] List of 36
[17:43:49.269]  $ worker          : chr "localhost"
[17:43:49.269]   ..- attr(*, "localhost")= logi TRUE
[17:43:49.269]  $ master          : chr "localhost"
[17:43:49.269]  $ port            : int 11887
[17:43:49.269]  $ connectTimeout  : num 120
[17:43:49.269]  $ timeout         : num 2592000
[17:43:49.269]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:43:49.269]  $ homogeneous     : logi TRUE
[17:43:49.269]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:43:49.269]  $ rscript_envs    : NULL
[17:43:49.269]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:49.269]  $ rscript_startup : NULL
[17:43:49.269]  $ rscript_sh      : chr "sh"
[17:43:49.269]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:49.269]  $ methods         : logi TRUE
[17:43:49.269]  $ socketOptions   : chr "no-delay"
[17:43:49.269]  $ useXDR          : logi FALSE
[17:43:49.269]  $ outfile         : chr "/dev/null"
[17:43:49.269]  $ renice          : int NA
[17:43:49.269]  $ rshcmd          : NULL
[17:43:49.269]  $ user            : chr(0) 
[17:43:49.269]  $ revtunnel       : logi FALSE
[17:43:49.269]  $ rshlogfile      : NULL
[17:43:49.269]  $ rshopts         : chr(0) 
[17:43:49.269]  $ rank            : int 1
[17:43:49.269]  $ manual          : logi FALSE
[17:43:49.269]  $ dryrun          : logi FALSE
[17:43:49.269]  $ quiet           : logi FALSE
[17:43:49.269]  $ setup_strategy  : chr "parallel"
[17:43:49.269]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:49.269]  $ pidfile         : chr "/tmp/RtmpRRGhM6/worker.rank=1.parallelly.parent=28370.6ed23cc82921.pid"
[17:43:49.269]  $ rshcmd_label    : NULL
[17:43:49.269]  $ rsh_call        : NULL
[17:43:49.269]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:49.269]  $ localMachine    : logi TRUE
[17:43:49.269]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:43:49.269]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:43:49.269]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:43:49.269]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:43:49.269]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:43:49.269]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:43:49.269]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:43:49.269]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:43:49.269]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:43:49.269]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:43:49.269]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:43:49.269]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:43:49.269]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:43:49.269]  $ arguments       :List of 28
[17:43:49.269]   ..$ worker          : chr "localhost"
[17:43:49.269]   ..$ master          : NULL
[17:43:49.269]   ..$ port            : int 11887
[17:43:49.269]   ..$ connectTimeout  : num 120
[17:43:49.269]   ..$ timeout         : num 2592000
[17:43:49.269]   ..$ rscript         : NULL
[17:43:49.269]   ..$ homogeneous     : NULL
[17:43:49.269]   ..$ rscript_args    : NULL
[17:43:49.269]   ..$ rscript_envs    : NULL
[17:43:49.269]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:49.269]   ..$ rscript_startup : NULL
[17:43:49.269]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:43:49.269]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:49.269]   ..$ methods         : logi TRUE
[17:43:49.269]   ..$ socketOptions   : chr "no-delay"
[17:43:49.269]   ..$ useXDR          : logi FALSE
[17:43:49.269]   ..$ outfile         : chr "/dev/null"
[17:43:49.269]   ..$ renice          : int NA
[17:43:49.269]   ..$ rshcmd          : NULL
[17:43:49.269]   ..$ user            : NULL
[17:43:49.269]   ..$ revtunnel       : logi NA
[17:43:49.269]   ..$ rshlogfile      : NULL
[17:43:49.269]   ..$ rshopts         : NULL
[17:43:49.269]   ..$ rank            : int 1
[17:43:49.269]   ..$ manual          : logi FALSE
[17:43:49.269]   ..$ dryrun          : logi FALSE
[17:43:49.269]   ..$ quiet           : logi FALSE
[17:43:49.269]   ..$ setup_strategy  : chr "parallel"
[17:43:49.269]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:43:49.285] [local output] System call to launch all workers:
[17:43:49.286] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpRRGhM6/worker.rank=1.parallelly.parent=28370.6ed23cc82921.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11887 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:43:49.286] [local output] Starting PSOCK main server
[17:43:49.291] [local output] Workers launched
[17:43:49.292] [local output] Waiting for workers to connect back
[17:43:49.292]  - [local output] 0 workers out of 2 ready
[17:43:49.538]  - [local output] 0 workers out of 2 ready
[17:43:49.538]  - [local output] 1 workers out of 2 ready
[17:43:49.553]  - [local output] 1 workers out of 2 ready
[17:43:49.553]  - [local output] 2 workers out of 2 ready
[17:43:49.553] [local output] Launching of workers completed
[17:43:49.553] [local output] Collecting session information from workers
[17:43:49.554] [local output]  - Worker #1 of 2
[17:43:49.555] [local output]  - Worker #2 of 2
[17:43:49.555] [local output] makeClusterPSOCK() ... done
[17:43:49.567] Packages needed by the future expression (n = 0): <none>
[17:43:49.567] Packages needed by future strategies (n = 0): <none>
[17:43:49.567] {
[17:43:49.567]     {
[17:43:49.567]         {
[17:43:49.567]             ...future.startTime <- base::Sys.time()
[17:43:49.567]             {
[17:43:49.567]                 {
[17:43:49.567]                   {
[17:43:49.567]                     {
[17:43:49.567]                       base::local({
[17:43:49.567]                         has_future <- base::requireNamespace("future", 
[17:43:49.567]                           quietly = TRUE)
[17:43:49.567]                         if (has_future) {
[17:43:49.567]                           ns <- base::getNamespace("future")
[17:43:49.567]                           version <- ns[[".package"]][["version"]]
[17:43:49.567]                           if (is.null(version)) 
[17:43:49.567]                             version <- utils::packageVersion("future")
[17:43:49.567]                         }
[17:43:49.567]                         else {
[17:43:49.567]                           version <- NULL
[17:43:49.567]                         }
[17:43:49.567]                         if (!has_future || version < "1.8.0") {
[17:43:49.567]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:49.567]                             "", base::R.version$version.string), 
[17:43:49.567]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:49.567]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:49.567]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:49.567]                               "release", "version")], collapse = " "), 
[17:43:49.567]                             hostname = base::Sys.info()[["nodename"]])
[17:43:49.567]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:49.567]                             info)
[17:43:49.567]                           info <- base::paste(info, collapse = "; ")
[17:43:49.567]                           if (!has_future) {
[17:43:49.567]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:49.567]                               info)
[17:43:49.567]                           }
[17:43:49.567]                           else {
[17:43:49.567]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:49.567]                               info, version)
[17:43:49.567]                           }
[17:43:49.567]                           base::stop(msg)
[17:43:49.567]                         }
[17:43:49.567]                       })
[17:43:49.567]                     }
[17:43:49.567]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:49.567]                     base::options(mc.cores = 1L)
[17:43:49.567]                   }
[17:43:49.567]                   ...future.strategy.old <- future::plan("list")
[17:43:49.567]                   options(future.plan = NULL)
[17:43:49.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:49.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:49.567]                 }
[17:43:49.567]                 ...future.workdir <- getwd()
[17:43:49.567]             }
[17:43:49.567]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:49.567]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:49.567]         }
[17:43:49.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:49.567]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:49.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:49.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:49.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:49.567]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:49.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:49.567]             base::names(...future.oldOptions))
[17:43:49.567]     }
[17:43:49.567]     if (FALSE) {
[17:43:49.567]     }
[17:43:49.567]     else {
[17:43:49.567]         if (TRUE) {
[17:43:49.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:49.567]                 open = "w")
[17:43:49.567]         }
[17:43:49.567]         else {
[17:43:49.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:49.567]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:49.567]         }
[17:43:49.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:49.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:49.567]             base::sink(type = "output", split = FALSE)
[17:43:49.567]             base::close(...future.stdout)
[17:43:49.567]         }, add = TRUE)
[17:43:49.567]     }
[17:43:49.567]     ...future.frame <- base::sys.nframe()
[17:43:49.567]     ...future.conditions <- base::list()
[17:43:49.567]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:49.567]     if (FALSE) {
[17:43:49.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:49.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:49.567]     }
[17:43:49.567]     ...future.result <- base::tryCatch({
[17:43:49.567]         base::withCallingHandlers({
[17:43:49.567]             ...future.value <- base::withVisible(base::local({
[17:43:49.567]                 ...future.makeSendCondition <- base::local({
[17:43:49.567]                   sendCondition <- NULL
[17:43:49.567]                   function(frame = 1L) {
[17:43:49.567]                     if (is.function(sendCondition)) 
[17:43:49.567]                       return(sendCondition)
[17:43:49.567]                     ns <- getNamespace("parallel")
[17:43:49.567]                     if (exists("sendData", mode = "function", 
[17:43:49.567]                       envir = ns)) {
[17:43:49.567]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:49.567]                         envir = ns)
[17:43:49.567]                       envir <- sys.frame(frame)
[17:43:49.567]                       master <- NULL
[17:43:49.567]                       while (!identical(envir, .GlobalEnv) && 
[17:43:49.567]                         !identical(envir, emptyenv())) {
[17:43:49.567]                         if (exists("master", mode = "list", envir = envir, 
[17:43:49.567]                           inherits = FALSE)) {
[17:43:49.567]                           master <- get("master", mode = "list", 
[17:43:49.567]                             envir = envir, inherits = FALSE)
[17:43:49.567]                           if (inherits(master, c("SOCKnode", 
[17:43:49.567]                             "SOCK0node"))) {
[17:43:49.567]                             sendCondition <<- function(cond) {
[17:43:49.567]                               data <- list(type = "VALUE", value = cond, 
[17:43:49.567]                                 success = TRUE)
[17:43:49.567]                               parallel_sendData(master, data)
[17:43:49.567]                             }
[17:43:49.567]                             return(sendCondition)
[17:43:49.567]                           }
[17:43:49.567]                         }
[17:43:49.567]                         frame <- frame + 1L
[17:43:49.567]                         envir <- sys.frame(frame)
[17:43:49.567]                       }
[17:43:49.567]                     }
[17:43:49.567]                     sendCondition <<- function(cond) NULL
[17:43:49.567]                   }
[17:43:49.567]                 })
[17:43:49.567]                 withCallingHandlers({
[17:43:49.567]                   NA
[17:43:49.567]                 }, immediateCondition = function(cond) {
[17:43:49.567]                   sendCondition <- ...future.makeSendCondition()
[17:43:49.567]                   sendCondition(cond)
[17:43:49.567]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.567]                   {
[17:43:49.567]                     inherits <- base::inherits
[17:43:49.567]                     invokeRestart <- base::invokeRestart
[17:43:49.567]                     is.null <- base::is.null
[17:43:49.567]                     muffled <- FALSE
[17:43:49.567]                     if (inherits(cond, "message")) {
[17:43:49.567]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:49.567]                       if (muffled) 
[17:43:49.567]                         invokeRestart("muffleMessage")
[17:43:49.567]                     }
[17:43:49.567]                     else if (inherits(cond, "warning")) {
[17:43:49.567]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:49.567]                       if (muffled) 
[17:43:49.567]                         invokeRestart("muffleWarning")
[17:43:49.567]                     }
[17:43:49.567]                     else if (inherits(cond, "condition")) {
[17:43:49.567]                       if (!is.null(pattern)) {
[17:43:49.567]                         computeRestarts <- base::computeRestarts
[17:43:49.567]                         grepl <- base::grepl
[17:43:49.567]                         restarts <- computeRestarts(cond)
[17:43:49.567]                         for (restart in restarts) {
[17:43:49.567]                           name <- restart$name
[17:43:49.567]                           if (is.null(name)) 
[17:43:49.567]                             next
[17:43:49.567]                           if (!grepl(pattern, name)) 
[17:43:49.567]                             next
[17:43:49.567]                           invokeRestart(restart)
[17:43:49.567]                           muffled <- TRUE
[17:43:49.567]                           break
[17:43:49.567]                         }
[17:43:49.567]                       }
[17:43:49.567]                     }
[17:43:49.567]                     invisible(muffled)
[17:43:49.567]                   }
[17:43:49.567]                   muffleCondition(cond)
[17:43:49.567]                 })
[17:43:49.567]             }))
[17:43:49.567]             future::FutureResult(value = ...future.value$value, 
[17:43:49.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:49.567]                   ...future.rng), globalenv = if (FALSE) 
[17:43:49.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:49.567]                     ...future.globalenv.names))
[17:43:49.567]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:49.567]         }, condition = base::local({
[17:43:49.567]             c <- base::c
[17:43:49.567]             inherits <- base::inherits
[17:43:49.567]             invokeRestart <- base::invokeRestart
[17:43:49.567]             length <- base::length
[17:43:49.567]             list <- base::list
[17:43:49.567]             seq.int <- base::seq.int
[17:43:49.567]             signalCondition <- base::signalCondition
[17:43:49.567]             sys.calls <- base::sys.calls
[17:43:49.567]             `[[` <- base::`[[`
[17:43:49.567]             `+` <- base::`+`
[17:43:49.567]             `<<-` <- base::`<<-`
[17:43:49.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:49.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:49.567]                   3L)]
[17:43:49.567]             }
[17:43:49.567]             function(cond) {
[17:43:49.567]                 is_error <- inherits(cond, "error")
[17:43:49.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:49.567]                   NULL)
[17:43:49.567]                 if (is_error) {
[17:43:49.567]                   sessionInformation <- function() {
[17:43:49.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:49.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:49.567]                       search = base::search(), system = base::Sys.info())
[17:43:49.567]                   }
[17:43:49.567]                   ...future.conditions[[length(...future.conditions) + 
[17:43:49.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:49.567]                     cond$call), session = sessionInformation(), 
[17:43:49.567]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:49.567]                   signalCondition(cond)
[17:43:49.567]                 }
[17:43:49.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:49.567]                 "immediateCondition"))) {
[17:43:49.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:49.567]                   ...future.conditions[[length(...future.conditions) + 
[17:43:49.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:49.567]                   if (TRUE && !signal) {
[17:43:49.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.567]                     {
[17:43:49.567]                       inherits <- base::inherits
[17:43:49.567]                       invokeRestart <- base::invokeRestart
[17:43:49.567]                       is.null <- base::is.null
[17:43:49.567]                       muffled <- FALSE
[17:43:49.567]                       if (inherits(cond, "message")) {
[17:43:49.567]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:49.567]                         if (muffled) 
[17:43:49.567]                           invokeRestart("muffleMessage")
[17:43:49.567]                       }
[17:43:49.567]                       else if (inherits(cond, "warning")) {
[17:43:49.567]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:49.567]                         if (muffled) 
[17:43:49.567]                           invokeRestart("muffleWarning")
[17:43:49.567]                       }
[17:43:49.567]                       else if (inherits(cond, "condition")) {
[17:43:49.567]                         if (!is.null(pattern)) {
[17:43:49.567]                           computeRestarts <- base::computeRestarts
[17:43:49.567]                           grepl <- base::grepl
[17:43:49.567]                           restarts <- computeRestarts(cond)
[17:43:49.567]                           for (restart in restarts) {
[17:43:49.567]                             name <- restart$name
[17:43:49.567]                             if (is.null(name)) 
[17:43:49.567]                               next
[17:43:49.567]                             if (!grepl(pattern, name)) 
[17:43:49.567]                               next
[17:43:49.567]                             invokeRestart(restart)
[17:43:49.567]                             muffled <- TRUE
[17:43:49.567]                             break
[17:43:49.567]                           }
[17:43:49.567]                         }
[17:43:49.567]                       }
[17:43:49.567]                       invisible(muffled)
[17:43:49.567]                     }
[17:43:49.567]                     muffleCondition(cond, pattern = "^muffle")
[17:43:49.567]                   }
[17:43:49.567]                 }
[17:43:49.567]                 else {
[17:43:49.567]                   if (TRUE) {
[17:43:49.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.567]                     {
[17:43:49.567]                       inherits <- base::inherits
[17:43:49.567]                       invokeRestart <- base::invokeRestart
[17:43:49.567]                       is.null <- base::is.null
[17:43:49.567]                       muffled <- FALSE
[17:43:49.567]                       if (inherits(cond, "message")) {
[17:43:49.567]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:49.567]                         if (muffled) 
[17:43:49.567]                           invokeRestart("muffleMessage")
[17:43:49.567]                       }
[17:43:49.567]                       else if (inherits(cond, "warning")) {
[17:43:49.567]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:49.567]                         if (muffled) 
[17:43:49.567]                           invokeRestart("muffleWarning")
[17:43:49.567]                       }
[17:43:49.567]                       else if (inherits(cond, "condition")) {
[17:43:49.567]                         if (!is.null(pattern)) {
[17:43:49.567]                           computeRestarts <- base::computeRestarts
[17:43:49.567]                           grepl <- base::grepl
[17:43:49.567]                           restarts <- computeRestarts(cond)
[17:43:49.567]                           for (restart in restarts) {
[17:43:49.567]                             name <- restart$name
[17:43:49.567]                             if (is.null(name)) 
[17:43:49.567]                               next
[17:43:49.567]                             if (!grepl(pattern, name)) 
[17:43:49.567]                               next
[17:43:49.567]                             invokeRestart(restart)
[17:43:49.567]                             muffled <- TRUE
[17:43:49.567]                             break
[17:43:49.567]                           }
[17:43:49.567]                         }
[17:43:49.567]                       }
[17:43:49.567]                       invisible(muffled)
[17:43:49.567]                     }
[17:43:49.567]                     muffleCondition(cond, pattern = "^muffle")
[17:43:49.567]                   }
[17:43:49.567]                 }
[17:43:49.567]             }
[17:43:49.567]         }))
[17:43:49.567]     }, error = function(ex) {
[17:43:49.567]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:49.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:49.567]                 ...future.rng), started = ...future.startTime, 
[17:43:49.567]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:49.567]             version = "1.8"), class = "FutureResult")
[17:43:49.567]     }, finally = {
[17:43:49.567]         if (!identical(...future.workdir, getwd())) 
[17:43:49.567]             setwd(...future.workdir)
[17:43:49.567]         {
[17:43:49.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:49.567]                 ...future.oldOptions$nwarnings <- NULL
[17:43:49.567]             }
[17:43:49.567]             base::options(...future.oldOptions)
[17:43:49.567]             if (.Platform$OS.type == "windows") {
[17:43:49.567]                 old_names <- names(...future.oldEnvVars)
[17:43:49.567]                 envs <- base::Sys.getenv()
[17:43:49.567]                 names <- names(envs)
[17:43:49.567]                 common <- intersect(names, old_names)
[17:43:49.567]                 added <- setdiff(names, old_names)
[17:43:49.567]                 removed <- setdiff(old_names, names)
[17:43:49.567]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:49.567]                   envs[common]]
[17:43:49.567]                 NAMES <- toupper(changed)
[17:43:49.567]                 args <- list()
[17:43:49.567]                 for (kk in seq_along(NAMES)) {
[17:43:49.567]                   name <- changed[[kk]]
[17:43:49.567]                   NAME <- NAMES[[kk]]
[17:43:49.567]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.567]                     next
[17:43:49.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:49.567]                 }
[17:43:49.567]                 NAMES <- toupper(added)
[17:43:49.567]                 for (kk in seq_along(NAMES)) {
[17:43:49.567]                   name <- added[[kk]]
[17:43:49.567]                   NAME <- NAMES[[kk]]
[17:43:49.567]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.567]                     next
[17:43:49.567]                   args[[name]] <- ""
[17:43:49.567]                 }
[17:43:49.567]                 NAMES <- toupper(removed)
[17:43:49.567]                 for (kk in seq_along(NAMES)) {
[17:43:49.567]                   name <- removed[[kk]]
[17:43:49.567]                   NAME <- NAMES[[kk]]
[17:43:49.567]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.567]                     next
[17:43:49.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:49.567]                 }
[17:43:49.567]                 if (length(args) > 0) 
[17:43:49.567]                   base::do.call(base::Sys.setenv, args = args)
[17:43:49.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:49.567]             }
[17:43:49.567]             else {
[17:43:49.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:49.567]             }
[17:43:49.567]             {
[17:43:49.567]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:49.567]                   0L) {
[17:43:49.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:49.567]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:49.567]                   base::options(opts)
[17:43:49.567]                 }
[17:43:49.567]                 {
[17:43:49.567]                   {
[17:43:49.567]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:49.567]                     NULL
[17:43:49.567]                   }
[17:43:49.567]                   options(future.plan = NULL)
[17:43:49.567]                   if (is.na(NA_character_)) 
[17:43:49.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:49.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:49.567]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:49.567]                     .init = FALSE)
[17:43:49.567]                 }
[17:43:49.567]             }
[17:43:49.567]         }
[17:43:49.567]     })
[17:43:49.567]     if (TRUE) {
[17:43:49.567]         base::sink(type = "output", split = FALSE)
[17:43:49.567]         if (TRUE) {
[17:43:49.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:49.567]         }
[17:43:49.567]         else {
[17:43:49.567]             ...future.result["stdout"] <- base::list(NULL)
[17:43:49.567]         }
[17:43:49.567]         base::close(...future.stdout)
[17:43:49.567]         ...future.stdout <- NULL
[17:43:49.567]     }
[17:43:49.567]     ...future.result$conditions <- ...future.conditions
[17:43:49.567]     ...future.result$finished <- base::Sys.time()
[17:43:49.567]     ...future.result
[17:43:49.567] }
[17:43:49.619] MultisessionFuture started
[17:43:49.620] result() for ClusterFuture ...
[17:43:49.621] receiveMessageFromWorker() for ClusterFuture ...
[17:43:49.621] - Validating connection of MultisessionFuture
[17:43:49.652] - received message: FutureResult
[17:43:49.653] - Received FutureResult
[17:43:49.653] - Erased future from FutureRegistry
[17:43:49.653] result() for ClusterFuture ...
[17:43:49.653] - result already collected: FutureResult
[17:43:49.653] result() for ClusterFuture ... done
[17:43:49.653] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:49.653] result() for ClusterFuture ... done
[17:43:49.653] result() for ClusterFuture ...
[17:43:49.654] - result already collected: FutureResult
[17:43:49.654] result() for ClusterFuture ... done
[17:43:49.654] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:43:49.658] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[17:43:49.658] getGlobalsAndPackagesXApply() ...
[17:43:49.659]  - future.globals: TRUE
[17:43:49.659] getGlobalsAndPackages() ...
[17:43:49.659] Searching for globals...
[17:43:49.700] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:43:49.701] Searching for globals ... DONE
[17:43:49.701] Resolving globals: FALSE
[17:43:49.705] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:43:49.705] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:43:49.705] - globals: [1] ‘FUN’
[17:43:49.705] 
[17:43:49.705] getGlobalsAndPackages() ... DONE
[17:43:49.706]  - globals found/used: [n=1] ‘FUN’
[17:43:49.706]  - needed namespaces: [n=0] 
[17:43:49.706] Finding globals ... DONE
[17:43:49.706]  - use_args: TRUE
[17:43:49.706]  - Getting '...' globals ...
[17:43:49.706] resolve() on list ...
[17:43:49.706]  recursive: 0
[17:43:49.706]  length: 1
[17:43:49.706]  elements: ‘...’
[17:43:49.707]  length: 0 (resolved future 1)
[17:43:49.707] resolve() on list ... DONE
[17:43:49.707]    - '...' content: [n=0] 
[17:43:49.707] List of 1
[17:43:49.707]  $ ...: list()
[17:43:49.707]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:49.707]  - attr(*, "where")=List of 1
[17:43:49.707]   ..$ ...:<environment: 0x55dfd610b3f8> 
[17:43:49.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:49.707]  - attr(*, "resolved")= logi TRUE
[17:43:49.707]  - attr(*, "total_size")= num NA
[17:43:49.709]  - Getting '...' globals ... DONE
[17:43:49.710] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:49.710] List of 2
[17:43:49.710]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:49.710]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:49.710]  $ ...          : list()
[17:43:49.710]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:49.710]  - attr(*, "where")=List of 2
[17:43:49.710]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:49.710]   ..$ ...          :<environment: 0x55dfd610b3f8> 
[17:43:49.710]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:49.710]  - attr(*, "resolved")= logi FALSE
[17:43:49.710]  - attr(*, "total_size")= num 354224
[17:43:49.712] Packages to be attached in all futures: [n=0] 
[17:43:49.713] getGlobalsAndPackagesXApply() ... DONE
[17:43:49.716] future_lapply() ...
[17:43:49.748] Number of chunks: 2
[17:43:49.749] getGlobalsAndPackagesXApply() ...
[17:43:49.749]  - future.globals: <name-value list> with names ‘list()’
[17:43:49.749]  - use_args: TRUE
[17:43:49.749] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:49.749] List of 2
[17:43:49.749]  $ ...          : list()
[17:43:49.749]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:49.749]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:49.749]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:49.749]  - attr(*, "where")=List of 2
[17:43:49.749]   ..$ ...          :<environment: 0x55dfd610b3f8> 
[17:43:49.749]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:49.749]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:49.749]  - attr(*, "resolved")= logi FALSE
[17:43:49.749]  - attr(*, "total_size")= num NA
[17:43:49.752] Packages to be attached in all futures: [n=0] 
[17:43:49.753] getGlobalsAndPackagesXApply() ... DONE
[17:43:49.753] Number of futures (= number of chunks): 2
[17:43:49.753] Launching 2 futures (chunks) ...
[17:43:49.753] Chunk #1 of 2 ...
[17:43:49.753]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:49.753]  - seeds: <none>
[17:43:49.753]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:49.753] getGlobalsAndPackages() ...
[17:43:49.753] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:49.754] Resolving globals: FALSE
[17:43:49.754] Tweak future expression to call with '...' arguments ...
[17:43:49.754] {
[17:43:49.754]     do.call(function(...) {
[17:43:49.754]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:49.754]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:49.754]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:49.754]             on.exit(options(oopts), add = TRUE)
[17:43:49.754]         }
[17:43:49.754]         {
[17:43:49.754]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:49.754]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:49.754]                 ...future.FUN(...future.X_jj, ...)
[17:43:49.754]             })
[17:43:49.754]         }
[17:43:49.754]     }, args = future.call.arguments)
[17:43:49.754] }
[17:43:49.754] Tweak future expression to call with '...' arguments ... DONE
[17:43:49.754] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:49.755] 
[17:43:49.755] getGlobalsAndPackages() ... DONE
[17:43:49.755] run() for ‘Future’ ...
[17:43:49.755] - state: ‘created’
[17:43:49.755] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:49.769] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:49.769] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:49.769]   - Field: ‘node’
[17:43:49.769]   - Field: ‘label’
[17:43:49.769]   - Field: ‘local’
[17:43:49.769]   - Field: ‘owner’
[17:43:49.769]   - Field: ‘envir’
[17:43:49.769]   - Field: ‘workers’
[17:43:49.769]   - Field: ‘packages’
[17:43:49.770]   - Field: ‘gc’
[17:43:49.770]   - Field: ‘conditions’
[17:43:49.770]   - Field: ‘persistent’
[17:43:49.770]   - Field: ‘expr’
[17:43:49.770]   - Field: ‘uuid’
[17:43:49.770]   - Field: ‘seed’
[17:43:49.770]   - Field: ‘version’
[17:43:49.770]   - Field: ‘result’
[17:43:49.770]   - Field: ‘asynchronous’
[17:43:49.770]   - Field: ‘calls’
[17:43:49.770]   - Field: ‘globals’
[17:43:49.770]   - Field: ‘stdout’
[17:43:49.771]   - Field: ‘earlySignal’
[17:43:49.771]   - Field: ‘lazy’
[17:43:49.771]   - Field: ‘state’
[17:43:49.771] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:49.771] - Launch lazy future ...
[17:43:49.771] Packages needed by the future expression (n = 0): <none>
[17:43:49.771] Packages needed by future strategies (n = 0): <none>
[17:43:49.772] {
[17:43:49.772]     {
[17:43:49.772]         {
[17:43:49.772]             ...future.startTime <- base::Sys.time()
[17:43:49.772]             {
[17:43:49.772]                 {
[17:43:49.772]                   {
[17:43:49.772]                     {
[17:43:49.772]                       base::local({
[17:43:49.772]                         has_future <- base::requireNamespace("future", 
[17:43:49.772]                           quietly = TRUE)
[17:43:49.772]                         if (has_future) {
[17:43:49.772]                           ns <- base::getNamespace("future")
[17:43:49.772]                           version <- ns[[".package"]][["version"]]
[17:43:49.772]                           if (is.null(version)) 
[17:43:49.772]                             version <- utils::packageVersion("future")
[17:43:49.772]                         }
[17:43:49.772]                         else {
[17:43:49.772]                           version <- NULL
[17:43:49.772]                         }
[17:43:49.772]                         if (!has_future || version < "1.8.0") {
[17:43:49.772]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:49.772]                             "", base::R.version$version.string), 
[17:43:49.772]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:49.772]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:49.772]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:49.772]                               "release", "version")], collapse = " "), 
[17:43:49.772]                             hostname = base::Sys.info()[["nodename"]])
[17:43:49.772]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:49.772]                             info)
[17:43:49.772]                           info <- base::paste(info, collapse = "; ")
[17:43:49.772]                           if (!has_future) {
[17:43:49.772]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:49.772]                               info)
[17:43:49.772]                           }
[17:43:49.772]                           else {
[17:43:49.772]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:49.772]                               info, version)
[17:43:49.772]                           }
[17:43:49.772]                           base::stop(msg)
[17:43:49.772]                         }
[17:43:49.772]                       })
[17:43:49.772]                     }
[17:43:49.772]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:49.772]                     base::options(mc.cores = 1L)
[17:43:49.772]                   }
[17:43:49.772]                   ...future.strategy.old <- future::plan("list")
[17:43:49.772]                   options(future.plan = NULL)
[17:43:49.772]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:49.772]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:49.772]                 }
[17:43:49.772]                 ...future.workdir <- getwd()
[17:43:49.772]             }
[17:43:49.772]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:49.772]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:49.772]         }
[17:43:49.772]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:49.772]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:49.772]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:49.772]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:49.772]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:49.772]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:49.772]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:49.772]             base::names(...future.oldOptions))
[17:43:49.772]     }
[17:43:49.772]     if (FALSE) {
[17:43:49.772]     }
[17:43:49.772]     else {
[17:43:49.772]         if (TRUE) {
[17:43:49.772]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:49.772]                 open = "w")
[17:43:49.772]         }
[17:43:49.772]         else {
[17:43:49.772]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:49.772]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:49.772]         }
[17:43:49.772]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:49.772]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:49.772]             base::sink(type = "output", split = FALSE)
[17:43:49.772]             base::close(...future.stdout)
[17:43:49.772]         }, add = TRUE)
[17:43:49.772]     }
[17:43:49.772]     ...future.frame <- base::sys.nframe()
[17:43:49.772]     ...future.conditions <- base::list()
[17:43:49.772]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:49.772]     if (FALSE) {
[17:43:49.772]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:49.772]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:49.772]     }
[17:43:49.772]     ...future.result <- base::tryCatch({
[17:43:49.772]         base::withCallingHandlers({
[17:43:49.772]             ...future.value <- base::withVisible(base::local({
[17:43:49.772]                 ...future.makeSendCondition <- base::local({
[17:43:49.772]                   sendCondition <- NULL
[17:43:49.772]                   function(frame = 1L) {
[17:43:49.772]                     if (is.function(sendCondition)) 
[17:43:49.772]                       return(sendCondition)
[17:43:49.772]                     ns <- getNamespace("parallel")
[17:43:49.772]                     if (exists("sendData", mode = "function", 
[17:43:49.772]                       envir = ns)) {
[17:43:49.772]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:49.772]                         envir = ns)
[17:43:49.772]                       envir <- sys.frame(frame)
[17:43:49.772]                       master <- NULL
[17:43:49.772]                       while (!identical(envir, .GlobalEnv) && 
[17:43:49.772]                         !identical(envir, emptyenv())) {
[17:43:49.772]                         if (exists("master", mode = "list", envir = envir, 
[17:43:49.772]                           inherits = FALSE)) {
[17:43:49.772]                           master <- get("master", mode = "list", 
[17:43:49.772]                             envir = envir, inherits = FALSE)
[17:43:49.772]                           if (inherits(master, c("SOCKnode", 
[17:43:49.772]                             "SOCK0node"))) {
[17:43:49.772]                             sendCondition <<- function(cond) {
[17:43:49.772]                               data <- list(type = "VALUE", value = cond, 
[17:43:49.772]                                 success = TRUE)
[17:43:49.772]                               parallel_sendData(master, data)
[17:43:49.772]                             }
[17:43:49.772]                             return(sendCondition)
[17:43:49.772]                           }
[17:43:49.772]                         }
[17:43:49.772]                         frame <- frame + 1L
[17:43:49.772]                         envir <- sys.frame(frame)
[17:43:49.772]                       }
[17:43:49.772]                     }
[17:43:49.772]                     sendCondition <<- function(cond) NULL
[17:43:49.772]                   }
[17:43:49.772]                 })
[17:43:49.772]                 withCallingHandlers({
[17:43:49.772]                   {
[17:43:49.772]                     do.call(function(...) {
[17:43:49.772]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:49.772]                       if (!identical(...future.globals.maxSize.org, 
[17:43:49.772]                         ...future.globals.maxSize)) {
[17:43:49.772]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:49.772]                         on.exit(options(oopts), add = TRUE)
[17:43:49.772]                       }
[17:43:49.772]                       {
[17:43:49.772]                         lapply(seq_along(...future.elements_ii), 
[17:43:49.772]                           FUN = function(jj) {
[17:43:49.772]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:49.772]                             ...future.FUN(...future.X_jj, ...)
[17:43:49.772]                           })
[17:43:49.772]                       }
[17:43:49.772]                     }, args = future.call.arguments)
[17:43:49.772]                   }
[17:43:49.772]                 }, immediateCondition = function(cond) {
[17:43:49.772]                   sendCondition <- ...future.makeSendCondition()
[17:43:49.772]                   sendCondition(cond)
[17:43:49.772]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.772]                   {
[17:43:49.772]                     inherits <- base::inherits
[17:43:49.772]                     invokeRestart <- base::invokeRestart
[17:43:49.772]                     is.null <- base::is.null
[17:43:49.772]                     muffled <- FALSE
[17:43:49.772]                     if (inherits(cond, "message")) {
[17:43:49.772]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:49.772]                       if (muffled) 
[17:43:49.772]                         invokeRestart("muffleMessage")
[17:43:49.772]                     }
[17:43:49.772]                     else if (inherits(cond, "warning")) {
[17:43:49.772]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:49.772]                       if (muffled) 
[17:43:49.772]                         invokeRestart("muffleWarning")
[17:43:49.772]                     }
[17:43:49.772]                     else if (inherits(cond, "condition")) {
[17:43:49.772]                       if (!is.null(pattern)) {
[17:43:49.772]                         computeRestarts <- base::computeRestarts
[17:43:49.772]                         grepl <- base::grepl
[17:43:49.772]                         restarts <- computeRestarts(cond)
[17:43:49.772]                         for (restart in restarts) {
[17:43:49.772]                           name <- restart$name
[17:43:49.772]                           if (is.null(name)) 
[17:43:49.772]                             next
[17:43:49.772]                           if (!grepl(pattern, name)) 
[17:43:49.772]                             next
[17:43:49.772]                           invokeRestart(restart)
[17:43:49.772]                           muffled <- TRUE
[17:43:49.772]                           break
[17:43:49.772]                         }
[17:43:49.772]                       }
[17:43:49.772]                     }
[17:43:49.772]                     invisible(muffled)
[17:43:49.772]                   }
[17:43:49.772]                   muffleCondition(cond)
[17:43:49.772]                 })
[17:43:49.772]             }))
[17:43:49.772]             future::FutureResult(value = ...future.value$value, 
[17:43:49.772]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:49.772]                   ...future.rng), globalenv = if (FALSE) 
[17:43:49.772]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:49.772]                     ...future.globalenv.names))
[17:43:49.772]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:49.772]         }, condition = base::local({
[17:43:49.772]             c <- base::c
[17:43:49.772]             inherits <- base::inherits
[17:43:49.772]             invokeRestart <- base::invokeRestart
[17:43:49.772]             length <- base::length
[17:43:49.772]             list <- base::list
[17:43:49.772]             seq.int <- base::seq.int
[17:43:49.772]             signalCondition <- base::signalCondition
[17:43:49.772]             sys.calls <- base::sys.calls
[17:43:49.772]             `[[` <- base::`[[`
[17:43:49.772]             `+` <- base::`+`
[17:43:49.772]             `<<-` <- base::`<<-`
[17:43:49.772]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:49.772]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:49.772]                   3L)]
[17:43:49.772]             }
[17:43:49.772]             function(cond) {
[17:43:49.772]                 is_error <- inherits(cond, "error")
[17:43:49.772]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:49.772]                   NULL)
[17:43:49.772]                 if (is_error) {
[17:43:49.772]                   sessionInformation <- function() {
[17:43:49.772]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:49.772]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:49.772]                       search = base::search(), system = base::Sys.info())
[17:43:49.772]                   }
[17:43:49.772]                   ...future.conditions[[length(...future.conditions) + 
[17:43:49.772]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:49.772]                     cond$call), session = sessionInformation(), 
[17:43:49.772]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:49.772]                   signalCondition(cond)
[17:43:49.772]                 }
[17:43:49.772]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:49.772]                 "immediateCondition"))) {
[17:43:49.772]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:49.772]                   ...future.conditions[[length(...future.conditions) + 
[17:43:49.772]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:49.772]                   if (TRUE && !signal) {
[17:43:49.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.772]                     {
[17:43:49.772]                       inherits <- base::inherits
[17:43:49.772]                       invokeRestart <- base::invokeRestart
[17:43:49.772]                       is.null <- base::is.null
[17:43:49.772]                       muffled <- FALSE
[17:43:49.772]                       if (inherits(cond, "message")) {
[17:43:49.772]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:49.772]                         if (muffled) 
[17:43:49.772]                           invokeRestart("muffleMessage")
[17:43:49.772]                       }
[17:43:49.772]                       else if (inherits(cond, "warning")) {
[17:43:49.772]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:49.772]                         if (muffled) 
[17:43:49.772]                           invokeRestart("muffleWarning")
[17:43:49.772]                       }
[17:43:49.772]                       else if (inherits(cond, "condition")) {
[17:43:49.772]                         if (!is.null(pattern)) {
[17:43:49.772]                           computeRestarts <- base::computeRestarts
[17:43:49.772]                           grepl <- base::grepl
[17:43:49.772]                           restarts <- computeRestarts(cond)
[17:43:49.772]                           for (restart in restarts) {
[17:43:49.772]                             name <- restart$name
[17:43:49.772]                             if (is.null(name)) 
[17:43:49.772]                               next
[17:43:49.772]                             if (!grepl(pattern, name)) 
[17:43:49.772]                               next
[17:43:49.772]                             invokeRestart(restart)
[17:43:49.772]                             muffled <- TRUE
[17:43:49.772]                             break
[17:43:49.772]                           }
[17:43:49.772]                         }
[17:43:49.772]                       }
[17:43:49.772]                       invisible(muffled)
[17:43:49.772]                     }
[17:43:49.772]                     muffleCondition(cond, pattern = "^muffle")
[17:43:49.772]                   }
[17:43:49.772]                 }
[17:43:49.772]                 else {
[17:43:49.772]                   if (TRUE) {
[17:43:49.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.772]                     {
[17:43:49.772]                       inherits <- base::inherits
[17:43:49.772]                       invokeRestart <- base::invokeRestart
[17:43:49.772]                       is.null <- base::is.null
[17:43:49.772]                       muffled <- FALSE
[17:43:49.772]                       if (inherits(cond, "message")) {
[17:43:49.772]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:49.772]                         if (muffled) 
[17:43:49.772]                           invokeRestart("muffleMessage")
[17:43:49.772]                       }
[17:43:49.772]                       else if (inherits(cond, "warning")) {
[17:43:49.772]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:49.772]                         if (muffled) 
[17:43:49.772]                           invokeRestart("muffleWarning")
[17:43:49.772]                       }
[17:43:49.772]                       else if (inherits(cond, "condition")) {
[17:43:49.772]                         if (!is.null(pattern)) {
[17:43:49.772]                           computeRestarts <- base::computeRestarts
[17:43:49.772]                           grepl <- base::grepl
[17:43:49.772]                           restarts <- computeRestarts(cond)
[17:43:49.772]                           for (restart in restarts) {
[17:43:49.772]                             name <- restart$name
[17:43:49.772]                             if (is.null(name)) 
[17:43:49.772]                               next
[17:43:49.772]                             if (!grepl(pattern, name)) 
[17:43:49.772]                               next
[17:43:49.772]                             invokeRestart(restart)
[17:43:49.772]                             muffled <- TRUE
[17:43:49.772]                             break
[17:43:49.772]                           }
[17:43:49.772]                         }
[17:43:49.772]                       }
[17:43:49.772]                       invisible(muffled)
[17:43:49.772]                     }
[17:43:49.772]                     muffleCondition(cond, pattern = "^muffle")
[17:43:49.772]                   }
[17:43:49.772]                 }
[17:43:49.772]             }
[17:43:49.772]         }))
[17:43:49.772]     }, error = function(ex) {
[17:43:49.772]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:49.772]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:49.772]                 ...future.rng), started = ...future.startTime, 
[17:43:49.772]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:49.772]             version = "1.8"), class = "FutureResult")
[17:43:49.772]     }, finally = {
[17:43:49.772]         if (!identical(...future.workdir, getwd())) 
[17:43:49.772]             setwd(...future.workdir)
[17:43:49.772]         {
[17:43:49.772]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:49.772]                 ...future.oldOptions$nwarnings <- NULL
[17:43:49.772]             }
[17:43:49.772]             base::options(...future.oldOptions)
[17:43:49.772]             if (.Platform$OS.type == "windows") {
[17:43:49.772]                 old_names <- names(...future.oldEnvVars)
[17:43:49.772]                 envs <- base::Sys.getenv()
[17:43:49.772]                 names <- names(envs)
[17:43:49.772]                 common <- intersect(names, old_names)
[17:43:49.772]                 added <- setdiff(names, old_names)
[17:43:49.772]                 removed <- setdiff(old_names, names)
[17:43:49.772]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:49.772]                   envs[common]]
[17:43:49.772]                 NAMES <- toupper(changed)
[17:43:49.772]                 args <- list()
[17:43:49.772]                 for (kk in seq_along(NAMES)) {
[17:43:49.772]                   name <- changed[[kk]]
[17:43:49.772]                   NAME <- NAMES[[kk]]
[17:43:49.772]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.772]                     next
[17:43:49.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:49.772]                 }
[17:43:49.772]                 NAMES <- toupper(added)
[17:43:49.772]                 for (kk in seq_along(NAMES)) {
[17:43:49.772]                   name <- added[[kk]]
[17:43:49.772]                   NAME <- NAMES[[kk]]
[17:43:49.772]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.772]                     next
[17:43:49.772]                   args[[name]] <- ""
[17:43:49.772]                 }
[17:43:49.772]                 NAMES <- toupper(removed)
[17:43:49.772]                 for (kk in seq_along(NAMES)) {
[17:43:49.772]                   name <- removed[[kk]]
[17:43:49.772]                   NAME <- NAMES[[kk]]
[17:43:49.772]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.772]                     next
[17:43:49.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:49.772]                 }
[17:43:49.772]                 if (length(args) > 0) 
[17:43:49.772]                   base::do.call(base::Sys.setenv, args = args)
[17:43:49.772]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:49.772]             }
[17:43:49.772]             else {
[17:43:49.772]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:49.772]             }
[17:43:49.772]             {
[17:43:49.772]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:49.772]                   0L) {
[17:43:49.772]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:49.772]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:49.772]                   base::options(opts)
[17:43:49.772]                 }
[17:43:49.772]                 {
[17:43:49.772]                   {
[17:43:49.772]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:49.772]                     NULL
[17:43:49.772]                   }
[17:43:49.772]                   options(future.plan = NULL)
[17:43:49.772]                   if (is.na(NA_character_)) 
[17:43:49.772]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:49.772]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:49.772]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:49.772]                     .init = FALSE)
[17:43:49.772]                 }
[17:43:49.772]             }
[17:43:49.772]         }
[17:43:49.772]     })
[17:43:49.772]     if (TRUE) {
[17:43:49.772]         base::sink(type = "output", split = FALSE)
[17:43:49.772]         if (TRUE) {
[17:43:49.772]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:49.772]         }
[17:43:49.772]         else {
[17:43:49.772]             ...future.result["stdout"] <- base::list(NULL)
[17:43:49.772]         }
[17:43:49.772]         base::close(...future.stdout)
[17:43:49.772]         ...future.stdout <- NULL
[17:43:49.772]     }
[17:43:49.772]     ...future.result$conditions <- ...future.conditions
[17:43:49.772]     ...future.result$finished <- base::Sys.time()
[17:43:49.772]     ...future.result
[17:43:49.772] }
[17:43:49.775] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[17:43:49.775] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:49.776] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:49.776] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[17:43:49.820] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[17:43:49.820] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[17:43:49.821] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[17:43:49.821] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:49.821] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:49.821] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:43:49.821] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:43:49.822] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[17:43:49.822] MultisessionFuture started
[17:43:49.822] - Launch lazy future ... done
[17:43:49.822] run() for ‘MultisessionFuture’ ... done
[17:43:49.822] Created future:
[17:43:49.823] MultisessionFuture:
[17:43:49.823] Label: ‘future_apply-1’
[17:43:49.823] Expression:
[17:43:49.823] {
[17:43:49.823]     do.call(function(...) {
[17:43:49.823]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:49.823]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:49.823]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:49.823]             on.exit(options(oopts), add = TRUE)
[17:43:49.823]         }
[17:43:49.823]         {
[17:43:49.823]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:49.823]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:49.823]                 ...future.FUN(...future.X_jj, ...)
[17:43:49.823]             })
[17:43:49.823]         }
[17:43:49.823]     }, args = future.call.arguments)
[17:43:49.823] }
[17:43:49.823] Lazy evaluation: FALSE
[17:43:49.823] Asynchronous evaluation: TRUE
[17:43:49.823] Local evaluation: TRUE
[17:43:49.823] Environment: R_GlobalEnv
[17:43:49.823] Capture standard output: TRUE
[17:43:49.823] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:49.823] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:49.823] Packages: <none>
[17:43:49.823] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:49.823] Resolved: FALSE
[17:43:49.823] Value: <not collected>
[17:43:49.823] Conditions captured: <none>
[17:43:49.823] Early signaling: FALSE
[17:43:49.823] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:49.823] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:49.835] Chunk #1 of 2 ... DONE
[17:43:49.835] Chunk #2 of 2 ...
[17:43:49.835]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:49.835]  - seeds: <none>
[17:43:49.835]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:49.835] getGlobalsAndPackages() ...
[17:43:49.835] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:49.835] Resolving globals: FALSE
[17:43:49.836] Tweak future expression to call with '...' arguments ...
[17:43:49.836] {
[17:43:49.836]     do.call(function(...) {
[17:43:49.836]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:49.836]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:49.836]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:49.836]             on.exit(options(oopts), add = TRUE)
[17:43:49.836]         }
[17:43:49.836]         {
[17:43:49.836]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:49.836]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:49.836]                 ...future.FUN(...future.X_jj, ...)
[17:43:49.836]             })
[17:43:49.836]         }
[17:43:49.836]     }, args = future.call.arguments)
[17:43:49.836] }
[17:43:49.836] Tweak future expression to call with '...' arguments ... DONE
[17:43:49.836] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:49.836] 
[17:43:49.837] getGlobalsAndPackages() ... DONE
[17:43:49.837] run() for ‘Future’ ...
[17:43:49.837] - state: ‘created’
[17:43:49.837] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:49.851] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:49.851] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:49.851]   - Field: ‘node’
[17:43:49.852]   - Field: ‘label’
[17:43:49.852]   - Field: ‘local’
[17:43:49.852]   - Field: ‘owner’
[17:43:49.852]   - Field: ‘envir’
[17:43:49.852]   - Field: ‘workers’
[17:43:49.852]   - Field: ‘packages’
[17:43:49.852]   - Field: ‘gc’
[17:43:49.852]   - Field: ‘conditions’
[17:43:49.852]   - Field: ‘persistent’
[17:43:49.852]   - Field: ‘expr’
[17:43:49.852]   - Field: ‘uuid’
[17:43:49.853]   - Field: ‘seed’
[17:43:49.853]   - Field: ‘version’
[17:43:49.853]   - Field: ‘result’
[17:43:49.853]   - Field: ‘asynchronous’
[17:43:49.853]   - Field: ‘calls’
[17:43:49.853]   - Field: ‘globals’
[17:43:49.853]   - Field: ‘stdout’
[17:43:49.853]   - Field: ‘earlySignal’
[17:43:49.853]   - Field: ‘lazy’
[17:43:49.853]   - Field: ‘state’
[17:43:49.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:49.854] - Launch lazy future ...
[17:43:49.854] Packages needed by the future expression (n = 0): <none>
[17:43:49.854] Packages needed by future strategies (n = 0): <none>
[17:43:49.859] {
[17:43:49.859]     {
[17:43:49.859]         {
[17:43:49.859]             ...future.startTime <- base::Sys.time()
[17:43:49.859]             {
[17:43:49.859]                 {
[17:43:49.859]                   {
[17:43:49.859]                     {
[17:43:49.859]                       base::local({
[17:43:49.859]                         has_future <- base::requireNamespace("future", 
[17:43:49.859]                           quietly = TRUE)
[17:43:49.859]                         if (has_future) {
[17:43:49.859]                           ns <- base::getNamespace("future")
[17:43:49.859]                           version <- ns[[".package"]][["version"]]
[17:43:49.859]                           if (is.null(version)) 
[17:43:49.859]                             version <- utils::packageVersion("future")
[17:43:49.859]                         }
[17:43:49.859]                         else {
[17:43:49.859]                           version <- NULL
[17:43:49.859]                         }
[17:43:49.859]                         if (!has_future || version < "1.8.0") {
[17:43:49.859]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:49.859]                             "", base::R.version$version.string), 
[17:43:49.859]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:49.859]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:49.859]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:49.859]                               "release", "version")], collapse = " "), 
[17:43:49.859]                             hostname = base::Sys.info()[["nodename"]])
[17:43:49.859]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:49.859]                             info)
[17:43:49.859]                           info <- base::paste(info, collapse = "; ")
[17:43:49.859]                           if (!has_future) {
[17:43:49.859]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:49.859]                               info)
[17:43:49.859]                           }
[17:43:49.859]                           else {
[17:43:49.859]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:49.859]                               info, version)
[17:43:49.859]                           }
[17:43:49.859]                           base::stop(msg)
[17:43:49.859]                         }
[17:43:49.859]                       })
[17:43:49.859]                     }
[17:43:49.859]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:49.859]                     base::options(mc.cores = 1L)
[17:43:49.859]                   }
[17:43:49.859]                   ...future.strategy.old <- future::plan("list")
[17:43:49.859]                   options(future.plan = NULL)
[17:43:49.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:49.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:49.859]                 }
[17:43:49.859]                 ...future.workdir <- getwd()
[17:43:49.859]             }
[17:43:49.859]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:49.859]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:49.859]         }
[17:43:49.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:49.859]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:49.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:49.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:49.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:49.859]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:49.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:49.859]             base::names(...future.oldOptions))
[17:43:49.859]     }
[17:43:49.859]     if (FALSE) {
[17:43:49.859]     }
[17:43:49.859]     else {
[17:43:49.859]         if (TRUE) {
[17:43:49.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:49.859]                 open = "w")
[17:43:49.859]         }
[17:43:49.859]         else {
[17:43:49.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:49.859]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:49.859]         }
[17:43:49.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:49.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:49.859]             base::sink(type = "output", split = FALSE)
[17:43:49.859]             base::close(...future.stdout)
[17:43:49.859]         }, add = TRUE)
[17:43:49.859]     }
[17:43:49.859]     ...future.frame <- base::sys.nframe()
[17:43:49.859]     ...future.conditions <- base::list()
[17:43:49.859]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:49.859]     if (FALSE) {
[17:43:49.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:49.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:49.859]     }
[17:43:49.859]     ...future.result <- base::tryCatch({
[17:43:49.859]         base::withCallingHandlers({
[17:43:49.859]             ...future.value <- base::withVisible(base::local({
[17:43:49.859]                 ...future.makeSendCondition <- base::local({
[17:43:49.859]                   sendCondition <- NULL
[17:43:49.859]                   function(frame = 1L) {
[17:43:49.859]                     if (is.function(sendCondition)) 
[17:43:49.859]                       return(sendCondition)
[17:43:49.859]                     ns <- getNamespace("parallel")
[17:43:49.859]                     if (exists("sendData", mode = "function", 
[17:43:49.859]                       envir = ns)) {
[17:43:49.859]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:49.859]                         envir = ns)
[17:43:49.859]                       envir <- sys.frame(frame)
[17:43:49.859]                       master <- NULL
[17:43:49.859]                       while (!identical(envir, .GlobalEnv) && 
[17:43:49.859]                         !identical(envir, emptyenv())) {
[17:43:49.859]                         if (exists("master", mode = "list", envir = envir, 
[17:43:49.859]                           inherits = FALSE)) {
[17:43:49.859]                           master <- get("master", mode = "list", 
[17:43:49.859]                             envir = envir, inherits = FALSE)
[17:43:49.859]                           if (inherits(master, c("SOCKnode", 
[17:43:49.859]                             "SOCK0node"))) {
[17:43:49.859]                             sendCondition <<- function(cond) {
[17:43:49.859]                               data <- list(type = "VALUE", value = cond, 
[17:43:49.859]                                 success = TRUE)
[17:43:49.859]                               parallel_sendData(master, data)
[17:43:49.859]                             }
[17:43:49.859]                             return(sendCondition)
[17:43:49.859]                           }
[17:43:49.859]                         }
[17:43:49.859]                         frame <- frame + 1L
[17:43:49.859]                         envir <- sys.frame(frame)
[17:43:49.859]                       }
[17:43:49.859]                     }
[17:43:49.859]                     sendCondition <<- function(cond) NULL
[17:43:49.859]                   }
[17:43:49.859]                 })
[17:43:49.859]                 withCallingHandlers({
[17:43:49.859]                   {
[17:43:49.859]                     do.call(function(...) {
[17:43:49.859]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:49.859]                       if (!identical(...future.globals.maxSize.org, 
[17:43:49.859]                         ...future.globals.maxSize)) {
[17:43:49.859]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:49.859]                         on.exit(options(oopts), add = TRUE)
[17:43:49.859]                       }
[17:43:49.859]                       {
[17:43:49.859]                         lapply(seq_along(...future.elements_ii), 
[17:43:49.859]                           FUN = function(jj) {
[17:43:49.859]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:49.859]                             ...future.FUN(...future.X_jj, ...)
[17:43:49.859]                           })
[17:43:49.859]                       }
[17:43:49.859]                     }, args = future.call.arguments)
[17:43:49.859]                   }
[17:43:49.859]                 }, immediateCondition = function(cond) {
[17:43:49.859]                   sendCondition <- ...future.makeSendCondition()
[17:43:49.859]                   sendCondition(cond)
[17:43:49.859]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.859]                   {
[17:43:49.859]                     inherits <- base::inherits
[17:43:49.859]                     invokeRestart <- base::invokeRestart
[17:43:49.859]                     is.null <- base::is.null
[17:43:49.859]                     muffled <- FALSE
[17:43:49.859]                     if (inherits(cond, "message")) {
[17:43:49.859]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:49.859]                       if (muffled) 
[17:43:49.859]                         invokeRestart("muffleMessage")
[17:43:49.859]                     }
[17:43:49.859]                     else if (inherits(cond, "warning")) {
[17:43:49.859]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:49.859]                       if (muffled) 
[17:43:49.859]                         invokeRestart("muffleWarning")
[17:43:49.859]                     }
[17:43:49.859]                     else if (inherits(cond, "condition")) {
[17:43:49.859]                       if (!is.null(pattern)) {
[17:43:49.859]                         computeRestarts <- base::computeRestarts
[17:43:49.859]                         grepl <- base::grepl
[17:43:49.859]                         restarts <- computeRestarts(cond)
[17:43:49.859]                         for (restart in restarts) {
[17:43:49.859]                           name <- restart$name
[17:43:49.859]                           if (is.null(name)) 
[17:43:49.859]                             next
[17:43:49.859]                           if (!grepl(pattern, name)) 
[17:43:49.859]                             next
[17:43:49.859]                           invokeRestart(restart)
[17:43:49.859]                           muffled <- TRUE
[17:43:49.859]                           break
[17:43:49.859]                         }
[17:43:49.859]                       }
[17:43:49.859]                     }
[17:43:49.859]                     invisible(muffled)
[17:43:49.859]                   }
[17:43:49.859]                   muffleCondition(cond)
[17:43:49.859]                 })
[17:43:49.859]             }))
[17:43:49.859]             future::FutureResult(value = ...future.value$value, 
[17:43:49.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:49.859]                   ...future.rng), globalenv = if (FALSE) 
[17:43:49.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:49.859]                     ...future.globalenv.names))
[17:43:49.859]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:49.859]         }, condition = base::local({
[17:43:49.859]             c <- base::c
[17:43:49.859]             inherits <- base::inherits
[17:43:49.859]             invokeRestart <- base::invokeRestart
[17:43:49.859]             length <- base::length
[17:43:49.859]             list <- base::list
[17:43:49.859]             seq.int <- base::seq.int
[17:43:49.859]             signalCondition <- base::signalCondition
[17:43:49.859]             sys.calls <- base::sys.calls
[17:43:49.859]             `[[` <- base::`[[`
[17:43:49.859]             `+` <- base::`+`
[17:43:49.859]             `<<-` <- base::`<<-`
[17:43:49.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:49.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:49.859]                   3L)]
[17:43:49.859]             }
[17:43:49.859]             function(cond) {
[17:43:49.859]                 is_error <- inherits(cond, "error")
[17:43:49.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:49.859]                   NULL)
[17:43:49.859]                 if (is_error) {
[17:43:49.859]                   sessionInformation <- function() {
[17:43:49.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:49.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:49.859]                       search = base::search(), system = base::Sys.info())
[17:43:49.859]                   }
[17:43:49.859]                   ...future.conditions[[length(...future.conditions) + 
[17:43:49.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:49.859]                     cond$call), session = sessionInformation(), 
[17:43:49.859]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:49.859]                   signalCondition(cond)
[17:43:49.859]                 }
[17:43:49.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:49.859]                 "immediateCondition"))) {
[17:43:49.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:49.859]                   ...future.conditions[[length(...future.conditions) + 
[17:43:49.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:49.859]                   if (TRUE && !signal) {
[17:43:49.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.859]                     {
[17:43:49.859]                       inherits <- base::inherits
[17:43:49.859]                       invokeRestart <- base::invokeRestart
[17:43:49.859]                       is.null <- base::is.null
[17:43:49.859]                       muffled <- FALSE
[17:43:49.859]                       if (inherits(cond, "message")) {
[17:43:49.859]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:49.859]                         if (muffled) 
[17:43:49.859]                           invokeRestart("muffleMessage")
[17:43:49.859]                       }
[17:43:49.859]                       else if (inherits(cond, "warning")) {
[17:43:49.859]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:49.859]                         if (muffled) 
[17:43:49.859]                           invokeRestart("muffleWarning")
[17:43:49.859]                       }
[17:43:49.859]                       else if (inherits(cond, "condition")) {
[17:43:49.859]                         if (!is.null(pattern)) {
[17:43:49.859]                           computeRestarts <- base::computeRestarts
[17:43:49.859]                           grepl <- base::grepl
[17:43:49.859]                           restarts <- computeRestarts(cond)
[17:43:49.859]                           for (restart in restarts) {
[17:43:49.859]                             name <- restart$name
[17:43:49.859]                             if (is.null(name)) 
[17:43:49.859]                               next
[17:43:49.859]                             if (!grepl(pattern, name)) 
[17:43:49.859]                               next
[17:43:49.859]                             invokeRestart(restart)
[17:43:49.859]                             muffled <- TRUE
[17:43:49.859]                             break
[17:43:49.859]                           }
[17:43:49.859]                         }
[17:43:49.859]                       }
[17:43:49.859]                       invisible(muffled)
[17:43:49.859]                     }
[17:43:49.859]                     muffleCondition(cond, pattern = "^muffle")
[17:43:49.859]                   }
[17:43:49.859]                 }
[17:43:49.859]                 else {
[17:43:49.859]                   if (TRUE) {
[17:43:49.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.859]                     {
[17:43:49.859]                       inherits <- base::inherits
[17:43:49.859]                       invokeRestart <- base::invokeRestart
[17:43:49.859]                       is.null <- base::is.null
[17:43:49.859]                       muffled <- FALSE
[17:43:49.859]                       if (inherits(cond, "message")) {
[17:43:49.859]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:49.859]                         if (muffled) 
[17:43:49.859]                           invokeRestart("muffleMessage")
[17:43:49.859]                       }
[17:43:49.859]                       else if (inherits(cond, "warning")) {
[17:43:49.859]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:49.859]                         if (muffled) 
[17:43:49.859]                           invokeRestart("muffleWarning")
[17:43:49.859]                       }
[17:43:49.859]                       else if (inherits(cond, "condition")) {
[17:43:49.859]                         if (!is.null(pattern)) {
[17:43:49.859]                           computeRestarts <- base::computeRestarts
[17:43:49.859]                           grepl <- base::grepl
[17:43:49.859]                           restarts <- computeRestarts(cond)
[17:43:49.859]                           for (restart in restarts) {
[17:43:49.859]                             name <- restart$name
[17:43:49.859]                             if (is.null(name)) 
[17:43:49.859]                               next
[17:43:49.859]                             if (!grepl(pattern, name)) 
[17:43:49.859]                               next
[17:43:49.859]                             invokeRestart(restart)
[17:43:49.859]                             muffled <- TRUE
[17:43:49.859]                             break
[17:43:49.859]                           }
[17:43:49.859]                         }
[17:43:49.859]                       }
[17:43:49.859]                       invisible(muffled)
[17:43:49.859]                     }
[17:43:49.859]                     muffleCondition(cond, pattern = "^muffle")
[17:43:49.859]                   }
[17:43:49.859]                 }
[17:43:49.859]             }
[17:43:49.859]         }))
[17:43:49.859]     }, error = function(ex) {
[17:43:49.859]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:49.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:49.859]                 ...future.rng), started = ...future.startTime, 
[17:43:49.859]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:49.859]             version = "1.8"), class = "FutureResult")
[17:43:49.859]     }, finally = {
[17:43:49.859]         if (!identical(...future.workdir, getwd())) 
[17:43:49.859]             setwd(...future.workdir)
[17:43:49.859]         {
[17:43:49.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:49.859]                 ...future.oldOptions$nwarnings <- NULL
[17:43:49.859]             }
[17:43:49.859]             base::options(...future.oldOptions)
[17:43:49.859]             if (.Platform$OS.type == "windows") {
[17:43:49.859]                 old_names <- names(...future.oldEnvVars)
[17:43:49.859]                 envs <- base::Sys.getenv()
[17:43:49.859]                 names <- names(envs)
[17:43:49.859]                 common <- intersect(names, old_names)
[17:43:49.859]                 added <- setdiff(names, old_names)
[17:43:49.859]                 removed <- setdiff(old_names, names)
[17:43:49.859]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:49.859]                   envs[common]]
[17:43:49.859]                 NAMES <- toupper(changed)
[17:43:49.859]                 args <- list()
[17:43:49.859]                 for (kk in seq_along(NAMES)) {
[17:43:49.859]                   name <- changed[[kk]]
[17:43:49.859]                   NAME <- NAMES[[kk]]
[17:43:49.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.859]                     next
[17:43:49.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:49.859]                 }
[17:43:49.859]                 NAMES <- toupper(added)
[17:43:49.859]                 for (kk in seq_along(NAMES)) {
[17:43:49.859]                   name <- added[[kk]]
[17:43:49.859]                   NAME <- NAMES[[kk]]
[17:43:49.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.859]                     next
[17:43:49.859]                   args[[name]] <- ""
[17:43:49.859]                 }
[17:43:49.859]                 NAMES <- toupper(removed)
[17:43:49.859]                 for (kk in seq_along(NAMES)) {
[17:43:49.859]                   name <- removed[[kk]]
[17:43:49.859]                   NAME <- NAMES[[kk]]
[17:43:49.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.859]                     next
[17:43:49.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:49.859]                 }
[17:43:49.859]                 if (length(args) > 0) 
[17:43:49.859]                   base::do.call(base::Sys.setenv, args = args)
[17:43:49.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:49.859]             }
[17:43:49.859]             else {
[17:43:49.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:49.859]             }
[17:43:49.859]             {
[17:43:49.859]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:49.859]                   0L) {
[17:43:49.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:49.859]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:49.859]                   base::options(opts)
[17:43:49.859]                 }
[17:43:49.859]                 {
[17:43:49.859]                   {
[17:43:49.859]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:49.859]                     NULL
[17:43:49.859]                   }
[17:43:49.859]                   options(future.plan = NULL)
[17:43:49.859]                   if (is.na(NA_character_)) 
[17:43:49.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:49.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:49.859]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:49.859]                     .init = FALSE)
[17:43:49.859]                 }
[17:43:49.859]             }
[17:43:49.859]         }
[17:43:49.859]     })
[17:43:49.859]     if (TRUE) {
[17:43:49.859]         base::sink(type = "output", split = FALSE)
[17:43:49.859]         if (TRUE) {
[17:43:49.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:49.859]         }
[17:43:49.859]         else {
[17:43:49.859]             ...future.result["stdout"] <- base::list(NULL)
[17:43:49.859]         }
[17:43:49.859]         base::close(...future.stdout)
[17:43:49.859]         ...future.stdout <- NULL
[17:43:49.859]     }
[17:43:49.859]     ...future.result$conditions <- ...future.conditions
[17:43:49.859]     ...future.result$finished <- base::Sys.time()
[17:43:49.859]     ...future.result
[17:43:49.859] }
[17:43:49.911] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[17:43:49.912] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:49.912] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:49.912] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[17:43:49.956] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[17:43:49.956] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[17:43:49.957] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[17:43:49.957] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:49.957] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:49.957] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:43:49.957] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:43:49.958] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[17:43:49.958] MultisessionFuture started
[17:43:49.958] - Launch lazy future ... done
[17:43:49.958] run() for ‘MultisessionFuture’ ... done
[17:43:49.958] Created future:
[17:43:49.959] MultisessionFuture:
[17:43:49.959] Label: ‘future_apply-2’
[17:43:49.959] Expression:
[17:43:49.959] {
[17:43:49.959]     do.call(function(...) {
[17:43:49.959]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:49.959]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:49.959]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:49.959]             on.exit(options(oopts), add = TRUE)
[17:43:49.959]         }
[17:43:49.959]         {
[17:43:49.959]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:49.959]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:49.959]                 ...future.FUN(...future.X_jj, ...)
[17:43:49.959]             })
[17:43:49.959]         }
[17:43:49.959]     }, args = future.call.arguments)
[17:43:49.959] }
[17:43:49.959] Lazy evaluation: FALSE
[17:43:49.959] Asynchronous evaluation: TRUE
[17:43:49.959] Local evaluation: TRUE
[17:43:49.959] Environment: R_GlobalEnv
[17:43:49.959] Capture standard output: TRUE
[17:43:49.959] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:49.959] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:49.959] Packages: <none>
[17:43:49.959] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:49.959] Resolved: FALSE
[17:43:49.959] Value: <not collected>
[17:43:49.959] Conditions captured: <none>
[17:43:49.959] Early signaling: FALSE
[17:43:49.959] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:49.959] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:49.970] Chunk #2 of 2 ... DONE
[17:43:49.970] Launching 2 futures (chunks) ... DONE
[17:43:49.971] Resolving 2 futures (chunks) ...
[17:43:49.971] resolve() on list ...
[17:43:49.971]  recursive: 0
[17:43:49.971]  length: 2
[17:43:49.971] 
[17:43:49.972] receiveMessageFromWorker() for ClusterFuture ...
[17:43:49.972] - Validating connection of MultisessionFuture
[17:43:49.972] - received message: FutureResult
[17:43:49.972] - Received FutureResult
[17:43:49.972] - Erased future from FutureRegistry
[17:43:49.972] result() for ClusterFuture ...
[17:43:49.972] - result already collected: FutureResult
[17:43:49.972] result() for ClusterFuture ... done
[17:43:49.972] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:49.973] Future #1
[17:43:49.973] result() for ClusterFuture ...
[17:43:49.973] - result already collected: FutureResult
[17:43:49.973] result() for ClusterFuture ... done
[17:43:49.973] result() for ClusterFuture ...
[17:43:49.973] - result already collected: FutureResult
[17:43:49.973] result() for ClusterFuture ... done
[17:43:49.973] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:49.973] - nx: 2
[17:43:49.973] - relay: TRUE
[17:43:49.973] - stdout: TRUE
[17:43:49.973] - signal: TRUE
[17:43:49.974] - resignal: FALSE
[17:43:49.974] - force: TRUE
[17:43:49.974] - relayed: [n=2] FALSE, FALSE
[17:43:49.974] - queued futures: [n=2] FALSE, FALSE
[17:43:49.974]  - until=1
[17:43:49.974]  - relaying element #1
[17:43:49.974] result() for ClusterFuture ...
[17:43:49.974] - result already collected: FutureResult
[17:43:49.974] result() for ClusterFuture ... done
[17:43:49.974] result() for ClusterFuture ...
[17:43:49.974] - result already collected: FutureResult
[17:43:49.975] result() for ClusterFuture ... done
[17:43:49.975] result() for ClusterFuture ...
[17:43:49.975] - result already collected: FutureResult
[17:43:49.975] result() for ClusterFuture ... done
[17:43:49.975] result() for ClusterFuture ...
[17:43:49.975] - result already collected: FutureResult
[17:43:49.975] result() for ClusterFuture ... done
[17:43:49.975] - relayed: [n=2] TRUE, FALSE
[17:43:49.975] - queued futures: [n=2] TRUE, FALSE
[17:43:49.975] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:49.975]  length: 1 (resolved future 1)
[17:43:50.038] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.038] - Validating connection of MultisessionFuture
[17:43:50.038] - received message: FutureResult
[17:43:50.039] - Received FutureResult
[17:43:50.039] - Erased future from FutureRegistry
[17:43:50.039] result() for ClusterFuture ...
[17:43:50.039] - result already collected: FutureResult
[17:43:50.039] result() for ClusterFuture ... done
[17:43:50.039] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.039] Future #2
[17:43:50.039] result() for ClusterFuture ...
[17:43:50.039] - result already collected: FutureResult
[17:43:50.039] result() for ClusterFuture ... done
[17:43:50.040] result() for ClusterFuture ...
[17:43:50.040] - result already collected: FutureResult
[17:43:50.040] result() for ClusterFuture ... done
[17:43:50.040] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:50.040] - nx: 2
[17:43:50.040] - relay: TRUE
[17:43:50.040] - stdout: TRUE
[17:43:50.040] - signal: TRUE
[17:43:50.040] - resignal: FALSE
[17:43:50.040] - force: TRUE
[17:43:50.040] - relayed: [n=2] TRUE, FALSE
[17:43:50.040] - queued futures: [n=2] TRUE, FALSE
[17:43:50.041]  - until=2
[17:43:50.041]  - relaying element #2
[17:43:50.041] result() for ClusterFuture ...
[17:43:50.041] - result already collected: FutureResult
[17:43:50.041] result() for ClusterFuture ... done
[17:43:50.041] result() for ClusterFuture ...
[17:43:50.041] - result already collected: FutureResult
[17:43:50.041] result() for ClusterFuture ... done
[17:43:50.041] result() for ClusterFuture ...
[17:43:50.041] - result already collected: FutureResult
[17:43:50.041] result() for ClusterFuture ... done
[17:43:50.042] result() for ClusterFuture ...
[17:43:50.042] - result already collected: FutureResult
[17:43:50.042] result() for ClusterFuture ... done
[17:43:50.042] - relayed: [n=2] TRUE, TRUE
[17:43:50.042] - queued futures: [n=2] TRUE, TRUE
[17:43:50.042] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:50.042]  length: 0 (resolved future 2)
[17:43:50.042] Relaying remaining futures
[17:43:50.042] signalConditionsASAP(NULL, pos=0) ...
[17:43:50.042] - nx: 2
[17:43:50.042] - relay: TRUE
[17:43:50.043] - stdout: TRUE
[17:43:50.043] - signal: TRUE
[17:43:50.043] - resignal: FALSE
[17:43:50.043] - force: TRUE
[17:43:50.043] - relayed: [n=2] TRUE, TRUE
[17:43:50.043] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:50.043] - relayed: [n=2] TRUE, TRUE
[17:43:50.043] - queued futures: [n=2] TRUE, TRUE
[17:43:50.043] signalConditionsASAP(NULL, pos=0) ... done
[17:43:50.043] resolve() on list ... DONE
[17:43:50.043] result() for ClusterFuture ...
[17:43:50.044] - result already collected: FutureResult
[17:43:50.044] result() for ClusterFuture ... done
[17:43:50.044] result() for ClusterFuture ...
[17:43:50.044] - result already collected: FutureResult
[17:43:50.044] result() for ClusterFuture ... done
[17:43:50.044] result() for ClusterFuture ...
[17:43:50.044] - result already collected: FutureResult
[17:43:50.044] result() for ClusterFuture ... done
[17:43:50.044] result() for ClusterFuture ...
[17:43:50.044] - result already collected: FutureResult
[17:43:50.044] result() for ClusterFuture ... done
[17:43:50.045]  - Number of value chunks collected: 2
[17:43:50.045] Resolving 2 futures (chunks) ... DONE
[17:43:50.045] Reducing values from 2 chunks ...
[17:43:50.045]  - Number of values collected after concatenation: 2
[17:43:50.045]  - Number of values expected: 2
[17:43:50.045] Reducing values from 2 chunks ... DONE
[17:43:50.045] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:43:50.045] getGlobalsAndPackagesXApply() ...
[17:43:50.046]  - future.globals: TRUE
[17:43:50.046] getGlobalsAndPackages() ...
[17:43:50.046] Searching for globals...
[17:43:50.077] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[17:43:50.077] Searching for globals ... DONE
[17:43:50.077] Resolving globals: FALSE
[17:43:50.079] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[17:43:50.080] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[17:43:50.080] - globals: [1] ‘FUN’
[17:43:50.080] 
[17:43:50.080] getGlobalsAndPackages() ... DONE
[17:43:50.080]  - globals found/used: [n=1] ‘FUN’
[17:43:50.080]  - needed namespaces: [n=0] 
[17:43:50.080] Finding globals ... DONE
[17:43:50.080]  - use_args: TRUE
[17:43:50.080]  - Getting '...' globals ...
[17:43:50.081] resolve() on list ...
[17:43:50.081]  recursive: 0
[17:43:50.081]  length: 1
[17:43:50.081]  elements: ‘...’
[17:43:50.081]  length: 0 (resolved future 1)
[17:43:50.081] resolve() on list ... DONE
[17:43:50.081]    - '...' content: [n=0] 
[17:43:50.081] List of 1
[17:43:50.081]  $ ...: list()
[17:43:50.081]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.081]  - attr(*, "where")=List of 1
[17:43:50.081]   ..$ ...:<environment: 0x55dfd35a7428> 
[17:43:50.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.081]  - attr(*, "resolved")= logi TRUE
[17:43:50.081]  - attr(*, "total_size")= num NA
[17:43:50.084]  - Getting '...' globals ... DONE
[17:43:50.084] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:50.084] List of 2
[17:43:50.084]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:50.084]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:50.084]  $ ...          : list()
[17:43:50.084]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.084]  - attr(*, "where")=List of 2
[17:43:50.084]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:50.084]   ..$ ...          :<environment: 0x55dfd35a7428> 
[17:43:50.084]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.084]  - attr(*, "resolved")= logi FALSE
[17:43:50.084]  - attr(*, "total_size")= num 354224
[17:43:50.087] Packages to be attached in all futures: [n=0] 
[17:43:50.087] getGlobalsAndPackagesXApply() ... DONE
[17:43:50.091] future_lapply() ...
[17:43:50.125] Number of chunks: 2
[17:43:50.125] getGlobalsAndPackagesXApply() ...
[17:43:50.125]  - future.globals: <name-value list> with names ‘list()’
[17:43:50.125]  - use_args: TRUE
[17:43:50.125] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:50.126] List of 2
[17:43:50.126]  $ ...          : list()
[17:43:50.126]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.126]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[17:43:50.126]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[17:43:50.126]  - attr(*, "where")=List of 2
[17:43:50.126]   ..$ ...          :<environment: 0x55dfd35a7428> 
[17:43:50.126]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:50.126]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.126]  - attr(*, "resolved")= logi FALSE
[17:43:50.126]  - attr(*, "total_size")= num NA
[17:43:50.129] Packages to be attached in all futures: [n=0] 
[17:43:50.129] getGlobalsAndPackagesXApply() ... DONE
[17:43:50.129] Number of futures (= number of chunks): 2
[17:43:50.130] Launching 2 futures (chunks) ...
[17:43:50.130] Chunk #1 of 2 ...
[17:43:50.130]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:50.130]  - seeds: <none>
[17:43:50.130]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.130] getGlobalsAndPackages() ...
[17:43:50.130] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.130] Resolving globals: FALSE
[17:43:50.130] Tweak future expression to call with '...' arguments ...
[17:43:50.131] {
[17:43:50.131]     do.call(function(...) {
[17:43:50.131]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.131]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.131]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.131]             on.exit(options(oopts), add = TRUE)
[17:43:50.131]         }
[17:43:50.131]         {
[17:43:50.131]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.131]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.131]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.131]             })
[17:43:50.131]         }
[17:43:50.131]     }, args = future.call.arguments)
[17:43:50.131] }
[17:43:50.131] Tweak future expression to call with '...' arguments ... DONE
[17:43:50.131] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.131] 
[17:43:50.131] getGlobalsAndPackages() ... DONE
[17:43:50.132] run() for ‘Future’ ...
[17:43:50.132] - state: ‘created’
[17:43:50.132] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.145] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.145] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.145]   - Field: ‘node’
[17:43:50.146]   - Field: ‘label’
[17:43:50.146]   - Field: ‘local’
[17:43:50.146]   - Field: ‘owner’
[17:43:50.146]   - Field: ‘envir’
[17:43:50.146]   - Field: ‘workers’
[17:43:50.146]   - Field: ‘packages’
[17:43:50.146]   - Field: ‘gc’
[17:43:50.146]   - Field: ‘conditions’
[17:43:50.146]   - Field: ‘persistent’
[17:43:50.146]   - Field: ‘expr’
[17:43:50.147]   - Field: ‘uuid’
[17:43:50.147]   - Field: ‘seed’
[17:43:50.147]   - Field: ‘version’
[17:43:50.147]   - Field: ‘result’
[17:43:50.147]   - Field: ‘asynchronous’
[17:43:50.147]   - Field: ‘calls’
[17:43:50.147]   - Field: ‘globals’
[17:43:50.147]   - Field: ‘stdout’
[17:43:50.147]   - Field: ‘earlySignal’
[17:43:50.147]   - Field: ‘lazy’
[17:43:50.147]   - Field: ‘state’
[17:43:50.148] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.148] - Launch lazy future ...
[17:43:50.148] Packages needed by the future expression (n = 0): <none>
[17:43:50.148] Packages needed by future strategies (n = 0): <none>
[17:43:50.148] {
[17:43:50.148]     {
[17:43:50.148]         {
[17:43:50.148]             ...future.startTime <- base::Sys.time()
[17:43:50.148]             {
[17:43:50.148]                 {
[17:43:50.148]                   {
[17:43:50.148]                     {
[17:43:50.148]                       base::local({
[17:43:50.148]                         has_future <- base::requireNamespace("future", 
[17:43:50.148]                           quietly = TRUE)
[17:43:50.148]                         if (has_future) {
[17:43:50.148]                           ns <- base::getNamespace("future")
[17:43:50.148]                           version <- ns[[".package"]][["version"]]
[17:43:50.148]                           if (is.null(version)) 
[17:43:50.148]                             version <- utils::packageVersion("future")
[17:43:50.148]                         }
[17:43:50.148]                         else {
[17:43:50.148]                           version <- NULL
[17:43:50.148]                         }
[17:43:50.148]                         if (!has_future || version < "1.8.0") {
[17:43:50.148]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.148]                             "", base::R.version$version.string), 
[17:43:50.148]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:50.148]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:50.148]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.148]                               "release", "version")], collapse = " "), 
[17:43:50.148]                             hostname = base::Sys.info()[["nodename"]])
[17:43:50.148]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.148]                             info)
[17:43:50.148]                           info <- base::paste(info, collapse = "; ")
[17:43:50.148]                           if (!has_future) {
[17:43:50.148]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.148]                               info)
[17:43:50.148]                           }
[17:43:50.148]                           else {
[17:43:50.148]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.148]                               info, version)
[17:43:50.148]                           }
[17:43:50.148]                           base::stop(msg)
[17:43:50.148]                         }
[17:43:50.148]                       })
[17:43:50.148]                     }
[17:43:50.148]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.148]                     base::options(mc.cores = 1L)
[17:43:50.148]                   }
[17:43:50.148]                   ...future.strategy.old <- future::plan("list")
[17:43:50.148]                   options(future.plan = NULL)
[17:43:50.148]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.148]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.148]                 }
[17:43:50.148]                 ...future.workdir <- getwd()
[17:43:50.148]             }
[17:43:50.148]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.148]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.148]         }
[17:43:50.148]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.148]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:50.148]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.148]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.148]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.148]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.148]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.148]             base::names(...future.oldOptions))
[17:43:50.148]     }
[17:43:50.148]     if (FALSE) {
[17:43:50.148]     }
[17:43:50.148]     else {
[17:43:50.148]         if (TRUE) {
[17:43:50.148]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.148]                 open = "w")
[17:43:50.148]         }
[17:43:50.148]         else {
[17:43:50.148]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.148]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.148]         }
[17:43:50.148]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.148]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.148]             base::sink(type = "output", split = FALSE)
[17:43:50.148]             base::close(...future.stdout)
[17:43:50.148]         }, add = TRUE)
[17:43:50.148]     }
[17:43:50.148]     ...future.frame <- base::sys.nframe()
[17:43:50.148]     ...future.conditions <- base::list()
[17:43:50.148]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.148]     if (FALSE) {
[17:43:50.148]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.148]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.148]     }
[17:43:50.148]     ...future.result <- base::tryCatch({
[17:43:50.148]         base::withCallingHandlers({
[17:43:50.148]             ...future.value <- base::withVisible(base::local({
[17:43:50.148]                 ...future.makeSendCondition <- base::local({
[17:43:50.148]                   sendCondition <- NULL
[17:43:50.148]                   function(frame = 1L) {
[17:43:50.148]                     if (is.function(sendCondition)) 
[17:43:50.148]                       return(sendCondition)
[17:43:50.148]                     ns <- getNamespace("parallel")
[17:43:50.148]                     if (exists("sendData", mode = "function", 
[17:43:50.148]                       envir = ns)) {
[17:43:50.148]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.148]                         envir = ns)
[17:43:50.148]                       envir <- sys.frame(frame)
[17:43:50.148]                       master <- NULL
[17:43:50.148]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.148]                         !identical(envir, emptyenv())) {
[17:43:50.148]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.148]                           inherits = FALSE)) {
[17:43:50.148]                           master <- get("master", mode = "list", 
[17:43:50.148]                             envir = envir, inherits = FALSE)
[17:43:50.148]                           if (inherits(master, c("SOCKnode", 
[17:43:50.148]                             "SOCK0node"))) {
[17:43:50.148]                             sendCondition <<- function(cond) {
[17:43:50.148]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.148]                                 success = TRUE)
[17:43:50.148]                               parallel_sendData(master, data)
[17:43:50.148]                             }
[17:43:50.148]                             return(sendCondition)
[17:43:50.148]                           }
[17:43:50.148]                         }
[17:43:50.148]                         frame <- frame + 1L
[17:43:50.148]                         envir <- sys.frame(frame)
[17:43:50.148]                       }
[17:43:50.148]                     }
[17:43:50.148]                     sendCondition <<- function(cond) NULL
[17:43:50.148]                   }
[17:43:50.148]                 })
[17:43:50.148]                 withCallingHandlers({
[17:43:50.148]                   {
[17:43:50.148]                     do.call(function(...) {
[17:43:50.148]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.148]                       if (!identical(...future.globals.maxSize.org, 
[17:43:50.148]                         ...future.globals.maxSize)) {
[17:43:50.148]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.148]                         on.exit(options(oopts), add = TRUE)
[17:43:50.148]                       }
[17:43:50.148]                       {
[17:43:50.148]                         lapply(seq_along(...future.elements_ii), 
[17:43:50.148]                           FUN = function(jj) {
[17:43:50.148]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.148]                             ...future.FUN(...future.X_jj, ...)
[17:43:50.148]                           })
[17:43:50.148]                       }
[17:43:50.148]                     }, args = future.call.arguments)
[17:43:50.148]                   }
[17:43:50.148]                 }, immediateCondition = function(cond) {
[17:43:50.148]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.148]                   sendCondition(cond)
[17:43:50.148]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.148]                   {
[17:43:50.148]                     inherits <- base::inherits
[17:43:50.148]                     invokeRestart <- base::invokeRestart
[17:43:50.148]                     is.null <- base::is.null
[17:43:50.148]                     muffled <- FALSE
[17:43:50.148]                     if (inherits(cond, "message")) {
[17:43:50.148]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.148]                       if (muffled) 
[17:43:50.148]                         invokeRestart("muffleMessage")
[17:43:50.148]                     }
[17:43:50.148]                     else if (inherits(cond, "warning")) {
[17:43:50.148]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.148]                       if (muffled) 
[17:43:50.148]                         invokeRestart("muffleWarning")
[17:43:50.148]                     }
[17:43:50.148]                     else if (inherits(cond, "condition")) {
[17:43:50.148]                       if (!is.null(pattern)) {
[17:43:50.148]                         computeRestarts <- base::computeRestarts
[17:43:50.148]                         grepl <- base::grepl
[17:43:50.148]                         restarts <- computeRestarts(cond)
[17:43:50.148]                         for (restart in restarts) {
[17:43:50.148]                           name <- restart$name
[17:43:50.148]                           if (is.null(name)) 
[17:43:50.148]                             next
[17:43:50.148]                           if (!grepl(pattern, name)) 
[17:43:50.148]                             next
[17:43:50.148]                           invokeRestart(restart)
[17:43:50.148]                           muffled <- TRUE
[17:43:50.148]                           break
[17:43:50.148]                         }
[17:43:50.148]                       }
[17:43:50.148]                     }
[17:43:50.148]                     invisible(muffled)
[17:43:50.148]                   }
[17:43:50.148]                   muffleCondition(cond)
[17:43:50.148]                 })
[17:43:50.148]             }))
[17:43:50.148]             future::FutureResult(value = ...future.value$value, 
[17:43:50.148]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.148]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.148]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.148]                     ...future.globalenv.names))
[17:43:50.148]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.148]         }, condition = base::local({
[17:43:50.148]             c <- base::c
[17:43:50.148]             inherits <- base::inherits
[17:43:50.148]             invokeRestart <- base::invokeRestart
[17:43:50.148]             length <- base::length
[17:43:50.148]             list <- base::list
[17:43:50.148]             seq.int <- base::seq.int
[17:43:50.148]             signalCondition <- base::signalCondition
[17:43:50.148]             sys.calls <- base::sys.calls
[17:43:50.148]             `[[` <- base::`[[`
[17:43:50.148]             `+` <- base::`+`
[17:43:50.148]             `<<-` <- base::`<<-`
[17:43:50.148]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.148]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.148]                   3L)]
[17:43:50.148]             }
[17:43:50.148]             function(cond) {
[17:43:50.148]                 is_error <- inherits(cond, "error")
[17:43:50.148]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.148]                   NULL)
[17:43:50.148]                 if (is_error) {
[17:43:50.148]                   sessionInformation <- function() {
[17:43:50.148]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.148]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.148]                       search = base::search(), system = base::Sys.info())
[17:43:50.148]                   }
[17:43:50.148]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.148]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.148]                     cond$call), session = sessionInformation(), 
[17:43:50.148]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.148]                   signalCondition(cond)
[17:43:50.148]                 }
[17:43:50.148]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.148]                 "immediateCondition"))) {
[17:43:50.148]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.148]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.148]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.148]                   if (TRUE && !signal) {
[17:43:50.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.148]                     {
[17:43:50.148]                       inherits <- base::inherits
[17:43:50.148]                       invokeRestart <- base::invokeRestart
[17:43:50.148]                       is.null <- base::is.null
[17:43:50.148]                       muffled <- FALSE
[17:43:50.148]                       if (inherits(cond, "message")) {
[17:43:50.148]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.148]                         if (muffled) 
[17:43:50.148]                           invokeRestart("muffleMessage")
[17:43:50.148]                       }
[17:43:50.148]                       else if (inherits(cond, "warning")) {
[17:43:50.148]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.148]                         if (muffled) 
[17:43:50.148]                           invokeRestart("muffleWarning")
[17:43:50.148]                       }
[17:43:50.148]                       else if (inherits(cond, "condition")) {
[17:43:50.148]                         if (!is.null(pattern)) {
[17:43:50.148]                           computeRestarts <- base::computeRestarts
[17:43:50.148]                           grepl <- base::grepl
[17:43:50.148]                           restarts <- computeRestarts(cond)
[17:43:50.148]                           for (restart in restarts) {
[17:43:50.148]                             name <- restart$name
[17:43:50.148]                             if (is.null(name)) 
[17:43:50.148]                               next
[17:43:50.148]                             if (!grepl(pattern, name)) 
[17:43:50.148]                               next
[17:43:50.148]                             invokeRestart(restart)
[17:43:50.148]                             muffled <- TRUE
[17:43:50.148]                             break
[17:43:50.148]                           }
[17:43:50.148]                         }
[17:43:50.148]                       }
[17:43:50.148]                       invisible(muffled)
[17:43:50.148]                     }
[17:43:50.148]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.148]                   }
[17:43:50.148]                 }
[17:43:50.148]                 else {
[17:43:50.148]                   if (TRUE) {
[17:43:50.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.148]                     {
[17:43:50.148]                       inherits <- base::inherits
[17:43:50.148]                       invokeRestart <- base::invokeRestart
[17:43:50.148]                       is.null <- base::is.null
[17:43:50.148]                       muffled <- FALSE
[17:43:50.148]                       if (inherits(cond, "message")) {
[17:43:50.148]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.148]                         if (muffled) 
[17:43:50.148]                           invokeRestart("muffleMessage")
[17:43:50.148]                       }
[17:43:50.148]                       else if (inherits(cond, "warning")) {
[17:43:50.148]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.148]                         if (muffled) 
[17:43:50.148]                           invokeRestart("muffleWarning")
[17:43:50.148]                       }
[17:43:50.148]                       else if (inherits(cond, "condition")) {
[17:43:50.148]                         if (!is.null(pattern)) {
[17:43:50.148]                           computeRestarts <- base::computeRestarts
[17:43:50.148]                           grepl <- base::grepl
[17:43:50.148]                           restarts <- computeRestarts(cond)
[17:43:50.148]                           for (restart in restarts) {
[17:43:50.148]                             name <- restart$name
[17:43:50.148]                             if (is.null(name)) 
[17:43:50.148]                               next
[17:43:50.148]                             if (!grepl(pattern, name)) 
[17:43:50.148]                               next
[17:43:50.148]                             invokeRestart(restart)
[17:43:50.148]                             muffled <- TRUE
[17:43:50.148]                             break
[17:43:50.148]                           }
[17:43:50.148]                         }
[17:43:50.148]                       }
[17:43:50.148]                       invisible(muffled)
[17:43:50.148]                     }
[17:43:50.148]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.148]                   }
[17:43:50.148]                 }
[17:43:50.148]             }
[17:43:50.148]         }))
[17:43:50.148]     }, error = function(ex) {
[17:43:50.148]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.148]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.148]                 ...future.rng), started = ...future.startTime, 
[17:43:50.148]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.148]             version = "1.8"), class = "FutureResult")
[17:43:50.148]     }, finally = {
[17:43:50.148]         if (!identical(...future.workdir, getwd())) 
[17:43:50.148]             setwd(...future.workdir)
[17:43:50.148]         {
[17:43:50.148]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.148]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.148]             }
[17:43:50.148]             base::options(...future.oldOptions)
[17:43:50.148]             if (.Platform$OS.type == "windows") {
[17:43:50.148]                 old_names <- names(...future.oldEnvVars)
[17:43:50.148]                 envs <- base::Sys.getenv()
[17:43:50.148]                 names <- names(envs)
[17:43:50.148]                 common <- intersect(names, old_names)
[17:43:50.148]                 added <- setdiff(names, old_names)
[17:43:50.148]                 removed <- setdiff(old_names, names)
[17:43:50.148]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.148]                   envs[common]]
[17:43:50.148]                 NAMES <- toupper(changed)
[17:43:50.148]                 args <- list()
[17:43:50.148]                 for (kk in seq_along(NAMES)) {
[17:43:50.148]                   name <- changed[[kk]]
[17:43:50.148]                   NAME <- NAMES[[kk]]
[17:43:50.148]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.148]                     next
[17:43:50.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.148]                 }
[17:43:50.148]                 NAMES <- toupper(added)
[17:43:50.148]                 for (kk in seq_along(NAMES)) {
[17:43:50.148]                   name <- added[[kk]]
[17:43:50.148]                   NAME <- NAMES[[kk]]
[17:43:50.148]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.148]                     next
[17:43:50.148]                   args[[name]] <- ""
[17:43:50.148]                 }
[17:43:50.148]                 NAMES <- toupper(removed)
[17:43:50.148]                 for (kk in seq_along(NAMES)) {
[17:43:50.148]                   name <- removed[[kk]]
[17:43:50.148]                   NAME <- NAMES[[kk]]
[17:43:50.148]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.148]                     next
[17:43:50.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.148]                 }
[17:43:50.148]                 if (length(args) > 0) 
[17:43:50.148]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.148]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.148]             }
[17:43:50.148]             else {
[17:43:50.148]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.148]             }
[17:43:50.148]             {
[17:43:50.148]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.148]                   0L) {
[17:43:50.148]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.148]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.148]                   base::options(opts)
[17:43:50.148]                 }
[17:43:50.148]                 {
[17:43:50.148]                   {
[17:43:50.148]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.148]                     NULL
[17:43:50.148]                   }
[17:43:50.148]                   options(future.plan = NULL)
[17:43:50.148]                   if (is.na(NA_character_)) 
[17:43:50.148]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.148]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.148]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:50.148]                     .init = FALSE)
[17:43:50.148]                 }
[17:43:50.148]             }
[17:43:50.148]         }
[17:43:50.148]     })
[17:43:50.148]     if (TRUE) {
[17:43:50.148]         base::sink(type = "output", split = FALSE)
[17:43:50.148]         if (TRUE) {
[17:43:50.148]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.148]         }
[17:43:50.148]         else {
[17:43:50.148]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.148]         }
[17:43:50.148]         base::close(...future.stdout)
[17:43:50.148]         ...future.stdout <- NULL
[17:43:50.148]     }
[17:43:50.148]     ...future.result$conditions <- ...future.conditions
[17:43:50.148]     ...future.result$finished <- base::Sys.time()
[17:43:50.148]     ...future.result
[17:43:50.148] }
[17:43:50.152] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[17:43:50.152] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:50.152] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:50.153] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[17:43:50.203] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[17:43:50.204] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[17:43:50.204] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[17:43:50.204] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:50.205] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:50.205] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:43:50.205] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:43:50.205] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[17:43:50.206] MultisessionFuture started
[17:43:50.206] - Launch lazy future ... done
[17:43:50.206] run() for ‘MultisessionFuture’ ... done
[17:43:50.206] Created future:
[17:43:50.207] MultisessionFuture:
[17:43:50.207] Label: ‘future_apply-1’
[17:43:50.207] Expression:
[17:43:50.207] {
[17:43:50.207]     do.call(function(...) {
[17:43:50.207]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.207]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.207]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.207]             on.exit(options(oopts), add = TRUE)
[17:43:50.207]         }
[17:43:50.207]         {
[17:43:50.207]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.207]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.207]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.207]             })
[17:43:50.207]         }
[17:43:50.207]     }, args = future.call.arguments)
[17:43:50.207] }
[17:43:50.207] Lazy evaluation: FALSE
[17:43:50.207] Asynchronous evaluation: TRUE
[17:43:50.207] Local evaluation: TRUE
[17:43:50.207] Environment: R_GlobalEnv
[17:43:50.207] Capture standard output: TRUE
[17:43:50.207] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:50.207] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:50.207] Packages: <none>
[17:43:50.207] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:50.207] Resolved: FALSE
[17:43:50.207] Value: <not collected>
[17:43:50.207] Conditions captured: <none>
[17:43:50.207] Early signaling: FALSE
[17:43:50.207] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:50.207] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.218] Chunk #1 of 2 ... DONE
[17:43:50.219] Chunk #2 of 2 ...
[17:43:50.219]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:50.219]  - seeds: <none>
[17:43:50.219]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.219] getGlobalsAndPackages() ...
[17:43:50.220] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.220] Resolving globals: FALSE
[17:43:50.220] Tweak future expression to call with '...' arguments ...
[17:43:50.220] {
[17:43:50.220]     do.call(function(...) {
[17:43:50.220]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.220]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.220]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.220]             on.exit(options(oopts), add = TRUE)
[17:43:50.220]         }
[17:43:50.220]         {
[17:43:50.220]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.220]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.220]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.220]             })
[17:43:50.220]         }
[17:43:50.220]     }, args = future.call.arguments)
[17:43:50.220] }
[17:43:50.220] Tweak future expression to call with '...' arguments ... DONE
[17:43:50.221] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.221] 
[17:43:50.221] getGlobalsAndPackages() ... DONE
[17:43:50.221] run() for ‘Future’ ...
[17:43:50.221] - state: ‘created’
[17:43:50.221] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.235] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.236] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.236]   - Field: ‘node’
[17:43:50.236]   - Field: ‘label’
[17:43:50.236]   - Field: ‘local’
[17:43:50.236]   - Field: ‘owner’
[17:43:50.236]   - Field: ‘envir’
[17:43:50.236]   - Field: ‘workers’
[17:43:50.236]   - Field: ‘packages’
[17:43:50.236]   - Field: ‘gc’
[17:43:50.237]   - Field: ‘conditions’
[17:43:50.237]   - Field: ‘persistent’
[17:43:50.237]   - Field: ‘expr’
[17:43:50.237]   - Field: ‘uuid’
[17:43:50.237]   - Field: ‘seed’
[17:43:50.237]   - Field: ‘version’
[17:43:50.237]   - Field: ‘result’
[17:43:50.237]   - Field: ‘asynchronous’
[17:43:50.237]   - Field: ‘calls’
[17:43:50.237]   - Field: ‘globals’
[17:43:50.237]   - Field: ‘stdout’
[17:43:50.238]   - Field: ‘earlySignal’
[17:43:50.238]   - Field: ‘lazy’
[17:43:50.238]   - Field: ‘state’
[17:43:50.238] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.238] - Launch lazy future ...
[17:43:50.238] Packages needed by the future expression (n = 0): <none>
[17:43:50.238] Packages needed by future strategies (n = 0): <none>
[17:43:50.239] {
[17:43:50.239]     {
[17:43:50.239]         {
[17:43:50.239]             ...future.startTime <- base::Sys.time()
[17:43:50.239]             {
[17:43:50.239]                 {
[17:43:50.239]                   {
[17:43:50.239]                     {
[17:43:50.239]                       base::local({
[17:43:50.239]                         has_future <- base::requireNamespace("future", 
[17:43:50.239]                           quietly = TRUE)
[17:43:50.239]                         if (has_future) {
[17:43:50.239]                           ns <- base::getNamespace("future")
[17:43:50.239]                           version <- ns[[".package"]][["version"]]
[17:43:50.239]                           if (is.null(version)) 
[17:43:50.239]                             version <- utils::packageVersion("future")
[17:43:50.239]                         }
[17:43:50.239]                         else {
[17:43:50.239]                           version <- NULL
[17:43:50.239]                         }
[17:43:50.239]                         if (!has_future || version < "1.8.0") {
[17:43:50.239]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.239]                             "", base::R.version$version.string), 
[17:43:50.239]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:50.239]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:50.239]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.239]                               "release", "version")], collapse = " "), 
[17:43:50.239]                             hostname = base::Sys.info()[["nodename"]])
[17:43:50.239]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.239]                             info)
[17:43:50.239]                           info <- base::paste(info, collapse = "; ")
[17:43:50.239]                           if (!has_future) {
[17:43:50.239]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.239]                               info)
[17:43:50.239]                           }
[17:43:50.239]                           else {
[17:43:50.239]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.239]                               info, version)
[17:43:50.239]                           }
[17:43:50.239]                           base::stop(msg)
[17:43:50.239]                         }
[17:43:50.239]                       })
[17:43:50.239]                     }
[17:43:50.239]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.239]                     base::options(mc.cores = 1L)
[17:43:50.239]                   }
[17:43:50.239]                   ...future.strategy.old <- future::plan("list")
[17:43:50.239]                   options(future.plan = NULL)
[17:43:50.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.239]                 }
[17:43:50.239]                 ...future.workdir <- getwd()
[17:43:50.239]             }
[17:43:50.239]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.239]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.239]         }
[17:43:50.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.239]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:50.239]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.239]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.239]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.239]             base::names(...future.oldOptions))
[17:43:50.239]     }
[17:43:50.239]     if (FALSE) {
[17:43:50.239]     }
[17:43:50.239]     else {
[17:43:50.239]         if (TRUE) {
[17:43:50.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.239]                 open = "w")
[17:43:50.239]         }
[17:43:50.239]         else {
[17:43:50.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.239]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.239]         }
[17:43:50.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.239]             base::sink(type = "output", split = FALSE)
[17:43:50.239]             base::close(...future.stdout)
[17:43:50.239]         }, add = TRUE)
[17:43:50.239]     }
[17:43:50.239]     ...future.frame <- base::sys.nframe()
[17:43:50.239]     ...future.conditions <- base::list()
[17:43:50.239]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.239]     if (FALSE) {
[17:43:50.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.239]     }
[17:43:50.239]     ...future.result <- base::tryCatch({
[17:43:50.239]         base::withCallingHandlers({
[17:43:50.239]             ...future.value <- base::withVisible(base::local({
[17:43:50.239]                 ...future.makeSendCondition <- base::local({
[17:43:50.239]                   sendCondition <- NULL
[17:43:50.239]                   function(frame = 1L) {
[17:43:50.239]                     if (is.function(sendCondition)) 
[17:43:50.239]                       return(sendCondition)
[17:43:50.239]                     ns <- getNamespace("parallel")
[17:43:50.239]                     if (exists("sendData", mode = "function", 
[17:43:50.239]                       envir = ns)) {
[17:43:50.239]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.239]                         envir = ns)
[17:43:50.239]                       envir <- sys.frame(frame)
[17:43:50.239]                       master <- NULL
[17:43:50.239]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.239]                         !identical(envir, emptyenv())) {
[17:43:50.239]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.239]                           inherits = FALSE)) {
[17:43:50.239]                           master <- get("master", mode = "list", 
[17:43:50.239]                             envir = envir, inherits = FALSE)
[17:43:50.239]                           if (inherits(master, c("SOCKnode", 
[17:43:50.239]                             "SOCK0node"))) {
[17:43:50.239]                             sendCondition <<- function(cond) {
[17:43:50.239]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.239]                                 success = TRUE)
[17:43:50.239]                               parallel_sendData(master, data)
[17:43:50.239]                             }
[17:43:50.239]                             return(sendCondition)
[17:43:50.239]                           }
[17:43:50.239]                         }
[17:43:50.239]                         frame <- frame + 1L
[17:43:50.239]                         envir <- sys.frame(frame)
[17:43:50.239]                       }
[17:43:50.239]                     }
[17:43:50.239]                     sendCondition <<- function(cond) NULL
[17:43:50.239]                   }
[17:43:50.239]                 })
[17:43:50.239]                 withCallingHandlers({
[17:43:50.239]                   {
[17:43:50.239]                     do.call(function(...) {
[17:43:50.239]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.239]                       if (!identical(...future.globals.maxSize.org, 
[17:43:50.239]                         ...future.globals.maxSize)) {
[17:43:50.239]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.239]                         on.exit(options(oopts), add = TRUE)
[17:43:50.239]                       }
[17:43:50.239]                       {
[17:43:50.239]                         lapply(seq_along(...future.elements_ii), 
[17:43:50.239]                           FUN = function(jj) {
[17:43:50.239]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.239]                             ...future.FUN(...future.X_jj, ...)
[17:43:50.239]                           })
[17:43:50.239]                       }
[17:43:50.239]                     }, args = future.call.arguments)
[17:43:50.239]                   }
[17:43:50.239]                 }, immediateCondition = function(cond) {
[17:43:50.239]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.239]                   sendCondition(cond)
[17:43:50.239]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.239]                   {
[17:43:50.239]                     inherits <- base::inherits
[17:43:50.239]                     invokeRestart <- base::invokeRestart
[17:43:50.239]                     is.null <- base::is.null
[17:43:50.239]                     muffled <- FALSE
[17:43:50.239]                     if (inherits(cond, "message")) {
[17:43:50.239]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.239]                       if (muffled) 
[17:43:50.239]                         invokeRestart("muffleMessage")
[17:43:50.239]                     }
[17:43:50.239]                     else if (inherits(cond, "warning")) {
[17:43:50.239]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.239]                       if (muffled) 
[17:43:50.239]                         invokeRestart("muffleWarning")
[17:43:50.239]                     }
[17:43:50.239]                     else if (inherits(cond, "condition")) {
[17:43:50.239]                       if (!is.null(pattern)) {
[17:43:50.239]                         computeRestarts <- base::computeRestarts
[17:43:50.239]                         grepl <- base::grepl
[17:43:50.239]                         restarts <- computeRestarts(cond)
[17:43:50.239]                         for (restart in restarts) {
[17:43:50.239]                           name <- restart$name
[17:43:50.239]                           if (is.null(name)) 
[17:43:50.239]                             next
[17:43:50.239]                           if (!grepl(pattern, name)) 
[17:43:50.239]                             next
[17:43:50.239]                           invokeRestart(restart)
[17:43:50.239]                           muffled <- TRUE
[17:43:50.239]                           break
[17:43:50.239]                         }
[17:43:50.239]                       }
[17:43:50.239]                     }
[17:43:50.239]                     invisible(muffled)
[17:43:50.239]                   }
[17:43:50.239]                   muffleCondition(cond)
[17:43:50.239]                 })
[17:43:50.239]             }))
[17:43:50.239]             future::FutureResult(value = ...future.value$value, 
[17:43:50.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.239]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.239]                     ...future.globalenv.names))
[17:43:50.239]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.239]         }, condition = base::local({
[17:43:50.239]             c <- base::c
[17:43:50.239]             inherits <- base::inherits
[17:43:50.239]             invokeRestart <- base::invokeRestart
[17:43:50.239]             length <- base::length
[17:43:50.239]             list <- base::list
[17:43:50.239]             seq.int <- base::seq.int
[17:43:50.239]             signalCondition <- base::signalCondition
[17:43:50.239]             sys.calls <- base::sys.calls
[17:43:50.239]             `[[` <- base::`[[`
[17:43:50.239]             `+` <- base::`+`
[17:43:50.239]             `<<-` <- base::`<<-`
[17:43:50.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.239]                   3L)]
[17:43:50.239]             }
[17:43:50.239]             function(cond) {
[17:43:50.239]                 is_error <- inherits(cond, "error")
[17:43:50.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.239]                   NULL)
[17:43:50.239]                 if (is_error) {
[17:43:50.239]                   sessionInformation <- function() {
[17:43:50.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.239]                       search = base::search(), system = base::Sys.info())
[17:43:50.239]                   }
[17:43:50.239]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.239]                     cond$call), session = sessionInformation(), 
[17:43:50.239]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.239]                   signalCondition(cond)
[17:43:50.239]                 }
[17:43:50.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.239]                 "immediateCondition"))) {
[17:43:50.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.239]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.239]                   if (TRUE && !signal) {
[17:43:50.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.239]                     {
[17:43:50.239]                       inherits <- base::inherits
[17:43:50.239]                       invokeRestart <- base::invokeRestart
[17:43:50.239]                       is.null <- base::is.null
[17:43:50.239]                       muffled <- FALSE
[17:43:50.239]                       if (inherits(cond, "message")) {
[17:43:50.239]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.239]                         if (muffled) 
[17:43:50.239]                           invokeRestart("muffleMessage")
[17:43:50.239]                       }
[17:43:50.239]                       else if (inherits(cond, "warning")) {
[17:43:50.239]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.239]                         if (muffled) 
[17:43:50.239]                           invokeRestart("muffleWarning")
[17:43:50.239]                       }
[17:43:50.239]                       else if (inherits(cond, "condition")) {
[17:43:50.239]                         if (!is.null(pattern)) {
[17:43:50.239]                           computeRestarts <- base::computeRestarts
[17:43:50.239]                           grepl <- base::grepl
[17:43:50.239]                           restarts <- computeRestarts(cond)
[17:43:50.239]                           for (restart in restarts) {
[17:43:50.239]                             name <- restart$name
[17:43:50.239]                             if (is.null(name)) 
[17:43:50.239]                               next
[17:43:50.239]                             if (!grepl(pattern, name)) 
[17:43:50.239]                               next
[17:43:50.239]                             invokeRestart(restart)
[17:43:50.239]                             muffled <- TRUE
[17:43:50.239]                             break
[17:43:50.239]                           }
[17:43:50.239]                         }
[17:43:50.239]                       }
[17:43:50.239]                       invisible(muffled)
[17:43:50.239]                     }
[17:43:50.239]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.239]                   }
[17:43:50.239]                 }
[17:43:50.239]                 else {
[17:43:50.239]                   if (TRUE) {
[17:43:50.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.239]                     {
[17:43:50.239]                       inherits <- base::inherits
[17:43:50.239]                       invokeRestart <- base::invokeRestart
[17:43:50.239]                       is.null <- base::is.null
[17:43:50.239]                       muffled <- FALSE
[17:43:50.239]                       if (inherits(cond, "message")) {
[17:43:50.239]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.239]                         if (muffled) 
[17:43:50.239]                           invokeRestart("muffleMessage")
[17:43:50.239]                       }
[17:43:50.239]                       else if (inherits(cond, "warning")) {
[17:43:50.239]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.239]                         if (muffled) 
[17:43:50.239]                           invokeRestart("muffleWarning")
[17:43:50.239]                       }
[17:43:50.239]                       else if (inherits(cond, "condition")) {
[17:43:50.239]                         if (!is.null(pattern)) {
[17:43:50.239]                           computeRestarts <- base::computeRestarts
[17:43:50.239]                           grepl <- base::grepl
[17:43:50.239]                           restarts <- computeRestarts(cond)
[17:43:50.239]                           for (restart in restarts) {
[17:43:50.239]                             name <- restart$name
[17:43:50.239]                             if (is.null(name)) 
[17:43:50.239]                               next
[17:43:50.239]                             if (!grepl(pattern, name)) 
[17:43:50.239]                               next
[17:43:50.239]                             invokeRestart(restart)
[17:43:50.239]                             muffled <- TRUE
[17:43:50.239]                             break
[17:43:50.239]                           }
[17:43:50.239]                         }
[17:43:50.239]                       }
[17:43:50.239]                       invisible(muffled)
[17:43:50.239]                     }
[17:43:50.239]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.239]                   }
[17:43:50.239]                 }
[17:43:50.239]             }
[17:43:50.239]         }))
[17:43:50.239]     }, error = function(ex) {
[17:43:50.239]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.239]                 ...future.rng), started = ...future.startTime, 
[17:43:50.239]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.239]             version = "1.8"), class = "FutureResult")
[17:43:50.239]     }, finally = {
[17:43:50.239]         if (!identical(...future.workdir, getwd())) 
[17:43:50.239]             setwd(...future.workdir)
[17:43:50.239]         {
[17:43:50.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.239]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.239]             }
[17:43:50.239]             base::options(...future.oldOptions)
[17:43:50.239]             if (.Platform$OS.type == "windows") {
[17:43:50.239]                 old_names <- names(...future.oldEnvVars)
[17:43:50.239]                 envs <- base::Sys.getenv()
[17:43:50.239]                 names <- names(envs)
[17:43:50.239]                 common <- intersect(names, old_names)
[17:43:50.239]                 added <- setdiff(names, old_names)
[17:43:50.239]                 removed <- setdiff(old_names, names)
[17:43:50.239]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.239]                   envs[common]]
[17:43:50.239]                 NAMES <- toupper(changed)
[17:43:50.239]                 args <- list()
[17:43:50.239]                 for (kk in seq_along(NAMES)) {
[17:43:50.239]                   name <- changed[[kk]]
[17:43:50.239]                   NAME <- NAMES[[kk]]
[17:43:50.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.239]                     next
[17:43:50.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.239]                 }
[17:43:50.239]                 NAMES <- toupper(added)
[17:43:50.239]                 for (kk in seq_along(NAMES)) {
[17:43:50.239]                   name <- added[[kk]]
[17:43:50.239]                   NAME <- NAMES[[kk]]
[17:43:50.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.239]                     next
[17:43:50.239]                   args[[name]] <- ""
[17:43:50.239]                 }
[17:43:50.239]                 NAMES <- toupper(removed)
[17:43:50.239]                 for (kk in seq_along(NAMES)) {
[17:43:50.239]                   name <- removed[[kk]]
[17:43:50.239]                   NAME <- NAMES[[kk]]
[17:43:50.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.239]                     next
[17:43:50.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.239]                 }
[17:43:50.239]                 if (length(args) > 0) 
[17:43:50.239]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.239]             }
[17:43:50.239]             else {
[17:43:50.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.239]             }
[17:43:50.239]             {
[17:43:50.239]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.239]                   0L) {
[17:43:50.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.239]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.239]                   base::options(opts)
[17:43:50.239]                 }
[17:43:50.239]                 {
[17:43:50.239]                   {
[17:43:50.239]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.239]                     NULL
[17:43:50.239]                   }
[17:43:50.239]                   options(future.plan = NULL)
[17:43:50.239]                   if (is.na(NA_character_)) 
[17:43:50.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.239]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:50.239]                     .init = FALSE)
[17:43:50.239]                 }
[17:43:50.239]             }
[17:43:50.239]         }
[17:43:50.239]     })
[17:43:50.239]     if (TRUE) {
[17:43:50.239]         base::sink(type = "output", split = FALSE)
[17:43:50.239]         if (TRUE) {
[17:43:50.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.239]         }
[17:43:50.239]         else {
[17:43:50.239]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.239]         }
[17:43:50.239]         base::close(...future.stdout)
[17:43:50.239]         ...future.stdout <- NULL
[17:43:50.239]     }
[17:43:50.239]     ...future.result$conditions <- ...future.conditions
[17:43:50.239]     ...future.result$finished <- base::Sys.time()
[17:43:50.239]     ...future.result
[17:43:50.239] }
[17:43:50.242] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[17:43:50.242] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:50.243] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:50.243] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[17:43:50.284] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[17:43:50.284] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[17:43:50.285] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[17:43:50.285] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:50.285] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:50.285] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:43:50.286] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:43:50.286] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[17:43:50.286] MultisessionFuture started
[17:43:50.287] - Launch lazy future ... done
[17:43:50.287] run() for ‘MultisessionFuture’ ... done
[17:43:50.287] Created future:
[17:43:50.287] MultisessionFuture:
[17:43:50.287] Label: ‘future_apply-2’
[17:43:50.287] Expression:
[17:43:50.287] {
[17:43:50.287]     do.call(function(...) {
[17:43:50.287]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.287]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.287]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.287]             on.exit(options(oopts), add = TRUE)
[17:43:50.287]         }
[17:43:50.287]         {
[17:43:50.287]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.287]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.287]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.287]             })
[17:43:50.287]         }
[17:43:50.287]     }, args = future.call.arguments)
[17:43:50.287] }
[17:43:50.287] Lazy evaluation: FALSE
[17:43:50.287] Asynchronous evaluation: TRUE
[17:43:50.287] Local evaluation: TRUE
[17:43:50.287] Environment: R_GlobalEnv
[17:43:50.287] Capture standard output: TRUE
[17:43:50.287] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:50.287] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:50.287] Packages: <none>
[17:43:50.287] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:50.287] Resolved: FALSE
[17:43:50.287] Value: <not collected>
[17:43:50.287] Conditions captured: <none>
[17:43:50.287] Early signaling: FALSE
[17:43:50.287] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:50.287] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.299] Chunk #2 of 2 ... DONE
[17:43:50.299] Launching 2 futures (chunks) ... DONE
[17:43:50.299] Resolving 2 futures (chunks) ...
[17:43:50.299] resolve() on list ...
[17:43:50.299]  recursive: 0
[17:43:50.299]  length: 2
[17:43:50.299] 
[17:43:50.300] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.300] - Validating connection of MultisessionFuture
[17:43:50.300] - received message: FutureResult
[17:43:50.300] - Received FutureResult
[17:43:50.300] - Erased future from FutureRegistry
[17:43:50.300] result() for ClusterFuture ...
[17:43:50.301] - result already collected: FutureResult
[17:43:50.301] result() for ClusterFuture ... done
[17:43:50.301] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.301] Future #1
[17:43:50.301] result() for ClusterFuture ...
[17:43:50.301] - result already collected: FutureResult
[17:43:50.301] result() for ClusterFuture ... done
[17:43:50.301] result() for ClusterFuture ...
[17:43:50.301] - result already collected: FutureResult
[17:43:50.301] result() for ClusterFuture ... done
[17:43:50.301] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:50.302] - nx: 2
[17:43:50.302] - relay: TRUE
[17:43:50.302] - stdout: TRUE
[17:43:50.302] - signal: TRUE
[17:43:50.302] - resignal: FALSE
[17:43:50.302] - force: TRUE
[17:43:50.302] - relayed: [n=2] FALSE, FALSE
[17:43:50.302] - queued futures: [n=2] FALSE, FALSE
[17:43:50.302]  - until=1
[17:43:50.302]  - relaying element #1
[17:43:50.302] result() for ClusterFuture ...
[17:43:50.302] - result already collected: FutureResult
[17:43:50.303] result() for ClusterFuture ... done
[17:43:50.303] result() for ClusterFuture ...
[17:43:50.303] - result already collected: FutureResult
[17:43:50.303] result() for ClusterFuture ... done
[17:43:50.303] result() for ClusterFuture ...
[17:43:50.303] - result already collected: FutureResult
[17:43:50.303] result() for ClusterFuture ... done
[17:43:50.303] result() for ClusterFuture ...
[17:43:50.303] - result already collected: FutureResult
[17:43:50.303] result() for ClusterFuture ... done
[17:43:50.303] - relayed: [n=2] TRUE, FALSE
[17:43:50.304] - queued futures: [n=2] TRUE, FALSE
[17:43:50.304] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:50.304]  length: 1 (resolved future 1)
[17:43:50.332] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.333] - Validating connection of MultisessionFuture
[17:43:50.333] - received message: FutureResult
[17:43:50.333] - Received FutureResult
[17:43:50.333] - Erased future from FutureRegistry
[17:43:50.333] result() for ClusterFuture ...
[17:43:50.333] - result already collected: FutureResult
[17:43:50.333] result() for ClusterFuture ... done
[17:43:50.333] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.334] Future #2
[17:43:50.334] result() for ClusterFuture ...
[17:43:50.334] - result already collected: FutureResult
[17:43:50.334] result() for ClusterFuture ... done
[17:43:50.334] result() for ClusterFuture ...
[17:43:50.334] - result already collected: FutureResult
[17:43:50.334] result() for ClusterFuture ... done
[17:43:50.334] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:50.334] - nx: 2
[17:43:50.334] - relay: TRUE
[17:43:50.334] - stdout: TRUE
[17:43:50.335] - signal: TRUE
[17:43:50.335] - resignal: FALSE
[17:43:50.335] - force: TRUE
[17:43:50.335] - relayed: [n=2] TRUE, FALSE
[17:43:50.335] - queued futures: [n=2] TRUE, FALSE
[17:43:50.335]  - until=2
[17:43:50.335]  - relaying element #2
[17:43:50.335] result() for ClusterFuture ...
[17:43:50.335] - result already collected: FutureResult
[17:43:50.335] result() for ClusterFuture ... done
[17:43:50.336] result() for ClusterFuture ...
[17:43:50.336] - result already collected: FutureResult
[17:43:50.336] result() for ClusterFuture ... done
[17:43:50.338] result() for ClusterFuture ...
[17:43:50.338] - result already collected: FutureResult
[17:43:50.338] result() for ClusterFuture ... done
[17:43:50.338] result() for ClusterFuture ...
[17:43:50.338] - result already collected: FutureResult
[17:43:50.338] result() for ClusterFuture ... done
[17:43:50.338] - relayed: [n=2] TRUE, TRUE
[17:43:50.338] - queued futures: [n=2] TRUE, TRUE
[17:43:50.338] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:50.339]  length: 0 (resolved future 2)
[17:43:50.339] Relaying remaining futures
[17:43:50.339] signalConditionsASAP(NULL, pos=0) ...
[17:43:50.339] - nx: 2
[17:43:50.339] - relay: TRUE
[17:43:50.339] - stdout: TRUE
[17:43:50.339] - signal: TRUE
[17:43:50.339] - resignal: FALSE
[17:43:50.339] - force: TRUE
[17:43:50.339] - relayed: [n=2] TRUE, TRUE
[17:43:50.339] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:50.340] - relayed: [n=2] TRUE, TRUE
[17:43:50.340] - queued futures: [n=2] TRUE, TRUE
[17:43:50.340] signalConditionsASAP(NULL, pos=0) ... done
[17:43:50.340] resolve() on list ... DONE
[17:43:50.340] result() for ClusterFuture ...
[17:43:50.340] - result already collected: FutureResult
[17:43:50.340] result() for ClusterFuture ... done
[17:43:50.340] result() for ClusterFuture ...
[17:43:50.340] - result already collected: FutureResult
[17:43:50.340] result() for ClusterFuture ... done
[17:43:50.340] result() for ClusterFuture ...
[17:43:50.340] - result already collected: FutureResult
[17:43:50.341] result() for ClusterFuture ... done
[17:43:50.341] result() for ClusterFuture ...
[17:43:50.341] - result already collected: FutureResult
[17:43:50.341] result() for ClusterFuture ... done
[17:43:50.341]  - Number of value chunks collected: 2
[17:43:50.341] Resolving 2 futures (chunks) ... DONE
[17:43:50.341] Reducing values from 2 chunks ...
[17:43:50.341]  - Number of values collected after concatenation: 2
[17:43:50.341]  - Number of values expected: 2
[17:43:50.341] Reducing values from 2 chunks ... DONE
[17:43:50.341] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[17:43:50.342] getGlobalsAndPackagesXApply() ...
[17:43:50.342]  - future.globals: TRUE
[17:43:50.342] getGlobalsAndPackages() ...
[17:43:50.342] Searching for globals...
[17:43:50.344] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:43:50.344] Searching for globals ... DONE
[17:43:50.344] Resolving globals: FALSE
[17:43:50.344] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[17:43:50.345] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[17:43:50.345] - globals: [1] ‘FUN’
[17:43:50.345] - packages: [1] ‘stats’
[17:43:50.345] getGlobalsAndPackages() ... DONE
[17:43:50.345]  - globals found/used: [n=1] ‘FUN’
[17:43:50.345]  - needed namespaces: [n=1] ‘stats’
[17:43:50.345] Finding globals ... DONE
[17:43:50.345]  - use_args: TRUE
[17:43:50.345]  - Getting '...' globals ...
[17:43:50.346] resolve() on list ...
[17:43:50.346]  recursive: 0
[17:43:50.346]  length: 1
[17:43:50.346]  elements: ‘...’
[17:43:50.346]  length: 0 (resolved future 1)
[17:43:50.346] resolve() on list ... DONE
[17:43:50.346]    - '...' content: [n=0] 
[17:43:50.346] List of 1
[17:43:50.346]  $ ...: list()
[17:43:50.346]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.346]  - attr(*, "where")=List of 1
[17:43:50.346]   ..$ ...:<environment: 0x55dfd5171928> 
[17:43:50.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.346]  - attr(*, "resolved")= logi TRUE
[17:43:50.346]  - attr(*, "total_size")= num NA
[17:43:50.349]  - Getting '...' globals ... DONE
[17:43:50.349] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:50.349] List of 2
[17:43:50.349]  $ ...future.FUN:function (x, ...)  
[17:43:50.349]  $ ...          : list()
[17:43:50.349]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.349]  - attr(*, "where")=List of 2
[17:43:50.349]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:50.349]   ..$ ...          :<environment: 0x55dfd5171928> 
[17:43:50.349]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.349]  - attr(*, "resolved")= logi FALSE
[17:43:50.349]  - attr(*, "total_size")= num 1248
[17:43:50.352] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:50.352] getGlobalsAndPackagesXApply() ... DONE
[17:43:50.356] future_lapply() ...
[17:43:50.360] Number of chunks: 2
[17:43:50.360] getGlobalsAndPackagesXApply() ...
[17:43:50.360]  - future.globals: <name-value list> with names ‘list()’
[17:43:50.360]  - use_args: TRUE
[17:43:50.360] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:50.360] List of 2
[17:43:50.360]  $ ...          : list()
[17:43:50.360]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.360]  $ ...future.FUN:function (x, ...)  
[17:43:50.360]  - attr(*, "where")=List of 2
[17:43:50.360]   ..$ ...          :<environment: 0x55dfd5171928> 
[17:43:50.360]   ..$ ...future.FUN:<environment: namespace:stats> 
[17:43:50.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.360]  - attr(*, "resolved")= logi FALSE
[17:43:50.360]  - attr(*, "total_size")= num NA
[17:43:50.363] Packages to be attached in all futures: [n=1] ‘stats’
[17:43:50.363] getGlobalsAndPackagesXApply() ... DONE
[17:43:50.364] Number of futures (= number of chunks): 2
[17:43:50.364] Launching 2 futures (chunks) ...
[17:43:50.364] Chunk #1 of 2 ...
[17:43:50.364]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:50.364]  - seeds: <none>
[17:43:50.364]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.364] getGlobalsAndPackages() ...
[17:43:50.364] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.364] Resolving globals: FALSE
[17:43:50.365] Tweak future expression to call with '...' arguments ...
[17:43:50.365] {
[17:43:50.365]     do.call(function(...) {
[17:43:50.365]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.365]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.365]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.365]             on.exit(options(oopts), add = TRUE)
[17:43:50.365]         }
[17:43:50.365]         {
[17:43:50.365]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.365]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.365]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.365]             })
[17:43:50.365]         }
[17:43:50.365]     }, args = future.call.arguments)
[17:43:50.365] }
[17:43:50.365] Tweak future expression to call with '...' arguments ... DONE
[17:43:50.365] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.365] - packages: [1] ‘stats’
[17:43:50.366] getGlobalsAndPackages() ... DONE
[17:43:50.366] run() for ‘Future’ ...
[17:43:50.366] - state: ‘created’
[17:43:50.366] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.380] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.380] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.381]   - Field: ‘node’
[17:43:50.381]   - Field: ‘label’
[17:43:50.381]   - Field: ‘local’
[17:43:50.381]   - Field: ‘owner’
[17:43:50.381]   - Field: ‘envir’
[17:43:50.381]   - Field: ‘workers’
[17:43:50.381]   - Field: ‘packages’
[17:43:50.381]   - Field: ‘gc’
[17:43:50.381]   - Field: ‘conditions’
[17:43:50.381]   - Field: ‘persistent’
[17:43:50.381]   - Field: ‘expr’
[17:43:50.382]   - Field: ‘uuid’
[17:43:50.382]   - Field: ‘seed’
[17:43:50.382]   - Field: ‘version’
[17:43:50.382]   - Field: ‘result’
[17:43:50.382]   - Field: ‘asynchronous’
[17:43:50.382]   - Field: ‘calls’
[17:43:50.382]   - Field: ‘globals’
[17:43:50.382]   - Field: ‘stdout’
[17:43:50.382]   - Field: ‘earlySignal’
[17:43:50.382]   - Field: ‘lazy’
[17:43:50.382]   - Field: ‘state’
[17:43:50.383] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.383] - Launch lazy future ...
[17:43:50.383] Packages needed by the future expression (n = 1): ‘stats’
[17:43:50.383] Packages needed by future strategies (n = 0): <none>
[17:43:50.384] {
[17:43:50.384]     {
[17:43:50.384]         {
[17:43:50.384]             ...future.startTime <- base::Sys.time()
[17:43:50.384]             {
[17:43:50.384]                 {
[17:43:50.384]                   {
[17:43:50.384]                     {
[17:43:50.384]                       {
[17:43:50.384]                         base::local({
[17:43:50.384]                           has_future <- base::requireNamespace("future", 
[17:43:50.384]                             quietly = TRUE)
[17:43:50.384]                           if (has_future) {
[17:43:50.384]                             ns <- base::getNamespace("future")
[17:43:50.384]                             version <- ns[[".package"]][["version"]]
[17:43:50.384]                             if (is.null(version)) 
[17:43:50.384]                               version <- utils::packageVersion("future")
[17:43:50.384]                           }
[17:43:50.384]                           else {
[17:43:50.384]                             version <- NULL
[17:43:50.384]                           }
[17:43:50.384]                           if (!has_future || version < "1.8.0") {
[17:43:50.384]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.384]                               "", base::R.version$version.string), 
[17:43:50.384]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:50.384]                                 base::R.version$platform, 8 * 
[17:43:50.384]                                   base::.Machine$sizeof.pointer), 
[17:43:50.384]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.384]                                 "release", "version")], collapse = " "), 
[17:43:50.384]                               hostname = base::Sys.info()[["nodename"]])
[17:43:50.384]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.384]                               info)
[17:43:50.384]                             info <- base::paste(info, collapse = "; ")
[17:43:50.384]                             if (!has_future) {
[17:43:50.384]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.384]                                 info)
[17:43:50.384]                             }
[17:43:50.384]                             else {
[17:43:50.384]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.384]                                 info, version)
[17:43:50.384]                             }
[17:43:50.384]                             base::stop(msg)
[17:43:50.384]                           }
[17:43:50.384]                         })
[17:43:50.384]                       }
[17:43:50.384]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.384]                       base::options(mc.cores = 1L)
[17:43:50.384]                     }
[17:43:50.384]                     base::local({
[17:43:50.384]                       for (pkg in "stats") {
[17:43:50.384]                         base::loadNamespace(pkg)
[17:43:50.384]                         base::library(pkg, character.only = TRUE)
[17:43:50.384]                       }
[17:43:50.384]                     })
[17:43:50.384]                   }
[17:43:50.384]                   ...future.strategy.old <- future::plan("list")
[17:43:50.384]                   options(future.plan = NULL)
[17:43:50.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.384]                 }
[17:43:50.384]                 ...future.workdir <- getwd()
[17:43:50.384]             }
[17:43:50.384]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.384]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.384]         }
[17:43:50.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.384]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:50.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.384]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.384]             base::names(...future.oldOptions))
[17:43:50.384]     }
[17:43:50.384]     if (FALSE) {
[17:43:50.384]     }
[17:43:50.384]     else {
[17:43:50.384]         if (TRUE) {
[17:43:50.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.384]                 open = "w")
[17:43:50.384]         }
[17:43:50.384]         else {
[17:43:50.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.384]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.384]         }
[17:43:50.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.384]             base::sink(type = "output", split = FALSE)
[17:43:50.384]             base::close(...future.stdout)
[17:43:50.384]         }, add = TRUE)
[17:43:50.384]     }
[17:43:50.384]     ...future.frame <- base::sys.nframe()
[17:43:50.384]     ...future.conditions <- base::list()
[17:43:50.384]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.384]     if (FALSE) {
[17:43:50.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.384]     }
[17:43:50.384]     ...future.result <- base::tryCatch({
[17:43:50.384]         base::withCallingHandlers({
[17:43:50.384]             ...future.value <- base::withVisible(base::local({
[17:43:50.384]                 ...future.makeSendCondition <- base::local({
[17:43:50.384]                   sendCondition <- NULL
[17:43:50.384]                   function(frame = 1L) {
[17:43:50.384]                     if (is.function(sendCondition)) 
[17:43:50.384]                       return(sendCondition)
[17:43:50.384]                     ns <- getNamespace("parallel")
[17:43:50.384]                     if (exists("sendData", mode = "function", 
[17:43:50.384]                       envir = ns)) {
[17:43:50.384]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.384]                         envir = ns)
[17:43:50.384]                       envir <- sys.frame(frame)
[17:43:50.384]                       master <- NULL
[17:43:50.384]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.384]                         !identical(envir, emptyenv())) {
[17:43:50.384]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.384]                           inherits = FALSE)) {
[17:43:50.384]                           master <- get("master", mode = "list", 
[17:43:50.384]                             envir = envir, inherits = FALSE)
[17:43:50.384]                           if (inherits(master, c("SOCKnode", 
[17:43:50.384]                             "SOCK0node"))) {
[17:43:50.384]                             sendCondition <<- function(cond) {
[17:43:50.384]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.384]                                 success = TRUE)
[17:43:50.384]                               parallel_sendData(master, data)
[17:43:50.384]                             }
[17:43:50.384]                             return(sendCondition)
[17:43:50.384]                           }
[17:43:50.384]                         }
[17:43:50.384]                         frame <- frame + 1L
[17:43:50.384]                         envir <- sys.frame(frame)
[17:43:50.384]                       }
[17:43:50.384]                     }
[17:43:50.384]                     sendCondition <<- function(cond) NULL
[17:43:50.384]                   }
[17:43:50.384]                 })
[17:43:50.384]                 withCallingHandlers({
[17:43:50.384]                   {
[17:43:50.384]                     do.call(function(...) {
[17:43:50.384]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.384]                       if (!identical(...future.globals.maxSize.org, 
[17:43:50.384]                         ...future.globals.maxSize)) {
[17:43:50.384]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.384]                         on.exit(options(oopts), add = TRUE)
[17:43:50.384]                       }
[17:43:50.384]                       {
[17:43:50.384]                         lapply(seq_along(...future.elements_ii), 
[17:43:50.384]                           FUN = function(jj) {
[17:43:50.384]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.384]                             ...future.FUN(...future.X_jj, ...)
[17:43:50.384]                           })
[17:43:50.384]                       }
[17:43:50.384]                     }, args = future.call.arguments)
[17:43:50.384]                   }
[17:43:50.384]                 }, immediateCondition = function(cond) {
[17:43:50.384]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.384]                   sendCondition(cond)
[17:43:50.384]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.384]                   {
[17:43:50.384]                     inherits <- base::inherits
[17:43:50.384]                     invokeRestart <- base::invokeRestart
[17:43:50.384]                     is.null <- base::is.null
[17:43:50.384]                     muffled <- FALSE
[17:43:50.384]                     if (inherits(cond, "message")) {
[17:43:50.384]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.384]                       if (muffled) 
[17:43:50.384]                         invokeRestart("muffleMessage")
[17:43:50.384]                     }
[17:43:50.384]                     else if (inherits(cond, "warning")) {
[17:43:50.384]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.384]                       if (muffled) 
[17:43:50.384]                         invokeRestart("muffleWarning")
[17:43:50.384]                     }
[17:43:50.384]                     else if (inherits(cond, "condition")) {
[17:43:50.384]                       if (!is.null(pattern)) {
[17:43:50.384]                         computeRestarts <- base::computeRestarts
[17:43:50.384]                         grepl <- base::grepl
[17:43:50.384]                         restarts <- computeRestarts(cond)
[17:43:50.384]                         for (restart in restarts) {
[17:43:50.384]                           name <- restart$name
[17:43:50.384]                           if (is.null(name)) 
[17:43:50.384]                             next
[17:43:50.384]                           if (!grepl(pattern, name)) 
[17:43:50.384]                             next
[17:43:50.384]                           invokeRestart(restart)
[17:43:50.384]                           muffled <- TRUE
[17:43:50.384]                           break
[17:43:50.384]                         }
[17:43:50.384]                       }
[17:43:50.384]                     }
[17:43:50.384]                     invisible(muffled)
[17:43:50.384]                   }
[17:43:50.384]                   muffleCondition(cond)
[17:43:50.384]                 })
[17:43:50.384]             }))
[17:43:50.384]             future::FutureResult(value = ...future.value$value, 
[17:43:50.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.384]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.384]                     ...future.globalenv.names))
[17:43:50.384]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.384]         }, condition = base::local({
[17:43:50.384]             c <- base::c
[17:43:50.384]             inherits <- base::inherits
[17:43:50.384]             invokeRestart <- base::invokeRestart
[17:43:50.384]             length <- base::length
[17:43:50.384]             list <- base::list
[17:43:50.384]             seq.int <- base::seq.int
[17:43:50.384]             signalCondition <- base::signalCondition
[17:43:50.384]             sys.calls <- base::sys.calls
[17:43:50.384]             `[[` <- base::`[[`
[17:43:50.384]             `+` <- base::`+`
[17:43:50.384]             `<<-` <- base::`<<-`
[17:43:50.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.384]                   3L)]
[17:43:50.384]             }
[17:43:50.384]             function(cond) {
[17:43:50.384]                 is_error <- inherits(cond, "error")
[17:43:50.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.384]                   NULL)
[17:43:50.384]                 if (is_error) {
[17:43:50.384]                   sessionInformation <- function() {
[17:43:50.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.384]                       search = base::search(), system = base::Sys.info())
[17:43:50.384]                   }
[17:43:50.384]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.384]                     cond$call), session = sessionInformation(), 
[17:43:50.384]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.384]                   signalCondition(cond)
[17:43:50.384]                 }
[17:43:50.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.384]                 "immediateCondition"))) {
[17:43:50.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.384]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.384]                   if (TRUE && !signal) {
[17:43:50.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.384]                     {
[17:43:50.384]                       inherits <- base::inherits
[17:43:50.384]                       invokeRestart <- base::invokeRestart
[17:43:50.384]                       is.null <- base::is.null
[17:43:50.384]                       muffled <- FALSE
[17:43:50.384]                       if (inherits(cond, "message")) {
[17:43:50.384]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.384]                         if (muffled) 
[17:43:50.384]                           invokeRestart("muffleMessage")
[17:43:50.384]                       }
[17:43:50.384]                       else if (inherits(cond, "warning")) {
[17:43:50.384]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.384]                         if (muffled) 
[17:43:50.384]                           invokeRestart("muffleWarning")
[17:43:50.384]                       }
[17:43:50.384]                       else if (inherits(cond, "condition")) {
[17:43:50.384]                         if (!is.null(pattern)) {
[17:43:50.384]                           computeRestarts <- base::computeRestarts
[17:43:50.384]                           grepl <- base::grepl
[17:43:50.384]                           restarts <- computeRestarts(cond)
[17:43:50.384]                           for (restart in restarts) {
[17:43:50.384]                             name <- restart$name
[17:43:50.384]                             if (is.null(name)) 
[17:43:50.384]                               next
[17:43:50.384]                             if (!grepl(pattern, name)) 
[17:43:50.384]                               next
[17:43:50.384]                             invokeRestart(restart)
[17:43:50.384]                             muffled <- TRUE
[17:43:50.384]                             break
[17:43:50.384]                           }
[17:43:50.384]                         }
[17:43:50.384]                       }
[17:43:50.384]                       invisible(muffled)
[17:43:50.384]                     }
[17:43:50.384]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.384]                   }
[17:43:50.384]                 }
[17:43:50.384]                 else {
[17:43:50.384]                   if (TRUE) {
[17:43:50.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.384]                     {
[17:43:50.384]                       inherits <- base::inherits
[17:43:50.384]                       invokeRestart <- base::invokeRestart
[17:43:50.384]                       is.null <- base::is.null
[17:43:50.384]                       muffled <- FALSE
[17:43:50.384]                       if (inherits(cond, "message")) {
[17:43:50.384]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.384]                         if (muffled) 
[17:43:50.384]                           invokeRestart("muffleMessage")
[17:43:50.384]                       }
[17:43:50.384]                       else if (inherits(cond, "warning")) {
[17:43:50.384]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.384]                         if (muffled) 
[17:43:50.384]                           invokeRestart("muffleWarning")
[17:43:50.384]                       }
[17:43:50.384]                       else if (inherits(cond, "condition")) {
[17:43:50.384]                         if (!is.null(pattern)) {
[17:43:50.384]                           computeRestarts <- base::computeRestarts
[17:43:50.384]                           grepl <- base::grepl
[17:43:50.384]                           restarts <- computeRestarts(cond)
[17:43:50.384]                           for (restart in restarts) {
[17:43:50.384]                             name <- restart$name
[17:43:50.384]                             if (is.null(name)) 
[17:43:50.384]                               next
[17:43:50.384]                             if (!grepl(pattern, name)) 
[17:43:50.384]                               next
[17:43:50.384]                             invokeRestart(restart)
[17:43:50.384]                             muffled <- TRUE
[17:43:50.384]                             break
[17:43:50.384]                           }
[17:43:50.384]                         }
[17:43:50.384]                       }
[17:43:50.384]                       invisible(muffled)
[17:43:50.384]                     }
[17:43:50.384]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.384]                   }
[17:43:50.384]                 }
[17:43:50.384]             }
[17:43:50.384]         }))
[17:43:50.384]     }, error = function(ex) {
[17:43:50.384]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.384]                 ...future.rng), started = ...future.startTime, 
[17:43:50.384]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.384]             version = "1.8"), class = "FutureResult")
[17:43:50.384]     }, finally = {
[17:43:50.384]         if (!identical(...future.workdir, getwd())) 
[17:43:50.384]             setwd(...future.workdir)
[17:43:50.384]         {
[17:43:50.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.384]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.384]             }
[17:43:50.384]             base::options(...future.oldOptions)
[17:43:50.384]             if (.Platform$OS.type == "windows") {
[17:43:50.384]                 old_names <- names(...future.oldEnvVars)
[17:43:50.384]                 envs <- base::Sys.getenv()
[17:43:50.384]                 names <- names(envs)
[17:43:50.384]                 common <- intersect(names, old_names)
[17:43:50.384]                 added <- setdiff(names, old_names)
[17:43:50.384]                 removed <- setdiff(old_names, names)
[17:43:50.384]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.384]                   envs[common]]
[17:43:50.384]                 NAMES <- toupper(changed)
[17:43:50.384]                 args <- list()
[17:43:50.384]                 for (kk in seq_along(NAMES)) {
[17:43:50.384]                   name <- changed[[kk]]
[17:43:50.384]                   NAME <- NAMES[[kk]]
[17:43:50.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.384]                     next
[17:43:50.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.384]                 }
[17:43:50.384]                 NAMES <- toupper(added)
[17:43:50.384]                 for (kk in seq_along(NAMES)) {
[17:43:50.384]                   name <- added[[kk]]
[17:43:50.384]                   NAME <- NAMES[[kk]]
[17:43:50.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.384]                     next
[17:43:50.384]                   args[[name]] <- ""
[17:43:50.384]                 }
[17:43:50.384]                 NAMES <- toupper(removed)
[17:43:50.384]                 for (kk in seq_along(NAMES)) {
[17:43:50.384]                   name <- removed[[kk]]
[17:43:50.384]                   NAME <- NAMES[[kk]]
[17:43:50.384]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.384]                     next
[17:43:50.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.384]                 }
[17:43:50.384]                 if (length(args) > 0) 
[17:43:50.384]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.384]             }
[17:43:50.384]             else {
[17:43:50.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.384]             }
[17:43:50.384]             {
[17:43:50.384]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.384]                   0L) {
[17:43:50.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.384]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.384]                   base::options(opts)
[17:43:50.384]                 }
[17:43:50.384]                 {
[17:43:50.384]                   {
[17:43:50.384]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.384]                     NULL
[17:43:50.384]                   }
[17:43:50.384]                   options(future.plan = NULL)
[17:43:50.384]                   if (is.na(NA_character_)) 
[17:43:50.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.384]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:50.384]                     .init = FALSE)
[17:43:50.384]                 }
[17:43:50.384]             }
[17:43:50.384]         }
[17:43:50.384]     })
[17:43:50.384]     if (TRUE) {
[17:43:50.384]         base::sink(type = "output", split = FALSE)
[17:43:50.384]         if (TRUE) {
[17:43:50.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.384]         }
[17:43:50.384]         else {
[17:43:50.384]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.384]         }
[17:43:50.384]         base::close(...future.stdout)
[17:43:50.384]         ...future.stdout <- NULL
[17:43:50.384]     }
[17:43:50.384]     ...future.result$conditions <- ...future.conditions
[17:43:50.384]     ...future.result$finished <- base::Sys.time()
[17:43:50.384]     ...future.result
[17:43:50.384] }
[17:43:50.387] Exporting 5 global objects (1.35 KiB) to cluster node #1 ...
[17:43:50.387] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:50.387] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:50.388] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[17:43:50.388] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:43:50.388] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[17:43:50.388] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[17:43:50.389] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:50.389] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:50.389] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:43:50.390] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:43:50.390] Exporting 5 global objects (1.35 KiB) to cluster node #1 ... DONE
[17:43:50.390] MultisessionFuture started
[17:43:50.390] - Launch lazy future ... done
[17:43:50.390] run() for ‘MultisessionFuture’ ... done
[17:43:50.391] Created future:
[17:43:50.391] MultisessionFuture:
[17:43:50.391] Label: ‘future_apply-1’
[17:43:50.391] Expression:
[17:43:50.391] {
[17:43:50.391]     do.call(function(...) {
[17:43:50.391]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.391]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.391]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.391]             on.exit(options(oopts), add = TRUE)
[17:43:50.391]         }
[17:43:50.391]         {
[17:43:50.391]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.391]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.391]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.391]             })
[17:43:50.391]         }
[17:43:50.391]     }, args = future.call.arguments)
[17:43:50.391] }
[17:43:50.391] Lazy evaluation: FALSE
[17:43:50.391] Asynchronous evaluation: TRUE
[17:43:50.391] Local evaluation: TRUE
[17:43:50.391] Environment: R_GlobalEnv
[17:43:50.391] Capture standard output: TRUE
[17:43:50.391] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:50.391] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:50.391] Packages: 1 packages (‘stats’)
[17:43:50.391] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:50.391] Resolved: FALSE
[17:43:50.391] Value: <not collected>
[17:43:50.391] Conditions captured: <none>
[17:43:50.391] Early signaling: FALSE
[17:43:50.391] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:50.391] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.402] Chunk #1 of 2 ... DONE
[17:43:50.402] Chunk #2 of 2 ...
[17:43:50.403]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:50.403]  - seeds: <none>
[17:43:50.403]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.403] getGlobalsAndPackages() ...
[17:43:50.403] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.403] Resolving globals: FALSE
[17:43:50.403] Tweak future expression to call with '...' arguments ...
[17:43:50.404] {
[17:43:50.404]     do.call(function(...) {
[17:43:50.404]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.404]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.404]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.404]             on.exit(options(oopts), add = TRUE)
[17:43:50.404]         }
[17:43:50.404]         {
[17:43:50.404]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.404]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.404]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.404]             })
[17:43:50.404]         }
[17:43:50.404]     }, args = future.call.arguments)
[17:43:50.404] }
[17:43:50.404] Tweak future expression to call with '...' arguments ... DONE
[17:43:50.404] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.404] - packages: [1] ‘stats’
[17:43:50.404] getGlobalsAndPackages() ... DONE
[17:43:50.405] run() for ‘Future’ ...
[17:43:50.405] - state: ‘created’
[17:43:50.405] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.419] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.419] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.419]   - Field: ‘node’
[17:43:50.419]   - Field: ‘label’
[17:43:50.419]   - Field: ‘local’
[17:43:50.419]   - Field: ‘owner’
[17:43:50.420]   - Field: ‘envir’
[17:43:50.420]   - Field: ‘workers’
[17:43:50.420]   - Field: ‘packages’
[17:43:50.420]   - Field: ‘gc’
[17:43:50.420]   - Field: ‘conditions’
[17:43:50.420]   - Field: ‘persistent’
[17:43:50.420]   - Field: ‘expr’
[17:43:50.420]   - Field: ‘uuid’
[17:43:50.420]   - Field: ‘seed’
[17:43:50.420]   - Field: ‘version’
[17:43:50.420]   - Field: ‘result’
[17:43:50.421]   - Field: ‘asynchronous’
[17:43:50.421]   - Field: ‘calls’
[17:43:50.421]   - Field: ‘globals’
[17:43:50.421]   - Field: ‘stdout’
[17:43:50.421]   - Field: ‘earlySignal’
[17:43:50.421]   - Field: ‘lazy’
[17:43:50.421]   - Field: ‘state’
[17:43:50.421] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.421] - Launch lazy future ...
[17:43:50.422] Packages needed by the future expression (n = 1): ‘stats’
[17:43:50.422] Packages needed by future strategies (n = 0): <none>
[17:43:50.422] {
[17:43:50.422]     {
[17:43:50.422]         {
[17:43:50.422]             ...future.startTime <- base::Sys.time()
[17:43:50.422]             {
[17:43:50.422]                 {
[17:43:50.422]                   {
[17:43:50.422]                     {
[17:43:50.422]                       {
[17:43:50.422]                         base::local({
[17:43:50.422]                           has_future <- base::requireNamespace("future", 
[17:43:50.422]                             quietly = TRUE)
[17:43:50.422]                           if (has_future) {
[17:43:50.422]                             ns <- base::getNamespace("future")
[17:43:50.422]                             version <- ns[[".package"]][["version"]]
[17:43:50.422]                             if (is.null(version)) 
[17:43:50.422]                               version <- utils::packageVersion("future")
[17:43:50.422]                           }
[17:43:50.422]                           else {
[17:43:50.422]                             version <- NULL
[17:43:50.422]                           }
[17:43:50.422]                           if (!has_future || version < "1.8.0") {
[17:43:50.422]                             info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.422]                               "", base::R.version$version.string), 
[17:43:50.422]                               platform = base::sprintf("%s (%s-bit)", 
[17:43:50.422]                                 base::R.version$platform, 8 * 
[17:43:50.422]                                   base::.Machine$sizeof.pointer), 
[17:43:50.422]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.422]                                 "release", "version")], collapse = " "), 
[17:43:50.422]                               hostname = base::Sys.info()[["nodename"]])
[17:43:50.422]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.422]                               info)
[17:43:50.422]                             info <- base::paste(info, collapse = "; ")
[17:43:50.422]                             if (!has_future) {
[17:43:50.422]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.422]                                 info)
[17:43:50.422]                             }
[17:43:50.422]                             else {
[17:43:50.422]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.422]                                 info, version)
[17:43:50.422]                             }
[17:43:50.422]                             base::stop(msg)
[17:43:50.422]                           }
[17:43:50.422]                         })
[17:43:50.422]                       }
[17:43:50.422]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.422]                       base::options(mc.cores = 1L)
[17:43:50.422]                     }
[17:43:50.422]                     base::local({
[17:43:50.422]                       for (pkg in "stats") {
[17:43:50.422]                         base::loadNamespace(pkg)
[17:43:50.422]                         base::library(pkg, character.only = TRUE)
[17:43:50.422]                       }
[17:43:50.422]                     })
[17:43:50.422]                   }
[17:43:50.422]                   ...future.strategy.old <- future::plan("list")
[17:43:50.422]                   options(future.plan = NULL)
[17:43:50.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.422]                 }
[17:43:50.422]                 ...future.workdir <- getwd()
[17:43:50.422]             }
[17:43:50.422]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.422]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.422]         }
[17:43:50.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.422]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:50.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.422]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.422]             base::names(...future.oldOptions))
[17:43:50.422]     }
[17:43:50.422]     if (FALSE) {
[17:43:50.422]     }
[17:43:50.422]     else {
[17:43:50.422]         if (TRUE) {
[17:43:50.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.422]                 open = "w")
[17:43:50.422]         }
[17:43:50.422]         else {
[17:43:50.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.422]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.422]         }
[17:43:50.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.422]             base::sink(type = "output", split = FALSE)
[17:43:50.422]             base::close(...future.stdout)
[17:43:50.422]         }, add = TRUE)
[17:43:50.422]     }
[17:43:50.422]     ...future.frame <- base::sys.nframe()
[17:43:50.422]     ...future.conditions <- base::list()
[17:43:50.422]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.422]     if (FALSE) {
[17:43:50.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.422]     }
[17:43:50.422]     ...future.result <- base::tryCatch({
[17:43:50.422]         base::withCallingHandlers({
[17:43:50.422]             ...future.value <- base::withVisible(base::local({
[17:43:50.422]                 ...future.makeSendCondition <- base::local({
[17:43:50.422]                   sendCondition <- NULL
[17:43:50.422]                   function(frame = 1L) {
[17:43:50.422]                     if (is.function(sendCondition)) 
[17:43:50.422]                       return(sendCondition)
[17:43:50.422]                     ns <- getNamespace("parallel")
[17:43:50.422]                     if (exists("sendData", mode = "function", 
[17:43:50.422]                       envir = ns)) {
[17:43:50.422]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.422]                         envir = ns)
[17:43:50.422]                       envir <- sys.frame(frame)
[17:43:50.422]                       master <- NULL
[17:43:50.422]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.422]                         !identical(envir, emptyenv())) {
[17:43:50.422]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.422]                           inherits = FALSE)) {
[17:43:50.422]                           master <- get("master", mode = "list", 
[17:43:50.422]                             envir = envir, inherits = FALSE)
[17:43:50.422]                           if (inherits(master, c("SOCKnode", 
[17:43:50.422]                             "SOCK0node"))) {
[17:43:50.422]                             sendCondition <<- function(cond) {
[17:43:50.422]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.422]                                 success = TRUE)
[17:43:50.422]                               parallel_sendData(master, data)
[17:43:50.422]                             }
[17:43:50.422]                             return(sendCondition)
[17:43:50.422]                           }
[17:43:50.422]                         }
[17:43:50.422]                         frame <- frame + 1L
[17:43:50.422]                         envir <- sys.frame(frame)
[17:43:50.422]                       }
[17:43:50.422]                     }
[17:43:50.422]                     sendCondition <<- function(cond) NULL
[17:43:50.422]                   }
[17:43:50.422]                 })
[17:43:50.422]                 withCallingHandlers({
[17:43:50.422]                   {
[17:43:50.422]                     do.call(function(...) {
[17:43:50.422]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.422]                       if (!identical(...future.globals.maxSize.org, 
[17:43:50.422]                         ...future.globals.maxSize)) {
[17:43:50.422]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.422]                         on.exit(options(oopts), add = TRUE)
[17:43:50.422]                       }
[17:43:50.422]                       {
[17:43:50.422]                         lapply(seq_along(...future.elements_ii), 
[17:43:50.422]                           FUN = function(jj) {
[17:43:50.422]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.422]                             ...future.FUN(...future.X_jj, ...)
[17:43:50.422]                           })
[17:43:50.422]                       }
[17:43:50.422]                     }, args = future.call.arguments)
[17:43:50.422]                   }
[17:43:50.422]                 }, immediateCondition = function(cond) {
[17:43:50.422]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.422]                   sendCondition(cond)
[17:43:50.422]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.422]                   {
[17:43:50.422]                     inherits <- base::inherits
[17:43:50.422]                     invokeRestart <- base::invokeRestart
[17:43:50.422]                     is.null <- base::is.null
[17:43:50.422]                     muffled <- FALSE
[17:43:50.422]                     if (inherits(cond, "message")) {
[17:43:50.422]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.422]                       if (muffled) 
[17:43:50.422]                         invokeRestart("muffleMessage")
[17:43:50.422]                     }
[17:43:50.422]                     else if (inherits(cond, "warning")) {
[17:43:50.422]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.422]                       if (muffled) 
[17:43:50.422]                         invokeRestart("muffleWarning")
[17:43:50.422]                     }
[17:43:50.422]                     else if (inherits(cond, "condition")) {
[17:43:50.422]                       if (!is.null(pattern)) {
[17:43:50.422]                         computeRestarts <- base::computeRestarts
[17:43:50.422]                         grepl <- base::grepl
[17:43:50.422]                         restarts <- computeRestarts(cond)
[17:43:50.422]                         for (restart in restarts) {
[17:43:50.422]                           name <- restart$name
[17:43:50.422]                           if (is.null(name)) 
[17:43:50.422]                             next
[17:43:50.422]                           if (!grepl(pattern, name)) 
[17:43:50.422]                             next
[17:43:50.422]                           invokeRestart(restart)
[17:43:50.422]                           muffled <- TRUE
[17:43:50.422]                           break
[17:43:50.422]                         }
[17:43:50.422]                       }
[17:43:50.422]                     }
[17:43:50.422]                     invisible(muffled)
[17:43:50.422]                   }
[17:43:50.422]                   muffleCondition(cond)
[17:43:50.422]                 })
[17:43:50.422]             }))
[17:43:50.422]             future::FutureResult(value = ...future.value$value, 
[17:43:50.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.422]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.422]                     ...future.globalenv.names))
[17:43:50.422]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.422]         }, condition = base::local({
[17:43:50.422]             c <- base::c
[17:43:50.422]             inherits <- base::inherits
[17:43:50.422]             invokeRestart <- base::invokeRestart
[17:43:50.422]             length <- base::length
[17:43:50.422]             list <- base::list
[17:43:50.422]             seq.int <- base::seq.int
[17:43:50.422]             signalCondition <- base::signalCondition
[17:43:50.422]             sys.calls <- base::sys.calls
[17:43:50.422]             `[[` <- base::`[[`
[17:43:50.422]             `+` <- base::`+`
[17:43:50.422]             `<<-` <- base::`<<-`
[17:43:50.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.422]                   3L)]
[17:43:50.422]             }
[17:43:50.422]             function(cond) {
[17:43:50.422]                 is_error <- inherits(cond, "error")
[17:43:50.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.422]                   NULL)
[17:43:50.422]                 if (is_error) {
[17:43:50.422]                   sessionInformation <- function() {
[17:43:50.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.422]                       search = base::search(), system = base::Sys.info())
[17:43:50.422]                   }
[17:43:50.422]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.422]                     cond$call), session = sessionInformation(), 
[17:43:50.422]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.422]                   signalCondition(cond)
[17:43:50.422]                 }
[17:43:50.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.422]                 "immediateCondition"))) {
[17:43:50.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.422]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.422]                   if (TRUE && !signal) {
[17:43:50.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.422]                     {
[17:43:50.422]                       inherits <- base::inherits
[17:43:50.422]                       invokeRestart <- base::invokeRestart
[17:43:50.422]                       is.null <- base::is.null
[17:43:50.422]                       muffled <- FALSE
[17:43:50.422]                       if (inherits(cond, "message")) {
[17:43:50.422]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.422]                         if (muffled) 
[17:43:50.422]                           invokeRestart("muffleMessage")
[17:43:50.422]                       }
[17:43:50.422]                       else if (inherits(cond, "warning")) {
[17:43:50.422]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.422]                         if (muffled) 
[17:43:50.422]                           invokeRestart("muffleWarning")
[17:43:50.422]                       }
[17:43:50.422]                       else if (inherits(cond, "condition")) {
[17:43:50.422]                         if (!is.null(pattern)) {
[17:43:50.422]                           computeRestarts <- base::computeRestarts
[17:43:50.422]                           grepl <- base::grepl
[17:43:50.422]                           restarts <- computeRestarts(cond)
[17:43:50.422]                           for (restart in restarts) {
[17:43:50.422]                             name <- restart$name
[17:43:50.422]                             if (is.null(name)) 
[17:43:50.422]                               next
[17:43:50.422]                             if (!grepl(pattern, name)) 
[17:43:50.422]                               next
[17:43:50.422]                             invokeRestart(restart)
[17:43:50.422]                             muffled <- TRUE
[17:43:50.422]                             break
[17:43:50.422]                           }
[17:43:50.422]                         }
[17:43:50.422]                       }
[17:43:50.422]                       invisible(muffled)
[17:43:50.422]                     }
[17:43:50.422]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.422]                   }
[17:43:50.422]                 }
[17:43:50.422]                 else {
[17:43:50.422]                   if (TRUE) {
[17:43:50.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.422]                     {
[17:43:50.422]                       inherits <- base::inherits
[17:43:50.422]                       invokeRestart <- base::invokeRestart
[17:43:50.422]                       is.null <- base::is.null
[17:43:50.422]                       muffled <- FALSE
[17:43:50.422]                       if (inherits(cond, "message")) {
[17:43:50.422]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.422]                         if (muffled) 
[17:43:50.422]                           invokeRestart("muffleMessage")
[17:43:50.422]                       }
[17:43:50.422]                       else if (inherits(cond, "warning")) {
[17:43:50.422]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.422]                         if (muffled) 
[17:43:50.422]                           invokeRestart("muffleWarning")
[17:43:50.422]                       }
[17:43:50.422]                       else if (inherits(cond, "condition")) {
[17:43:50.422]                         if (!is.null(pattern)) {
[17:43:50.422]                           computeRestarts <- base::computeRestarts
[17:43:50.422]                           grepl <- base::grepl
[17:43:50.422]                           restarts <- computeRestarts(cond)
[17:43:50.422]                           for (restart in restarts) {
[17:43:50.422]                             name <- restart$name
[17:43:50.422]                             if (is.null(name)) 
[17:43:50.422]                               next
[17:43:50.422]                             if (!grepl(pattern, name)) 
[17:43:50.422]                               next
[17:43:50.422]                             invokeRestart(restart)
[17:43:50.422]                             muffled <- TRUE
[17:43:50.422]                             break
[17:43:50.422]                           }
[17:43:50.422]                         }
[17:43:50.422]                       }
[17:43:50.422]                       invisible(muffled)
[17:43:50.422]                     }
[17:43:50.422]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.422]                   }
[17:43:50.422]                 }
[17:43:50.422]             }
[17:43:50.422]         }))
[17:43:50.422]     }, error = function(ex) {
[17:43:50.422]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.422]                 ...future.rng), started = ...future.startTime, 
[17:43:50.422]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.422]             version = "1.8"), class = "FutureResult")
[17:43:50.422]     }, finally = {
[17:43:50.422]         if (!identical(...future.workdir, getwd())) 
[17:43:50.422]             setwd(...future.workdir)
[17:43:50.422]         {
[17:43:50.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.422]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.422]             }
[17:43:50.422]             base::options(...future.oldOptions)
[17:43:50.422]             if (.Platform$OS.type == "windows") {
[17:43:50.422]                 old_names <- names(...future.oldEnvVars)
[17:43:50.422]                 envs <- base::Sys.getenv()
[17:43:50.422]                 names <- names(envs)
[17:43:50.422]                 common <- intersect(names, old_names)
[17:43:50.422]                 added <- setdiff(names, old_names)
[17:43:50.422]                 removed <- setdiff(old_names, names)
[17:43:50.422]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.422]                   envs[common]]
[17:43:50.422]                 NAMES <- toupper(changed)
[17:43:50.422]                 args <- list()
[17:43:50.422]                 for (kk in seq_along(NAMES)) {
[17:43:50.422]                   name <- changed[[kk]]
[17:43:50.422]                   NAME <- NAMES[[kk]]
[17:43:50.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.422]                     next
[17:43:50.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.422]                 }
[17:43:50.422]                 NAMES <- toupper(added)
[17:43:50.422]                 for (kk in seq_along(NAMES)) {
[17:43:50.422]                   name <- added[[kk]]
[17:43:50.422]                   NAME <- NAMES[[kk]]
[17:43:50.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.422]                     next
[17:43:50.422]                   args[[name]] <- ""
[17:43:50.422]                 }
[17:43:50.422]                 NAMES <- toupper(removed)
[17:43:50.422]                 for (kk in seq_along(NAMES)) {
[17:43:50.422]                   name <- removed[[kk]]
[17:43:50.422]                   NAME <- NAMES[[kk]]
[17:43:50.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.422]                     next
[17:43:50.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.422]                 }
[17:43:50.422]                 if (length(args) > 0) 
[17:43:50.422]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.422]             }
[17:43:50.422]             else {
[17:43:50.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.422]             }
[17:43:50.422]             {
[17:43:50.422]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.422]                   0L) {
[17:43:50.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.422]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.422]                   base::options(opts)
[17:43:50.422]                 }
[17:43:50.422]                 {
[17:43:50.422]                   {
[17:43:50.422]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.422]                     NULL
[17:43:50.422]                   }
[17:43:50.422]                   options(future.plan = NULL)
[17:43:50.422]                   if (is.na(NA_character_)) 
[17:43:50.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.422]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:50.422]                     .init = FALSE)
[17:43:50.422]                 }
[17:43:50.422]             }
[17:43:50.422]         }
[17:43:50.422]     })
[17:43:50.422]     if (TRUE) {
[17:43:50.422]         base::sink(type = "output", split = FALSE)
[17:43:50.422]         if (TRUE) {
[17:43:50.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.422]         }
[17:43:50.422]         else {
[17:43:50.422]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.422]         }
[17:43:50.422]         base::close(...future.stdout)
[17:43:50.422]         ...future.stdout <- NULL
[17:43:50.422]     }
[17:43:50.422]     ...future.result$conditions <- ...future.conditions
[17:43:50.422]     ...future.result$finished <- base::Sys.time()
[17:43:50.422]     ...future.result
[17:43:50.422] }
[17:43:50.425] Exporting 5 global objects (1.35 KiB) to cluster node #2 ...
[17:43:50.426] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:50.426] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:50.426] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[17:43:50.427] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:43:50.427] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[17:43:50.427] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[17:43:50.427] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:50.428] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:50.428] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:43:50.428] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:43:50.428] Exporting 5 global objects (1.35 KiB) to cluster node #2 ... DONE
[17:43:50.429] MultisessionFuture started
[17:43:50.429] - Launch lazy future ... done
[17:43:50.429] run() for ‘MultisessionFuture’ ... done
[17:43:50.429] Created future:
[17:43:50.430] MultisessionFuture:
[17:43:50.430] Label: ‘future_apply-2’
[17:43:50.430] Expression:
[17:43:50.430] {
[17:43:50.430]     do.call(function(...) {
[17:43:50.430]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.430]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.430]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.430]             on.exit(options(oopts), add = TRUE)
[17:43:50.430]         }
[17:43:50.430]         {
[17:43:50.430]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.430]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.430]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.430]             })
[17:43:50.430]         }
[17:43:50.430]     }, args = future.call.arguments)
[17:43:50.430] }
[17:43:50.430] Lazy evaluation: FALSE
[17:43:50.430] Asynchronous evaluation: TRUE
[17:43:50.430] Local evaluation: TRUE
[17:43:50.430] Environment: R_GlobalEnv
[17:43:50.430] Capture standard output: TRUE
[17:43:50.430] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:50.430] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:50.430] Packages: 1 packages (‘stats’)
[17:43:50.430] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:50.430] Resolved: FALSE
[17:43:50.430] Value: <not collected>
[17:43:50.430] Conditions captured: <none>
[17:43:50.430] Early signaling: FALSE
[17:43:50.430] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:50.430] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.441] Chunk #2 of 2 ... DONE
[17:43:50.441] Launching 2 futures (chunks) ... DONE
[17:43:50.441] Resolving 2 futures (chunks) ...
[17:43:50.441] resolve() on list ...
[17:43:50.441]  recursive: 0
[17:43:50.442]  length: 2
[17:43:50.442] 
[17:43:50.442] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.442] - Validating connection of MultisessionFuture
[17:43:50.442] - received message: FutureResult
[17:43:50.443] - Received FutureResult
[17:43:50.443] - Erased future from FutureRegistry
[17:43:50.443] result() for ClusterFuture ...
[17:43:50.443] - result already collected: FutureResult
[17:43:50.443] result() for ClusterFuture ... done
[17:43:50.443] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.443] Future #1
[17:43:50.443] result() for ClusterFuture ...
[17:43:50.443] - result already collected: FutureResult
[17:43:50.443] result() for ClusterFuture ... done
[17:43:50.444] result() for ClusterFuture ...
[17:43:50.444] - result already collected: FutureResult
[17:43:50.444] result() for ClusterFuture ... done
[17:43:50.444] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:50.444] - nx: 2
[17:43:50.444] - relay: TRUE
[17:43:50.444] - stdout: TRUE
[17:43:50.444] - signal: TRUE
[17:43:50.444] - resignal: FALSE
[17:43:50.444] - force: TRUE
[17:43:50.444] - relayed: [n=2] FALSE, FALSE
[17:43:50.445] - queued futures: [n=2] FALSE, FALSE
[17:43:50.445]  - until=1
[17:43:50.445]  - relaying element #1
[17:43:50.445] result() for ClusterFuture ...
[17:43:50.445] - result already collected: FutureResult
[17:43:50.445] result() for ClusterFuture ... done
[17:43:50.445] result() for ClusterFuture ...
[17:43:50.445] - result already collected: FutureResult
[17:43:50.445] result() for ClusterFuture ... done
[17:43:50.445] result() for ClusterFuture ...
[17:43:50.445] - result already collected: FutureResult
[17:43:50.445] result() for ClusterFuture ... done
[17:43:50.446] result() for ClusterFuture ...
[17:43:50.446] - result already collected: FutureResult
[17:43:50.446] result() for ClusterFuture ... done
[17:43:50.446] - relayed: [n=2] TRUE, FALSE
[17:43:50.446] - queued futures: [n=2] TRUE, FALSE
[17:43:50.446] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:50.446]  length: 1 (resolved future 1)
[17:43:50.475] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.475] - Validating connection of MultisessionFuture
[17:43:50.475] - received message: FutureResult
[17:43:50.476] - Received FutureResult
[17:43:50.476] - Erased future from FutureRegistry
[17:43:50.476] result() for ClusterFuture ...
[17:43:50.476] - result already collected: FutureResult
[17:43:50.476] result() for ClusterFuture ... done
[17:43:50.476] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.476] Future #2
[17:43:50.476] result() for ClusterFuture ...
[17:43:50.476] - result already collected: FutureResult
[17:43:50.476] result() for ClusterFuture ... done
[17:43:50.477] result() for ClusterFuture ...
[17:43:50.477] - result already collected: FutureResult
[17:43:50.477] result() for ClusterFuture ... done
[17:43:50.477] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:50.477] - nx: 2
[17:43:50.477] - relay: TRUE
[17:43:50.477] - stdout: TRUE
[17:43:50.477] - signal: TRUE
[17:43:50.477] - resignal: FALSE
[17:43:50.477] - force: TRUE
[17:43:50.477] - relayed: [n=2] TRUE, FALSE
[17:43:50.477] - queued futures: [n=2] TRUE, FALSE
[17:43:50.478]  - until=2
[17:43:50.478]  - relaying element #2
[17:43:50.478] result() for ClusterFuture ...
[17:43:50.478] - result already collected: FutureResult
[17:43:50.478] result() for ClusterFuture ... done
[17:43:50.478] result() for ClusterFuture ...
[17:43:50.478] - result already collected: FutureResult
[17:43:50.478] result() for ClusterFuture ... done
[17:43:50.478] result() for ClusterFuture ...
[17:43:50.478] - result already collected: FutureResult
[17:43:50.478] result() for ClusterFuture ... done
[17:43:50.479] result() for ClusterFuture ...
[17:43:50.479] - result already collected: FutureResult
[17:43:50.479] result() for ClusterFuture ... done
[17:43:50.479] - relayed: [n=2] TRUE, TRUE
[17:43:50.479] - queued futures: [n=2] TRUE, TRUE
[17:43:50.479] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:50.479]  length: 0 (resolved future 2)
[17:43:50.479] Relaying remaining futures
[17:43:50.479] signalConditionsASAP(NULL, pos=0) ...
[17:43:50.479] - nx: 2
[17:43:50.479] - relay: TRUE
[17:43:50.480] - stdout: TRUE
[17:43:50.480] - signal: TRUE
[17:43:50.480] - resignal: FALSE
[17:43:50.480] - force: TRUE
[17:43:50.480] - relayed: [n=2] TRUE, TRUE
[17:43:50.480] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:50.480] - relayed: [n=2] TRUE, TRUE
[17:43:50.480] - queued futures: [n=2] TRUE, TRUE
[17:43:50.480] signalConditionsASAP(NULL, pos=0) ... done
[17:43:50.480] resolve() on list ... DONE
[17:43:50.480] result() for ClusterFuture ...
[17:43:50.481] - result already collected: FutureResult
[17:43:50.481] result() for ClusterFuture ... done
[17:43:50.481] result() for ClusterFuture ...
[17:43:50.481] - result already collected: FutureResult
[17:43:50.481] result() for ClusterFuture ... done
[17:43:50.481] result() for ClusterFuture ...
[17:43:50.481] - result already collected: FutureResult
[17:43:50.481] result() for ClusterFuture ... done
[17:43:50.481] result() for ClusterFuture ...
[17:43:50.481] - result already collected: FutureResult
[17:43:50.481] result() for ClusterFuture ... done
[17:43:50.482]  - Number of value chunks collected: 2
[17:43:50.482] Resolving 2 futures (chunks) ... DONE
[17:43:50.482] Reducing values from 2 chunks ...
[17:43:50.482]  - Number of values collected after concatenation: 2
[17:43:50.482]  - Number of values expected: 2
[17:43:50.482] Reducing values from 2 chunks ... DONE
[17:43:50.482] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[17:43:50.483] getGlobalsAndPackagesXApply() ...
[17:43:50.483]  - future.globals: TRUE
[17:43:50.483] getGlobalsAndPackages() ...
[17:43:50.483] Searching for globals...
[17:43:50.484] - globals found: [1] ‘FUN’
[17:43:50.484] Searching for globals ... DONE
[17:43:50.484] Resolving globals: FALSE
[17:43:50.484] The total size of the 1 globals is 848 bytes (848 bytes)
[17:43:50.485] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:43:50.485] - globals: [1] ‘FUN’
[17:43:50.485] 
[17:43:50.485] getGlobalsAndPackages() ... DONE
[17:43:50.485]  - globals found/used: [n=1] ‘FUN’
[17:43:50.485]  - needed namespaces: [n=0] 
[17:43:50.485] Finding globals ... DONE
[17:43:50.486]  - use_args: TRUE
[17:43:50.486]  - Getting '...' globals ...
[17:43:50.486] resolve() on list ...
[17:43:50.486]  recursive: 0
[17:43:50.486]  length: 1
[17:43:50.486]  elements: ‘...’
[17:43:50.486]  length: 0 (resolved future 1)
[17:43:50.486] resolve() on list ... DONE
[17:43:50.486]    - '...' content: [n=0] 
[17:43:50.487] List of 1
[17:43:50.487]  $ ...: list()
[17:43:50.487]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.487]  - attr(*, "where")=List of 1
[17:43:50.487]   ..$ ...:<environment: 0x55dfd6621280> 
[17:43:50.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.487]  - attr(*, "resolved")= logi TRUE
[17:43:50.487]  - attr(*, "total_size")= num NA
[17:43:50.489]  - Getting '...' globals ... DONE
[17:43:50.489] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:50.489] List of 2
[17:43:50.489]  $ ...future.FUN:function (x)  
[17:43:50.489]  $ ...          : list()
[17:43:50.489]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.489]  - attr(*, "where")=List of 2
[17:43:50.489]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:50.489]   ..$ ...          :<environment: 0x55dfd6621280> 
[17:43:50.489]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.489]  - attr(*, "resolved")= logi FALSE
[17:43:50.489]  - attr(*, "total_size")= num 848
[17:43:50.492] Packages to be attached in all futures: [n=0] 
[17:43:50.492] getGlobalsAndPackagesXApply() ... DONE
[17:43:50.496] future_lapply() ...
[17:43:50.499] Number of chunks: 2
[17:43:50.500] getGlobalsAndPackagesXApply() ...
[17:43:50.500]  - future.globals: <name-value list> with names ‘list()’
[17:43:50.500]  - use_args: TRUE
[17:43:50.500] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:50.500] List of 2
[17:43:50.500]  $ ...          : list()
[17:43:50.500]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.500]  $ ...future.FUN:function (x)  
[17:43:50.500]  - attr(*, "where")=List of 2
[17:43:50.500]   ..$ ...          :<environment: 0x55dfd6621280> 
[17:43:50.500]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:50.500]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.500]  - attr(*, "resolved")= logi FALSE
[17:43:50.500]  - attr(*, "total_size")= num NA
[17:43:50.505] Packages to be attached in all futures: [n=0] 
[17:43:50.505] getGlobalsAndPackagesXApply() ... DONE
[17:43:50.505] Number of futures (= number of chunks): 2
[17:43:50.505] Launching 2 futures (chunks) ...
[17:43:50.505] Chunk #1 of 2 ...
[17:43:50.506]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:50.506]  - seeds: <none>
[17:43:50.506]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.506] getGlobalsAndPackages() ...
[17:43:50.506] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.506] Resolving globals: FALSE
[17:43:50.506] Tweak future expression to call with '...' arguments ...
[17:43:50.506] {
[17:43:50.506]     do.call(function(...) {
[17:43:50.506]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.506]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.506]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.506]             on.exit(options(oopts), add = TRUE)
[17:43:50.506]         }
[17:43:50.506]         {
[17:43:50.506]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.506]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.506]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.506]             })
[17:43:50.506]         }
[17:43:50.506]     }, args = future.call.arguments)
[17:43:50.506] }
[17:43:50.507] Tweak future expression to call with '...' arguments ... DONE
[17:43:50.507] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.507] 
[17:43:50.507] getGlobalsAndPackages() ... DONE
[17:43:50.508] run() for ‘Future’ ...
[17:43:50.508] - state: ‘created’
[17:43:50.508] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.521] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.521] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.522]   - Field: ‘node’
[17:43:50.522]   - Field: ‘label’
[17:43:50.522]   - Field: ‘local’
[17:43:50.522]   - Field: ‘owner’
[17:43:50.522]   - Field: ‘envir’
[17:43:50.522]   - Field: ‘workers’
[17:43:50.522]   - Field: ‘packages’
[17:43:50.522]   - Field: ‘gc’
[17:43:50.522]   - Field: ‘conditions’
[17:43:50.522]   - Field: ‘persistent’
[17:43:50.522]   - Field: ‘expr’
[17:43:50.523]   - Field: ‘uuid’
[17:43:50.523]   - Field: ‘seed’
[17:43:50.523]   - Field: ‘version’
[17:43:50.523]   - Field: ‘result’
[17:43:50.523]   - Field: ‘asynchronous’
[17:43:50.523]   - Field: ‘calls’
[17:43:50.523]   - Field: ‘globals’
[17:43:50.523]   - Field: ‘stdout’
[17:43:50.523]   - Field: ‘earlySignal’
[17:43:50.523]   - Field: ‘lazy’
[17:43:50.523]   - Field: ‘state’
[17:43:50.524] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.524] - Launch lazy future ...
[17:43:50.524] Packages needed by the future expression (n = 0): <none>
[17:43:50.524] Packages needed by future strategies (n = 0): <none>
[17:43:50.524] {
[17:43:50.524]     {
[17:43:50.524]         {
[17:43:50.524]             ...future.startTime <- base::Sys.time()
[17:43:50.524]             {
[17:43:50.524]                 {
[17:43:50.524]                   {
[17:43:50.524]                     {
[17:43:50.524]                       base::local({
[17:43:50.524]                         has_future <- base::requireNamespace("future", 
[17:43:50.524]                           quietly = TRUE)
[17:43:50.524]                         if (has_future) {
[17:43:50.524]                           ns <- base::getNamespace("future")
[17:43:50.524]                           version <- ns[[".package"]][["version"]]
[17:43:50.524]                           if (is.null(version)) 
[17:43:50.524]                             version <- utils::packageVersion("future")
[17:43:50.524]                         }
[17:43:50.524]                         else {
[17:43:50.524]                           version <- NULL
[17:43:50.524]                         }
[17:43:50.524]                         if (!has_future || version < "1.8.0") {
[17:43:50.524]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.524]                             "", base::R.version$version.string), 
[17:43:50.524]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:50.524]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:50.524]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.524]                               "release", "version")], collapse = " "), 
[17:43:50.524]                             hostname = base::Sys.info()[["nodename"]])
[17:43:50.524]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.524]                             info)
[17:43:50.524]                           info <- base::paste(info, collapse = "; ")
[17:43:50.524]                           if (!has_future) {
[17:43:50.524]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.524]                               info)
[17:43:50.524]                           }
[17:43:50.524]                           else {
[17:43:50.524]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.524]                               info, version)
[17:43:50.524]                           }
[17:43:50.524]                           base::stop(msg)
[17:43:50.524]                         }
[17:43:50.524]                       })
[17:43:50.524]                     }
[17:43:50.524]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.524]                     base::options(mc.cores = 1L)
[17:43:50.524]                   }
[17:43:50.524]                   ...future.strategy.old <- future::plan("list")
[17:43:50.524]                   options(future.plan = NULL)
[17:43:50.524]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.524]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.524]                 }
[17:43:50.524]                 ...future.workdir <- getwd()
[17:43:50.524]             }
[17:43:50.524]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.524]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.524]         }
[17:43:50.524]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.524]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:50.524]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.524]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.524]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.524]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.524]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.524]             base::names(...future.oldOptions))
[17:43:50.524]     }
[17:43:50.524]     if (FALSE) {
[17:43:50.524]     }
[17:43:50.524]     else {
[17:43:50.524]         if (TRUE) {
[17:43:50.524]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.524]                 open = "w")
[17:43:50.524]         }
[17:43:50.524]         else {
[17:43:50.524]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.524]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.524]         }
[17:43:50.524]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.524]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.524]             base::sink(type = "output", split = FALSE)
[17:43:50.524]             base::close(...future.stdout)
[17:43:50.524]         }, add = TRUE)
[17:43:50.524]     }
[17:43:50.524]     ...future.frame <- base::sys.nframe()
[17:43:50.524]     ...future.conditions <- base::list()
[17:43:50.524]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.524]     if (FALSE) {
[17:43:50.524]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.524]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.524]     }
[17:43:50.524]     ...future.result <- base::tryCatch({
[17:43:50.524]         base::withCallingHandlers({
[17:43:50.524]             ...future.value <- base::withVisible(base::local({
[17:43:50.524]                 ...future.makeSendCondition <- base::local({
[17:43:50.524]                   sendCondition <- NULL
[17:43:50.524]                   function(frame = 1L) {
[17:43:50.524]                     if (is.function(sendCondition)) 
[17:43:50.524]                       return(sendCondition)
[17:43:50.524]                     ns <- getNamespace("parallel")
[17:43:50.524]                     if (exists("sendData", mode = "function", 
[17:43:50.524]                       envir = ns)) {
[17:43:50.524]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.524]                         envir = ns)
[17:43:50.524]                       envir <- sys.frame(frame)
[17:43:50.524]                       master <- NULL
[17:43:50.524]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.524]                         !identical(envir, emptyenv())) {
[17:43:50.524]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.524]                           inherits = FALSE)) {
[17:43:50.524]                           master <- get("master", mode = "list", 
[17:43:50.524]                             envir = envir, inherits = FALSE)
[17:43:50.524]                           if (inherits(master, c("SOCKnode", 
[17:43:50.524]                             "SOCK0node"))) {
[17:43:50.524]                             sendCondition <<- function(cond) {
[17:43:50.524]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.524]                                 success = TRUE)
[17:43:50.524]                               parallel_sendData(master, data)
[17:43:50.524]                             }
[17:43:50.524]                             return(sendCondition)
[17:43:50.524]                           }
[17:43:50.524]                         }
[17:43:50.524]                         frame <- frame + 1L
[17:43:50.524]                         envir <- sys.frame(frame)
[17:43:50.524]                       }
[17:43:50.524]                     }
[17:43:50.524]                     sendCondition <<- function(cond) NULL
[17:43:50.524]                   }
[17:43:50.524]                 })
[17:43:50.524]                 withCallingHandlers({
[17:43:50.524]                   {
[17:43:50.524]                     do.call(function(...) {
[17:43:50.524]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.524]                       if (!identical(...future.globals.maxSize.org, 
[17:43:50.524]                         ...future.globals.maxSize)) {
[17:43:50.524]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.524]                         on.exit(options(oopts), add = TRUE)
[17:43:50.524]                       }
[17:43:50.524]                       {
[17:43:50.524]                         lapply(seq_along(...future.elements_ii), 
[17:43:50.524]                           FUN = function(jj) {
[17:43:50.524]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.524]                             ...future.FUN(...future.X_jj, ...)
[17:43:50.524]                           })
[17:43:50.524]                       }
[17:43:50.524]                     }, args = future.call.arguments)
[17:43:50.524]                   }
[17:43:50.524]                 }, immediateCondition = function(cond) {
[17:43:50.524]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.524]                   sendCondition(cond)
[17:43:50.524]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.524]                   {
[17:43:50.524]                     inherits <- base::inherits
[17:43:50.524]                     invokeRestart <- base::invokeRestart
[17:43:50.524]                     is.null <- base::is.null
[17:43:50.524]                     muffled <- FALSE
[17:43:50.524]                     if (inherits(cond, "message")) {
[17:43:50.524]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.524]                       if (muffled) 
[17:43:50.524]                         invokeRestart("muffleMessage")
[17:43:50.524]                     }
[17:43:50.524]                     else if (inherits(cond, "warning")) {
[17:43:50.524]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.524]                       if (muffled) 
[17:43:50.524]                         invokeRestart("muffleWarning")
[17:43:50.524]                     }
[17:43:50.524]                     else if (inherits(cond, "condition")) {
[17:43:50.524]                       if (!is.null(pattern)) {
[17:43:50.524]                         computeRestarts <- base::computeRestarts
[17:43:50.524]                         grepl <- base::grepl
[17:43:50.524]                         restarts <- computeRestarts(cond)
[17:43:50.524]                         for (restart in restarts) {
[17:43:50.524]                           name <- restart$name
[17:43:50.524]                           if (is.null(name)) 
[17:43:50.524]                             next
[17:43:50.524]                           if (!grepl(pattern, name)) 
[17:43:50.524]                             next
[17:43:50.524]                           invokeRestart(restart)
[17:43:50.524]                           muffled <- TRUE
[17:43:50.524]                           break
[17:43:50.524]                         }
[17:43:50.524]                       }
[17:43:50.524]                     }
[17:43:50.524]                     invisible(muffled)
[17:43:50.524]                   }
[17:43:50.524]                   muffleCondition(cond)
[17:43:50.524]                 })
[17:43:50.524]             }))
[17:43:50.524]             future::FutureResult(value = ...future.value$value, 
[17:43:50.524]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.524]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.524]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.524]                     ...future.globalenv.names))
[17:43:50.524]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.524]         }, condition = base::local({
[17:43:50.524]             c <- base::c
[17:43:50.524]             inherits <- base::inherits
[17:43:50.524]             invokeRestart <- base::invokeRestart
[17:43:50.524]             length <- base::length
[17:43:50.524]             list <- base::list
[17:43:50.524]             seq.int <- base::seq.int
[17:43:50.524]             signalCondition <- base::signalCondition
[17:43:50.524]             sys.calls <- base::sys.calls
[17:43:50.524]             `[[` <- base::`[[`
[17:43:50.524]             `+` <- base::`+`
[17:43:50.524]             `<<-` <- base::`<<-`
[17:43:50.524]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.524]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.524]                   3L)]
[17:43:50.524]             }
[17:43:50.524]             function(cond) {
[17:43:50.524]                 is_error <- inherits(cond, "error")
[17:43:50.524]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.524]                   NULL)
[17:43:50.524]                 if (is_error) {
[17:43:50.524]                   sessionInformation <- function() {
[17:43:50.524]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.524]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.524]                       search = base::search(), system = base::Sys.info())
[17:43:50.524]                   }
[17:43:50.524]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.524]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.524]                     cond$call), session = sessionInformation(), 
[17:43:50.524]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.524]                   signalCondition(cond)
[17:43:50.524]                 }
[17:43:50.524]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.524]                 "immediateCondition"))) {
[17:43:50.524]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.524]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.524]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.524]                   if (TRUE && !signal) {
[17:43:50.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.524]                     {
[17:43:50.524]                       inherits <- base::inherits
[17:43:50.524]                       invokeRestart <- base::invokeRestart
[17:43:50.524]                       is.null <- base::is.null
[17:43:50.524]                       muffled <- FALSE
[17:43:50.524]                       if (inherits(cond, "message")) {
[17:43:50.524]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.524]                         if (muffled) 
[17:43:50.524]                           invokeRestart("muffleMessage")
[17:43:50.524]                       }
[17:43:50.524]                       else if (inherits(cond, "warning")) {
[17:43:50.524]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.524]                         if (muffled) 
[17:43:50.524]                           invokeRestart("muffleWarning")
[17:43:50.524]                       }
[17:43:50.524]                       else if (inherits(cond, "condition")) {
[17:43:50.524]                         if (!is.null(pattern)) {
[17:43:50.524]                           computeRestarts <- base::computeRestarts
[17:43:50.524]                           grepl <- base::grepl
[17:43:50.524]                           restarts <- computeRestarts(cond)
[17:43:50.524]                           for (restart in restarts) {
[17:43:50.524]                             name <- restart$name
[17:43:50.524]                             if (is.null(name)) 
[17:43:50.524]                               next
[17:43:50.524]                             if (!grepl(pattern, name)) 
[17:43:50.524]                               next
[17:43:50.524]                             invokeRestart(restart)
[17:43:50.524]                             muffled <- TRUE
[17:43:50.524]                             break
[17:43:50.524]                           }
[17:43:50.524]                         }
[17:43:50.524]                       }
[17:43:50.524]                       invisible(muffled)
[17:43:50.524]                     }
[17:43:50.524]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.524]                   }
[17:43:50.524]                 }
[17:43:50.524]                 else {
[17:43:50.524]                   if (TRUE) {
[17:43:50.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.524]                     {
[17:43:50.524]                       inherits <- base::inherits
[17:43:50.524]                       invokeRestart <- base::invokeRestart
[17:43:50.524]                       is.null <- base::is.null
[17:43:50.524]                       muffled <- FALSE
[17:43:50.524]                       if (inherits(cond, "message")) {
[17:43:50.524]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.524]                         if (muffled) 
[17:43:50.524]                           invokeRestart("muffleMessage")
[17:43:50.524]                       }
[17:43:50.524]                       else if (inherits(cond, "warning")) {
[17:43:50.524]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.524]                         if (muffled) 
[17:43:50.524]                           invokeRestart("muffleWarning")
[17:43:50.524]                       }
[17:43:50.524]                       else if (inherits(cond, "condition")) {
[17:43:50.524]                         if (!is.null(pattern)) {
[17:43:50.524]                           computeRestarts <- base::computeRestarts
[17:43:50.524]                           grepl <- base::grepl
[17:43:50.524]                           restarts <- computeRestarts(cond)
[17:43:50.524]                           for (restart in restarts) {
[17:43:50.524]                             name <- restart$name
[17:43:50.524]                             if (is.null(name)) 
[17:43:50.524]                               next
[17:43:50.524]                             if (!grepl(pattern, name)) 
[17:43:50.524]                               next
[17:43:50.524]                             invokeRestart(restart)
[17:43:50.524]                             muffled <- TRUE
[17:43:50.524]                             break
[17:43:50.524]                           }
[17:43:50.524]                         }
[17:43:50.524]                       }
[17:43:50.524]                       invisible(muffled)
[17:43:50.524]                     }
[17:43:50.524]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.524]                   }
[17:43:50.524]                 }
[17:43:50.524]             }
[17:43:50.524]         }))
[17:43:50.524]     }, error = function(ex) {
[17:43:50.524]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.524]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.524]                 ...future.rng), started = ...future.startTime, 
[17:43:50.524]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.524]             version = "1.8"), class = "FutureResult")
[17:43:50.524]     }, finally = {
[17:43:50.524]         if (!identical(...future.workdir, getwd())) 
[17:43:50.524]             setwd(...future.workdir)
[17:43:50.524]         {
[17:43:50.524]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.524]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.524]             }
[17:43:50.524]             base::options(...future.oldOptions)
[17:43:50.524]             if (.Platform$OS.type == "windows") {
[17:43:50.524]                 old_names <- names(...future.oldEnvVars)
[17:43:50.524]                 envs <- base::Sys.getenv()
[17:43:50.524]                 names <- names(envs)
[17:43:50.524]                 common <- intersect(names, old_names)
[17:43:50.524]                 added <- setdiff(names, old_names)
[17:43:50.524]                 removed <- setdiff(old_names, names)
[17:43:50.524]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.524]                   envs[common]]
[17:43:50.524]                 NAMES <- toupper(changed)
[17:43:50.524]                 args <- list()
[17:43:50.524]                 for (kk in seq_along(NAMES)) {
[17:43:50.524]                   name <- changed[[kk]]
[17:43:50.524]                   NAME <- NAMES[[kk]]
[17:43:50.524]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.524]                     next
[17:43:50.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.524]                 }
[17:43:50.524]                 NAMES <- toupper(added)
[17:43:50.524]                 for (kk in seq_along(NAMES)) {
[17:43:50.524]                   name <- added[[kk]]
[17:43:50.524]                   NAME <- NAMES[[kk]]
[17:43:50.524]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.524]                     next
[17:43:50.524]                   args[[name]] <- ""
[17:43:50.524]                 }
[17:43:50.524]                 NAMES <- toupper(removed)
[17:43:50.524]                 for (kk in seq_along(NAMES)) {
[17:43:50.524]                   name <- removed[[kk]]
[17:43:50.524]                   NAME <- NAMES[[kk]]
[17:43:50.524]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.524]                     next
[17:43:50.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.524]                 }
[17:43:50.524]                 if (length(args) > 0) 
[17:43:50.524]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.524]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.524]             }
[17:43:50.524]             else {
[17:43:50.524]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.524]             }
[17:43:50.524]             {
[17:43:50.524]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.524]                   0L) {
[17:43:50.524]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.524]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.524]                   base::options(opts)
[17:43:50.524]                 }
[17:43:50.524]                 {
[17:43:50.524]                   {
[17:43:50.524]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.524]                     NULL
[17:43:50.524]                   }
[17:43:50.524]                   options(future.plan = NULL)
[17:43:50.524]                   if (is.na(NA_character_)) 
[17:43:50.524]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.524]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.524]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:50.524]                     .init = FALSE)
[17:43:50.524]                 }
[17:43:50.524]             }
[17:43:50.524]         }
[17:43:50.524]     })
[17:43:50.524]     if (TRUE) {
[17:43:50.524]         base::sink(type = "output", split = FALSE)
[17:43:50.524]         if (TRUE) {
[17:43:50.524]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.524]         }
[17:43:50.524]         else {
[17:43:50.524]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.524]         }
[17:43:50.524]         base::close(...future.stdout)
[17:43:50.524]         ...future.stdout <- NULL
[17:43:50.524]     }
[17:43:50.524]     ...future.result$conditions <- ...future.conditions
[17:43:50.524]     ...future.result$finished <- base::Sys.time()
[17:43:50.524]     ...future.result
[17:43:50.524] }
[17:43:50.528] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[17:43:50.528] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:50.528] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:50.528] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:43:50.529] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:43:50.529] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:43:50.529] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:43:50.529] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:50.530] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:50.530] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:43:50.530] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:43:50.530] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[17:43:50.531] MultisessionFuture started
[17:43:50.531] - Launch lazy future ... done
[17:43:50.531] run() for ‘MultisessionFuture’ ... done
[17:43:50.531] Created future:
[17:43:50.531] MultisessionFuture:
[17:43:50.531] Label: ‘future_apply-1’
[17:43:50.531] Expression:
[17:43:50.531] {
[17:43:50.531]     do.call(function(...) {
[17:43:50.531]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.531]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.531]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.531]             on.exit(options(oopts), add = TRUE)
[17:43:50.531]         }
[17:43:50.531]         {
[17:43:50.531]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.531]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.531]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.531]             })
[17:43:50.531]         }
[17:43:50.531]     }, args = future.call.arguments)
[17:43:50.531] }
[17:43:50.531] Lazy evaluation: FALSE
[17:43:50.531] Asynchronous evaluation: TRUE
[17:43:50.531] Local evaluation: TRUE
[17:43:50.531] Environment: R_GlobalEnv
[17:43:50.531] Capture standard output: TRUE
[17:43:50.531] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:50.531] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:50.531] Packages: <none>
[17:43:50.531] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:50.531] Resolved: FALSE
[17:43:50.531] Value: <not collected>
[17:43:50.531] Conditions captured: <none>
[17:43:50.531] Early signaling: FALSE
[17:43:50.531] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:50.531] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.543] Chunk #1 of 2 ... DONE
[17:43:50.543] Chunk #2 of 2 ...
[17:43:50.543]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:50.543]  - seeds: <none>
[17:43:50.544]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.544] getGlobalsAndPackages() ...
[17:43:50.544] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.544] Resolving globals: FALSE
[17:43:50.544] Tweak future expression to call with '...' arguments ...
[17:43:50.544] {
[17:43:50.544]     do.call(function(...) {
[17:43:50.544]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.544]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.544]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.544]             on.exit(options(oopts), add = TRUE)
[17:43:50.544]         }
[17:43:50.544]         {
[17:43:50.544]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.544]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.544]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.544]             })
[17:43:50.544]         }
[17:43:50.544]     }, args = future.call.arguments)
[17:43:50.544] }
[17:43:50.544] Tweak future expression to call with '...' arguments ... DONE
[17:43:50.545] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.545] 
[17:43:50.545] getGlobalsAndPackages() ... DONE
[17:43:50.545] run() for ‘Future’ ...
[17:43:50.545] - state: ‘created’
[17:43:50.545] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.560] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.560] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.560]   - Field: ‘node’
[17:43:50.560]   - Field: ‘label’
[17:43:50.560]   - Field: ‘local’
[17:43:50.560]   - Field: ‘owner’
[17:43:50.560]   - Field: ‘envir’
[17:43:50.561]   - Field: ‘workers’
[17:43:50.561]   - Field: ‘packages’
[17:43:50.561]   - Field: ‘gc’
[17:43:50.561]   - Field: ‘conditions’
[17:43:50.561]   - Field: ‘persistent’
[17:43:50.561]   - Field: ‘expr’
[17:43:50.561]   - Field: ‘uuid’
[17:43:50.561]   - Field: ‘seed’
[17:43:50.561]   - Field: ‘version’
[17:43:50.561]   - Field: ‘result’
[17:43:50.561]   - Field: ‘asynchronous’
[17:43:50.561]   - Field: ‘calls’
[17:43:50.562]   - Field: ‘globals’
[17:43:50.562]   - Field: ‘stdout’
[17:43:50.562]   - Field: ‘earlySignal’
[17:43:50.562]   - Field: ‘lazy’
[17:43:50.562]   - Field: ‘state’
[17:43:50.562] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.562] - Launch lazy future ...
[17:43:50.562] Packages needed by the future expression (n = 0): <none>
[17:43:50.562] Packages needed by future strategies (n = 0): <none>
[17:43:50.563] {
[17:43:50.563]     {
[17:43:50.563]         {
[17:43:50.563]             ...future.startTime <- base::Sys.time()
[17:43:50.563]             {
[17:43:50.563]                 {
[17:43:50.563]                   {
[17:43:50.563]                     {
[17:43:50.563]                       base::local({
[17:43:50.563]                         has_future <- base::requireNamespace("future", 
[17:43:50.563]                           quietly = TRUE)
[17:43:50.563]                         if (has_future) {
[17:43:50.563]                           ns <- base::getNamespace("future")
[17:43:50.563]                           version <- ns[[".package"]][["version"]]
[17:43:50.563]                           if (is.null(version)) 
[17:43:50.563]                             version <- utils::packageVersion("future")
[17:43:50.563]                         }
[17:43:50.563]                         else {
[17:43:50.563]                           version <- NULL
[17:43:50.563]                         }
[17:43:50.563]                         if (!has_future || version < "1.8.0") {
[17:43:50.563]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.563]                             "", base::R.version$version.string), 
[17:43:50.563]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:50.563]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:50.563]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.563]                               "release", "version")], collapse = " "), 
[17:43:50.563]                             hostname = base::Sys.info()[["nodename"]])
[17:43:50.563]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.563]                             info)
[17:43:50.563]                           info <- base::paste(info, collapse = "; ")
[17:43:50.563]                           if (!has_future) {
[17:43:50.563]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.563]                               info)
[17:43:50.563]                           }
[17:43:50.563]                           else {
[17:43:50.563]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.563]                               info, version)
[17:43:50.563]                           }
[17:43:50.563]                           base::stop(msg)
[17:43:50.563]                         }
[17:43:50.563]                       })
[17:43:50.563]                     }
[17:43:50.563]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.563]                     base::options(mc.cores = 1L)
[17:43:50.563]                   }
[17:43:50.563]                   ...future.strategy.old <- future::plan("list")
[17:43:50.563]                   options(future.plan = NULL)
[17:43:50.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.563]                 }
[17:43:50.563]                 ...future.workdir <- getwd()
[17:43:50.563]             }
[17:43:50.563]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.563]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.563]         }
[17:43:50.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.563]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:50.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.563]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.563]             base::names(...future.oldOptions))
[17:43:50.563]     }
[17:43:50.563]     if (FALSE) {
[17:43:50.563]     }
[17:43:50.563]     else {
[17:43:50.563]         if (TRUE) {
[17:43:50.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.563]                 open = "w")
[17:43:50.563]         }
[17:43:50.563]         else {
[17:43:50.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.563]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.563]         }
[17:43:50.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.563]             base::sink(type = "output", split = FALSE)
[17:43:50.563]             base::close(...future.stdout)
[17:43:50.563]         }, add = TRUE)
[17:43:50.563]     }
[17:43:50.563]     ...future.frame <- base::sys.nframe()
[17:43:50.563]     ...future.conditions <- base::list()
[17:43:50.563]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.563]     if (FALSE) {
[17:43:50.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.563]     }
[17:43:50.563]     ...future.result <- base::tryCatch({
[17:43:50.563]         base::withCallingHandlers({
[17:43:50.563]             ...future.value <- base::withVisible(base::local({
[17:43:50.563]                 ...future.makeSendCondition <- base::local({
[17:43:50.563]                   sendCondition <- NULL
[17:43:50.563]                   function(frame = 1L) {
[17:43:50.563]                     if (is.function(sendCondition)) 
[17:43:50.563]                       return(sendCondition)
[17:43:50.563]                     ns <- getNamespace("parallel")
[17:43:50.563]                     if (exists("sendData", mode = "function", 
[17:43:50.563]                       envir = ns)) {
[17:43:50.563]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.563]                         envir = ns)
[17:43:50.563]                       envir <- sys.frame(frame)
[17:43:50.563]                       master <- NULL
[17:43:50.563]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.563]                         !identical(envir, emptyenv())) {
[17:43:50.563]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.563]                           inherits = FALSE)) {
[17:43:50.563]                           master <- get("master", mode = "list", 
[17:43:50.563]                             envir = envir, inherits = FALSE)
[17:43:50.563]                           if (inherits(master, c("SOCKnode", 
[17:43:50.563]                             "SOCK0node"))) {
[17:43:50.563]                             sendCondition <<- function(cond) {
[17:43:50.563]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.563]                                 success = TRUE)
[17:43:50.563]                               parallel_sendData(master, data)
[17:43:50.563]                             }
[17:43:50.563]                             return(sendCondition)
[17:43:50.563]                           }
[17:43:50.563]                         }
[17:43:50.563]                         frame <- frame + 1L
[17:43:50.563]                         envir <- sys.frame(frame)
[17:43:50.563]                       }
[17:43:50.563]                     }
[17:43:50.563]                     sendCondition <<- function(cond) NULL
[17:43:50.563]                   }
[17:43:50.563]                 })
[17:43:50.563]                 withCallingHandlers({
[17:43:50.563]                   {
[17:43:50.563]                     do.call(function(...) {
[17:43:50.563]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.563]                       if (!identical(...future.globals.maxSize.org, 
[17:43:50.563]                         ...future.globals.maxSize)) {
[17:43:50.563]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.563]                         on.exit(options(oopts), add = TRUE)
[17:43:50.563]                       }
[17:43:50.563]                       {
[17:43:50.563]                         lapply(seq_along(...future.elements_ii), 
[17:43:50.563]                           FUN = function(jj) {
[17:43:50.563]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.563]                             ...future.FUN(...future.X_jj, ...)
[17:43:50.563]                           })
[17:43:50.563]                       }
[17:43:50.563]                     }, args = future.call.arguments)
[17:43:50.563]                   }
[17:43:50.563]                 }, immediateCondition = function(cond) {
[17:43:50.563]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.563]                   sendCondition(cond)
[17:43:50.563]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.563]                   {
[17:43:50.563]                     inherits <- base::inherits
[17:43:50.563]                     invokeRestart <- base::invokeRestart
[17:43:50.563]                     is.null <- base::is.null
[17:43:50.563]                     muffled <- FALSE
[17:43:50.563]                     if (inherits(cond, "message")) {
[17:43:50.563]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.563]                       if (muffled) 
[17:43:50.563]                         invokeRestart("muffleMessage")
[17:43:50.563]                     }
[17:43:50.563]                     else if (inherits(cond, "warning")) {
[17:43:50.563]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.563]                       if (muffled) 
[17:43:50.563]                         invokeRestart("muffleWarning")
[17:43:50.563]                     }
[17:43:50.563]                     else if (inherits(cond, "condition")) {
[17:43:50.563]                       if (!is.null(pattern)) {
[17:43:50.563]                         computeRestarts <- base::computeRestarts
[17:43:50.563]                         grepl <- base::grepl
[17:43:50.563]                         restarts <- computeRestarts(cond)
[17:43:50.563]                         for (restart in restarts) {
[17:43:50.563]                           name <- restart$name
[17:43:50.563]                           if (is.null(name)) 
[17:43:50.563]                             next
[17:43:50.563]                           if (!grepl(pattern, name)) 
[17:43:50.563]                             next
[17:43:50.563]                           invokeRestart(restart)
[17:43:50.563]                           muffled <- TRUE
[17:43:50.563]                           break
[17:43:50.563]                         }
[17:43:50.563]                       }
[17:43:50.563]                     }
[17:43:50.563]                     invisible(muffled)
[17:43:50.563]                   }
[17:43:50.563]                   muffleCondition(cond)
[17:43:50.563]                 })
[17:43:50.563]             }))
[17:43:50.563]             future::FutureResult(value = ...future.value$value, 
[17:43:50.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.563]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.563]                     ...future.globalenv.names))
[17:43:50.563]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.563]         }, condition = base::local({
[17:43:50.563]             c <- base::c
[17:43:50.563]             inherits <- base::inherits
[17:43:50.563]             invokeRestart <- base::invokeRestart
[17:43:50.563]             length <- base::length
[17:43:50.563]             list <- base::list
[17:43:50.563]             seq.int <- base::seq.int
[17:43:50.563]             signalCondition <- base::signalCondition
[17:43:50.563]             sys.calls <- base::sys.calls
[17:43:50.563]             `[[` <- base::`[[`
[17:43:50.563]             `+` <- base::`+`
[17:43:50.563]             `<<-` <- base::`<<-`
[17:43:50.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.563]                   3L)]
[17:43:50.563]             }
[17:43:50.563]             function(cond) {
[17:43:50.563]                 is_error <- inherits(cond, "error")
[17:43:50.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.563]                   NULL)
[17:43:50.563]                 if (is_error) {
[17:43:50.563]                   sessionInformation <- function() {
[17:43:50.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.563]                       search = base::search(), system = base::Sys.info())
[17:43:50.563]                   }
[17:43:50.563]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.563]                     cond$call), session = sessionInformation(), 
[17:43:50.563]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.563]                   signalCondition(cond)
[17:43:50.563]                 }
[17:43:50.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.563]                 "immediateCondition"))) {
[17:43:50.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.563]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.563]                   if (TRUE && !signal) {
[17:43:50.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.563]                     {
[17:43:50.563]                       inherits <- base::inherits
[17:43:50.563]                       invokeRestart <- base::invokeRestart
[17:43:50.563]                       is.null <- base::is.null
[17:43:50.563]                       muffled <- FALSE
[17:43:50.563]                       if (inherits(cond, "message")) {
[17:43:50.563]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.563]                         if (muffled) 
[17:43:50.563]                           invokeRestart("muffleMessage")
[17:43:50.563]                       }
[17:43:50.563]                       else if (inherits(cond, "warning")) {
[17:43:50.563]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.563]                         if (muffled) 
[17:43:50.563]                           invokeRestart("muffleWarning")
[17:43:50.563]                       }
[17:43:50.563]                       else if (inherits(cond, "condition")) {
[17:43:50.563]                         if (!is.null(pattern)) {
[17:43:50.563]                           computeRestarts <- base::computeRestarts
[17:43:50.563]                           grepl <- base::grepl
[17:43:50.563]                           restarts <- computeRestarts(cond)
[17:43:50.563]                           for (restart in restarts) {
[17:43:50.563]                             name <- restart$name
[17:43:50.563]                             if (is.null(name)) 
[17:43:50.563]                               next
[17:43:50.563]                             if (!grepl(pattern, name)) 
[17:43:50.563]                               next
[17:43:50.563]                             invokeRestart(restart)
[17:43:50.563]                             muffled <- TRUE
[17:43:50.563]                             break
[17:43:50.563]                           }
[17:43:50.563]                         }
[17:43:50.563]                       }
[17:43:50.563]                       invisible(muffled)
[17:43:50.563]                     }
[17:43:50.563]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.563]                   }
[17:43:50.563]                 }
[17:43:50.563]                 else {
[17:43:50.563]                   if (TRUE) {
[17:43:50.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.563]                     {
[17:43:50.563]                       inherits <- base::inherits
[17:43:50.563]                       invokeRestart <- base::invokeRestart
[17:43:50.563]                       is.null <- base::is.null
[17:43:50.563]                       muffled <- FALSE
[17:43:50.563]                       if (inherits(cond, "message")) {
[17:43:50.563]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.563]                         if (muffled) 
[17:43:50.563]                           invokeRestart("muffleMessage")
[17:43:50.563]                       }
[17:43:50.563]                       else if (inherits(cond, "warning")) {
[17:43:50.563]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.563]                         if (muffled) 
[17:43:50.563]                           invokeRestart("muffleWarning")
[17:43:50.563]                       }
[17:43:50.563]                       else if (inherits(cond, "condition")) {
[17:43:50.563]                         if (!is.null(pattern)) {
[17:43:50.563]                           computeRestarts <- base::computeRestarts
[17:43:50.563]                           grepl <- base::grepl
[17:43:50.563]                           restarts <- computeRestarts(cond)
[17:43:50.563]                           for (restart in restarts) {
[17:43:50.563]                             name <- restart$name
[17:43:50.563]                             if (is.null(name)) 
[17:43:50.563]                               next
[17:43:50.563]                             if (!grepl(pattern, name)) 
[17:43:50.563]                               next
[17:43:50.563]                             invokeRestart(restart)
[17:43:50.563]                             muffled <- TRUE
[17:43:50.563]                             break
[17:43:50.563]                           }
[17:43:50.563]                         }
[17:43:50.563]                       }
[17:43:50.563]                       invisible(muffled)
[17:43:50.563]                     }
[17:43:50.563]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.563]                   }
[17:43:50.563]                 }
[17:43:50.563]             }
[17:43:50.563]         }))
[17:43:50.563]     }, error = function(ex) {
[17:43:50.563]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.563]                 ...future.rng), started = ...future.startTime, 
[17:43:50.563]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.563]             version = "1.8"), class = "FutureResult")
[17:43:50.563]     }, finally = {
[17:43:50.563]         if (!identical(...future.workdir, getwd())) 
[17:43:50.563]             setwd(...future.workdir)
[17:43:50.563]         {
[17:43:50.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.563]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.563]             }
[17:43:50.563]             base::options(...future.oldOptions)
[17:43:50.563]             if (.Platform$OS.type == "windows") {
[17:43:50.563]                 old_names <- names(...future.oldEnvVars)
[17:43:50.563]                 envs <- base::Sys.getenv()
[17:43:50.563]                 names <- names(envs)
[17:43:50.563]                 common <- intersect(names, old_names)
[17:43:50.563]                 added <- setdiff(names, old_names)
[17:43:50.563]                 removed <- setdiff(old_names, names)
[17:43:50.563]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.563]                   envs[common]]
[17:43:50.563]                 NAMES <- toupper(changed)
[17:43:50.563]                 args <- list()
[17:43:50.563]                 for (kk in seq_along(NAMES)) {
[17:43:50.563]                   name <- changed[[kk]]
[17:43:50.563]                   NAME <- NAMES[[kk]]
[17:43:50.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.563]                     next
[17:43:50.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.563]                 }
[17:43:50.563]                 NAMES <- toupper(added)
[17:43:50.563]                 for (kk in seq_along(NAMES)) {
[17:43:50.563]                   name <- added[[kk]]
[17:43:50.563]                   NAME <- NAMES[[kk]]
[17:43:50.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.563]                     next
[17:43:50.563]                   args[[name]] <- ""
[17:43:50.563]                 }
[17:43:50.563]                 NAMES <- toupper(removed)
[17:43:50.563]                 for (kk in seq_along(NAMES)) {
[17:43:50.563]                   name <- removed[[kk]]
[17:43:50.563]                   NAME <- NAMES[[kk]]
[17:43:50.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.563]                     next
[17:43:50.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.563]                 }
[17:43:50.563]                 if (length(args) > 0) 
[17:43:50.563]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.563]             }
[17:43:50.563]             else {
[17:43:50.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.563]             }
[17:43:50.563]             {
[17:43:50.563]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.563]                   0L) {
[17:43:50.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.563]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.563]                   base::options(opts)
[17:43:50.563]                 }
[17:43:50.563]                 {
[17:43:50.563]                   {
[17:43:50.563]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.563]                     NULL
[17:43:50.563]                   }
[17:43:50.563]                   options(future.plan = NULL)
[17:43:50.563]                   if (is.na(NA_character_)) 
[17:43:50.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.563]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:50.563]                     .init = FALSE)
[17:43:50.563]                 }
[17:43:50.563]             }
[17:43:50.563]         }
[17:43:50.563]     })
[17:43:50.563]     if (TRUE) {
[17:43:50.563]         base::sink(type = "output", split = FALSE)
[17:43:50.563]         if (TRUE) {
[17:43:50.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.563]         }
[17:43:50.563]         else {
[17:43:50.563]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.563]         }
[17:43:50.563]         base::close(...future.stdout)
[17:43:50.563]         ...future.stdout <- NULL
[17:43:50.563]     }
[17:43:50.563]     ...future.result$conditions <- ...future.conditions
[17:43:50.563]     ...future.result$finished <- base::Sys.time()
[17:43:50.563]     ...future.result
[17:43:50.563] }
[17:43:50.566] Exporting 5 global objects (0.99 KiB) to cluster node #2 ...
[17:43:50.566] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:50.566] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:50.567] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:43:50.567] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:43:50.567] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:43:50.567] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:43:50.568] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:50.568] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:50.568] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:43:50.568] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:43:50.568] Exporting 5 global objects (0.99 KiB) to cluster node #2 ... DONE
[17:43:50.569] MultisessionFuture started
[17:43:50.569] - Launch lazy future ... done
[17:43:50.569] run() for ‘MultisessionFuture’ ... done
[17:43:50.569] Created future:
[17:43:50.569] MultisessionFuture:
[17:43:50.569] Label: ‘future_apply-2’
[17:43:50.569] Expression:
[17:43:50.569] {
[17:43:50.569]     do.call(function(...) {
[17:43:50.569]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.569]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.569]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.569]             on.exit(options(oopts), add = TRUE)
[17:43:50.569]         }
[17:43:50.569]         {
[17:43:50.569]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.569]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.569]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.569]             })
[17:43:50.569]         }
[17:43:50.569]     }, args = future.call.arguments)
[17:43:50.569] }
[17:43:50.569] Lazy evaluation: FALSE
[17:43:50.569] Asynchronous evaluation: TRUE
[17:43:50.569] Local evaluation: TRUE
[17:43:50.569] Environment: R_GlobalEnv
[17:43:50.569] Capture standard output: TRUE
[17:43:50.569] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:50.569] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:50.569] Packages: <none>
[17:43:50.569] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:50.569] Resolved: FALSE
[17:43:50.569] Value: <not collected>
[17:43:50.569] Conditions captured: <none>
[17:43:50.569] Early signaling: FALSE
[17:43:50.569] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:50.569] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.581] Chunk #2 of 2 ... DONE
[17:43:50.581] Launching 2 futures (chunks) ... DONE
[17:43:50.581] Resolving 2 futures (chunks) ...
[17:43:50.581] resolve() on list ...
[17:43:50.581]  recursive: 0
[17:43:50.581]  length: 2
[17:43:50.581] 
[17:43:50.582] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.582] - Validating connection of MultisessionFuture
[17:43:50.582] - received message: FutureResult
[17:43:50.582] - Received FutureResult
[17:43:50.582] - Erased future from FutureRegistry
[17:43:50.582] result() for ClusterFuture ...
[17:43:50.582] - result already collected: FutureResult
[17:43:50.582] result() for ClusterFuture ... done
[17:43:50.583] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.583] Future #1
[17:43:50.583] result() for ClusterFuture ...
[17:43:50.583] - result already collected: FutureResult
[17:43:50.583] result() for ClusterFuture ... done
[17:43:50.583] result() for ClusterFuture ...
[17:43:50.583] - result already collected: FutureResult
[17:43:50.583] result() for ClusterFuture ... done
[17:43:50.583] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:50.583] - nx: 2
[17:43:50.584] - relay: TRUE
[17:43:50.584] - stdout: TRUE
[17:43:50.584] - signal: TRUE
[17:43:50.584] - resignal: FALSE
[17:43:50.584] - force: TRUE
[17:43:50.584] - relayed: [n=2] FALSE, FALSE
[17:43:50.584] - queued futures: [n=2] FALSE, FALSE
[17:43:50.584]  - until=1
[17:43:50.584]  - relaying element #1
[17:43:50.584] result() for ClusterFuture ...
[17:43:50.584] - result already collected: FutureResult
[17:43:50.584] result() for ClusterFuture ... done
[17:43:50.585] result() for ClusterFuture ...
[17:43:50.585] - result already collected: FutureResult
[17:43:50.585] result() for ClusterFuture ... done
[17:43:50.585] result() for ClusterFuture ...
[17:43:50.585] - result already collected: FutureResult
[17:43:50.585] result() for ClusterFuture ... done
[17:43:50.585] result() for ClusterFuture ...
[17:43:50.585] - result already collected: FutureResult
[17:43:50.585] result() for ClusterFuture ... done
[17:43:50.585] - relayed: [n=2] TRUE, FALSE
[17:43:50.585] - queued futures: [n=2] TRUE, FALSE
[17:43:50.586] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:50.586]  length: 1 (resolved future 1)
[17:43:50.613] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.613] - Validating connection of MultisessionFuture
[17:43:50.613] - received message: FutureResult
[17:43:50.613] - Received FutureResult
[17:43:50.613] - Erased future from FutureRegistry
[17:43:50.613] result() for ClusterFuture ...
[17:43:50.614] - result already collected: FutureResult
[17:43:50.614] result() for ClusterFuture ... done
[17:43:50.614] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.614] Future #2
[17:43:50.614] result() for ClusterFuture ...
[17:43:50.614] - result already collected: FutureResult
[17:43:50.614] result() for ClusterFuture ... done
[17:43:50.614] result() for ClusterFuture ...
[17:43:50.614] - result already collected: FutureResult
[17:43:50.614] result() for ClusterFuture ... done
[17:43:50.614] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:50.615] - nx: 2
[17:43:50.615] - relay: TRUE
[17:43:50.615] - stdout: TRUE
[17:43:50.615] - signal: TRUE
[17:43:50.615] - resignal: FALSE
[17:43:50.615] - force: TRUE
[17:43:50.615] - relayed: [n=2] TRUE, FALSE
[17:43:50.615] - queued futures: [n=2] TRUE, FALSE
[17:43:50.615]  - until=2
[17:43:50.615]  - relaying element #2
[17:43:50.615] result() for ClusterFuture ...
[17:43:50.616] - result already collected: FutureResult
[17:43:50.616] result() for ClusterFuture ... done
[17:43:50.616] result() for ClusterFuture ...
[17:43:50.616] - result already collected: FutureResult
[17:43:50.616] result() for ClusterFuture ... done
[17:43:50.616] result() for ClusterFuture ...
[17:43:50.616] - result already collected: FutureResult
[17:43:50.616] result() for ClusterFuture ... done
[17:43:50.616] result() for ClusterFuture ...
[17:43:50.616] - result already collected: FutureResult
[17:43:50.616] result() for ClusterFuture ... done
[17:43:50.616] - relayed: [n=2] TRUE, TRUE
[17:43:50.617] - queued futures: [n=2] TRUE, TRUE
[17:43:50.617] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:50.617]  length: 0 (resolved future 2)
[17:43:50.617] Relaying remaining futures
[17:43:50.617] signalConditionsASAP(NULL, pos=0) ...
[17:43:50.617] - nx: 2
[17:43:50.617] - relay: TRUE
[17:43:50.617] - stdout: TRUE
[17:43:50.617] - signal: TRUE
[17:43:50.617] - resignal: FALSE
[17:43:50.617] - force: TRUE
[17:43:50.617] - relayed: [n=2] TRUE, TRUE
[17:43:50.618] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:50.618] - relayed: [n=2] TRUE, TRUE
[17:43:50.618] - queued futures: [n=2] TRUE, TRUE
[17:43:50.618] signalConditionsASAP(NULL, pos=0) ... done
[17:43:50.618] resolve() on list ... DONE
[17:43:50.618] result() for ClusterFuture ...
[17:43:50.618] - result already collected: FutureResult
[17:43:50.618] result() for ClusterFuture ... done
[17:43:50.618] result() for ClusterFuture ...
[17:43:50.618] - result already collected: FutureResult
[17:43:50.618] result() for ClusterFuture ... done
[17:43:50.619] result() for ClusterFuture ...
[17:43:50.619] - result already collected: FutureResult
[17:43:50.619] result() for ClusterFuture ... done
[17:43:50.619] result() for ClusterFuture ...
[17:43:50.619] - result already collected: FutureResult
[17:43:50.619] result() for ClusterFuture ... done
[17:43:50.619]  - Number of value chunks collected: 2
[17:43:50.619] Resolving 2 futures (chunks) ... DONE
[17:43:50.619] Reducing values from 2 chunks ...
[17:43:50.619]  - Number of values collected after concatenation: 2
[17:43:50.619]  - Number of values expected: 2
[17:43:50.620] Reducing values from 2 chunks ... DONE
[17:43:50.620] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[17:43:50.620] getGlobalsAndPackagesXApply() ...
[17:43:50.620]  - future.globals: TRUE
[17:43:50.620] getGlobalsAndPackages() ...
[17:43:50.620] Searching for globals...
[17:43:50.621] - globals found: [1] ‘FUN’
[17:43:50.621] Searching for globals ... DONE
[17:43:50.622] Resolving globals: FALSE
[17:43:50.622] The total size of the 1 globals is 848 bytes (848 bytes)
[17:43:50.622] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:43:50.622] - globals: [1] ‘FUN’
[17:43:50.622] 
[17:43:50.623] getGlobalsAndPackages() ... DONE
[17:43:50.623]  - globals found/used: [n=1] ‘FUN’
[17:43:50.623]  - needed namespaces: [n=0] 
[17:43:50.623] Finding globals ... DONE
[17:43:50.623]  - use_args: TRUE
[17:43:50.623]  - Getting '...' globals ...
[17:43:50.623] resolve() on list ...
[17:43:50.623]  recursive: 0
[17:43:50.623]  length: 1
[17:43:50.624]  elements: ‘...’
[17:43:50.624]  length: 0 (resolved future 1)
[17:43:50.624] resolve() on list ... DONE
[17:43:50.624]    - '...' content: [n=0] 
[17:43:50.624] List of 1
[17:43:50.624]  $ ...: list()
[17:43:50.624]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.624]  - attr(*, "where")=List of 1
[17:43:50.624]   ..$ ...:<environment: 0x55dfd6066a90> 
[17:43:50.624]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.624]  - attr(*, "resolved")= logi TRUE
[17:43:50.624]  - attr(*, "total_size")= num NA
[17:43:50.626]  - Getting '...' globals ... DONE
[17:43:50.627] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:50.627] List of 2
[17:43:50.627]  $ ...future.FUN:function (x)  
[17:43:50.627]  $ ...          : list()
[17:43:50.627]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.627]  - attr(*, "where")=List of 2
[17:43:50.627]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:50.627]   ..$ ...          :<environment: 0x55dfd6066a90> 
[17:43:50.627]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.627]  - attr(*, "resolved")= logi FALSE
[17:43:50.627]  - attr(*, "total_size")= num 848
[17:43:50.629] Packages to be attached in all futures: [n=0] 
[17:43:50.629] getGlobalsAndPackagesXApply() ... DONE
[17:43:50.633] future_lapply() ...
[17:43:50.637] Number of chunks: 2
[17:43:50.637] getGlobalsAndPackagesXApply() ...
[17:43:50.637]  - future.globals: <name-value list> with names ‘list()’
[17:43:50.637]  - use_args: TRUE
[17:43:50.637] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:50.637] List of 2
[17:43:50.637]  $ ...          : list()
[17:43:50.637]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.637]  $ ...future.FUN:function (x)  
[17:43:50.637]  - attr(*, "where")=List of 2
[17:43:50.637]   ..$ ...          :<environment: 0x55dfd6066a90> 
[17:43:50.637]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:50.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.637]  - attr(*, "resolved")= logi FALSE
[17:43:50.637]  - attr(*, "total_size")= num NA
[17:43:50.641] Packages to be attached in all futures: [n=0] 
[17:43:50.641] getGlobalsAndPackagesXApply() ... DONE
[17:43:50.641] Number of futures (= number of chunks): 2
[17:43:50.641] Launching 2 futures (chunks) ...
[17:43:50.641] Chunk #1 of 2 ...
[17:43:50.641]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:50.641]  - seeds: <none>
[17:43:50.641]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.641] getGlobalsAndPackages() ...
[17:43:50.642] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.642] Resolving globals: FALSE
[17:43:50.642] Tweak future expression to call with '...' arguments ...
[17:43:50.642] {
[17:43:50.642]     do.call(function(...) {
[17:43:50.642]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.642]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.642]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.642]             on.exit(options(oopts), add = TRUE)
[17:43:50.642]         }
[17:43:50.642]         {
[17:43:50.642]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.642]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.642]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.642]             })
[17:43:50.642]         }
[17:43:50.642]     }, args = future.call.arguments)
[17:43:50.642] }
[17:43:50.642] Tweak future expression to call with '...' arguments ... DONE
[17:43:50.643] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.643] 
[17:43:50.643] getGlobalsAndPackages() ... DONE
[17:43:50.643] run() for ‘Future’ ...
[17:43:50.643] - state: ‘created’
[17:43:50.643] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.657] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.657]   - Field: ‘node’
[17:43:50.657]   - Field: ‘label’
[17:43:50.657]   - Field: ‘local’
[17:43:50.657]   - Field: ‘owner’
[17:43:50.658]   - Field: ‘envir’
[17:43:50.658]   - Field: ‘workers’
[17:43:50.658]   - Field: ‘packages’
[17:43:50.658]   - Field: ‘gc’
[17:43:50.658]   - Field: ‘conditions’
[17:43:50.658]   - Field: ‘persistent’
[17:43:50.658]   - Field: ‘expr’
[17:43:50.658]   - Field: ‘uuid’
[17:43:50.658]   - Field: ‘seed’
[17:43:50.658]   - Field: ‘version’
[17:43:50.658]   - Field: ‘result’
[17:43:50.658]   - Field: ‘asynchronous’
[17:43:50.659]   - Field: ‘calls’
[17:43:50.659]   - Field: ‘globals’
[17:43:50.659]   - Field: ‘stdout’
[17:43:50.659]   - Field: ‘earlySignal’
[17:43:50.659]   - Field: ‘lazy’
[17:43:50.659]   - Field: ‘state’
[17:43:50.659] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.659] - Launch lazy future ...
[17:43:50.660] Packages needed by the future expression (n = 0): <none>
[17:43:50.660] Packages needed by future strategies (n = 0): <none>
[17:43:50.660] {
[17:43:50.660]     {
[17:43:50.660]         {
[17:43:50.660]             ...future.startTime <- base::Sys.time()
[17:43:50.660]             {
[17:43:50.660]                 {
[17:43:50.660]                   {
[17:43:50.660]                     {
[17:43:50.660]                       base::local({
[17:43:50.660]                         has_future <- base::requireNamespace("future", 
[17:43:50.660]                           quietly = TRUE)
[17:43:50.660]                         if (has_future) {
[17:43:50.660]                           ns <- base::getNamespace("future")
[17:43:50.660]                           version <- ns[[".package"]][["version"]]
[17:43:50.660]                           if (is.null(version)) 
[17:43:50.660]                             version <- utils::packageVersion("future")
[17:43:50.660]                         }
[17:43:50.660]                         else {
[17:43:50.660]                           version <- NULL
[17:43:50.660]                         }
[17:43:50.660]                         if (!has_future || version < "1.8.0") {
[17:43:50.660]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.660]                             "", base::R.version$version.string), 
[17:43:50.660]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:50.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:50.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.660]                               "release", "version")], collapse = " "), 
[17:43:50.660]                             hostname = base::Sys.info()[["nodename"]])
[17:43:50.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.660]                             info)
[17:43:50.660]                           info <- base::paste(info, collapse = "; ")
[17:43:50.660]                           if (!has_future) {
[17:43:50.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.660]                               info)
[17:43:50.660]                           }
[17:43:50.660]                           else {
[17:43:50.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.660]                               info, version)
[17:43:50.660]                           }
[17:43:50.660]                           base::stop(msg)
[17:43:50.660]                         }
[17:43:50.660]                       })
[17:43:50.660]                     }
[17:43:50.660]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.660]                     base::options(mc.cores = 1L)
[17:43:50.660]                   }
[17:43:50.660]                   ...future.strategy.old <- future::plan("list")
[17:43:50.660]                   options(future.plan = NULL)
[17:43:50.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.660]                 }
[17:43:50.660]                 ...future.workdir <- getwd()
[17:43:50.660]             }
[17:43:50.660]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.660]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.660]         }
[17:43:50.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.660]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:50.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.660]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.660]             base::names(...future.oldOptions))
[17:43:50.660]     }
[17:43:50.660]     if (FALSE) {
[17:43:50.660]     }
[17:43:50.660]     else {
[17:43:50.660]         if (TRUE) {
[17:43:50.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.660]                 open = "w")
[17:43:50.660]         }
[17:43:50.660]         else {
[17:43:50.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.660]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.660]         }
[17:43:50.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.660]             base::sink(type = "output", split = FALSE)
[17:43:50.660]             base::close(...future.stdout)
[17:43:50.660]         }, add = TRUE)
[17:43:50.660]     }
[17:43:50.660]     ...future.frame <- base::sys.nframe()
[17:43:50.660]     ...future.conditions <- base::list()
[17:43:50.660]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.660]     if (FALSE) {
[17:43:50.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.660]     }
[17:43:50.660]     ...future.result <- base::tryCatch({
[17:43:50.660]         base::withCallingHandlers({
[17:43:50.660]             ...future.value <- base::withVisible(base::local({
[17:43:50.660]                 ...future.makeSendCondition <- base::local({
[17:43:50.660]                   sendCondition <- NULL
[17:43:50.660]                   function(frame = 1L) {
[17:43:50.660]                     if (is.function(sendCondition)) 
[17:43:50.660]                       return(sendCondition)
[17:43:50.660]                     ns <- getNamespace("parallel")
[17:43:50.660]                     if (exists("sendData", mode = "function", 
[17:43:50.660]                       envir = ns)) {
[17:43:50.660]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.660]                         envir = ns)
[17:43:50.660]                       envir <- sys.frame(frame)
[17:43:50.660]                       master <- NULL
[17:43:50.660]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.660]                         !identical(envir, emptyenv())) {
[17:43:50.660]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.660]                           inherits = FALSE)) {
[17:43:50.660]                           master <- get("master", mode = "list", 
[17:43:50.660]                             envir = envir, inherits = FALSE)
[17:43:50.660]                           if (inherits(master, c("SOCKnode", 
[17:43:50.660]                             "SOCK0node"))) {
[17:43:50.660]                             sendCondition <<- function(cond) {
[17:43:50.660]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.660]                                 success = TRUE)
[17:43:50.660]                               parallel_sendData(master, data)
[17:43:50.660]                             }
[17:43:50.660]                             return(sendCondition)
[17:43:50.660]                           }
[17:43:50.660]                         }
[17:43:50.660]                         frame <- frame + 1L
[17:43:50.660]                         envir <- sys.frame(frame)
[17:43:50.660]                       }
[17:43:50.660]                     }
[17:43:50.660]                     sendCondition <<- function(cond) NULL
[17:43:50.660]                   }
[17:43:50.660]                 })
[17:43:50.660]                 withCallingHandlers({
[17:43:50.660]                   {
[17:43:50.660]                     do.call(function(...) {
[17:43:50.660]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.660]                       if (!identical(...future.globals.maxSize.org, 
[17:43:50.660]                         ...future.globals.maxSize)) {
[17:43:50.660]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.660]                         on.exit(options(oopts), add = TRUE)
[17:43:50.660]                       }
[17:43:50.660]                       {
[17:43:50.660]                         lapply(seq_along(...future.elements_ii), 
[17:43:50.660]                           FUN = function(jj) {
[17:43:50.660]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.660]                             ...future.FUN(...future.X_jj, ...)
[17:43:50.660]                           })
[17:43:50.660]                       }
[17:43:50.660]                     }, args = future.call.arguments)
[17:43:50.660]                   }
[17:43:50.660]                 }, immediateCondition = function(cond) {
[17:43:50.660]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.660]                   sendCondition(cond)
[17:43:50.660]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.660]                   {
[17:43:50.660]                     inherits <- base::inherits
[17:43:50.660]                     invokeRestart <- base::invokeRestart
[17:43:50.660]                     is.null <- base::is.null
[17:43:50.660]                     muffled <- FALSE
[17:43:50.660]                     if (inherits(cond, "message")) {
[17:43:50.660]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.660]                       if (muffled) 
[17:43:50.660]                         invokeRestart("muffleMessage")
[17:43:50.660]                     }
[17:43:50.660]                     else if (inherits(cond, "warning")) {
[17:43:50.660]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.660]                       if (muffled) 
[17:43:50.660]                         invokeRestart("muffleWarning")
[17:43:50.660]                     }
[17:43:50.660]                     else if (inherits(cond, "condition")) {
[17:43:50.660]                       if (!is.null(pattern)) {
[17:43:50.660]                         computeRestarts <- base::computeRestarts
[17:43:50.660]                         grepl <- base::grepl
[17:43:50.660]                         restarts <- computeRestarts(cond)
[17:43:50.660]                         for (restart in restarts) {
[17:43:50.660]                           name <- restart$name
[17:43:50.660]                           if (is.null(name)) 
[17:43:50.660]                             next
[17:43:50.660]                           if (!grepl(pattern, name)) 
[17:43:50.660]                             next
[17:43:50.660]                           invokeRestart(restart)
[17:43:50.660]                           muffled <- TRUE
[17:43:50.660]                           break
[17:43:50.660]                         }
[17:43:50.660]                       }
[17:43:50.660]                     }
[17:43:50.660]                     invisible(muffled)
[17:43:50.660]                   }
[17:43:50.660]                   muffleCondition(cond)
[17:43:50.660]                 })
[17:43:50.660]             }))
[17:43:50.660]             future::FutureResult(value = ...future.value$value, 
[17:43:50.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.660]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.660]                     ...future.globalenv.names))
[17:43:50.660]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.660]         }, condition = base::local({
[17:43:50.660]             c <- base::c
[17:43:50.660]             inherits <- base::inherits
[17:43:50.660]             invokeRestart <- base::invokeRestart
[17:43:50.660]             length <- base::length
[17:43:50.660]             list <- base::list
[17:43:50.660]             seq.int <- base::seq.int
[17:43:50.660]             signalCondition <- base::signalCondition
[17:43:50.660]             sys.calls <- base::sys.calls
[17:43:50.660]             `[[` <- base::`[[`
[17:43:50.660]             `+` <- base::`+`
[17:43:50.660]             `<<-` <- base::`<<-`
[17:43:50.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.660]                   3L)]
[17:43:50.660]             }
[17:43:50.660]             function(cond) {
[17:43:50.660]                 is_error <- inherits(cond, "error")
[17:43:50.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.660]                   NULL)
[17:43:50.660]                 if (is_error) {
[17:43:50.660]                   sessionInformation <- function() {
[17:43:50.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.660]                       search = base::search(), system = base::Sys.info())
[17:43:50.660]                   }
[17:43:50.660]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.660]                     cond$call), session = sessionInformation(), 
[17:43:50.660]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.660]                   signalCondition(cond)
[17:43:50.660]                 }
[17:43:50.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.660]                 "immediateCondition"))) {
[17:43:50.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.660]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.660]                   if (TRUE && !signal) {
[17:43:50.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.660]                     {
[17:43:50.660]                       inherits <- base::inherits
[17:43:50.660]                       invokeRestart <- base::invokeRestart
[17:43:50.660]                       is.null <- base::is.null
[17:43:50.660]                       muffled <- FALSE
[17:43:50.660]                       if (inherits(cond, "message")) {
[17:43:50.660]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.660]                         if (muffled) 
[17:43:50.660]                           invokeRestart("muffleMessage")
[17:43:50.660]                       }
[17:43:50.660]                       else if (inherits(cond, "warning")) {
[17:43:50.660]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.660]                         if (muffled) 
[17:43:50.660]                           invokeRestart("muffleWarning")
[17:43:50.660]                       }
[17:43:50.660]                       else if (inherits(cond, "condition")) {
[17:43:50.660]                         if (!is.null(pattern)) {
[17:43:50.660]                           computeRestarts <- base::computeRestarts
[17:43:50.660]                           grepl <- base::grepl
[17:43:50.660]                           restarts <- computeRestarts(cond)
[17:43:50.660]                           for (restart in restarts) {
[17:43:50.660]                             name <- restart$name
[17:43:50.660]                             if (is.null(name)) 
[17:43:50.660]                               next
[17:43:50.660]                             if (!grepl(pattern, name)) 
[17:43:50.660]                               next
[17:43:50.660]                             invokeRestart(restart)
[17:43:50.660]                             muffled <- TRUE
[17:43:50.660]                             break
[17:43:50.660]                           }
[17:43:50.660]                         }
[17:43:50.660]                       }
[17:43:50.660]                       invisible(muffled)
[17:43:50.660]                     }
[17:43:50.660]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.660]                   }
[17:43:50.660]                 }
[17:43:50.660]                 else {
[17:43:50.660]                   if (TRUE) {
[17:43:50.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.660]                     {
[17:43:50.660]                       inherits <- base::inherits
[17:43:50.660]                       invokeRestart <- base::invokeRestart
[17:43:50.660]                       is.null <- base::is.null
[17:43:50.660]                       muffled <- FALSE
[17:43:50.660]                       if (inherits(cond, "message")) {
[17:43:50.660]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.660]                         if (muffled) 
[17:43:50.660]                           invokeRestart("muffleMessage")
[17:43:50.660]                       }
[17:43:50.660]                       else if (inherits(cond, "warning")) {
[17:43:50.660]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.660]                         if (muffled) 
[17:43:50.660]                           invokeRestart("muffleWarning")
[17:43:50.660]                       }
[17:43:50.660]                       else if (inherits(cond, "condition")) {
[17:43:50.660]                         if (!is.null(pattern)) {
[17:43:50.660]                           computeRestarts <- base::computeRestarts
[17:43:50.660]                           grepl <- base::grepl
[17:43:50.660]                           restarts <- computeRestarts(cond)
[17:43:50.660]                           for (restart in restarts) {
[17:43:50.660]                             name <- restart$name
[17:43:50.660]                             if (is.null(name)) 
[17:43:50.660]                               next
[17:43:50.660]                             if (!grepl(pattern, name)) 
[17:43:50.660]                               next
[17:43:50.660]                             invokeRestart(restart)
[17:43:50.660]                             muffled <- TRUE
[17:43:50.660]                             break
[17:43:50.660]                           }
[17:43:50.660]                         }
[17:43:50.660]                       }
[17:43:50.660]                       invisible(muffled)
[17:43:50.660]                     }
[17:43:50.660]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.660]                   }
[17:43:50.660]                 }
[17:43:50.660]             }
[17:43:50.660]         }))
[17:43:50.660]     }, error = function(ex) {
[17:43:50.660]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.660]                 ...future.rng), started = ...future.startTime, 
[17:43:50.660]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.660]             version = "1.8"), class = "FutureResult")
[17:43:50.660]     }, finally = {
[17:43:50.660]         if (!identical(...future.workdir, getwd())) 
[17:43:50.660]             setwd(...future.workdir)
[17:43:50.660]         {
[17:43:50.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.660]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.660]             }
[17:43:50.660]             base::options(...future.oldOptions)
[17:43:50.660]             if (.Platform$OS.type == "windows") {
[17:43:50.660]                 old_names <- names(...future.oldEnvVars)
[17:43:50.660]                 envs <- base::Sys.getenv()
[17:43:50.660]                 names <- names(envs)
[17:43:50.660]                 common <- intersect(names, old_names)
[17:43:50.660]                 added <- setdiff(names, old_names)
[17:43:50.660]                 removed <- setdiff(old_names, names)
[17:43:50.660]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.660]                   envs[common]]
[17:43:50.660]                 NAMES <- toupper(changed)
[17:43:50.660]                 args <- list()
[17:43:50.660]                 for (kk in seq_along(NAMES)) {
[17:43:50.660]                   name <- changed[[kk]]
[17:43:50.660]                   NAME <- NAMES[[kk]]
[17:43:50.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.660]                     next
[17:43:50.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.660]                 }
[17:43:50.660]                 NAMES <- toupper(added)
[17:43:50.660]                 for (kk in seq_along(NAMES)) {
[17:43:50.660]                   name <- added[[kk]]
[17:43:50.660]                   NAME <- NAMES[[kk]]
[17:43:50.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.660]                     next
[17:43:50.660]                   args[[name]] <- ""
[17:43:50.660]                 }
[17:43:50.660]                 NAMES <- toupper(removed)
[17:43:50.660]                 for (kk in seq_along(NAMES)) {
[17:43:50.660]                   name <- removed[[kk]]
[17:43:50.660]                   NAME <- NAMES[[kk]]
[17:43:50.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.660]                     next
[17:43:50.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.660]                 }
[17:43:50.660]                 if (length(args) > 0) 
[17:43:50.660]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.660]             }
[17:43:50.660]             else {
[17:43:50.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.660]             }
[17:43:50.660]             {
[17:43:50.660]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.660]                   0L) {
[17:43:50.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.660]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.660]                   base::options(opts)
[17:43:50.660]                 }
[17:43:50.660]                 {
[17:43:50.660]                   {
[17:43:50.660]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.660]                     NULL
[17:43:50.660]                   }
[17:43:50.660]                   options(future.plan = NULL)
[17:43:50.660]                   if (is.na(NA_character_)) 
[17:43:50.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:50.660]                     .init = FALSE)
[17:43:50.660]                 }
[17:43:50.660]             }
[17:43:50.660]         }
[17:43:50.660]     })
[17:43:50.660]     if (TRUE) {
[17:43:50.660]         base::sink(type = "output", split = FALSE)
[17:43:50.660]         if (TRUE) {
[17:43:50.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.660]         }
[17:43:50.660]         else {
[17:43:50.660]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.660]         }
[17:43:50.660]         base::close(...future.stdout)
[17:43:50.660]         ...future.stdout <- NULL
[17:43:50.660]     }
[17:43:50.660]     ...future.result$conditions <- ...future.conditions
[17:43:50.660]     ...future.result$finished <- base::Sys.time()
[17:43:50.660]     ...future.result
[17:43:50.660] }
[17:43:50.663] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:43:50.663] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:50.664] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:50.664] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:43:50.664] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:43:50.664] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:43:50.665] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:43:50.665] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:50.665] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:50.665] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:43:50.665] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:43:50.665] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:43:50.666] MultisessionFuture started
[17:43:50.666] - Launch lazy future ... done
[17:43:50.666] run() for ‘MultisessionFuture’ ... done
[17:43:50.666] Created future:
[17:43:50.666] MultisessionFuture:
[17:43:50.666] Label: ‘future_apply-1’
[17:43:50.666] Expression:
[17:43:50.666] {
[17:43:50.666]     do.call(function(...) {
[17:43:50.666]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.666]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.666]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.666]             on.exit(options(oopts), add = TRUE)
[17:43:50.666]         }
[17:43:50.666]         {
[17:43:50.666]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.666]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.666]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.666]             })
[17:43:50.666]         }
[17:43:50.666]     }, args = future.call.arguments)
[17:43:50.666] }
[17:43:50.666] Lazy evaluation: FALSE
[17:43:50.666] Asynchronous evaluation: TRUE
[17:43:50.666] Local evaluation: TRUE
[17:43:50.666] Environment: R_GlobalEnv
[17:43:50.666] Capture standard output: TRUE
[17:43:50.666] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:50.666] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:50.666] Packages: <none>
[17:43:50.666] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:50.666] Resolved: FALSE
[17:43:50.666] Value: <not collected>
[17:43:50.666] Conditions captured: <none>
[17:43:50.666] Early signaling: FALSE
[17:43:50.666] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:50.666] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.678] Chunk #1 of 2 ... DONE
[17:43:50.678] Chunk #2 of 2 ...
[17:43:50.678]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:50.678]  - seeds: <none>
[17:43:50.678]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.679] getGlobalsAndPackages() ...
[17:43:50.679] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.679] Resolving globals: FALSE
[17:43:50.679] Tweak future expression to call with '...' arguments ...
[17:43:50.679] {
[17:43:50.679]     do.call(function(...) {
[17:43:50.679]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.679]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.679]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.679]             on.exit(options(oopts), add = TRUE)
[17:43:50.679]         }
[17:43:50.679]         {
[17:43:50.679]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.679]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.679]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.679]             })
[17:43:50.679]         }
[17:43:50.679]     }, args = future.call.arguments)
[17:43:50.679] }
[17:43:50.679] Tweak future expression to call with '...' arguments ... DONE
[17:43:50.680] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.680] 
[17:43:50.680] getGlobalsAndPackages() ... DONE
[17:43:50.680] run() for ‘Future’ ...
[17:43:50.680] - state: ‘created’
[17:43:50.680] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.694] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.694] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.694]   - Field: ‘node’
[17:43:50.694]   - Field: ‘label’
[17:43:50.695]   - Field: ‘local’
[17:43:50.695]   - Field: ‘owner’
[17:43:50.695]   - Field: ‘envir’
[17:43:50.695]   - Field: ‘workers’
[17:43:50.695]   - Field: ‘packages’
[17:43:50.695]   - Field: ‘gc’
[17:43:50.695]   - Field: ‘conditions’
[17:43:50.695]   - Field: ‘persistent’
[17:43:50.695]   - Field: ‘expr’
[17:43:50.695]   - Field: ‘uuid’
[17:43:50.696]   - Field: ‘seed’
[17:43:50.696]   - Field: ‘version’
[17:43:50.696]   - Field: ‘result’
[17:43:50.696]   - Field: ‘asynchronous’
[17:43:50.696]   - Field: ‘calls’
[17:43:50.696]   - Field: ‘globals’
[17:43:50.698]   - Field: ‘stdout’
[17:43:50.698]   - Field: ‘earlySignal’
[17:43:50.698]   - Field: ‘lazy’
[17:43:50.698]   - Field: ‘state’
[17:43:50.698] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.699] - Launch lazy future ...
[17:43:50.699] Packages needed by the future expression (n = 0): <none>
[17:43:50.699] Packages needed by future strategies (n = 0): <none>
[17:43:50.699] {
[17:43:50.699]     {
[17:43:50.699]         {
[17:43:50.699]             ...future.startTime <- base::Sys.time()
[17:43:50.699]             {
[17:43:50.699]                 {
[17:43:50.699]                   {
[17:43:50.699]                     {
[17:43:50.699]                       base::local({
[17:43:50.699]                         has_future <- base::requireNamespace("future", 
[17:43:50.699]                           quietly = TRUE)
[17:43:50.699]                         if (has_future) {
[17:43:50.699]                           ns <- base::getNamespace("future")
[17:43:50.699]                           version <- ns[[".package"]][["version"]]
[17:43:50.699]                           if (is.null(version)) 
[17:43:50.699]                             version <- utils::packageVersion("future")
[17:43:50.699]                         }
[17:43:50.699]                         else {
[17:43:50.699]                           version <- NULL
[17:43:50.699]                         }
[17:43:50.699]                         if (!has_future || version < "1.8.0") {
[17:43:50.699]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.699]                             "", base::R.version$version.string), 
[17:43:50.699]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:50.699]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:50.699]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.699]                               "release", "version")], collapse = " "), 
[17:43:50.699]                             hostname = base::Sys.info()[["nodename"]])
[17:43:50.699]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.699]                             info)
[17:43:50.699]                           info <- base::paste(info, collapse = "; ")
[17:43:50.699]                           if (!has_future) {
[17:43:50.699]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.699]                               info)
[17:43:50.699]                           }
[17:43:50.699]                           else {
[17:43:50.699]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.699]                               info, version)
[17:43:50.699]                           }
[17:43:50.699]                           base::stop(msg)
[17:43:50.699]                         }
[17:43:50.699]                       })
[17:43:50.699]                     }
[17:43:50.699]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.699]                     base::options(mc.cores = 1L)
[17:43:50.699]                   }
[17:43:50.699]                   ...future.strategy.old <- future::plan("list")
[17:43:50.699]                   options(future.plan = NULL)
[17:43:50.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.699]                 }
[17:43:50.699]                 ...future.workdir <- getwd()
[17:43:50.699]             }
[17:43:50.699]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.699]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.699]         }
[17:43:50.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.699]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:50.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.699]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.699]             base::names(...future.oldOptions))
[17:43:50.699]     }
[17:43:50.699]     if (FALSE) {
[17:43:50.699]     }
[17:43:50.699]     else {
[17:43:50.699]         if (TRUE) {
[17:43:50.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.699]                 open = "w")
[17:43:50.699]         }
[17:43:50.699]         else {
[17:43:50.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.699]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.699]         }
[17:43:50.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.699]             base::sink(type = "output", split = FALSE)
[17:43:50.699]             base::close(...future.stdout)
[17:43:50.699]         }, add = TRUE)
[17:43:50.699]     }
[17:43:50.699]     ...future.frame <- base::sys.nframe()
[17:43:50.699]     ...future.conditions <- base::list()
[17:43:50.699]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.699]     if (FALSE) {
[17:43:50.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.699]     }
[17:43:50.699]     ...future.result <- base::tryCatch({
[17:43:50.699]         base::withCallingHandlers({
[17:43:50.699]             ...future.value <- base::withVisible(base::local({
[17:43:50.699]                 ...future.makeSendCondition <- base::local({
[17:43:50.699]                   sendCondition <- NULL
[17:43:50.699]                   function(frame = 1L) {
[17:43:50.699]                     if (is.function(sendCondition)) 
[17:43:50.699]                       return(sendCondition)
[17:43:50.699]                     ns <- getNamespace("parallel")
[17:43:50.699]                     if (exists("sendData", mode = "function", 
[17:43:50.699]                       envir = ns)) {
[17:43:50.699]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.699]                         envir = ns)
[17:43:50.699]                       envir <- sys.frame(frame)
[17:43:50.699]                       master <- NULL
[17:43:50.699]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.699]                         !identical(envir, emptyenv())) {
[17:43:50.699]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.699]                           inherits = FALSE)) {
[17:43:50.699]                           master <- get("master", mode = "list", 
[17:43:50.699]                             envir = envir, inherits = FALSE)
[17:43:50.699]                           if (inherits(master, c("SOCKnode", 
[17:43:50.699]                             "SOCK0node"))) {
[17:43:50.699]                             sendCondition <<- function(cond) {
[17:43:50.699]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.699]                                 success = TRUE)
[17:43:50.699]                               parallel_sendData(master, data)
[17:43:50.699]                             }
[17:43:50.699]                             return(sendCondition)
[17:43:50.699]                           }
[17:43:50.699]                         }
[17:43:50.699]                         frame <- frame + 1L
[17:43:50.699]                         envir <- sys.frame(frame)
[17:43:50.699]                       }
[17:43:50.699]                     }
[17:43:50.699]                     sendCondition <<- function(cond) NULL
[17:43:50.699]                   }
[17:43:50.699]                 })
[17:43:50.699]                 withCallingHandlers({
[17:43:50.699]                   {
[17:43:50.699]                     do.call(function(...) {
[17:43:50.699]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.699]                       if (!identical(...future.globals.maxSize.org, 
[17:43:50.699]                         ...future.globals.maxSize)) {
[17:43:50.699]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.699]                         on.exit(options(oopts), add = TRUE)
[17:43:50.699]                       }
[17:43:50.699]                       {
[17:43:50.699]                         lapply(seq_along(...future.elements_ii), 
[17:43:50.699]                           FUN = function(jj) {
[17:43:50.699]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.699]                             ...future.FUN(...future.X_jj, ...)
[17:43:50.699]                           })
[17:43:50.699]                       }
[17:43:50.699]                     }, args = future.call.arguments)
[17:43:50.699]                   }
[17:43:50.699]                 }, immediateCondition = function(cond) {
[17:43:50.699]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.699]                   sendCondition(cond)
[17:43:50.699]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.699]                   {
[17:43:50.699]                     inherits <- base::inherits
[17:43:50.699]                     invokeRestart <- base::invokeRestart
[17:43:50.699]                     is.null <- base::is.null
[17:43:50.699]                     muffled <- FALSE
[17:43:50.699]                     if (inherits(cond, "message")) {
[17:43:50.699]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.699]                       if (muffled) 
[17:43:50.699]                         invokeRestart("muffleMessage")
[17:43:50.699]                     }
[17:43:50.699]                     else if (inherits(cond, "warning")) {
[17:43:50.699]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.699]                       if (muffled) 
[17:43:50.699]                         invokeRestart("muffleWarning")
[17:43:50.699]                     }
[17:43:50.699]                     else if (inherits(cond, "condition")) {
[17:43:50.699]                       if (!is.null(pattern)) {
[17:43:50.699]                         computeRestarts <- base::computeRestarts
[17:43:50.699]                         grepl <- base::grepl
[17:43:50.699]                         restarts <- computeRestarts(cond)
[17:43:50.699]                         for (restart in restarts) {
[17:43:50.699]                           name <- restart$name
[17:43:50.699]                           if (is.null(name)) 
[17:43:50.699]                             next
[17:43:50.699]                           if (!grepl(pattern, name)) 
[17:43:50.699]                             next
[17:43:50.699]                           invokeRestart(restart)
[17:43:50.699]                           muffled <- TRUE
[17:43:50.699]                           break
[17:43:50.699]                         }
[17:43:50.699]                       }
[17:43:50.699]                     }
[17:43:50.699]                     invisible(muffled)
[17:43:50.699]                   }
[17:43:50.699]                   muffleCondition(cond)
[17:43:50.699]                 })
[17:43:50.699]             }))
[17:43:50.699]             future::FutureResult(value = ...future.value$value, 
[17:43:50.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.699]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.699]                     ...future.globalenv.names))
[17:43:50.699]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.699]         }, condition = base::local({
[17:43:50.699]             c <- base::c
[17:43:50.699]             inherits <- base::inherits
[17:43:50.699]             invokeRestart <- base::invokeRestart
[17:43:50.699]             length <- base::length
[17:43:50.699]             list <- base::list
[17:43:50.699]             seq.int <- base::seq.int
[17:43:50.699]             signalCondition <- base::signalCondition
[17:43:50.699]             sys.calls <- base::sys.calls
[17:43:50.699]             `[[` <- base::`[[`
[17:43:50.699]             `+` <- base::`+`
[17:43:50.699]             `<<-` <- base::`<<-`
[17:43:50.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.699]                   3L)]
[17:43:50.699]             }
[17:43:50.699]             function(cond) {
[17:43:50.699]                 is_error <- inherits(cond, "error")
[17:43:50.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.699]                   NULL)
[17:43:50.699]                 if (is_error) {
[17:43:50.699]                   sessionInformation <- function() {
[17:43:50.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.699]                       search = base::search(), system = base::Sys.info())
[17:43:50.699]                   }
[17:43:50.699]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.699]                     cond$call), session = sessionInformation(), 
[17:43:50.699]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.699]                   signalCondition(cond)
[17:43:50.699]                 }
[17:43:50.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.699]                 "immediateCondition"))) {
[17:43:50.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.699]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.699]                   if (TRUE && !signal) {
[17:43:50.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.699]                     {
[17:43:50.699]                       inherits <- base::inherits
[17:43:50.699]                       invokeRestart <- base::invokeRestart
[17:43:50.699]                       is.null <- base::is.null
[17:43:50.699]                       muffled <- FALSE
[17:43:50.699]                       if (inherits(cond, "message")) {
[17:43:50.699]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.699]                         if (muffled) 
[17:43:50.699]                           invokeRestart("muffleMessage")
[17:43:50.699]                       }
[17:43:50.699]                       else if (inherits(cond, "warning")) {
[17:43:50.699]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.699]                         if (muffled) 
[17:43:50.699]                           invokeRestart("muffleWarning")
[17:43:50.699]                       }
[17:43:50.699]                       else if (inherits(cond, "condition")) {
[17:43:50.699]                         if (!is.null(pattern)) {
[17:43:50.699]                           computeRestarts <- base::computeRestarts
[17:43:50.699]                           grepl <- base::grepl
[17:43:50.699]                           restarts <- computeRestarts(cond)
[17:43:50.699]                           for (restart in restarts) {
[17:43:50.699]                             name <- restart$name
[17:43:50.699]                             if (is.null(name)) 
[17:43:50.699]                               next
[17:43:50.699]                             if (!grepl(pattern, name)) 
[17:43:50.699]                               next
[17:43:50.699]                             invokeRestart(restart)
[17:43:50.699]                             muffled <- TRUE
[17:43:50.699]                             break
[17:43:50.699]                           }
[17:43:50.699]                         }
[17:43:50.699]                       }
[17:43:50.699]                       invisible(muffled)
[17:43:50.699]                     }
[17:43:50.699]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.699]                   }
[17:43:50.699]                 }
[17:43:50.699]                 else {
[17:43:50.699]                   if (TRUE) {
[17:43:50.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.699]                     {
[17:43:50.699]                       inherits <- base::inherits
[17:43:50.699]                       invokeRestart <- base::invokeRestart
[17:43:50.699]                       is.null <- base::is.null
[17:43:50.699]                       muffled <- FALSE
[17:43:50.699]                       if (inherits(cond, "message")) {
[17:43:50.699]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.699]                         if (muffled) 
[17:43:50.699]                           invokeRestart("muffleMessage")
[17:43:50.699]                       }
[17:43:50.699]                       else if (inherits(cond, "warning")) {
[17:43:50.699]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.699]                         if (muffled) 
[17:43:50.699]                           invokeRestart("muffleWarning")
[17:43:50.699]                       }
[17:43:50.699]                       else if (inherits(cond, "condition")) {
[17:43:50.699]                         if (!is.null(pattern)) {
[17:43:50.699]                           computeRestarts <- base::computeRestarts
[17:43:50.699]                           grepl <- base::grepl
[17:43:50.699]                           restarts <- computeRestarts(cond)
[17:43:50.699]                           for (restart in restarts) {
[17:43:50.699]                             name <- restart$name
[17:43:50.699]                             if (is.null(name)) 
[17:43:50.699]                               next
[17:43:50.699]                             if (!grepl(pattern, name)) 
[17:43:50.699]                               next
[17:43:50.699]                             invokeRestart(restart)
[17:43:50.699]                             muffled <- TRUE
[17:43:50.699]                             break
[17:43:50.699]                           }
[17:43:50.699]                         }
[17:43:50.699]                       }
[17:43:50.699]                       invisible(muffled)
[17:43:50.699]                     }
[17:43:50.699]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.699]                   }
[17:43:50.699]                 }
[17:43:50.699]             }
[17:43:50.699]         }))
[17:43:50.699]     }, error = function(ex) {
[17:43:50.699]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.699]                 ...future.rng), started = ...future.startTime, 
[17:43:50.699]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.699]             version = "1.8"), class = "FutureResult")
[17:43:50.699]     }, finally = {
[17:43:50.699]         if (!identical(...future.workdir, getwd())) 
[17:43:50.699]             setwd(...future.workdir)
[17:43:50.699]         {
[17:43:50.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.699]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.699]             }
[17:43:50.699]             base::options(...future.oldOptions)
[17:43:50.699]             if (.Platform$OS.type == "windows") {
[17:43:50.699]                 old_names <- names(...future.oldEnvVars)
[17:43:50.699]                 envs <- base::Sys.getenv()
[17:43:50.699]                 names <- names(envs)
[17:43:50.699]                 common <- intersect(names, old_names)
[17:43:50.699]                 added <- setdiff(names, old_names)
[17:43:50.699]                 removed <- setdiff(old_names, names)
[17:43:50.699]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.699]                   envs[common]]
[17:43:50.699]                 NAMES <- toupper(changed)
[17:43:50.699]                 args <- list()
[17:43:50.699]                 for (kk in seq_along(NAMES)) {
[17:43:50.699]                   name <- changed[[kk]]
[17:43:50.699]                   NAME <- NAMES[[kk]]
[17:43:50.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.699]                     next
[17:43:50.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.699]                 }
[17:43:50.699]                 NAMES <- toupper(added)
[17:43:50.699]                 for (kk in seq_along(NAMES)) {
[17:43:50.699]                   name <- added[[kk]]
[17:43:50.699]                   NAME <- NAMES[[kk]]
[17:43:50.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.699]                     next
[17:43:50.699]                   args[[name]] <- ""
[17:43:50.699]                 }
[17:43:50.699]                 NAMES <- toupper(removed)
[17:43:50.699]                 for (kk in seq_along(NAMES)) {
[17:43:50.699]                   name <- removed[[kk]]
[17:43:50.699]                   NAME <- NAMES[[kk]]
[17:43:50.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.699]                     next
[17:43:50.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.699]                 }
[17:43:50.699]                 if (length(args) > 0) 
[17:43:50.699]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.699]             }
[17:43:50.699]             else {
[17:43:50.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.699]             }
[17:43:50.699]             {
[17:43:50.699]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.699]                   0L) {
[17:43:50.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.699]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.699]                   base::options(opts)
[17:43:50.699]                 }
[17:43:50.699]                 {
[17:43:50.699]                   {
[17:43:50.699]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.699]                     NULL
[17:43:50.699]                   }
[17:43:50.699]                   options(future.plan = NULL)
[17:43:50.699]                   if (is.na(NA_character_)) 
[17:43:50.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.699]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:50.699]                     .init = FALSE)
[17:43:50.699]                 }
[17:43:50.699]             }
[17:43:50.699]         }
[17:43:50.699]     })
[17:43:50.699]     if (TRUE) {
[17:43:50.699]         base::sink(type = "output", split = FALSE)
[17:43:50.699]         if (TRUE) {
[17:43:50.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.699]         }
[17:43:50.699]         else {
[17:43:50.699]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.699]         }
[17:43:50.699]         base::close(...future.stdout)
[17:43:50.699]         ...future.stdout <- NULL
[17:43:50.699]     }
[17:43:50.699]     ...future.result$conditions <- ...future.conditions
[17:43:50.699]     ...future.result$finished <- base::Sys.time()
[17:43:50.699]     ...future.result
[17:43:50.699] }
[17:43:50.702] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:43:50.703] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:50.703] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:50.703] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:43:50.703] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:43:50.704] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ...
[17:43:50.704] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #2 ... DONE
[17:43:50.704] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:50.704] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:50.704] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:43:50.705] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:43:50.705] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:43:50.705] MultisessionFuture started
[17:43:50.705] - Launch lazy future ... done
[17:43:50.705] run() for ‘MultisessionFuture’ ... done
[17:43:50.706] Created future:
[17:43:50.706] MultisessionFuture:
[17:43:50.706] Label: ‘future_apply-2’
[17:43:50.706] Expression:
[17:43:50.706] {
[17:43:50.706]     do.call(function(...) {
[17:43:50.706]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.706]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.706]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.706]             on.exit(options(oopts), add = TRUE)
[17:43:50.706]         }
[17:43:50.706]         {
[17:43:50.706]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.706]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.706]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.706]             })
[17:43:50.706]         }
[17:43:50.706]     }, args = future.call.arguments)
[17:43:50.706] }
[17:43:50.706] Lazy evaluation: FALSE
[17:43:50.706] Asynchronous evaluation: TRUE
[17:43:50.706] Local evaluation: TRUE
[17:43:50.706] Environment: R_GlobalEnv
[17:43:50.706] Capture standard output: TRUE
[17:43:50.706] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:50.706] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:50.706] Packages: <none>
[17:43:50.706] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:50.706] Resolved: FALSE
[17:43:50.706] Value: <not collected>
[17:43:50.706] Conditions captured: <none>
[17:43:50.706] Early signaling: FALSE
[17:43:50.706] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:50.706] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.717] Chunk #2 of 2 ... DONE
[17:43:50.717] Launching 2 futures (chunks) ... DONE
[17:43:50.717] Resolving 2 futures (chunks) ...
[17:43:50.717] resolve() on list ...
[17:43:50.717]  recursive: 0
[17:43:50.718]  length: 2
[17:43:50.718] 
[17:43:50.718] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.718] - Validating connection of MultisessionFuture
[17:43:50.718] - received message: FutureResult
[17:43:50.719] - Received FutureResult
[17:43:50.719] - Erased future from FutureRegistry
[17:43:50.719] result() for ClusterFuture ...
[17:43:50.719] - result already collected: FutureResult
[17:43:50.719] result() for ClusterFuture ... done
[17:43:50.719] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.719] Future #1
[17:43:50.719] result() for ClusterFuture ...
[17:43:50.719] - result already collected: FutureResult
[17:43:50.719] result() for ClusterFuture ... done
[17:43:50.719] result() for ClusterFuture ...
[17:43:50.720] - result already collected: FutureResult
[17:43:50.720] result() for ClusterFuture ... done
[17:43:50.720] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:50.720] - nx: 2
[17:43:50.720] - relay: TRUE
[17:43:50.720] - stdout: TRUE
[17:43:50.720] - signal: TRUE
[17:43:50.720] - resignal: FALSE
[17:43:50.720] - force: TRUE
[17:43:50.720] - relayed: [n=2] FALSE, FALSE
[17:43:50.720] - queued futures: [n=2] FALSE, FALSE
[17:43:50.720]  - until=1
[17:43:50.721]  - relaying element #1
[17:43:50.721] result() for ClusterFuture ...
[17:43:50.721] - result already collected: FutureResult
[17:43:50.721] result() for ClusterFuture ... done
[17:43:50.721] result() for ClusterFuture ...
[17:43:50.721] - result already collected: FutureResult
[17:43:50.721] result() for ClusterFuture ... done
[17:43:50.721] result() for ClusterFuture ...
[17:43:50.721] - result already collected: FutureResult
[17:43:50.721] result() for ClusterFuture ... done
[17:43:50.721] result() for ClusterFuture ...
[17:43:50.722] - result already collected: FutureResult
[17:43:50.722] result() for ClusterFuture ... done
[17:43:50.722] - relayed: [n=2] TRUE, FALSE
[17:43:50.722] - queued futures: [n=2] TRUE, FALSE
[17:43:50.722] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:50.722]  length: 1 (resolved future 1)
[17:43:50.749] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.749] - Validating connection of MultisessionFuture
[17:43:50.749] - received message: FutureResult
[17:43:50.749] - Received FutureResult
[17:43:50.749] - Erased future from FutureRegistry
[17:43:50.749] result() for ClusterFuture ...
[17:43:50.749] - result already collected: FutureResult
[17:43:50.750] result() for ClusterFuture ... done
[17:43:50.750] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.750] Future #2
[17:43:50.750] result() for ClusterFuture ...
[17:43:50.750] - result already collected: FutureResult
[17:43:50.750] result() for ClusterFuture ... done
[17:43:50.750] result() for ClusterFuture ...
[17:43:50.750] - result already collected: FutureResult
[17:43:50.750] result() for ClusterFuture ... done
[17:43:50.750] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:50.750] - nx: 2
[17:43:50.751] - relay: TRUE
[17:43:50.751] - stdout: TRUE
[17:43:50.751] - signal: TRUE
[17:43:50.751] - resignal: FALSE
[17:43:50.751] - force: TRUE
[17:43:50.751] - relayed: [n=2] TRUE, FALSE
[17:43:50.751] - queued futures: [n=2] TRUE, FALSE
[17:43:50.751]  - until=2
[17:43:50.751]  - relaying element #2
[17:43:50.751] result() for ClusterFuture ...
[17:43:50.751] - result already collected: FutureResult
[17:43:50.751] result() for ClusterFuture ... done
[17:43:50.752] result() for ClusterFuture ...
[17:43:50.752] - result already collected: FutureResult
[17:43:50.752] result() for ClusterFuture ... done
[17:43:50.752] result() for ClusterFuture ...
[17:43:50.752] - result already collected: FutureResult
[17:43:50.752] result() for ClusterFuture ... done
[17:43:50.752] result() for ClusterFuture ...
[17:43:50.752] - result already collected: FutureResult
[17:43:50.752] result() for ClusterFuture ... done
[17:43:50.752] - relayed: [n=2] TRUE, TRUE
[17:43:50.752] - queued futures: [n=2] TRUE, TRUE
[17:43:50.753] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:50.753]  length: 0 (resolved future 2)
[17:43:50.753] Relaying remaining futures
[17:43:50.753] signalConditionsASAP(NULL, pos=0) ...
[17:43:50.753] - nx: 2
[17:43:50.753] - relay: TRUE
[17:43:50.753] - stdout: TRUE
[17:43:50.753] - signal: TRUE
[17:43:50.753] - resignal: FALSE
[17:43:50.753] - force: TRUE
[17:43:50.753] - relayed: [n=2] TRUE, TRUE
[17:43:50.753] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:50.754] - relayed: [n=2] TRUE, TRUE
[17:43:50.754] - queued futures: [n=2] TRUE, TRUE
[17:43:50.754] signalConditionsASAP(NULL, pos=0) ... done
[17:43:50.754] resolve() on list ... DONE
[17:43:50.754] result() for ClusterFuture ...
[17:43:50.754] - result already collected: FutureResult
[17:43:50.754] result() for ClusterFuture ... done
[17:43:50.754] result() for ClusterFuture ...
[17:43:50.754] - result already collected: FutureResult
[17:43:50.754] result() for ClusterFuture ... done
[17:43:50.754] result() for ClusterFuture ...
[17:43:50.755] - result already collected: FutureResult
[17:43:50.755] result() for ClusterFuture ... done
[17:43:50.755] result() for ClusterFuture ...
[17:43:50.755] - result already collected: FutureResult
[17:43:50.755] result() for ClusterFuture ... done
[17:43:50.755]  - Number of value chunks collected: 2
[17:43:50.755] Resolving 2 futures (chunks) ... DONE
[17:43:50.755] Reducing values from 2 chunks ...
[17:43:50.755]  - Number of values collected after concatenation: 6
[17:43:50.755]  - Number of values expected: 6
[17:43:50.755] Reducing values from 2 chunks ... DONE
[17:43:50.756] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[17:43:50.756] getGlobalsAndPackagesXApply() ...
[17:43:50.756]  - future.globals: TRUE
[17:43:50.756] getGlobalsAndPackages() ...
[17:43:50.756] Searching for globals...
[17:43:50.758] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[17:43:50.758] Searching for globals ... DONE
[17:43:50.758] Resolving globals: FALSE
[17:43:50.758] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[17:43:50.759] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[17:43:50.759] - globals: [1] ‘FUN’
[17:43:50.759] 
[17:43:50.759] getGlobalsAndPackages() ... DONE
[17:43:50.759]  - globals found/used: [n=1] ‘FUN’
[17:43:50.759]  - needed namespaces: [n=0] 
[17:43:50.759] Finding globals ... DONE
[17:43:50.759]  - use_args: TRUE
[17:43:50.759]  - Getting '...' globals ...
[17:43:50.760] resolve() on list ...
[17:43:50.760]  recursive: 0
[17:43:50.760]  length: 1
[17:43:50.760]  elements: ‘...’
[17:43:50.760]  length: 0 (resolved future 1)
[17:43:50.760] resolve() on list ... DONE
[17:43:50.760]    - '...' content: [n=0] 
[17:43:50.760] List of 1
[17:43:50.760]  $ ...: list()
[17:43:50.760]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.760]  - attr(*, "where")=List of 1
[17:43:50.760]   ..$ ...:<environment: 0x55dfd2cd0fb8> 
[17:43:50.760]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.760]  - attr(*, "resolved")= logi TRUE
[17:43:50.760]  - attr(*, "total_size")= num NA
[17:43:50.763]  - Getting '...' globals ... DONE
[17:43:50.763] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:50.763] List of 2
[17:43:50.763]  $ ...future.FUN:function (x)  
[17:43:50.763]  $ ...          : list()
[17:43:50.763]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.763]  - attr(*, "where")=List of 2
[17:43:50.763]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:50.763]   ..$ ...          :<environment: 0x55dfd2cd0fb8> 
[17:43:50.763]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.763]  - attr(*, "resolved")= logi FALSE
[17:43:50.763]  - attr(*, "total_size")= num 1768
[17:43:50.766] Packages to be attached in all futures: [n=0] 
[17:43:50.766] getGlobalsAndPackagesXApply() ... DONE
[17:43:50.769] future_lapply() ...
[17:43:50.773] Number of chunks: 2
[17:43:50.773] getGlobalsAndPackagesXApply() ...
[17:43:50.773]  - future.globals: <name-value list> with names ‘list()’
[17:43:50.773]  - use_args: TRUE
[17:43:50.773] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:50.773] List of 2
[17:43:50.773]  $ ...          : list()
[17:43:50.773]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.773]  $ ...future.FUN:function (x)  
[17:43:50.773]  - attr(*, "where")=List of 2
[17:43:50.773]   ..$ ...          :<environment: 0x55dfd2cd0fb8> 
[17:43:50.773]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:43:50.773]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.773]  - attr(*, "resolved")= logi FALSE
[17:43:50.773]  - attr(*, "total_size")= num NA
[17:43:50.776] Packages to be attached in all futures: [n=0] 
[17:43:50.777] getGlobalsAndPackagesXApply() ... DONE
[17:43:50.777] Number of futures (= number of chunks): 2
[17:43:50.777] Launching 2 futures (chunks) ...
[17:43:50.777] Chunk #1 of 2 ...
[17:43:50.777]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:50.777]  - seeds: <none>
[17:43:50.777]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.777] getGlobalsAndPackages() ...
[17:43:50.778] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.778] Resolving globals: FALSE
[17:43:50.778] Tweak future expression to call with '...' arguments ...
[17:43:50.778] {
[17:43:50.778]     do.call(function(...) {
[17:43:50.778]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.778]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.778]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.778]             on.exit(options(oopts), add = TRUE)
[17:43:50.778]         }
[17:43:50.778]         {
[17:43:50.778]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.778]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.778]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.778]             })
[17:43:50.778]         }
[17:43:50.778]     }, args = future.call.arguments)
[17:43:50.778] }
[17:43:50.778] Tweak future expression to call with '...' arguments ... DONE
[17:43:50.778] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.779] 
[17:43:50.779] getGlobalsAndPackages() ... DONE
[17:43:50.779] run() for ‘Future’ ...
[17:43:50.779] - state: ‘created’
[17:43:50.779] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.792] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.793] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.793]   - Field: ‘node’
[17:43:50.793]   - Field: ‘label’
[17:43:50.793]   - Field: ‘local’
[17:43:50.793]   - Field: ‘owner’
[17:43:50.793]   - Field: ‘envir’
[17:43:50.793]   - Field: ‘workers’
[17:43:50.793]   - Field: ‘packages’
[17:43:50.793]   - Field: ‘gc’
[17:43:50.793]   - Field: ‘conditions’
[17:43:50.793]   - Field: ‘persistent’
[17:43:50.794]   - Field: ‘expr’
[17:43:50.794]   - Field: ‘uuid’
[17:43:50.794]   - Field: ‘seed’
[17:43:50.794]   - Field: ‘version’
[17:43:50.794]   - Field: ‘result’
[17:43:50.794]   - Field: ‘asynchronous’
[17:43:50.794]   - Field: ‘calls’
[17:43:50.794]   - Field: ‘globals’
[17:43:50.794]   - Field: ‘stdout’
[17:43:50.794]   - Field: ‘earlySignal’
[17:43:50.795]   - Field: ‘lazy’
[17:43:50.795]   - Field: ‘state’
[17:43:50.795] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.795] - Launch lazy future ...
[17:43:50.795] Packages needed by the future expression (n = 0): <none>
[17:43:50.795] Packages needed by future strategies (n = 0): <none>
[17:43:50.796] {
[17:43:50.796]     {
[17:43:50.796]         {
[17:43:50.796]             ...future.startTime <- base::Sys.time()
[17:43:50.796]             {
[17:43:50.796]                 {
[17:43:50.796]                   {
[17:43:50.796]                     {
[17:43:50.796]                       base::local({
[17:43:50.796]                         has_future <- base::requireNamespace("future", 
[17:43:50.796]                           quietly = TRUE)
[17:43:50.796]                         if (has_future) {
[17:43:50.796]                           ns <- base::getNamespace("future")
[17:43:50.796]                           version <- ns[[".package"]][["version"]]
[17:43:50.796]                           if (is.null(version)) 
[17:43:50.796]                             version <- utils::packageVersion("future")
[17:43:50.796]                         }
[17:43:50.796]                         else {
[17:43:50.796]                           version <- NULL
[17:43:50.796]                         }
[17:43:50.796]                         if (!has_future || version < "1.8.0") {
[17:43:50.796]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.796]                             "", base::R.version$version.string), 
[17:43:50.796]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:50.796]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:50.796]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.796]                               "release", "version")], collapse = " "), 
[17:43:50.796]                             hostname = base::Sys.info()[["nodename"]])
[17:43:50.796]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.796]                             info)
[17:43:50.796]                           info <- base::paste(info, collapse = "; ")
[17:43:50.796]                           if (!has_future) {
[17:43:50.796]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.796]                               info)
[17:43:50.796]                           }
[17:43:50.796]                           else {
[17:43:50.796]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.796]                               info, version)
[17:43:50.796]                           }
[17:43:50.796]                           base::stop(msg)
[17:43:50.796]                         }
[17:43:50.796]                       })
[17:43:50.796]                     }
[17:43:50.796]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.796]                     base::options(mc.cores = 1L)
[17:43:50.796]                   }
[17:43:50.796]                   ...future.strategy.old <- future::plan("list")
[17:43:50.796]                   options(future.plan = NULL)
[17:43:50.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.796]                 }
[17:43:50.796]                 ...future.workdir <- getwd()
[17:43:50.796]             }
[17:43:50.796]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.796]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.796]         }
[17:43:50.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.796]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:50.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.796]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.796]             base::names(...future.oldOptions))
[17:43:50.796]     }
[17:43:50.796]     if (FALSE) {
[17:43:50.796]     }
[17:43:50.796]     else {
[17:43:50.796]         if (TRUE) {
[17:43:50.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.796]                 open = "w")
[17:43:50.796]         }
[17:43:50.796]         else {
[17:43:50.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.796]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.796]         }
[17:43:50.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.796]             base::sink(type = "output", split = FALSE)
[17:43:50.796]             base::close(...future.stdout)
[17:43:50.796]         }, add = TRUE)
[17:43:50.796]     }
[17:43:50.796]     ...future.frame <- base::sys.nframe()
[17:43:50.796]     ...future.conditions <- base::list()
[17:43:50.796]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.796]     if (FALSE) {
[17:43:50.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.796]     }
[17:43:50.796]     ...future.result <- base::tryCatch({
[17:43:50.796]         base::withCallingHandlers({
[17:43:50.796]             ...future.value <- base::withVisible(base::local({
[17:43:50.796]                 ...future.makeSendCondition <- base::local({
[17:43:50.796]                   sendCondition <- NULL
[17:43:50.796]                   function(frame = 1L) {
[17:43:50.796]                     if (is.function(sendCondition)) 
[17:43:50.796]                       return(sendCondition)
[17:43:50.796]                     ns <- getNamespace("parallel")
[17:43:50.796]                     if (exists("sendData", mode = "function", 
[17:43:50.796]                       envir = ns)) {
[17:43:50.796]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.796]                         envir = ns)
[17:43:50.796]                       envir <- sys.frame(frame)
[17:43:50.796]                       master <- NULL
[17:43:50.796]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.796]                         !identical(envir, emptyenv())) {
[17:43:50.796]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.796]                           inherits = FALSE)) {
[17:43:50.796]                           master <- get("master", mode = "list", 
[17:43:50.796]                             envir = envir, inherits = FALSE)
[17:43:50.796]                           if (inherits(master, c("SOCKnode", 
[17:43:50.796]                             "SOCK0node"))) {
[17:43:50.796]                             sendCondition <<- function(cond) {
[17:43:50.796]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.796]                                 success = TRUE)
[17:43:50.796]                               parallel_sendData(master, data)
[17:43:50.796]                             }
[17:43:50.796]                             return(sendCondition)
[17:43:50.796]                           }
[17:43:50.796]                         }
[17:43:50.796]                         frame <- frame + 1L
[17:43:50.796]                         envir <- sys.frame(frame)
[17:43:50.796]                       }
[17:43:50.796]                     }
[17:43:50.796]                     sendCondition <<- function(cond) NULL
[17:43:50.796]                   }
[17:43:50.796]                 })
[17:43:50.796]                 withCallingHandlers({
[17:43:50.796]                   {
[17:43:50.796]                     do.call(function(...) {
[17:43:50.796]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.796]                       if (!identical(...future.globals.maxSize.org, 
[17:43:50.796]                         ...future.globals.maxSize)) {
[17:43:50.796]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.796]                         on.exit(options(oopts), add = TRUE)
[17:43:50.796]                       }
[17:43:50.796]                       {
[17:43:50.796]                         lapply(seq_along(...future.elements_ii), 
[17:43:50.796]                           FUN = function(jj) {
[17:43:50.796]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.796]                             ...future.FUN(...future.X_jj, ...)
[17:43:50.796]                           })
[17:43:50.796]                       }
[17:43:50.796]                     }, args = future.call.arguments)
[17:43:50.796]                   }
[17:43:50.796]                 }, immediateCondition = function(cond) {
[17:43:50.796]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.796]                   sendCondition(cond)
[17:43:50.796]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.796]                   {
[17:43:50.796]                     inherits <- base::inherits
[17:43:50.796]                     invokeRestart <- base::invokeRestart
[17:43:50.796]                     is.null <- base::is.null
[17:43:50.796]                     muffled <- FALSE
[17:43:50.796]                     if (inherits(cond, "message")) {
[17:43:50.796]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.796]                       if (muffled) 
[17:43:50.796]                         invokeRestart("muffleMessage")
[17:43:50.796]                     }
[17:43:50.796]                     else if (inherits(cond, "warning")) {
[17:43:50.796]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.796]                       if (muffled) 
[17:43:50.796]                         invokeRestart("muffleWarning")
[17:43:50.796]                     }
[17:43:50.796]                     else if (inherits(cond, "condition")) {
[17:43:50.796]                       if (!is.null(pattern)) {
[17:43:50.796]                         computeRestarts <- base::computeRestarts
[17:43:50.796]                         grepl <- base::grepl
[17:43:50.796]                         restarts <- computeRestarts(cond)
[17:43:50.796]                         for (restart in restarts) {
[17:43:50.796]                           name <- restart$name
[17:43:50.796]                           if (is.null(name)) 
[17:43:50.796]                             next
[17:43:50.796]                           if (!grepl(pattern, name)) 
[17:43:50.796]                             next
[17:43:50.796]                           invokeRestart(restart)
[17:43:50.796]                           muffled <- TRUE
[17:43:50.796]                           break
[17:43:50.796]                         }
[17:43:50.796]                       }
[17:43:50.796]                     }
[17:43:50.796]                     invisible(muffled)
[17:43:50.796]                   }
[17:43:50.796]                   muffleCondition(cond)
[17:43:50.796]                 })
[17:43:50.796]             }))
[17:43:50.796]             future::FutureResult(value = ...future.value$value, 
[17:43:50.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.796]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.796]                     ...future.globalenv.names))
[17:43:50.796]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.796]         }, condition = base::local({
[17:43:50.796]             c <- base::c
[17:43:50.796]             inherits <- base::inherits
[17:43:50.796]             invokeRestart <- base::invokeRestart
[17:43:50.796]             length <- base::length
[17:43:50.796]             list <- base::list
[17:43:50.796]             seq.int <- base::seq.int
[17:43:50.796]             signalCondition <- base::signalCondition
[17:43:50.796]             sys.calls <- base::sys.calls
[17:43:50.796]             `[[` <- base::`[[`
[17:43:50.796]             `+` <- base::`+`
[17:43:50.796]             `<<-` <- base::`<<-`
[17:43:50.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.796]                   3L)]
[17:43:50.796]             }
[17:43:50.796]             function(cond) {
[17:43:50.796]                 is_error <- inherits(cond, "error")
[17:43:50.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.796]                   NULL)
[17:43:50.796]                 if (is_error) {
[17:43:50.796]                   sessionInformation <- function() {
[17:43:50.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.796]                       search = base::search(), system = base::Sys.info())
[17:43:50.796]                   }
[17:43:50.796]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.796]                     cond$call), session = sessionInformation(), 
[17:43:50.796]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.796]                   signalCondition(cond)
[17:43:50.796]                 }
[17:43:50.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.796]                 "immediateCondition"))) {
[17:43:50.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.796]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.796]                   if (TRUE && !signal) {
[17:43:50.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.796]                     {
[17:43:50.796]                       inherits <- base::inherits
[17:43:50.796]                       invokeRestart <- base::invokeRestart
[17:43:50.796]                       is.null <- base::is.null
[17:43:50.796]                       muffled <- FALSE
[17:43:50.796]                       if (inherits(cond, "message")) {
[17:43:50.796]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.796]                         if (muffled) 
[17:43:50.796]                           invokeRestart("muffleMessage")
[17:43:50.796]                       }
[17:43:50.796]                       else if (inherits(cond, "warning")) {
[17:43:50.796]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.796]                         if (muffled) 
[17:43:50.796]                           invokeRestart("muffleWarning")
[17:43:50.796]                       }
[17:43:50.796]                       else if (inherits(cond, "condition")) {
[17:43:50.796]                         if (!is.null(pattern)) {
[17:43:50.796]                           computeRestarts <- base::computeRestarts
[17:43:50.796]                           grepl <- base::grepl
[17:43:50.796]                           restarts <- computeRestarts(cond)
[17:43:50.796]                           for (restart in restarts) {
[17:43:50.796]                             name <- restart$name
[17:43:50.796]                             if (is.null(name)) 
[17:43:50.796]                               next
[17:43:50.796]                             if (!grepl(pattern, name)) 
[17:43:50.796]                               next
[17:43:50.796]                             invokeRestart(restart)
[17:43:50.796]                             muffled <- TRUE
[17:43:50.796]                             break
[17:43:50.796]                           }
[17:43:50.796]                         }
[17:43:50.796]                       }
[17:43:50.796]                       invisible(muffled)
[17:43:50.796]                     }
[17:43:50.796]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.796]                   }
[17:43:50.796]                 }
[17:43:50.796]                 else {
[17:43:50.796]                   if (TRUE) {
[17:43:50.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.796]                     {
[17:43:50.796]                       inherits <- base::inherits
[17:43:50.796]                       invokeRestart <- base::invokeRestart
[17:43:50.796]                       is.null <- base::is.null
[17:43:50.796]                       muffled <- FALSE
[17:43:50.796]                       if (inherits(cond, "message")) {
[17:43:50.796]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.796]                         if (muffled) 
[17:43:50.796]                           invokeRestart("muffleMessage")
[17:43:50.796]                       }
[17:43:50.796]                       else if (inherits(cond, "warning")) {
[17:43:50.796]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.796]                         if (muffled) 
[17:43:50.796]                           invokeRestart("muffleWarning")
[17:43:50.796]                       }
[17:43:50.796]                       else if (inherits(cond, "condition")) {
[17:43:50.796]                         if (!is.null(pattern)) {
[17:43:50.796]                           computeRestarts <- base::computeRestarts
[17:43:50.796]                           grepl <- base::grepl
[17:43:50.796]                           restarts <- computeRestarts(cond)
[17:43:50.796]                           for (restart in restarts) {
[17:43:50.796]                             name <- restart$name
[17:43:50.796]                             if (is.null(name)) 
[17:43:50.796]                               next
[17:43:50.796]                             if (!grepl(pattern, name)) 
[17:43:50.796]                               next
[17:43:50.796]                             invokeRestart(restart)
[17:43:50.796]                             muffled <- TRUE
[17:43:50.796]                             break
[17:43:50.796]                           }
[17:43:50.796]                         }
[17:43:50.796]                       }
[17:43:50.796]                       invisible(muffled)
[17:43:50.796]                     }
[17:43:50.796]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.796]                   }
[17:43:50.796]                 }
[17:43:50.796]             }
[17:43:50.796]         }))
[17:43:50.796]     }, error = function(ex) {
[17:43:50.796]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.796]                 ...future.rng), started = ...future.startTime, 
[17:43:50.796]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.796]             version = "1.8"), class = "FutureResult")
[17:43:50.796]     }, finally = {
[17:43:50.796]         if (!identical(...future.workdir, getwd())) 
[17:43:50.796]             setwd(...future.workdir)
[17:43:50.796]         {
[17:43:50.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.796]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.796]             }
[17:43:50.796]             base::options(...future.oldOptions)
[17:43:50.796]             if (.Platform$OS.type == "windows") {
[17:43:50.796]                 old_names <- names(...future.oldEnvVars)
[17:43:50.796]                 envs <- base::Sys.getenv()
[17:43:50.796]                 names <- names(envs)
[17:43:50.796]                 common <- intersect(names, old_names)
[17:43:50.796]                 added <- setdiff(names, old_names)
[17:43:50.796]                 removed <- setdiff(old_names, names)
[17:43:50.796]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.796]                   envs[common]]
[17:43:50.796]                 NAMES <- toupper(changed)
[17:43:50.796]                 args <- list()
[17:43:50.796]                 for (kk in seq_along(NAMES)) {
[17:43:50.796]                   name <- changed[[kk]]
[17:43:50.796]                   NAME <- NAMES[[kk]]
[17:43:50.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.796]                     next
[17:43:50.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.796]                 }
[17:43:50.796]                 NAMES <- toupper(added)
[17:43:50.796]                 for (kk in seq_along(NAMES)) {
[17:43:50.796]                   name <- added[[kk]]
[17:43:50.796]                   NAME <- NAMES[[kk]]
[17:43:50.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.796]                     next
[17:43:50.796]                   args[[name]] <- ""
[17:43:50.796]                 }
[17:43:50.796]                 NAMES <- toupper(removed)
[17:43:50.796]                 for (kk in seq_along(NAMES)) {
[17:43:50.796]                   name <- removed[[kk]]
[17:43:50.796]                   NAME <- NAMES[[kk]]
[17:43:50.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.796]                     next
[17:43:50.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.796]                 }
[17:43:50.796]                 if (length(args) > 0) 
[17:43:50.796]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.796]             }
[17:43:50.796]             else {
[17:43:50.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.796]             }
[17:43:50.796]             {
[17:43:50.796]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.796]                   0L) {
[17:43:50.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.796]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.796]                   base::options(opts)
[17:43:50.796]                 }
[17:43:50.796]                 {
[17:43:50.796]                   {
[17:43:50.796]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.796]                     NULL
[17:43:50.796]                   }
[17:43:50.796]                   options(future.plan = NULL)
[17:43:50.796]                   if (is.na(NA_character_)) 
[17:43:50.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.796]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:50.796]                     .init = FALSE)
[17:43:50.796]                 }
[17:43:50.796]             }
[17:43:50.796]         }
[17:43:50.796]     })
[17:43:50.796]     if (TRUE) {
[17:43:50.796]         base::sink(type = "output", split = FALSE)
[17:43:50.796]         if (TRUE) {
[17:43:50.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.796]         }
[17:43:50.796]         else {
[17:43:50.796]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.796]         }
[17:43:50.796]         base::close(...future.stdout)
[17:43:50.796]         ...future.stdout <- NULL
[17:43:50.796]     }
[17:43:50.796]     ...future.result$conditions <- ...future.conditions
[17:43:50.796]     ...future.result$finished <- base::Sys.time()
[17:43:50.796]     ...future.result
[17:43:50.796] }
[17:43:50.799] Exporting 5 global objects (1.97 KiB) to cluster node #1 ...
[17:43:50.799] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:50.799] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:50.799] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ...
[17:43:50.800] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ... DONE
[17:43:50.800] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ...
[17:43:50.800] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ... DONE
[17:43:50.800] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:50.801] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:50.801] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:43:50.801] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:43:50.801] Exporting 5 global objects (1.97 KiB) to cluster node #1 ... DONE
[17:43:50.801] MultisessionFuture started
[17:43:50.802] - Launch lazy future ... done
[17:43:50.802] run() for ‘MultisessionFuture’ ... done
[17:43:50.802] Created future:
[17:43:50.802] MultisessionFuture:
[17:43:50.802] Label: ‘future_apply-1’
[17:43:50.802] Expression:
[17:43:50.802] {
[17:43:50.802]     do.call(function(...) {
[17:43:50.802]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.802]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.802]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.802]             on.exit(options(oopts), add = TRUE)
[17:43:50.802]         }
[17:43:50.802]         {
[17:43:50.802]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.802]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.802]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.802]             })
[17:43:50.802]         }
[17:43:50.802]     }, args = future.call.arguments)
[17:43:50.802] }
[17:43:50.802] Lazy evaluation: FALSE
[17:43:50.802] Asynchronous evaluation: TRUE
[17:43:50.802] Local evaluation: TRUE
[17:43:50.802] Environment: R_GlobalEnv
[17:43:50.802] Capture standard output: TRUE
[17:43:50.802] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:50.802] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:50.802] Packages: <none>
[17:43:50.802] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:50.802] Resolved: FALSE
[17:43:50.802] Value: <not collected>
[17:43:50.802] Conditions captured: <none>
[17:43:50.802] Early signaling: FALSE
[17:43:50.802] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:50.802] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.813] Chunk #1 of 2 ... DONE
[17:43:50.813] Chunk #2 of 2 ...
[17:43:50.814]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:50.814]  - seeds: <none>
[17:43:50.814]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.814] getGlobalsAndPackages() ...
[17:43:50.814] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.814] Resolving globals: FALSE
[17:43:50.814] Tweak future expression to call with '...' arguments ...
[17:43:50.814] {
[17:43:50.814]     do.call(function(...) {
[17:43:50.814]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.814]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.814]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.814]             on.exit(options(oopts), add = TRUE)
[17:43:50.814]         }
[17:43:50.814]         {
[17:43:50.814]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.814]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.814]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.814]             })
[17:43:50.814]         }
[17:43:50.814]     }, args = future.call.arguments)
[17:43:50.814] }
[17:43:50.815] Tweak future expression to call with '...' arguments ... DONE
[17:43:50.815] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.815] 
[17:43:50.815] getGlobalsAndPackages() ... DONE
[17:43:50.815] run() for ‘Future’ ...
[17:43:50.816] - state: ‘created’
[17:43:50.816] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.829] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.829]   - Field: ‘node’
[17:43:50.829]   - Field: ‘label’
[17:43:50.829]   - Field: ‘local’
[17:43:50.830]   - Field: ‘owner’
[17:43:50.830]   - Field: ‘envir’
[17:43:50.830]   - Field: ‘workers’
[17:43:50.830]   - Field: ‘packages’
[17:43:50.830]   - Field: ‘gc’
[17:43:50.830]   - Field: ‘conditions’
[17:43:50.830]   - Field: ‘persistent’
[17:43:50.830]   - Field: ‘expr’
[17:43:50.830]   - Field: ‘uuid’
[17:43:50.830]   - Field: ‘seed’
[17:43:50.830]   - Field: ‘version’
[17:43:50.831]   - Field: ‘result’
[17:43:50.831]   - Field: ‘asynchronous’
[17:43:50.831]   - Field: ‘calls’
[17:43:50.831]   - Field: ‘globals’
[17:43:50.831]   - Field: ‘stdout’
[17:43:50.831]   - Field: ‘earlySignal’
[17:43:50.831]   - Field: ‘lazy’
[17:43:50.831]   - Field: ‘state’
[17:43:50.831] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.831] - Launch lazy future ...
[17:43:50.832] Packages needed by the future expression (n = 0): <none>
[17:43:50.832] Packages needed by future strategies (n = 0): <none>
[17:43:50.832] {
[17:43:50.832]     {
[17:43:50.832]         {
[17:43:50.832]             ...future.startTime <- base::Sys.time()
[17:43:50.832]             {
[17:43:50.832]                 {
[17:43:50.832]                   {
[17:43:50.832]                     {
[17:43:50.832]                       base::local({
[17:43:50.832]                         has_future <- base::requireNamespace("future", 
[17:43:50.832]                           quietly = TRUE)
[17:43:50.832]                         if (has_future) {
[17:43:50.832]                           ns <- base::getNamespace("future")
[17:43:50.832]                           version <- ns[[".package"]][["version"]]
[17:43:50.832]                           if (is.null(version)) 
[17:43:50.832]                             version <- utils::packageVersion("future")
[17:43:50.832]                         }
[17:43:50.832]                         else {
[17:43:50.832]                           version <- NULL
[17:43:50.832]                         }
[17:43:50.832]                         if (!has_future || version < "1.8.0") {
[17:43:50.832]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.832]                             "", base::R.version$version.string), 
[17:43:50.832]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:50.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:50.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.832]                               "release", "version")], collapse = " "), 
[17:43:50.832]                             hostname = base::Sys.info()[["nodename"]])
[17:43:50.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.832]                             info)
[17:43:50.832]                           info <- base::paste(info, collapse = "; ")
[17:43:50.832]                           if (!has_future) {
[17:43:50.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.832]                               info)
[17:43:50.832]                           }
[17:43:50.832]                           else {
[17:43:50.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.832]                               info, version)
[17:43:50.832]                           }
[17:43:50.832]                           base::stop(msg)
[17:43:50.832]                         }
[17:43:50.832]                       })
[17:43:50.832]                     }
[17:43:50.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.832]                     base::options(mc.cores = 1L)
[17:43:50.832]                   }
[17:43:50.832]                   ...future.strategy.old <- future::plan("list")
[17:43:50.832]                   options(future.plan = NULL)
[17:43:50.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.832]                 }
[17:43:50.832]                 ...future.workdir <- getwd()
[17:43:50.832]             }
[17:43:50.832]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.832]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.832]         }
[17:43:50.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.832]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:50.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.832]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.832]             base::names(...future.oldOptions))
[17:43:50.832]     }
[17:43:50.832]     if (FALSE) {
[17:43:50.832]     }
[17:43:50.832]     else {
[17:43:50.832]         if (TRUE) {
[17:43:50.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.832]                 open = "w")
[17:43:50.832]         }
[17:43:50.832]         else {
[17:43:50.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.832]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.832]         }
[17:43:50.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.832]             base::sink(type = "output", split = FALSE)
[17:43:50.832]             base::close(...future.stdout)
[17:43:50.832]         }, add = TRUE)
[17:43:50.832]     }
[17:43:50.832]     ...future.frame <- base::sys.nframe()
[17:43:50.832]     ...future.conditions <- base::list()
[17:43:50.832]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.832]     if (FALSE) {
[17:43:50.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.832]     }
[17:43:50.832]     ...future.result <- base::tryCatch({
[17:43:50.832]         base::withCallingHandlers({
[17:43:50.832]             ...future.value <- base::withVisible(base::local({
[17:43:50.832]                 ...future.makeSendCondition <- base::local({
[17:43:50.832]                   sendCondition <- NULL
[17:43:50.832]                   function(frame = 1L) {
[17:43:50.832]                     if (is.function(sendCondition)) 
[17:43:50.832]                       return(sendCondition)
[17:43:50.832]                     ns <- getNamespace("parallel")
[17:43:50.832]                     if (exists("sendData", mode = "function", 
[17:43:50.832]                       envir = ns)) {
[17:43:50.832]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.832]                         envir = ns)
[17:43:50.832]                       envir <- sys.frame(frame)
[17:43:50.832]                       master <- NULL
[17:43:50.832]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.832]                         !identical(envir, emptyenv())) {
[17:43:50.832]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.832]                           inherits = FALSE)) {
[17:43:50.832]                           master <- get("master", mode = "list", 
[17:43:50.832]                             envir = envir, inherits = FALSE)
[17:43:50.832]                           if (inherits(master, c("SOCKnode", 
[17:43:50.832]                             "SOCK0node"))) {
[17:43:50.832]                             sendCondition <<- function(cond) {
[17:43:50.832]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.832]                                 success = TRUE)
[17:43:50.832]                               parallel_sendData(master, data)
[17:43:50.832]                             }
[17:43:50.832]                             return(sendCondition)
[17:43:50.832]                           }
[17:43:50.832]                         }
[17:43:50.832]                         frame <- frame + 1L
[17:43:50.832]                         envir <- sys.frame(frame)
[17:43:50.832]                       }
[17:43:50.832]                     }
[17:43:50.832]                     sendCondition <<- function(cond) NULL
[17:43:50.832]                   }
[17:43:50.832]                 })
[17:43:50.832]                 withCallingHandlers({
[17:43:50.832]                   {
[17:43:50.832]                     do.call(function(...) {
[17:43:50.832]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.832]                       if (!identical(...future.globals.maxSize.org, 
[17:43:50.832]                         ...future.globals.maxSize)) {
[17:43:50.832]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.832]                         on.exit(options(oopts), add = TRUE)
[17:43:50.832]                       }
[17:43:50.832]                       {
[17:43:50.832]                         lapply(seq_along(...future.elements_ii), 
[17:43:50.832]                           FUN = function(jj) {
[17:43:50.832]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.832]                             ...future.FUN(...future.X_jj, ...)
[17:43:50.832]                           })
[17:43:50.832]                       }
[17:43:50.832]                     }, args = future.call.arguments)
[17:43:50.832]                   }
[17:43:50.832]                 }, immediateCondition = function(cond) {
[17:43:50.832]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.832]                   sendCondition(cond)
[17:43:50.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.832]                   {
[17:43:50.832]                     inherits <- base::inherits
[17:43:50.832]                     invokeRestart <- base::invokeRestart
[17:43:50.832]                     is.null <- base::is.null
[17:43:50.832]                     muffled <- FALSE
[17:43:50.832]                     if (inherits(cond, "message")) {
[17:43:50.832]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.832]                       if (muffled) 
[17:43:50.832]                         invokeRestart("muffleMessage")
[17:43:50.832]                     }
[17:43:50.832]                     else if (inherits(cond, "warning")) {
[17:43:50.832]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.832]                       if (muffled) 
[17:43:50.832]                         invokeRestart("muffleWarning")
[17:43:50.832]                     }
[17:43:50.832]                     else if (inherits(cond, "condition")) {
[17:43:50.832]                       if (!is.null(pattern)) {
[17:43:50.832]                         computeRestarts <- base::computeRestarts
[17:43:50.832]                         grepl <- base::grepl
[17:43:50.832]                         restarts <- computeRestarts(cond)
[17:43:50.832]                         for (restart in restarts) {
[17:43:50.832]                           name <- restart$name
[17:43:50.832]                           if (is.null(name)) 
[17:43:50.832]                             next
[17:43:50.832]                           if (!grepl(pattern, name)) 
[17:43:50.832]                             next
[17:43:50.832]                           invokeRestart(restart)
[17:43:50.832]                           muffled <- TRUE
[17:43:50.832]                           break
[17:43:50.832]                         }
[17:43:50.832]                       }
[17:43:50.832]                     }
[17:43:50.832]                     invisible(muffled)
[17:43:50.832]                   }
[17:43:50.832]                   muffleCondition(cond)
[17:43:50.832]                 })
[17:43:50.832]             }))
[17:43:50.832]             future::FutureResult(value = ...future.value$value, 
[17:43:50.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.832]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.832]                     ...future.globalenv.names))
[17:43:50.832]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.832]         }, condition = base::local({
[17:43:50.832]             c <- base::c
[17:43:50.832]             inherits <- base::inherits
[17:43:50.832]             invokeRestart <- base::invokeRestart
[17:43:50.832]             length <- base::length
[17:43:50.832]             list <- base::list
[17:43:50.832]             seq.int <- base::seq.int
[17:43:50.832]             signalCondition <- base::signalCondition
[17:43:50.832]             sys.calls <- base::sys.calls
[17:43:50.832]             `[[` <- base::`[[`
[17:43:50.832]             `+` <- base::`+`
[17:43:50.832]             `<<-` <- base::`<<-`
[17:43:50.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.832]                   3L)]
[17:43:50.832]             }
[17:43:50.832]             function(cond) {
[17:43:50.832]                 is_error <- inherits(cond, "error")
[17:43:50.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.832]                   NULL)
[17:43:50.832]                 if (is_error) {
[17:43:50.832]                   sessionInformation <- function() {
[17:43:50.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.832]                       search = base::search(), system = base::Sys.info())
[17:43:50.832]                   }
[17:43:50.832]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.832]                     cond$call), session = sessionInformation(), 
[17:43:50.832]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.832]                   signalCondition(cond)
[17:43:50.832]                 }
[17:43:50.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.832]                 "immediateCondition"))) {
[17:43:50.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.832]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.832]                   if (TRUE && !signal) {
[17:43:50.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.832]                     {
[17:43:50.832]                       inherits <- base::inherits
[17:43:50.832]                       invokeRestart <- base::invokeRestart
[17:43:50.832]                       is.null <- base::is.null
[17:43:50.832]                       muffled <- FALSE
[17:43:50.832]                       if (inherits(cond, "message")) {
[17:43:50.832]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.832]                         if (muffled) 
[17:43:50.832]                           invokeRestart("muffleMessage")
[17:43:50.832]                       }
[17:43:50.832]                       else if (inherits(cond, "warning")) {
[17:43:50.832]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.832]                         if (muffled) 
[17:43:50.832]                           invokeRestart("muffleWarning")
[17:43:50.832]                       }
[17:43:50.832]                       else if (inherits(cond, "condition")) {
[17:43:50.832]                         if (!is.null(pattern)) {
[17:43:50.832]                           computeRestarts <- base::computeRestarts
[17:43:50.832]                           grepl <- base::grepl
[17:43:50.832]                           restarts <- computeRestarts(cond)
[17:43:50.832]                           for (restart in restarts) {
[17:43:50.832]                             name <- restart$name
[17:43:50.832]                             if (is.null(name)) 
[17:43:50.832]                               next
[17:43:50.832]                             if (!grepl(pattern, name)) 
[17:43:50.832]                               next
[17:43:50.832]                             invokeRestart(restart)
[17:43:50.832]                             muffled <- TRUE
[17:43:50.832]                             break
[17:43:50.832]                           }
[17:43:50.832]                         }
[17:43:50.832]                       }
[17:43:50.832]                       invisible(muffled)
[17:43:50.832]                     }
[17:43:50.832]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.832]                   }
[17:43:50.832]                 }
[17:43:50.832]                 else {
[17:43:50.832]                   if (TRUE) {
[17:43:50.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.832]                     {
[17:43:50.832]                       inherits <- base::inherits
[17:43:50.832]                       invokeRestart <- base::invokeRestart
[17:43:50.832]                       is.null <- base::is.null
[17:43:50.832]                       muffled <- FALSE
[17:43:50.832]                       if (inherits(cond, "message")) {
[17:43:50.832]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.832]                         if (muffled) 
[17:43:50.832]                           invokeRestart("muffleMessage")
[17:43:50.832]                       }
[17:43:50.832]                       else if (inherits(cond, "warning")) {
[17:43:50.832]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.832]                         if (muffled) 
[17:43:50.832]                           invokeRestart("muffleWarning")
[17:43:50.832]                       }
[17:43:50.832]                       else if (inherits(cond, "condition")) {
[17:43:50.832]                         if (!is.null(pattern)) {
[17:43:50.832]                           computeRestarts <- base::computeRestarts
[17:43:50.832]                           grepl <- base::grepl
[17:43:50.832]                           restarts <- computeRestarts(cond)
[17:43:50.832]                           for (restart in restarts) {
[17:43:50.832]                             name <- restart$name
[17:43:50.832]                             if (is.null(name)) 
[17:43:50.832]                               next
[17:43:50.832]                             if (!grepl(pattern, name)) 
[17:43:50.832]                               next
[17:43:50.832]                             invokeRestart(restart)
[17:43:50.832]                             muffled <- TRUE
[17:43:50.832]                             break
[17:43:50.832]                           }
[17:43:50.832]                         }
[17:43:50.832]                       }
[17:43:50.832]                       invisible(muffled)
[17:43:50.832]                     }
[17:43:50.832]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.832]                   }
[17:43:50.832]                 }
[17:43:50.832]             }
[17:43:50.832]         }))
[17:43:50.832]     }, error = function(ex) {
[17:43:50.832]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.832]                 ...future.rng), started = ...future.startTime, 
[17:43:50.832]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.832]             version = "1.8"), class = "FutureResult")
[17:43:50.832]     }, finally = {
[17:43:50.832]         if (!identical(...future.workdir, getwd())) 
[17:43:50.832]             setwd(...future.workdir)
[17:43:50.832]         {
[17:43:50.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.832]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.832]             }
[17:43:50.832]             base::options(...future.oldOptions)
[17:43:50.832]             if (.Platform$OS.type == "windows") {
[17:43:50.832]                 old_names <- names(...future.oldEnvVars)
[17:43:50.832]                 envs <- base::Sys.getenv()
[17:43:50.832]                 names <- names(envs)
[17:43:50.832]                 common <- intersect(names, old_names)
[17:43:50.832]                 added <- setdiff(names, old_names)
[17:43:50.832]                 removed <- setdiff(old_names, names)
[17:43:50.832]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.832]                   envs[common]]
[17:43:50.832]                 NAMES <- toupper(changed)
[17:43:50.832]                 args <- list()
[17:43:50.832]                 for (kk in seq_along(NAMES)) {
[17:43:50.832]                   name <- changed[[kk]]
[17:43:50.832]                   NAME <- NAMES[[kk]]
[17:43:50.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.832]                     next
[17:43:50.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.832]                 }
[17:43:50.832]                 NAMES <- toupper(added)
[17:43:50.832]                 for (kk in seq_along(NAMES)) {
[17:43:50.832]                   name <- added[[kk]]
[17:43:50.832]                   NAME <- NAMES[[kk]]
[17:43:50.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.832]                     next
[17:43:50.832]                   args[[name]] <- ""
[17:43:50.832]                 }
[17:43:50.832]                 NAMES <- toupper(removed)
[17:43:50.832]                 for (kk in seq_along(NAMES)) {
[17:43:50.832]                   name <- removed[[kk]]
[17:43:50.832]                   NAME <- NAMES[[kk]]
[17:43:50.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.832]                     next
[17:43:50.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.832]                 }
[17:43:50.832]                 if (length(args) > 0) 
[17:43:50.832]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.832]             }
[17:43:50.832]             else {
[17:43:50.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.832]             }
[17:43:50.832]             {
[17:43:50.832]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.832]                   0L) {
[17:43:50.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.832]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.832]                   base::options(opts)
[17:43:50.832]                 }
[17:43:50.832]                 {
[17:43:50.832]                   {
[17:43:50.832]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.832]                     NULL
[17:43:50.832]                   }
[17:43:50.832]                   options(future.plan = NULL)
[17:43:50.832]                   if (is.na(NA_character_)) 
[17:43:50.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:50.832]                     .init = FALSE)
[17:43:50.832]                 }
[17:43:50.832]             }
[17:43:50.832]         }
[17:43:50.832]     })
[17:43:50.832]     if (TRUE) {
[17:43:50.832]         base::sink(type = "output", split = FALSE)
[17:43:50.832]         if (TRUE) {
[17:43:50.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.832]         }
[17:43:50.832]         else {
[17:43:50.832]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.832]         }
[17:43:50.832]         base::close(...future.stdout)
[17:43:50.832]         ...future.stdout <- NULL
[17:43:50.832]     }
[17:43:50.832]     ...future.result$conditions <- ...future.conditions
[17:43:50.832]     ...future.result$finished <- base::Sys.time()
[17:43:50.832]     ...future.result
[17:43:50.832] }
[17:43:50.835] Exporting 5 global objects (1.97 KiB) to cluster node #2 ...
[17:43:50.835] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:50.836] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:50.836] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ...
[17:43:50.836] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ... DONE
[17:43:50.836] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ...
[17:43:50.837] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ... DONE
[17:43:50.837] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:50.837] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:50.837] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:43:50.837] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:43:50.837] Exporting 5 global objects (1.97 KiB) to cluster node #2 ... DONE
[17:43:50.838] MultisessionFuture started
[17:43:50.838] - Launch lazy future ... done
[17:43:50.838] run() for ‘MultisessionFuture’ ... done
[17:43:50.838] Created future:
[17:43:50.838] MultisessionFuture:
[17:43:50.838] Label: ‘future_apply-2’
[17:43:50.838] Expression:
[17:43:50.838] {
[17:43:50.838]     do.call(function(...) {
[17:43:50.838]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.838]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.838]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.838]             on.exit(options(oopts), add = TRUE)
[17:43:50.838]         }
[17:43:50.838]         {
[17:43:50.838]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.838]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.838]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.838]             })
[17:43:50.838]         }
[17:43:50.838]     }, args = future.call.arguments)
[17:43:50.838] }
[17:43:50.838] Lazy evaluation: FALSE
[17:43:50.838] Asynchronous evaluation: TRUE
[17:43:50.838] Local evaluation: TRUE
[17:43:50.838] Environment: R_GlobalEnv
[17:43:50.838] Capture standard output: TRUE
[17:43:50.838] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:50.838] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:50.838] Packages: <none>
[17:43:50.838] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:50.838] Resolved: FALSE
[17:43:50.838] Value: <not collected>
[17:43:50.838] Conditions captured: <none>
[17:43:50.838] Early signaling: FALSE
[17:43:50.838] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:50.838] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.850] Chunk #2 of 2 ... DONE
[17:43:50.850] Launching 2 futures (chunks) ... DONE
[17:43:50.850] Resolving 2 futures (chunks) ...
[17:43:50.850] resolve() on list ...
[17:43:50.850]  recursive: 0
[17:43:50.850]  length: 2
[17:43:50.850] 
[17:43:50.851] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.851] - Validating connection of MultisessionFuture
[17:43:50.851] - received message: FutureResult
[17:43:50.851] - Received FutureResult
[17:43:50.851] - Erased future from FutureRegistry
[17:43:50.852] result() for ClusterFuture ...
[17:43:50.852] - result already collected: FutureResult
[17:43:50.852] result() for ClusterFuture ... done
[17:43:50.852] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.852] Future #1
[17:43:50.852] result() for ClusterFuture ...
[17:43:50.852] - result already collected: FutureResult
[17:43:50.852] result() for ClusterFuture ... done
[17:43:50.852] result() for ClusterFuture ...
[17:43:50.852] - result already collected: FutureResult
[17:43:50.852] result() for ClusterFuture ... done
[17:43:50.852] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:50.853] - nx: 2
[17:43:50.853] - relay: TRUE
[17:43:50.853] - stdout: TRUE
[17:43:50.853] - signal: TRUE
[17:43:50.853] - resignal: FALSE
[17:43:50.853] - force: TRUE
[17:43:50.853] - relayed: [n=2] FALSE, FALSE
[17:43:50.853] - queued futures: [n=2] FALSE, FALSE
[17:43:50.853]  - until=1
[17:43:50.853]  - relaying element #1
[17:43:50.853] result() for ClusterFuture ...
[17:43:50.853] - result already collected: FutureResult
[17:43:50.854] result() for ClusterFuture ... done
[17:43:50.854] result() for ClusterFuture ...
[17:43:50.854] - result already collected: FutureResult
[17:43:50.854] result() for ClusterFuture ... done
[17:43:50.854] result() for ClusterFuture ...
[17:43:50.854] - result already collected: FutureResult
[17:43:50.854] result() for ClusterFuture ... done
[17:43:50.854] result() for ClusterFuture ...
[17:43:50.854] - result already collected: FutureResult
[17:43:50.854] result() for ClusterFuture ... done
[17:43:50.854] - relayed: [n=2] TRUE, FALSE
[17:43:50.855] - queued futures: [n=2] TRUE, FALSE
[17:43:50.855] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:50.855]  length: 1 (resolved future 1)
[17:43:50.881] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.881] - Validating connection of MultisessionFuture
[17:43:50.881] - received message: FutureResult
[17:43:50.881] - Received FutureResult
[17:43:50.881] - Erased future from FutureRegistry
[17:43:50.881] result() for ClusterFuture ...
[17:43:50.882] - result already collected: FutureResult
[17:43:50.882] result() for ClusterFuture ... done
[17:43:50.882] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.882] Future #2
[17:43:50.882] result() for ClusterFuture ...
[17:43:50.882] - result already collected: FutureResult
[17:43:50.882] result() for ClusterFuture ... done
[17:43:50.882] result() for ClusterFuture ...
[17:43:50.882] - result already collected: FutureResult
[17:43:50.882] result() for ClusterFuture ... done
[17:43:50.883] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:50.883] - nx: 2
[17:43:50.883] - relay: TRUE
[17:43:50.883] - stdout: TRUE
[17:43:50.883] - signal: TRUE
[17:43:50.883] - resignal: FALSE
[17:43:50.883] - force: TRUE
[17:43:50.883] - relayed: [n=2] TRUE, FALSE
[17:43:50.883] - queued futures: [n=2] TRUE, FALSE
[17:43:50.883]  - until=2
[17:43:50.883]  - relaying element #2
[17:43:50.883] result() for ClusterFuture ...
[17:43:50.884] - result already collected: FutureResult
[17:43:50.884] result() for ClusterFuture ... done
[17:43:50.884] result() for ClusterFuture ...
[17:43:50.884] - result already collected: FutureResult
[17:43:50.884] result() for ClusterFuture ... done
[17:43:50.884] result() for ClusterFuture ...
[17:43:50.884] - result already collected: FutureResult
[17:43:50.884] result() for ClusterFuture ... done
[17:43:50.884] result() for ClusterFuture ...
[17:43:50.884] - result already collected: FutureResult
[17:43:50.884] result() for ClusterFuture ... done
[17:43:50.885] - relayed: [n=2] TRUE, TRUE
[17:43:50.885] - queued futures: [n=2] TRUE, TRUE
[17:43:50.885] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:50.885]  length: 0 (resolved future 2)
[17:43:50.885] Relaying remaining futures
[17:43:50.885] signalConditionsASAP(NULL, pos=0) ...
[17:43:50.885] - nx: 2
[17:43:50.885] - relay: TRUE
[17:43:50.885] - stdout: TRUE
[17:43:50.885] - signal: TRUE
[17:43:50.885] - resignal: FALSE
[17:43:50.885] - force: TRUE
[17:43:50.886] - relayed: [n=2] TRUE, TRUE
[17:43:50.886] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:50.886] - relayed: [n=2] TRUE, TRUE
[17:43:50.886] - queued futures: [n=2] TRUE, TRUE
[17:43:50.886] signalConditionsASAP(NULL, pos=0) ... done
[17:43:50.886] resolve() on list ... DONE
[17:43:50.886] result() for ClusterFuture ...
[17:43:50.886] - result already collected: FutureResult
[17:43:50.886] result() for ClusterFuture ... done
[17:43:50.886] result() for ClusterFuture ...
[17:43:50.886] - result already collected: FutureResult
[17:43:50.887] result() for ClusterFuture ... done
[17:43:50.887] result() for ClusterFuture ...
[17:43:50.887] - result already collected: FutureResult
[17:43:50.887] result() for ClusterFuture ... done
[17:43:50.887] result() for ClusterFuture ...
[17:43:50.887] - result already collected: FutureResult
[17:43:50.887] result() for ClusterFuture ... done
[17:43:50.887]  - Number of value chunks collected: 2
[17:43:50.887] Resolving 2 futures (chunks) ... DONE
[17:43:50.887] Reducing values from 2 chunks ...
[17:43:50.887]  - Number of values collected after concatenation: 6
[17:43:50.888]  - Number of values expected: 6
[17:43:50.888] Reducing values from 2 chunks ... DONE
[17:43:50.888] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[17:43:50.888] getGlobalsAndPackagesXApply() ...
[17:43:50.888]  - future.globals: TRUE
[17:43:50.888] getGlobalsAndPackages() ...
[17:43:50.888] Searching for globals...
[17:43:50.891] - globals found: [1] ‘FUN’
[17:43:50.892] Searching for globals ... DONE
[17:43:50.892] Resolving globals: FALSE
[17:43:50.892] The total size of the 1 globals is 848 bytes (848 bytes)
[17:43:50.892] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:43:50.892] - globals: [1] ‘FUN’
[17:43:50.893] 
[17:43:50.893] getGlobalsAndPackages() ... DONE
[17:43:50.893]  - globals found/used: [n=1] ‘FUN’
[17:43:50.893]  - needed namespaces: [n=0] 
[17:43:50.893] Finding globals ... DONE
[17:43:50.893]  - use_args: TRUE
[17:43:50.893]  - Getting '...' globals ...
[17:43:50.893] resolve() on list ...
[17:43:50.893]  recursive: 0
[17:43:50.894]  length: 1
[17:43:50.894]  elements: ‘...’
[17:43:50.894]  length: 0 (resolved future 1)
[17:43:50.894] resolve() on list ... DONE
[17:43:50.894]    - '...' content: [n=0] 
[17:43:50.894] List of 1
[17:43:50.894]  $ ...: list()
[17:43:50.894]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.894]  - attr(*, "where")=List of 1
[17:43:50.894]   ..$ ...:<environment: 0x55dfd71e5810> 
[17:43:50.894]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.894]  - attr(*, "resolved")= logi TRUE
[17:43:50.894]  - attr(*, "total_size")= num NA
[17:43:50.896]  - Getting '...' globals ... DONE
[17:43:50.897] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:50.897] List of 2
[17:43:50.897]  $ ...future.FUN:function (x)  
[17:43:50.897]  $ ...          : list()
[17:43:50.897]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.897]  - attr(*, "where")=List of 2
[17:43:50.897]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:50.897]   ..$ ...          :<environment: 0x55dfd71e5810> 
[17:43:50.897]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.897]  - attr(*, "resolved")= logi FALSE
[17:43:50.897]  - attr(*, "total_size")= num 848
[17:43:50.899] Packages to be attached in all futures: [n=0] 
[17:43:50.899] getGlobalsAndPackagesXApply() ... DONE
[17:43:50.903] future_lapply() ...
[17:43:50.907] Number of chunks: 2
[17:43:50.907] getGlobalsAndPackagesXApply() ...
[17:43:50.907]  - future.globals: <name-value list> with names ‘list()’
[17:43:50.907]  - use_args: TRUE
[17:43:50.908] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:50.908] List of 2
[17:43:50.908]  $ ...          : list()
[17:43:50.908]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:50.908]  $ ...future.FUN:function (x)  
[17:43:50.908]  - attr(*, "where")=List of 2
[17:43:50.908]   ..$ ...          :<environment: 0x55dfd71e5810> 
[17:43:50.908]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:50.908]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:50.908]  - attr(*, "resolved")= logi FALSE
[17:43:50.908]  - attr(*, "total_size")= num NA
[17:43:50.911] Packages to be attached in all futures: [n=0] 
[17:43:50.911] getGlobalsAndPackagesXApply() ... DONE
[17:43:50.911] Number of futures (= number of chunks): 2
[17:43:50.911] Launching 2 futures (chunks) ...
[17:43:50.911] Chunk #1 of 2 ...
[17:43:50.912]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:50.912]  - seeds: <none>
[17:43:50.912]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.912] getGlobalsAndPackages() ...
[17:43:50.912] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.912] Resolving globals: FALSE
[17:43:50.912] Tweak future expression to call with '...' arguments ...
[17:43:50.912] {
[17:43:50.912]     do.call(function(...) {
[17:43:50.912]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.912]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.912]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.912]             on.exit(options(oopts), add = TRUE)
[17:43:50.912]         }
[17:43:50.912]         {
[17:43:50.912]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.912]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.912]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.912]             })
[17:43:50.912]         }
[17:43:50.912]     }, args = future.call.arguments)
[17:43:50.912] }
[17:43:50.913] Tweak future expression to call with '...' arguments ... DONE
[17:43:50.913] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.913] 
[17:43:50.913] getGlobalsAndPackages() ... DONE
[17:43:50.913] run() for ‘Future’ ...
[17:43:50.914] - state: ‘created’
[17:43:50.914] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.928] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.928] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.928]   - Field: ‘node’
[17:43:50.928]   - Field: ‘label’
[17:43:50.928]   - Field: ‘local’
[17:43:50.928]   - Field: ‘owner’
[17:43:50.928]   - Field: ‘envir’
[17:43:50.928]   - Field: ‘workers’
[17:43:50.928]   - Field: ‘packages’
[17:43:50.929]   - Field: ‘gc’
[17:43:50.929]   - Field: ‘conditions’
[17:43:50.929]   - Field: ‘persistent’
[17:43:50.929]   - Field: ‘expr’
[17:43:50.929]   - Field: ‘uuid’
[17:43:50.929]   - Field: ‘seed’
[17:43:50.929]   - Field: ‘version’
[17:43:50.929]   - Field: ‘result’
[17:43:50.929]   - Field: ‘asynchronous’
[17:43:50.929]   - Field: ‘calls’
[17:43:50.929]   - Field: ‘globals’
[17:43:50.930]   - Field: ‘stdout’
[17:43:50.930]   - Field: ‘earlySignal’
[17:43:50.930]   - Field: ‘lazy’
[17:43:50.930]   - Field: ‘state’
[17:43:50.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.930] - Launch lazy future ...
[17:43:50.930] Packages needed by the future expression (n = 0): <none>
[17:43:50.930] Packages needed by future strategies (n = 0): <none>
[17:43:50.931] {
[17:43:50.931]     {
[17:43:50.931]         {
[17:43:50.931]             ...future.startTime <- base::Sys.time()
[17:43:50.931]             {
[17:43:50.931]                 {
[17:43:50.931]                   {
[17:43:50.931]                     {
[17:43:50.931]                       base::local({
[17:43:50.931]                         has_future <- base::requireNamespace("future", 
[17:43:50.931]                           quietly = TRUE)
[17:43:50.931]                         if (has_future) {
[17:43:50.931]                           ns <- base::getNamespace("future")
[17:43:50.931]                           version <- ns[[".package"]][["version"]]
[17:43:50.931]                           if (is.null(version)) 
[17:43:50.931]                             version <- utils::packageVersion("future")
[17:43:50.931]                         }
[17:43:50.931]                         else {
[17:43:50.931]                           version <- NULL
[17:43:50.931]                         }
[17:43:50.931]                         if (!has_future || version < "1.8.0") {
[17:43:50.931]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.931]                             "", base::R.version$version.string), 
[17:43:50.931]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:50.931]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:50.931]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.931]                               "release", "version")], collapse = " "), 
[17:43:50.931]                             hostname = base::Sys.info()[["nodename"]])
[17:43:50.931]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.931]                             info)
[17:43:50.931]                           info <- base::paste(info, collapse = "; ")
[17:43:50.931]                           if (!has_future) {
[17:43:50.931]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.931]                               info)
[17:43:50.931]                           }
[17:43:50.931]                           else {
[17:43:50.931]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.931]                               info, version)
[17:43:50.931]                           }
[17:43:50.931]                           base::stop(msg)
[17:43:50.931]                         }
[17:43:50.931]                       })
[17:43:50.931]                     }
[17:43:50.931]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.931]                     base::options(mc.cores = 1L)
[17:43:50.931]                   }
[17:43:50.931]                   ...future.strategy.old <- future::plan("list")
[17:43:50.931]                   options(future.plan = NULL)
[17:43:50.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.931]                 }
[17:43:50.931]                 ...future.workdir <- getwd()
[17:43:50.931]             }
[17:43:50.931]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.931]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.931]         }
[17:43:50.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.931]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:50.931]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.931]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.931]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.931]             base::names(...future.oldOptions))
[17:43:50.931]     }
[17:43:50.931]     if (FALSE) {
[17:43:50.931]     }
[17:43:50.931]     else {
[17:43:50.931]         if (TRUE) {
[17:43:50.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.931]                 open = "w")
[17:43:50.931]         }
[17:43:50.931]         else {
[17:43:50.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.931]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.931]         }
[17:43:50.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.931]             base::sink(type = "output", split = FALSE)
[17:43:50.931]             base::close(...future.stdout)
[17:43:50.931]         }, add = TRUE)
[17:43:50.931]     }
[17:43:50.931]     ...future.frame <- base::sys.nframe()
[17:43:50.931]     ...future.conditions <- base::list()
[17:43:50.931]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.931]     if (FALSE) {
[17:43:50.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.931]     }
[17:43:50.931]     ...future.result <- base::tryCatch({
[17:43:50.931]         base::withCallingHandlers({
[17:43:50.931]             ...future.value <- base::withVisible(base::local({
[17:43:50.931]                 ...future.makeSendCondition <- base::local({
[17:43:50.931]                   sendCondition <- NULL
[17:43:50.931]                   function(frame = 1L) {
[17:43:50.931]                     if (is.function(sendCondition)) 
[17:43:50.931]                       return(sendCondition)
[17:43:50.931]                     ns <- getNamespace("parallel")
[17:43:50.931]                     if (exists("sendData", mode = "function", 
[17:43:50.931]                       envir = ns)) {
[17:43:50.931]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.931]                         envir = ns)
[17:43:50.931]                       envir <- sys.frame(frame)
[17:43:50.931]                       master <- NULL
[17:43:50.931]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.931]                         !identical(envir, emptyenv())) {
[17:43:50.931]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.931]                           inherits = FALSE)) {
[17:43:50.931]                           master <- get("master", mode = "list", 
[17:43:50.931]                             envir = envir, inherits = FALSE)
[17:43:50.931]                           if (inherits(master, c("SOCKnode", 
[17:43:50.931]                             "SOCK0node"))) {
[17:43:50.931]                             sendCondition <<- function(cond) {
[17:43:50.931]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.931]                                 success = TRUE)
[17:43:50.931]                               parallel_sendData(master, data)
[17:43:50.931]                             }
[17:43:50.931]                             return(sendCondition)
[17:43:50.931]                           }
[17:43:50.931]                         }
[17:43:50.931]                         frame <- frame + 1L
[17:43:50.931]                         envir <- sys.frame(frame)
[17:43:50.931]                       }
[17:43:50.931]                     }
[17:43:50.931]                     sendCondition <<- function(cond) NULL
[17:43:50.931]                   }
[17:43:50.931]                 })
[17:43:50.931]                 withCallingHandlers({
[17:43:50.931]                   {
[17:43:50.931]                     do.call(function(...) {
[17:43:50.931]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.931]                       if (!identical(...future.globals.maxSize.org, 
[17:43:50.931]                         ...future.globals.maxSize)) {
[17:43:50.931]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.931]                         on.exit(options(oopts), add = TRUE)
[17:43:50.931]                       }
[17:43:50.931]                       {
[17:43:50.931]                         lapply(seq_along(...future.elements_ii), 
[17:43:50.931]                           FUN = function(jj) {
[17:43:50.931]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.931]                             ...future.FUN(...future.X_jj, ...)
[17:43:50.931]                           })
[17:43:50.931]                       }
[17:43:50.931]                     }, args = future.call.arguments)
[17:43:50.931]                   }
[17:43:50.931]                 }, immediateCondition = function(cond) {
[17:43:50.931]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.931]                   sendCondition(cond)
[17:43:50.931]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.931]                   {
[17:43:50.931]                     inherits <- base::inherits
[17:43:50.931]                     invokeRestart <- base::invokeRestart
[17:43:50.931]                     is.null <- base::is.null
[17:43:50.931]                     muffled <- FALSE
[17:43:50.931]                     if (inherits(cond, "message")) {
[17:43:50.931]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.931]                       if (muffled) 
[17:43:50.931]                         invokeRestart("muffleMessage")
[17:43:50.931]                     }
[17:43:50.931]                     else if (inherits(cond, "warning")) {
[17:43:50.931]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.931]                       if (muffled) 
[17:43:50.931]                         invokeRestart("muffleWarning")
[17:43:50.931]                     }
[17:43:50.931]                     else if (inherits(cond, "condition")) {
[17:43:50.931]                       if (!is.null(pattern)) {
[17:43:50.931]                         computeRestarts <- base::computeRestarts
[17:43:50.931]                         grepl <- base::grepl
[17:43:50.931]                         restarts <- computeRestarts(cond)
[17:43:50.931]                         for (restart in restarts) {
[17:43:50.931]                           name <- restart$name
[17:43:50.931]                           if (is.null(name)) 
[17:43:50.931]                             next
[17:43:50.931]                           if (!grepl(pattern, name)) 
[17:43:50.931]                             next
[17:43:50.931]                           invokeRestart(restart)
[17:43:50.931]                           muffled <- TRUE
[17:43:50.931]                           break
[17:43:50.931]                         }
[17:43:50.931]                       }
[17:43:50.931]                     }
[17:43:50.931]                     invisible(muffled)
[17:43:50.931]                   }
[17:43:50.931]                   muffleCondition(cond)
[17:43:50.931]                 })
[17:43:50.931]             }))
[17:43:50.931]             future::FutureResult(value = ...future.value$value, 
[17:43:50.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.931]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.931]                     ...future.globalenv.names))
[17:43:50.931]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.931]         }, condition = base::local({
[17:43:50.931]             c <- base::c
[17:43:50.931]             inherits <- base::inherits
[17:43:50.931]             invokeRestart <- base::invokeRestart
[17:43:50.931]             length <- base::length
[17:43:50.931]             list <- base::list
[17:43:50.931]             seq.int <- base::seq.int
[17:43:50.931]             signalCondition <- base::signalCondition
[17:43:50.931]             sys.calls <- base::sys.calls
[17:43:50.931]             `[[` <- base::`[[`
[17:43:50.931]             `+` <- base::`+`
[17:43:50.931]             `<<-` <- base::`<<-`
[17:43:50.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.931]                   3L)]
[17:43:50.931]             }
[17:43:50.931]             function(cond) {
[17:43:50.931]                 is_error <- inherits(cond, "error")
[17:43:50.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.931]                   NULL)
[17:43:50.931]                 if (is_error) {
[17:43:50.931]                   sessionInformation <- function() {
[17:43:50.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.931]                       search = base::search(), system = base::Sys.info())
[17:43:50.931]                   }
[17:43:50.931]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.931]                     cond$call), session = sessionInformation(), 
[17:43:50.931]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.931]                   signalCondition(cond)
[17:43:50.931]                 }
[17:43:50.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.931]                 "immediateCondition"))) {
[17:43:50.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.931]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.931]                   if (TRUE && !signal) {
[17:43:50.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.931]                     {
[17:43:50.931]                       inherits <- base::inherits
[17:43:50.931]                       invokeRestart <- base::invokeRestart
[17:43:50.931]                       is.null <- base::is.null
[17:43:50.931]                       muffled <- FALSE
[17:43:50.931]                       if (inherits(cond, "message")) {
[17:43:50.931]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.931]                         if (muffled) 
[17:43:50.931]                           invokeRestart("muffleMessage")
[17:43:50.931]                       }
[17:43:50.931]                       else if (inherits(cond, "warning")) {
[17:43:50.931]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.931]                         if (muffled) 
[17:43:50.931]                           invokeRestart("muffleWarning")
[17:43:50.931]                       }
[17:43:50.931]                       else if (inherits(cond, "condition")) {
[17:43:50.931]                         if (!is.null(pattern)) {
[17:43:50.931]                           computeRestarts <- base::computeRestarts
[17:43:50.931]                           grepl <- base::grepl
[17:43:50.931]                           restarts <- computeRestarts(cond)
[17:43:50.931]                           for (restart in restarts) {
[17:43:50.931]                             name <- restart$name
[17:43:50.931]                             if (is.null(name)) 
[17:43:50.931]                               next
[17:43:50.931]                             if (!grepl(pattern, name)) 
[17:43:50.931]                               next
[17:43:50.931]                             invokeRestart(restart)
[17:43:50.931]                             muffled <- TRUE
[17:43:50.931]                             break
[17:43:50.931]                           }
[17:43:50.931]                         }
[17:43:50.931]                       }
[17:43:50.931]                       invisible(muffled)
[17:43:50.931]                     }
[17:43:50.931]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.931]                   }
[17:43:50.931]                 }
[17:43:50.931]                 else {
[17:43:50.931]                   if (TRUE) {
[17:43:50.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.931]                     {
[17:43:50.931]                       inherits <- base::inherits
[17:43:50.931]                       invokeRestart <- base::invokeRestart
[17:43:50.931]                       is.null <- base::is.null
[17:43:50.931]                       muffled <- FALSE
[17:43:50.931]                       if (inherits(cond, "message")) {
[17:43:50.931]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.931]                         if (muffled) 
[17:43:50.931]                           invokeRestart("muffleMessage")
[17:43:50.931]                       }
[17:43:50.931]                       else if (inherits(cond, "warning")) {
[17:43:50.931]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.931]                         if (muffled) 
[17:43:50.931]                           invokeRestart("muffleWarning")
[17:43:50.931]                       }
[17:43:50.931]                       else if (inherits(cond, "condition")) {
[17:43:50.931]                         if (!is.null(pattern)) {
[17:43:50.931]                           computeRestarts <- base::computeRestarts
[17:43:50.931]                           grepl <- base::grepl
[17:43:50.931]                           restarts <- computeRestarts(cond)
[17:43:50.931]                           for (restart in restarts) {
[17:43:50.931]                             name <- restart$name
[17:43:50.931]                             if (is.null(name)) 
[17:43:50.931]                               next
[17:43:50.931]                             if (!grepl(pattern, name)) 
[17:43:50.931]                               next
[17:43:50.931]                             invokeRestart(restart)
[17:43:50.931]                             muffled <- TRUE
[17:43:50.931]                             break
[17:43:50.931]                           }
[17:43:50.931]                         }
[17:43:50.931]                       }
[17:43:50.931]                       invisible(muffled)
[17:43:50.931]                     }
[17:43:50.931]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.931]                   }
[17:43:50.931]                 }
[17:43:50.931]             }
[17:43:50.931]         }))
[17:43:50.931]     }, error = function(ex) {
[17:43:50.931]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.931]                 ...future.rng), started = ...future.startTime, 
[17:43:50.931]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.931]             version = "1.8"), class = "FutureResult")
[17:43:50.931]     }, finally = {
[17:43:50.931]         if (!identical(...future.workdir, getwd())) 
[17:43:50.931]             setwd(...future.workdir)
[17:43:50.931]         {
[17:43:50.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.931]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.931]             }
[17:43:50.931]             base::options(...future.oldOptions)
[17:43:50.931]             if (.Platform$OS.type == "windows") {
[17:43:50.931]                 old_names <- names(...future.oldEnvVars)
[17:43:50.931]                 envs <- base::Sys.getenv()
[17:43:50.931]                 names <- names(envs)
[17:43:50.931]                 common <- intersect(names, old_names)
[17:43:50.931]                 added <- setdiff(names, old_names)
[17:43:50.931]                 removed <- setdiff(old_names, names)
[17:43:50.931]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.931]                   envs[common]]
[17:43:50.931]                 NAMES <- toupper(changed)
[17:43:50.931]                 args <- list()
[17:43:50.931]                 for (kk in seq_along(NAMES)) {
[17:43:50.931]                   name <- changed[[kk]]
[17:43:50.931]                   NAME <- NAMES[[kk]]
[17:43:50.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.931]                     next
[17:43:50.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.931]                 }
[17:43:50.931]                 NAMES <- toupper(added)
[17:43:50.931]                 for (kk in seq_along(NAMES)) {
[17:43:50.931]                   name <- added[[kk]]
[17:43:50.931]                   NAME <- NAMES[[kk]]
[17:43:50.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.931]                     next
[17:43:50.931]                   args[[name]] <- ""
[17:43:50.931]                 }
[17:43:50.931]                 NAMES <- toupper(removed)
[17:43:50.931]                 for (kk in seq_along(NAMES)) {
[17:43:50.931]                   name <- removed[[kk]]
[17:43:50.931]                   NAME <- NAMES[[kk]]
[17:43:50.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.931]                     next
[17:43:50.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.931]                 }
[17:43:50.931]                 if (length(args) > 0) 
[17:43:50.931]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.931]             }
[17:43:50.931]             else {
[17:43:50.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.931]             }
[17:43:50.931]             {
[17:43:50.931]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.931]                   0L) {
[17:43:50.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.931]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.931]                   base::options(opts)
[17:43:50.931]                 }
[17:43:50.931]                 {
[17:43:50.931]                   {
[17:43:50.931]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.931]                     NULL
[17:43:50.931]                   }
[17:43:50.931]                   options(future.plan = NULL)
[17:43:50.931]                   if (is.na(NA_character_)) 
[17:43:50.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.931]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:50.931]                     .init = FALSE)
[17:43:50.931]                 }
[17:43:50.931]             }
[17:43:50.931]         }
[17:43:50.931]     })
[17:43:50.931]     if (TRUE) {
[17:43:50.931]         base::sink(type = "output", split = FALSE)
[17:43:50.931]         if (TRUE) {
[17:43:50.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.931]         }
[17:43:50.931]         else {
[17:43:50.931]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.931]         }
[17:43:50.931]         base::close(...future.stdout)
[17:43:50.931]         ...future.stdout <- NULL
[17:43:50.931]     }
[17:43:50.931]     ...future.result$conditions <- ...future.conditions
[17:43:50.931]     ...future.result$finished <- base::Sys.time()
[17:43:50.931]     ...future.result
[17:43:50.931] }
[17:43:50.934] Exporting 5 global objects (960 bytes) to cluster node #1 ...
[17:43:50.934] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:50.934] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:50.934] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:43:50.935] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:43:50.935] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:43:50.935] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:43:50.935] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:50.936] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:50.936] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:43:50.936] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:43:50.936] Exporting 5 global objects (960 bytes) to cluster node #1 ... DONE
[17:43:50.937] MultisessionFuture started
[17:43:50.937] - Launch lazy future ... done
[17:43:50.937] run() for ‘MultisessionFuture’ ... done
[17:43:50.937] Created future:
[17:43:50.937] MultisessionFuture:
[17:43:50.937] Label: ‘future_apply-1’
[17:43:50.937] Expression:
[17:43:50.937] {
[17:43:50.937]     do.call(function(...) {
[17:43:50.937]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.937]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.937]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.937]             on.exit(options(oopts), add = TRUE)
[17:43:50.937]         }
[17:43:50.937]         {
[17:43:50.937]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.937]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.937]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.937]             })
[17:43:50.937]         }
[17:43:50.937]     }, args = future.call.arguments)
[17:43:50.937] }
[17:43:50.937] Lazy evaluation: FALSE
[17:43:50.937] Asynchronous evaluation: TRUE
[17:43:50.937] Local evaluation: TRUE
[17:43:50.937] Environment: R_GlobalEnv
[17:43:50.937] Capture standard output: TRUE
[17:43:50.937] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:50.937] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:50.937] Packages: <none>
[17:43:50.937] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:50.937] Resolved: FALSE
[17:43:50.937] Value: <not collected>
[17:43:50.937] Conditions captured: <none>
[17:43:50.937] Early signaling: FALSE
[17:43:50.937] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:50.937] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.949] Chunk #1 of 2 ... DONE
[17:43:50.949] Chunk #2 of 2 ...
[17:43:50.949]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:50.949]  - seeds: <none>
[17:43:50.949]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.949] getGlobalsAndPackages() ...
[17:43:50.949] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.949] Resolving globals: FALSE
[17:43:50.949] Tweak future expression to call with '...' arguments ...
[17:43:50.950] {
[17:43:50.950]     do.call(function(...) {
[17:43:50.950]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.950]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.950]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.950]             on.exit(options(oopts), add = TRUE)
[17:43:50.950]         }
[17:43:50.950]         {
[17:43:50.950]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.950]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.950]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.950]             })
[17:43:50.950]         }
[17:43:50.950]     }, args = future.call.arguments)
[17:43:50.950] }
[17:43:50.950] Tweak future expression to call with '...' arguments ... DONE
[17:43:50.950] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:50.950] 
[17:43:50.950] getGlobalsAndPackages() ... DONE
[17:43:50.951] run() for ‘Future’ ...
[17:43:50.951] - state: ‘created’
[17:43:50.951] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.965] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.965]   - Field: ‘node’
[17:43:50.965]   - Field: ‘label’
[17:43:50.965]   - Field: ‘local’
[17:43:50.965]   - Field: ‘owner’
[17:43:50.965]   - Field: ‘envir’
[17:43:50.965]   - Field: ‘workers’
[17:43:50.965]   - Field: ‘packages’
[17:43:50.965]   - Field: ‘gc’
[17:43:50.966]   - Field: ‘conditions’
[17:43:50.966]   - Field: ‘persistent’
[17:43:50.966]   - Field: ‘expr’
[17:43:50.966]   - Field: ‘uuid’
[17:43:50.966]   - Field: ‘seed’
[17:43:50.966]   - Field: ‘version’
[17:43:50.966]   - Field: ‘result’
[17:43:50.966]   - Field: ‘asynchronous’
[17:43:50.966]   - Field: ‘calls’
[17:43:50.966]   - Field: ‘globals’
[17:43:50.966]   - Field: ‘stdout’
[17:43:50.967]   - Field: ‘earlySignal’
[17:43:50.967]   - Field: ‘lazy’
[17:43:50.967]   - Field: ‘state’
[17:43:50.967] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.967] - Launch lazy future ...
[17:43:50.967] Packages needed by the future expression (n = 0): <none>
[17:43:50.967] Packages needed by future strategies (n = 0): <none>
[17:43:50.968] {
[17:43:50.968]     {
[17:43:50.968]         {
[17:43:50.968]             ...future.startTime <- base::Sys.time()
[17:43:50.968]             {
[17:43:50.968]                 {
[17:43:50.968]                   {
[17:43:50.968]                     {
[17:43:50.968]                       base::local({
[17:43:50.968]                         has_future <- base::requireNamespace("future", 
[17:43:50.968]                           quietly = TRUE)
[17:43:50.968]                         if (has_future) {
[17:43:50.968]                           ns <- base::getNamespace("future")
[17:43:50.968]                           version <- ns[[".package"]][["version"]]
[17:43:50.968]                           if (is.null(version)) 
[17:43:50.968]                             version <- utils::packageVersion("future")
[17:43:50.968]                         }
[17:43:50.968]                         else {
[17:43:50.968]                           version <- NULL
[17:43:50.968]                         }
[17:43:50.968]                         if (!has_future || version < "1.8.0") {
[17:43:50.968]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.968]                             "", base::R.version$version.string), 
[17:43:50.968]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:50.968]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:50.968]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.968]                               "release", "version")], collapse = " "), 
[17:43:50.968]                             hostname = base::Sys.info()[["nodename"]])
[17:43:50.968]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.968]                             info)
[17:43:50.968]                           info <- base::paste(info, collapse = "; ")
[17:43:50.968]                           if (!has_future) {
[17:43:50.968]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.968]                               info)
[17:43:50.968]                           }
[17:43:50.968]                           else {
[17:43:50.968]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.968]                               info, version)
[17:43:50.968]                           }
[17:43:50.968]                           base::stop(msg)
[17:43:50.968]                         }
[17:43:50.968]                       })
[17:43:50.968]                     }
[17:43:50.968]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.968]                     base::options(mc.cores = 1L)
[17:43:50.968]                   }
[17:43:50.968]                   ...future.strategy.old <- future::plan("list")
[17:43:50.968]                   options(future.plan = NULL)
[17:43:50.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.968]                 }
[17:43:50.968]                 ...future.workdir <- getwd()
[17:43:50.968]             }
[17:43:50.968]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.968]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.968]         }
[17:43:50.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.968]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:50.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.968]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.968]             base::names(...future.oldOptions))
[17:43:50.968]     }
[17:43:50.968]     if (FALSE) {
[17:43:50.968]     }
[17:43:50.968]     else {
[17:43:50.968]         if (TRUE) {
[17:43:50.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.968]                 open = "w")
[17:43:50.968]         }
[17:43:50.968]         else {
[17:43:50.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.968]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.968]         }
[17:43:50.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.968]             base::sink(type = "output", split = FALSE)
[17:43:50.968]             base::close(...future.stdout)
[17:43:50.968]         }, add = TRUE)
[17:43:50.968]     }
[17:43:50.968]     ...future.frame <- base::sys.nframe()
[17:43:50.968]     ...future.conditions <- base::list()
[17:43:50.968]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.968]     if (FALSE) {
[17:43:50.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.968]     }
[17:43:50.968]     ...future.result <- base::tryCatch({
[17:43:50.968]         base::withCallingHandlers({
[17:43:50.968]             ...future.value <- base::withVisible(base::local({
[17:43:50.968]                 ...future.makeSendCondition <- base::local({
[17:43:50.968]                   sendCondition <- NULL
[17:43:50.968]                   function(frame = 1L) {
[17:43:50.968]                     if (is.function(sendCondition)) 
[17:43:50.968]                       return(sendCondition)
[17:43:50.968]                     ns <- getNamespace("parallel")
[17:43:50.968]                     if (exists("sendData", mode = "function", 
[17:43:50.968]                       envir = ns)) {
[17:43:50.968]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.968]                         envir = ns)
[17:43:50.968]                       envir <- sys.frame(frame)
[17:43:50.968]                       master <- NULL
[17:43:50.968]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.968]                         !identical(envir, emptyenv())) {
[17:43:50.968]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.968]                           inherits = FALSE)) {
[17:43:50.968]                           master <- get("master", mode = "list", 
[17:43:50.968]                             envir = envir, inherits = FALSE)
[17:43:50.968]                           if (inherits(master, c("SOCKnode", 
[17:43:50.968]                             "SOCK0node"))) {
[17:43:50.968]                             sendCondition <<- function(cond) {
[17:43:50.968]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.968]                                 success = TRUE)
[17:43:50.968]                               parallel_sendData(master, data)
[17:43:50.968]                             }
[17:43:50.968]                             return(sendCondition)
[17:43:50.968]                           }
[17:43:50.968]                         }
[17:43:50.968]                         frame <- frame + 1L
[17:43:50.968]                         envir <- sys.frame(frame)
[17:43:50.968]                       }
[17:43:50.968]                     }
[17:43:50.968]                     sendCondition <<- function(cond) NULL
[17:43:50.968]                   }
[17:43:50.968]                 })
[17:43:50.968]                 withCallingHandlers({
[17:43:50.968]                   {
[17:43:50.968]                     do.call(function(...) {
[17:43:50.968]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.968]                       if (!identical(...future.globals.maxSize.org, 
[17:43:50.968]                         ...future.globals.maxSize)) {
[17:43:50.968]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.968]                         on.exit(options(oopts), add = TRUE)
[17:43:50.968]                       }
[17:43:50.968]                       {
[17:43:50.968]                         lapply(seq_along(...future.elements_ii), 
[17:43:50.968]                           FUN = function(jj) {
[17:43:50.968]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.968]                             ...future.FUN(...future.X_jj, ...)
[17:43:50.968]                           })
[17:43:50.968]                       }
[17:43:50.968]                     }, args = future.call.arguments)
[17:43:50.968]                   }
[17:43:50.968]                 }, immediateCondition = function(cond) {
[17:43:50.968]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.968]                   sendCondition(cond)
[17:43:50.968]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.968]                   {
[17:43:50.968]                     inherits <- base::inherits
[17:43:50.968]                     invokeRestart <- base::invokeRestart
[17:43:50.968]                     is.null <- base::is.null
[17:43:50.968]                     muffled <- FALSE
[17:43:50.968]                     if (inherits(cond, "message")) {
[17:43:50.968]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.968]                       if (muffled) 
[17:43:50.968]                         invokeRestart("muffleMessage")
[17:43:50.968]                     }
[17:43:50.968]                     else if (inherits(cond, "warning")) {
[17:43:50.968]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.968]                       if (muffled) 
[17:43:50.968]                         invokeRestart("muffleWarning")
[17:43:50.968]                     }
[17:43:50.968]                     else if (inherits(cond, "condition")) {
[17:43:50.968]                       if (!is.null(pattern)) {
[17:43:50.968]                         computeRestarts <- base::computeRestarts
[17:43:50.968]                         grepl <- base::grepl
[17:43:50.968]                         restarts <- computeRestarts(cond)
[17:43:50.968]                         for (restart in restarts) {
[17:43:50.968]                           name <- restart$name
[17:43:50.968]                           if (is.null(name)) 
[17:43:50.968]                             next
[17:43:50.968]                           if (!grepl(pattern, name)) 
[17:43:50.968]                             next
[17:43:50.968]                           invokeRestart(restart)
[17:43:50.968]                           muffled <- TRUE
[17:43:50.968]                           break
[17:43:50.968]                         }
[17:43:50.968]                       }
[17:43:50.968]                     }
[17:43:50.968]                     invisible(muffled)
[17:43:50.968]                   }
[17:43:50.968]                   muffleCondition(cond)
[17:43:50.968]                 })
[17:43:50.968]             }))
[17:43:50.968]             future::FutureResult(value = ...future.value$value, 
[17:43:50.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.968]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.968]                     ...future.globalenv.names))
[17:43:50.968]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.968]         }, condition = base::local({
[17:43:50.968]             c <- base::c
[17:43:50.968]             inherits <- base::inherits
[17:43:50.968]             invokeRestart <- base::invokeRestart
[17:43:50.968]             length <- base::length
[17:43:50.968]             list <- base::list
[17:43:50.968]             seq.int <- base::seq.int
[17:43:50.968]             signalCondition <- base::signalCondition
[17:43:50.968]             sys.calls <- base::sys.calls
[17:43:50.968]             `[[` <- base::`[[`
[17:43:50.968]             `+` <- base::`+`
[17:43:50.968]             `<<-` <- base::`<<-`
[17:43:50.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.968]                   3L)]
[17:43:50.968]             }
[17:43:50.968]             function(cond) {
[17:43:50.968]                 is_error <- inherits(cond, "error")
[17:43:50.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.968]                   NULL)
[17:43:50.968]                 if (is_error) {
[17:43:50.968]                   sessionInformation <- function() {
[17:43:50.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.968]                       search = base::search(), system = base::Sys.info())
[17:43:50.968]                   }
[17:43:50.968]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.968]                     cond$call), session = sessionInformation(), 
[17:43:50.968]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.968]                   signalCondition(cond)
[17:43:50.968]                 }
[17:43:50.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.968]                 "immediateCondition"))) {
[17:43:50.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.968]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.968]                   if (TRUE && !signal) {
[17:43:50.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.968]                     {
[17:43:50.968]                       inherits <- base::inherits
[17:43:50.968]                       invokeRestart <- base::invokeRestart
[17:43:50.968]                       is.null <- base::is.null
[17:43:50.968]                       muffled <- FALSE
[17:43:50.968]                       if (inherits(cond, "message")) {
[17:43:50.968]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.968]                         if (muffled) 
[17:43:50.968]                           invokeRestart("muffleMessage")
[17:43:50.968]                       }
[17:43:50.968]                       else if (inherits(cond, "warning")) {
[17:43:50.968]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.968]                         if (muffled) 
[17:43:50.968]                           invokeRestart("muffleWarning")
[17:43:50.968]                       }
[17:43:50.968]                       else if (inherits(cond, "condition")) {
[17:43:50.968]                         if (!is.null(pattern)) {
[17:43:50.968]                           computeRestarts <- base::computeRestarts
[17:43:50.968]                           grepl <- base::grepl
[17:43:50.968]                           restarts <- computeRestarts(cond)
[17:43:50.968]                           for (restart in restarts) {
[17:43:50.968]                             name <- restart$name
[17:43:50.968]                             if (is.null(name)) 
[17:43:50.968]                               next
[17:43:50.968]                             if (!grepl(pattern, name)) 
[17:43:50.968]                               next
[17:43:50.968]                             invokeRestart(restart)
[17:43:50.968]                             muffled <- TRUE
[17:43:50.968]                             break
[17:43:50.968]                           }
[17:43:50.968]                         }
[17:43:50.968]                       }
[17:43:50.968]                       invisible(muffled)
[17:43:50.968]                     }
[17:43:50.968]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.968]                   }
[17:43:50.968]                 }
[17:43:50.968]                 else {
[17:43:50.968]                   if (TRUE) {
[17:43:50.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.968]                     {
[17:43:50.968]                       inherits <- base::inherits
[17:43:50.968]                       invokeRestart <- base::invokeRestart
[17:43:50.968]                       is.null <- base::is.null
[17:43:50.968]                       muffled <- FALSE
[17:43:50.968]                       if (inherits(cond, "message")) {
[17:43:50.968]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.968]                         if (muffled) 
[17:43:50.968]                           invokeRestart("muffleMessage")
[17:43:50.968]                       }
[17:43:50.968]                       else if (inherits(cond, "warning")) {
[17:43:50.968]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.968]                         if (muffled) 
[17:43:50.968]                           invokeRestart("muffleWarning")
[17:43:50.968]                       }
[17:43:50.968]                       else if (inherits(cond, "condition")) {
[17:43:50.968]                         if (!is.null(pattern)) {
[17:43:50.968]                           computeRestarts <- base::computeRestarts
[17:43:50.968]                           grepl <- base::grepl
[17:43:50.968]                           restarts <- computeRestarts(cond)
[17:43:50.968]                           for (restart in restarts) {
[17:43:50.968]                             name <- restart$name
[17:43:50.968]                             if (is.null(name)) 
[17:43:50.968]                               next
[17:43:50.968]                             if (!grepl(pattern, name)) 
[17:43:50.968]                               next
[17:43:50.968]                             invokeRestart(restart)
[17:43:50.968]                             muffled <- TRUE
[17:43:50.968]                             break
[17:43:50.968]                           }
[17:43:50.968]                         }
[17:43:50.968]                       }
[17:43:50.968]                       invisible(muffled)
[17:43:50.968]                     }
[17:43:50.968]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.968]                   }
[17:43:50.968]                 }
[17:43:50.968]             }
[17:43:50.968]         }))
[17:43:50.968]     }, error = function(ex) {
[17:43:50.968]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.968]                 ...future.rng), started = ...future.startTime, 
[17:43:50.968]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.968]             version = "1.8"), class = "FutureResult")
[17:43:50.968]     }, finally = {
[17:43:50.968]         if (!identical(...future.workdir, getwd())) 
[17:43:50.968]             setwd(...future.workdir)
[17:43:50.968]         {
[17:43:50.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.968]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.968]             }
[17:43:50.968]             base::options(...future.oldOptions)
[17:43:50.968]             if (.Platform$OS.type == "windows") {
[17:43:50.968]                 old_names <- names(...future.oldEnvVars)
[17:43:50.968]                 envs <- base::Sys.getenv()
[17:43:50.968]                 names <- names(envs)
[17:43:50.968]                 common <- intersect(names, old_names)
[17:43:50.968]                 added <- setdiff(names, old_names)
[17:43:50.968]                 removed <- setdiff(old_names, names)
[17:43:50.968]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.968]                   envs[common]]
[17:43:50.968]                 NAMES <- toupper(changed)
[17:43:50.968]                 args <- list()
[17:43:50.968]                 for (kk in seq_along(NAMES)) {
[17:43:50.968]                   name <- changed[[kk]]
[17:43:50.968]                   NAME <- NAMES[[kk]]
[17:43:50.968]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.968]                     next
[17:43:50.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.968]                 }
[17:43:50.968]                 NAMES <- toupper(added)
[17:43:50.968]                 for (kk in seq_along(NAMES)) {
[17:43:50.968]                   name <- added[[kk]]
[17:43:50.968]                   NAME <- NAMES[[kk]]
[17:43:50.968]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.968]                     next
[17:43:50.968]                   args[[name]] <- ""
[17:43:50.968]                 }
[17:43:50.968]                 NAMES <- toupper(removed)
[17:43:50.968]                 for (kk in seq_along(NAMES)) {
[17:43:50.968]                   name <- removed[[kk]]
[17:43:50.968]                   NAME <- NAMES[[kk]]
[17:43:50.968]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.968]                     next
[17:43:50.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.968]                 }
[17:43:50.968]                 if (length(args) > 0) 
[17:43:50.968]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.968]             }
[17:43:50.968]             else {
[17:43:50.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.968]             }
[17:43:50.968]             {
[17:43:50.968]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.968]                   0L) {
[17:43:50.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.968]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.968]                   base::options(opts)
[17:43:50.968]                 }
[17:43:50.968]                 {
[17:43:50.968]                   {
[17:43:50.968]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.968]                     NULL
[17:43:50.968]                   }
[17:43:50.968]                   options(future.plan = NULL)
[17:43:50.968]                   if (is.na(NA_character_)) 
[17:43:50.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.968]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:50.968]                     .init = FALSE)
[17:43:50.968]                 }
[17:43:50.968]             }
[17:43:50.968]         }
[17:43:50.968]     })
[17:43:50.968]     if (TRUE) {
[17:43:50.968]         base::sink(type = "output", split = FALSE)
[17:43:50.968]         if (TRUE) {
[17:43:50.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.968]         }
[17:43:50.968]         else {
[17:43:50.968]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.968]         }
[17:43:50.968]         base::close(...future.stdout)
[17:43:50.968]         ...future.stdout <- NULL
[17:43:50.968]     }
[17:43:50.968]     ...future.result$conditions <- ...future.conditions
[17:43:50.968]     ...future.result$finished <- base::Sys.time()
[17:43:50.968]     ...future.result
[17:43:50.968] }
[17:43:50.971] Exporting 5 global objects (960 bytes) to cluster node #2 ...
[17:43:50.971] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:50.971] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:50.971] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:43:50.972] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:43:50.972] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:43:50.972] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:43:50.972] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:50.973] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:50.973] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:43:50.973] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:43:50.973] Exporting 5 global objects (960 bytes) to cluster node #2 ... DONE
[17:43:50.974] MultisessionFuture started
[17:43:50.974] - Launch lazy future ... done
[17:43:50.974] run() for ‘MultisessionFuture’ ... done
[17:43:50.974] Created future:
[17:43:50.974] MultisessionFuture:
[17:43:50.974] Label: ‘future_apply-2’
[17:43:50.974] Expression:
[17:43:50.974] {
[17:43:50.974]     do.call(function(...) {
[17:43:50.974]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:50.974]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:50.974]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:50.974]             on.exit(options(oopts), add = TRUE)
[17:43:50.974]         }
[17:43:50.974]         {
[17:43:50.974]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:50.974]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:50.974]                 ...future.FUN(...future.X_jj, ...)
[17:43:50.974]             })
[17:43:50.974]         }
[17:43:50.974]     }, args = future.call.arguments)
[17:43:50.974] }
[17:43:50.974] Lazy evaluation: FALSE
[17:43:50.974] Asynchronous evaluation: TRUE
[17:43:50.974] Local evaluation: TRUE
[17:43:50.974] Environment: R_GlobalEnv
[17:43:50.974] Capture standard output: TRUE
[17:43:50.974] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:50.974] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:50.974] Packages: <none>
[17:43:50.974] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:50.974] Resolved: FALSE
[17:43:50.974] Value: <not collected>
[17:43:50.974] Conditions captured: <none>
[17:43:50.974] Early signaling: FALSE
[17:43:50.974] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:50.974] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.986] Chunk #2 of 2 ... DONE
[17:43:50.986] Launching 2 futures (chunks) ... DONE
[17:43:50.986] Resolving 2 futures (chunks) ...
[17:43:50.986] resolve() on list ...
[17:43:50.986]  recursive: 0
[17:43:50.986]  length: 2
[17:43:50.986] 
[17:43:50.987] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.987] - Validating connection of MultisessionFuture
[17:43:50.987] - received message: FutureResult
[17:43:50.987] - Received FutureResult
[17:43:50.987] - Erased future from FutureRegistry
[17:43:50.987] result() for ClusterFuture ...
[17:43:50.987] - result already collected: FutureResult
[17:43:50.987] result() for ClusterFuture ... done
[17:43:50.988] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.988] Future #1
[17:43:50.988] result() for ClusterFuture ...
[17:43:50.988] - result already collected: FutureResult
[17:43:50.988] result() for ClusterFuture ... done
[17:43:50.988] result() for ClusterFuture ...
[17:43:50.988] - result already collected: FutureResult
[17:43:50.988] result() for ClusterFuture ... done
[17:43:50.988] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:50.988] - nx: 2
[17:43:50.988] - relay: TRUE
[17:43:50.989] - stdout: TRUE
[17:43:50.989] - signal: TRUE
[17:43:50.989] - resignal: FALSE
[17:43:50.989] - force: TRUE
[17:43:50.989] - relayed: [n=2] FALSE, FALSE
[17:43:50.989] - queued futures: [n=2] FALSE, FALSE
[17:43:50.989]  - until=1
[17:43:50.989]  - relaying element #1
[17:43:50.989] result() for ClusterFuture ...
[17:43:50.989] - result already collected: FutureResult
[17:43:50.989] result() for ClusterFuture ... done
[17:43:50.990] result() for ClusterFuture ...
[17:43:50.990] - result already collected: FutureResult
[17:43:50.990] result() for ClusterFuture ... done
[17:43:50.990] result() for ClusterFuture ...
[17:43:50.990] - result already collected: FutureResult
[17:43:50.990] result() for ClusterFuture ... done
[17:43:50.990] result() for ClusterFuture ...
[17:43:50.990] - result already collected: FutureResult
[17:43:50.990] result() for ClusterFuture ... done
[17:43:50.990] - relayed: [n=2] TRUE, FALSE
[17:43:50.990] - queued futures: [n=2] TRUE, FALSE
[17:43:50.990] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:50.991]  length: 1 (resolved future 1)
[17:43:51.017] receiveMessageFromWorker() for ClusterFuture ...
[17:43:51.017] - Validating connection of MultisessionFuture
[17:43:51.017] - received message: FutureResult
[17:43:51.017] - Received FutureResult
[17:43:51.018] - Erased future from FutureRegistry
[17:43:51.018] result() for ClusterFuture ...
[17:43:51.018] - result already collected: FutureResult
[17:43:51.018] result() for ClusterFuture ... done
[17:43:51.018] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:51.018] Future #2
[17:43:51.018] result() for ClusterFuture ...
[17:43:51.018] - result already collected: FutureResult
[17:43:51.018] result() for ClusterFuture ... done
[17:43:51.019] result() for ClusterFuture ...
[17:43:51.019] - result already collected: FutureResult
[17:43:51.019] result() for ClusterFuture ... done
[17:43:51.019] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:51.019] - nx: 2
[17:43:51.019] - relay: TRUE
[17:43:51.019] - stdout: TRUE
[17:43:51.019] - signal: TRUE
[17:43:51.019] - resignal: FALSE
[17:43:51.019] - force: TRUE
[17:43:51.019] - relayed: [n=2] TRUE, FALSE
[17:43:51.020] - queued futures: [n=2] TRUE, FALSE
[17:43:51.020]  - until=2
[17:43:51.020]  - relaying element #2
[17:43:51.020] result() for ClusterFuture ...
[17:43:51.020] - result already collected: FutureResult
[17:43:51.020] result() for ClusterFuture ... done
[17:43:51.020] result() for ClusterFuture ...
[17:43:51.020] - result already collected: FutureResult
[17:43:51.020] result() for ClusterFuture ... done
[17:43:51.020] result() for ClusterFuture ...
[17:43:51.020] - result already collected: FutureResult
[17:43:51.021] result() for ClusterFuture ... done
[17:43:51.021] result() for ClusterFuture ...
[17:43:51.021] - result already collected: FutureResult
[17:43:51.021] result() for ClusterFuture ... done
[17:43:51.021] - relayed: [n=2] TRUE, TRUE
[17:43:51.021] - queued futures: [n=2] TRUE, TRUE
[17:43:51.021] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:51.021]  length: 0 (resolved future 2)
[17:43:51.021] Relaying remaining futures
[17:43:51.021] signalConditionsASAP(NULL, pos=0) ...
[17:43:51.021] - nx: 2
[17:43:51.022] - relay: TRUE
[17:43:51.022] - stdout: TRUE
[17:43:51.022] - signal: TRUE
[17:43:51.022] - resignal: FALSE
[17:43:51.022] - force: TRUE
[17:43:51.022] - relayed: [n=2] TRUE, TRUE
[17:43:51.022] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:51.022] - relayed: [n=2] TRUE, TRUE
[17:43:51.022] - queued futures: [n=2] TRUE, TRUE
[17:43:51.022] signalConditionsASAP(NULL, pos=0) ... done
[17:43:51.022] resolve() on list ... DONE
[17:43:51.023] result() for ClusterFuture ...
[17:43:51.023] - result already collected: FutureResult
[17:43:51.023] result() for ClusterFuture ... done
[17:43:51.023] result() for ClusterFuture ...
[17:43:51.023] - result already collected: FutureResult
[17:43:51.023] result() for ClusterFuture ... done
[17:43:51.023] result() for ClusterFuture ...
[17:43:51.023] - result already collected: FutureResult
[17:43:51.023] result() for ClusterFuture ... done
[17:43:51.023] result() for ClusterFuture ...
[17:43:51.023] - result already collected: FutureResult
[17:43:51.024] result() for ClusterFuture ... done
[17:43:51.024]  - Number of value chunks collected: 2
[17:43:51.024] Resolving 2 futures (chunks) ... DONE
[17:43:51.024] Reducing values from 2 chunks ...
[17:43:51.024]  - Number of values collected after concatenation: 2
[17:43:51.024]  - Number of values expected: 2
[17:43:51.024] Reducing values from 2 chunks ... DONE
[17:43:51.024] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[17:43:51.024] getGlobalsAndPackagesXApply() ...
[17:43:51.025]  - future.globals: TRUE
[17:43:51.025] getGlobalsAndPackages() ...
[17:43:51.025] Searching for globals...
[17:43:51.026] - globals found: [1] ‘FUN’
[17:43:51.026] Searching for globals ... DONE
[17:43:51.026] Resolving globals: FALSE
[17:43:51.026] The total size of the 1 globals is 848 bytes (848 bytes)
[17:43:51.027] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:43:51.027] - globals: [1] ‘FUN’
[17:43:51.027] 
[17:43:51.027] getGlobalsAndPackages() ... DONE
[17:43:51.027]  - globals found/used: [n=1] ‘FUN’
[17:43:51.027]  - needed namespaces: [n=0] 
[17:43:51.027] Finding globals ... DONE
[17:43:51.027]  - use_args: TRUE
[17:43:51.028]  - Getting '...' globals ...
[17:43:51.028] resolve() on list ...
[17:43:51.028]  recursive: 0
[17:43:51.028]  length: 1
[17:43:51.028]  elements: ‘...’
[17:43:51.028]  length: 0 (resolved future 1)
[17:43:51.028] resolve() on list ... DONE
[17:43:51.028]    - '...' content: [n=0] 
[17:43:51.029] List of 1
[17:43:51.029]  $ ...: list()
[17:43:51.029]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.029]  - attr(*, "where")=List of 1
[17:43:51.029]   ..$ ...:<environment: 0x55dfd63fc040> 
[17:43:51.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.029]  - attr(*, "resolved")= logi TRUE
[17:43:51.029]  - attr(*, "total_size")= num NA
[17:43:51.031]  - Getting '...' globals ... DONE
[17:43:51.031] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:51.031] List of 2
[17:43:51.031]  $ ...future.FUN:function (x)  
[17:43:51.031]  $ ...          : list()
[17:43:51.031]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.031]  - attr(*, "where")=List of 2
[17:43:51.031]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:51.031]   ..$ ...          :<environment: 0x55dfd63fc040> 
[17:43:51.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.031]  - attr(*, "resolved")= logi FALSE
[17:43:51.031]  - attr(*, "total_size")= num 848
[17:43:51.034] Packages to be attached in all futures: [n=0] 
[17:43:51.034] getGlobalsAndPackagesXApply() ... DONE
[17:43:51.038] future_lapply() ...
[17:43:51.041] Number of chunks: 2
[17:43:51.042] getGlobalsAndPackagesXApply() ...
[17:43:51.042]  - future.globals: <name-value list> with names ‘list()’
[17:43:51.042]  - use_args: TRUE
[17:43:51.042] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:51.042] List of 2
[17:43:51.042]  $ ...          : list()
[17:43:51.042]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.042]  $ ...future.FUN:function (x)  
[17:43:51.042]  - attr(*, "where")=List of 2
[17:43:51.042]   ..$ ...          :<environment: 0x55dfd63fc040> 
[17:43:51.042]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:51.042]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.042]  - attr(*, "resolved")= logi FALSE
[17:43:51.042]  - attr(*, "total_size")= num NA
[17:43:51.045] Packages to be attached in all futures: [n=0] 
[17:43:51.046] getGlobalsAndPackagesXApply() ... DONE
[17:43:51.046] Number of futures (= number of chunks): 2
[17:43:51.046] Launching 2 futures (chunks) ...
[17:43:51.046] Chunk #1 of 2 ...
[17:43:51.046]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:51.046]  - seeds: <none>
[17:43:51.046]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.046] getGlobalsAndPackages() ...
[17:43:51.047] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.047] Resolving globals: FALSE
[17:43:51.047] Tweak future expression to call with '...' arguments ...
[17:43:51.047] {
[17:43:51.047]     do.call(function(...) {
[17:43:51.047]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.047]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.047]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.047]             on.exit(options(oopts), add = TRUE)
[17:43:51.047]         }
[17:43:51.047]         {
[17:43:51.047]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.047]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.047]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.047]             })
[17:43:51.047]         }
[17:43:51.047]     }, args = future.call.arguments)
[17:43:51.047] }
[17:43:51.047] Tweak future expression to call with '...' arguments ... DONE
[17:43:51.048] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.048] 
[17:43:51.048] getGlobalsAndPackages() ... DONE
[17:43:51.048] run() for ‘Future’ ...
[17:43:51.048] - state: ‘created’
[17:43:51.048] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:51.065] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:51.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:51.066]   - Field: ‘node’
[17:43:51.066]   - Field: ‘label’
[17:43:51.066]   - Field: ‘local’
[17:43:51.066]   - Field: ‘owner’
[17:43:51.066]   - Field: ‘envir’
[17:43:51.066]   - Field: ‘workers’
[17:43:51.066]   - Field: ‘packages’
[17:43:51.066]   - Field: ‘gc’
[17:43:51.066]   - Field: ‘conditions’
[17:43:51.066]   - Field: ‘persistent’
[17:43:51.067]   - Field: ‘expr’
[17:43:51.067]   - Field: ‘uuid’
[17:43:51.067]   - Field: ‘seed’
[17:43:51.067]   - Field: ‘version’
[17:43:51.067]   - Field: ‘result’
[17:43:51.067]   - Field: ‘asynchronous’
[17:43:51.067]   - Field: ‘calls’
[17:43:51.067]   - Field: ‘globals’
[17:43:51.067]   - Field: ‘stdout’
[17:43:51.067]   - Field: ‘earlySignal’
[17:43:51.067]   - Field: ‘lazy’
[17:43:51.068]   - Field: ‘state’
[17:43:51.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:51.068] - Launch lazy future ...
[17:43:51.068] Packages needed by the future expression (n = 0): <none>
[17:43:51.068] Packages needed by future strategies (n = 0): <none>
[17:43:51.069] {
[17:43:51.069]     {
[17:43:51.069]         {
[17:43:51.069]             ...future.startTime <- base::Sys.time()
[17:43:51.069]             {
[17:43:51.069]                 {
[17:43:51.069]                   {
[17:43:51.069]                     {
[17:43:51.069]                       base::local({
[17:43:51.069]                         has_future <- base::requireNamespace("future", 
[17:43:51.069]                           quietly = TRUE)
[17:43:51.069]                         if (has_future) {
[17:43:51.069]                           ns <- base::getNamespace("future")
[17:43:51.069]                           version <- ns[[".package"]][["version"]]
[17:43:51.069]                           if (is.null(version)) 
[17:43:51.069]                             version <- utils::packageVersion("future")
[17:43:51.069]                         }
[17:43:51.069]                         else {
[17:43:51.069]                           version <- NULL
[17:43:51.069]                         }
[17:43:51.069]                         if (!has_future || version < "1.8.0") {
[17:43:51.069]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:51.069]                             "", base::R.version$version.string), 
[17:43:51.069]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:51.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:51.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:51.069]                               "release", "version")], collapse = " "), 
[17:43:51.069]                             hostname = base::Sys.info()[["nodename"]])
[17:43:51.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:51.069]                             info)
[17:43:51.069]                           info <- base::paste(info, collapse = "; ")
[17:43:51.069]                           if (!has_future) {
[17:43:51.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:51.069]                               info)
[17:43:51.069]                           }
[17:43:51.069]                           else {
[17:43:51.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:51.069]                               info, version)
[17:43:51.069]                           }
[17:43:51.069]                           base::stop(msg)
[17:43:51.069]                         }
[17:43:51.069]                       })
[17:43:51.069]                     }
[17:43:51.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:51.069]                     base::options(mc.cores = 1L)
[17:43:51.069]                   }
[17:43:51.069]                   ...future.strategy.old <- future::plan("list")
[17:43:51.069]                   options(future.plan = NULL)
[17:43:51.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:51.069]                 }
[17:43:51.069]                 ...future.workdir <- getwd()
[17:43:51.069]             }
[17:43:51.069]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:51.069]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:51.069]         }
[17:43:51.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:51.069]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:51.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:51.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:51.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:51.069]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:51.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:51.069]             base::names(...future.oldOptions))
[17:43:51.069]     }
[17:43:51.069]     if (FALSE) {
[17:43:51.069]     }
[17:43:51.069]     else {
[17:43:51.069]         if (TRUE) {
[17:43:51.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:51.069]                 open = "w")
[17:43:51.069]         }
[17:43:51.069]         else {
[17:43:51.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:51.069]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:51.069]         }
[17:43:51.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:51.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:51.069]             base::sink(type = "output", split = FALSE)
[17:43:51.069]             base::close(...future.stdout)
[17:43:51.069]         }, add = TRUE)
[17:43:51.069]     }
[17:43:51.069]     ...future.frame <- base::sys.nframe()
[17:43:51.069]     ...future.conditions <- base::list()
[17:43:51.069]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:51.069]     if (FALSE) {
[17:43:51.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:51.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:51.069]     }
[17:43:51.069]     ...future.result <- base::tryCatch({
[17:43:51.069]         base::withCallingHandlers({
[17:43:51.069]             ...future.value <- base::withVisible(base::local({
[17:43:51.069]                 ...future.makeSendCondition <- base::local({
[17:43:51.069]                   sendCondition <- NULL
[17:43:51.069]                   function(frame = 1L) {
[17:43:51.069]                     if (is.function(sendCondition)) 
[17:43:51.069]                       return(sendCondition)
[17:43:51.069]                     ns <- getNamespace("parallel")
[17:43:51.069]                     if (exists("sendData", mode = "function", 
[17:43:51.069]                       envir = ns)) {
[17:43:51.069]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:51.069]                         envir = ns)
[17:43:51.069]                       envir <- sys.frame(frame)
[17:43:51.069]                       master <- NULL
[17:43:51.069]                       while (!identical(envir, .GlobalEnv) && 
[17:43:51.069]                         !identical(envir, emptyenv())) {
[17:43:51.069]                         if (exists("master", mode = "list", envir = envir, 
[17:43:51.069]                           inherits = FALSE)) {
[17:43:51.069]                           master <- get("master", mode = "list", 
[17:43:51.069]                             envir = envir, inherits = FALSE)
[17:43:51.069]                           if (inherits(master, c("SOCKnode", 
[17:43:51.069]                             "SOCK0node"))) {
[17:43:51.069]                             sendCondition <<- function(cond) {
[17:43:51.069]                               data <- list(type = "VALUE", value = cond, 
[17:43:51.069]                                 success = TRUE)
[17:43:51.069]                               parallel_sendData(master, data)
[17:43:51.069]                             }
[17:43:51.069]                             return(sendCondition)
[17:43:51.069]                           }
[17:43:51.069]                         }
[17:43:51.069]                         frame <- frame + 1L
[17:43:51.069]                         envir <- sys.frame(frame)
[17:43:51.069]                       }
[17:43:51.069]                     }
[17:43:51.069]                     sendCondition <<- function(cond) NULL
[17:43:51.069]                   }
[17:43:51.069]                 })
[17:43:51.069]                 withCallingHandlers({
[17:43:51.069]                   {
[17:43:51.069]                     do.call(function(...) {
[17:43:51.069]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.069]                       if (!identical(...future.globals.maxSize.org, 
[17:43:51.069]                         ...future.globals.maxSize)) {
[17:43:51.069]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.069]                         on.exit(options(oopts), add = TRUE)
[17:43:51.069]                       }
[17:43:51.069]                       {
[17:43:51.069]                         lapply(seq_along(...future.elements_ii), 
[17:43:51.069]                           FUN = function(jj) {
[17:43:51.069]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.069]                             ...future.FUN(...future.X_jj, ...)
[17:43:51.069]                           })
[17:43:51.069]                       }
[17:43:51.069]                     }, args = future.call.arguments)
[17:43:51.069]                   }
[17:43:51.069]                 }, immediateCondition = function(cond) {
[17:43:51.069]                   sendCondition <- ...future.makeSendCondition()
[17:43:51.069]                   sendCondition(cond)
[17:43:51.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.069]                   {
[17:43:51.069]                     inherits <- base::inherits
[17:43:51.069]                     invokeRestart <- base::invokeRestart
[17:43:51.069]                     is.null <- base::is.null
[17:43:51.069]                     muffled <- FALSE
[17:43:51.069]                     if (inherits(cond, "message")) {
[17:43:51.069]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:51.069]                       if (muffled) 
[17:43:51.069]                         invokeRestart("muffleMessage")
[17:43:51.069]                     }
[17:43:51.069]                     else if (inherits(cond, "warning")) {
[17:43:51.069]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:51.069]                       if (muffled) 
[17:43:51.069]                         invokeRestart("muffleWarning")
[17:43:51.069]                     }
[17:43:51.069]                     else if (inherits(cond, "condition")) {
[17:43:51.069]                       if (!is.null(pattern)) {
[17:43:51.069]                         computeRestarts <- base::computeRestarts
[17:43:51.069]                         grepl <- base::grepl
[17:43:51.069]                         restarts <- computeRestarts(cond)
[17:43:51.069]                         for (restart in restarts) {
[17:43:51.069]                           name <- restart$name
[17:43:51.069]                           if (is.null(name)) 
[17:43:51.069]                             next
[17:43:51.069]                           if (!grepl(pattern, name)) 
[17:43:51.069]                             next
[17:43:51.069]                           invokeRestart(restart)
[17:43:51.069]                           muffled <- TRUE
[17:43:51.069]                           break
[17:43:51.069]                         }
[17:43:51.069]                       }
[17:43:51.069]                     }
[17:43:51.069]                     invisible(muffled)
[17:43:51.069]                   }
[17:43:51.069]                   muffleCondition(cond)
[17:43:51.069]                 })
[17:43:51.069]             }))
[17:43:51.069]             future::FutureResult(value = ...future.value$value, 
[17:43:51.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.069]                   ...future.rng), globalenv = if (FALSE) 
[17:43:51.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:51.069]                     ...future.globalenv.names))
[17:43:51.069]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:51.069]         }, condition = base::local({
[17:43:51.069]             c <- base::c
[17:43:51.069]             inherits <- base::inherits
[17:43:51.069]             invokeRestart <- base::invokeRestart
[17:43:51.069]             length <- base::length
[17:43:51.069]             list <- base::list
[17:43:51.069]             seq.int <- base::seq.int
[17:43:51.069]             signalCondition <- base::signalCondition
[17:43:51.069]             sys.calls <- base::sys.calls
[17:43:51.069]             `[[` <- base::`[[`
[17:43:51.069]             `+` <- base::`+`
[17:43:51.069]             `<<-` <- base::`<<-`
[17:43:51.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:51.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:51.069]                   3L)]
[17:43:51.069]             }
[17:43:51.069]             function(cond) {
[17:43:51.069]                 is_error <- inherits(cond, "error")
[17:43:51.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:51.069]                   NULL)
[17:43:51.069]                 if (is_error) {
[17:43:51.069]                   sessionInformation <- function() {
[17:43:51.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:51.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:51.069]                       search = base::search(), system = base::Sys.info())
[17:43:51.069]                   }
[17:43:51.069]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:51.069]                     cond$call), session = sessionInformation(), 
[17:43:51.069]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:51.069]                   signalCondition(cond)
[17:43:51.069]                 }
[17:43:51.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:51.069]                 "immediateCondition"))) {
[17:43:51.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:51.069]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:51.069]                   if (TRUE && !signal) {
[17:43:51.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.069]                     {
[17:43:51.069]                       inherits <- base::inherits
[17:43:51.069]                       invokeRestart <- base::invokeRestart
[17:43:51.069]                       is.null <- base::is.null
[17:43:51.069]                       muffled <- FALSE
[17:43:51.069]                       if (inherits(cond, "message")) {
[17:43:51.069]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.069]                         if (muffled) 
[17:43:51.069]                           invokeRestart("muffleMessage")
[17:43:51.069]                       }
[17:43:51.069]                       else if (inherits(cond, "warning")) {
[17:43:51.069]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.069]                         if (muffled) 
[17:43:51.069]                           invokeRestart("muffleWarning")
[17:43:51.069]                       }
[17:43:51.069]                       else if (inherits(cond, "condition")) {
[17:43:51.069]                         if (!is.null(pattern)) {
[17:43:51.069]                           computeRestarts <- base::computeRestarts
[17:43:51.069]                           grepl <- base::grepl
[17:43:51.069]                           restarts <- computeRestarts(cond)
[17:43:51.069]                           for (restart in restarts) {
[17:43:51.069]                             name <- restart$name
[17:43:51.069]                             if (is.null(name)) 
[17:43:51.069]                               next
[17:43:51.069]                             if (!grepl(pattern, name)) 
[17:43:51.069]                               next
[17:43:51.069]                             invokeRestart(restart)
[17:43:51.069]                             muffled <- TRUE
[17:43:51.069]                             break
[17:43:51.069]                           }
[17:43:51.069]                         }
[17:43:51.069]                       }
[17:43:51.069]                       invisible(muffled)
[17:43:51.069]                     }
[17:43:51.069]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.069]                   }
[17:43:51.069]                 }
[17:43:51.069]                 else {
[17:43:51.069]                   if (TRUE) {
[17:43:51.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.069]                     {
[17:43:51.069]                       inherits <- base::inherits
[17:43:51.069]                       invokeRestart <- base::invokeRestart
[17:43:51.069]                       is.null <- base::is.null
[17:43:51.069]                       muffled <- FALSE
[17:43:51.069]                       if (inherits(cond, "message")) {
[17:43:51.069]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.069]                         if (muffled) 
[17:43:51.069]                           invokeRestart("muffleMessage")
[17:43:51.069]                       }
[17:43:51.069]                       else if (inherits(cond, "warning")) {
[17:43:51.069]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.069]                         if (muffled) 
[17:43:51.069]                           invokeRestart("muffleWarning")
[17:43:51.069]                       }
[17:43:51.069]                       else if (inherits(cond, "condition")) {
[17:43:51.069]                         if (!is.null(pattern)) {
[17:43:51.069]                           computeRestarts <- base::computeRestarts
[17:43:51.069]                           grepl <- base::grepl
[17:43:51.069]                           restarts <- computeRestarts(cond)
[17:43:51.069]                           for (restart in restarts) {
[17:43:51.069]                             name <- restart$name
[17:43:51.069]                             if (is.null(name)) 
[17:43:51.069]                               next
[17:43:51.069]                             if (!grepl(pattern, name)) 
[17:43:51.069]                               next
[17:43:51.069]                             invokeRestart(restart)
[17:43:51.069]                             muffled <- TRUE
[17:43:51.069]                             break
[17:43:51.069]                           }
[17:43:51.069]                         }
[17:43:51.069]                       }
[17:43:51.069]                       invisible(muffled)
[17:43:51.069]                     }
[17:43:51.069]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.069]                   }
[17:43:51.069]                 }
[17:43:51.069]             }
[17:43:51.069]         }))
[17:43:51.069]     }, error = function(ex) {
[17:43:51.069]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:51.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.069]                 ...future.rng), started = ...future.startTime, 
[17:43:51.069]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:51.069]             version = "1.8"), class = "FutureResult")
[17:43:51.069]     }, finally = {
[17:43:51.069]         if (!identical(...future.workdir, getwd())) 
[17:43:51.069]             setwd(...future.workdir)
[17:43:51.069]         {
[17:43:51.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:51.069]                 ...future.oldOptions$nwarnings <- NULL
[17:43:51.069]             }
[17:43:51.069]             base::options(...future.oldOptions)
[17:43:51.069]             if (.Platform$OS.type == "windows") {
[17:43:51.069]                 old_names <- names(...future.oldEnvVars)
[17:43:51.069]                 envs <- base::Sys.getenv()
[17:43:51.069]                 names <- names(envs)
[17:43:51.069]                 common <- intersect(names, old_names)
[17:43:51.069]                 added <- setdiff(names, old_names)
[17:43:51.069]                 removed <- setdiff(old_names, names)
[17:43:51.069]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:51.069]                   envs[common]]
[17:43:51.069]                 NAMES <- toupper(changed)
[17:43:51.069]                 args <- list()
[17:43:51.069]                 for (kk in seq_along(NAMES)) {
[17:43:51.069]                   name <- changed[[kk]]
[17:43:51.069]                   NAME <- NAMES[[kk]]
[17:43:51.069]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.069]                     next
[17:43:51.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.069]                 }
[17:43:51.069]                 NAMES <- toupper(added)
[17:43:51.069]                 for (kk in seq_along(NAMES)) {
[17:43:51.069]                   name <- added[[kk]]
[17:43:51.069]                   NAME <- NAMES[[kk]]
[17:43:51.069]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.069]                     next
[17:43:51.069]                   args[[name]] <- ""
[17:43:51.069]                 }
[17:43:51.069]                 NAMES <- toupper(removed)
[17:43:51.069]                 for (kk in seq_along(NAMES)) {
[17:43:51.069]                   name <- removed[[kk]]
[17:43:51.069]                   NAME <- NAMES[[kk]]
[17:43:51.069]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.069]                     next
[17:43:51.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.069]                 }
[17:43:51.069]                 if (length(args) > 0) 
[17:43:51.069]                   base::do.call(base::Sys.setenv, args = args)
[17:43:51.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:51.069]             }
[17:43:51.069]             else {
[17:43:51.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:51.069]             }
[17:43:51.069]             {
[17:43:51.069]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:51.069]                   0L) {
[17:43:51.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:51.069]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:51.069]                   base::options(opts)
[17:43:51.069]                 }
[17:43:51.069]                 {
[17:43:51.069]                   {
[17:43:51.069]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:51.069]                     NULL
[17:43:51.069]                   }
[17:43:51.069]                   options(future.plan = NULL)
[17:43:51.069]                   if (is.na(NA_character_)) 
[17:43:51.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:51.069]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:51.069]                     .init = FALSE)
[17:43:51.069]                 }
[17:43:51.069]             }
[17:43:51.069]         }
[17:43:51.069]     })
[17:43:51.069]     if (TRUE) {
[17:43:51.069]         base::sink(type = "output", split = FALSE)
[17:43:51.069]         if (TRUE) {
[17:43:51.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:51.069]         }
[17:43:51.069]         else {
[17:43:51.069]             ...future.result["stdout"] <- base::list(NULL)
[17:43:51.069]         }
[17:43:51.069]         base::close(...future.stdout)
[17:43:51.069]         ...future.stdout <- NULL
[17:43:51.069]     }
[17:43:51.069]     ...future.result$conditions <- ...future.conditions
[17:43:51.069]     ...future.result$finished <- base::Sys.time()
[17:43:51.069]     ...future.result
[17:43:51.069] }
[17:43:51.072] Exporting 5 global objects (1.12 KiB) to cluster node #1 ...
[17:43:51.072] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:51.072] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:51.072] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:43:51.072] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:43:51.073] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ...
[17:43:51.073] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ... DONE
[17:43:51.073] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:51.073] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:51.073] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:43:51.074] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:43:51.074] Exporting 5 global objects (1.12 KiB) to cluster node #1 ... DONE
[17:43:51.074] MultisessionFuture started
[17:43:51.074] - Launch lazy future ... done
[17:43:51.074] run() for ‘MultisessionFuture’ ... done
[17:43:51.075] Created future:
[17:43:51.075] MultisessionFuture:
[17:43:51.075] Label: ‘future_apply-1’
[17:43:51.075] Expression:
[17:43:51.075] {
[17:43:51.075]     do.call(function(...) {
[17:43:51.075]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.075]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.075]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.075]             on.exit(options(oopts), add = TRUE)
[17:43:51.075]         }
[17:43:51.075]         {
[17:43:51.075]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.075]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.075]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.075]             })
[17:43:51.075]         }
[17:43:51.075]     }, args = future.call.arguments)
[17:43:51.075] }
[17:43:51.075] Lazy evaluation: FALSE
[17:43:51.075] Asynchronous evaluation: TRUE
[17:43:51.075] Local evaluation: TRUE
[17:43:51.075] Environment: R_GlobalEnv
[17:43:51.075] Capture standard output: TRUE
[17:43:51.075] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:51.075] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:51.075] Packages: <none>
[17:43:51.075] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:51.075] Resolved: FALSE
[17:43:51.075] Value: <not collected>
[17:43:51.075] Conditions captured: <none>
[17:43:51.075] Early signaling: FALSE
[17:43:51.075] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:51.075] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:51.086] Chunk #1 of 2 ... DONE
[17:43:51.086] Chunk #2 of 2 ...
[17:43:51.087]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:51.087]  - seeds: <none>
[17:43:51.087]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.087] getGlobalsAndPackages() ...
[17:43:51.087] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.087] Resolving globals: FALSE
[17:43:51.087] Tweak future expression to call with '...' arguments ...
[17:43:51.087] {
[17:43:51.087]     do.call(function(...) {
[17:43:51.087]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.087]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.087]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.087]             on.exit(options(oopts), add = TRUE)
[17:43:51.087]         }
[17:43:51.087]         {
[17:43:51.087]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.087]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.087]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.087]             })
[17:43:51.087]         }
[17:43:51.087]     }, args = future.call.arguments)
[17:43:51.087] }
[17:43:51.088] Tweak future expression to call with '...' arguments ... DONE
[17:43:51.088] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.088] 
[17:43:51.088] getGlobalsAndPackages() ... DONE
[17:43:51.088] run() for ‘Future’ ...
[17:43:51.089] - state: ‘created’
[17:43:51.089] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:51.103] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:51.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:51.103]   - Field: ‘node’
[17:43:51.103]   - Field: ‘label’
[17:43:51.104]   - Field: ‘local’
[17:43:51.104]   - Field: ‘owner’
[17:43:51.104]   - Field: ‘envir’
[17:43:51.104]   - Field: ‘workers’
[17:43:51.104]   - Field: ‘packages’
[17:43:51.104]   - Field: ‘gc’
[17:43:51.104]   - Field: ‘conditions’
[17:43:51.104]   - Field: ‘persistent’
[17:43:51.104]   - Field: ‘expr’
[17:43:51.104]   - Field: ‘uuid’
[17:43:51.104]   - Field: ‘seed’
[17:43:51.105]   - Field: ‘version’
[17:43:51.105]   - Field: ‘result’
[17:43:51.105]   - Field: ‘asynchronous’
[17:43:51.105]   - Field: ‘calls’
[17:43:51.105]   - Field: ‘globals’
[17:43:51.105]   - Field: ‘stdout’
[17:43:51.105]   - Field: ‘earlySignal’
[17:43:51.105]   - Field: ‘lazy’
[17:43:51.105]   - Field: ‘state’
[17:43:51.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:51.105] - Launch lazy future ...
[17:43:51.106] Packages needed by the future expression (n = 0): <none>
[17:43:51.106] Packages needed by future strategies (n = 0): <none>
[17:43:51.106] {
[17:43:51.106]     {
[17:43:51.106]         {
[17:43:51.106]             ...future.startTime <- base::Sys.time()
[17:43:51.106]             {
[17:43:51.106]                 {
[17:43:51.106]                   {
[17:43:51.106]                     {
[17:43:51.106]                       base::local({
[17:43:51.106]                         has_future <- base::requireNamespace("future", 
[17:43:51.106]                           quietly = TRUE)
[17:43:51.106]                         if (has_future) {
[17:43:51.106]                           ns <- base::getNamespace("future")
[17:43:51.106]                           version <- ns[[".package"]][["version"]]
[17:43:51.106]                           if (is.null(version)) 
[17:43:51.106]                             version <- utils::packageVersion("future")
[17:43:51.106]                         }
[17:43:51.106]                         else {
[17:43:51.106]                           version <- NULL
[17:43:51.106]                         }
[17:43:51.106]                         if (!has_future || version < "1.8.0") {
[17:43:51.106]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:51.106]                             "", base::R.version$version.string), 
[17:43:51.106]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:51.106]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:51.106]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:51.106]                               "release", "version")], collapse = " "), 
[17:43:51.106]                             hostname = base::Sys.info()[["nodename"]])
[17:43:51.106]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:51.106]                             info)
[17:43:51.106]                           info <- base::paste(info, collapse = "; ")
[17:43:51.106]                           if (!has_future) {
[17:43:51.106]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:51.106]                               info)
[17:43:51.106]                           }
[17:43:51.106]                           else {
[17:43:51.106]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:51.106]                               info, version)
[17:43:51.106]                           }
[17:43:51.106]                           base::stop(msg)
[17:43:51.106]                         }
[17:43:51.106]                       })
[17:43:51.106]                     }
[17:43:51.106]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:51.106]                     base::options(mc.cores = 1L)
[17:43:51.106]                   }
[17:43:51.106]                   ...future.strategy.old <- future::plan("list")
[17:43:51.106]                   options(future.plan = NULL)
[17:43:51.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:51.106]                 }
[17:43:51.106]                 ...future.workdir <- getwd()
[17:43:51.106]             }
[17:43:51.106]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:51.106]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:51.106]         }
[17:43:51.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:51.106]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:51.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:51.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:51.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:51.106]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:51.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:51.106]             base::names(...future.oldOptions))
[17:43:51.106]     }
[17:43:51.106]     if (FALSE) {
[17:43:51.106]     }
[17:43:51.106]     else {
[17:43:51.106]         if (TRUE) {
[17:43:51.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:51.106]                 open = "w")
[17:43:51.106]         }
[17:43:51.106]         else {
[17:43:51.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:51.106]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:51.106]         }
[17:43:51.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:51.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:51.106]             base::sink(type = "output", split = FALSE)
[17:43:51.106]             base::close(...future.stdout)
[17:43:51.106]         }, add = TRUE)
[17:43:51.106]     }
[17:43:51.106]     ...future.frame <- base::sys.nframe()
[17:43:51.106]     ...future.conditions <- base::list()
[17:43:51.106]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:51.106]     if (FALSE) {
[17:43:51.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:51.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:51.106]     }
[17:43:51.106]     ...future.result <- base::tryCatch({
[17:43:51.106]         base::withCallingHandlers({
[17:43:51.106]             ...future.value <- base::withVisible(base::local({
[17:43:51.106]                 ...future.makeSendCondition <- base::local({
[17:43:51.106]                   sendCondition <- NULL
[17:43:51.106]                   function(frame = 1L) {
[17:43:51.106]                     if (is.function(sendCondition)) 
[17:43:51.106]                       return(sendCondition)
[17:43:51.106]                     ns <- getNamespace("parallel")
[17:43:51.106]                     if (exists("sendData", mode = "function", 
[17:43:51.106]                       envir = ns)) {
[17:43:51.106]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:51.106]                         envir = ns)
[17:43:51.106]                       envir <- sys.frame(frame)
[17:43:51.106]                       master <- NULL
[17:43:51.106]                       while (!identical(envir, .GlobalEnv) && 
[17:43:51.106]                         !identical(envir, emptyenv())) {
[17:43:51.106]                         if (exists("master", mode = "list", envir = envir, 
[17:43:51.106]                           inherits = FALSE)) {
[17:43:51.106]                           master <- get("master", mode = "list", 
[17:43:51.106]                             envir = envir, inherits = FALSE)
[17:43:51.106]                           if (inherits(master, c("SOCKnode", 
[17:43:51.106]                             "SOCK0node"))) {
[17:43:51.106]                             sendCondition <<- function(cond) {
[17:43:51.106]                               data <- list(type = "VALUE", value = cond, 
[17:43:51.106]                                 success = TRUE)
[17:43:51.106]                               parallel_sendData(master, data)
[17:43:51.106]                             }
[17:43:51.106]                             return(sendCondition)
[17:43:51.106]                           }
[17:43:51.106]                         }
[17:43:51.106]                         frame <- frame + 1L
[17:43:51.106]                         envir <- sys.frame(frame)
[17:43:51.106]                       }
[17:43:51.106]                     }
[17:43:51.106]                     sendCondition <<- function(cond) NULL
[17:43:51.106]                   }
[17:43:51.106]                 })
[17:43:51.106]                 withCallingHandlers({
[17:43:51.106]                   {
[17:43:51.106]                     do.call(function(...) {
[17:43:51.106]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.106]                       if (!identical(...future.globals.maxSize.org, 
[17:43:51.106]                         ...future.globals.maxSize)) {
[17:43:51.106]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.106]                         on.exit(options(oopts), add = TRUE)
[17:43:51.106]                       }
[17:43:51.106]                       {
[17:43:51.106]                         lapply(seq_along(...future.elements_ii), 
[17:43:51.106]                           FUN = function(jj) {
[17:43:51.106]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.106]                             ...future.FUN(...future.X_jj, ...)
[17:43:51.106]                           })
[17:43:51.106]                       }
[17:43:51.106]                     }, args = future.call.arguments)
[17:43:51.106]                   }
[17:43:51.106]                 }, immediateCondition = function(cond) {
[17:43:51.106]                   sendCondition <- ...future.makeSendCondition()
[17:43:51.106]                   sendCondition(cond)
[17:43:51.106]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.106]                   {
[17:43:51.106]                     inherits <- base::inherits
[17:43:51.106]                     invokeRestart <- base::invokeRestart
[17:43:51.106]                     is.null <- base::is.null
[17:43:51.106]                     muffled <- FALSE
[17:43:51.106]                     if (inherits(cond, "message")) {
[17:43:51.106]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:51.106]                       if (muffled) 
[17:43:51.106]                         invokeRestart("muffleMessage")
[17:43:51.106]                     }
[17:43:51.106]                     else if (inherits(cond, "warning")) {
[17:43:51.106]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:51.106]                       if (muffled) 
[17:43:51.106]                         invokeRestart("muffleWarning")
[17:43:51.106]                     }
[17:43:51.106]                     else if (inherits(cond, "condition")) {
[17:43:51.106]                       if (!is.null(pattern)) {
[17:43:51.106]                         computeRestarts <- base::computeRestarts
[17:43:51.106]                         grepl <- base::grepl
[17:43:51.106]                         restarts <- computeRestarts(cond)
[17:43:51.106]                         for (restart in restarts) {
[17:43:51.106]                           name <- restart$name
[17:43:51.106]                           if (is.null(name)) 
[17:43:51.106]                             next
[17:43:51.106]                           if (!grepl(pattern, name)) 
[17:43:51.106]                             next
[17:43:51.106]                           invokeRestart(restart)
[17:43:51.106]                           muffled <- TRUE
[17:43:51.106]                           break
[17:43:51.106]                         }
[17:43:51.106]                       }
[17:43:51.106]                     }
[17:43:51.106]                     invisible(muffled)
[17:43:51.106]                   }
[17:43:51.106]                   muffleCondition(cond)
[17:43:51.106]                 })
[17:43:51.106]             }))
[17:43:51.106]             future::FutureResult(value = ...future.value$value, 
[17:43:51.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.106]                   ...future.rng), globalenv = if (FALSE) 
[17:43:51.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:51.106]                     ...future.globalenv.names))
[17:43:51.106]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:51.106]         }, condition = base::local({
[17:43:51.106]             c <- base::c
[17:43:51.106]             inherits <- base::inherits
[17:43:51.106]             invokeRestart <- base::invokeRestart
[17:43:51.106]             length <- base::length
[17:43:51.106]             list <- base::list
[17:43:51.106]             seq.int <- base::seq.int
[17:43:51.106]             signalCondition <- base::signalCondition
[17:43:51.106]             sys.calls <- base::sys.calls
[17:43:51.106]             `[[` <- base::`[[`
[17:43:51.106]             `+` <- base::`+`
[17:43:51.106]             `<<-` <- base::`<<-`
[17:43:51.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:51.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:51.106]                   3L)]
[17:43:51.106]             }
[17:43:51.106]             function(cond) {
[17:43:51.106]                 is_error <- inherits(cond, "error")
[17:43:51.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:51.106]                   NULL)
[17:43:51.106]                 if (is_error) {
[17:43:51.106]                   sessionInformation <- function() {
[17:43:51.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:51.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:51.106]                       search = base::search(), system = base::Sys.info())
[17:43:51.106]                   }
[17:43:51.106]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:51.106]                     cond$call), session = sessionInformation(), 
[17:43:51.106]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:51.106]                   signalCondition(cond)
[17:43:51.106]                 }
[17:43:51.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:51.106]                 "immediateCondition"))) {
[17:43:51.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:51.106]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:51.106]                   if (TRUE && !signal) {
[17:43:51.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.106]                     {
[17:43:51.106]                       inherits <- base::inherits
[17:43:51.106]                       invokeRestart <- base::invokeRestart
[17:43:51.106]                       is.null <- base::is.null
[17:43:51.106]                       muffled <- FALSE
[17:43:51.106]                       if (inherits(cond, "message")) {
[17:43:51.106]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.106]                         if (muffled) 
[17:43:51.106]                           invokeRestart("muffleMessage")
[17:43:51.106]                       }
[17:43:51.106]                       else if (inherits(cond, "warning")) {
[17:43:51.106]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.106]                         if (muffled) 
[17:43:51.106]                           invokeRestart("muffleWarning")
[17:43:51.106]                       }
[17:43:51.106]                       else if (inherits(cond, "condition")) {
[17:43:51.106]                         if (!is.null(pattern)) {
[17:43:51.106]                           computeRestarts <- base::computeRestarts
[17:43:51.106]                           grepl <- base::grepl
[17:43:51.106]                           restarts <- computeRestarts(cond)
[17:43:51.106]                           for (restart in restarts) {
[17:43:51.106]                             name <- restart$name
[17:43:51.106]                             if (is.null(name)) 
[17:43:51.106]                               next
[17:43:51.106]                             if (!grepl(pattern, name)) 
[17:43:51.106]                               next
[17:43:51.106]                             invokeRestart(restart)
[17:43:51.106]                             muffled <- TRUE
[17:43:51.106]                             break
[17:43:51.106]                           }
[17:43:51.106]                         }
[17:43:51.106]                       }
[17:43:51.106]                       invisible(muffled)
[17:43:51.106]                     }
[17:43:51.106]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.106]                   }
[17:43:51.106]                 }
[17:43:51.106]                 else {
[17:43:51.106]                   if (TRUE) {
[17:43:51.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.106]                     {
[17:43:51.106]                       inherits <- base::inherits
[17:43:51.106]                       invokeRestart <- base::invokeRestart
[17:43:51.106]                       is.null <- base::is.null
[17:43:51.106]                       muffled <- FALSE
[17:43:51.106]                       if (inherits(cond, "message")) {
[17:43:51.106]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.106]                         if (muffled) 
[17:43:51.106]                           invokeRestart("muffleMessage")
[17:43:51.106]                       }
[17:43:51.106]                       else if (inherits(cond, "warning")) {
[17:43:51.106]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.106]                         if (muffled) 
[17:43:51.106]                           invokeRestart("muffleWarning")
[17:43:51.106]                       }
[17:43:51.106]                       else if (inherits(cond, "condition")) {
[17:43:51.106]                         if (!is.null(pattern)) {
[17:43:51.106]                           computeRestarts <- base::computeRestarts
[17:43:51.106]                           grepl <- base::grepl
[17:43:51.106]                           restarts <- computeRestarts(cond)
[17:43:51.106]                           for (restart in restarts) {
[17:43:51.106]                             name <- restart$name
[17:43:51.106]                             if (is.null(name)) 
[17:43:51.106]                               next
[17:43:51.106]                             if (!grepl(pattern, name)) 
[17:43:51.106]                               next
[17:43:51.106]                             invokeRestart(restart)
[17:43:51.106]                             muffled <- TRUE
[17:43:51.106]                             break
[17:43:51.106]                           }
[17:43:51.106]                         }
[17:43:51.106]                       }
[17:43:51.106]                       invisible(muffled)
[17:43:51.106]                     }
[17:43:51.106]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.106]                   }
[17:43:51.106]                 }
[17:43:51.106]             }
[17:43:51.106]         }))
[17:43:51.106]     }, error = function(ex) {
[17:43:51.106]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:51.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.106]                 ...future.rng), started = ...future.startTime, 
[17:43:51.106]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:51.106]             version = "1.8"), class = "FutureResult")
[17:43:51.106]     }, finally = {
[17:43:51.106]         if (!identical(...future.workdir, getwd())) 
[17:43:51.106]             setwd(...future.workdir)
[17:43:51.106]         {
[17:43:51.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:51.106]                 ...future.oldOptions$nwarnings <- NULL
[17:43:51.106]             }
[17:43:51.106]             base::options(...future.oldOptions)
[17:43:51.106]             if (.Platform$OS.type == "windows") {
[17:43:51.106]                 old_names <- names(...future.oldEnvVars)
[17:43:51.106]                 envs <- base::Sys.getenv()
[17:43:51.106]                 names <- names(envs)
[17:43:51.106]                 common <- intersect(names, old_names)
[17:43:51.106]                 added <- setdiff(names, old_names)
[17:43:51.106]                 removed <- setdiff(old_names, names)
[17:43:51.106]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:51.106]                   envs[common]]
[17:43:51.106]                 NAMES <- toupper(changed)
[17:43:51.106]                 args <- list()
[17:43:51.106]                 for (kk in seq_along(NAMES)) {
[17:43:51.106]                   name <- changed[[kk]]
[17:43:51.106]                   NAME <- NAMES[[kk]]
[17:43:51.106]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.106]                     next
[17:43:51.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.106]                 }
[17:43:51.106]                 NAMES <- toupper(added)
[17:43:51.106]                 for (kk in seq_along(NAMES)) {
[17:43:51.106]                   name <- added[[kk]]
[17:43:51.106]                   NAME <- NAMES[[kk]]
[17:43:51.106]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.106]                     next
[17:43:51.106]                   args[[name]] <- ""
[17:43:51.106]                 }
[17:43:51.106]                 NAMES <- toupper(removed)
[17:43:51.106]                 for (kk in seq_along(NAMES)) {
[17:43:51.106]                   name <- removed[[kk]]
[17:43:51.106]                   NAME <- NAMES[[kk]]
[17:43:51.106]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.106]                     next
[17:43:51.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.106]                 }
[17:43:51.106]                 if (length(args) > 0) 
[17:43:51.106]                   base::do.call(base::Sys.setenv, args = args)
[17:43:51.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:51.106]             }
[17:43:51.106]             else {
[17:43:51.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:51.106]             }
[17:43:51.106]             {
[17:43:51.106]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:51.106]                   0L) {
[17:43:51.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:51.106]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:51.106]                   base::options(opts)
[17:43:51.106]                 }
[17:43:51.106]                 {
[17:43:51.106]                   {
[17:43:51.106]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:51.106]                     NULL
[17:43:51.106]                   }
[17:43:51.106]                   options(future.plan = NULL)
[17:43:51.106]                   if (is.na(NA_character_)) 
[17:43:51.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:51.106]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:51.106]                     .init = FALSE)
[17:43:51.106]                 }
[17:43:51.106]             }
[17:43:51.106]         }
[17:43:51.106]     })
[17:43:51.106]     if (TRUE) {
[17:43:51.106]         base::sink(type = "output", split = FALSE)
[17:43:51.106]         if (TRUE) {
[17:43:51.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:51.106]         }
[17:43:51.106]         else {
[17:43:51.106]             ...future.result["stdout"] <- base::list(NULL)
[17:43:51.106]         }
[17:43:51.106]         base::close(...future.stdout)
[17:43:51.106]         ...future.stdout <- NULL
[17:43:51.106]     }
[17:43:51.106]     ...future.result$conditions <- ...future.conditions
[17:43:51.106]     ...future.result$finished <- base::Sys.time()
[17:43:51.106]     ...future.result
[17:43:51.106] }
[17:43:51.109] Exporting 5 global objects (1.12 KiB) to cluster node #2 ...
[17:43:51.110] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:51.110] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:51.110] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:43:51.110] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:43:51.110] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ...
[17:43:51.111] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ... DONE
[17:43:51.111] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:51.111] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:51.111] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:43:51.112] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:43:51.112] Exporting 5 global objects (1.12 KiB) to cluster node #2 ... DONE
[17:43:51.112] MultisessionFuture started
[17:43:51.112] - Launch lazy future ... done
[17:43:51.112] run() for ‘MultisessionFuture’ ... done
[17:43:51.113] Created future:
[17:43:51.113] MultisessionFuture:
[17:43:51.113] Label: ‘future_apply-2’
[17:43:51.113] Expression:
[17:43:51.113] {
[17:43:51.113]     do.call(function(...) {
[17:43:51.113]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.113]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.113]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.113]             on.exit(options(oopts), add = TRUE)
[17:43:51.113]         }
[17:43:51.113]         {
[17:43:51.113]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.113]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.113]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.113]             })
[17:43:51.113]         }
[17:43:51.113]     }, args = future.call.arguments)
[17:43:51.113] }
[17:43:51.113] Lazy evaluation: FALSE
[17:43:51.113] Asynchronous evaluation: TRUE
[17:43:51.113] Local evaluation: TRUE
[17:43:51.113] Environment: R_GlobalEnv
[17:43:51.113] Capture standard output: TRUE
[17:43:51.113] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:51.113] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:51.113] Packages: <none>
[17:43:51.113] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:51.113] Resolved: FALSE
[17:43:51.113] Value: <not collected>
[17:43:51.113] Conditions captured: <none>
[17:43:51.113] Early signaling: FALSE
[17:43:51.113] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:51.113] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:51.124] Chunk #2 of 2 ... DONE
[17:43:51.124] Launching 2 futures (chunks) ... DONE
[17:43:51.124] Resolving 2 futures (chunks) ...
[17:43:51.124] resolve() on list ...
[17:43:51.125]  recursive: 0
[17:43:51.125]  length: 2
[17:43:51.125] 
[17:43:51.125] receiveMessageFromWorker() for ClusterFuture ...
[17:43:51.125] - Validating connection of MultisessionFuture
[17:43:51.126] - received message: FutureResult
[17:43:51.126] - Received FutureResult
[17:43:51.126] - Erased future from FutureRegistry
[17:43:51.126] result() for ClusterFuture ...
[17:43:51.126] - result already collected: FutureResult
[17:43:51.126] result() for ClusterFuture ... done
[17:43:51.126] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:51.126] Future #1
[17:43:51.126] result() for ClusterFuture ...
[17:43:51.126] - result already collected: FutureResult
[17:43:51.126] result() for ClusterFuture ... done
[17:43:51.127] result() for ClusterFuture ...
[17:43:51.127] - result already collected: FutureResult
[17:43:51.127] result() for ClusterFuture ... done
[17:43:51.127] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:51.127] - nx: 2
[17:43:51.127] - relay: TRUE
[17:43:51.127] - stdout: TRUE
[17:43:51.127] - signal: TRUE
[17:43:51.127] - resignal: FALSE
[17:43:51.127] - force: TRUE
[17:43:51.127] - relayed: [n=2] FALSE, FALSE
[17:43:51.128] - queued futures: [n=2] FALSE, FALSE
[17:43:51.128]  - until=1
[17:43:51.128]  - relaying element #1
[17:43:51.128] result() for ClusterFuture ...
[17:43:51.128] - result already collected: FutureResult
[17:43:51.128] result() for ClusterFuture ... done
[17:43:51.128] result() for ClusterFuture ...
[17:43:51.128] - result already collected: FutureResult
[17:43:51.128] result() for ClusterFuture ... done
[17:43:51.128] result() for ClusterFuture ...
[17:43:51.128] - result already collected: FutureResult
[17:43:51.129] result() for ClusterFuture ... done
[17:43:51.129] result() for ClusterFuture ...
[17:43:51.129] - result already collected: FutureResult
[17:43:51.129] result() for ClusterFuture ... done
[17:43:51.129] - relayed: [n=2] TRUE, FALSE
[17:43:51.129] - queued futures: [n=2] TRUE, FALSE
[17:43:51.129] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:51.129]  length: 1 (resolved future 1)
[17:43:51.157] receiveMessageFromWorker() for ClusterFuture ...
[17:43:51.157] - Validating connection of MultisessionFuture
[17:43:51.157] - received message: FutureResult
[17:43:51.157] - Received FutureResult
[17:43:51.158] - Erased future from FutureRegistry
[17:43:51.158] result() for ClusterFuture ...
[17:43:51.158] - result already collected: FutureResult
[17:43:51.158] result() for ClusterFuture ... done
[17:43:51.158] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:51.158] Future #2
[17:43:51.158] result() for ClusterFuture ...
[17:43:51.158] - result already collected: FutureResult
[17:43:51.158] result() for ClusterFuture ... done
[17:43:51.158] result() for ClusterFuture ...
[17:43:51.158] - result already collected: FutureResult
[17:43:51.158] result() for ClusterFuture ... done
[17:43:51.159] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:51.159] - nx: 2
[17:43:51.159] - relay: TRUE
[17:43:51.159] - stdout: TRUE
[17:43:51.159] - signal: TRUE
[17:43:51.159] - resignal: FALSE
[17:43:51.159] - force: TRUE
[17:43:51.159] - relayed: [n=2] TRUE, FALSE
[17:43:51.159] - queued futures: [n=2] TRUE, FALSE
[17:43:51.159]  - until=2
[17:43:51.159]  - relaying element #2
[17:43:51.160] result() for ClusterFuture ...
[17:43:51.160] - result already collected: FutureResult
[17:43:51.160] result() for ClusterFuture ... done
[17:43:51.160] result() for ClusterFuture ...
[17:43:51.160] - result already collected: FutureResult
[17:43:51.160] result() for ClusterFuture ... done
[17:43:51.160] result() for ClusterFuture ...
[17:43:51.160] - result already collected: FutureResult
[17:43:51.160] result() for ClusterFuture ... done
[17:43:51.160] result() for ClusterFuture ...
[17:43:51.160] - result already collected: FutureResult
[17:43:51.161] result() for ClusterFuture ... done
[17:43:51.161] - relayed: [n=2] TRUE, TRUE
[17:43:51.161] - queued futures: [n=2] TRUE, TRUE
[17:43:51.161] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:51.161]  length: 0 (resolved future 2)
[17:43:51.161] Relaying remaining futures
[17:43:51.161] signalConditionsASAP(NULL, pos=0) ...
[17:43:51.161] - nx: 2
[17:43:51.161] - relay: TRUE
[17:43:51.161] - stdout: TRUE
[17:43:51.161] - signal: TRUE
[17:43:51.161] - resignal: FALSE
[17:43:51.162] - force: TRUE
[17:43:51.162] - relayed: [n=2] TRUE, TRUE
[17:43:51.162] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:51.162] - relayed: [n=2] TRUE, TRUE
[17:43:51.162] - queued futures: [n=2] TRUE, TRUE
[17:43:51.162] signalConditionsASAP(NULL, pos=0) ... done
[17:43:51.162] resolve() on list ... DONE
[17:43:51.162] result() for ClusterFuture ...
[17:43:51.162] - result already collected: FutureResult
[17:43:51.162] result() for ClusterFuture ... done
[17:43:51.162] result() for ClusterFuture ...
[17:43:51.163] - result already collected: FutureResult
[17:43:51.163] result() for ClusterFuture ... done
[17:43:51.163] result() for ClusterFuture ...
[17:43:51.163] - result already collected: FutureResult
[17:43:51.163] result() for ClusterFuture ... done
[17:43:51.163] result() for ClusterFuture ...
[17:43:51.163] - result already collected: FutureResult
[17:43:51.163] result() for ClusterFuture ... done
[17:43:51.163]  - Number of value chunks collected: 2
[17:43:51.163] Resolving 2 futures (chunks) ... DONE
[17:43:51.163] Reducing values from 2 chunks ...
[17:43:51.164]  - Number of values collected after concatenation: 2
[17:43:51.164]  - Number of values expected: 2
[17:43:51.164] Reducing values from 2 chunks ... DONE
[17:43:51.164] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[17:43:51.164] getGlobalsAndPackagesXApply() ...
[17:43:51.164]  - future.globals: TRUE
[17:43:51.164] getGlobalsAndPackages() ...
[17:43:51.164] Searching for globals...
[17:43:51.167] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[17:43:51.167] Searching for globals ... DONE
[17:43:51.167] Resolving globals: FALSE
[17:43:51.168] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[17:43:51.168] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[17:43:51.168] - globals: [1] ‘FUN’
[17:43:51.168] 
[17:43:51.168] getGlobalsAndPackages() ... DONE
[17:43:51.168]  - globals found/used: [n=1] ‘FUN’
[17:43:51.168]  - needed namespaces: [n=0] 
[17:43:51.169] Finding globals ... DONE
[17:43:51.169]  - use_args: TRUE
[17:43:51.169]  - Getting '...' globals ...
[17:43:51.169] resolve() on list ...
[17:43:51.169]  recursive: 0
[17:43:51.169]  length: 1
[17:43:51.169]  elements: ‘...’
[17:43:51.169]  length: 0 (resolved future 1)
[17:43:51.170] resolve() on list ... DONE
[17:43:51.170]    - '...' content: [n=0] 
[17:43:51.170] List of 1
[17:43:51.170]  $ ...: list()
[17:43:51.170]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.170]  - attr(*, "where")=List of 1
[17:43:51.170]   ..$ ...:<environment: 0x55dfd6c33fd0> 
[17:43:51.170]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.170]  - attr(*, "resolved")= logi TRUE
[17:43:51.170]  - attr(*, "total_size")= num NA
[17:43:51.172]  - Getting '...' globals ... DONE
[17:43:51.172] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:51.172] List of 2
[17:43:51.172]  $ ...future.FUN:function (x)  
[17:43:51.172]  $ ...          : list()
[17:43:51.172]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.172]  - attr(*, "where")=List of 2
[17:43:51.172]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:51.172]   ..$ ...          :<environment: 0x55dfd6c33fd0> 
[17:43:51.172]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.172]  - attr(*, "resolved")= logi FALSE
[17:43:51.172]  - attr(*, "total_size")= num 9888
[17:43:51.175] Packages to be attached in all futures: [n=0] 
[17:43:51.175] getGlobalsAndPackagesXApply() ... DONE
[17:43:51.179] future_lapply() ...
[17:43:51.183] Number of chunks: 2
[17:43:51.183] getGlobalsAndPackagesXApply() ...
[17:43:51.183]  - future.globals: <name-value list> with names ‘list()’
[17:43:51.183]  - use_args: TRUE
[17:43:51.184] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:51.184] List of 2
[17:43:51.184]  $ ...          : list()
[17:43:51.184]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.184]  $ ...future.FUN:function (x)  
[17:43:51.184]  - attr(*, "where")=List of 2
[17:43:51.184]   ..$ ...          :<environment: 0x55dfd6c33fd0> 
[17:43:51.184]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[17:43:51.184]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.184]  - attr(*, "resolved")= logi FALSE
[17:43:51.184]  - attr(*, "total_size")= num NA
[17:43:51.186] Packages to be attached in all futures: [n=0] 
[17:43:51.186] getGlobalsAndPackagesXApply() ... DONE
[17:43:51.187] Number of futures (= number of chunks): 2
[17:43:51.187] Launching 2 futures (chunks) ...
[17:43:51.187] Chunk #1 of 2 ...
[17:43:51.187]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:51.187]  - seeds: <none>
[17:43:51.187]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.187] getGlobalsAndPackages() ...
[17:43:51.187] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.188] Resolving globals: FALSE
[17:43:51.188] Tweak future expression to call with '...' arguments ...
[17:43:51.188] {
[17:43:51.188]     do.call(function(...) {
[17:43:51.188]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.188]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.188]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.188]             on.exit(options(oopts), add = TRUE)
[17:43:51.188]         }
[17:43:51.188]         {
[17:43:51.188]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.188]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.188]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.188]             })
[17:43:51.188]         }
[17:43:51.188]     }, args = future.call.arguments)
[17:43:51.188] }
[17:43:51.188] Tweak future expression to call with '...' arguments ... DONE
[17:43:51.188] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.188] 
[17:43:51.189] getGlobalsAndPackages() ... DONE
[17:43:51.189] run() for ‘Future’ ...
[17:43:51.189] - state: ‘created’
[17:43:51.189] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:51.204] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:51.204] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:51.204]   - Field: ‘node’
[17:43:51.204]   - Field: ‘label’
[17:43:51.204]   - Field: ‘local’
[17:43:51.204]   - Field: ‘owner’
[17:43:51.204]   - Field: ‘envir’
[17:43:51.204]   - Field: ‘workers’
[17:43:51.204]   - Field: ‘packages’
[17:43:51.204]   - Field: ‘gc’
[17:43:51.205]   - Field: ‘conditions’
[17:43:51.205]   - Field: ‘persistent’
[17:43:51.205]   - Field: ‘expr’
[17:43:51.205]   - Field: ‘uuid’
[17:43:51.205]   - Field: ‘seed’
[17:43:51.205]   - Field: ‘version’
[17:43:51.205]   - Field: ‘result’
[17:43:51.205]   - Field: ‘asynchronous’
[17:43:51.205]   - Field: ‘calls’
[17:43:51.205]   - Field: ‘globals’
[17:43:51.205]   - Field: ‘stdout’
[17:43:51.206]   - Field: ‘earlySignal’
[17:43:51.206]   - Field: ‘lazy’
[17:43:51.206]   - Field: ‘state’
[17:43:51.206] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:51.206] - Launch lazy future ...
[17:43:51.206] Packages needed by the future expression (n = 0): <none>
[17:43:51.206] Packages needed by future strategies (n = 0): <none>
[17:43:51.207] {
[17:43:51.207]     {
[17:43:51.207]         {
[17:43:51.207]             ...future.startTime <- base::Sys.time()
[17:43:51.207]             {
[17:43:51.207]                 {
[17:43:51.207]                   {
[17:43:51.207]                     {
[17:43:51.207]                       base::local({
[17:43:51.207]                         has_future <- base::requireNamespace("future", 
[17:43:51.207]                           quietly = TRUE)
[17:43:51.207]                         if (has_future) {
[17:43:51.207]                           ns <- base::getNamespace("future")
[17:43:51.207]                           version <- ns[[".package"]][["version"]]
[17:43:51.207]                           if (is.null(version)) 
[17:43:51.207]                             version <- utils::packageVersion("future")
[17:43:51.207]                         }
[17:43:51.207]                         else {
[17:43:51.207]                           version <- NULL
[17:43:51.207]                         }
[17:43:51.207]                         if (!has_future || version < "1.8.0") {
[17:43:51.207]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:51.207]                             "", base::R.version$version.string), 
[17:43:51.207]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:51.207]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:51.207]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:51.207]                               "release", "version")], collapse = " "), 
[17:43:51.207]                             hostname = base::Sys.info()[["nodename"]])
[17:43:51.207]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:51.207]                             info)
[17:43:51.207]                           info <- base::paste(info, collapse = "; ")
[17:43:51.207]                           if (!has_future) {
[17:43:51.207]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:51.207]                               info)
[17:43:51.207]                           }
[17:43:51.207]                           else {
[17:43:51.207]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:51.207]                               info, version)
[17:43:51.207]                           }
[17:43:51.207]                           base::stop(msg)
[17:43:51.207]                         }
[17:43:51.207]                       })
[17:43:51.207]                     }
[17:43:51.207]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:51.207]                     base::options(mc.cores = 1L)
[17:43:51.207]                   }
[17:43:51.207]                   ...future.strategy.old <- future::plan("list")
[17:43:51.207]                   options(future.plan = NULL)
[17:43:51.207]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.207]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:51.207]                 }
[17:43:51.207]                 ...future.workdir <- getwd()
[17:43:51.207]             }
[17:43:51.207]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:51.207]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:51.207]         }
[17:43:51.207]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:51.207]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:51.207]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:51.207]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:51.207]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:51.207]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:51.207]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:51.207]             base::names(...future.oldOptions))
[17:43:51.207]     }
[17:43:51.207]     if (FALSE) {
[17:43:51.207]     }
[17:43:51.207]     else {
[17:43:51.207]         if (TRUE) {
[17:43:51.207]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:51.207]                 open = "w")
[17:43:51.207]         }
[17:43:51.207]         else {
[17:43:51.207]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:51.207]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:51.207]         }
[17:43:51.207]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:51.207]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:51.207]             base::sink(type = "output", split = FALSE)
[17:43:51.207]             base::close(...future.stdout)
[17:43:51.207]         }, add = TRUE)
[17:43:51.207]     }
[17:43:51.207]     ...future.frame <- base::sys.nframe()
[17:43:51.207]     ...future.conditions <- base::list()
[17:43:51.207]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:51.207]     if (FALSE) {
[17:43:51.207]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:51.207]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:51.207]     }
[17:43:51.207]     ...future.result <- base::tryCatch({
[17:43:51.207]         base::withCallingHandlers({
[17:43:51.207]             ...future.value <- base::withVisible(base::local({
[17:43:51.207]                 ...future.makeSendCondition <- base::local({
[17:43:51.207]                   sendCondition <- NULL
[17:43:51.207]                   function(frame = 1L) {
[17:43:51.207]                     if (is.function(sendCondition)) 
[17:43:51.207]                       return(sendCondition)
[17:43:51.207]                     ns <- getNamespace("parallel")
[17:43:51.207]                     if (exists("sendData", mode = "function", 
[17:43:51.207]                       envir = ns)) {
[17:43:51.207]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:51.207]                         envir = ns)
[17:43:51.207]                       envir <- sys.frame(frame)
[17:43:51.207]                       master <- NULL
[17:43:51.207]                       while (!identical(envir, .GlobalEnv) && 
[17:43:51.207]                         !identical(envir, emptyenv())) {
[17:43:51.207]                         if (exists("master", mode = "list", envir = envir, 
[17:43:51.207]                           inherits = FALSE)) {
[17:43:51.207]                           master <- get("master", mode = "list", 
[17:43:51.207]                             envir = envir, inherits = FALSE)
[17:43:51.207]                           if (inherits(master, c("SOCKnode", 
[17:43:51.207]                             "SOCK0node"))) {
[17:43:51.207]                             sendCondition <<- function(cond) {
[17:43:51.207]                               data <- list(type = "VALUE", value = cond, 
[17:43:51.207]                                 success = TRUE)
[17:43:51.207]                               parallel_sendData(master, data)
[17:43:51.207]                             }
[17:43:51.207]                             return(sendCondition)
[17:43:51.207]                           }
[17:43:51.207]                         }
[17:43:51.207]                         frame <- frame + 1L
[17:43:51.207]                         envir <- sys.frame(frame)
[17:43:51.207]                       }
[17:43:51.207]                     }
[17:43:51.207]                     sendCondition <<- function(cond) NULL
[17:43:51.207]                   }
[17:43:51.207]                 })
[17:43:51.207]                 withCallingHandlers({
[17:43:51.207]                   {
[17:43:51.207]                     do.call(function(...) {
[17:43:51.207]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.207]                       if (!identical(...future.globals.maxSize.org, 
[17:43:51.207]                         ...future.globals.maxSize)) {
[17:43:51.207]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.207]                         on.exit(options(oopts), add = TRUE)
[17:43:51.207]                       }
[17:43:51.207]                       {
[17:43:51.207]                         lapply(seq_along(...future.elements_ii), 
[17:43:51.207]                           FUN = function(jj) {
[17:43:51.207]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.207]                             ...future.FUN(...future.X_jj, ...)
[17:43:51.207]                           })
[17:43:51.207]                       }
[17:43:51.207]                     }, args = future.call.arguments)
[17:43:51.207]                   }
[17:43:51.207]                 }, immediateCondition = function(cond) {
[17:43:51.207]                   sendCondition <- ...future.makeSendCondition()
[17:43:51.207]                   sendCondition(cond)
[17:43:51.207]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.207]                   {
[17:43:51.207]                     inherits <- base::inherits
[17:43:51.207]                     invokeRestart <- base::invokeRestart
[17:43:51.207]                     is.null <- base::is.null
[17:43:51.207]                     muffled <- FALSE
[17:43:51.207]                     if (inherits(cond, "message")) {
[17:43:51.207]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:51.207]                       if (muffled) 
[17:43:51.207]                         invokeRestart("muffleMessage")
[17:43:51.207]                     }
[17:43:51.207]                     else if (inherits(cond, "warning")) {
[17:43:51.207]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:51.207]                       if (muffled) 
[17:43:51.207]                         invokeRestart("muffleWarning")
[17:43:51.207]                     }
[17:43:51.207]                     else if (inherits(cond, "condition")) {
[17:43:51.207]                       if (!is.null(pattern)) {
[17:43:51.207]                         computeRestarts <- base::computeRestarts
[17:43:51.207]                         grepl <- base::grepl
[17:43:51.207]                         restarts <- computeRestarts(cond)
[17:43:51.207]                         for (restart in restarts) {
[17:43:51.207]                           name <- restart$name
[17:43:51.207]                           if (is.null(name)) 
[17:43:51.207]                             next
[17:43:51.207]                           if (!grepl(pattern, name)) 
[17:43:51.207]                             next
[17:43:51.207]                           invokeRestart(restart)
[17:43:51.207]                           muffled <- TRUE
[17:43:51.207]                           break
[17:43:51.207]                         }
[17:43:51.207]                       }
[17:43:51.207]                     }
[17:43:51.207]                     invisible(muffled)
[17:43:51.207]                   }
[17:43:51.207]                   muffleCondition(cond)
[17:43:51.207]                 })
[17:43:51.207]             }))
[17:43:51.207]             future::FutureResult(value = ...future.value$value, 
[17:43:51.207]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.207]                   ...future.rng), globalenv = if (FALSE) 
[17:43:51.207]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:51.207]                     ...future.globalenv.names))
[17:43:51.207]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:51.207]         }, condition = base::local({
[17:43:51.207]             c <- base::c
[17:43:51.207]             inherits <- base::inherits
[17:43:51.207]             invokeRestart <- base::invokeRestart
[17:43:51.207]             length <- base::length
[17:43:51.207]             list <- base::list
[17:43:51.207]             seq.int <- base::seq.int
[17:43:51.207]             signalCondition <- base::signalCondition
[17:43:51.207]             sys.calls <- base::sys.calls
[17:43:51.207]             `[[` <- base::`[[`
[17:43:51.207]             `+` <- base::`+`
[17:43:51.207]             `<<-` <- base::`<<-`
[17:43:51.207]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:51.207]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:51.207]                   3L)]
[17:43:51.207]             }
[17:43:51.207]             function(cond) {
[17:43:51.207]                 is_error <- inherits(cond, "error")
[17:43:51.207]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:51.207]                   NULL)
[17:43:51.207]                 if (is_error) {
[17:43:51.207]                   sessionInformation <- function() {
[17:43:51.207]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:51.207]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:51.207]                       search = base::search(), system = base::Sys.info())
[17:43:51.207]                   }
[17:43:51.207]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.207]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:51.207]                     cond$call), session = sessionInformation(), 
[17:43:51.207]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:51.207]                   signalCondition(cond)
[17:43:51.207]                 }
[17:43:51.207]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:51.207]                 "immediateCondition"))) {
[17:43:51.207]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:51.207]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.207]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:51.207]                   if (TRUE && !signal) {
[17:43:51.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.207]                     {
[17:43:51.207]                       inherits <- base::inherits
[17:43:51.207]                       invokeRestart <- base::invokeRestart
[17:43:51.207]                       is.null <- base::is.null
[17:43:51.207]                       muffled <- FALSE
[17:43:51.207]                       if (inherits(cond, "message")) {
[17:43:51.207]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.207]                         if (muffled) 
[17:43:51.207]                           invokeRestart("muffleMessage")
[17:43:51.207]                       }
[17:43:51.207]                       else if (inherits(cond, "warning")) {
[17:43:51.207]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.207]                         if (muffled) 
[17:43:51.207]                           invokeRestart("muffleWarning")
[17:43:51.207]                       }
[17:43:51.207]                       else if (inherits(cond, "condition")) {
[17:43:51.207]                         if (!is.null(pattern)) {
[17:43:51.207]                           computeRestarts <- base::computeRestarts
[17:43:51.207]                           grepl <- base::grepl
[17:43:51.207]                           restarts <- computeRestarts(cond)
[17:43:51.207]                           for (restart in restarts) {
[17:43:51.207]                             name <- restart$name
[17:43:51.207]                             if (is.null(name)) 
[17:43:51.207]                               next
[17:43:51.207]                             if (!grepl(pattern, name)) 
[17:43:51.207]                               next
[17:43:51.207]                             invokeRestart(restart)
[17:43:51.207]                             muffled <- TRUE
[17:43:51.207]                             break
[17:43:51.207]                           }
[17:43:51.207]                         }
[17:43:51.207]                       }
[17:43:51.207]                       invisible(muffled)
[17:43:51.207]                     }
[17:43:51.207]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.207]                   }
[17:43:51.207]                 }
[17:43:51.207]                 else {
[17:43:51.207]                   if (TRUE) {
[17:43:51.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.207]                     {
[17:43:51.207]                       inherits <- base::inherits
[17:43:51.207]                       invokeRestart <- base::invokeRestart
[17:43:51.207]                       is.null <- base::is.null
[17:43:51.207]                       muffled <- FALSE
[17:43:51.207]                       if (inherits(cond, "message")) {
[17:43:51.207]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.207]                         if (muffled) 
[17:43:51.207]                           invokeRestart("muffleMessage")
[17:43:51.207]                       }
[17:43:51.207]                       else if (inherits(cond, "warning")) {
[17:43:51.207]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.207]                         if (muffled) 
[17:43:51.207]                           invokeRestart("muffleWarning")
[17:43:51.207]                       }
[17:43:51.207]                       else if (inherits(cond, "condition")) {
[17:43:51.207]                         if (!is.null(pattern)) {
[17:43:51.207]                           computeRestarts <- base::computeRestarts
[17:43:51.207]                           grepl <- base::grepl
[17:43:51.207]                           restarts <- computeRestarts(cond)
[17:43:51.207]                           for (restart in restarts) {
[17:43:51.207]                             name <- restart$name
[17:43:51.207]                             if (is.null(name)) 
[17:43:51.207]                               next
[17:43:51.207]                             if (!grepl(pattern, name)) 
[17:43:51.207]                               next
[17:43:51.207]                             invokeRestart(restart)
[17:43:51.207]                             muffled <- TRUE
[17:43:51.207]                             break
[17:43:51.207]                           }
[17:43:51.207]                         }
[17:43:51.207]                       }
[17:43:51.207]                       invisible(muffled)
[17:43:51.207]                     }
[17:43:51.207]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.207]                   }
[17:43:51.207]                 }
[17:43:51.207]             }
[17:43:51.207]         }))
[17:43:51.207]     }, error = function(ex) {
[17:43:51.207]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:51.207]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.207]                 ...future.rng), started = ...future.startTime, 
[17:43:51.207]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:51.207]             version = "1.8"), class = "FutureResult")
[17:43:51.207]     }, finally = {
[17:43:51.207]         if (!identical(...future.workdir, getwd())) 
[17:43:51.207]             setwd(...future.workdir)
[17:43:51.207]         {
[17:43:51.207]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:51.207]                 ...future.oldOptions$nwarnings <- NULL
[17:43:51.207]             }
[17:43:51.207]             base::options(...future.oldOptions)
[17:43:51.207]             if (.Platform$OS.type == "windows") {
[17:43:51.207]                 old_names <- names(...future.oldEnvVars)
[17:43:51.207]                 envs <- base::Sys.getenv()
[17:43:51.207]                 names <- names(envs)
[17:43:51.207]                 common <- intersect(names, old_names)
[17:43:51.207]                 added <- setdiff(names, old_names)
[17:43:51.207]                 removed <- setdiff(old_names, names)
[17:43:51.207]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:51.207]                   envs[common]]
[17:43:51.207]                 NAMES <- toupper(changed)
[17:43:51.207]                 args <- list()
[17:43:51.207]                 for (kk in seq_along(NAMES)) {
[17:43:51.207]                   name <- changed[[kk]]
[17:43:51.207]                   NAME <- NAMES[[kk]]
[17:43:51.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.207]                     next
[17:43:51.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.207]                 }
[17:43:51.207]                 NAMES <- toupper(added)
[17:43:51.207]                 for (kk in seq_along(NAMES)) {
[17:43:51.207]                   name <- added[[kk]]
[17:43:51.207]                   NAME <- NAMES[[kk]]
[17:43:51.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.207]                     next
[17:43:51.207]                   args[[name]] <- ""
[17:43:51.207]                 }
[17:43:51.207]                 NAMES <- toupper(removed)
[17:43:51.207]                 for (kk in seq_along(NAMES)) {
[17:43:51.207]                   name <- removed[[kk]]
[17:43:51.207]                   NAME <- NAMES[[kk]]
[17:43:51.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.207]                     next
[17:43:51.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.207]                 }
[17:43:51.207]                 if (length(args) > 0) 
[17:43:51.207]                   base::do.call(base::Sys.setenv, args = args)
[17:43:51.207]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:51.207]             }
[17:43:51.207]             else {
[17:43:51.207]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:51.207]             }
[17:43:51.207]             {
[17:43:51.207]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:51.207]                   0L) {
[17:43:51.207]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:51.207]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:51.207]                   base::options(opts)
[17:43:51.207]                 }
[17:43:51.207]                 {
[17:43:51.207]                   {
[17:43:51.207]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:51.207]                     NULL
[17:43:51.207]                   }
[17:43:51.207]                   options(future.plan = NULL)
[17:43:51.207]                   if (is.na(NA_character_)) 
[17:43:51.207]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.207]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:51.207]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:51.207]                     .init = FALSE)
[17:43:51.207]                 }
[17:43:51.207]             }
[17:43:51.207]         }
[17:43:51.207]     })
[17:43:51.207]     if (TRUE) {
[17:43:51.207]         base::sink(type = "output", split = FALSE)
[17:43:51.207]         if (TRUE) {
[17:43:51.207]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:51.207]         }
[17:43:51.207]         else {
[17:43:51.207]             ...future.result["stdout"] <- base::list(NULL)
[17:43:51.207]         }
[17:43:51.207]         base::close(...future.stdout)
[17:43:51.207]         ...future.stdout <- NULL
[17:43:51.207]     }
[17:43:51.207]     ...future.result$conditions <- ...future.conditions
[17:43:51.207]     ...future.result$finished <- base::Sys.time()
[17:43:51.207]     ...future.result
[17:43:51.207] }
[17:43:51.210] Exporting 5 global objects (9.77 KiB) to cluster node #1 ...
[17:43:51.210] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:51.210] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:51.211] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ...
[17:43:51.211] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ... DONE
[17:43:51.211] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:43:51.211] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:43:51.212] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:43:51.212] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:43:51.212] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:43:51.212] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:43:51.213] Exporting 5 global objects (9.77 KiB) to cluster node #1 ... DONE
[17:43:51.213] MultisessionFuture started
[17:43:51.213] - Launch lazy future ... done
[17:43:51.213] run() for ‘MultisessionFuture’ ... done
[17:43:51.214] Created future:
[17:43:51.214] MultisessionFuture:
[17:43:51.214] Label: ‘future_apply-1’
[17:43:51.214] Expression:
[17:43:51.214] {
[17:43:51.214]     do.call(function(...) {
[17:43:51.214]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.214]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.214]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.214]             on.exit(options(oopts), add = TRUE)
[17:43:51.214]         }
[17:43:51.214]         {
[17:43:51.214]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.214]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.214]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.214]             })
[17:43:51.214]         }
[17:43:51.214]     }, args = future.call.arguments)
[17:43:51.214] }
[17:43:51.214] Lazy evaluation: FALSE
[17:43:51.214] Asynchronous evaluation: TRUE
[17:43:51.214] Local evaluation: TRUE
[17:43:51.214] Environment: R_GlobalEnv
[17:43:51.214] Capture standard output: TRUE
[17:43:51.214] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:51.214] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:51.214] Packages: <none>
[17:43:51.214] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:51.214] Resolved: FALSE
[17:43:51.214] Value: <not collected>
[17:43:51.214] Conditions captured: <none>
[17:43:51.214] Early signaling: FALSE
[17:43:51.214] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:51.214] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:51.225] Chunk #1 of 2 ... DONE
[17:43:51.225] Chunk #2 of 2 ...
[17:43:51.225]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:51.225]  - seeds: <none>
[17:43:51.226]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.226] getGlobalsAndPackages() ...
[17:43:51.226] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.226] Resolving globals: FALSE
[17:43:51.226] Tweak future expression to call with '...' arguments ...
[17:43:51.226] {
[17:43:51.226]     do.call(function(...) {
[17:43:51.226]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.226]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.226]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.226]             on.exit(options(oopts), add = TRUE)
[17:43:51.226]         }
[17:43:51.226]         {
[17:43:51.226]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.226]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.226]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.226]             })
[17:43:51.226]         }
[17:43:51.226]     }, args = future.call.arguments)
[17:43:51.226] }
[17:43:51.226] Tweak future expression to call with '...' arguments ... DONE
[17:43:51.227] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.227] 
[17:43:51.227] getGlobalsAndPackages() ... DONE
[17:43:51.227] run() for ‘Future’ ...
[17:43:51.227] - state: ‘created’
[17:43:51.227] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:51.241] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:51.241] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:51.241]   - Field: ‘node’
[17:43:51.241]   - Field: ‘label’
[17:43:51.242]   - Field: ‘local’
[17:43:51.242]   - Field: ‘owner’
[17:43:51.242]   - Field: ‘envir’
[17:43:51.242]   - Field: ‘workers’
[17:43:51.242]   - Field: ‘packages’
[17:43:51.242]   - Field: ‘gc’
[17:43:51.242]   - Field: ‘conditions’
[17:43:51.242]   - Field: ‘persistent’
[17:43:51.242]   - Field: ‘expr’
[17:43:51.242]   - Field: ‘uuid’
[17:43:51.242]   - Field: ‘seed’
[17:43:51.243]   - Field: ‘version’
[17:43:51.243]   - Field: ‘result’
[17:43:51.243]   - Field: ‘asynchronous’
[17:43:51.243]   - Field: ‘calls’
[17:43:51.243]   - Field: ‘globals’
[17:43:51.243]   - Field: ‘stdout’
[17:43:51.243]   - Field: ‘earlySignal’
[17:43:51.243]   - Field: ‘lazy’
[17:43:51.245]   - Field: ‘state’
[17:43:51.246] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:51.246] - Launch lazy future ...
[17:43:51.246] Packages needed by the future expression (n = 0): <none>
[17:43:51.246] Packages needed by future strategies (n = 0): <none>
[17:43:51.246] {
[17:43:51.246]     {
[17:43:51.246]         {
[17:43:51.246]             ...future.startTime <- base::Sys.time()
[17:43:51.246]             {
[17:43:51.246]                 {
[17:43:51.246]                   {
[17:43:51.246]                     {
[17:43:51.246]                       base::local({
[17:43:51.246]                         has_future <- base::requireNamespace("future", 
[17:43:51.246]                           quietly = TRUE)
[17:43:51.246]                         if (has_future) {
[17:43:51.246]                           ns <- base::getNamespace("future")
[17:43:51.246]                           version <- ns[[".package"]][["version"]]
[17:43:51.246]                           if (is.null(version)) 
[17:43:51.246]                             version <- utils::packageVersion("future")
[17:43:51.246]                         }
[17:43:51.246]                         else {
[17:43:51.246]                           version <- NULL
[17:43:51.246]                         }
[17:43:51.246]                         if (!has_future || version < "1.8.0") {
[17:43:51.246]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:51.246]                             "", base::R.version$version.string), 
[17:43:51.246]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:51.246]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:51.246]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:51.246]                               "release", "version")], collapse = " "), 
[17:43:51.246]                             hostname = base::Sys.info()[["nodename"]])
[17:43:51.246]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:51.246]                             info)
[17:43:51.246]                           info <- base::paste(info, collapse = "; ")
[17:43:51.246]                           if (!has_future) {
[17:43:51.246]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:51.246]                               info)
[17:43:51.246]                           }
[17:43:51.246]                           else {
[17:43:51.246]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:51.246]                               info, version)
[17:43:51.246]                           }
[17:43:51.246]                           base::stop(msg)
[17:43:51.246]                         }
[17:43:51.246]                       })
[17:43:51.246]                     }
[17:43:51.246]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:51.246]                     base::options(mc.cores = 1L)
[17:43:51.246]                   }
[17:43:51.246]                   ...future.strategy.old <- future::plan("list")
[17:43:51.246]                   options(future.plan = NULL)
[17:43:51.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:51.246]                 }
[17:43:51.246]                 ...future.workdir <- getwd()
[17:43:51.246]             }
[17:43:51.246]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:51.246]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:51.246]         }
[17:43:51.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:51.246]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:51.246]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:51.246]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:51.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:51.246]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:51.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:51.246]             base::names(...future.oldOptions))
[17:43:51.246]     }
[17:43:51.246]     if (FALSE) {
[17:43:51.246]     }
[17:43:51.246]     else {
[17:43:51.246]         if (TRUE) {
[17:43:51.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:51.246]                 open = "w")
[17:43:51.246]         }
[17:43:51.246]         else {
[17:43:51.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:51.246]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:51.246]         }
[17:43:51.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:51.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:51.246]             base::sink(type = "output", split = FALSE)
[17:43:51.246]             base::close(...future.stdout)
[17:43:51.246]         }, add = TRUE)
[17:43:51.246]     }
[17:43:51.246]     ...future.frame <- base::sys.nframe()
[17:43:51.246]     ...future.conditions <- base::list()
[17:43:51.246]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:51.246]     if (FALSE) {
[17:43:51.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:51.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:51.246]     }
[17:43:51.246]     ...future.result <- base::tryCatch({
[17:43:51.246]         base::withCallingHandlers({
[17:43:51.246]             ...future.value <- base::withVisible(base::local({
[17:43:51.246]                 ...future.makeSendCondition <- base::local({
[17:43:51.246]                   sendCondition <- NULL
[17:43:51.246]                   function(frame = 1L) {
[17:43:51.246]                     if (is.function(sendCondition)) 
[17:43:51.246]                       return(sendCondition)
[17:43:51.246]                     ns <- getNamespace("parallel")
[17:43:51.246]                     if (exists("sendData", mode = "function", 
[17:43:51.246]                       envir = ns)) {
[17:43:51.246]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:51.246]                         envir = ns)
[17:43:51.246]                       envir <- sys.frame(frame)
[17:43:51.246]                       master <- NULL
[17:43:51.246]                       while (!identical(envir, .GlobalEnv) && 
[17:43:51.246]                         !identical(envir, emptyenv())) {
[17:43:51.246]                         if (exists("master", mode = "list", envir = envir, 
[17:43:51.246]                           inherits = FALSE)) {
[17:43:51.246]                           master <- get("master", mode = "list", 
[17:43:51.246]                             envir = envir, inherits = FALSE)
[17:43:51.246]                           if (inherits(master, c("SOCKnode", 
[17:43:51.246]                             "SOCK0node"))) {
[17:43:51.246]                             sendCondition <<- function(cond) {
[17:43:51.246]                               data <- list(type = "VALUE", value = cond, 
[17:43:51.246]                                 success = TRUE)
[17:43:51.246]                               parallel_sendData(master, data)
[17:43:51.246]                             }
[17:43:51.246]                             return(sendCondition)
[17:43:51.246]                           }
[17:43:51.246]                         }
[17:43:51.246]                         frame <- frame + 1L
[17:43:51.246]                         envir <- sys.frame(frame)
[17:43:51.246]                       }
[17:43:51.246]                     }
[17:43:51.246]                     sendCondition <<- function(cond) NULL
[17:43:51.246]                   }
[17:43:51.246]                 })
[17:43:51.246]                 withCallingHandlers({
[17:43:51.246]                   {
[17:43:51.246]                     do.call(function(...) {
[17:43:51.246]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.246]                       if (!identical(...future.globals.maxSize.org, 
[17:43:51.246]                         ...future.globals.maxSize)) {
[17:43:51.246]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.246]                         on.exit(options(oopts), add = TRUE)
[17:43:51.246]                       }
[17:43:51.246]                       {
[17:43:51.246]                         lapply(seq_along(...future.elements_ii), 
[17:43:51.246]                           FUN = function(jj) {
[17:43:51.246]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.246]                             ...future.FUN(...future.X_jj, ...)
[17:43:51.246]                           })
[17:43:51.246]                       }
[17:43:51.246]                     }, args = future.call.arguments)
[17:43:51.246]                   }
[17:43:51.246]                 }, immediateCondition = function(cond) {
[17:43:51.246]                   sendCondition <- ...future.makeSendCondition()
[17:43:51.246]                   sendCondition(cond)
[17:43:51.246]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.246]                   {
[17:43:51.246]                     inherits <- base::inherits
[17:43:51.246]                     invokeRestart <- base::invokeRestart
[17:43:51.246]                     is.null <- base::is.null
[17:43:51.246]                     muffled <- FALSE
[17:43:51.246]                     if (inherits(cond, "message")) {
[17:43:51.246]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:51.246]                       if (muffled) 
[17:43:51.246]                         invokeRestart("muffleMessage")
[17:43:51.246]                     }
[17:43:51.246]                     else if (inherits(cond, "warning")) {
[17:43:51.246]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:51.246]                       if (muffled) 
[17:43:51.246]                         invokeRestart("muffleWarning")
[17:43:51.246]                     }
[17:43:51.246]                     else if (inherits(cond, "condition")) {
[17:43:51.246]                       if (!is.null(pattern)) {
[17:43:51.246]                         computeRestarts <- base::computeRestarts
[17:43:51.246]                         grepl <- base::grepl
[17:43:51.246]                         restarts <- computeRestarts(cond)
[17:43:51.246]                         for (restart in restarts) {
[17:43:51.246]                           name <- restart$name
[17:43:51.246]                           if (is.null(name)) 
[17:43:51.246]                             next
[17:43:51.246]                           if (!grepl(pattern, name)) 
[17:43:51.246]                             next
[17:43:51.246]                           invokeRestart(restart)
[17:43:51.246]                           muffled <- TRUE
[17:43:51.246]                           break
[17:43:51.246]                         }
[17:43:51.246]                       }
[17:43:51.246]                     }
[17:43:51.246]                     invisible(muffled)
[17:43:51.246]                   }
[17:43:51.246]                   muffleCondition(cond)
[17:43:51.246]                 })
[17:43:51.246]             }))
[17:43:51.246]             future::FutureResult(value = ...future.value$value, 
[17:43:51.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.246]                   ...future.rng), globalenv = if (FALSE) 
[17:43:51.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:51.246]                     ...future.globalenv.names))
[17:43:51.246]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:51.246]         }, condition = base::local({
[17:43:51.246]             c <- base::c
[17:43:51.246]             inherits <- base::inherits
[17:43:51.246]             invokeRestart <- base::invokeRestart
[17:43:51.246]             length <- base::length
[17:43:51.246]             list <- base::list
[17:43:51.246]             seq.int <- base::seq.int
[17:43:51.246]             signalCondition <- base::signalCondition
[17:43:51.246]             sys.calls <- base::sys.calls
[17:43:51.246]             `[[` <- base::`[[`
[17:43:51.246]             `+` <- base::`+`
[17:43:51.246]             `<<-` <- base::`<<-`
[17:43:51.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:51.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:51.246]                   3L)]
[17:43:51.246]             }
[17:43:51.246]             function(cond) {
[17:43:51.246]                 is_error <- inherits(cond, "error")
[17:43:51.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:51.246]                   NULL)
[17:43:51.246]                 if (is_error) {
[17:43:51.246]                   sessionInformation <- function() {
[17:43:51.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:51.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:51.246]                       search = base::search(), system = base::Sys.info())
[17:43:51.246]                   }
[17:43:51.246]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:51.246]                     cond$call), session = sessionInformation(), 
[17:43:51.246]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:51.246]                   signalCondition(cond)
[17:43:51.246]                 }
[17:43:51.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:51.246]                 "immediateCondition"))) {
[17:43:51.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:51.246]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:51.246]                   if (TRUE && !signal) {
[17:43:51.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.246]                     {
[17:43:51.246]                       inherits <- base::inherits
[17:43:51.246]                       invokeRestart <- base::invokeRestart
[17:43:51.246]                       is.null <- base::is.null
[17:43:51.246]                       muffled <- FALSE
[17:43:51.246]                       if (inherits(cond, "message")) {
[17:43:51.246]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.246]                         if (muffled) 
[17:43:51.246]                           invokeRestart("muffleMessage")
[17:43:51.246]                       }
[17:43:51.246]                       else if (inherits(cond, "warning")) {
[17:43:51.246]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.246]                         if (muffled) 
[17:43:51.246]                           invokeRestart("muffleWarning")
[17:43:51.246]                       }
[17:43:51.246]                       else if (inherits(cond, "condition")) {
[17:43:51.246]                         if (!is.null(pattern)) {
[17:43:51.246]                           computeRestarts <- base::computeRestarts
[17:43:51.246]                           grepl <- base::grepl
[17:43:51.246]                           restarts <- computeRestarts(cond)
[17:43:51.246]                           for (restart in restarts) {
[17:43:51.246]                             name <- restart$name
[17:43:51.246]                             if (is.null(name)) 
[17:43:51.246]                               next
[17:43:51.246]                             if (!grepl(pattern, name)) 
[17:43:51.246]                               next
[17:43:51.246]                             invokeRestart(restart)
[17:43:51.246]                             muffled <- TRUE
[17:43:51.246]                             break
[17:43:51.246]                           }
[17:43:51.246]                         }
[17:43:51.246]                       }
[17:43:51.246]                       invisible(muffled)
[17:43:51.246]                     }
[17:43:51.246]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.246]                   }
[17:43:51.246]                 }
[17:43:51.246]                 else {
[17:43:51.246]                   if (TRUE) {
[17:43:51.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.246]                     {
[17:43:51.246]                       inherits <- base::inherits
[17:43:51.246]                       invokeRestart <- base::invokeRestart
[17:43:51.246]                       is.null <- base::is.null
[17:43:51.246]                       muffled <- FALSE
[17:43:51.246]                       if (inherits(cond, "message")) {
[17:43:51.246]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.246]                         if (muffled) 
[17:43:51.246]                           invokeRestart("muffleMessage")
[17:43:51.246]                       }
[17:43:51.246]                       else if (inherits(cond, "warning")) {
[17:43:51.246]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.246]                         if (muffled) 
[17:43:51.246]                           invokeRestart("muffleWarning")
[17:43:51.246]                       }
[17:43:51.246]                       else if (inherits(cond, "condition")) {
[17:43:51.246]                         if (!is.null(pattern)) {
[17:43:51.246]                           computeRestarts <- base::computeRestarts
[17:43:51.246]                           grepl <- base::grepl
[17:43:51.246]                           restarts <- computeRestarts(cond)
[17:43:51.246]                           for (restart in restarts) {
[17:43:51.246]                             name <- restart$name
[17:43:51.246]                             if (is.null(name)) 
[17:43:51.246]                               next
[17:43:51.246]                             if (!grepl(pattern, name)) 
[17:43:51.246]                               next
[17:43:51.246]                             invokeRestart(restart)
[17:43:51.246]                             muffled <- TRUE
[17:43:51.246]                             break
[17:43:51.246]                           }
[17:43:51.246]                         }
[17:43:51.246]                       }
[17:43:51.246]                       invisible(muffled)
[17:43:51.246]                     }
[17:43:51.246]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.246]                   }
[17:43:51.246]                 }
[17:43:51.246]             }
[17:43:51.246]         }))
[17:43:51.246]     }, error = function(ex) {
[17:43:51.246]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:51.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.246]                 ...future.rng), started = ...future.startTime, 
[17:43:51.246]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:51.246]             version = "1.8"), class = "FutureResult")
[17:43:51.246]     }, finally = {
[17:43:51.246]         if (!identical(...future.workdir, getwd())) 
[17:43:51.246]             setwd(...future.workdir)
[17:43:51.246]         {
[17:43:51.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:51.246]                 ...future.oldOptions$nwarnings <- NULL
[17:43:51.246]             }
[17:43:51.246]             base::options(...future.oldOptions)
[17:43:51.246]             if (.Platform$OS.type == "windows") {
[17:43:51.246]                 old_names <- names(...future.oldEnvVars)
[17:43:51.246]                 envs <- base::Sys.getenv()
[17:43:51.246]                 names <- names(envs)
[17:43:51.246]                 common <- intersect(names, old_names)
[17:43:51.246]                 added <- setdiff(names, old_names)
[17:43:51.246]                 removed <- setdiff(old_names, names)
[17:43:51.246]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:51.246]                   envs[common]]
[17:43:51.246]                 NAMES <- toupper(changed)
[17:43:51.246]                 args <- list()
[17:43:51.246]                 for (kk in seq_along(NAMES)) {
[17:43:51.246]                   name <- changed[[kk]]
[17:43:51.246]                   NAME <- NAMES[[kk]]
[17:43:51.246]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.246]                     next
[17:43:51.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.246]                 }
[17:43:51.246]                 NAMES <- toupper(added)
[17:43:51.246]                 for (kk in seq_along(NAMES)) {
[17:43:51.246]                   name <- added[[kk]]
[17:43:51.246]                   NAME <- NAMES[[kk]]
[17:43:51.246]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.246]                     next
[17:43:51.246]                   args[[name]] <- ""
[17:43:51.246]                 }
[17:43:51.246]                 NAMES <- toupper(removed)
[17:43:51.246]                 for (kk in seq_along(NAMES)) {
[17:43:51.246]                   name <- removed[[kk]]
[17:43:51.246]                   NAME <- NAMES[[kk]]
[17:43:51.246]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.246]                     next
[17:43:51.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.246]                 }
[17:43:51.246]                 if (length(args) > 0) 
[17:43:51.246]                   base::do.call(base::Sys.setenv, args = args)
[17:43:51.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:51.246]             }
[17:43:51.246]             else {
[17:43:51.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:51.246]             }
[17:43:51.246]             {
[17:43:51.246]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:51.246]                   0L) {
[17:43:51.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:51.246]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:51.246]                   base::options(opts)
[17:43:51.246]                 }
[17:43:51.246]                 {
[17:43:51.246]                   {
[17:43:51.246]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:51.246]                     NULL
[17:43:51.246]                   }
[17:43:51.246]                   options(future.plan = NULL)
[17:43:51.246]                   if (is.na(NA_character_)) 
[17:43:51.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:51.246]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:51.246]                     .init = FALSE)
[17:43:51.246]                 }
[17:43:51.246]             }
[17:43:51.246]         }
[17:43:51.246]     })
[17:43:51.246]     if (TRUE) {
[17:43:51.246]         base::sink(type = "output", split = FALSE)
[17:43:51.246]         if (TRUE) {
[17:43:51.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:51.246]         }
[17:43:51.246]         else {
[17:43:51.246]             ...future.result["stdout"] <- base::list(NULL)
[17:43:51.246]         }
[17:43:51.246]         base::close(...future.stdout)
[17:43:51.246]         ...future.stdout <- NULL
[17:43:51.246]     }
[17:43:51.246]     ...future.result$conditions <- ...future.conditions
[17:43:51.246]     ...future.result$finished <- base::Sys.time()
[17:43:51.246]     ...future.result
[17:43:51.246] }
[17:43:51.249] Exporting 5 global objects (9.77 KiB) to cluster node #2 ...
[17:43:51.250] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:51.250] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:51.250] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ...
[17:43:51.250] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ... DONE
[17:43:51.251] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:43:51.251] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:43:51.251] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:43:51.252] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:43:51.252] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:43:51.252] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:43:51.252] Exporting 5 global objects (9.77 KiB) to cluster node #2 ... DONE
[17:43:51.253] MultisessionFuture started
[17:43:51.253] - Launch lazy future ... done
[17:43:51.253] run() for ‘MultisessionFuture’ ... done
[17:43:51.253] Created future:
[17:43:51.253] MultisessionFuture:
[17:43:51.253] Label: ‘future_apply-2’
[17:43:51.253] Expression:
[17:43:51.253] {
[17:43:51.253]     do.call(function(...) {
[17:43:51.253]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.253]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.253]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.253]             on.exit(options(oopts), add = TRUE)
[17:43:51.253]         }
[17:43:51.253]         {
[17:43:51.253]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.253]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.253]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.253]             })
[17:43:51.253]         }
[17:43:51.253]     }, args = future.call.arguments)
[17:43:51.253] }
[17:43:51.253] Lazy evaluation: FALSE
[17:43:51.253] Asynchronous evaluation: TRUE
[17:43:51.253] Local evaluation: TRUE
[17:43:51.253] Environment: R_GlobalEnv
[17:43:51.253] Capture standard output: TRUE
[17:43:51.253] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:43:51.253] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:51.253] Packages: <none>
[17:43:51.253] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:43:51.253] Resolved: FALSE
[17:43:51.253] Value: <not collected>
[17:43:51.253] Conditions captured: <none>
[17:43:51.253] Early signaling: FALSE
[17:43:51.253] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:51.253] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:51.265] Chunk #2 of 2 ... DONE
[17:43:51.265] Launching 2 futures (chunks) ... DONE
[17:43:51.265] Resolving 2 futures (chunks) ...
[17:43:51.265] resolve() on list ...
[17:43:51.265]  recursive: 0
[17:43:51.265]  length: 2
[17:43:51.265] 
[17:43:51.266] receiveMessageFromWorker() for ClusterFuture ...
[17:43:51.266] - Validating connection of MultisessionFuture
[17:43:51.266] - received message: FutureResult
[17:43:51.266] - Received FutureResult
[17:43:51.266] - Erased future from FutureRegistry
[17:43:51.266] result() for ClusterFuture ...
[17:43:51.266] - result already collected: FutureResult
[17:43:51.266] result() for ClusterFuture ... done
[17:43:51.266] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:51.267] Future #1
[17:43:51.267] result() for ClusterFuture ...
[17:43:51.267] - result already collected: FutureResult
[17:43:51.267] result() for ClusterFuture ... done
[17:43:51.267] result() for ClusterFuture ...
[17:43:51.267] - result already collected: FutureResult
[17:43:51.267] result() for ClusterFuture ... done
[17:43:51.267] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:51.267] - nx: 2
[17:43:51.267] - relay: TRUE
[17:43:51.267] - stdout: TRUE
[17:43:51.268] - signal: TRUE
[17:43:51.268] - resignal: FALSE
[17:43:51.268] - force: TRUE
[17:43:51.268] - relayed: [n=2] FALSE, FALSE
[17:43:51.268] - queued futures: [n=2] FALSE, FALSE
[17:43:51.268]  - until=1
[17:43:51.268]  - relaying element #1
[17:43:51.268] result() for ClusterFuture ...
[17:43:51.268] - result already collected: FutureResult
[17:43:51.268] result() for ClusterFuture ... done
[17:43:51.268] result() for ClusterFuture ...
[17:43:51.268] - result already collected: FutureResult
[17:43:51.269] result() for ClusterFuture ... done
[17:43:51.269] result() for ClusterFuture ...
[17:43:51.269] - result already collected: FutureResult
[17:43:51.269] result() for ClusterFuture ... done
[17:43:51.269] result() for ClusterFuture ...
[17:43:51.269] - result already collected: FutureResult
[17:43:51.269] result() for ClusterFuture ... done
[17:43:51.269] - relayed: [n=2] TRUE, FALSE
[17:43:51.269] - queued futures: [n=2] TRUE, FALSE
[17:43:51.269] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:51.269]  length: 1 (resolved future 1)
[17:43:51.297] receiveMessageFromWorker() for ClusterFuture ...
[17:43:51.297] - Validating connection of MultisessionFuture
[17:43:51.297] - received message: FutureResult
[17:43:51.297] - Received FutureResult
[17:43:51.297] - Erased future from FutureRegistry
[17:43:51.297] result() for ClusterFuture ...
[17:43:51.297] - result already collected: FutureResult
[17:43:51.298] result() for ClusterFuture ... done
[17:43:51.298] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:51.298] Future #2
[17:43:51.298] result() for ClusterFuture ...
[17:43:51.298] - result already collected: FutureResult
[17:43:51.298] result() for ClusterFuture ... done
[17:43:51.298] result() for ClusterFuture ...
[17:43:51.298] - result already collected: FutureResult
[17:43:51.298] result() for ClusterFuture ... done
[17:43:51.298] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:51.298] - nx: 2
[17:43:51.299] - relay: TRUE
[17:43:51.299] - stdout: TRUE
[17:43:51.299] - signal: TRUE
[17:43:51.299] - resignal: FALSE
[17:43:51.299] - force: TRUE
[17:43:51.299] - relayed: [n=2] TRUE, FALSE
[17:43:51.299] - queued futures: [n=2] TRUE, FALSE
[17:43:51.299]  - until=2
[17:43:51.299]  - relaying element #2
[17:43:51.299] result() for ClusterFuture ...
[17:43:51.299] - result already collected: FutureResult
[17:43:51.300] result() for ClusterFuture ... done
[17:43:51.300] result() for ClusterFuture ...
[17:43:51.300] - result already collected: FutureResult
[17:43:51.300] result() for ClusterFuture ... done
[17:43:51.300] result() for ClusterFuture ...
[17:43:51.300] - result already collected: FutureResult
[17:43:51.300] result() for ClusterFuture ... done
[17:43:51.300] result() for ClusterFuture ...
[17:43:51.300] - result already collected: FutureResult
[17:43:51.300] result() for ClusterFuture ... done
[17:43:51.300] - relayed: [n=2] TRUE, TRUE
[17:43:51.301] - queued futures: [n=2] TRUE, TRUE
[17:43:51.301] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:51.301]  length: 0 (resolved future 2)
[17:43:51.301] Relaying remaining futures
[17:43:51.301] signalConditionsASAP(NULL, pos=0) ...
[17:43:51.301] - nx: 2
[17:43:51.301] - relay: TRUE
[17:43:51.301] - stdout: TRUE
[17:43:51.301] - signal: TRUE
[17:43:51.301] - resignal: FALSE
[17:43:51.301] - force: TRUE
[17:43:51.301] - relayed: [n=2] TRUE, TRUE
[17:43:51.302] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:51.302] - relayed: [n=2] TRUE, TRUE
[17:43:51.302] - queued futures: [n=2] TRUE, TRUE
[17:43:51.302] signalConditionsASAP(NULL, pos=0) ... done
[17:43:51.302] resolve() on list ... DONE
[17:43:51.302] result() for ClusterFuture ...
[17:43:51.302] - result already collected: FutureResult
[17:43:51.302] result() for ClusterFuture ... done
[17:43:51.302] result() for ClusterFuture ...
[17:43:51.302] - result already collected: FutureResult
[17:43:51.302] result() for ClusterFuture ... done
[17:43:51.303] result() for ClusterFuture ...
[17:43:51.303] - result already collected: FutureResult
[17:43:51.303] result() for ClusterFuture ... done
[17:43:51.303] result() for ClusterFuture ...
[17:43:51.303] - result already collected: FutureResult
[17:43:51.303] result() for ClusterFuture ... done
[17:43:51.303]  - Number of value chunks collected: 2
[17:43:51.303] Resolving 2 futures (chunks) ... DONE
[17:43:51.303] Reducing values from 2 chunks ...
[17:43:51.303]  - Number of values collected after concatenation: 2
[17:43:51.303]  - Number of values expected: 2
[17:43:51.304] Reducing values from 2 chunks ... DONE
[17:43:51.304] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[17:43:51.304] getGlobalsAndPackagesXApply() ...
[17:43:51.304]  - future.globals: TRUE
[17:43:51.304] getGlobalsAndPackages() ...
[17:43:51.304] Searching for globals...
[17:43:51.307] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[17:43:51.307] Searching for globals ... DONE
[17:43:51.307] Resolving globals: FALSE
[17:43:51.308] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[17:43:51.308] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[17:43:51.308] - globals: [1] ‘FUN’
[17:43:51.308] 
[17:43:51.308] getGlobalsAndPackages() ... DONE
[17:43:51.309]  - globals found/used: [n=1] ‘FUN’
[17:43:51.309]  - needed namespaces: [n=0] 
[17:43:51.309] Finding globals ... DONE
[17:43:51.309]  - use_args: TRUE
[17:43:51.309]  - Getting '...' globals ...
[17:43:51.309] resolve() on list ...
[17:43:51.309]  recursive: 0
[17:43:51.309]  length: 1
[17:43:51.310]  elements: ‘...’
[17:43:51.310]  length: 0 (resolved future 1)
[17:43:51.310] resolve() on list ... DONE
[17:43:51.310]    - '...' content: [n=0] 
[17:43:51.310] List of 1
[17:43:51.310]  $ ...: list()
[17:43:51.310]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.310]  - attr(*, "where")=List of 1
[17:43:51.310]   ..$ ...:<environment: 0x55dfd2b0b4e0> 
[17:43:51.310]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.310]  - attr(*, "resolved")= logi TRUE
[17:43:51.310]  - attr(*, "total_size")= num NA
[17:43:51.312]  - Getting '...' globals ... DONE
[17:43:51.313] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:43:51.313] List of 2
[17:43:51.313]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:43:51.313]  $ ...          : list()
[17:43:51.313]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.313]  - attr(*, "where")=List of 2
[17:43:51.313]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:43:51.313]   ..$ ...          :<environment: 0x55dfd2b0b4e0> 
[17:43:51.313]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.313]  - attr(*, "resolved")= logi FALSE
[17:43:51.313]  - attr(*, "total_size")= num 36296
[17:43:51.315] Packages to be attached in all futures: [n=0] 
[17:43:51.315] getGlobalsAndPackagesXApply() ... DONE
[17:43:51.319] future_lapply() ...
[17:43:51.321] Generating random seeds ...
[17:43:51.321] Generating random seed streams for 2 elements ...
[17:43:51.321] Generating random seed streams for 2 elements ... DONE
[17:43:51.321] Generating random seeds ... DONE
[17:43:51.321] Will set RNG state on exit: 10407, 497165730, -446490268, 282910480, -10551270, -1745626119, 1551039455
[17:43:51.325] Number of chunks: 2
[17:43:51.325] getGlobalsAndPackagesXApply() ...
[17:43:51.325]  - future.globals: <name-value list> with names ‘list()’
[17:43:51.325]  - use_args: TRUE
[17:43:51.325] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[17:43:51.325] List of 2
[17:43:51.325]  $ ...          : list()
[17:43:51.325]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:43:51.325]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[17:43:51.325]  - attr(*, "where")=List of 2
[17:43:51.325]   ..$ ...          :<environment: 0x55dfd2b0b4e0> 
[17:43:51.325]   ..$ ...future.FUN:<environment: namespace:base> 
[17:43:51.325]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:51.325]  - attr(*, "resolved")= logi FALSE
[17:43:51.325]  - attr(*, "total_size")= num NA
[17:43:51.329] Packages to be attached in all futures: [n=0] 
[17:43:51.329] getGlobalsAndPackagesXApply() ... DONE
[17:43:51.329] Number of futures (= number of chunks): 2
[17:43:51.329] Launching 2 futures (chunks) ...
[17:43:51.329] Chunk #1 of 2 ...
[17:43:51.329]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:51.329]  - seeds: [1] <seeds>
[17:43:51.329]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.330] getGlobalsAndPackages() ...
[17:43:51.330] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.330] Resolving globals: FALSE
[17:43:51.330] Tweak future expression to call with '...' arguments ...
[17:43:51.330] {
[17:43:51.330]     do.call(function(...) {
[17:43:51.330]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.330]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.330]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.330]             on.exit(options(oopts), add = TRUE)
[17:43:51.330]         }
[17:43:51.330]         {
[17:43:51.330]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.330]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.330]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:51.330]                   envir = globalenv(), inherits = FALSE)
[17:43:51.330]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.330]             })
[17:43:51.330]         }
[17:43:51.330]     }, args = future.call.arguments)
[17:43:51.330] }
[17:43:51.330] Tweak future expression to call with '...' arguments ... DONE
[17:43:51.331] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.331] 
[17:43:51.331] getGlobalsAndPackages() ... DONE
[17:43:51.331] run() for ‘Future’ ...
[17:43:51.331] - state: ‘created’
[17:43:51.331] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:51.345] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:51.345] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:51.345]   - Field: ‘node’
[17:43:51.345]   - Field: ‘label’
[17:43:51.345]   - Field: ‘local’
[17:43:51.345]   - Field: ‘owner’
[17:43:51.345]   - Field: ‘envir’
[17:43:51.345]   - Field: ‘workers’
[17:43:51.346]   - Field: ‘packages’
[17:43:51.346]   - Field: ‘gc’
[17:43:51.346]   - Field: ‘conditions’
[17:43:51.346]   - Field: ‘persistent’
[17:43:51.346]   - Field: ‘expr’
[17:43:51.346]   - Field: ‘uuid’
[17:43:51.346]   - Field: ‘seed’
[17:43:51.346]   - Field: ‘version’
[17:43:51.346]   - Field: ‘result’
[17:43:51.346]   - Field: ‘asynchronous’
[17:43:51.346]   - Field: ‘calls’
[17:43:51.347]   - Field: ‘globals’
[17:43:51.347]   - Field: ‘stdout’
[17:43:51.347]   - Field: ‘earlySignal’
[17:43:51.347]   - Field: ‘lazy’
[17:43:51.347]   - Field: ‘state’
[17:43:51.347] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:51.347] - Launch lazy future ...
[17:43:51.347] Packages needed by the future expression (n = 0): <none>
[17:43:51.348] Packages needed by future strategies (n = 0): <none>
[17:43:51.348] {
[17:43:51.348]     {
[17:43:51.348]         {
[17:43:51.348]             ...future.startTime <- base::Sys.time()
[17:43:51.348]             {
[17:43:51.348]                 {
[17:43:51.348]                   {
[17:43:51.348]                     {
[17:43:51.348]                       base::local({
[17:43:51.348]                         has_future <- base::requireNamespace("future", 
[17:43:51.348]                           quietly = TRUE)
[17:43:51.348]                         if (has_future) {
[17:43:51.348]                           ns <- base::getNamespace("future")
[17:43:51.348]                           version <- ns[[".package"]][["version"]]
[17:43:51.348]                           if (is.null(version)) 
[17:43:51.348]                             version <- utils::packageVersion("future")
[17:43:51.348]                         }
[17:43:51.348]                         else {
[17:43:51.348]                           version <- NULL
[17:43:51.348]                         }
[17:43:51.348]                         if (!has_future || version < "1.8.0") {
[17:43:51.348]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:51.348]                             "", base::R.version$version.string), 
[17:43:51.348]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:51.348]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:51.348]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:51.348]                               "release", "version")], collapse = " "), 
[17:43:51.348]                             hostname = base::Sys.info()[["nodename"]])
[17:43:51.348]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:51.348]                             info)
[17:43:51.348]                           info <- base::paste(info, collapse = "; ")
[17:43:51.348]                           if (!has_future) {
[17:43:51.348]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:51.348]                               info)
[17:43:51.348]                           }
[17:43:51.348]                           else {
[17:43:51.348]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:51.348]                               info, version)
[17:43:51.348]                           }
[17:43:51.348]                           base::stop(msg)
[17:43:51.348]                         }
[17:43:51.348]                       })
[17:43:51.348]                     }
[17:43:51.348]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:51.348]                     base::options(mc.cores = 1L)
[17:43:51.348]                   }
[17:43:51.348]                   ...future.strategy.old <- future::plan("list")
[17:43:51.348]                   options(future.plan = NULL)
[17:43:51.348]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.348]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:51.348]                 }
[17:43:51.348]                 ...future.workdir <- getwd()
[17:43:51.348]             }
[17:43:51.348]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:51.348]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:51.348]         }
[17:43:51.348]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:51.348]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:51.348]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:51.348]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:51.348]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:51.348]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:51.348]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:51.348]             base::names(...future.oldOptions))
[17:43:51.348]     }
[17:43:51.348]     if (FALSE) {
[17:43:51.348]     }
[17:43:51.348]     else {
[17:43:51.348]         if (TRUE) {
[17:43:51.348]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:51.348]                 open = "w")
[17:43:51.348]         }
[17:43:51.348]         else {
[17:43:51.348]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:51.348]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:51.348]         }
[17:43:51.348]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:51.348]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:51.348]             base::sink(type = "output", split = FALSE)
[17:43:51.348]             base::close(...future.stdout)
[17:43:51.348]         }, add = TRUE)
[17:43:51.348]     }
[17:43:51.348]     ...future.frame <- base::sys.nframe()
[17:43:51.348]     ...future.conditions <- base::list()
[17:43:51.348]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:51.348]     if (FALSE) {
[17:43:51.348]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:51.348]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:51.348]     }
[17:43:51.348]     ...future.result <- base::tryCatch({
[17:43:51.348]         base::withCallingHandlers({
[17:43:51.348]             ...future.value <- base::withVisible(base::local({
[17:43:51.348]                 ...future.makeSendCondition <- base::local({
[17:43:51.348]                   sendCondition <- NULL
[17:43:51.348]                   function(frame = 1L) {
[17:43:51.348]                     if (is.function(sendCondition)) 
[17:43:51.348]                       return(sendCondition)
[17:43:51.348]                     ns <- getNamespace("parallel")
[17:43:51.348]                     if (exists("sendData", mode = "function", 
[17:43:51.348]                       envir = ns)) {
[17:43:51.348]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:51.348]                         envir = ns)
[17:43:51.348]                       envir <- sys.frame(frame)
[17:43:51.348]                       master <- NULL
[17:43:51.348]                       while (!identical(envir, .GlobalEnv) && 
[17:43:51.348]                         !identical(envir, emptyenv())) {
[17:43:51.348]                         if (exists("master", mode = "list", envir = envir, 
[17:43:51.348]                           inherits = FALSE)) {
[17:43:51.348]                           master <- get("master", mode = "list", 
[17:43:51.348]                             envir = envir, inherits = FALSE)
[17:43:51.348]                           if (inherits(master, c("SOCKnode", 
[17:43:51.348]                             "SOCK0node"))) {
[17:43:51.348]                             sendCondition <<- function(cond) {
[17:43:51.348]                               data <- list(type = "VALUE", value = cond, 
[17:43:51.348]                                 success = TRUE)
[17:43:51.348]                               parallel_sendData(master, data)
[17:43:51.348]                             }
[17:43:51.348]                             return(sendCondition)
[17:43:51.348]                           }
[17:43:51.348]                         }
[17:43:51.348]                         frame <- frame + 1L
[17:43:51.348]                         envir <- sys.frame(frame)
[17:43:51.348]                       }
[17:43:51.348]                     }
[17:43:51.348]                     sendCondition <<- function(cond) NULL
[17:43:51.348]                   }
[17:43:51.348]                 })
[17:43:51.348]                 withCallingHandlers({
[17:43:51.348]                   {
[17:43:51.348]                     do.call(function(...) {
[17:43:51.348]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.348]                       if (!identical(...future.globals.maxSize.org, 
[17:43:51.348]                         ...future.globals.maxSize)) {
[17:43:51.348]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.348]                         on.exit(options(oopts), add = TRUE)
[17:43:51.348]                       }
[17:43:51.348]                       {
[17:43:51.348]                         lapply(seq_along(...future.elements_ii), 
[17:43:51.348]                           FUN = function(jj) {
[17:43:51.348]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.348]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:51.348]                               envir = globalenv(), inherits = FALSE)
[17:43:51.348]                             ...future.FUN(...future.X_jj, ...)
[17:43:51.348]                           })
[17:43:51.348]                       }
[17:43:51.348]                     }, args = future.call.arguments)
[17:43:51.348]                   }
[17:43:51.348]                 }, immediateCondition = function(cond) {
[17:43:51.348]                   sendCondition <- ...future.makeSendCondition()
[17:43:51.348]                   sendCondition(cond)
[17:43:51.348]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.348]                   {
[17:43:51.348]                     inherits <- base::inherits
[17:43:51.348]                     invokeRestart <- base::invokeRestart
[17:43:51.348]                     is.null <- base::is.null
[17:43:51.348]                     muffled <- FALSE
[17:43:51.348]                     if (inherits(cond, "message")) {
[17:43:51.348]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:51.348]                       if (muffled) 
[17:43:51.348]                         invokeRestart("muffleMessage")
[17:43:51.348]                     }
[17:43:51.348]                     else if (inherits(cond, "warning")) {
[17:43:51.348]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:51.348]                       if (muffled) 
[17:43:51.348]                         invokeRestart("muffleWarning")
[17:43:51.348]                     }
[17:43:51.348]                     else if (inherits(cond, "condition")) {
[17:43:51.348]                       if (!is.null(pattern)) {
[17:43:51.348]                         computeRestarts <- base::computeRestarts
[17:43:51.348]                         grepl <- base::grepl
[17:43:51.348]                         restarts <- computeRestarts(cond)
[17:43:51.348]                         for (restart in restarts) {
[17:43:51.348]                           name <- restart$name
[17:43:51.348]                           if (is.null(name)) 
[17:43:51.348]                             next
[17:43:51.348]                           if (!grepl(pattern, name)) 
[17:43:51.348]                             next
[17:43:51.348]                           invokeRestart(restart)
[17:43:51.348]                           muffled <- TRUE
[17:43:51.348]                           break
[17:43:51.348]                         }
[17:43:51.348]                       }
[17:43:51.348]                     }
[17:43:51.348]                     invisible(muffled)
[17:43:51.348]                   }
[17:43:51.348]                   muffleCondition(cond)
[17:43:51.348]                 })
[17:43:51.348]             }))
[17:43:51.348]             future::FutureResult(value = ...future.value$value, 
[17:43:51.348]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.348]                   ...future.rng), globalenv = if (FALSE) 
[17:43:51.348]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:51.348]                     ...future.globalenv.names))
[17:43:51.348]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:51.348]         }, condition = base::local({
[17:43:51.348]             c <- base::c
[17:43:51.348]             inherits <- base::inherits
[17:43:51.348]             invokeRestart <- base::invokeRestart
[17:43:51.348]             length <- base::length
[17:43:51.348]             list <- base::list
[17:43:51.348]             seq.int <- base::seq.int
[17:43:51.348]             signalCondition <- base::signalCondition
[17:43:51.348]             sys.calls <- base::sys.calls
[17:43:51.348]             `[[` <- base::`[[`
[17:43:51.348]             `+` <- base::`+`
[17:43:51.348]             `<<-` <- base::`<<-`
[17:43:51.348]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:51.348]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:51.348]                   3L)]
[17:43:51.348]             }
[17:43:51.348]             function(cond) {
[17:43:51.348]                 is_error <- inherits(cond, "error")
[17:43:51.348]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:51.348]                   NULL)
[17:43:51.348]                 if (is_error) {
[17:43:51.348]                   sessionInformation <- function() {
[17:43:51.348]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:51.348]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:51.348]                       search = base::search(), system = base::Sys.info())
[17:43:51.348]                   }
[17:43:51.348]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.348]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:51.348]                     cond$call), session = sessionInformation(), 
[17:43:51.348]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:51.348]                   signalCondition(cond)
[17:43:51.348]                 }
[17:43:51.348]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:43:51.348]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:51.348]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.348]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:51.348]                   if (TRUE && !signal) {
[17:43:51.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.348]                     {
[17:43:51.348]                       inherits <- base::inherits
[17:43:51.348]                       invokeRestart <- base::invokeRestart
[17:43:51.348]                       is.null <- base::is.null
[17:43:51.348]                       muffled <- FALSE
[17:43:51.348]                       if (inherits(cond, "message")) {
[17:43:51.348]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.348]                         if (muffled) 
[17:43:51.348]                           invokeRestart("muffleMessage")
[17:43:51.348]                       }
[17:43:51.348]                       else if (inherits(cond, "warning")) {
[17:43:51.348]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.348]                         if (muffled) 
[17:43:51.348]                           invokeRestart("muffleWarning")
[17:43:51.348]                       }
[17:43:51.348]                       else if (inherits(cond, "condition")) {
[17:43:51.348]                         if (!is.null(pattern)) {
[17:43:51.348]                           computeRestarts <- base::computeRestarts
[17:43:51.348]                           grepl <- base::grepl
[17:43:51.348]                           restarts <- computeRestarts(cond)
[17:43:51.348]                           for (restart in restarts) {
[17:43:51.348]                             name <- restart$name
[17:43:51.348]                             if (is.null(name)) 
[17:43:51.348]                               next
[17:43:51.348]                             if (!grepl(pattern, name)) 
[17:43:51.348]                               next
[17:43:51.348]                             invokeRestart(restart)
[17:43:51.348]                             muffled <- TRUE
[17:43:51.348]                             break
[17:43:51.348]                           }
[17:43:51.348]                         }
[17:43:51.348]                       }
[17:43:51.348]                       invisible(muffled)
[17:43:51.348]                     }
[17:43:51.348]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.348]                   }
[17:43:51.348]                 }
[17:43:51.348]                 else {
[17:43:51.348]                   if (TRUE) {
[17:43:51.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.348]                     {
[17:43:51.348]                       inherits <- base::inherits
[17:43:51.348]                       invokeRestart <- base::invokeRestart
[17:43:51.348]                       is.null <- base::is.null
[17:43:51.348]                       muffled <- FALSE
[17:43:51.348]                       if (inherits(cond, "message")) {
[17:43:51.348]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.348]                         if (muffled) 
[17:43:51.348]                           invokeRestart("muffleMessage")
[17:43:51.348]                       }
[17:43:51.348]                       else if (inherits(cond, "warning")) {
[17:43:51.348]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.348]                         if (muffled) 
[17:43:51.348]                           invokeRestart("muffleWarning")
[17:43:51.348]                       }
[17:43:51.348]                       else if (inherits(cond, "condition")) {
[17:43:51.348]                         if (!is.null(pattern)) {
[17:43:51.348]                           computeRestarts <- base::computeRestarts
[17:43:51.348]                           grepl <- base::grepl
[17:43:51.348]                           restarts <- computeRestarts(cond)
[17:43:51.348]                           for (restart in restarts) {
[17:43:51.348]                             name <- restart$name
[17:43:51.348]                             if (is.null(name)) 
[17:43:51.348]                               next
[17:43:51.348]                             if (!grepl(pattern, name)) 
[17:43:51.348]                               next
[17:43:51.348]                             invokeRestart(restart)
[17:43:51.348]                             muffled <- TRUE
[17:43:51.348]                             break
[17:43:51.348]                           }
[17:43:51.348]                         }
[17:43:51.348]                       }
[17:43:51.348]                       invisible(muffled)
[17:43:51.348]                     }
[17:43:51.348]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.348]                   }
[17:43:51.348]                 }
[17:43:51.348]             }
[17:43:51.348]         }))
[17:43:51.348]     }, error = function(ex) {
[17:43:51.348]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:51.348]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.348]                 ...future.rng), started = ...future.startTime, 
[17:43:51.348]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:51.348]             version = "1.8"), class = "FutureResult")
[17:43:51.348]     }, finally = {
[17:43:51.348]         if (!identical(...future.workdir, getwd())) 
[17:43:51.348]             setwd(...future.workdir)
[17:43:51.348]         {
[17:43:51.348]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:51.348]                 ...future.oldOptions$nwarnings <- NULL
[17:43:51.348]             }
[17:43:51.348]             base::options(...future.oldOptions)
[17:43:51.348]             if (.Platform$OS.type == "windows") {
[17:43:51.348]                 old_names <- names(...future.oldEnvVars)
[17:43:51.348]                 envs <- base::Sys.getenv()
[17:43:51.348]                 names <- names(envs)
[17:43:51.348]                 common <- intersect(names, old_names)
[17:43:51.348]                 added <- setdiff(names, old_names)
[17:43:51.348]                 removed <- setdiff(old_names, names)
[17:43:51.348]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:51.348]                   envs[common]]
[17:43:51.348]                 NAMES <- toupper(changed)
[17:43:51.348]                 args <- list()
[17:43:51.348]                 for (kk in seq_along(NAMES)) {
[17:43:51.348]                   name <- changed[[kk]]
[17:43:51.348]                   NAME <- NAMES[[kk]]
[17:43:51.348]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.348]                     next
[17:43:51.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.348]                 }
[17:43:51.348]                 NAMES <- toupper(added)
[17:43:51.348]                 for (kk in seq_along(NAMES)) {
[17:43:51.348]                   name <- added[[kk]]
[17:43:51.348]                   NAME <- NAMES[[kk]]
[17:43:51.348]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.348]                     next
[17:43:51.348]                   args[[name]] <- ""
[17:43:51.348]                 }
[17:43:51.348]                 NAMES <- toupper(removed)
[17:43:51.348]                 for (kk in seq_along(NAMES)) {
[17:43:51.348]                   name <- removed[[kk]]
[17:43:51.348]                   NAME <- NAMES[[kk]]
[17:43:51.348]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.348]                     next
[17:43:51.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.348]                 }
[17:43:51.348]                 if (length(args) > 0) 
[17:43:51.348]                   base::do.call(base::Sys.setenv, args = args)
[17:43:51.348]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:51.348]             }
[17:43:51.348]             else {
[17:43:51.348]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:51.348]             }
[17:43:51.348]             {
[17:43:51.348]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:51.348]                   0L) {
[17:43:51.348]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:51.348]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:51.348]                   base::options(opts)
[17:43:51.348]                 }
[17:43:51.348]                 {
[17:43:51.348]                   {
[17:43:51.348]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:51.348]                     NULL
[17:43:51.348]                   }
[17:43:51.348]                   options(future.plan = NULL)
[17:43:51.348]                   if (is.na(NA_character_)) 
[17:43:51.348]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.348]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:51.348]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:51.348]                     .init = FALSE)
[17:43:51.348]                 }
[17:43:51.348]             }
[17:43:51.348]         }
[17:43:51.348]     })
[17:43:51.348]     if (TRUE) {
[17:43:51.348]         base::sink(type = "output", split = FALSE)
[17:43:51.348]         if (TRUE) {
[17:43:51.348]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:51.348]         }
[17:43:51.348]         else {
[17:43:51.348]             ...future.result["stdout"] <- base::list(NULL)
[17:43:51.348]         }
[17:43:51.348]         base::close(...future.stdout)
[17:43:51.348]         ...future.stdout <- NULL
[17:43:51.348]     }
[17:43:51.348]     ...future.result$conditions <- ...future.conditions
[17:43:51.348]     ...future.result$finished <- base::Sys.time()
[17:43:51.348]     ...future.result
[17:43:51.348] }
[17:43:51.351] Exporting 5 global objects (35.63 KiB) to cluster node #1 ...
[17:43:51.351] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:43:51.352] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:43:51.352] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[17:43:51.396] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[17:43:51.396] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:43:51.396] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:43:51.396] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[17:43:51.397] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[17:43:51.397] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[17:43:51.397] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[17:43:51.397] Exporting 5 global objects (35.63 KiB) to cluster node #1 ... DONE
[17:43:51.398] MultisessionFuture started
[17:43:51.398] - Launch lazy future ... done
[17:43:51.398] run() for ‘MultisessionFuture’ ... done
[17:43:51.398] Created future:
[17:43:51.399] MultisessionFuture:
[17:43:51.399] Label: ‘future_apply-1’
[17:43:51.399] Expression:
[17:43:51.399] {
[17:43:51.399]     do.call(function(...) {
[17:43:51.399]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.399]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.399]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.399]             on.exit(options(oopts), add = TRUE)
[17:43:51.399]         }
[17:43:51.399]         {
[17:43:51.399]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.399]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.399]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:51.399]                   envir = globalenv(), inherits = FALSE)
[17:43:51.399]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.399]             })
[17:43:51.399]         }
[17:43:51.399]     }, args = future.call.arguments)
[17:43:51.399] }
[17:43:51.399] Lazy evaluation: FALSE
[17:43:51.399] Asynchronous evaluation: TRUE
[17:43:51.399] Local evaluation: TRUE
[17:43:51.399] Environment: R_GlobalEnv
[17:43:51.399] Capture standard output: TRUE
[17:43:51.399] Capture condition classes: <none>
[17:43:51.399] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:51.399] Packages: <none>
[17:43:51.399] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:43:51.399] Resolved: FALSE
[17:43:51.399] Value: <not collected>
[17:43:51.399] Conditions captured: <none>
[17:43:51.399] Early signaling: FALSE
[17:43:51.399] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:51.399] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:51.410] Chunk #1 of 2 ... DONE
[17:43:51.410] Chunk #2 of 2 ...
[17:43:51.410]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[17:43:51.411]  - seeds: [1] <seeds>
[17:43:51.411]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.411] getGlobalsAndPackages() ...
[17:43:51.411] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.411] Resolving globals: FALSE
[17:43:51.411] Tweak future expression to call with '...' arguments ...
[17:43:51.411] {
[17:43:51.411]     do.call(function(...) {
[17:43:51.411]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.411]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.411]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.411]             on.exit(options(oopts), add = TRUE)
[17:43:51.411]         }
[17:43:51.411]         {
[17:43:51.411]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.411]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.411]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:51.411]                   envir = globalenv(), inherits = FALSE)
[17:43:51.411]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.411]             })
[17:43:51.411]         }
[17:43:51.411]     }, args = future.call.arguments)
[17:43:51.411] }
[17:43:51.412] Tweak future expression to call with '...' arguments ... DONE
[17:43:51.412] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:43:51.412] 
[17:43:51.412] getGlobalsAndPackages() ... DONE
[17:43:51.413] run() for ‘Future’ ...
[17:43:51.413] - state: ‘created’
[17:43:51.413] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:51.427] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:51.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:51.427]   - Field: ‘node’
[17:43:51.427]   - Field: ‘label’
[17:43:51.427]   - Field: ‘local’
[17:43:51.427]   - Field: ‘owner’
[17:43:51.427]   - Field: ‘envir’
[17:43:51.428]   - Field: ‘workers’
[17:43:51.428]   - Field: ‘packages’
[17:43:51.428]   - Field: ‘gc’
[17:43:51.428]   - Field: ‘conditions’
[17:43:51.428]   - Field: ‘persistent’
[17:43:51.428]   - Field: ‘expr’
[17:43:51.428]   - Field: ‘uuid’
[17:43:51.428]   - Field: ‘seed’
[17:43:51.428]   - Field: ‘version’
[17:43:51.428]   - Field: ‘result’
[17:43:51.428]   - Field: ‘asynchronous’
[17:43:51.428]   - Field: ‘calls’
[17:43:51.429]   - Field: ‘globals’
[17:43:51.429]   - Field: ‘stdout’
[17:43:51.429]   - Field: ‘earlySignal’
[17:43:51.429]   - Field: ‘lazy’
[17:43:51.429]   - Field: ‘state’
[17:43:51.429] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:51.429] - Launch lazy future ...
[17:43:51.429] Packages needed by the future expression (n = 0): <none>
[17:43:51.430] Packages needed by future strategies (n = 0): <none>
[17:43:51.430] {
[17:43:51.430]     {
[17:43:51.430]         {
[17:43:51.430]             ...future.startTime <- base::Sys.time()
[17:43:51.430]             {
[17:43:51.430]                 {
[17:43:51.430]                   {
[17:43:51.430]                     {
[17:43:51.430]                       base::local({
[17:43:51.430]                         has_future <- base::requireNamespace("future", 
[17:43:51.430]                           quietly = TRUE)
[17:43:51.430]                         if (has_future) {
[17:43:51.430]                           ns <- base::getNamespace("future")
[17:43:51.430]                           version <- ns[[".package"]][["version"]]
[17:43:51.430]                           if (is.null(version)) 
[17:43:51.430]                             version <- utils::packageVersion("future")
[17:43:51.430]                         }
[17:43:51.430]                         else {
[17:43:51.430]                           version <- NULL
[17:43:51.430]                         }
[17:43:51.430]                         if (!has_future || version < "1.8.0") {
[17:43:51.430]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:51.430]                             "", base::R.version$version.string), 
[17:43:51.430]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:51.430]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:51.430]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:51.430]                               "release", "version")], collapse = " "), 
[17:43:51.430]                             hostname = base::Sys.info()[["nodename"]])
[17:43:51.430]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:51.430]                             info)
[17:43:51.430]                           info <- base::paste(info, collapse = "; ")
[17:43:51.430]                           if (!has_future) {
[17:43:51.430]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:51.430]                               info)
[17:43:51.430]                           }
[17:43:51.430]                           else {
[17:43:51.430]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:51.430]                               info, version)
[17:43:51.430]                           }
[17:43:51.430]                           base::stop(msg)
[17:43:51.430]                         }
[17:43:51.430]                       })
[17:43:51.430]                     }
[17:43:51.430]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:51.430]                     base::options(mc.cores = 1L)
[17:43:51.430]                   }
[17:43:51.430]                   ...future.strategy.old <- future::plan("list")
[17:43:51.430]                   options(future.plan = NULL)
[17:43:51.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:51.430]                 }
[17:43:51.430]                 ...future.workdir <- getwd()
[17:43:51.430]             }
[17:43:51.430]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:51.430]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:51.430]         }
[17:43:51.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:51.430]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[17:43:51.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:51.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:51.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:51.430]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:51.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:51.430]             base::names(...future.oldOptions))
[17:43:51.430]     }
[17:43:51.430]     if (FALSE) {
[17:43:51.430]     }
[17:43:51.430]     else {
[17:43:51.430]         if (TRUE) {
[17:43:51.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:51.430]                 open = "w")
[17:43:51.430]         }
[17:43:51.430]         else {
[17:43:51.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:51.430]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:51.430]         }
[17:43:51.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:51.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:51.430]             base::sink(type = "output", split = FALSE)
[17:43:51.430]             base::close(...future.stdout)
[17:43:51.430]         }, add = TRUE)
[17:43:51.430]     }
[17:43:51.430]     ...future.frame <- base::sys.nframe()
[17:43:51.430]     ...future.conditions <- base::list()
[17:43:51.430]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:51.430]     if (FALSE) {
[17:43:51.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:51.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:51.430]     }
[17:43:51.430]     ...future.result <- base::tryCatch({
[17:43:51.430]         base::withCallingHandlers({
[17:43:51.430]             ...future.value <- base::withVisible(base::local({
[17:43:51.430]                 ...future.makeSendCondition <- base::local({
[17:43:51.430]                   sendCondition <- NULL
[17:43:51.430]                   function(frame = 1L) {
[17:43:51.430]                     if (is.function(sendCondition)) 
[17:43:51.430]                       return(sendCondition)
[17:43:51.430]                     ns <- getNamespace("parallel")
[17:43:51.430]                     if (exists("sendData", mode = "function", 
[17:43:51.430]                       envir = ns)) {
[17:43:51.430]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:51.430]                         envir = ns)
[17:43:51.430]                       envir <- sys.frame(frame)
[17:43:51.430]                       master <- NULL
[17:43:51.430]                       while (!identical(envir, .GlobalEnv) && 
[17:43:51.430]                         !identical(envir, emptyenv())) {
[17:43:51.430]                         if (exists("master", mode = "list", envir = envir, 
[17:43:51.430]                           inherits = FALSE)) {
[17:43:51.430]                           master <- get("master", mode = "list", 
[17:43:51.430]                             envir = envir, inherits = FALSE)
[17:43:51.430]                           if (inherits(master, c("SOCKnode", 
[17:43:51.430]                             "SOCK0node"))) {
[17:43:51.430]                             sendCondition <<- function(cond) {
[17:43:51.430]                               data <- list(type = "VALUE", value = cond, 
[17:43:51.430]                                 success = TRUE)
[17:43:51.430]                               parallel_sendData(master, data)
[17:43:51.430]                             }
[17:43:51.430]                             return(sendCondition)
[17:43:51.430]                           }
[17:43:51.430]                         }
[17:43:51.430]                         frame <- frame + 1L
[17:43:51.430]                         envir <- sys.frame(frame)
[17:43:51.430]                       }
[17:43:51.430]                     }
[17:43:51.430]                     sendCondition <<- function(cond) NULL
[17:43:51.430]                   }
[17:43:51.430]                 })
[17:43:51.430]                 withCallingHandlers({
[17:43:51.430]                   {
[17:43:51.430]                     do.call(function(...) {
[17:43:51.430]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.430]                       if (!identical(...future.globals.maxSize.org, 
[17:43:51.430]                         ...future.globals.maxSize)) {
[17:43:51.430]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.430]                         on.exit(options(oopts), add = TRUE)
[17:43:51.430]                       }
[17:43:51.430]                       {
[17:43:51.430]                         lapply(seq_along(...future.elements_ii), 
[17:43:51.430]                           FUN = function(jj) {
[17:43:51.430]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.430]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:51.430]                               envir = globalenv(), inherits = FALSE)
[17:43:51.430]                             ...future.FUN(...future.X_jj, ...)
[17:43:51.430]                           })
[17:43:51.430]                       }
[17:43:51.430]                     }, args = future.call.arguments)
[17:43:51.430]                   }
[17:43:51.430]                 }, immediateCondition = function(cond) {
[17:43:51.430]                   sendCondition <- ...future.makeSendCondition()
[17:43:51.430]                   sendCondition(cond)
[17:43:51.430]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.430]                   {
[17:43:51.430]                     inherits <- base::inherits
[17:43:51.430]                     invokeRestart <- base::invokeRestart
[17:43:51.430]                     is.null <- base::is.null
[17:43:51.430]                     muffled <- FALSE
[17:43:51.430]                     if (inherits(cond, "message")) {
[17:43:51.430]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:51.430]                       if (muffled) 
[17:43:51.430]                         invokeRestart("muffleMessage")
[17:43:51.430]                     }
[17:43:51.430]                     else if (inherits(cond, "warning")) {
[17:43:51.430]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:51.430]                       if (muffled) 
[17:43:51.430]                         invokeRestart("muffleWarning")
[17:43:51.430]                     }
[17:43:51.430]                     else if (inherits(cond, "condition")) {
[17:43:51.430]                       if (!is.null(pattern)) {
[17:43:51.430]                         computeRestarts <- base::computeRestarts
[17:43:51.430]                         grepl <- base::grepl
[17:43:51.430]                         restarts <- computeRestarts(cond)
[17:43:51.430]                         for (restart in restarts) {
[17:43:51.430]                           name <- restart$name
[17:43:51.430]                           if (is.null(name)) 
[17:43:51.430]                             next
[17:43:51.430]                           if (!grepl(pattern, name)) 
[17:43:51.430]                             next
[17:43:51.430]                           invokeRestart(restart)
[17:43:51.430]                           muffled <- TRUE
[17:43:51.430]                           break
[17:43:51.430]                         }
[17:43:51.430]                       }
[17:43:51.430]                     }
[17:43:51.430]                     invisible(muffled)
[17:43:51.430]                   }
[17:43:51.430]                   muffleCondition(cond)
[17:43:51.430]                 })
[17:43:51.430]             }))
[17:43:51.430]             future::FutureResult(value = ...future.value$value, 
[17:43:51.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.430]                   ...future.rng), globalenv = if (FALSE) 
[17:43:51.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:51.430]                     ...future.globalenv.names))
[17:43:51.430]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:51.430]         }, condition = base::local({
[17:43:51.430]             c <- base::c
[17:43:51.430]             inherits <- base::inherits
[17:43:51.430]             invokeRestart <- base::invokeRestart
[17:43:51.430]             length <- base::length
[17:43:51.430]             list <- base::list
[17:43:51.430]             seq.int <- base::seq.int
[17:43:51.430]             signalCondition <- base::signalCondition
[17:43:51.430]             sys.calls <- base::sys.calls
[17:43:51.430]             `[[` <- base::`[[`
[17:43:51.430]             `+` <- base::`+`
[17:43:51.430]             `<<-` <- base::`<<-`
[17:43:51.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:51.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:51.430]                   3L)]
[17:43:51.430]             }
[17:43:51.430]             function(cond) {
[17:43:51.430]                 is_error <- inherits(cond, "error")
[17:43:51.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:51.430]                   NULL)
[17:43:51.430]                 if (is_error) {
[17:43:51.430]                   sessionInformation <- function() {
[17:43:51.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:51.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:51.430]                       search = base::search(), system = base::Sys.info())
[17:43:51.430]                   }
[17:43:51.430]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:51.430]                     cond$call), session = sessionInformation(), 
[17:43:51.430]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:51.430]                   signalCondition(cond)
[17:43:51.430]                 }
[17:43:51.430]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[17:43:51.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:51.430]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:51.430]                   if (TRUE && !signal) {
[17:43:51.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.430]                     {
[17:43:51.430]                       inherits <- base::inherits
[17:43:51.430]                       invokeRestart <- base::invokeRestart
[17:43:51.430]                       is.null <- base::is.null
[17:43:51.430]                       muffled <- FALSE
[17:43:51.430]                       if (inherits(cond, "message")) {
[17:43:51.430]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.430]                         if (muffled) 
[17:43:51.430]                           invokeRestart("muffleMessage")
[17:43:51.430]                       }
[17:43:51.430]                       else if (inherits(cond, "warning")) {
[17:43:51.430]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.430]                         if (muffled) 
[17:43:51.430]                           invokeRestart("muffleWarning")
[17:43:51.430]                       }
[17:43:51.430]                       else if (inherits(cond, "condition")) {
[17:43:51.430]                         if (!is.null(pattern)) {
[17:43:51.430]                           computeRestarts <- base::computeRestarts
[17:43:51.430]                           grepl <- base::grepl
[17:43:51.430]                           restarts <- computeRestarts(cond)
[17:43:51.430]                           for (restart in restarts) {
[17:43:51.430]                             name <- restart$name
[17:43:51.430]                             if (is.null(name)) 
[17:43:51.430]                               next
[17:43:51.430]                             if (!grepl(pattern, name)) 
[17:43:51.430]                               next
[17:43:51.430]                             invokeRestart(restart)
[17:43:51.430]                             muffled <- TRUE
[17:43:51.430]                             break
[17:43:51.430]                           }
[17:43:51.430]                         }
[17:43:51.430]                       }
[17:43:51.430]                       invisible(muffled)
[17:43:51.430]                     }
[17:43:51.430]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.430]                   }
[17:43:51.430]                 }
[17:43:51.430]                 else {
[17:43:51.430]                   if (TRUE) {
[17:43:51.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.430]                     {
[17:43:51.430]                       inherits <- base::inherits
[17:43:51.430]                       invokeRestart <- base::invokeRestart
[17:43:51.430]                       is.null <- base::is.null
[17:43:51.430]                       muffled <- FALSE
[17:43:51.430]                       if (inherits(cond, "message")) {
[17:43:51.430]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.430]                         if (muffled) 
[17:43:51.430]                           invokeRestart("muffleMessage")
[17:43:51.430]                       }
[17:43:51.430]                       else if (inherits(cond, "warning")) {
[17:43:51.430]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.430]                         if (muffled) 
[17:43:51.430]                           invokeRestart("muffleWarning")
[17:43:51.430]                       }
[17:43:51.430]                       else if (inherits(cond, "condition")) {
[17:43:51.430]                         if (!is.null(pattern)) {
[17:43:51.430]                           computeRestarts <- base::computeRestarts
[17:43:51.430]                           grepl <- base::grepl
[17:43:51.430]                           restarts <- computeRestarts(cond)
[17:43:51.430]                           for (restart in restarts) {
[17:43:51.430]                             name <- restart$name
[17:43:51.430]                             if (is.null(name)) 
[17:43:51.430]                               next
[17:43:51.430]                             if (!grepl(pattern, name)) 
[17:43:51.430]                               next
[17:43:51.430]                             invokeRestart(restart)
[17:43:51.430]                             muffled <- TRUE
[17:43:51.430]                             break
[17:43:51.430]                           }
[17:43:51.430]                         }
[17:43:51.430]                       }
[17:43:51.430]                       invisible(muffled)
[17:43:51.430]                     }
[17:43:51.430]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.430]                   }
[17:43:51.430]                 }
[17:43:51.430]             }
[17:43:51.430]         }))
[17:43:51.430]     }, error = function(ex) {
[17:43:51.430]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:51.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.430]                 ...future.rng), started = ...future.startTime, 
[17:43:51.430]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:51.430]             version = "1.8"), class = "FutureResult")
[17:43:51.430]     }, finally = {
[17:43:51.430]         if (!identical(...future.workdir, getwd())) 
[17:43:51.430]             setwd(...future.workdir)
[17:43:51.430]         {
[17:43:51.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:51.430]                 ...future.oldOptions$nwarnings <- NULL
[17:43:51.430]             }
[17:43:51.430]             base::options(...future.oldOptions)
[17:43:51.430]             if (.Platform$OS.type == "windows") {
[17:43:51.430]                 old_names <- names(...future.oldEnvVars)
[17:43:51.430]                 envs <- base::Sys.getenv()
[17:43:51.430]                 names <- names(envs)
[17:43:51.430]                 common <- intersect(names, old_names)
[17:43:51.430]                 added <- setdiff(names, old_names)
[17:43:51.430]                 removed <- setdiff(old_names, names)
[17:43:51.430]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:51.430]                   envs[common]]
[17:43:51.430]                 NAMES <- toupper(changed)
[17:43:51.430]                 args <- list()
[17:43:51.430]                 for (kk in seq_along(NAMES)) {
[17:43:51.430]                   name <- changed[[kk]]
[17:43:51.430]                   NAME <- NAMES[[kk]]
[17:43:51.430]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.430]                     next
[17:43:51.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.430]                 }
[17:43:51.430]                 NAMES <- toupper(added)
[17:43:51.430]                 for (kk in seq_along(NAMES)) {
[17:43:51.430]                   name <- added[[kk]]
[17:43:51.430]                   NAME <- NAMES[[kk]]
[17:43:51.430]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.430]                     next
[17:43:51.430]                   args[[name]] <- ""
[17:43:51.430]                 }
[17:43:51.430]                 NAMES <- toupper(removed)
[17:43:51.430]                 for (kk in seq_along(NAMES)) {
[17:43:51.430]                   name <- removed[[kk]]
[17:43:51.430]                   NAME <- NAMES[[kk]]
[17:43:51.430]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.430]                     next
[17:43:51.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.430]                 }
[17:43:51.430]                 if (length(args) > 0) 
[17:43:51.430]                   base::do.call(base::Sys.setenv, args = args)
[17:43:51.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:51.430]             }
[17:43:51.430]             else {
[17:43:51.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:51.430]             }
[17:43:51.430]             {
[17:43:51.430]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:51.430]                   0L) {
[17:43:51.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:51.430]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:51.430]                   base::options(opts)
[17:43:51.430]                 }
[17:43:51.430]                 {
[17:43:51.430]                   {
[17:43:51.430]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:51.430]                     NULL
[17:43:51.430]                   }
[17:43:51.430]                   options(future.plan = NULL)
[17:43:51.430]                   if (is.na(NA_character_)) 
[17:43:51.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:51.430]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:43:51.430]                     .init = FALSE)
[17:43:51.430]                 }
[17:43:51.430]             }
[17:43:51.430]         }
[17:43:51.430]     })
[17:43:51.430]     if (TRUE) {
[17:43:51.430]         base::sink(type = "output", split = FALSE)
[17:43:51.430]         if (TRUE) {
[17:43:51.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:51.430]         }
[17:43:51.430]         else {
[17:43:51.430]             ...future.result["stdout"] <- base::list(NULL)
[17:43:51.430]         }
[17:43:51.430]         base::close(...future.stdout)
[17:43:51.430]         ...future.stdout <- NULL
[17:43:51.430]     }
[17:43:51.430]     ...future.result$conditions <- ...future.conditions
[17:43:51.430]     ...future.result$finished <- base::Sys.time()
[17:43:51.430]     ...future.result
[17:43:51.430] }
[17:43:51.433] Exporting 5 global objects (35.63 KiB) to cluster node #2 ...
[17:43:51.433] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:43:51.433] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:43:51.434] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ...
[17:43:51.476] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #2 ... DONE
[17:43:51.476] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:43:51.476] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:43:51.476] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[17:43:51.477] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[17:43:51.477] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[17:43:51.477] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[17:43:51.477] Exporting 5 global objects (35.63 KiB) to cluster node #2 ... DONE
[17:43:51.478] MultisessionFuture started
[17:43:51.478] - Launch lazy future ... done
[17:43:51.478] run() for ‘MultisessionFuture’ ... done
[17:43:51.478] Created future:
[17:43:51.478] MultisessionFuture:
[17:43:51.478] Label: ‘future_apply-2’
[17:43:51.478] Expression:
[17:43:51.478] {
[17:43:51.478]     do.call(function(...) {
[17:43:51.478]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:43:51.478]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:43:51.478]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:43:51.478]             on.exit(options(oopts), add = TRUE)
[17:43:51.478]         }
[17:43:51.478]         {
[17:43:51.478]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:43:51.478]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:43:51.478]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[17:43:51.478]                   envir = globalenv(), inherits = FALSE)
[17:43:51.478]                 ...future.FUN(...future.X_jj, ...)
[17:43:51.478]             })
[17:43:51.478]         }
[17:43:51.478]     }, args = future.call.arguments)
[17:43:51.478] }
[17:43:51.478] Lazy evaluation: FALSE
[17:43:51.478] Asynchronous evaluation: TRUE
[17:43:51.478] Local evaluation: TRUE
[17:43:51.478] Environment: R_GlobalEnv
[17:43:51.478] Capture standard output: TRUE
[17:43:51.478] Capture condition classes: <none>
[17:43:51.478] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[17:43:51.478] Packages: <none>
[17:43:51.478] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:43:51.478] Resolved: FALSE
[17:43:51.478] Value: <not collected>
[17:43:51.478] Conditions captured: <none>
[17:43:51.478] Early signaling: FALSE
[17:43:51.478] Owner process: 9ccf49ab-f446-e78a-17af-0926c6fa2048
[17:43:51.478] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:51.489] Chunk #2 of 2 ... DONE
[17:43:51.490] Launching 2 futures (chunks) ... DONE
[17:43:51.490] Resolving 2 futures (chunks) ...
[17:43:51.490] resolve() on list ...
[17:43:51.490]  recursive: 0
[17:43:51.490]  length: 2
[17:43:51.490] 
[17:43:51.491] receiveMessageFromWorker() for ClusterFuture ...
[17:43:51.491] - Validating connection of MultisessionFuture
[17:43:51.491] - received message: FutureResult
[17:43:51.491] - Received FutureResult
[17:43:51.491] - Erased future from FutureRegistry
[17:43:51.491] result() for ClusterFuture ...
[17:43:51.491] - result already collected: FutureResult
[17:43:51.491] result() for ClusterFuture ... done
[17:43:51.491] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:51.492] Future #1
[17:43:51.492] result() for ClusterFuture ...
[17:43:51.492] - result already collected: FutureResult
[17:43:51.492] result() for ClusterFuture ... done
[17:43:51.492] result() for ClusterFuture ...
[17:43:51.492] - result already collected: FutureResult
[17:43:51.492] result() for ClusterFuture ... done
[17:43:51.492] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:43:51.492] - nx: 2
[17:43:51.492] - relay: TRUE
[17:43:51.492] - stdout: TRUE
[17:43:51.492] - signal: TRUE
[17:43:51.493] - resignal: FALSE
[17:43:51.493] - force: TRUE
[17:43:51.493] - relayed: [n=2] FALSE, FALSE
[17:43:51.493] - queued futures: [n=2] FALSE, FALSE
[17:43:51.493]  - until=1
[17:43:51.493]  - relaying element #1
[17:43:51.493] result() for ClusterFuture ...
[17:43:51.493] - result already collected: FutureResult
[17:43:51.493] result() for ClusterFuture ... done
[17:43:51.493] result() for ClusterFuture ...
[17:43:51.493] - result already collected: FutureResult
[17:43:51.494] result() for ClusterFuture ... done
[17:43:51.494] result() for ClusterFuture ...
[17:43:51.494] - result already collected: FutureResult
[17:43:51.494] result() for ClusterFuture ... done
[17:43:51.494] result() for ClusterFuture ...
[17:43:51.494] - result already collected: FutureResult
[17:43:51.494] result() for ClusterFuture ... done
[17:43:51.494] - relayed: [n=2] TRUE, FALSE
[17:43:51.494] - queued futures: [n=2] TRUE, FALSE
[17:43:51.494] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:43:51.494]  length: 1 (resolved future 1)
[17:43:51.521] receiveMessageFromWorker() for ClusterFuture ...
[17:43:51.521] - Validating connection of MultisessionFuture
[17:43:51.521] - received message: FutureResult
[17:43:51.521] - Received FutureResult
[17:43:51.521] - Erased future from FutureRegistry
[17:43:51.521] result() for ClusterFuture ...
[17:43:51.522] - result already collected: FutureResult
[17:43:51.522] result() for ClusterFuture ... done
[17:43:51.522] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:51.522] Future #2
[17:43:51.522] result() for ClusterFuture ...
[17:43:51.522] - result already collected: FutureResult
[17:43:51.522] result() for ClusterFuture ... done
[17:43:51.522] result() for ClusterFuture ...
[17:43:51.522] - result already collected: FutureResult
[17:43:51.522] result() for ClusterFuture ... done
[17:43:51.522] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:43:51.522] - nx: 2
[17:43:51.523] - relay: TRUE
[17:43:51.523] - stdout: TRUE
[17:43:51.523] - signal: TRUE
[17:43:51.523] - resignal: FALSE
[17:43:51.523] - force: TRUE
[17:43:51.523] - relayed: [n=2] TRUE, FALSE
[17:43:51.525] - queued futures: [n=2] TRUE, FALSE
[17:43:51.525]  - until=2
[17:43:51.526]  - relaying element #2
[17:43:51.526] result() for ClusterFuture ...
[17:43:51.526] - result already collected: FutureResult
[17:43:51.526] result() for ClusterFuture ... done
[17:43:51.526] result() for ClusterFuture ...
[17:43:51.526] - result already collected: FutureResult
[17:43:51.526] result() for ClusterFuture ... done
[17:43:51.526] result() for ClusterFuture ...
[17:43:51.526] - result already collected: FutureResult
[17:43:51.526] result() for ClusterFuture ... done
[17:43:51.526] result() for ClusterFuture ...
[17:43:51.526] - result already collected: FutureResult
[17:43:51.527] result() for ClusterFuture ... done
[17:43:51.527] - relayed: [n=2] TRUE, TRUE
[17:43:51.527] - queued futures: [n=2] TRUE, TRUE
[17:43:51.527] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:43:51.527]  length: 0 (resolved future 2)
[17:43:51.527] Relaying remaining futures
[17:43:51.527] signalConditionsASAP(NULL, pos=0) ...
[17:43:51.527] - nx: 2
[17:43:51.527] - relay: TRUE
[17:43:51.527] - stdout: TRUE
[17:43:51.527] - signal: TRUE
[17:43:51.527] - resignal: FALSE
[17:43:51.528] - force: TRUE
[17:43:51.528] - relayed: [n=2] TRUE, TRUE
[17:43:51.528] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:43:51.528] - relayed: [n=2] TRUE, TRUE
[17:43:51.528] - queued futures: [n=2] TRUE, TRUE
[17:43:51.528] signalConditionsASAP(NULL, pos=0) ... done
[17:43:51.528] resolve() on list ... DONE
[17:43:51.528] result() for ClusterFuture ...
[17:43:51.528] - result already collected: FutureResult
[17:43:51.528] result() for ClusterFuture ... done
[17:43:51.528] result() for ClusterFuture ...
[17:43:51.529] - result already collected: FutureResult
[17:43:51.529] result() for ClusterFuture ... done
[17:43:51.529] result() for ClusterFuture ...
[17:43:51.529] - result already collected: FutureResult
[17:43:51.529] result() for ClusterFuture ... done
[17:43:51.529] result() for ClusterFuture ...
[17:43:51.529] - result already collected: FutureResult
[17:43:51.529] result() for ClusterFuture ... done
[17:43:51.529]  - Number of value chunks collected: 2
[17:43:51.529] Resolving 2 futures (chunks) ... DONE
[17:43:51.529] Reducing values from 2 chunks ...
[17:43:51.529]  - Number of values collected after concatenation: 2
[17:43:51.530]  - Number of values expected: 2
[17:43:51.530] Reducing values from 2 chunks ... DONE
[17:43:51.530] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[17:43:51.530] plan(): Setting new future strategy stack:
[17:43:51.530] List of future strategies:
[17:43:51.530] 1. sequential:
[17:43:51.530]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:51.530]    - tweaked: FALSE
[17:43:51.530]    - call: plan(sequential)
[17:43:51.531] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[17:43:51.533] plan(): Setting new future strategy stack:
[17:43:51.533] List of future strategies:
[17:43:51.533] 1. FutureStrategy:
[17:43:51.533]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:43:51.533]    - tweaked: FALSE
[17:43:51.533]    - call: future::plan(oplan)
[17:43:51.534] plan(): nbrOfWorkers() = 1
> 
